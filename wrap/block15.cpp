
/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaTechLayerHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaTechLayerHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaTechLayerHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaTechLayerHeaderObject* self = (PyoaDataAppDef_oaTechLayerHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaTechLayerHeader)
    {
        PyParamoaDataAppDef_oaTechLayerHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaTechLayerHeader_Convert,&p1)) {
            PyoaDataAppDef_oaTechLayerHeaderObject* cself=((PyoaDataAppDef_oaTechLayerHeaderObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaTechLayerHeader, Choices are:\n"
        "    (oaDataAppDef_oaTechLayerHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaTechLayerHeader_tp_dealloc(PyoaDataAppDef_oaTechLayerHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaTechLayerHeader_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaTechLayerHeader value;
    int convert_status=PyoaDataAppDef_oaTechLayerHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[52];
    sprintf(buffer,"<oaDataAppDef_oaTechLayerHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaTechLayerHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaTechLayerHeader v1;
    PyParamoaDataAppDef_oaTechLayerHeader v2;
    int convert_status1=PyoaDataAppDef_oaTechLayerHeader_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaTechLayerHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaTechLayerHeader_Convert(PyObject* ob,PyParamoaDataAppDef_oaTechLayerHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaTechLayerHeader_Check(ob)) {
        result->SetData( (oaDataAppDef_oaTechLayerHeader**) ((PyoaDataAppDef_oaTechLayerHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaTechLayerHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaTechLayerHeader_FromoaDataAppDef_oaTechLayerHeader(oaDataAppDef_oaTechLayerHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaTechLayerHeader* data=*value;
        PyObject* bself = PyoaDataAppDef_oaTechLayerHeader_Type.tp_alloc(&PyoaDataAppDef_oaTechLayerHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaTechLayerHeaderObject* self = (PyoaDataAppDef_oaTechLayerHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaTechLayerHeader_FromoaDataAppDef_oaTechLayerHeader(oaDataAppDef_oaTechLayerHeader* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaTechLayerHeader_Type.tp_alloc(&PyoaDataAppDef_oaTechLayerHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaTechLayerHeaderObject* self = (PyoaDataAppDef_oaTechLayerHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaTechLayerHeader_get_doc[] = 
"Class: oaDataAppDef_oaTechLayerHeader, Function: get\n"
"  Paramegers: (oaTechLayerHeader,[oaByte])\n"
"    Calls: void get(const oaTechLayerHeader* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaTechLayerHeader,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaTechLayerHeader_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaTechLayerHeader data;
    int convert_status=PyoaDataAppDef_oaTechLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaTechLayerHeaderObject* self=(PyoaDataAppDef_oaTechLayerHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechLayerHeader p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTechLayerHeader_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaTechLayerHeader_getDefault_doc[] = 
"Class: oaDataAppDef_oaTechLayerHeader, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaTechLayerHeader_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaTechLayerHeader data;
    int convert_status=PyoaDataAppDef_oaTechLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaTechLayerHeaderObject* self=(PyoaDataAppDef_oaTechLayerHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaTechLayerHeader_getSize_doc[] = 
"Class: oaDataAppDef_oaTechLayerHeader, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaTechLayerHeader_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaTechLayerHeader data;
    int convert_status=PyoaDataAppDef_oaTechLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaTechLayerHeaderObject* self=(PyoaDataAppDef_oaTechLayerHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaTechLayerHeader_set_doc[] = 
"Class: oaDataAppDef_oaTechLayerHeader, Function: set\n"
"  Paramegers: (oaTechLayerHeader,[oaByte])\n"
"    Calls: void set(oaTechLayerHeader* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaTechLayerHeader,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaTechLayerHeader_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaTechLayerHeader data;
    int convert_status=PyoaDataAppDef_oaTechLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaTechLayerHeaderObject* self=(PyoaDataAppDef_oaTechLayerHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechLayerHeader p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTechLayerHeader_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaTechLayerHeader_isNull_doc[] =
"Class: oaDataAppDef_oaTechLayerHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaTechLayerHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaTechLayerHeader data;
    int convert_status=PyoaDataAppDef_oaTechLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaTechLayerHeader_assign_doc[] = 
"Class: oaDataAppDef_oaTechLayerHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaTechLayerHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaTechLayerHeader data;
  int convert_status=PyoaDataAppDef_oaTechLayerHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaTechLayerHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaTechLayerHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaTechLayerHeader_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaTechLayerHeader_get,METH_VARARGS,oaDataAppDef_oaTechLayerHeader_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaTechLayerHeader_getDefault,METH_VARARGS,oaDataAppDef_oaTechLayerHeader_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaTechLayerHeader_getSize,METH_VARARGS,oaDataAppDef_oaTechLayerHeader_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaTechLayerHeader_set,METH_VARARGS,oaDataAppDef_oaTechLayerHeader_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaTechLayerHeader_tp_isNull,METH_VARARGS,oaDataAppDef_oaTechLayerHeader_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaTechLayerHeader_tp_assign,METH_VARARGS,oaDataAppDef_oaTechLayerHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaTechLayerHeader_doc[] = 
"Class: oaDataAppDef_oaTechLayerHeader\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaTechLayerHeader)\n"
"    Calls: (const oaDataAppDef_oaTechLayerHeader&)\n"
"    Signature: oaDataAppDef_oaTechLayerHeader||cref-oaDataAppDef_oaTechLayerHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaTechLayerHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaTechLayerHeader",
    sizeof(PyoaDataAppDef_oaTechLayerHeaderObject),
    0,
    (destructor)oaDataAppDef_oaTechLayerHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaTechLayerHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaTechLayerHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaTechLayerHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaTechLayerHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaTechLayerHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaTechLayerHeader_static_find_doc[] = 
"Class: oaDataAppDef_oaTechLayerHeader, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaTechLayerHeader* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaTechLayerHeader|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaTechLayerHeader* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaTechLayerHeader|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaTechLayerHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaTechLayerHeaderp result= (oaDataAppDef_oaTechLayerHeader::find(p1.Data()));
            return PyoaDataAppDef_oaTechLayerHeader_FromoaDataAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaTechLayerHeaderp result= (oaDataAppDef_oaTechLayerHeader::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaTechLayerHeader_FromoaDataAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaTechLayerHeader, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaTechLayerHeader_static_get_doc[] = 
"Class: oaDataAppDef_oaTechLayerHeader, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaTechLayerHeader* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaTechLayerHeader|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaTechLayerHeader* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaTechLayerHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaTechLayerHeader_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaTechLayerHeaderp result= (oaDataAppDef_oaTechLayerHeader::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaTechLayerHeader_FromoaDataAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaTechLayerHeaderp result= (oaDataAppDef_oaTechLayerHeader::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaTechLayerHeader_FromoaDataAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaTechLayerHeader, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaTechLayerHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaTechLayerHeader_static_find,METH_VARARGS,oaDataAppDef_oaTechLayerHeader_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaTechLayerHeader_static_get,METH_VARARGS,oaDataAppDef_oaTechLayerHeader_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaTechLayerHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaTechLayerHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaTechLayerHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaTechLayerHeader",
           (PyObject*)(&PyoaDataAppDef_oaTechLayerHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaTechLayerHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaTechLayerHeader_Type.tp_dict;
    for(method=oaDataAppDef_oaTechLayerHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaTechViaDefHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaTechViaDefHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaTechViaDefHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaTechViaDefHeaderObject* self = (PyoaDataAppDef_oaTechViaDefHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaTechViaDefHeader)
    {
        PyParamoaDataAppDef_oaTechViaDefHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaTechViaDefHeader_Convert,&p1)) {
            PyoaDataAppDef_oaTechViaDefHeaderObject* cself=((PyoaDataAppDef_oaTechViaDefHeaderObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaTechViaDefHeader, Choices are:\n"
        "    (oaDataAppDef_oaTechViaDefHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaTechViaDefHeader_tp_dealloc(PyoaDataAppDef_oaTechViaDefHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaTechViaDefHeader_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaTechViaDefHeader value;
    int convert_status=PyoaDataAppDef_oaTechViaDefHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[53];
    sprintf(buffer,"<oaDataAppDef_oaTechViaDefHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaTechViaDefHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaTechViaDefHeader v1;
    PyParamoaDataAppDef_oaTechViaDefHeader v2;
    int convert_status1=PyoaDataAppDef_oaTechViaDefHeader_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaTechViaDefHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaTechViaDefHeader_Convert(PyObject* ob,PyParamoaDataAppDef_oaTechViaDefHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaTechViaDefHeader_Check(ob)) {
        result->SetData( (oaDataAppDef_oaTechViaDefHeader**) ((PyoaDataAppDef_oaTechViaDefHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaTechViaDefHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaTechViaDefHeader_FromoaDataAppDef_oaTechViaDefHeader(oaDataAppDef_oaTechViaDefHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaTechViaDefHeader* data=*value;
        PyObject* bself = PyoaDataAppDef_oaTechViaDefHeader_Type.tp_alloc(&PyoaDataAppDef_oaTechViaDefHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaTechViaDefHeaderObject* self = (PyoaDataAppDef_oaTechViaDefHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaTechViaDefHeader_FromoaDataAppDef_oaTechViaDefHeader(oaDataAppDef_oaTechViaDefHeader* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaTechViaDefHeader_Type.tp_alloc(&PyoaDataAppDef_oaTechViaDefHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaTechViaDefHeaderObject* self = (PyoaDataAppDef_oaTechViaDefHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaTechViaDefHeader_get_doc[] = 
"Class: oaDataAppDef_oaTechViaDefHeader, Function: get\n"
"  Paramegers: (oaTechViaDefHeader,[oaByte])\n"
"    Calls: void get(const oaTechViaDefHeader* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaTechViaDefHeader,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaTechViaDefHeader_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaTechViaDefHeader data;
    int convert_status=PyoaDataAppDef_oaTechViaDefHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaTechViaDefHeaderObject* self=(PyoaDataAppDef_oaTechViaDefHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechViaDefHeader p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTechViaDefHeader_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaTechViaDefHeader_getDefault_doc[] = 
"Class: oaDataAppDef_oaTechViaDefHeader, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaTechViaDefHeader_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaTechViaDefHeader data;
    int convert_status=PyoaDataAppDef_oaTechViaDefHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaTechViaDefHeaderObject* self=(PyoaDataAppDef_oaTechViaDefHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaTechViaDefHeader_getSize_doc[] = 
"Class: oaDataAppDef_oaTechViaDefHeader, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaTechViaDefHeader_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaTechViaDefHeader data;
    int convert_status=PyoaDataAppDef_oaTechViaDefHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaTechViaDefHeaderObject* self=(PyoaDataAppDef_oaTechViaDefHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaTechViaDefHeader_set_doc[] = 
"Class: oaDataAppDef_oaTechViaDefHeader, Function: set\n"
"  Paramegers: (oaTechViaDefHeader,[oaByte])\n"
"    Calls: void set(oaTechViaDefHeader* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaTechViaDefHeader,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaTechViaDefHeader_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaTechViaDefHeader data;
    int convert_status=PyoaDataAppDef_oaTechViaDefHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaTechViaDefHeaderObject* self=(PyoaDataAppDef_oaTechViaDefHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechViaDefHeader p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTechViaDefHeader_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaTechViaDefHeader_isNull_doc[] =
"Class: oaDataAppDef_oaTechViaDefHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaTechViaDefHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaTechViaDefHeader data;
    int convert_status=PyoaDataAppDef_oaTechViaDefHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaTechViaDefHeader_assign_doc[] = 
"Class: oaDataAppDef_oaTechViaDefHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaTechViaDefHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaTechViaDefHeader data;
  int convert_status=PyoaDataAppDef_oaTechViaDefHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaTechViaDefHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaTechViaDefHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaTechViaDefHeader_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaTechViaDefHeader_get,METH_VARARGS,oaDataAppDef_oaTechViaDefHeader_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaTechViaDefHeader_getDefault,METH_VARARGS,oaDataAppDef_oaTechViaDefHeader_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaTechViaDefHeader_getSize,METH_VARARGS,oaDataAppDef_oaTechViaDefHeader_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaTechViaDefHeader_set,METH_VARARGS,oaDataAppDef_oaTechViaDefHeader_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaTechViaDefHeader_tp_isNull,METH_VARARGS,oaDataAppDef_oaTechViaDefHeader_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaTechViaDefHeader_tp_assign,METH_VARARGS,oaDataAppDef_oaTechViaDefHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaTechViaDefHeader_doc[] = 
"Class: oaDataAppDef_oaTechViaDefHeader\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaTechViaDefHeader)\n"
"    Calls: (const oaDataAppDef_oaTechViaDefHeader&)\n"
"    Signature: oaDataAppDef_oaTechViaDefHeader||cref-oaDataAppDef_oaTechViaDefHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaTechViaDefHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaTechViaDefHeader",
    sizeof(PyoaDataAppDef_oaTechViaDefHeaderObject),
    0,
    (destructor)oaDataAppDef_oaTechViaDefHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaTechViaDefHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaTechViaDefHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaTechViaDefHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaTechViaDefHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaTechViaDefHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaTechViaDefHeader_static_find_doc[] = 
"Class: oaDataAppDef_oaTechViaDefHeader, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaTechViaDefHeader* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaTechViaDefHeader|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaTechViaDefHeader* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaTechViaDefHeader|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaTechViaDefHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaTechViaDefHeaderp result= (oaDataAppDef_oaTechViaDefHeader::find(p1.Data()));
            return PyoaDataAppDef_oaTechViaDefHeader_FromoaDataAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaTechViaDefHeaderp result= (oaDataAppDef_oaTechViaDefHeader::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaTechViaDefHeader_FromoaDataAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaTechViaDefHeader, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaTechViaDefHeader_static_get_doc[] = 
"Class: oaDataAppDef_oaTechViaDefHeader, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaTechViaDefHeader* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaTechViaDefHeader|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaTechViaDefHeader* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaTechViaDefHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaTechViaDefHeader_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaTechViaDefHeaderp result= (oaDataAppDef_oaTechViaDefHeader::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaTechViaDefHeader_FromoaDataAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaTechViaDefHeaderp result= (oaDataAppDef_oaTechViaDefHeader::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaTechViaDefHeader_FromoaDataAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaTechViaDefHeader, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaTechViaDefHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaTechViaDefHeader_static_find,METH_VARARGS,oaDataAppDef_oaTechViaDefHeader_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaTechViaDefHeader_static_get,METH_VARARGS,oaDataAppDef_oaTechViaDefHeader_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaTechViaDefHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaTechViaDefHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaTechViaDefHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaTechViaDefHeader",
           (PyObject*)(&PyoaDataAppDef_oaTechViaDefHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaTechViaDefHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaTechViaDefHeader_Type.tp_dict;
    for(method=oaDataAppDef_oaTechViaDefHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaTerm
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaTerm_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaTerm_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaTermObject* self = (PyoaDataAppDef_oaTermObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaTerm)
    {
        PyParamoaDataAppDef_oaTerm p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaTerm_Convert,&p1)) {
            PyoaDataAppDef_oaTermObject* cself=((PyoaDataAppDef_oaTermObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaTerm, Choices are:\n"
        "    (oaDataAppDef_oaTerm)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaTerm_tp_dealloc(PyoaDataAppDef_oaTermObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaTerm_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaTerm value;
    int convert_status=PyoaDataAppDef_oaTerm_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[41];
    sprintf(buffer,"<oaDataAppDef_oaTerm::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaTerm_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaTerm v1;
    PyParamoaDataAppDef_oaTerm v2;
    int convert_status1=PyoaDataAppDef_oaTerm_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaTerm_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaTerm_Convert(PyObject* ob,PyParamoaDataAppDef_oaTerm* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaTerm_Check(ob)) {
        result->SetData( (oaDataAppDef_oaTerm**) ((PyoaDataAppDef_oaTermObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaTerm Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaTerm_FromoaDataAppDef_oaTerm(oaDataAppDef_oaTerm** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaTerm* data=*value;
        PyObject* bself = PyoaDataAppDef_oaTerm_Type.tp_alloc(&PyoaDataAppDef_oaTerm_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaTermObject* self = (PyoaDataAppDef_oaTermObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaTerm_FromoaDataAppDef_oaTerm(oaDataAppDef_oaTerm* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaTerm_Type.tp_alloc(&PyoaDataAppDef_oaTerm_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaTermObject* self = (PyoaDataAppDef_oaTermObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaTerm_get_doc[] = 
"Class: oaDataAppDef_oaTerm, Function: get\n"
"  Paramegers: (oaTerm,[oaByte])\n"
"    Calls: void get(const oaTerm* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaTerm,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaTerm_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaTerm data;
    int convert_status=PyoaDataAppDef_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaTermObject* self=(PyoaDataAppDef_oaTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTerm p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTerm_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaTerm_getDefault_doc[] = 
"Class: oaDataAppDef_oaTerm, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaTerm_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaTerm data;
    int convert_status=PyoaDataAppDef_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaTermObject* self=(PyoaDataAppDef_oaTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaTerm_getSize_doc[] = 
"Class: oaDataAppDef_oaTerm, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaTerm_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaTerm data;
    int convert_status=PyoaDataAppDef_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaTermObject* self=(PyoaDataAppDef_oaTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaTerm_set_doc[] = 
"Class: oaDataAppDef_oaTerm, Function: set\n"
"  Paramegers: (oaTerm,[oaByte])\n"
"    Calls: void set(oaTerm* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaTerm,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaTerm_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaTerm data;
    int convert_status=PyoaDataAppDef_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaTermObject* self=(PyoaDataAppDef_oaTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTerm p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTerm_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaTerm_isNull_doc[] =
"Class: oaDataAppDef_oaTerm, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaTerm_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaTerm data;
    int convert_status=PyoaDataAppDef_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaTerm_assign_doc[] = 
"Class: oaDataAppDef_oaTerm, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaTerm_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaTerm data;
  int convert_status=PyoaDataAppDef_oaTerm_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaTerm p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaTerm_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaTerm_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaTerm_get,METH_VARARGS,oaDataAppDef_oaTerm_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaTerm_getDefault,METH_VARARGS,oaDataAppDef_oaTerm_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaTerm_getSize,METH_VARARGS,oaDataAppDef_oaTerm_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaTerm_set,METH_VARARGS,oaDataAppDef_oaTerm_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaTerm_tp_isNull,METH_VARARGS,oaDataAppDef_oaTerm_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaTerm_tp_assign,METH_VARARGS,oaDataAppDef_oaTerm_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaTerm_doc[] = 
"Class: oaDataAppDef_oaTerm\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaTerm)\n"
"    Calls: (const oaDataAppDef_oaTerm&)\n"
"    Signature: oaDataAppDef_oaTerm||cref-oaDataAppDef_oaTerm,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaTerm_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaTerm",
    sizeof(PyoaDataAppDef_oaTermObject),
    0,
    (destructor)oaDataAppDef_oaTerm_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaTerm_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaTerm_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaTerm_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaTerm_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaTerm_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaTerm_static_find_doc[] = 
"Class: oaDataAppDef_oaTerm, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaTerm* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaTerm|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaTerm* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaTerm|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaTerm_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaTermp result= (oaDataAppDef_oaTerm::find(p1.Data()));
            return PyoaDataAppDef_oaTerm_FromoaDataAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaTermp result= (oaDataAppDef_oaTerm::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaTerm_FromoaDataAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaTerm, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaTerm_static_get_doc[] = 
"Class: oaDataAppDef_oaTerm, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaTerm* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaTerm|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaTerm* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaTerm|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaTerm_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaTermp result= (oaDataAppDef_oaTerm::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaTerm_FromoaDataAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaTermp result= (oaDataAppDef_oaTerm::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaTerm_FromoaDataAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaTerm, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaTerm_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaTerm_static_find,METH_VARARGS,oaDataAppDef_oaTerm_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaTerm_static_get,METH_VARARGS,oaDataAppDef_oaTerm_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaTerm_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaTerm_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaTerm\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaTerm",
           (PyObject*)(&PyoaDataAppDef_oaTerm_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaTerm\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaTerm_Type.tp_dict;
    for(method=oaDataAppDef_oaTerm_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaTrackPattern
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaTrackPattern_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaTrackPattern_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaTrackPatternObject* self = (PyoaDataAppDef_oaTrackPatternObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaTrackPattern)
    {
        PyParamoaDataAppDef_oaTrackPattern p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaTrackPattern_Convert,&p1)) {
            PyoaDataAppDef_oaTrackPatternObject* cself=((PyoaDataAppDef_oaTrackPatternObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaTrackPattern, Choices are:\n"
        "    (oaDataAppDef_oaTrackPattern)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaTrackPattern_tp_dealloc(PyoaDataAppDef_oaTrackPatternObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaTrackPattern_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaTrackPattern value;
    int convert_status=PyoaDataAppDef_oaTrackPattern_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[49];
    sprintf(buffer,"<oaDataAppDef_oaTrackPattern::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaTrackPattern_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaTrackPattern v1;
    PyParamoaDataAppDef_oaTrackPattern v2;
    int convert_status1=PyoaDataAppDef_oaTrackPattern_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaTrackPattern_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaTrackPattern_Convert(PyObject* ob,PyParamoaDataAppDef_oaTrackPattern* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaTrackPattern_Check(ob)) {
        result->SetData( (oaDataAppDef_oaTrackPattern**) ((PyoaDataAppDef_oaTrackPatternObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaTrackPattern Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaTrackPattern_FromoaDataAppDef_oaTrackPattern(oaDataAppDef_oaTrackPattern** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaTrackPattern* data=*value;
        PyObject* bself = PyoaDataAppDef_oaTrackPattern_Type.tp_alloc(&PyoaDataAppDef_oaTrackPattern_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaTrackPatternObject* self = (PyoaDataAppDef_oaTrackPatternObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaTrackPattern_FromoaDataAppDef_oaTrackPattern(oaDataAppDef_oaTrackPattern* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaTrackPattern_Type.tp_alloc(&PyoaDataAppDef_oaTrackPattern_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaTrackPatternObject* self = (PyoaDataAppDef_oaTrackPatternObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaTrackPattern_get_doc[] = 
"Class: oaDataAppDef_oaTrackPattern, Function: get\n"
"  Paramegers: (oaTrackPattern,[oaByte])\n"
"    Calls: void get(const oaTrackPattern* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaTrackPattern,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaTrackPattern_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaTrackPattern data;
    int convert_status=PyoaDataAppDef_oaTrackPattern_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaTrackPatternObject* self=(PyoaDataAppDef_oaTrackPatternObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTrackPattern p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTrackPattern_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaTrackPattern_getDefault_doc[] = 
"Class: oaDataAppDef_oaTrackPattern, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaTrackPattern_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaTrackPattern data;
    int convert_status=PyoaDataAppDef_oaTrackPattern_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaTrackPatternObject* self=(PyoaDataAppDef_oaTrackPatternObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaTrackPattern_getSize_doc[] = 
"Class: oaDataAppDef_oaTrackPattern, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaTrackPattern_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaTrackPattern data;
    int convert_status=PyoaDataAppDef_oaTrackPattern_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaTrackPatternObject* self=(PyoaDataAppDef_oaTrackPatternObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaTrackPattern_set_doc[] = 
"Class: oaDataAppDef_oaTrackPattern, Function: set\n"
"  Paramegers: (oaTrackPattern,[oaByte])\n"
"    Calls: void set(oaTrackPattern* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaTrackPattern,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaTrackPattern_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaTrackPattern data;
    int convert_status=PyoaDataAppDef_oaTrackPattern_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaTrackPatternObject* self=(PyoaDataAppDef_oaTrackPatternObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTrackPattern p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTrackPattern_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaTrackPattern_isNull_doc[] =
"Class: oaDataAppDef_oaTrackPattern, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaTrackPattern_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaTrackPattern data;
    int convert_status=PyoaDataAppDef_oaTrackPattern_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaTrackPattern_assign_doc[] = 
"Class: oaDataAppDef_oaTrackPattern, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaTrackPattern_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaTrackPattern data;
  int convert_status=PyoaDataAppDef_oaTrackPattern_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaTrackPattern p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaTrackPattern_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaTrackPattern_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaTrackPattern_get,METH_VARARGS,oaDataAppDef_oaTrackPattern_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaTrackPattern_getDefault,METH_VARARGS,oaDataAppDef_oaTrackPattern_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaTrackPattern_getSize,METH_VARARGS,oaDataAppDef_oaTrackPattern_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaTrackPattern_set,METH_VARARGS,oaDataAppDef_oaTrackPattern_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaTrackPattern_tp_isNull,METH_VARARGS,oaDataAppDef_oaTrackPattern_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaTrackPattern_tp_assign,METH_VARARGS,oaDataAppDef_oaTrackPattern_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaTrackPattern_doc[] = 
"Class: oaDataAppDef_oaTrackPattern\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaTrackPattern)\n"
"    Calls: (const oaDataAppDef_oaTrackPattern&)\n"
"    Signature: oaDataAppDef_oaTrackPattern||cref-oaDataAppDef_oaTrackPattern,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaTrackPattern_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaTrackPattern",
    sizeof(PyoaDataAppDef_oaTrackPatternObject),
    0,
    (destructor)oaDataAppDef_oaTrackPattern_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaTrackPattern_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaTrackPattern_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaTrackPattern_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaTrackPattern_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaTrackPattern_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaTrackPattern_static_find_doc[] = 
"Class: oaDataAppDef_oaTrackPattern, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaTrackPattern* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaTrackPattern|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaTrackPattern* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaTrackPattern|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaTrackPattern_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaTrackPatternp result= (oaDataAppDef_oaTrackPattern::find(p1.Data()));
            return PyoaDataAppDef_oaTrackPattern_FromoaDataAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaTrackPatternp result= (oaDataAppDef_oaTrackPattern::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaTrackPattern_FromoaDataAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaTrackPattern, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaTrackPattern_static_get_doc[] = 
"Class: oaDataAppDef_oaTrackPattern, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaTrackPattern* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaTrackPattern|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaTrackPattern* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaTrackPattern|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaTrackPattern_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaTrackPatternp result= (oaDataAppDef_oaTrackPattern::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaTrackPattern_FromoaDataAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaTrackPatternp result= (oaDataAppDef_oaTrackPattern::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaTrackPattern_FromoaDataAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaTrackPattern, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaTrackPattern_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaTrackPattern_static_find,METH_VARARGS,oaDataAppDef_oaTrackPattern_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaTrackPattern_static_get,METH_VARARGS,oaDataAppDef_oaTrackPattern_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaTrackPattern_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaTrackPattern_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaTrackPattern\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaTrackPattern",
           (PyObject*)(&PyoaDataAppDef_oaTrackPattern_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaTrackPattern\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaTrackPattern_Type.tp_dict;
    for(method=oaDataAppDef_oaTrackPattern_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaValue
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaValue_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaValue_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaValueObject* self = (PyoaDataAppDef_oaValueObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaValue)
    {
        PyParamoaDataAppDef_oaValue p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaValue_Convert,&p1)) {
            PyoaDataAppDef_oaValueObject* cself=((PyoaDataAppDef_oaValueObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaValue, Choices are:\n"
        "    (oaDataAppDef_oaValue)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaValue_tp_dealloc(PyoaDataAppDef_oaValueObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaValue_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaValue value;
    int convert_status=PyoaDataAppDef_oaValue_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaDataAppDef_oaValue::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaValue_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaValue v1;
    PyParamoaDataAppDef_oaValue v2;
    int convert_status1=PyoaDataAppDef_oaValue_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaValue_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaValue_Convert(PyObject* ob,PyParamoaDataAppDef_oaValue* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaValue_Check(ob)) {
        result->SetData( (oaDataAppDef_oaValue**) ((PyoaDataAppDef_oaValueObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaValue Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaValue_FromoaDataAppDef_oaValue(oaDataAppDef_oaValue** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaValue* data=*value;
        PyObject* bself = PyoaDataAppDef_oaValue_Type.tp_alloc(&PyoaDataAppDef_oaValue_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaValueObject* self = (PyoaDataAppDef_oaValueObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaValue_FromoaDataAppDef_oaValue(oaDataAppDef_oaValue* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaValue_Type.tp_alloc(&PyoaDataAppDef_oaValue_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaValueObject* self = (PyoaDataAppDef_oaValueObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaValue_get_doc[] = 
"Class: oaDataAppDef_oaValue, Function: get\n"
"  Paramegers: (oaValue,[oaByte])\n"
"    Calls: void get(const oaValue* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaValue,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaValue_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaValue data;
    int convert_status=PyoaDataAppDef_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaValueObject* self=(PyoaDataAppDef_oaValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaValue p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaValue_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaValue_getDefault_doc[] = 
"Class: oaDataAppDef_oaValue, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaValue_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaValue data;
    int convert_status=PyoaDataAppDef_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaValueObject* self=(PyoaDataAppDef_oaValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaValue_getSize_doc[] = 
"Class: oaDataAppDef_oaValue, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaValue_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaValue data;
    int convert_status=PyoaDataAppDef_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaValueObject* self=(PyoaDataAppDef_oaValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaValue_set_doc[] = 
"Class: oaDataAppDef_oaValue, Function: set\n"
"  Paramegers: (oaValue,[oaByte])\n"
"    Calls: void set(oaValue* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaValue,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaValue_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaValue data;
    int convert_status=PyoaDataAppDef_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaValueObject* self=(PyoaDataAppDef_oaValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaValue p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaValue_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaValue_isNull_doc[] =
"Class: oaDataAppDef_oaValue, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaValue_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaValue data;
    int convert_status=PyoaDataAppDef_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaValue_assign_doc[] = 
"Class: oaDataAppDef_oaValue, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaValue_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaValue data;
  int convert_status=PyoaDataAppDef_oaValue_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaValue p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaValue_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaValue_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaValue_get,METH_VARARGS,oaDataAppDef_oaValue_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaValue_getDefault,METH_VARARGS,oaDataAppDef_oaValue_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaValue_getSize,METH_VARARGS,oaDataAppDef_oaValue_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaValue_set,METH_VARARGS,oaDataAppDef_oaValue_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaValue_tp_isNull,METH_VARARGS,oaDataAppDef_oaValue_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaValue_tp_assign,METH_VARARGS,oaDataAppDef_oaValue_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaValue_doc[] = 
"Class: oaDataAppDef_oaValue\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaValue)\n"
"    Calls: (const oaDataAppDef_oaValue&)\n"
"    Signature: oaDataAppDef_oaValue||cref-oaDataAppDef_oaValue,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaValue_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaValue",
    sizeof(PyoaDataAppDef_oaValueObject),
    0,
    (destructor)oaDataAppDef_oaValue_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaValue_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaValue_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaValue_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaValue_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaValue_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaValue_static_find_doc[] = 
"Class: oaDataAppDef_oaValue, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaValue* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaValue|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaValue* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaValue|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaValue_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaValuep result= (oaDataAppDef_oaValue::find(p1.Data()));
            return PyoaDataAppDef_oaValue_FromoaDataAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaValuep result= (oaDataAppDef_oaValue::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaValue_FromoaDataAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaValue, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaValue_static_get_doc[] = 
"Class: oaDataAppDef_oaValue, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaValue* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaValue|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaValue* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaValue|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaValue_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaValuep result= (oaDataAppDef_oaValue::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaValue_FromoaDataAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaValuep result= (oaDataAppDef_oaValue::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaValue_FromoaDataAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaValue, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaValue_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaValue_static_find,METH_VARARGS,oaDataAppDef_oaValue_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaValue_static_get,METH_VARARGS,oaDataAppDef_oaValue_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaValue_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaValue_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaValue\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaValue",
           (PyObject*)(&PyoaDataAppDef_oaValue_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaValue\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaValue_Type.tp_dict;
    for(method=oaDataAppDef_oaValue_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaVectorInstDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaVectorInstDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaVectorInstDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaVectorInstDefObject* self = (PyoaDataAppDef_oaVectorInstDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaVectorInstDef)
    {
        PyParamoaDataAppDef_oaVectorInstDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaVectorInstDef_Convert,&p1)) {
            PyoaDataAppDef_oaVectorInstDefObject* cself=((PyoaDataAppDef_oaVectorInstDefObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaVectorInstDef, Choices are:\n"
        "    (oaDataAppDef_oaVectorInstDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaVectorInstDef_tp_dealloc(PyoaDataAppDef_oaVectorInstDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaVectorInstDef_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaVectorInstDef value;
    int convert_status=PyoaDataAppDef_oaVectorInstDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[50];
    sprintf(buffer,"<oaDataAppDef_oaVectorInstDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaVectorInstDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaVectorInstDef v1;
    PyParamoaDataAppDef_oaVectorInstDef v2;
    int convert_status1=PyoaDataAppDef_oaVectorInstDef_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaVectorInstDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaVectorInstDef_Convert(PyObject* ob,PyParamoaDataAppDef_oaVectorInstDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaVectorInstDef_Check(ob)) {
        result->SetData( (oaDataAppDef_oaVectorInstDef**) ((PyoaDataAppDef_oaVectorInstDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaVectorInstDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaVectorInstDef_FromoaDataAppDef_oaVectorInstDef(oaDataAppDef_oaVectorInstDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaVectorInstDef* data=*value;
        PyObject* bself = PyoaDataAppDef_oaVectorInstDef_Type.tp_alloc(&PyoaDataAppDef_oaVectorInstDef_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaVectorInstDefObject* self = (PyoaDataAppDef_oaVectorInstDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaVectorInstDef_FromoaDataAppDef_oaVectorInstDef(oaDataAppDef_oaVectorInstDef* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaVectorInstDef_Type.tp_alloc(&PyoaDataAppDef_oaVectorInstDef_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaVectorInstDefObject* self = (PyoaDataAppDef_oaVectorInstDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaVectorInstDef_get_doc[] = 
"Class: oaDataAppDef_oaVectorInstDef, Function: get\n"
"  Paramegers: (oaVectorInstDef,[oaByte])\n"
"    Calls: void get(const oaVectorInstDef* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaVectorInstDef,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaVectorInstDef_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaVectorInstDef data;
    int convert_status=PyoaDataAppDef_oaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaVectorInstDefObject* self=(PyoaDataAppDef_oaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaVectorInstDef p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaVectorInstDef_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaVectorInstDef_getDefault_doc[] = 
"Class: oaDataAppDef_oaVectorInstDef, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaVectorInstDef_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaVectorInstDef data;
    int convert_status=PyoaDataAppDef_oaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaVectorInstDefObject* self=(PyoaDataAppDef_oaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaVectorInstDef_getSize_doc[] = 
"Class: oaDataAppDef_oaVectorInstDef, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaVectorInstDef_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaVectorInstDef data;
    int convert_status=PyoaDataAppDef_oaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaVectorInstDefObject* self=(PyoaDataAppDef_oaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaVectorInstDef_set_doc[] = 
"Class: oaDataAppDef_oaVectorInstDef, Function: set\n"
"  Paramegers: (oaVectorInstDef,[oaByte])\n"
"    Calls: void set(oaVectorInstDef* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaVectorInstDef,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaVectorInstDef_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaVectorInstDef data;
    int convert_status=PyoaDataAppDef_oaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaVectorInstDefObject* self=(PyoaDataAppDef_oaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaVectorInstDef p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaVectorInstDef_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaVectorInstDef_isNull_doc[] =
"Class: oaDataAppDef_oaVectorInstDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaVectorInstDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaVectorInstDef data;
    int convert_status=PyoaDataAppDef_oaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaVectorInstDef_assign_doc[] = 
"Class: oaDataAppDef_oaVectorInstDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaVectorInstDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaVectorInstDef data;
  int convert_status=PyoaDataAppDef_oaVectorInstDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaVectorInstDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaVectorInstDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaVectorInstDef_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaVectorInstDef_get,METH_VARARGS,oaDataAppDef_oaVectorInstDef_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaVectorInstDef_getDefault,METH_VARARGS,oaDataAppDef_oaVectorInstDef_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaVectorInstDef_getSize,METH_VARARGS,oaDataAppDef_oaVectorInstDef_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaVectorInstDef_set,METH_VARARGS,oaDataAppDef_oaVectorInstDef_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaVectorInstDef_tp_isNull,METH_VARARGS,oaDataAppDef_oaVectorInstDef_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaVectorInstDef_tp_assign,METH_VARARGS,oaDataAppDef_oaVectorInstDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaVectorInstDef_doc[] = 
"Class: oaDataAppDef_oaVectorInstDef\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaVectorInstDef)\n"
"    Calls: (const oaDataAppDef_oaVectorInstDef&)\n"
"    Signature: oaDataAppDef_oaVectorInstDef||cref-oaDataAppDef_oaVectorInstDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaVectorInstDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaVectorInstDef",
    sizeof(PyoaDataAppDef_oaVectorInstDefObject),
    0,
    (destructor)oaDataAppDef_oaVectorInstDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaVectorInstDef_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaVectorInstDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaVectorInstDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaVectorInstDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaVectorInstDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaVectorInstDef_static_find_doc[] = 
"Class: oaDataAppDef_oaVectorInstDef, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaVectorInstDef* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaVectorInstDef|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaVectorInstDef* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaVectorInstDef|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaVectorInstDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaVectorInstDefp result= (oaDataAppDef_oaVectorInstDef::find(p1.Data()));
            return PyoaDataAppDef_oaVectorInstDef_FromoaDataAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaVectorInstDefp result= (oaDataAppDef_oaVectorInstDef::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaVectorInstDef_FromoaDataAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaVectorInstDef, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaVectorInstDef_static_get_doc[] = 
"Class: oaDataAppDef_oaVectorInstDef, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaVectorInstDef* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaVectorInstDef|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaVectorInstDef* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaVectorInstDef|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaVectorInstDef_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaVectorInstDefp result= (oaDataAppDef_oaVectorInstDef::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaVectorInstDef_FromoaDataAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaVectorInstDefp result= (oaDataAppDef_oaVectorInstDef::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaVectorInstDef_FromoaDataAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaVectorInstDef, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaVectorInstDef_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaVectorInstDef_static_find,METH_VARARGS,oaDataAppDef_oaVectorInstDef_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaVectorInstDef_static_get,METH_VARARGS,oaDataAppDef_oaVectorInstDef_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaVectorInstDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaVectorInstDef_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaVectorInstDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaVectorInstDef",
           (PyObject*)(&PyoaDataAppDef_oaVectorInstDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaVectorInstDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaVectorInstDef_Type.tp_dict;
    for(method=oaDataAppDef_oaVectorInstDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaVia
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaVia_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaVia_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaViaObject* self = (PyoaDataAppDef_oaViaObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaVia)
    {
        PyParamoaDataAppDef_oaVia p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaVia_Convert,&p1)) {
            PyoaDataAppDef_oaViaObject* cself=((PyoaDataAppDef_oaViaObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaVia, Choices are:\n"
        "    (oaDataAppDef_oaVia)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaVia_tp_dealloc(PyoaDataAppDef_oaViaObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaVia_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaVia value;
    int convert_status=PyoaDataAppDef_oaVia_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[40];
    sprintf(buffer,"<oaDataAppDef_oaVia::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaVia_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaVia v1;
    PyParamoaDataAppDef_oaVia v2;
    int convert_status1=PyoaDataAppDef_oaVia_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaVia_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaVia_Convert(PyObject* ob,PyParamoaDataAppDef_oaVia* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaVia_Check(ob)) {
        result->SetData( (oaDataAppDef_oaVia**) ((PyoaDataAppDef_oaViaObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaVia Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaVia_FromoaDataAppDef_oaVia(oaDataAppDef_oaVia** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaVia* data=*value;
        PyObject* bself = PyoaDataAppDef_oaVia_Type.tp_alloc(&PyoaDataAppDef_oaVia_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaViaObject* self = (PyoaDataAppDef_oaViaObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaVia_FromoaDataAppDef_oaVia(oaDataAppDef_oaVia* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaVia_Type.tp_alloc(&PyoaDataAppDef_oaVia_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaViaObject* self = (PyoaDataAppDef_oaViaObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaVia_get_doc[] = 
"Class: oaDataAppDef_oaVia, Function: get\n"
"  Paramegers: (oaVia,[oaByte])\n"
"    Calls: void get(const oaVia* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaVia,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaVia_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaVia data;
    int convert_status=PyoaDataAppDef_oaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaViaObject* self=(PyoaDataAppDef_oaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaVia p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaVia_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaVia_getDefault_doc[] = 
"Class: oaDataAppDef_oaVia, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaVia_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaVia data;
    int convert_status=PyoaDataAppDef_oaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaViaObject* self=(PyoaDataAppDef_oaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaVia_getSize_doc[] = 
"Class: oaDataAppDef_oaVia, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaVia_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaVia data;
    int convert_status=PyoaDataAppDef_oaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaViaObject* self=(PyoaDataAppDef_oaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaVia_set_doc[] = 
"Class: oaDataAppDef_oaVia, Function: set\n"
"  Paramegers: (oaVia,[oaByte])\n"
"    Calls: void set(oaVia* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaVia,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaVia_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaVia data;
    int convert_status=PyoaDataAppDef_oaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaViaObject* self=(PyoaDataAppDef_oaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaVia p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaVia_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaVia_isNull_doc[] =
"Class: oaDataAppDef_oaVia, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaVia_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaVia data;
    int convert_status=PyoaDataAppDef_oaVia_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaVia_assign_doc[] = 
"Class: oaDataAppDef_oaVia, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaVia_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaVia data;
  int convert_status=PyoaDataAppDef_oaVia_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaVia p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaVia_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaVia_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaVia_get,METH_VARARGS,oaDataAppDef_oaVia_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaVia_getDefault,METH_VARARGS,oaDataAppDef_oaVia_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaVia_getSize,METH_VARARGS,oaDataAppDef_oaVia_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaVia_set,METH_VARARGS,oaDataAppDef_oaVia_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaVia_tp_isNull,METH_VARARGS,oaDataAppDef_oaVia_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaVia_tp_assign,METH_VARARGS,oaDataAppDef_oaVia_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaVia_doc[] = 
"Class: oaDataAppDef_oaVia\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaVia)\n"
"    Calls: (const oaDataAppDef_oaVia&)\n"
"    Signature: oaDataAppDef_oaVia||cref-oaDataAppDef_oaVia,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaVia_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaVia",
    sizeof(PyoaDataAppDef_oaViaObject),
    0,
    (destructor)oaDataAppDef_oaVia_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaVia_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaVia_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaVia_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaVia_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaVia_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaVia_static_find_doc[] = 
"Class: oaDataAppDef_oaVia, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaVia* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaVia|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaVia* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaVia|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaVia_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaViap result= (oaDataAppDef_oaVia::find(p1.Data()));
            return PyoaDataAppDef_oaVia_FromoaDataAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaViap result= (oaDataAppDef_oaVia::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaVia_FromoaDataAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaVia, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaVia_static_get_doc[] = 
"Class: oaDataAppDef_oaVia, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaVia* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaVia|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaVia* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaVia|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaVia_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaViap result= (oaDataAppDef_oaVia::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaVia_FromoaDataAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaViap result= (oaDataAppDef_oaVia::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaVia_FromoaDataAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaVia, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaVia_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaVia_static_find,METH_VARARGS,oaDataAppDef_oaVia_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaVia_static_get,METH_VARARGS,oaDataAppDef_oaVia_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaVia_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaVia_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaVia\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaVia",
           (PyObject*)(&PyoaDataAppDef_oaVia_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaVia\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaVia_Type.tp_dict;
    for(method=oaDataAppDef_oaVia_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaViaDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaViaDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaViaDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaViaDefObject* self = (PyoaDataAppDef_oaViaDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaViaDef)
    {
        PyParamoaDataAppDef_oaViaDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaViaDef_Convert,&p1)) {
            PyoaDataAppDef_oaViaDefObject* cself=((PyoaDataAppDef_oaViaDefObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaViaDef, Choices are:\n"
        "    (oaDataAppDef_oaViaDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaViaDef_tp_dealloc(PyoaDataAppDef_oaViaDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaViaDef_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaViaDef value;
    int convert_status=PyoaDataAppDef_oaViaDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaDataAppDef_oaViaDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaViaDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaViaDef v1;
    PyParamoaDataAppDef_oaViaDef v2;
    int convert_status1=PyoaDataAppDef_oaViaDef_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaViaDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaViaDef_Convert(PyObject* ob,PyParamoaDataAppDef_oaViaDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaViaDef_Check(ob)) {
        result->SetData( (oaDataAppDef_oaViaDef**) ((PyoaDataAppDef_oaViaDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaViaDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaViaDef_FromoaDataAppDef_oaViaDef(oaDataAppDef_oaViaDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaViaDef* data=*value;
        PyObject* bself = PyoaDataAppDef_oaViaDef_Type.tp_alloc(&PyoaDataAppDef_oaViaDef_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaViaDefObject* self = (PyoaDataAppDef_oaViaDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaViaDef_FromoaDataAppDef_oaViaDef(oaDataAppDef_oaViaDef* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaViaDef_Type.tp_alloc(&PyoaDataAppDef_oaViaDef_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaViaDefObject* self = (PyoaDataAppDef_oaViaDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaViaDef_get_doc[] = 
"Class: oaDataAppDef_oaViaDef, Function: get\n"
"  Paramegers: (oaViaDef,[oaByte])\n"
"    Calls: void get(const oaViaDef* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaViaDef,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaViaDef_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaViaDef data;
    int convert_status=PyoaDataAppDef_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaViaDefObject* self=(PyoaDataAppDef_oaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaDef p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViaDef_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaViaDef_getDefault_doc[] = 
"Class: oaDataAppDef_oaViaDef, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaViaDef_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaViaDef data;
    int convert_status=PyoaDataAppDef_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaViaDefObject* self=(PyoaDataAppDef_oaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaViaDef_getSize_doc[] = 
"Class: oaDataAppDef_oaViaDef, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaViaDef_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaViaDef data;
    int convert_status=PyoaDataAppDef_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaViaDefObject* self=(PyoaDataAppDef_oaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaViaDef_set_doc[] = 
"Class: oaDataAppDef_oaViaDef, Function: set\n"
"  Paramegers: (oaViaDef,[oaByte])\n"
"    Calls: void set(oaViaDef* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaViaDef,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaViaDef_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaViaDef data;
    int convert_status=PyoaDataAppDef_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaViaDefObject* self=(PyoaDataAppDef_oaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaDef p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViaDef_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaViaDef_isNull_doc[] =
"Class: oaDataAppDef_oaViaDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaViaDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaViaDef data;
    int convert_status=PyoaDataAppDef_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaViaDef_assign_doc[] = 
"Class: oaDataAppDef_oaViaDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaViaDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaViaDef data;
  int convert_status=PyoaDataAppDef_oaViaDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaViaDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaViaDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaViaDef_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaViaDef_get,METH_VARARGS,oaDataAppDef_oaViaDef_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaViaDef_getDefault,METH_VARARGS,oaDataAppDef_oaViaDef_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaViaDef_getSize,METH_VARARGS,oaDataAppDef_oaViaDef_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaViaDef_set,METH_VARARGS,oaDataAppDef_oaViaDef_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaViaDef_tp_isNull,METH_VARARGS,oaDataAppDef_oaViaDef_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaViaDef_tp_assign,METH_VARARGS,oaDataAppDef_oaViaDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaViaDef_doc[] = 
"Class: oaDataAppDef_oaViaDef\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaViaDef)\n"
"    Calls: (const oaDataAppDef_oaViaDef&)\n"
"    Signature: oaDataAppDef_oaViaDef||cref-oaDataAppDef_oaViaDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaViaDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaViaDef",
    sizeof(PyoaDataAppDef_oaViaDefObject),
    0,
    (destructor)oaDataAppDef_oaViaDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaViaDef_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaViaDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaViaDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaViaDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaViaDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaViaDef_static_find_doc[] = 
"Class: oaDataAppDef_oaViaDef, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaViaDef* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaViaDef|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaViaDef* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaViaDef|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaViaDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaViaDefp result= (oaDataAppDef_oaViaDef::find(p1.Data()));
            return PyoaDataAppDef_oaViaDef_FromoaDataAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaViaDefp result= (oaDataAppDef_oaViaDef::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaViaDef_FromoaDataAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaViaDef, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaViaDef_static_get_doc[] = 
"Class: oaDataAppDef_oaViaDef, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaViaDef* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaViaDef|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaViaDef* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaViaDef|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaViaDef_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaViaDefp result= (oaDataAppDef_oaViaDef::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaViaDef_FromoaDataAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaViaDefp result= (oaDataAppDef_oaViaDef::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaViaDef_FromoaDataAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaViaDef, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaViaDef_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaViaDef_static_find,METH_VARARGS,oaDataAppDef_oaViaDef_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaViaDef_static_get,METH_VARARGS,oaDataAppDef_oaViaDef_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaViaDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaViaDef_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaViaDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaViaDef",
           (PyObject*)(&PyoaDataAppDef_oaViaDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaViaDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaViaDef_Type.tp_dict;
    for(method=oaDataAppDef_oaViaDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaViaHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaViaHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaViaHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaViaHeaderObject* self = (PyoaDataAppDef_oaViaHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaViaHeader)
    {
        PyParamoaDataAppDef_oaViaHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaViaHeader_Convert,&p1)) {
            PyoaDataAppDef_oaViaHeaderObject* cself=((PyoaDataAppDef_oaViaHeaderObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaViaHeader, Choices are:\n"
        "    (oaDataAppDef_oaViaHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaViaHeader_tp_dealloc(PyoaDataAppDef_oaViaHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaViaHeader_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaViaHeader value;
    int convert_status=PyoaDataAppDef_oaViaHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[46];
    sprintf(buffer,"<oaDataAppDef_oaViaHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaViaHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaViaHeader v1;
    PyParamoaDataAppDef_oaViaHeader v2;
    int convert_status1=PyoaDataAppDef_oaViaHeader_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaViaHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaViaHeader_Convert(PyObject* ob,PyParamoaDataAppDef_oaViaHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaViaHeader_Check(ob)) {
        result->SetData( (oaDataAppDef_oaViaHeader**) ((PyoaDataAppDef_oaViaHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaViaHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaViaHeader_FromoaDataAppDef_oaViaHeader(oaDataAppDef_oaViaHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaViaHeader* data=*value;
        PyObject* bself = PyoaDataAppDef_oaViaHeader_Type.tp_alloc(&PyoaDataAppDef_oaViaHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaViaHeaderObject* self = (PyoaDataAppDef_oaViaHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaViaHeader_FromoaDataAppDef_oaViaHeader(oaDataAppDef_oaViaHeader* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaViaHeader_Type.tp_alloc(&PyoaDataAppDef_oaViaHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaViaHeaderObject* self = (PyoaDataAppDef_oaViaHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaViaHeader_get_doc[] = 
"Class: oaDataAppDef_oaViaHeader, Function: get\n"
"  Paramegers: (oaViaHeader,[oaByte])\n"
"    Calls: void get(const oaViaHeader* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaViaHeader,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaViaHeader_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaViaHeader data;
    int convert_status=PyoaDataAppDef_oaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaViaHeaderObject* self=(PyoaDataAppDef_oaViaHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaHeader p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViaHeader_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaViaHeader_getDefault_doc[] = 
"Class: oaDataAppDef_oaViaHeader, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaViaHeader_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaViaHeader data;
    int convert_status=PyoaDataAppDef_oaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaViaHeaderObject* self=(PyoaDataAppDef_oaViaHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaViaHeader_getSize_doc[] = 
"Class: oaDataAppDef_oaViaHeader, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaViaHeader_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaViaHeader data;
    int convert_status=PyoaDataAppDef_oaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaViaHeaderObject* self=(PyoaDataAppDef_oaViaHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaViaHeader_set_doc[] = 
"Class: oaDataAppDef_oaViaHeader, Function: set\n"
"  Paramegers: (oaViaHeader,[oaByte])\n"
"    Calls: void set(oaViaHeader* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaViaHeader,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaViaHeader_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaViaHeader data;
    int convert_status=PyoaDataAppDef_oaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaViaHeaderObject* self=(PyoaDataAppDef_oaViaHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaHeader p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViaHeader_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaViaHeader_isNull_doc[] =
"Class: oaDataAppDef_oaViaHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaViaHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaViaHeader data;
    int convert_status=PyoaDataAppDef_oaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaViaHeader_assign_doc[] = 
"Class: oaDataAppDef_oaViaHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaViaHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaViaHeader data;
  int convert_status=PyoaDataAppDef_oaViaHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaViaHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaViaHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaViaHeader_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaViaHeader_get,METH_VARARGS,oaDataAppDef_oaViaHeader_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaViaHeader_getDefault,METH_VARARGS,oaDataAppDef_oaViaHeader_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaViaHeader_getSize,METH_VARARGS,oaDataAppDef_oaViaHeader_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaViaHeader_set,METH_VARARGS,oaDataAppDef_oaViaHeader_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaViaHeader_tp_isNull,METH_VARARGS,oaDataAppDef_oaViaHeader_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaViaHeader_tp_assign,METH_VARARGS,oaDataAppDef_oaViaHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaViaHeader_doc[] = 
"Class: oaDataAppDef_oaViaHeader\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaViaHeader)\n"
"    Calls: (const oaDataAppDef_oaViaHeader&)\n"
"    Signature: oaDataAppDef_oaViaHeader||cref-oaDataAppDef_oaViaHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaViaHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaViaHeader",
    sizeof(PyoaDataAppDef_oaViaHeaderObject),
    0,
    (destructor)oaDataAppDef_oaViaHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaViaHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaViaHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaViaHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaViaHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaViaHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaViaHeader_static_find_doc[] = 
"Class: oaDataAppDef_oaViaHeader, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaViaHeader* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaViaHeader|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaViaHeader* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaViaHeader|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaViaHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaViaHeaderp result= (oaDataAppDef_oaViaHeader::find(p1.Data()));
            return PyoaDataAppDef_oaViaHeader_FromoaDataAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaViaHeaderp result= (oaDataAppDef_oaViaHeader::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaViaHeader_FromoaDataAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaViaHeader, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaViaHeader_static_get_doc[] = 
"Class: oaDataAppDef_oaViaHeader, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaViaHeader* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaViaHeader|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaViaHeader* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaViaHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaViaHeader_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaViaHeaderp result= (oaDataAppDef_oaViaHeader::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaViaHeader_FromoaDataAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaViaHeaderp result= (oaDataAppDef_oaViaHeader::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaViaHeader_FromoaDataAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaViaHeader, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaViaHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaViaHeader_static_find,METH_VARARGS,oaDataAppDef_oaViaHeader_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaViaHeader_static_get,METH_VARARGS,oaDataAppDef_oaViaHeader_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaViaHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaViaHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaViaHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaViaHeader",
           (PyObject*)(&PyoaDataAppDef_oaViaHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaViaHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaViaHeader_Type.tp_dict;
    for(method=oaDataAppDef_oaViaHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaViaSpec
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaViaSpec_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaViaSpec_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaViaSpecObject* self = (PyoaDataAppDef_oaViaSpecObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaViaSpec)
    {
        PyParamoaDataAppDef_oaViaSpec p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaViaSpec_Convert,&p1)) {
            PyoaDataAppDef_oaViaSpecObject* cself=((PyoaDataAppDef_oaViaSpecObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaViaSpec, Choices are:\n"
        "    (oaDataAppDef_oaViaSpec)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaViaSpec_tp_dealloc(PyoaDataAppDef_oaViaSpecObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaViaSpec_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaViaSpec value;
    int convert_status=PyoaDataAppDef_oaViaSpec_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[44];
    sprintf(buffer,"<oaDataAppDef_oaViaSpec::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaViaSpec_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaViaSpec v1;
    PyParamoaDataAppDef_oaViaSpec v2;
    int convert_status1=PyoaDataAppDef_oaViaSpec_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaViaSpec_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaViaSpec_Convert(PyObject* ob,PyParamoaDataAppDef_oaViaSpec* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaViaSpec_Check(ob)) {
        result->SetData( (oaDataAppDef_oaViaSpec**) ((PyoaDataAppDef_oaViaSpecObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaViaSpec Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaViaSpec_FromoaDataAppDef_oaViaSpec(oaDataAppDef_oaViaSpec** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaViaSpec* data=*value;
        PyObject* bself = PyoaDataAppDef_oaViaSpec_Type.tp_alloc(&PyoaDataAppDef_oaViaSpec_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaViaSpecObject* self = (PyoaDataAppDef_oaViaSpecObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaViaSpec_FromoaDataAppDef_oaViaSpec(oaDataAppDef_oaViaSpec* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaViaSpec_Type.tp_alloc(&PyoaDataAppDef_oaViaSpec_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaViaSpecObject* self = (PyoaDataAppDef_oaViaSpecObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaViaSpec_get_doc[] = 
"Class: oaDataAppDef_oaViaSpec, Function: get\n"
"  Paramegers: (oaViaSpec,[oaByte])\n"
"    Calls: void get(const oaViaSpec* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaViaSpec,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaViaSpec_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaViaSpec data;
    int convert_status=PyoaDataAppDef_oaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaViaSpecObject* self=(PyoaDataAppDef_oaViaSpecObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaSpec p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViaSpec_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaViaSpec_getDefault_doc[] = 
"Class: oaDataAppDef_oaViaSpec, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaViaSpec_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaViaSpec data;
    int convert_status=PyoaDataAppDef_oaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaViaSpecObject* self=(PyoaDataAppDef_oaViaSpecObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaViaSpec_getSize_doc[] = 
"Class: oaDataAppDef_oaViaSpec, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaViaSpec_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaViaSpec data;
    int convert_status=PyoaDataAppDef_oaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaViaSpecObject* self=(PyoaDataAppDef_oaViaSpecObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaViaSpec_set_doc[] = 
"Class: oaDataAppDef_oaViaSpec, Function: set\n"
"  Paramegers: (oaViaSpec,[oaByte])\n"
"    Calls: void set(oaViaSpec* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaViaSpec,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaViaSpec_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaViaSpec data;
    int convert_status=PyoaDataAppDef_oaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaViaSpecObject* self=(PyoaDataAppDef_oaViaSpecObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaSpec p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViaSpec_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaViaSpec_isNull_doc[] =
"Class: oaDataAppDef_oaViaSpec, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaViaSpec_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaViaSpec data;
    int convert_status=PyoaDataAppDef_oaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaViaSpec_assign_doc[] = 
"Class: oaDataAppDef_oaViaSpec, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaViaSpec_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaViaSpec data;
  int convert_status=PyoaDataAppDef_oaViaSpec_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaViaSpec p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaViaSpec_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaViaSpec_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaViaSpec_get,METH_VARARGS,oaDataAppDef_oaViaSpec_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaViaSpec_getDefault,METH_VARARGS,oaDataAppDef_oaViaSpec_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaViaSpec_getSize,METH_VARARGS,oaDataAppDef_oaViaSpec_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaViaSpec_set,METH_VARARGS,oaDataAppDef_oaViaSpec_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaViaSpec_tp_isNull,METH_VARARGS,oaDataAppDef_oaViaSpec_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaViaSpec_tp_assign,METH_VARARGS,oaDataAppDef_oaViaSpec_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaViaSpec_doc[] = 
"Class: oaDataAppDef_oaViaSpec\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaViaSpec)\n"
"    Calls: (const oaDataAppDef_oaViaSpec&)\n"
"    Signature: oaDataAppDef_oaViaSpec||cref-oaDataAppDef_oaViaSpec,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaViaSpec_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaViaSpec",
    sizeof(PyoaDataAppDef_oaViaSpecObject),
    0,
    (destructor)oaDataAppDef_oaViaSpec_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaViaSpec_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaViaSpec_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaViaSpec_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaViaSpec_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaViaSpec_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaViaSpec_static_find_doc[] = 
"Class: oaDataAppDef_oaViaSpec, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaViaSpec* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaViaSpec|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaViaSpec* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaViaSpec|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaViaSpec_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaViaSpecp result= (oaDataAppDef_oaViaSpec::find(p1.Data()));
            return PyoaDataAppDef_oaViaSpec_FromoaDataAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaViaSpecp result= (oaDataAppDef_oaViaSpec::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaViaSpec_FromoaDataAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaViaSpec, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaViaSpec_static_get_doc[] = 
"Class: oaDataAppDef_oaViaSpec, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaViaSpec* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaViaSpec|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaViaSpec* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaViaSpec|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaViaSpec_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaViaSpecp result= (oaDataAppDef_oaViaSpec::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaViaSpec_FromoaDataAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaViaSpecp result= (oaDataAppDef_oaViaSpec::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaViaSpec_FromoaDataAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaViaSpec, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaViaSpec_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaViaSpec_static_find,METH_VARARGS,oaDataAppDef_oaViaSpec_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaViaSpec_static_get,METH_VARARGS,oaDataAppDef_oaViaSpec_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaViaSpec_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaViaSpec_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaViaSpec\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaViaSpec",
           (PyObject*)(&PyoaDataAppDef_oaViaSpec_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaViaSpec\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaViaSpec_Type.tp_dict;
    for(method=oaDataAppDef_oaViaSpec_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaView
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaView_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaView_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaViewObject* self = (PyoaDataAppDef_oaViewObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaView)
    {
        PyParamoaDataAppDef_oaView p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaView_Convert,&p1)) {
            PyoaDataAppDef_oaViewObject* cself=((PyoaDataAppDef_oaViewObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaView, Choices are:\n"
        "    (oaDataAppDef_oaView)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaView_tp_dealloc(PyoaDataAppDef_oaViewObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaView_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaView value;
    int convert_status=PyoaDataAppDef_oaView_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[41];
    sprintf(buffer,"<oaDataAppDef_oaView::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaView_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaView v1;
    PyParamoaDataAppDef_oaView v2;
    int convert_status1=PyoaDataAppDef_oaView_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaView_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaView_Convert(PyObject* ob,PyParamoaDataAppDef_oaView* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaView_Check(ob)) {
        result->SetData( (oaDataAppDef_oaView**) ((PyoaDataAppDef_oaViewObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaView Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaView_FromoaDataAppDef_oaView(oaDataAppDef_oaView** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaView* data=*value;
        PyObject* bself = PyoaDataAppDef_oaView_Type.tp_alloc(&PyoaDataAppDef_oaView_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaViewObject* self = (PyoaDataAppDef_oaViewObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaView_FromoaDataAppDef_oaView(oaDataAppDef_oaView* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaView_Type.tp_alloc(&PyoaDataAppDef_oaView_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaViewObject* self = (PyoaDataAppDef_oaViewObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaView_get_doc[] = 
"Class: oaDataAppDef_oaView, Function: get\n"
"  Paramegers: (oaView,[oaByte])\n"
"    Calls: void get(const oaView* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaView,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaView_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaView data;
    int convert_status=PyoaDataAppDef_oaView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaViewObject* self=(PyoaDataAppDef_oaViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaView p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaView_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaView_getDefault_doc[] = 
"Class: oaDataAppDef_oaView, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaView_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaView data;
    int convert_status=PyoaDataAppDef_oaView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaViewObject* self=(PyoaDataAppDef_oaViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaView_getSize_doc[] = 
"Class: oaDataAppDef_oaView, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaView_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaView data;
    int convert_status=PyoaDataAppDef_oaView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaViewObject* self=(PyoaDataAppDef_oaViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaView_set_doc[] = 
"Class: oaDataAppDef_oaView, Function: set\n"
"  Paramegers: (oaView,[oaByte])\n"
"    Calls: void set(oaView* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaView,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaView_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaView data;
    int convert_status=PyoaDataAppDef_oaView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaViewObject* self=(PyoaDataAppDef_oaViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaView p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaView_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaView_isNull_doc[] =
"Class: oaDataAppDef_oaView, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaView_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaView data;
    int convert_status=PyoaDataAppDef_oaView_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaView_assign_doc[] = 
"Class: oaDataAppDef_oaView, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaView_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaView data;
  int convert_status=PyoaDataAppDef_oaView_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaView p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaView_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaView_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaView_get,METH_VARARGS,oaDataAppDef_oaView_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaView_getDefault,METH_VARARGS,oaDataAppDef_oaView_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaView_getSize,METH_VARARGS,oaDataAppDef_oaView_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaView_set,METH_VARARGS,oaDataAppDef_oaView_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaView_tp_isNull,METH_VARARGS,oaDataAppDef_oaView_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaView_tp_assign,METH_VARARGS,oaDataAppDef_oaView_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaView_doc[] = 
"Class: oaDataAppDef_oaView\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaView)\n"
"    Calls: (const oaDataAppDef_oaView&)\n"
"    Signature: oaDataAppDef_oaView||cref-oaDataAppDef_oaView,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaView_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaView",
    sizeof(PyoaDataAppDef_oaViewObject),
    0,
    (destructor)oaDataAppDef_oaView_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaView_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaView_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaView_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaView_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaView_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaView_static_find_doc[] = 
"Class: oaDataAppDef_oaView, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaView* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaView|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaView* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaView|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaView_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaViewp result= (oaDataAppDef_oaView::find(p1.Data()));
            return PyoaDataAppDef_oaView_FromoaDataAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaViewp result= (oaDataAppDef_oaView::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaView_FromoaDataAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaView, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaView_static_get_doc[] = 
"Class: oaDataAppDef_oaView, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaView* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaView|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaView* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaView|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaView_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaViewp result= (oaDataAppDef_oaView::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaView_FromoaDataAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaViewp result= (oaDataAppDef_oaView::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaView_FromoaDataAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaView, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaView_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaView_static_find,METH_VARARGS,oaDataAppDef_oaView_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaView_static_get,METH_VARARGS,oaDataAppDef_oaView_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaView_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaView_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaView\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaView",
           (PyObject*)(&PyoaDataAppDef_oaView_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaView\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaView_Type.tp_dict;
    for(method=oaDataAppDef_oaView_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaWafer
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaWafer_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaWafer_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaWaferObject* self = (PyoaDataAppDef_oaWaferObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaWafer)
    {
        PyParamoaDataAppDef_oaWafer p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaWafer_Convert,&p1)) {
            PyoaDataAppDef_oaWaferObject* cself=((PyoaDataAppDef_oaWaferObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaWafer, Choices are:\n"
        "    (oaDataAppDef_oaWafer)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaWafer_tp_dealloc(PyoaDataAppDef_oaWaferObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaWafer_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaWafer value;
    int convert_status=PyoaDataAppDef_oaWafer_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaDataAppDef_oaWafer::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaWafer_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaWafer v1;
    PyParamoaDataAppDef_oaWafer v2;
    int convert_status1=PyoaDataAppDef_oaWafer_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaWafer_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaWafer_Convert(PyObject* ob,PyParamoaDataAppDef_oaWafer* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaWafer_Check(ob)) {
        result->SetData( (oaDataAppDef_oaWafer**) ((PyoaDataAppDef_oaWaferObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaWafer Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaWafer_FromoaDataAppDef_oaWafer(oaDataAppDef_oaWafer** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaWafer* data=*value;
        PyObject* bself = PyoaDataAppDef_oaWafer_Type.tp_alloc(&PyoaDataAppDef_oaWafer_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaWaferObject* self = (PyoaDataAppDef_oaWaferObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaWafer_FromoaDataAppDef_oaWafer(oaDataAppDef_oaWafer* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaWafer_Type.tp_alloc(&PyoaDataAppDef_oaWafer_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaWaferObject* self = (PyoaDataAppDef_oaWaferObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaWafer_get_doc[] = 
"Class: oaDataAppDef_oaWafer, Function: get\n"
"  Paramegers: (oaWafer,[oaByte])\n"
"    Calls: void get(const oaWafer* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaWafer,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaWafer_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaWafer data;
    int convert_status=PyoaDataAppDef_oaWafer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaWaferObject* self=(PyoaDataAppDef_oaWaferObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWafer p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaWafer_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaWafer_getDefault_doc[] = 
"Class: oaDataAppDef_oaWafer, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaWafer_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaWafer data;
    int convert_status=PyoaDataAppDef_oaWafer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaWaferObject* self=(PyoaDataAppDef_oaWaferObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaWafer_getSize_doc[] = 
"Class: oaDataAppDef_oaWafer, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaWafer_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaWafer data;
    int convert_status=PyoaDataAppDef_oaWafer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaWaferObject* self=(PyoaDataAppDef_oaWaferObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaWafer_set_doc[] = 
"Class: oaDataAppDef_oaWafer, Function: set\n"
"  Paramegers: (oaWafer,[oaByte])\n"
"    Calls: void set(oaWafer* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaWafer,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaWafer_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaWafer data;
    int convert_status=PyoaDataAppDef_oaWafer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaWaferObject* self=(PyoaDataAppDef_oaWaferObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWafer p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaWafer_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaWafer_isNull_doc[] =
"Class: oaDataAppDef_oaWafer, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaWafer_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaWafer data;
    int convert_status=PyoaDataAppDef_oaWafer_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaWafer_assign_doc[] = 
"Class: oaDataAppDef_oaWafer, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaWafer_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaWafer data;
  int convert_status=PyoaDataAppDef_oaWafer_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaWafer p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaWafer_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaWafer_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaWafer_get,METH_VARARGS,oaDataAppDef_oaWafer_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaWafer_getDefault,METH_VARARGS,oaDataAppDef_oaWafer_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaWafer_getSize,METH_VARARGS,oaDataAppDef_oaWafer_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaWafer_set,METH_VARARGS,oaDataAppDef_oaWafer_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaWafer_tp_isNull,METH_VARARGS,oaDataAppDef_oaWafer_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaWafer_tp_assign,METH_VARARGS,oaDataAppDef_oaWafer_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaWafer_doc[] = 
"Class: oaDataAppDef_oaWafer\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaWafer)\n"
"    Calls: (const oaDataAppDef_oaWafer&)\n"
"    Signature: oaDataAppDef_oaWafer||cref-oaDataAppDef_oaWafer,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaWafer_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaWafer",
    sizeof(PyoaDataAppDef_oaWaferObject),
    0,
    (destructor)oaDataAppDef_oaWafer_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaWafer_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaWafer_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaWafer_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaWafer_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaWafer_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaWafer_static_find_doc[] = 
"Class: oaDataAppDef_oaWafer, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaWafer* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaWafer|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaWafer* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaWafer|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaWafer_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaWaferp result= (oaDataAppDef_oaWafer::find(p1.Data()));
            return PyoaDataAppDef_oaWafer_FromoaDataAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaWaferp result= (oaDataAppDef_oaWafer::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaWafer_FromoaDataAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaWafer, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaWafer_static_get_doc[] = 
"Class: oaDataAppDef_oaWafer, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaWafer* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaWafer|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaWafer* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaWafer|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaWafer_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaWaferp result= (oaDataAppDef_oaWafer::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaWafer_FromoaDataAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaWaferp result= (oaDataAppDef_oaWafer::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaWafer_FromoaDataAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaWafer, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaWafer_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaWafer_static_find,METH_VARARGS,oaDataAppDef_oaWafer_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaWafer_static_get,METH_VARARGS,oaDataAppDef_oaWafer_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaWafer_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaWafer_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaWafer\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaWafer",
           (PyObject*)(&PyoaDataAppDef_oaWafer_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaWafer\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaWafer_Type.tp_dict;
    for(method=oaDataAppDef_oaWafer_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaWaferDesc
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaWaferDesc_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaWaferDesc_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaWaferDescObject* self = (PyoaDataAppDef_oaWaferDescObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaWaferDesc)
    {
        PyParamoaDataAppDef_oaWaferDesc p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaWaferDesc_Convert,&p1)) {
            PyoaDataAppDef_oaWaferDescObject* cself=((PyoaDataAppDef_oaWaferDescObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaWaferDesc, Choices are:\n"
        "    (oaDataAppDef_oaWaferDesc)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaWaferDesc_tp_dealloc(PyoaDataAppDef_oaWaferDescObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaWaferDesc_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaWaferDesc value;
    int convert_status=PyoaDataAppDef_oaWaferDesc_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[46];
    sprintf(buffer,"<oaDataAppDef_oaWaferDesc::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaWaferDesc_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaWaferDesc v1;
    PyParamoaDataAppDef_oaWaferDesc v2;
    int convert_status1=PyoaDataAppDef_oaWaferDesc_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaWaferDesc_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaWaferDesc_Convert(PyObject* ob,PyParamoaDataAppDef_oaWaferDesc* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaWaferDesc_Check(ob)) {
        result->SetData( (oaDataAppDef_oaWaferDesc**) ((PyoaDataAppDef_oaWaferDescObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaWaferDesc Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaWaferDesc_FromoaDataAppDef_oaWaferDesc(oaDataAppDef_oaWaferDesc** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaWaferDesc* data=*value;
        PyObject* bself = PyoaDataAppDef_oaWaferDesc_Type.tp_alloc(&PyoaDataAppDef_oaWaferDesc_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaWaferDescObject* self = (PyoaDataAppDef_oaWaferDescObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaWaferDesc_FromoaDataAppDef_oaWaferDesc(oaDataAppDef_oaWaferDesc* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaWaferDesc_Type.tp_alloc(&PyoaDataAppDef_oaWaferDesc_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaWaferDescObject* self = (PyoaDataAppDef_oaWaferDescObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaWaferDesc_get_doc[] = 
"Class: oaDataAppDef_oaWaferDesc, Function: get\n"
"  Paramegers: (oaWaferDesc,[oaByte])\n"
"    Calls: void get(const oaWaferDesc* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaWaferDesc,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaWaferDesc_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaWaferDesc data;
    int convert_status=PyoaDataAppDef_oaWaferDesc_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaWaferDescObject* self=(PyoaDataAppDef_oaWaferDescObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWaferDesc p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaWaferDesc_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaWaferDesc_getDefault_doc[] = 
"Class: oaDataAppDef_oaWaferDesc, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaWaferDesc_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaWaferDesc data;
    int convert_status=PyoaDataAppDef_oaWaferDesc_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaWaferDescObject* self=(PyoaDataAppDef_oaWaferDescObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaWaferDesc_getSize_doc[] = 
"Class: oaDataAppDef_oaWaferDesc, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaWaferDesc_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaWaferDesc data;
    int convert_status=PyoaDataAppDef_oaWaferDesc_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaWaferDescObject* self=(PyoaDataAppDef_oaWaferDescObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaWaferDesc_set_doc[] = 
"Class: oaDataAppDef_oaWaferDesc, Function: set\n"
"  Paramegers: (oaWaferDesc,[oaByte])\n"
"    Calls: void set(oaWaferDesc* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaWaferDesc,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaWaferDesc_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaWaferDesc data;
    int convert_status=PyoaDataAppDef_oaWaferDesc_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaWaferDescObject* self=(PyoaDataAppDef_oaWaferDescObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWaferDesc p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaWaferDesc_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaWaferDesc_isNull_doc[] =
"Class: oaDataAppDef_oaWaferDesc, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaWaferDesc_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaWaferDesc data;
    int convert_status=PyoaDataAppDef_oaWaferDesc_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaWaferDesc_assign_doc[] = 
"Class: oaDataAppDef_oaWaferDesc, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaWaferDesc_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaWaferDesc data;
  int convert_status=PyoaDataAppDef_oaWaferDesc_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaWaferDesc p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaWaferDesc_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaWaferDesc_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaWaferDesc_get,METH_VARARGS,oaDataAppDef_oaWaferDesc_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaWaferDesc_getDefault,METH_VARARGS,oaDataAppDef_oaWaferDesc_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaWaferDesc_getSize,METH_VARARGS,oaDataAppDef_oaWaferDesc_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaWaferDesc_set,METH_VARARGS,oaDataAppDef_oaWaferDesc_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaWaferDesc_tp_isNull,METH_VARARGS,oaDataAppDef_oaWaferDesc_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaWaferDesc_tp_assign,METH_VARARGS,oaDataAppDef_oaWaferDesc_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaWaferDesc_doc[] = 
"Class: oaDataAppDef_oaWaferDesc\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaWaferDesc)\n"
"    Calls: (const oaDataAppDef_oaWaferDesc&)\n"
"    Signature: oaDataAppDef_oaWaferDesc||cref-oaDataAppDef_oaWaferDesc,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaWaferDesc_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaWaferDesc",
    sizeof(PyoaDataAppDef_oaWaferDescObject),
    0,
    (destructor)oaDataAppDef_oaWaferDesc_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaWaferDesc_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaWaferDesc_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaWaferDesc_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaWaferDesc_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaWaferDesc_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaWaferDesc_static_find_doc[] = 
"Class: oaDataAppDef_oaWaferDesc, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaWaferDesc* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaWaferDesc|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaWaferDesc* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaWaferDesc|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaWaferDesc_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaWaferDescp result= (oaDataAppDef_oaWaferDesc::find(p1.Data()));
            return PyoaDataAppDef_oaWaferDesc_FromoaDataAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaWaferDescp result= (oaDataAppDef_oaWaferDesc::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaWaferDesc_FromoaDataAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaWaferDesc, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaWaferDesc_static_get_doc[] = 
"Class: oaDataAppDef_oaWaferDesc, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaWaferDesc* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaWaferDesc|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaWaferDesc* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaWaferDesc|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaWaferDesc_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaWaferDescp result= (oaDataAppDef_oaWaferDesc::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaWaferDesc_FromoaDataAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaWaferDescp result= (oaDataAppDef_oaWaferDesc::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaWaferDesc_FromoaDataAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaWaferDesc, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaWaferDesc_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaWaferDesc_static_find,METH_VARARGS,oaDataAppDef_oaWaferDesc_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaWaferDesc_static_get,METH_VARARGS,oaDataAppDef_oaWaferDesc_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaWaferDesc_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaWaferDesc_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaWaferDesc\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaWaferDesc",
           (PyObject*)(&PyoaDataAppDef_oaWaferDesc_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaWaferDesc\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaWaferDesc_Type.tp_dict;
    for(method=oaDataAppDef_oaWaferDesc_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaWaferFeature
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaWaferFeature_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaWaferFeature_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaWaferFeatureObject* self = (PyoaDataAppDef_oaWaferFeatureObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaWaferFeature)
    {
        PyParamoaDataAppDef_oaWaferFeature p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaWaferFeature_Convert,&p1)) {
            PyoaDataAppDef_oaWaferFeatureObject* cself=((PyoaDataAppDef_oaWaferFeatureObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaWaferFeature, Choices are:\n"
        "    (oaDataAppDef_oaWaferFeature)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaWaferFeature_tp_dealloc(PyoaDataAppDef_oaWaferFeatureObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaWaferFeature_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaWaferFeature value;
    int convert_status=PyoaDataAppDef_oaWaferFeature_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[49];
    sprintf(buffer,"<oaDataAppDef_oaWaferFeature::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaWaferFeature_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaWaferFeature v1;
    PyParamoaDataAppDef_oaWaferFeature v2;
    int convert_status1=PyoaDataAppDef_oaWaferFeature_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaWaferFeature_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaWaferFeature_Convert(PyObject* ob,PyParamoaDataAppDef_oaWaferFeature* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaWaferFeature_Check(ob)) {
        result->SetData( (oaDataAppDef_oaWaferFeature**) ((PyoaDataAppDef_oaWaferFeatureObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaWaferFeature Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaWaferFeature_FromoaDataAppDef_oaWaferFeature(oaDataAppDef_oaWaferFeature** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaWaferFeature* data=*value;
        PyObject* bself = PyoaDataAppDef_oaWaferFeature_Type.tp_alloc(&PyoaDataAppDef_oaWaferFeature_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaWaferFeatureObject* self = (PyoaDataAppDef_oaWaferFeatureObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaWaferFeature_FromoaDataAppDef_oaWaferFeature(oaDataAppDef_oaWaferFeature* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaWaferFeature_Type.tp_alloc(&PyoaDataAppDef_oaWaferFeature_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaWaferFeatureObject* self = (PyoaDataAppDef_oaWaferFeatureObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaWaferFeature_get_doc[] = 
"Class: oaDataAppDef_oaWaferFeature, Function: get\n"
"  Paramegers: (oaWaferFeature,[oaByte])\n"
"    Calls: void get(const oaWaferFeature* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaWaferFeature,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaWaferFeature_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaWaferFeature data;
    int convert_status=PyoaDataAppDef_oaWaferFeature_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaWaferFeatureObject* self=(PyoaDataAppDef_oaWaferFeatureObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWaferFeature p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaWaferFeature_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaWaferFeature_getDefault_doc[] = 
"Class: oaDataAppDef_oaWaferFeature, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaWaferFeature_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaWaferFeature data;
    int convert_status=PyoaDataAppDef_oaWaferFeature_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaWaferFeatureObject* self=(PyoaDataAppDef_oaWaferFeatureObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaWaferFeature_getSize_doc[] = 
"Class: oaDataAppDef_oaWaferFeature, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaWaferFeature_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaWaferFeature data;
    int convert_status=PyoaDataAppDef_oaWaferFeature_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaWaferFeatureObject* self=(PyoaDataAppDef_oaWaferFeatureObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaWaferFeature_set_doc[] = 
"Class: oaDataAppDef_oaWaferFeature, Function: set\n"
"  Paramegers: (oaWaferFeature,[oaByte])\n"
"    Calls: void set(oaWaferFeature* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaWaferFeature,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaWaferFeature_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaWaferFeature data;
    int convert_status=PyoaDataAppDef_oaWaferFeature_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaWaferFeatureObject* self=(PyoaDataAppDef_oaWaferFeatureObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWaferFeature p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaWaferFeature_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaWaferFeature_isNull_doc[] =
"Class: oaDataAppDef_oaWaferFeature, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaWaferFeature_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaWaferFeature data;
    int convert_status=PyoaDataAppDef_oaWaferFeature_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaWaferFeature_assign_doc[] = 
"Class: oaDataAppDef_oaWaferFeature, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaWaferFeature_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaWaferFeature data;
  int convert_status=PyoaDataAppDef_oaWaferFeature_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaWaferFeature p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaWaferFeature_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaWaferFeature_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaWaferFeature_get,METH_VARARGS,oaDataAppDef_oaWaferFeature_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaWaferFeature_getDefault,METH_VARARGS,oaDataAppDef_oaWaferFeature_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaWaferFeature_getSize,METH_VARARGS,oaDataAppDef_oaWaferFeature_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaWaferFeature_set,METH_VARARGS,oaDataAppDef_oaWaferFeature_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaWaferFeature_tp_isNull,METH_VARARGS,oaDataAppDef_oaWaferFeature_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaWaferFeature_tp_assign,METH_VARARGS,oaDataAppDef_oaWaferFeature_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaWaferFeature_doc[] = 
"Class: oaDataAppDef_oaWaferFeature\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaWaferFeature)\n"
"    Calls: (const oaDataAppDef_oaWaferFeature&)\n"
"    Signature: oaDataAppDef_oaWaferFeature||cref-oaDataAppDef_oaWaferFeature,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaWaferFeature_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaWaferFeature",
    sizeof(PyoaDataAppDef_oaWaferFeatureObject),
    0,
    (destructor)oaDataAppDef_oaWaferFeature_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaWaferFeature_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaWaferFeature_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaWaferFeature_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaWaferFeature_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaWaferFeature_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaWaferFeature_static_find_doc[] = 
"Class: oaDataAppDef_oaWaferFeature, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaWaferFeature* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaWaferFeature|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaWaferFeature* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaWaferFeature|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaWaferFeature_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaWaferFeaturep result= (oaDataAppDef_oaWaferFeature::find(p1.Data()));
            return PyoaDataAppDef_oaWaferFeature_FromoaDataAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaWaferFeaturep result= (oaDataAppDef_oaWaferFeature::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaWaferFeature_FromoaDataAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaWaferFeature, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaWaferFeature_static_get_doc[] = 
"Class: oaDataAppDef_oaWaferFeature, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaWaferFeature* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaWaferFeature|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaWaferFeature* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaWaferFeature|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaWaferFeature_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaWaferFeaturep result= (oaDataAppDef_oaWaferFeature::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaWaferFeature_FromoaDataAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaWaferFeaturep result= (oaDataAppDef_oaWaferFeature::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaWaferFeature_FromoaDataAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaWaferFeature, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaWaferFeature_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaWaferFeature_static_find,METH_VARARGS,oaDataAppDef_oaWaferFeature_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaWaferFeature_static_get,METH_VARARGS,oaDataAppDef_oaWaferFeature_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaWaferFeature_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaWaferFeature_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaWaferFeature\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaWaferFeature",
           (PyObject*)(&PyoaDataAppDef_oaWaferFeature_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaWaferFeature\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaWaferFeature_Type.tp_dict;
    for(method=oaDataAppDef_oaWaferFeature_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataModelModType
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataModelModType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataModelModType_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataModelModTypeObject* self = (PyoaDataModelModTypeObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaDataModelModType();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaDataModelModTypeEnum)
    {
        PyParamoaDataModelModTypeEnum p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDataModelModTypeEnum_Convert,&p1)) {
            self->value =  new oaDataModelModType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            self->value =  new oaDataModelModType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaDataModelModType)
    {
        PyParamoaDataModelModType p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataModelModType_Convert,&p1)) {
            self->value= new oaDataModelModType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataModelModType, Choices are:\n"
        "    ()\n"
        "    (oaDataModelModTypeEnum)\n"
        "    (oaString)\n"
        "    (oaDataModelModType)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataModelModType_tp_dealloc(PyoaDataModelModTypeObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataModelModType_tp_repr(PyObject *ob)
{
    PyParamoaDataModelModType value;
    int convert_status=PyoaDataModelModType_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    oaString sresult(value.DataCall()->getName());

    char addr[40];
    sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
    oaString buffer;
    buffer+=oaString("<oaDataModelModType::");
    buffer+=oaString(addr);
    buffer+=oaString("::");
    buffer+=oaString(sresult);
    buffer+=oaString(">");
    result=PyString_FromString((char*)(const char*)buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataModelModType_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataModelModType v1;
    PyParamoaDataModelModType v2;
    int convert_status1=PyoaDataModelModType_Convert(ob1,&v1);
    int convert_status2=PyoaDataModelModType_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataModelModType_Convert(PyObject* ob,PyParamoaDataModelModType* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataModelModType_Check(ob)) {
        result->SetData(  ((PyoaDataModelModTypeObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataModelModType Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataModelModType_FromoaDataModelModType(oaDataModelModType* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaDataModelModType_Type.tp_alloc(&PyoaDataModelModType_Type,0);
        if (bself == NULL) return bself;
        PyoaDataModelModTypeObject* self = (PyoaDataModelModTypeObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataModelModType_getName_doc[] = 
"Class: oaDataModelModType, Function: getName\n"
"  Paramegers: ()\n"
"    Calls: const oaString& getName() const\n"
"    Signature: getName|cref-oaString|\n"
"    BrowseData: 1\n"
"    This function returns the string name that corresponds to the enum value of this oaDataModelModType class object.\n"
;

static PyObject*
oaDataModelModType_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataModelModType data;
    int convert_status=PyoaDataModelModType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataModelModTypeObject* self=(PyoaDataModelModTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaString result= (data.DataCall()->getName());
        return PyoaString_FromoaString(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataModelModType_oaDataModelModTypeEnum_doc[] = 
"Class: oaDataModelModType, Function: oaDataModelModTypeEnum\n"
"  Paramegers: ()\n"
"    Calls: oaDataModelModTypeEnum oaDataModelModTypeEnum() const\n"
"    Signature: operator oaDataModelModTypeEnum|simple-oaDataModelModTypeEnum|\n"
"    BrowseData: 1\n"
"    This operator returns the enumerated value that corresponds to the oaDataModelModType that this object represents.\n"
;

static PyObject*
oaDataModelModType_oaDataModelModTypeEnum(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataModelModType data;
    int convert_status=PyoaDataModelModType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataModelModTypeObject* self=(PyoaDataModelModTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaDataModelModTypeEnum result= (data.DataCall()->operator oaDataModelModTypeEnum());
        return PyoaDataModelModTypeEnum_FromoaDataModelModTypeEnum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaDataModelModType_assign_doc[] = 
"Class: oaDataModelModType, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataModelModType_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataModelModType data;
  int convert_status=PyoaDataModelModType_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataModelModType p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataModelModType_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataModelModType_methodlist[] = {
    {"getName",(PyCFunction)oaDataModelModType_getName,METH_VARARGS,oaDataModelModType_getName_doc},
    {"oaDataModelModTypeEnum",(PyCFunction)oaDataModelModType_oaDataModelModTypeEnum,METH_VARARGS,oaDataModelModType_oaDataModelModTypeEnum_doc},
    {"assign",(PyCFunction)oaDataModelModType_tp_assign,METH_VARARGS,oaDataModelModType_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataModelModType_doc[] = 
"Class: oaDataModelModType\n"
"  oaDataModelModTypeEnum\n"
"  The oaDataModelModType class is an enum wrapper class for oaDataModelModTypeEnum values.\n"
"  See Enum Wrappers in the Programmers Guide for a discussion of enum wrappers.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaDataModelModType()\n"
"    Signature: oaDataModelModType||\n"
"    This is the default constructor for the oaDataModelModType class enum wrapper.\n"
"  Paramegers: (oaDataModelModTypeEnum)\n"
"    Calls: oaDataModelModType(oaDataModelModTypeEnum typeIn)\n"
"    Signature: oaDataModelModType||simple-oaDataModelModTypeEnum,\n"
"    This constructor for the oaDataModelModType class enum wrapper takes an oaDataModelModTypeEnum as input.\n"
"    typeIn\n"
"    An oaDataModelModTypeEnum\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataModelModType(const oaString& name)\n"
"    Signature: oaDataModelModType||cref-oaString,\n"
"    This constructor creates an oaDataModelModType object based on the constant string value that represents the dataModelModType.\n"
"    name\n"
"    A reference to a constant oaString object that holds the dataModelModType name.\n"
"  Paramegers: (oaDataModelModType)\n"
"    Calls: (const oaDataModelModType&)\n"
"    Signature: oaDataModelModType||cref-oaDataModelModType,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataModelModType_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataModelModType",
    sizeof(PyoaDataModelModTypeObject),
    0,
    (destructor)oaDataModelModType_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataModelModType_tp_compare,	/* tp_compare */
    (reprfunc)oaDataModelModType_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataModelModType_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataModelModType_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataModelModType_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataModelModType_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataModelModType_Type)<0) {
      printf("** PyType_Ready failed for: oaDataModelModType\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataModelModType",
           (PyObject*)(&PyoaDataModelModType_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataModelModType\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataModelModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaDataModelModTypeEnum_Convert(PyObject* ob,PyParamoaDataModelModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacFutureDataModelModType")==0) { result->SetData(oacFutureDataModelModType); return 1;}
        if (strcasecmp(str,"oacAdditionDataModelModType")==0) { result->SetData(oacAdditionDataModelModType); return 1;}
        if (strcasecmp(str,"oacRemovalDataModelModType")==0) { result->SetData(oacRemovalDataModelModType); return 1;}
        if (strcasecmp(str,"oacChangeDataModelModType")==0) { result->SetData(oacChangeDataModelModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaDataModelModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataModelModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaDataModelModTypeEnum_FromoaDataModelModTypeEnum(oaDataModelModTypeEnum ob)
{
    if (ob==oacFutureDataModelModType) return PyString_FromString("oacFutureDataModelModType");
    if (ob==oacAdditionDataModelModType) return PyString_FromString("oacAdditionDataModelModType");
    if (ob==oacRemovalDataModelModType) return PyString_FromString("oacRemovalDataModelModType");
    if (ob==oacChangeDataModelModType) return PyString_FromString("oacChangeDataModelModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaDataModelModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaDataModelModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaDataModelModTypeEnum_FromoaDataModelModTypeEnum(oaDataModelModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaDataModelModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaDataModelModTypeEnum_doc[] =
"Type convert function for enum: oaDataModelModTypeEnum";
                               
static PyMethodDef PyoaDataModelModTypeEnum_method =
  {"oaDataModelModTypeEnum",(PyCFunction)PyoaDataModelModTypeEnum_TypeFunction,METH_VARARGS,oaDataModelModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaDataModelModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacFutureDataModelModType");
    PyDict_SetItemString(mod_dict,"oacFutureDataModelModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAdditionDataModelModType");
    PyDict_SetItemString(mod_dict,"oacAdditionDataModelModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacRemovalDataModelModType");
    PyDict_SetItemString(mod_dict,"oacRemovalDataModelModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacChangeDataModelModType");
    PyDict_SetItemString(mod_dict,"oacChangeDataModelModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaDataModelModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaDataModelModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaDataModelModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDatabaseCollection
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDatabaseCollection_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDatabaseCollection_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDatabaseCollectionObject* self = (PyoaDatabaseCollectionObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaDatabaseCollection(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaDatabaseCollection)
    {
        PyParamoaDatabaseCollection p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDatabaseCollection_Convert,&p1)) {
            self->value =  new oaDatabaseCollection(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDatabaseCollection, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaDatabaseCollection)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDatabaseCollection_tp_dealloc(PyoaDatabaseCollectionObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDatabaseCollection_tp_repr(PyObject *ob)
{
    PyParamoaDatabaseCollection value;
    int convert_status=PyoaDatabaseCollection_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaDatabaseCollection::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDatabaseCollection_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDatabaseCollection v1;
    PyParamoaDatabaseCollection v2;
    int convert_status1=PyoaDatabaseCollection_Convert(ob1,&v1);
    int convert_status2=PyoaDatabaseCollection_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDatabaseCollection_Convert(PyObject* ob,PyParamoaDatabaseCollection* result)
{
    if (ob == NULL) return 1;
    if (PyoaDatabaseCollection_Check(ob)) {
        result->SetData(  ((PyoaDatabaseCollectionObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDatabaseCollection Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDatabaseCollection_FromoaDatabaseCollection(oaDatabaseCollection* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaDatabaseCollection_Type.tp_alloc(&PyoaDatabaseCollection_Type,0);
        if (bself == NULL) return bself;
        PyoaDatabaseCollectionObject* self = (PyoaDatabaseCollectionObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDatabaseCollection_getCount_doc[] = 
"Class: oaDatabaseCollection, Function: getCount\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getCount() const\n"
"    Signature: getCount|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    Function getCount\n"
;

static PyObject*
oaDatabaseCollection_getCount(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDatabaseCollection data;
    int convert_status=PyoaDatabaseCollection_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDatabaseCollectionObject* self=(PyoaDatabaseCollectionObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getCount());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDatabaseCollection_includes_doc[] = 
"Class: oaDatabaseCollection, Function: includes\n"
"  Paramegers: (oaObject)\n"
"    Calls: oaBoolean includes(const oaObject* database) const\n"
"    Signature: includes|simple-oaBoolean|cptr-oaObject,\n"
"    Function includes\n"
;

static PyObject*
oaDatabaseCollection_includes(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDatabaseCollection data;
    int convert_status=PyoaDatabaseCollection_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDatabaseCollectionObject* self=(PyoaDatabaseCollectionObject*)ob;

    PyParamoaObject p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaObject_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->includes(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDatabaseCollection_isEmpty_doc[] = 
"Class: oaDatabaseCollection, Function: isEmpty\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isEmpty() const\n"
"    Signature: isEmpty|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    Function isEmpty\n"
;

static PyObject*
oaDatabaseCollection_isEmpty(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDatabaseCollection data;
    int convert_status=PyoaDatabaseCollection_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDatabaseCollectionObject* self=(PyoaDatabaseCollectionObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isEmpty());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaDatabaseCollection_assign_doc[] = 
"Class: oaDatabaseCollection, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDatabaseCollection_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDatabaseCollection data;
  int convert_status=PyoaDatabaseCollection_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDatabaseCollection p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDatabaseCollection_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDatabaseCollection_methodlist[] = {
    {"getCount",(PyCFunction)oaDatabaseCollection_getCount,METH_VARARGS,oaDatabaseCollection_getCount_doc},
    {"includes",(PyCFunction)oaDatabaseCollection_includes,METH_VARARGS,oaDatabaseCollection_includes_doc},
    {"isEmpty",(PyCFunction)oaDatabaseCollection_isEmpty,METH_VARARGS,oaDatabaseCollection_isEmpty_doc},
    {"assign",(PyCFunction)oaDatabaseCollection_tp_assign,METH_VARARGS,oaDatabaseCollection_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDatabaseCollection_doc[] = 
"Class: oaDatabaseCollection\n"
"  Class type oaDatabaseCollection\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaDatabaseCollection(oaUInt4 dbIDIn)\n"
"    Signature: oaDatabaseCollection||simple-oaUInt4,\n"
"    Constructor oaDatabaseCollection\n"
"  Paramegers: (oaDatabaseCollection)\n"
"    Calls: oaDatabaseCollection(const oaDatabaseCollection& c)\n"
"    Signature: oaDatabaseCollection||cref-oaDatabaseCollection,\n"
"    Constructor oaDatabaseCollection\n"
"  Paramegers: (oaDatabaseCollection)\n"
"    Calls: (const oaDatabaseCollection&)\n"
"    Signature: oaDatabaseCollection||cref-oaDatabaseCollection,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDatabaseCollection_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDatabaseCollection",
    sizeof(PyoaDatabaseCollectionObject),
    0,
    (destructor)oaDatabaseCollection_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDatabaseCollection_tp_compare,	/* tp_compare */
    (reprfunc)oaDatabaseCollection_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDatabaseCollection_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDatabaseCollection_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDatabaseCollection_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDatabaseCollection_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDatabaseCollection_Type)<0) {
      printf("** PyType_Ready failed for: oaDatabaseCollection\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDatabaseCollection",
           (PyObject*)(&PyoaDatabaseCollection_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDatabaseCollection\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDatabaseIter
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDatabaseIter_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDatabaseIter_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDatabaseIterObject* self = (PyoaDatabaseIterObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDatabaseCollection)
    {
        PyParamoaDatabaseCollection p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDatabaseCollection_Convert,&p1)) {
            self->value =  new oaDatabaseIter(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaDatabaseIter)
    {
        PyParamoaDatabaseIter p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDatabaseIter_Convert,&p1)) {
            self->value =  new oaDatabaseIter(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDatabaseIter, Choices are:\n"
        "    (oaDatabaseCollection)\n"
        "    (oaDatabaseIter)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDatabaseIter_tp_dealloc(PyoaDatabaseIterObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDatabaseIter_tp_repr(PyObject *ob)
{
    PyParamoaDatabaseIter value;
    int convert_status=PyoaDatabaseIter_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[36];
    sprintf(buffer,"<oaDatabaseIter::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDatabaseIter_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDatabaseIter v1;
    PyParamoaDatabaseIter v2;
    int convert_status1=PyoaDatabaseIter_Convert(ob1,&v1);
    int convert_status2=PyoaDatabaseIter_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
static PyObject*
oaDatabaseIter_getiter(PyObject *self)
{
    Py_INCREF(self);
    return self;
}

// ------------------------------------------------------------------
static PyObject*
oaDatabaseIter_iternext(PyObject *self)
{
  try {
    PyParamoaDatabaseIter ob;
    int convert_status=PyoaDatabaseIter_Convert(self,&ob);
    assert(convert_status!=0);
    oaObject* result;
    result=ob.DataCall()->getNext();
    if (result==NULL) {
       PyErr_SetObject(PyExc_StopIteration,Py_None);
       return NULL;
    }
    return PyoaObject_FromoaObject(result);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
int
PyoaDatabaseIter_Convert(PyObject* ob,PyParamoaDatabaseIter* result)
{
    if (ob == NULL) return 1;
    if (PyoaDatabaseIter_Check(ob)) {
        result->SetData(  ((PyoaDatabaseIterObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDatabaseIter Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDatabaseIter_FromoaDatabaseIter(oaDatabaseIter* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaDatabaseIter_Type.tp_alloc(&PyoaDatabaseIter_Type,0);
        if (bself == NULL) return bself;
        PyoaDatabaseIterObject* self = (PyoaDatabaseIterObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDatabaseIter_getNext_doc[] = 
"Class: oaDatabaseIter, Function: getNext\n"
"  Paramegers: ()\n"
"    Calls: oaObject* getNext()\n"
"    Signature: getNext|ptr-oaObject|\n"
"    BrowseData: 1\n"
"    Function getNext\n"
;

static PyObject*
oaDatabaseIter_getNext(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDatabaseIter data;
    int convert_status=PyoaDatabaseIter_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDatabaseIterObject* self=(PyoaDatabaseIterObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaObjectp result= (data.DataCall()->getNext());
        return PyoaObject_FromoaObject(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDatabaseIter_next_doc[] = 
"Class: oaDatabaseIter, Function: next\n"
"  Paramegers: ()\n"
"    Calls: oaObject* next()\n"
"    Signature: next|ptr-oaObject|,\n"
"    BrowseData: 1\n"
"    get next value or raise StopIteration\n"
;

static PyObject*
oaDatabaseIter_next(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDatabaseIter data;
    int convert_status=PyoaDatabaseIter_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDatabaseIterObject* self=(PyoaDatabaseIterObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaObjectp result= (data.DataCall()->getNext());
        if (result==NULL) {
            PyErr_SetObject(PyExc_StopIteration,Py_None);
            return NULL;
        }
        return PyoaObject_FromoaObject(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDatabaseIter_reset_doc[] = 
"Class: oaDatabaseIter, Function: reset\n"
"  Paramegers: ()\n"
"    Calls: void reset()\n"
"    Signature: reset|void-void|\n"
"    BrowseData: 0\n"
"    Function reset\n"
;

static PyObject*
oaDatabaseIter_reset(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDatabaseIter data;
    int convert_status=PyoaDatabaseIter_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDatabaseIterObject* self=(PyoaDatabaseIterObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->reset();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaDatabaseIter_assign_doc[] = 
"Class: oaDatabaseIter, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDatabaseIter_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDatabaseIter data;
  int convert_status=PyoaDatabaseIter_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDatabaseIter p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDatabaseIter_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDatabaseIter_methodlist[] = {
    {"getNext",(PyCFunction)oaDatabaseIter_getNext,METH_VARARGS,oaDatabaseIter_getNext_doc},
    {"next",(PyCFunction)oaDatabaseIter_next,METH_VARARGS,oaDatabaseIter_next_doc},
    {"reset",(PyCFunction)oaDatabaseIter_reset,METH_VARARGS,oaDatabaseIter_reset_doc},
    {"assign",(PyCFunction)oaDatabaseIter_tp_assign,METH_VARARGS,oaDatabaseIter_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDatabaseIter_doc[] = 
"Class: oaDatabaseIter\n"
"  Class type oaDatabaseIter\n"
"Constructors:\n"
"  Paramegers: (oaDatabaseCollection)\n"
"    Calls: oaDatabaseIter(const oaDatabaseCollection& coll)\n"
"    Signature: oaDatabaseIter||cref-oaDatabaseCollection,\n"
"    Constructor oaDatabaseIter\n"
"  Paramegers: (oaDatabaseIter)\n"
"    Calls: oaDatabaseIter(const oaDatabaseIter& iterIn)\n"
"    Signature: oaDatabaseIter||cref-oaDatabaseIter,\n"
"    Constructor oaDatabaseIter\n"
"  Paramegers: (oaDatabaseIter)\n"
"    Calls: (const oaDatabaseIter&)\n"
"    Signature: oaDatabaseIter||cref-oaDatabaseIter,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDatabaseIter_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDatabaseIter",
    sizeof(PyoaDatabaseIterObject),
    0,
    (destructor)oaDatabaseIter_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDatabaseIter_tp_compare,	/* tp_compare */
    (reprfunc)oaDatabaseIter_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDatabaseIter_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    (getiterfunc)oaDatabaseIter_getiter,	/* tp_iter */
    (iternextfunc)oaDatabaseIter_iternext,	/* tp_iternext */
    oaDatabaseIter_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDatabaseIter_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDatabaseIter_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDatabaseIter_Type)<0) {
      printf("** PyType_Ready failed for: oaDatabaseIter\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDatabaseIter",
           (PyObject*)(&PyoaDatabaseIter_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDatabaseIter\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDefNS
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDefNS_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDefNS_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDefNSObject* self = (PyoaDefNSObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaNameSpace*)  new oaDefNS();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaDefNS)
    {
        PyParamoaDefNS p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDefNS_Convert,&p1)) {
            self->value=(oaNameSpace*)  new oaDefNS(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDefNS, Choices are:\n"
        "    ()\n"
        "    (oaDefNS)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDefNS_tp_dealloc(PyoaDefNSObject* self)
{
    if (!self->borrow) {
        delete (oaDefNS*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDefNS_tp_repr(PyObject *ob)
{
    PyParamoaDefNS value;
    int convert_status=PyoaDefNS_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[29];
    sprintf(buffer,"<oaDefNS::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDefNS_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDefNS v1;
    PyParamoaDefNS v2;
    int convert_status1=PyoaDefNS_Convert(ob1,&v1);
    int convert_status2=PyoaDefNS_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDefNS_Convert(PyObject* ob,PyParamoaDefNS* result)
{
    if (ob == NULL) return 1;
    if (PyoaDefNS_Check(ob)) {
        result->SetData( (oaDefNS*) ((PyoaDefNSObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDefNS Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDefNS_FromoaDefNS(oaDefNS* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaDefNS_Type.tp_alloc(&PyoaDefNS_Type,0);
        if (bself == NULL) return bself;
        PyoaDefNSObject* self = (PyoaDefNSObject*)bself;
        self->value = (oaNameSpace*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDefNS_isEqual_doc[] = 
"Class: oaDefNS, Function: isEqual\n"
"  Paramegers: (oaScalarName,oaScalarName)\n"
"    Calls: oaBoolean isEqual(const oaScalarName& n1,const oaScalarName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaScalarName,cref-oaScalarName,\n"
"    Function isEqual\n"
"  Paramegers: (oaVectorName,oaVectorName)\n"
"    Calls: oaBoolean isEqual(const oaVectorName& n1,const oaVectorName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaVectorName,cref-oaVectorName,\n"
"    Function isEqual\n"
"  Paramegers: (oaVectorBitName,oaVectorBitName)\n"
"    Calls: oaBoolean isEqual(const oaVectorBitName& n1,const oaVectorBitName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaVectorBitName,cref-oaVectorBitName,\n"
"    Function isEqual\n"
"  Paramegers: (oaBundleName,oaBundleName)\n"
"    Calls: oaBoolean isEqual(const oaBundleName& n1,const oaBundleName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaBundleName,cref-oaBundleName,\n"
"    Function isEqual\n"
"  Paramegers: (oaSimpleName,oaSimpleName)\n"
"    Calls: oaBoolean isEqual(const oaSimpleName& n1,const oaSimpleName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaSimpleName,cref-oaSimpleName,\n"
"    Function isEqual\n"
"  Paramegers: (oaName,oaName)\n"
"    Calls: oaBoolean isEqual(const oaName& n1,const oaName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaName,cref-oaName,\n"
"    Function isEqual\n"
;

static PyObject*
oaDefNS_isEqual(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDefNS data;
    int convert_status=PyoaDefNS_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDefNSObject* self=(PyoaDefNSObject*)ob;

    // Case: (oaScalarName,oaScalarName)
    {
        PyParamoaScalarName p1;
        PyParamoaScalarName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaScalarName_Convert,&p1,
              &PyoaScalarName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaVectorName,oaVectorName)
    {
        PyParamoaVectorName p1;
        PyParamoaVectorName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaVectorName_Convert,&p1,
              &PyoaVectorName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaVectorBitName,oaVectorBitName)
    {
        PyParamoaVectorBitName p1;
        PyParamoaVectorBitName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaVectorBitName_Convert,&p1,
              &PyoaVectorBitName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBundleName,oaBundleName)
    {
        PyParamoaBundleName p1;
        PyParamoaBundleName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBundleName_Convert,&p1,
              &PyoaBundleName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName,oaSimpleName)
    {
        PyParamoaSimpleName p1;
        PyParamoaSimpleName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaSimpleName_Convert,&p1,
              &PyoaSimpleName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaName,oaName)
    {
        PyParamoaName p1;
        PyParamoaName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaName_Convert,&p1,
              &PyoaName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDefNS, function: isEqual, Choices are:\n"
        "    (oaScalarName,oaScalarName)\n"
        "    (oaVectorName,oaVectorName)\n"
        "    (oaVectorBitName,oaVectorBitName)\n"
        "    (oaBundleName,oaBundleName)\n"
        "    (oaSimpleName,oaSimpleName)\n"
        "    (oaName,oaName)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaDefNS_assign_doc[] = 
"Class: oaDefNS, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDefNS_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDefNS data;
  int convert_status=PyoaDefNS_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDefNS p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDefNS_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDefNS_methodlist[] = {
    {"isEqual",(PyCFunction)oaDefNS_isEqual,METH_VARARGS,oaDefNS_isEqual_doc},
    {"assign",(PyCFunction)oaDefNS_tp_assign,METH_VARARGS,oaDefNS_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDefNS_doc[] = 
"Class: oaDefNS\n"
"  The oaDefNS class implements the DEF nameSpace used in name mapping. The DEF name space reflects the rules for specifying legal names in DEF files. In conjunction with the oaName object, the oaDefNS class facilitates mapping names to and from DEF. See the Name Mapping Section of the Programmers Guide for more information.\n"
"  The DEF nameSpace does not support vectored or stepped names, though it supports vector bit names. This nameSpace is case sensitive with programmable bus characters. DEF has a programmable hierarchy character. See its parent class oaLefNS for the functions that set and get the bus and hierarchy characters. Since keywords in DEF are position-sensitive, they are valid as names. See the LEF/DEF Name Space Section of the Programmers Guide for a more detailed description of the characteristics of the DEF name space.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaDefNS()\n"
"    Signature: oaDefNS||\n"
"    Constructor oaDefNS\n"
"  Paramegers: (oaDefNS)\n"
"    Calls: (const oaDefNS&)\n"
"    Signature: oaDefNS||cref-oaDefNS,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDefNS_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDefNS",
    sizeof(PyoaDefNSObject),
    0,
    (destructor)oaDefNS_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDefNS_tp_compare,	/* tp_compare */
    (reprfunc)oaDefNS_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDefNS_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDefNS_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaLefNS_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDefNS_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDefNS_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDefNS_Type)<0) {
      printf("** PyType_Ready failed for: oaDefNS\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDefNS",
           (PyObject*)(&PyoaDefNS_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDefNS\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDerivedLayer
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDerivedLayer_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDerivedLayer_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDerivedLayerObject* self = (PyoaDerivedLayerObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDerivedLayer)
    {
        PyParamoaDerivedLayer p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDerivedLayer_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDerivedLayer, Choices are:\n"
        "    (oaDerivedLayer)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDerivedLayer_tp_dealloc(PyoaDerivedLayerObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDerivedLayer_tp_repr(PyObject *ob)
{
    PyParamoaDerivedLayer value;
    int convert_status=PyoaDerivedLayer_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaDerivedLayer::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaString sresult;
        value.DataCall()->getName(sresult);
    
        char addr[36];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaDerivedLayer::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDerivedLayer_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDerivedLayer v1;
    PyParamoaDerivedLayer v2;
    int convert_status1=PyoaDerivedLayer_Convert(ob1,&v1);
    int convert_status2=PyoaDerivedLayer_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDerivedLayer_Convert(PyObject* ob,PyParamoaDerivedLayer* result)
{
    if (ob == NULL) return 1;
    if (PyoaDerivedLayer_Check(ob)) {
        result->SetData( (oaDerivedLayer**) ((PyoaDerivedLayerObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDerivedLayer Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDerivedLayer_FromoaDerivedLayer(oaDerivedLayer** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDerivedLayer* data=*value;
        PyObject* bself = PyoaDerivedLayer_Type.tp_alloc(&PyoaDerivedLayer_Type,0);
        if (bself == NULL) return bself;
        PyoaDerivedLayerObject* self = (PyoaDerivedLayerObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDerivedLayer_FromoaDerivedLayer(oaDerivedLayer* data)
{
    if (data) {
       PyObject* bself = PyoaDerivedLayer_Type.tp_alloc(&PyoaDerivedLayer_Type,0);
       if (bself == NULL) return bself;
       PyoaDerivedLayerObject* self = (PyoaDerivedLayerObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDerivedLayer_getDef_doc[] = 
"Class: oaDerivedLayer, Function: getDef\n"
"  Paramegers: ()\n"
"    Calls: oaDerivedLayerDef* getDef() const\n"
"    Signature: getDef|ptr-oaDerivedLayerDef|\n"
"    BrowseData: 1\n"
"    This function returns the derived layer def used to create this derivedLayer.\n"
;

static PyObject*
oaDerivedLayer_getDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayer data;
    int convert_status=PyoaDerivedLayer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerObject* self=(PyoaDerivedLayerObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaDerivedLayerDefp result= (data.DataCall()->getDef());
        return PyoaDerivedLayerDef_FromoaDerivedLayerDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayer_getLayer1_doc[] = 
"Class: oaDerivedLayer, Function: getLayer1\n"
"  Paramegers: ()\n"
"    Calls: oaLayer* getLayer1() const\n"
"    Signature: getLayer1|ptr-oaLayer|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to layer1 , from which the derived layer was created. NULL is returned if the layer comes from an unbound technology database referenced by the owning database of this derived layer.\n"
"    If the layer is not bound, you can use the getLayer1Num to get the number of the layer.\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
;

static PyObject*
oaDerivedLayer_getLayer1(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayer data;
    int convert_status=PyoaDerivedLayer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerObject* self=(PyoaDerivedLayerObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaLayerp result= (data.DataCall()->getLayer1());
        return PyoaLayer_FromoaLayer(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayer_getLayer1Num_doc[] = 
"Class: oaDerivedLayer, Function: getLayer1Num\n"
"  Paramegers: ()\n"
"    Calls: oaLayerNum getLayer1Num() const\n"
"    Signature: getLayer1Num|simple-oaLayerNum|\n"
"    BrowseData: 1\n"
"    oaDerivedLayer::getLayer1Num\n"
"    This function returns the number of the layer1 from which this derived layer was created even if the tech database containing the layer is unbound.\n"
;

static PyObject*
oaDerivedLayer_getLayer1Num(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayer data;
    int convert_status=PyoaDerivedLayer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerObject* self=(PyoaDerivedLayerObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaLayerNum result= (data.DataCall()->getLayer1Num());
        return PyoaLayerNum_FromoaLayerNum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayer_getLayer2_doc[] = 
"Class: oaDerivedLayer, Function: getLayer2\n"
"  Paramegers: ()\n"
"    Calls: oaLayer* getLayer2() const\n"
"    Signature: getLayer2|ptr-oaLayer|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to layer2 , from which the derived layer was created. For unary layer operations, this returns the same layer as oaDerivedLayer::getLayer1() . NULL may be returned if the layer referenced comes from an unbound technology database referenced by the owning database of this derived layer.\n"
"    If the layer is not bound, you can use the getLayer2Num to get the number of the layer.\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
;

static PyObject*
oaDerivedLayer_getLayer2(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayer data;
    int convert_status=PyoaDerivedLayer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerObject* self=(PyoaDerivedLayerObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaLayerp result= (data.DataCall()->getLayer2());
        return PyoaLayer_FromoaLayer(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayer_getLayer2Num_doc[] = 
"Class: oaDerivedLayer, Function: getLayer2Num\n"
"  Paramegers: ()\n"
"    Calls: oaLayerNum getLayer2Num() const\n"
"    Signature: getLayer2Num|simple-oaLayerNum|\n"
"    BrowseData: 1\n"
"    oaDerivedLayer::getLayer2Num\n"
"    This function returns the number of the layer2 from which this derived layer was created even if the tech database containing the layer is unbound. For unary layer operations, this returns the same layer number as getlayer1Num().\n"
;

static PyObject*
oaDerivedLayer_getLayer2Num(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayer data;
    int convert_status=PyoaDerivedLayer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerObject* self=(PyoaDerivedLayerObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaLayerNum result= (data.DataCall()->getLayer2Num());
        return PyoaLayerNum_FromoaLayerNum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayer_getOperation_doc[] = 
"Class: oaDerivedLayer, Function: getOperation\n"
"  Paramegers: ()\n"
"    Calls: oaLayerOp getOperation() const\n"
"    Signature: getOperation|simple-oaLayerOp|\n"
"    BrowseData: 1\n"
"    This function returns the built-in layerOp used to create this derivedLayer, or it returns oacUserDefinedLayerOp for user-defined derived layer definitions.\n"
;

static PyObject*
oaDerivedLayer_getOperation(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayer data;
    int convert_status=PyoaDerivedLayer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerObject* self=(PyoaDerivedLayerObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaLayerOp* result= new oaLayerOp(data.DataCall()->getOperation());
        return PyoaLayerOp_FromoaLayerOp(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayer_getParams_doc[] = 
"Class: oaDerivedLayer, Function: getParams\n"
"  Paramegers: (oaDerivedLayerParamArray)\n"
"    Calls: void getParams(oaDerivedLayerParamArray& params) const\n"
"    Signature: getParams|void-void|ref-oaDerivedLayerParamArray,\n"
"    BrowseData: 0,oaDerivedLayerParamArray\n"
"    This function retrieves the parameters of this derived layer.\n"
"    params\n"
"    The retrieved parameter array.\n"
;

static PyObject*
oaDerivedLayer_getParams(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayer data;
    int convert_status=PyoaDerivedLayer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerObject* self=(PyoaDerivedLayerObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDerivedLayerParamArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaDerivedLayerParamArray_Convert,&p1)) {
        data.DataCall()->getParams(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayer_hasParams_doc[] = 
"Class: oaDerivedLayer, Function: hasParams\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean hasParams() const\n"
"    Signature: hasParams|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean that indicates whether this derived layer has any parameters.\n"
;

static PyObject*
oaDerivedLayer_hasParams(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayer data;
    int convert_status=PyoaDerivedLayer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerObject* self=(PyoaDerivedLayerObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->hasParams());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayer_setParams_doc[] = 
"Class: oaDerivedLayer, Function: setParams\n"
"  Paramegers: (oaDerivedLayerParamArray)\n"
"    Calls: void setParams(const oaDerivedLayerParamArray& params)\n"
"    Signature: setParams|void-void|cref-oaDerivedLayerParamArray,\n"
"    This function sets the parameters of this derived layer to the given parameter array.\n"
"    params\n"
"    The array of parameters to set on this derived layer.\n"
"    oacDerivedLayerParamNotInSameDB\n"
;

static PyObject*
oaDerivedLayer_setParams(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayer data;
    int convert_status=PyoaDerivedLayer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerObject* self=(PyoaDerivedLayerObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDerivedLayerParamArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaDerivedLayerParamArray_Convert,&p1)) {
        data.DataCall()->setParams(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayer_isNull_doc[] =
"Class: oaDerivedLayer, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDerivedLayer_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDerivedLayer data;
    int convert_status=PyoaDerivedLayer_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDerivedLayer_assign_doc[] = 
"Class: oaDerivedLayer, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDerivedLayer_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDerivedLayer data;
  int convert_status=PyoaDerivedLayer_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDerivedLayer p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDerivedLayer_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDerivedLayer_methodlist[] = {
    {"getDef",(PyCFunction)oaDerivedLayer_getDef,METH_VARARGS,oaDerivedLayer_getDef_doc},
    {"getLayer1",(PyCFunction)oaDerivedLayer_getLayer1,METH_VARARGS,oaDerivedLayer_getLayer1_doc},
    {"getLayer1Num",(PyCFunction)oaDerivedLayer_getLayer1Num,METH_VARARGS,oaDerivedLayer_getLayer1Num_doc},
    {"getLayer2",(PyCFunction)oaDerivedLayer_getLayer2,METH_VARARGS,oaDerivedLayer_getLayer2_doc},
    {"getLayer2Num",(PyCFunction)oaDerivedLayer_getLayer2Num,METH_VARARGS,oaDerivedLayer_getLayer2Num_doc},
    {"getOperation",(PyCFunction)oaDerivedLayer_getOperation,METH_VARARGS,oaDerivedLayer_getOperation_doc},
    {"getParams",(PyCFunction)oaDerivedLayer_getParams,METH_VARARGS,oaDerivedLayer_getParams_doc},
    {"hasParams",(PyCFunction)oaDerivedLayer_hasParams,METH_VARARGS,oaDerivedLayer_hasParams_doc},
    {"setParams",(PyCFunction)oaDerivedLayer_setParams,METH_VARARGS,oaDerivedLayer_setParams_doc},
    {"isNull",(PyCFunction)oaDerivedLayer_tp_isNull,METH_VARARGS,oaDerivedLayer_isNull_doc},
    {"assign",(PyCFunction)oaDerivedLayer_tp_assign,METH_VARARGS,oaDerivedLayer_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDerivedLayer_doc[] = 
"Class: oaDerivedLayer\n"
"  The oaDerivedLayer class defines a derived layer, which is formed from one or two layers and a derived layer definition ( oaDerivedLayerDef ). A full description of a derived layer also requires its name ( oaString ), its layer number (oaLayerNum), and its database ( oaTech ), and an optional array of parameters ( oaDerivedLayerParamArray ).\n"
"  The derived layer definition is associated with a layer operation ( oaLayerOp ) and specifies the number of parent layers for the corresponding derived layer. Built-in derived layer definitions each have their own unique oaLayerOpEnum value, but all user-defined definitions have the same layer operation, oacUserDefinedLayerOp.\n"
"  Note that for backward compatibility, oaDerivedLayer::create member functions are still supported, and they allow creating a derived layer by directly specifying the layer operation and not specifying the database. Also, an oaDerivedLayer::find member function allows immediate searching for a derived layer by layer operation as opposed to layer definition. However, these functions are deprecated.\n"
"  Some layer operations require one or more parameters, such as shrink or grow. In such cases, an oaDerivedLayerParamArray can be associated with the derived layer.\n"
"Constructors:\n"
"  Paramegers: (oaDerivedLayer)\n"
"    Calls: (const oaDerivedLayer&)\n"
"    Signature: oaDerivedLayer||cref-oaDerivedLayer,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDerivedLayer_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDerivedLayer",
    sizeof(PyoaDerivedLayerObject),
    0,
    (destructor)oaDerivedLayer_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDerivedLayer_tp_compare,	/* tp_compare */
    (reprfunc)oaDerivedLayer_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDerivedLayer_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDerivedLayer_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaLayer_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDerivedLayer_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDerivedLayer_static_create_doc[] = 
"Class: oaDerivedLayer, Function: create\n"
"  Paramegers: (oaLayer,oaLayer,oaLayerOp,oaString,oaLayerNum)\n"
"    Calls: oaDerivedLayer* create(oaLayer* layer1,oaLayer* layer2,oaLayerOp operation,const oaString& name,oaLayerNum number)\n"
"    Signature: create|ptr-oaDerivedLayer|ptr-oaLayer,ptr-oaLayer,simple-oaLayerOp,cref-oaString,simple-oaLayerNum,\n"
"    This function is deprecated and is retained to ensure compatibility with previous versions of OpenAccess. Use the create function overload that takes an oaDerivedLayerDef argument instead of the oaLayerOp argument.\n"
"    The number, name, and operation must all be unique for the specified layer1 and layer2 combination. Both layer1 and layer2 must be defined in the same technology database, and neither value may be NULL. The two layers must also be in the same technology database as the derivedLayer that is being created. Only layer operations for two layers are supported through this interface.\n"
"    layer1\n"
"    The first layer for creating the derived layer.\n"
"    layer2\n"
"    The second layer for creating the derived layer.\n"
"    operation\n"
"    The operation to use for creating this derived layer.\n"
"    name\n"
"    The unique name of the derived layer.\n"
"    number\n"
"    The unique number of the derived layer.\n"
"    oacLayer1Layer2NotInSameTech\n"
"    oacLayerNotInReferencedTech\n"
"    oacConflictingLayerNamesInTech\n"
"    oacConflictingLayerNumbersInTech\n"
"    oacLayerDerivationExists\n"
"    oacLayerNumberExists\n"
"    oacLayerNameExists\n"
"  Paramegers: (oaTech,oaLayer,oaLayer,oaLayerOp,oaString,oaLayerNum)\n"
"    Calls: oaDerivedLayer* create(oaTech* tech,oaLayer* layer1,oaLayer* layer2,oaLayerOp operation,const oaString& name,oaLayerNum number)\n"
"    Signature: create|ptr-oaDerivedLayer|ptr-oaTech,ptr-oaLayer,ptr-oaLayer,simple-oaLayerOp,cref-oaString,simple-oaLayerNum,\n"
"    This function is deprecated and is retained to ensure compatibility with previous versions of OpenAccess. Use the create function overload that takes an oaDerivedLayerDef argument instead of the oaLayerOp argument.\n"
"    The number, name, and operation must all be unique for the specified layer1 and layer2 combination. The function creates the derived layer in the specified tech database. The databases in which either of layer1 and layer2 are residing must be referenced from the technology database in which the derived layer is to be created. Only layer operations for two layers are supported through this interface.\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    tech\n"
"    The technology database in which the derived layer will be created.\n"
"    layer1\n"
"    The first layer for creating the derived layer.\n"
"    layer2\n"
"    The second layer for creating the derived layer.\n"
"    operation\n"
"    The operation to use for creating this derived layer.\n"
"    name\n"
"    The unique name of the derived layer.\n"
"    number\n"
"    The unique number of the derived layer.\n"
"    oacLayerNotInReferencedTech\n"
"    oacConflictingLayerNamesInTech\n"
"    oacConflictingLayerNumbersInTech\n"
"    oacLayerNumberExists\n"
"    oacLayerDerivationExists\n"
"    oacLayerNameExists\n"
"    oacInvalidNumLayersForDerivedLayerDef\n"
"  Paramegers: (oaTech,oaLayer,oaDerivedLayerDef,oaString,oaLayerNum)\n"
"    Calls: oaDerivedLayer* create(oaTech* tech,const oaLayer* layer,const oaDerivedLayerDef* def,const oaString& name,oaLayerNum number)\n"
"    Signature: create|ptr-oaDerivedLayer|ptr-oaTech,cptr-oaLayer,cptr-oaDerivedLayerDef,cref-oaString,simple-oaLayerNum,cptr-oaDerivedLayerParamArray,\n"
"    This function creates a derived layer with the specified name , number , and derivation. The derived layer is based on a derived layer definition. The function creates the derived layer in the specified tech database.\n"
"    The oaLayer can be in the same technology database as the derived layer being created, or it can be in any of the referenced technology databases in the graph of databases rooted at the tech that will contain the derived layer. Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    tech\n"
"    The technology database in which the derived layer will be created.\n"
"    layer\n"
"    The layer for creating the derived layer.\n"
"    def\n"
"    The definition for the derived layer.\n"
"    name\n"
"    The unique name for the derived layer.\n"
"    number\n"
"    The unique number for the derived layer.\n"
"    params\n"
"    The parameters for the derived layer.\n"
"    oacLayerNotInReferencedTech\n"
"    oacConflictingLayerNamesInTech\n"
"    oacConflictingLayerNumbersInTech\n"
"    oacLayerNumberExists\n"
"    oacLayerNameExists\n"
"    oacInvalidNumLayersForDerivedLayerDef\n"
"    oacLayerDerivationExists\n"
"    oacDerivedLayerParamAlreadyOwned\n"
"    oacDerivedLayerParamNotInSameDB\n"
"  Paramegers: (oaTech,oaLayer,oaDerivedLayerDef,oaString,oaLayerNum,oaDerivedLayerParamArray)\n"
"    Calls: oaDerivedLayer* create(oaTech* tech,const oaLayer* layer,const oaDerivedLayerDef* def,const oaString& name,oaLayerNum number,const oaDerivedLayerParamArray* params)\n"
"    Signature: create|ptr-oaDerivedLayer|ptr-oaTech,cptr-oaLayer,cptr-oaDerivedLayerDef,cref-oaString,simple-oaLayerNum,cptr-oaDerivedLayerParamArray,\n"
"    This function creates a derived layer with the specified name , number , and derivation. The derived layer is based on a derived layer definition. The function creates the derived layer in the specified tech database.\n"
"    The oaLayer can be in the same technology database as the derived layer being created, or it can be in any of the referenced technology databases in the graph of databases rooted at the tech that will contain the derived layer. Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    tech\n"
"    The technology database in which the derived layer will be created.\n"
"    layer\n"
"    The layer for creating the derived layer.\n"
"    def\n"
"    The definition for the derived layer.\n"
"    name\n"
"    The unique name for the derived layer.\n"
"    number\n"
"    The unique number for the derived layer.\n"
"    params\n"
"    The parameters for the derived layer.\n"
"    oacLayerNotInReferencedTech\n"
"    oacConflictingLayerNamesInTech\n"
"    oacConflictingLayerNumbersInTech\n"
"    oacLayerNumberExists\n"
"    oacLayerNameExists\n"
"    oacInvalidNumLayersForDerivedLayerDef\n"
"    oacLayerDerivationExists\n"
"    oacDerivedLayerParamAlreadyOwned\n"
"    oacDerivedLayerParamNotInSameDB\n"
"  Paramegers: (oaTech,oaLayer,oaLayer,oaDerivedLayerDef,oaString,oaLayerNum)\n"
"    Calls: oaDerivedLayer* create(oaTech* tech,const oaLayer* layer1,const oaLayer* layer2,const oaDerivedLayerDef* def,const oaString& name,oaLayerNum number)\n"
"    Signature: create|ptr-oaDerivedLayer|ptr-oaTech,cptr-oaLayer,cptr-oaLayer,cptr-oaDerivedLayerDef,cref-oaString,simple-oaLayerNum,cptr-oaDerivedLayerParamArray,\n"
"    create2layer\n"
"    This function creates a derived layer with the specified name , number , and derivation in the specified tech. The derived layer is based on a derived layer definition. The number and name must be unique for the specified layer1 and layer2 combination.\n"
"    layer1 and layer2 can be in the specified tech , or in one or two databases in the graph of referenced technology databases rooted at the specified tech . Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    tech\n"
"    The technology database in which the derived layer will be created.\n"
"    layer1\n"
"    The first layer for creating the derived layer.\n"
"    layer2\n"
"    The second layer for creating the derived layer.\n"
"    def\n"
"    The definition for the derived layer.\n"
"    name\n"
"    The unique name for the derived layer.\n"
"    number\n"
"    The unique number for the derived layer.\n"
"    params\n"
"    The parameters for the derived layer.\n"
"    oacLayerNumberExists\n"
"    oacLayerNameExists\n"
"    oacInvalidNumLayersForDerivedLayerDef\n"
"    oacLayerDerivationExists\n"
"  Paramegers: (oaTech,oaLayer,oaLayer,oaDerivedLayerDef,oaString,oaLayerNum,oaDerivedLayerParamArray)\n"
"    Calls: oaDerivedLayer* create(oaTech* tech,const oaLayer* layer1,const oaLayer* layer2,const oaDerivedLayerDef* def,const oaString& name,oaLayerNum number,const oaDerivedLayerParamArray* params)\n"
"    Signature: create|ptr-oaDerivedLayer|ptr-oaTech,cptr-oaLayer,cptr-oaLayer,cptr-oaDerivedLayerDef,cref-oaString,simple-oaLayerNum,cptr-oaDerivedLayerParamArray,\n"
"    create2layer\n"
"    This function creates a derived layer with the specified name , number , and derivation in the specified tech. The derived layer is based on a derived layer definition. The number and name must be unique for the specified layer1 and layer2 combination.\n"
"    layer1 and layer2 can be in the specified tech , or in one or two databases in the graph of referenced technology databases rooted at the specified tech . Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    tech\n"
"    The technology database in which the derived layer will be created.\n"
"    layer1\n"
"    The first layer for creating the derived layer.\n"
"    layer2\n"
"    The second layer for creating the derived layer.\n"
"    def\n"
"    The definition for the derived layer.\n"
"    name\n"
"    The unique name for the derived layer.\n"
"    number\n"
"    The unique number for the derived layer.\n"
"    params\n"
"    The parameters for the derived layer.\n"
"    oacLayerNumberExists\n"
"    oacLayerNameExists\n"
"    oacInvalidNumLayersForDerivedLayerDef\n"
"    oacLayerDerivationExists\n"
;

static PyObject*
oaDerivedLayer_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaLayer,oaLayer,oaLayerOp,oaString,oaLayerNum)
    {
        PyParamoaLayer p1;
        PyParamoaLayer p2;
        PyParamoaLayerOp p3;
        PyParamoaString p4;
        PyParamoaLayerNum p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaLayer_Convert,&p1,
              &PyoaLayer_Convert,&p2,
              &PyoaLayerOp_Convert,&p3,
              &PyoaString_Convert,&p4,
              &PyoaLayerNum_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDerivedLayerp result= (oaDerivedLayer::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
            return PyoaDerivedLayer_FromoaDerivedLayer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTech,oaLayer,oaLayer,oaLayerOp,oaString,oaLayerNum)
    {
        PyParamoaTech p1;
        PyParamoaLayer p2;
        PyParamoaLayer p3;
        PyParamoaLayerOp p4;
        PyParamoaString p5;
        PyParamoaLayerNum p6;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaLayer_Convert,&p2,
              &PyoaLayer_Convert,&p3,
              &PyoaLayerOp_Convert,&p4,
              &PyoaString_Convert,&p5,
              &PyoaLayerNum_Convert,&p6)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            if (!PyValidateDbObject(p3.Data(),3)) return NULL;
            oaDerivedLayerp result= (oaDerivedLayer::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data()));
            return PyoaDerivedLayer_FromoaDerivedLayer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTech,oaLayer,oaDerivedLayerDef,oaString,oaLayerNum)
    {
        PyParamoaTech p1;
        PyParamoaLayer p2;
        PyParamoaDerivedLayerDef p3;
        PyParamoaString p4;
        PyParamoaLayerNum p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaLayer_Convert,&p2,
              &PyoaDerivedLayerDef_Convert,&p3,
              &PyoaString_Convert,&p4,
              &PyoaLayerNum_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            if (!PyValidateDbObject(p3.Data(),3)) return NULL;
            oaDerivedLayerp result= (oaDerivedLayer::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
            return PyoaDerivedLayer_FromoaDerivedLayer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTech,oaLayer,oaDerivedLayerDef,oaString,oaLayerNum,oaDerivedLayerParamArray)
    {
        PyParamoaTech p1;
        PyParamoaLayer p2;
        PyParamoaDerivedLayerDef p3;
        PyParamoaString p4;
        PyParamoaLayerNum p5;
        PyParamoaDerivedLayerParamArray p6;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaLayer_Convert,&p2,
              &PyoaDerivedLayerDef_Convert,&p3,
              &PyoaString_Convert,&p4,
              &PyoaLayerNum_Convert,&p5,
              &PyoaDerivedLayerParamArray_ConvertAof,&p6)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            if (!PyValidateDbObject(p3.Data(),3)) return NULL;
            oaDerivedLayerp result= (oaDerivedLayer::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.DataAof()));
            return PyoaDerivedLayer_FromoaDerivedLayer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTech,oaLayer,oaLayer,oaDerivedLayerDef,oaString,oaLayerNum)
    {
        PyParamoaTech p1;
        PyParamoaLayer p2;
        PyParamoaLayer p3;
        PyParamoaDerivedLayerDef p4;
        PyParamoaString p5;
        PyParamoaLayerNum p6;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaLayer_Convert,&p2,
              &PyoaLayer_Convert,&p3,
              &PyoaDerivedLayerDef_Convert,&p4,
              &PyoaString_Convert,&p5,
              &PyoaLayerNum_Convert,&p6)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            if (!PyValidateDbObject(p3.Data(),3)) return NULL;
            if (!PyValidateDbObject(p4.Data(),4)) return NULL;
            oaDerivedLayerp result= (oaDerivedLayer::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data()));
            return PyoaDerivedLayer_FromoaDerivedLayer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTech,oaLayer,oaLayer,oaDerivedLayerDef,oaString,oaLayerNum,oaDerivedLayerParamArray)
    {
        PyParamoaTech p1;
        PyParamoaLayer p2;
        PyParamoaLayer p3;
        PyParamoaDerivedLayerDef p4;
        PyParamoaString p5;
        PyParamoaLayerNum p6;
        PyParamoaDerivedLayerParamArray p7;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaLayer_Convert,&p2,
              &PyoaLayer_Convert,&p3,
              &PyoaDerivedLayerDef_Convert,&p4,
              &PyoaString_Convert,&p5,
              &PyoaLayerNum_Convert,&p6,
              &PyoaDerivedLayerParamArray_ConvertAof,&p7)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            if (!PyValidateDbObject(p3.Data(),3)) return NULL;
            if (!PyValidateDbObject(p4.Data(),4)) return NULL;
            oaDerivedLayerp result= (oaDerivedLayer::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.DataAof()));
            return PyoaDerivedLayer_FromoaDerivedLayer(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDerivedLayer, function: create, Choices are:\n"
        "    (oaLayer,oaLayer,oaLayerOp,oaString,oaLayerNum)\n"
        "    (oaTech,oaLayer,oaLayer,oaLayerOp,oaString,oaLayerNum)\n"
        "    (oaTech,oaLayer,oaDerivedLayerDef,oaString,oaLayerNum)\n"
        "    (oaTech,oaLayer,oaDerivedLayerDef,oaString,oaLayerNum,oaDerivedLayerParamArray)\n"
        "    (oaTech,oaLayer,oaLayer,oaDerivedLayerDef,oaString,oaLayerNum)\n"
        "    (oaTech,oaLayer,oaLayer,oaDerivedLayerDef,oaString,oaLayerNum,oaDerivedLayerParamArray)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayer_static_find_doc[] = 
"Class: oaDerivedLayer, Function: find\n"
"  Paramegers: (oaTech,oaString)\n"
"    Calls: oaDerivedLayer* find(const oaTech* tech,const oaString& name)\n"
"    Signature: find|ptr-oaDerivedLayer|cptr-oaTech,cref-oaString,\n"
"    This function searches the specified technology database for an oaDerivedLayer object with the specified name . If the specified technology database references other technology databases, those are searched as well and the first matching derived layer is returned. To find a derived layer in the current technology database only, refer to the find function that accepts the local argument.\n"
"    If found, a pointer to the derived layer object is returned. Otherwise, NULL is returned. Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    tech\n"
"    The technology database to begin the search.\n"
"    name\n"
"    The name of the derived layer to find.\n"
"  Paramegers: (oaTech,oaString,oaBoolean)\n"
"    Calls: oaDerivedLayer* find(const oaTech* tech,const oaString& name,oaBoolean local)\n"
"    Signature: find|ptr-oaDerivedLayer|cptr-oaTech,cref-oaString,simple-oaBoolean,\n"
"    oaDerivedLayer::find2\n"
"    This function searches for a derived layer with the specified name . The local argument specifies whether (if true) to look only in the specified technology database (if false) to look in the specified technology database and all of its referenced databases. If found, a pointer to the derived layer object is returned, otherwise NULL is returned.\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    tech\n"
"    The technology database from which to start the search for the derived layer.\n"
"    name\n"
"    The name of the derived layer to find.\n"
"    local\n"
"    A boolean that specifies whether (if true) to look in the specified technology database or (if false) to look in the specified technology database and all of its referenced databases.\n"
"  Paramegers: (oaTech,oaLayerNum)\n"
"    Calls: oaDerivedLayer* find(const oaTech* tech,oaLayerNum number)\n"
"    Signature: find|ptr-oaDerivedLayer|cptr-oaTech,simple-oaLayerNum,\n"
"    This function searches the specified technology database for an oaDerivedLayer object with the specified number . If the specified technology database references other technology databases, those are searched as well and the first matching derived layer is returned. To find a derived layer in the current technology database only, refer to the find function that accepts the local argument.\n"
"    If found, a pointer to the derived layer object is returned. Otherwise, NULL is returned.\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    tech\n"
"    The technology database to search.\n"
"    number\n"
"    The number of the derived layer to find.\n"
"  Paramegers: (oaTech,oaLayerNum,oaBoolean)\n"
"    Calls: oaDerivedLayer* find(const oaTech* tech,oaLayerNum number,oaBoolean local)\n"
"    Signature: find|ptr-oaDerivedLayer|cptr-oaTech,simple-oaLayerNum,simple-oaBoolean,\n"
"    oaDerivedLayer::find3\n"
"    This function searches for a derived layer with the specified number . referenced databases looking for a derived layer with the specified number . The local argument specifies whether (if true) to look only in the specified technology database (if false) to look in the specified technology database and all of its referenced databases. If found, a pointer to the derived layer object is returned, otherwise NULL is returned.\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    tech\n"
"    The technology database from which to start the search for the derived layer.\n"
"    number\n"
"    The number of the derived layer to find.\n"
"    local\n"
"    A boolean that specifies whether (if true) to look in the specified technology database or (if false) to look in the specified technology database and all of its referenced databases.\n"
"  Paramegers: (oaTech,oaLayerNum,oaDerivedLayerDef)\n"
"    Calls: oaDerivedLayer* find(const oaTech* tech,oaLayerNum layerNum,const oaDerivedLayerDef* def)\n"
"    Signature: find|ptr-oaDerivedLayer|cptr-oaTech,simple-oaLayerNum,cptr-oaDerivedLayerDef,cptr-oaDerivedLayerParamArray,simple-oaBoolean,\n"
"    This function searches for a derived layer based on the specified layerNum and derived layer definition. The local argument specifies whether (if true) to look only in the specified technology database (if false) to look in the specified technology database and all of its referenced databases. If found, a pointer to the derived layer object is returned, otherwise NULL is returned.\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    tech\n"
"    The technology database from which to start the search for the derived layer.\n"
"    layerNum\n"
"    The number of the derived layer to search for.\n"
"    def\n"
"    The definition of the derived layer to search for.\n"
"    params\n"
"    The parameters of the derived layer to search for.\n"
"    local\n"
"    Specifies whether (if true) to look only in the specified technology database or (if false) to look in the specified technology database and all of its referenced databases.\n"
"    oacDerivedLayerParamNotInSameDB\n"
"  Paramegers: (oaTech,oaLayerNum,oaDerivedLayerDef,oaDerivedLayerParamArray)\n"
"    Calls: oaDerivedLayer* find(const oaTech* tech,oaLayerNum layerNum,const oaDerivedLayerDef* def,const oaDerivedLayerParamArray* params)\n"
"    Signature: find|ptr-oaDerivedLayer|cptr-oaTech,simple-oaLayerNum,cptr-oaDerivedLayerDef,cptr-oaDerivedLayerParamArray,simple-oaBoolean,\n"
"    This function searches for a derived layer based on the specified layerNum and derived layer definition. The local argument specifies whether (if true) to look only in the specified technology database (if false) to look in the specified technology database and all of its referenced databases. If found, a pointer to the derived layer object is returned, otherwise NULL is returned.\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    tech\n"
"    The technology database from which to start the search for the derived layer.\n"
"    layerNum\n"
"    The number of the derived layer to search for.\n"
"    def\n"
"    The definition of the derived layer to search for.\n"
"    params\n"
"    The parameters of the derived layer to search for.\n"
"    local\n"
"    Specifies whether (if true) to look only in the specified technology database or (if false) to look in the specified technology database and all of its referenced databases.\n"
"    oacDerivedLayerParamNotInSameDB\n"
"  Paramegers: (oaTech,oaLayerNum,oaDerivedLayerDef,oaDerivedLayerParamArray,oaBoolean)\n"
"    Calls: oaDerivedLayer* find(const oaTech* tech,oaLayerNum layerNum,const oaDerivedLayerDef* def,const oaDerivedLayerParamArray* params,oaBoolean local)\n"
"    Signature: find|ptr-oaDerivedLayer|cptr-oaTech,simple-oaLayerNum,cptr-oaDerivedLayerDef,cptr-oaDerivedLayerParamArray,simple-oaBoolean,\n"
"    This function searches for a derived layer based on the specified layerNum and derived layer definition. The local argument specifies whether (if true) to look only in the specified technology database (if false) to look in the specified technology database and all of its referenced databases. If found, a pointer to the derived layer object is returned, otherwise NULL is returned.\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    tech\n"
"    The technology database from which to start the search for the derived layer.\n"
"    layerNum\n"
"    The number of the derived layer to search for.\n"
"    def\n"
"    The definition of the derived layer to search for.\n"
"    params\n"
"    The parameters of the derived layer to search for.\n"
"    local\n"
"    Specifies whether (if true) to look only in the specified technology database or (if false) to look in the specified technology database and all of its referenced databases.\n"
"    oacDerivedLayerParamNotInSameDB\n"
"  Paramegers: (oaTech,oaLayerNum,oaLayerNum,oaDerivedLayerDef)\n"
"    Calls: oaDerivedLayer* find(const oaTech* tech,oaLayerNum layer1Num,oaLayerNum layer2Num,const oaDerivedLayerDef* def)\n"
"    Signature: find|ptr-oaDerivedLayer|cptr-oaTech,simple-oaLayerNum,simple-oaLayerNum,cptr-oaDerivedLayerDef,cptr-oaDerivedLayerParamArray,simple-oaBoolean,\n"
"    This function searches for a derived layer based on the specified layer1Num , layer2Num , and derived layer definition. The local argument specifies whether (if true) to look only in the specified technology database (if false) to look in the specified technology database and all of its referenced databases. If found, a pointer to the derived layer object is returned, otherwise NULL is returned.\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    tech\n"
"    The technology database from which to start the search for the derived layer.\n"
"    layer1Num\n"
"    The first layer of the derived layer to search for.\n"
"    layer2Num\n"
"    The second layer of the derived layer to search for.\n"
"    def\n"
"    The definition of the derived layer to search for.\n"
"    params\n"
"    The parameters of the derived layer to search for.\n"
"    local\n"
"    Specifies whether (if true) to look only in the specified technology database or (if false) to look in the specified technology database and all of its referenced databases.\n"
"    oacDerivedLayerParamNotInSameDB\n"
"  Paramegers: (oaTech,oaLayerNum,oaLayerNum,oaDerivedLayerDef,oaDerivedLayerParamArray)\n"
"    Calls: oaDerivedLayer* find(const oaTech* tech,oaLayerNum layer1Num,oaLayerNum layer2Num,const oaDerivedLayerDef* def,const oaDerivedLayerParamArray* params)\n"
"    Signature: find|ptr-oaDerivedLayer|cptr-oaTech,simple-oaLayerNum,simple-oaLayerNum,cptr-oaDerivedLayerDef,cptr-oaDerivedLayerParamArray,simple-oaBoolean,\n"
"    This function searches for a derived layer based on the specified layer1Num , layer2Num , and derived layer definition. The local argument specifies whether (if true) to look only in the specified technology database (if false) to look in the specified technology database and all of its referenced databases. If found, a pointer to the derived layer object is returned, otherwise NULL is returned.\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    tech\n"
"    The technology database from which to start the search for the derived layer.\n"
"    layer1Num\n"
"    The first layer of the derived layer to search for.\n"
"    layer2Num\n"
"    The second layer of the derived layer to search for.\n"
"    def\n"
"    The definition of the derived layer to search for.\n"
"    params\n"
"    The parameters of the derived layer to search for.\n"
"    local\n"
"    Specifies whether (if true) to look only in the specified technology database or (if false) to look in the specified technology database and all of its referenced databases.\n"
"    oacDerivedLayerParamNotInSameDB\n"
"  Paramegers: (oaTech,oaLayerNum,oaLayerNum,oaDerivedLayerDef,oaDerivedLayerParamArray,oaBoolean)\n"
"    Calls: oaDerivedLayer* find(const oaTech* tech,oaLayerNum layer1Num,oaLayerNum layer2Num,const oaDerivedLayerDef* def,const oaDerivedLayerParamArray* params,oaBoolean local)\n"
"    Signature: find|ptr-oaDerivedLayer|cptr-oaTech,simple-oaLayerNum,simple-oaLayerNum,cptr-oaDerivedLayerDef,cptr-oaDerivedLayerParamArray,simple-oaBoolean,\n"
"    This function searches for a derived layer based on the specified layer1Num , layer2Num , and derived layer definition. The local argument specifies whether (if true) to look only in the specified technology database (if false) to look in the specified technology database and all of its referenced databases. If found, a pointer to the derived layer object is returned, otherwise NULL is returned.\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    tech\n"
"    The technology database from which to start the search for the derived layer.\n"
"    layer1Num\n"
"    The first layer of the derived layer to search for.\n"
"    layer2Num\n"
"    The second layer of the derived layer to search for.\n"
"    def\n"
"    The definition of the derived layer to search for.\n"
"    params\n"
"    The parameters of the derived layer to search for.\n"
"    local\n"
"    Specifies whether (if true) to look only in the specified technology database or (if false) to look in the specified technology database and all of its referenced databases.\n"
"    oacDerivedLayerParamNotInSameDB\n"
"  Paramegers: (oaLayer,oaLayer,oaLayerOp)\n"
"    Calls: oaDerivedLayer* find(const oaLayer* layer1,const oaLayer* layer2,oaLayerOp operation)\n"
"    Signature: find|ptr-oaDerivedLayer|cptr-oaLayer,cptr-oaLayer,simple-oaLayerOp,\n"
"    This function searches the technology database associated with the given layers looking for a derived layer with the specified layer derivation. For this variant of find function, the given layers must be in the same technology database, and the oaDerivedLayer lookup is local to that database.\n"
"    If the derived layer is found, a pointer to the derived layer object is returned. Otherwise, NULL is returned. Only binary layer operations are supported through this interface.\n"
"    layer1\n"
"    First layer of the derivation.\n"
"    layer2\n"
"    Second layer of the derivation.\n"
"    operation\n"
"    Layer operation.\n"
"    oacLayer1Layer2NotInSameTech\n"
;

static PyObject*
oaDerivedLayer_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaTech,oaString)
    {
        PyParamoaTech p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaDerivedLayerp result= (oaDerivedLayer::find(p1.Data(),p2.Data()));
            return PyoaDerivedLayer_FromoaDerivedLayer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTech,oaString,oaBoolean)
    {
        PyParamoaTech p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaDerivedLayerp result= (oaDerivedLayer::find(p1.Data(),p2.Data(),p3.Data()));
            return PyoaDerivedLayer_FromoaDerivedLayer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTech,oaLayerNum)
    {
        PyParamoaTech p1;
        PyParamoaLayerNum p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaLayerNum_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaDerivedLayerp result= (oaDerivedLayer::find(p1.Data(),p2.Data()));
            return PyoaDerivedLayer_FromoaDerivedLayer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTech,oaLayerNum,oaBoolean)
    {
        PyParamoaTech p1;
        PyParamoaLayerNum p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaDerivedLayerp result= (oaDerivedLayer::find(p1.Data(),p2.Data(),p3.Data()));
            return PyoaDerivedLayer_FromoaDerivedLayer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTech,oaLayerNum,oaDerivedLayerDef)
    {
        PyParamoaTech p1;
        PyParamoaLayerNum p2;
        PyParamoaDerivedLayerDef p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaDerivedLayerDef_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p3.Data(),3)) return NULL;
            oaDerivedLayerp result= (oaDerivedLayer::find(p1.Data(),p2.Data(),p3.Data()));
            return PyoaDerivedLayer_FromoaDerivedLayer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTech,oaLayerNum,oaDerivedLayerDef,oaDerivedLayerParamArray)
    {
        PyParamoaTech p1;
        PyParamoaLayerNum p2;
        PyParamoaDerivedLayerDef p3;
        PyParamoaDerivedLayerParamArray p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaDerivedLayerDef_Convert,&p3,
              &PyoaDerivedLayerParamArray_ConvertAof,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p3.Data(),3)) return NULL;
            oaDerivedLayerp result= (oaDerivedLayer::find(p1.Data(),p2.Data(),p3.Data(),p4.DataAof()));
            return PyoaDerivedLayer_FromoaDerivedLayer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTech,oaLayerNum,oaDerivedLayerDef,oaDerivedLayerParamArray,oaBoolean)
    {
        PyParamoaTech p1;
        PyParamoaLayerNum p2;
        PyParamoaDerivedLayerDef p3;
        PyParamoaDerivedLayerParamArray p4;
        PyParamoaBoolean p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaDerivedLayerDef_Convert,&p3,
              &PyoaDerivedLayerParamArray_ConvertAof,&p4,
              &PyoaBoolean_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p3.Data(),3)) return NULL;
            oaDerivedLayerp result= (oaDerivedLayer::find(p1.Data(),p2.Data(),p3.Data(),p4.DataAof(),p5.Data()));
            return PyoaDerivedLayer_FromoaDerivedLayer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTech,oaLayerNum,oaLayerNum,oaDerivedLayerDef)
    {
        PyParamoaTech p1;
        PyParamoaLayerNum p2;
        PyParamoaLayerNum p3;
        PyParamoaDerivedLayerDef p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaLayerNum_Convert,&p3,
              &PyoaDerivedLayerDef_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p4.Data(),4)) return NULL;
            oaDerivedLayerp result= (oaDerivedLayer::find(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaDerivedLayer_FromoaDerivedLayer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTech,oaLayerNum,oaLayerNum,oaDerivedLayerDef,oaDerivedLayerParamArray)
    {
        PyParamoaTech p1;
        PyParamoaLayerNum p2;
        PyParamoaLayerNum p3;
        PyParamoaDerivedLayerDef p4;
        PyParamoaDerivedLayerParamArray p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaLayerNum_Convert,&p3,
              &PyoaDerivedLayerDef_Convert,&p4,
              &PyoaDerivedLayerParamArray_ConvertAof,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p4.Data(),4)) return NULL;
            oaDerivedLayerp result= (oaDerivedLayer::find(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.DataAof()));
            return PyoaDerivedLayer_FromoaDerivedLayer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTech,oaLayerNum,oaLayerNum,oaDerivedLayerDef,oaDerivedLayerParamArray,oaBoolean)
    {
        PyParamoaTech p1;
        PyParamoaLayerNum p2;
        PyParamoaLayerNum p3;
        PyParamoaDerivedLayerDef p4;
        PyParamoaDerivedLayerParamArray p5;
        PyParamoaBoolean p6;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaLayerNum_Convert,&p3,
              &PyoaDerivedLayerDef_Convert,&p4,
              &PyoaDerivedLayerParamArray_ConvertAof,&p5,
              &PyoaBoolean_Convert,&p6)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p4.Data(),4)) return NULL;
            oaDerivedLayerp result= (oaDerivedLayer::find(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.DataAof(),p6.Data()));
            return PyoaDerivedLayer_FromoaDerivedLayer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaLayer,oaLayer,oaLayerOp)
    {
        PyParamoaLayer p1;
        PyParamoaLayer p2;
        PyParamoaLayerOp p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaLayer_Convert,&p1,
              &PyoaLayer_Convert,&p2,
              &PyoaLayerOp_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDerivedLayerp result= (oaDerivedLayer::find(p1.Data(),p2.Data(),p3.Data()));
            return PyoaDerivedLayer_FromoaDerivedLayer(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDerivedLayer, function: find, Choices are:\n"
        "    (oaTech,oaString)\n"
        "    (oaTech,oaString,oaBoolean)\n"
        "    (oaTech,oaLayerNum)\n"
        "    (oaTech,oaLayerNum,oaBoolean)\n"
        "    (oaTech,oaLayerNum,oaDerivedLayerDef)\n"
        "    (oaTech,oaLayerNum,oaDerivedLayerDef,oaDerivedLayerParamArray)\n"
        "    (oaTech,oaLayerNum,oaDerivedLayerDef,oaDerivedLayerParamArray,oaBoolean)\n"
        "    (oaTech,oaLayerNum,oaLayerNum,oaDerivedLayerDef)\n"
        "    (oaTech,oaLayerNum,oaLayerNum,oaDerivedLayerDef,oaDerivedLayerParamArray)\n"
        "    (oaTech,oaLayerNum,oaLayerNum,oaDerivedLayerDef,oaDerivedLayerParamArray,oaBoolean)\n"
        "    (oaLayer,oaLayer,oaLayerOp)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDerivedLayer_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaDerivedLayer_static_create,METH_VARARGS,oaDerivedLayer_static_create_doc},
    {"static_find",(PyCFunction)oaDerivedLayer_static_find,METH_VARARGS,oaDerivedLayer_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDerivedLayer_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDerivedLayer_Type)<0) {
      printf("** PyType_Ready failed for: oaDerivedLayer\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDerivedLayer",
           (PyObject*)(&PyoaDerivedLayer_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDerivedLayer\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDerivedLayer_Type.tp_dict;
    for(method=oaDerivedLayer_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDerivedLayerConnectivityType
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDerivedLayerConnectivityType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDerivedLayerConnectivityType_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDerivedLayerConnectivityTypeObject* self = (PyoaDerivedLayerConnectivityTypeObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDerivedLayerConnectivityTypeEnum)
    {
        PyParamoaDerivedLayerConnectivityTypeEnum p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDerivedLayerConnectivityTypeEnum_Convert,&p1)) {
            self->value =  new oaDerivedLayerConnectivityType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            self->value =  new oaDerivedLayerConnectivityType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaDerivedLayerConnectivityType)
    {
        PyParamoaDerivedLayerConnectivityType p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDerivedLayerConnectivityType_Convert,&p1)) {
            self->value= new oaDerivedLayerConnectivityType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDerivedLayerConnectivityType, Choices are:\n"
        "    (oaDerivedLayerConnectivityTypeEnum)\n"
        "    (oaString)\n"
        "    (oaDerivedLayerConnectivityType)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDerivedLayerConnectivityType_tp_dealloc(PyoaDerivedLayerConnectivityTypeObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDerivedLayerConnectivityType_tp_repr(PyObject *ob)
{
    PyParamoaDerivedLayerConnectivityType value;
    int convert_status=PyoaDerivedLayerConnectivityType_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    oaString sresult(value.DataCall()->getName());

    char addr[52];
    sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
    oaString buffer;
    buffer+=oaString("<oaDerivedLayerConnectivityType::");
    buffer+=oaString(addr);
    buffer+=oaString("::");
    buffer+=oaString(sresult);
    buffer+=oaString(">");
    result=PyString_FromString((char*)(const char*)buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDerivedLayerConnectivityType_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDerivedLayerConnectivityType v1;
    PyParamoaDerivedLayerConnectivityType v2;
    int convert_status1=PyoaDerivedLayerConnectivityType_Convert(ob1,&v1);
    int convert_status2=PyoaDerivedLayerConnectivityType_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDerivedLayerConnectivityType_Convert(PyObject* ob,PyParamoaDerivedLayerConnectivityType* result)
{
    if (ob == NULL) return 1;
    if (PyoaDerivedLayerConnectivityType_Check(ob)) {
        result->SetData(  ((PyoaDerivedLayerConnectivityTypeObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDerivedLayerConnectivityType Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDerivedLayerConnectivityType_FromoaDerivedLayerConnectivityType(oaDerivedLayerConnectivityType* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaDerivedLayerConnectivityType_Type.tp_alloc(&PyoaDerivedLayerConnectivityType_Type,0);
        if (bself == NULL) return bself;
        PyoaDerivedLayerConnectivityTypeObject* self = (PyoaDerivedLayerConnectivityTypeObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDerivedLayerConnectivityType_getName_doc[] = 
"Class: oaDerivedLayerConnectivityType, Function: getName\n"
"  Paramegers: ()\n"
"    Calls: const oaString& getName() const\n"
"    Signature: getName|cref-oaString|\n"
"    BrowseData: 1\n"
"    This function returns the string name of the oaDerivedLayerConnectivityTypeEnum value that this oaDerivedLayerConnectivityType object represents.\n"
;

static PyObject*
oaDerivedLayerConnectivityType_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayerConnectivityType data;
    int convert_status=PyoaDerivedLayerConnectivityType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerConnectivityTypeObject* self=(PyoaDerivedLayerConnectivityTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaString result= (data.DataCall()->getName());
        return PyoaString_FromoaString(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayerConnectivityType_oaDerivedLayerConnectivityTypeEnum_doc[] = 
"Class: oaDerivedLayerConnectivityType, Function: oaDerivedLayerConnectivityTypeEnum\n"
"  Paramegers: ()\n"
"    Calls: oaDerivedLayerConnectivityTypeEnum oaDerivedLayerConnectivityTypeEnum() const\n"
"    Signature: operator oaDerivedLayerConnectivityTypeEnum|simple-oaDerivedLayerConnectivityTypeEnum|\n"
"    BrowseData: 1\n"
"    This operator recasts this oaDerivedLayerConnectivityType object to the oaDerivedLayerConnectivityTypeEnum value it represents.\n"
;

static PyObject*
oaDerivedLayerConnectivityType_oaDerivedLayerConnectivityTypeEnum(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayerConnectivityType data;
    int convert_status=PyoaDerivedLayerConnectivityType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerConnectivityTypeObject* self=(PyoaDerivedLayerConnectivityTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaDerivedLayerConnectivityTypeEnum result= (data.DataCall()->operator oaDerivedLayerConnectivityTypeEnum());
        return PyoaDerivedLayerConnectivityTypeEnum_FromoaDerivedLayerConnectivityTypeEnum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaDerivedLayerConnectivityType_assign_doc[] = 
"Class: oaDerivedLayerConnectivityType, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDerivedLayerConnectivityType_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDerivedLayerConnectivityType data;
  int convert_status=PyoaDerivedLayerConnectivityType_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDerivedLayerConnectivityType p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDerivedLayerConnectivityType_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDerivedLayerConnectivityType_methodlist[] = {
    {"getName",(PyCFunction)oaDerivedLayerConnectivityType_getName,METH_VARARGS,oaDerivedLayerConnectivityType_getName_doc},
    {"oaDerivedLayerConnectivityTypeEnum",(PyCFunction)oaDerivedLayerConnectivityType_oaDerivedLayerConnectivityTypeEnum,METH_VARARGS,oaDerivedLayerConnectivityType_oaDerivedLayerConnectivityTypeEnum_doc},
    {"assign",(PyCFunction)oaDerivedLayerConnectivityType_tp_assign,METH_VARARGS,oaDerivedLayerConnectivityType_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDerivedLayerConnectivityType_doc[] = 
"Class: oaDerivedLayerConnectivityType\n"
"  oaDerivedLayerConnectivityTypeEnum\n"
"  The oaDerivedLayerConnectivityType class is an enum wrapper class for oaDerivedLayerConnectivityTypeEnum values.\n"
"  See Enum Wrappers in the Programmers Guide for a discussion of enum wrappers.\n"
"Constructors:\n"
"  Paramegers: (oaDerivedLayerConnectivityTypeEnum)\n"
"    Calls: oaDerivedLayerConnectivityType(oaDerivedLayerConnectivityTypeEnum valueIn)\n"
"    Signature: oaDerivedLayerConnectivityType||simple-oaDerivedLayerConnectivityTypeEnum,\n"
"    This oaDerivedLayerParamType constructor takes an oaDerivedLayerConnectivityTypeEnum value as input.\n"
"    valueIn\n"
"    an oaDerivedLayerConnectivityTypeEnum value\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDerivedLayerConnectivityType(const oaString& name)\n"
"    Signature: oaDerivedLayerConnectivityType||cref-oaString,\n"
"    This oaDerivedLayerParamType constructor takes the string name of an oaDerivedLayerConnectivityTypeEnum value as input.\n"
"    name\n"
"    The oaString name of an oaDerivedLayerConnectivityTypeEnum value.\n"
"    oacInvalidDerivedLayerConnectivityTypeName\n"
"  Paramegers: (oaDerivedLayerConnectivityType)\n"
"    Calls: (const oaDerivedLayerConnectivityType&)\n"
"    Signature: oaDerivedLayerConnectivityType||cref-oaDerivedLayerConnectivityType,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDerivedLayerConnectivityType_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDerivedLayerConnectivityType",
    sizeof(PyoaDerivedLayerConnectivityTypeObject),
    0,
    (destructor)oaDerivedLayerConnectivityType_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDerivedLayerConnectivityType_tp_compare,	/* tp_compare */
    (reprfunc)oaDerivedLayerConnectivityType_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDerivedLayerConnectivityType_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDerivedLayerConnectivityType_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDerivedLayerConnectivityType_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDerivedLayerConnectivityType_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDerivedLayerConnectivityType_Type)<0) {
      printf("** PyType_Ready failed for: oaDerivedLayerConnectivityType\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDerivedLayerConnectivityType",
           (PyObject*)(&PyoaDerivedLayerConnectivityType_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDerivedLayerConnectivityType\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDerivedLayerConnectivityTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaDerivedLayerConnectivityTypeEnum_Convert(PyObject* ob,PyParamoaDerivedLayerConnectivityTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacSameNetDerivedLayerConnectivityType")==0) { result->SetData(oacSameNetDerivedLayerConnectivityType); return 1;}
        if (strcasecmp(str,"oacDifferentNetDerivedLayerConnectivityType")==0) { result->SetData(oacDifferentNetDerivedLayerConnectivityType); return 1;}
        if (strcasecmp(str,"oacIgnoreDerivedLayerConnectivityType")==0) { result->SetData(oacIgnoreDerivedLayerConnectivityType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaDerivedLayerConnectivityTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDerivedLayerConnectivityTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaDerivedLayerConnectivityTypeEnum_FromoaDerivedLayerConnectivityTypeEnum(oaDerivedLayerConnectivityTypeEnum ob)
{
    if (ob==oacSameNetDerivedLayerConnectivityType) return PyString_FromString("oacSameNetDerivedLayerConnectivityType");
    if (ob==oacDifferentNetDerivedLayerConnectivityType) return PyString_FromString("oacDifferentNetDerivedLayerConnectivityType");
    if (ob==oacIgnoreDerivedLayerConnectivityType) return PyString_FromString("oacIgnoreDerivedLayerConnectivityType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaDerivedLayerConnectivityTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaDerivedLayerConnectivityTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaDerivedLayerConnectivityTypeEnum_FromoaDerivedLayerConnectivityTypeEnum(oaDerivedLayerConnectivityTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaDerivedLayerConnectivityTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaDerivedLayerConnectivityTypeEnum_doc[] =
"Type convert function for enum: oaDerivedLayerConnectivityTypeEnum";
                               
static PyMethodDef PyoaDerivedLayerConnectivityTypeEnum_method =
  {"oaDerivedLayerConnectivityTypeEnum",(PyCFunction)PyoaDerivedLayerConnectivityTypeEnum_TypeFunction,METH_VARARGS,oaDerivedLayerConnectivityTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaDerivedLayerConnectivityTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacSameNetDerivedLayerConnectivityType");
    PyDict_SetItemString(mod_dict,"oacSameNetDerivedLayerConnectivityType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDifferentNetDerivedLayerConnectivityType");
    PyDict_SetItemString(mod_dict,"oacDifferentNetDerivedLayerConnectivityType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacIgnoreDerivedLayerConnectivityType");
    PyDict_SetItemString(mod_dict,"oacIgnoreDerivedLayerConnectivityType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaDerivedLayerConnectivityTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaDerivedLayerConnectivityTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaDerivedLayerConnectivityTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDerivedLayerDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDerivedLayerDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDerivedLayerDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDerivedLayerDefObject* self = (PyoaDerivedLayerDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDerivedLayerDef)
    {
        PyParamoaDerivedLayerDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDerivedLayerDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDerivedLayerDef, Choices are:\n"
        "    (oaDerivedLayerDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDerivedLayerDef_tp_dealloc(PyoaDerivedLayerDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDerivedLayerDef_tp_repr(PyObject *ob)
{
    PyParamoaDerivedLayerDef value;
    int convert_status=PyoaDerivedLayerDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[39];
    sprintf(buffer,"<oaDerivedLayerDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDerivedLayerDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDerivedLayerDef v1;
    PyParamoaDerivedLayerDef v2;
    int convert_status1=PyoaDerivedLayerDef_Convert(ob1,&v1);
    int convert_status2=PyoaDerivedLayerDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDerivedLayerDef_Convert(PyObject* ob,PyParamoaDerivedLayerDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaDerivedLayerDef_Check(ob)) {
        result->SetData( (oaDerivedLayerDef**) ((PyoaDerivedLayerDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDerivedLayerDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDerivedLayerDef_FromoaDerivedLayerDef(oaDerivedLayerDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDerivedLayerDef* data=*value;
        PyObject* bself = PyoaDerivedLayerDef_Type.tp_alloc(&PyoaDerivedLayerDef_Type,0);
        if (bself == NULL) return bself;
        PyoaDerivedLayerDefObject* self = (PyoaDerivedLayerDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDerivedLayerDef_FromoaDerivedLayerDef(oaDerivedLayerDef* data)
{
    if (data) {
       PyObject* bself = PyoaDerivedLayerDef_Type.tp_alloc(&PyoaDerivedLayerDef_Type,0);
       if (bself == NULL) return bself;
       PyoaDerivedLayerDefObject* self = (PyoaDerivedLayerDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDerivedLayerDef_destroy_doc[] = 
"Class: oaDerivedLayerDef, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function destroys this oaDerivedLayerDef object.\n"
"    oacUnableToDestroyBuiltInType\n"
"    oacDerivedLayerParamDefHasReference\n"
"    Todo\n"
"    Check description of member function.\n"
;

static PyObject*
oaDerivedLayerDef_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayerDef data;
    int convert_status=PyoaDerivedLayerDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerDefObject* self=(PyoaDerivedLayerDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayerDef_getName_doc[] = 
"Class: oaDerivedLayerDef, Function: getName\n"
"  Paramegers: (oaString)\n"
"    Calls: void getName(oaString& name) const\n"
"    Signature: getName|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function returns the name of this derived layer definition.\n"
"    name\n"
"    A reference to the string name of this derived layer definition.\n"
;

static PyObject*
oaDerivedLayerDef_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayerDef data;
    int convert_status=PyoaDerivedLayerDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerDefObject* self=(PyoaDerivedLayerDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayerDef_getNumLayers_doc[] = 
"Class: oaDerivedLayerDef, Function: getNumLayers\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumLayers() const\n"
"    Signature: getNumLayers|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of input layers for a derived layer specified with this definiion.\n"
;

static PyObject*
oaDerivedLayerDef_getNumLayers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayerDef data;
    int convert_status=PyoaDerivedLayerDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerDefObject* self=(PyoaDerivedLayerDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumLayers());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayerDef_remove_doc[] = 
"Class: oaDerivedLayerDef, Function: remove\n"
"  Paramegers: (oaTech)\n"
"    Calls: void remove(oaTech* tech)\n"
"    Signature: remove|void-void|ptr-oaTech,\n"
"    This function removes this derived layer definition from the specified database. All derived layers are destroyed in the database that references this definition.\n"
"    tech\n"
"    The technology database containing the derived layer definition.\n"
"    Todo\n"
"    Check description of each parameter.\n"
;

static PyObject*
oaDerivedLayerDef_remove(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayerDef data;
    int convert_status=PyoaDerivedLayerDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerDefObject* self=(PyoaDerivedLayerDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTech p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTech_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->remove(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayerDef_isNull_doc[] =
"Class: oaDerivedLayerDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDerivedLayerDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDerivedLayerDef data;
    int convert_status=PyoaDerivedLayerDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDerivedLayerDef_assign_doc[] = 
"Class: oaDerivedLayerDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDerivedLayerDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDerivedLayerDef data;
  int convert_status=PyoaDerivedLayerDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDerivedLayerDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDerivedLayerDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDerivedLayerDef_methodlist[] = {
    {"destroy",(PyCFunction)oaDerivedLayerDef_destroy,METH_VARARGS,oaDerivedLayerDef_destroy_doc},
    {"getName",(PyCFunction)oaDerivedLayerDef_getName,METH_VARARGS,oaDerivedLayerDef_getName_doc},
    {"getNumLayers",(PyCFunction)oaDerivedLayerDef_getNumLayers,METH_VARARGS,oaDerivedLayerDef_getNumLayers_doc},
    {"remove",(PyCFunction)oaDerivedLayerDef_remove,METH_VARARGS,oaDerivedLayerDef_remove_doc},
    {"isNull",(PyCFunction)oaDerivedLayerDef_tp_isNull,METH_VARARGS,oaDerivedLayerDef_isNull_doc},
    {"assign",(PyCFunction)oaDerivedLayerDef_tp_assign,METH_VARARGS,oaDerivedLayerDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDerivedLayerDef_doc[] = 
"Class: oaDerivedLayerDef\n"
"  This class determines the number of parent layers for the corresponding derived layer. For each of the oaLayerOpEnum items, except oacUserDefinedLayerOp, there is a built-in oaDerivedLayerDef object. oacUserDefinedLayerOp is the oaLayerOpEnum value for any user-defined derived layer.\n"
"Constructors:\n"
"  Paramegers: (oaDerivedLayerDef)\n"
"    Calls: (const oaDerivedLayerDef&)\n"
"    Signature: oaDerivedLayerDef||cref-oaDerivedLayerDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDerivedLayerDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDerivedLayerDef",
    sizeof(PyoaDerivedLayerDefObject),
    0,
    (destructor)oaDerivedLayerDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDerivedLayerDef_tp_compare,	/* tp_compare */
    (reprfunc)oaDerivedLayerDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDerivedLayerDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDerivedLayerDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaSessionObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDerivedLayerDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDerivedLayerDef_static_create_doc[] = 
"Class: oaDerivedLayerDef, Function: create\n"
"  Paramegers: (oaString,oaUInt4)\n"
"    Calls: oaDerivedLayerDef* create(const oaString& name,oaUInt4 numLayers)\n"
"    Signature: create|ptr-oaDerivedLayerDef|cref-oaString,simple-oaUInt4,\n"
"    This function creates a new, user-defined layer definition.\n"
"    name\n"
"    numLayers\n"
"    oacDerivedLayerDefExists\n"
"    Todo\n"
"    Add description of member function. Add description of each parameter.\n"
;

static PyObject*
oaDerivedLayerDef_static_create(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaString p1;
    PyParamoaUInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaString_Convert,&p1,
          &PyoaUInt4_Convert,&p2)) {
        oaDerivedLayerDefp result= (oaDerivedLayerDef::create(p1.Data(),p2.Data()));
        return PyoaDerivedLayerDef_FromoaDerivedLayerDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayerDef_static_find_doc[] = 
"Class: oaDerivedLayerDef, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDerivedLayerDef* find(const oaString& name)\n"
"    Signature: find|ptr-oaDerivedLayerDef|cref-oaString,\n"
"    This function returns the derived layer definition with the name specified. If no definition by that name is found, NULL is returned.\n"
"    name\n"
"    The string name of the derived layer to find.\n"
;

static PyObject*
oaDerivedLayerDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        oaDerivedLayerDefp result= (oaDerivedLayerDef::find(p1.Data()));
        return PyoaDerivedLayerDef_FromoaDerivedLayerDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayerDef_static_get_doc[] = 
"Class: oaDerivedLayerDef, Function: get\n"
"  Paramegers: (oaLayerOp)\n"
"    Calls: oaDerivedLayerDef* get(oaLayerOp type)\n"
"    Signature: get|ptr-oaDerivedLayerDef|simple-oaLayerOp,\n"
"    This function returns the built-in layer definitions for the specified oaLayerOp object.\n"
"    type\n"
"    The type of the layer operation.\n"
"    Todo\n"
"    Check description of member function. Add description of each parameter.\n"
;

static PyObject*
oaDerivedLayerDef_static_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaLayerOp p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaLayerOp_Convert,&p1)) {
        oaDerivedLayerDefp result= (oaDerivedLayerDef::get(p1.Data()));
        return PyoaDerivedLayerDef_FromoaDerivedLayerDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDerivedLayerDef_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaDerivedLayerDef_static_create,METH_VARARGS,oaDerivedLayerDef_static_create_doc},
    {"static_find",(PyCFunction)oaDerivedLayerDef_static_find,METH_VARARGS,oaDerivedLayerDef_static_find_doc},
    {"static_get",(PyCFunction)oaDerivedLayerDef_static_get,METH_VARARGS,oaDerivedLayerDef_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDerivedLayerDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDerivedLayerDef_Type)<0) {
      printf("** PyType_Ready failed for: oaDerivedLayerDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDerivedLayerDef",
           (PyObject*)(&PyoaDerivedLayerDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDerivedLayerDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDerivedLayerDef_Type.tp_dict;
    for(method=oaDerivedLayerDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDerivedLayerModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaDerivedLayerModTypeEnum_Convert(PyObject* ob,PyParamoaDerivedLayerModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacSetNumLayersDerivedLayerModType")==0) { result->SetData(oacSetNumLayersDerivedLayerModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaDerivedLayerModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDerivedLayerModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaDerivedLayerModTypeEnum_FromoaDerivedLayerModTypeEnum(oaDerivedLayerModTypeEnum ob)
{
    if (ob==oacSetNumLayersDerivedLayerModType) return PyString_FromString("oacSetNumLayersDerivedLayerModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaDerivedLayerModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaDerivedLayerModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaDerivedLayerModTypeEnum_FromoaDerivedLayerModTypeEnum(oaDerivedLayerModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaDerivedLayerModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaDerivedLayerModTypeEnum_doc[] =
"Type convert function for enum: oaDerivedLayerModTypeEnum";
                               
static PyMethodDef PyoaDerivedLayerModTypeEnum_method =
  {"oaDerivedLayerModTypeEnum",(PyCFunction)PyoaDerivedLayerModTypeEnum_TypeFunction,METH_VARARGS,oaDerivedLayerModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaDerivedLayerModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacSetNumLayersDerivedLayerModType");
    PyDict_SetItemString(mod_dict,"oacSetNumLayersDerivedLayerModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaDerivedLayerModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaDerivedLayerModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaDerivedLayerModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDerivedLayerParam
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDerivedLayerParam_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDerivedLayerParam_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDerivedLayerParamObject* self = (PyoaDerivedLayerParamObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDerivedLayerParam)
    {
        PyParamoaDerivedLayerParam p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDerivedLayerParam_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDerivedLayerParam, Choices are:\n"
        "    (oaDerivedLayerParam)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDerivedLayerParam_tp_dealloc(PyoaDerivedLayerParamObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDerivedLayerParam_tp_repr(PyObject *ob)
{
    PyParamoaDerivedLayerParam value;
    int convert_status=PyoaDerivedLayerParam_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[41];
    sprintf(buffer,"<oaDerivedLayerParam::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDerivedLayerParam_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDerivedLayerParam v1;
    PyParamoaDerivedLayerParam v2;
    int convert_status1=PyoaDerivedLayerParam_Convert(ob1,&v1);
    int convert_status2=PyoaDerivedLayerParam_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDerivedLayerParam_Convert(PyObject* ob,PyParamoaDerivedLayerParam* result)
{
    if (ob == NULL) return 1;
    if (PyoaDerivedLayerParam_Check(ob)) {
        result->SetData( (oaDerivedLayerParam**) ((PyoaDerivedLayerParamObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDerivedLayerParam Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDerivedLayerParam_FromoaDerivedLayerParam(oaDerivedLayerParam** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDerivedLayerParam* data=*value;
        PyObject* bself = PyoaDerivedLayerParam_Type.tp_alloc(&PyoaDerivedLayerParam_Type,0);
        if (bself == NULL) return bself;
        PyoaDerivedLayerParamObject* self = (PyoaDerivedLayerParamObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDerivedLayerParam_FromoaDerivedLayerParam(oaDerivedLayerParam* data)
{
    if (data) {
       PyObject* bself = PyoaDerivedLayerParam_Type.tp_alloc(&PyoaDerivedLayerParam_Type,0);
       if (bself == NULL) return bself;
       PyoaDerivedLayerParamObject* self = (PyoaDerivedLayerParamObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDerivedLayerParam_copy_doc[] = 
"Class: oaDerivedLayerParam, Function: copy\n"
"  Paramegers: ()\n"
"    Calls: oaDerivedLayerParam* copy() const\n"
"    Signature: copy|ptr-oaDerivedLayerParam|\n"
"    BrowseData: 1\n"
"    This function copies this parameter and returns a pointer to the copy.\n"
"    Todo\n"
"    Check description of member function.\n"
;

static PyObject*
oaDerivedLayerParam_copy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayerParam data;
    int convert_status=PyoaDerivedLayerParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerParamObject* self=(PyoaDerivedLayerParamObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaDerivedLayerParamp result= (data.DataCall()->copy());
        return PyoaDerivedLayerParam_FromoaDerivedLayerParam(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayerParam_copyTo_doc[] = 
"Class: oaDerivedLayerParam, Function: copyTo\n"
"  Paramegers: (oaObject)\n"
"    Calls: oaDerivedLayerParam* copyTo(oaObject* database) const\n"
"    Signature: copyTo|ptr-oaDerivedLayerParam|ptr-oaObject,\n"
"    This function copies this derived layer parameter to the specified database. A pointer to the new derived layer parameter is returned.\n"
"    database\n"
"    oacValueInvalidForDerivedLayerParamDef\n"
"    Todo\n"
"    Check description of member function. Add description of each parameter.\n"
;

static PyObject*
oaDerivedLayerParam_copyTo(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayerParam data;
    int convert_status=PyoaDerivedLayerParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerParamObject* self=(PyoaDerivedLayerParamObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaObject p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaObject_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaDerivedLayerParamp result= (data.DataCall()->copyTo(p1.Data()));
        return PyoaDerivedLayerParam_FromoaDerivedLayerParam(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayerParam_destroy_doc[] = 
"Class: oaDerivedLayerParam, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function destroys this parameter, and all of its associated values. If the parameter is owned by a derived layer, an error is thrown.\n"
"    oacCantDestroyOwnedDerivedLayerParam\n"
"    Todo\n"
"    Check description of member function.\n"
;

static PyObject*
oaDerivedLayerParam_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayerParam data;
    int convert_status=PyoaDerivedLayerParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerParamObject* self=(PyoaDerivedLayerParamObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayerParam_getDef_doc[] = 
"Class: oaDerivedLayerParam, Function: getDef\n"
"  Paramegers: ()\n"
"    Calls: oaDerivedLayerParamDef* getDef() const\n"
"    Signature: getDef|ptr-oaDerivedLayerParamDef|\n"
"    BrowseData: 1\n"
"    This function returns the definition for this derived layer parameter.\n"
"    Todo\n"
"    Check description of member function.\n"
;

static PyObject*
oaDerivedLayerParam_getDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayerParam data;
    int convert_status=PyoaDerivedLayerParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerParamObject* self=(PyoaDerivedLayerParamObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaDerivedLayerParamDefp result= (data.DataCall()->getDef());
        return PyoaDerivedLayerParamDef_FromoaDerivedLayerParamDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayerParam_getValue_doc[] = 
"Class: oaDerivedLayerParam, Function: getValue\n"
"  Paramegers: ()\n"
"    Calls: oaValue* getValue() const\n"
"    Signature: getValue|ptr-oaValue|\n"
"    BrowseData: 1\n"
"    This function returns the value for this derived layer parameter.\n"
"    Todo\n"
"    Check description of member function.\n"
;

static PyObject*
oaDerivedLayerParam_getValue(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayerParam data;
    int convert_status=PyoaDerivedLayerParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerParamObject* self=(PyoaDerivedLayerParamObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaValuep result= (data.DataCall()->getValue());
        return PyoaValue_FromoaValue(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayerParam_isOwned_doc[] = 
"Class: oaDerivedLayerParam, Function: isOwned\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isOwned() const\n"
"    Signature: isOwned|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether this parameter is owned by a derived layer.\n"
"    Todo\n"
"    Check description of member function.\n"
;

static PyObject*
oaDerivedLayerParam_isOwned(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayerParam data;
    int convert_status=PyoaDerivedLayerParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerParamObject* self=(PyoaDerivedLayerParamObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isOwned());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayerParam_setValue_doc[] = 
"Class: oaDerivedLayerParam, Function: setValue\n"
"  Paramegers: (oaValue)\n"
"    Calls: void setValue(oaValue* value)\n"
"    Signature: setValue|void-void|ptr-oaValue,\n"
"    This function sets the value for this derived layer parameter.\n"
"    value\n"
"    oacValueAlreadyOwned\n"
"    oacValueNotInSameDatabase\n"
"    oacValueInvalidForDerivedLayerParamDef\n"
"    Todo\n"
"    Check description of member function. Add description of each parameter.\n"
;

static PyObject*
oaDerivedLayerParam_setValue(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayerParam data;
    int convert_status=PyoaDerivedLayerParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerParamObject* self=(PyoaDerivedLayerParamObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaValue p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaValue_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->setValue(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayerParam_isNull_doc[] =
"Class: oaDerivedLayerParam, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDerivedLayerParam_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDerivedLayerParam data;
    int convert_status=PyoaDerivedLayerParam_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDerivedLayerParam_assign_doc[] = 
"Class: oaDerivedLayerParam, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDerivedLayerParam_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDerivedLayerParam data;
  int convert_status=PyoaDerivedLayerParam_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDerivedLayerParam p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDerivedLayerParam_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDerivedLayerParam_methodlist[] = {
    {"copy",(PyCFunction)oaDerivedLayerParam_copy,METH_VARARGS,oaDerivedLayerParam_copy_doc},
    {"copyTo",(PyCFunction)oaDerivedLayerParam_copyTo,METH_VARARGS,oaDerivedLayerParam_copyTo_doc},
    {"destroy",(PyCFunction)oaDerivedLayerParam_destroy,METH_VARARGS,oaDerivedLayerParam_destroy_doc},
    {"getDef",(PyCFunction)oaDerivedLayerParam_getDef,METH_VARARGS,oaDerivedLayerParam_getDef_doc},
    {"getValue",(PyCFunction)oaDerivedLayerParam_getValue,METH_VARARGS,oaDerivedLayerParam_getValue_doc},
    {"isOwned",(PyCFunction)oaDerivedLayerParam_isOwned,METH_VARARGS,oaDerivedLayerParam_isOwned_doc},
    {"setValue",(PyCFunction)oaDerivedLayerParam_setValue,METH_VARARGS,oaDerivedLayerParam_setValue_doc},
    {"isNull",(PyCFunction)oaDerivedLayerParam_tp_isNull,METH_VARARGS,oaDerivedLayerParam_isNull_doc},
    {"assign",(PyCFunction)oaDerivedLayerParam_tp_assign,METH_VARARGS,oaDerivedLayerParam_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDerivedLayerParam_doc[] = 
"Class: oaDerivedLayerParam\n"
"  This class creates the parameters associated with a derived layer.\n"
"  Todo\n"
"  Check detailed description of class.\n"
"Constructors:\n"
"  Paramegers: (oaDerivedLayerParam)\n"
"    Calls: (const oaDerivedLayerParam&)\n"
"    Signature: oaDerivedLayerParam||cref-oaDerivedLayerParam,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDerivedLayerParam_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDerivedLayerParam",
    sizeof(PyoaDerivedLayerParamObject),
    0,
    (destructor)oaDerivedLayerParam_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDerivedLayerParam_tp_compare,	/* tp_compare */
    (reprfunc)oaDerivedLayerParam_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDerivedLayerParam_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDerivedLayerParam_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaTechObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDerivedLayerParam_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDerivedLayerParam_static_create_doc[] = 
"Class: oaDerivedLayerParam, Function: create\n"
"  Paramegers: (oaDerivedLayerParamDef,oaValue)\n"
"    Calls: oaDerivedLayerParam* create(const oaDerivedLayerParamDef* def,oaValue* value)\n"
"    Signature: create|ptr-oaDerivedLayerParam|cptr-oaDerivedLayerParamDef,ptr-oaValue,\n"
"    This function creates a derived layer parameter in the same database as the value specified.\n"
"    def\n"
"    value\n"
"    oacValueAlreadyOwned\n"
"    oacValueInvalidForDerivedLayerParamDef\n"
"    Todo\n"
"    Check description of member function. Add description of each parameter.\n"
;

static PyObject*
oaDerivedLayerParam_static_create(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayerParamDef p1;
    PyParamoaValue p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaDerivedLayerParamDef_Convert,&p1,
          &PyoaValue_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!PyValidateDbObject(p2.Data(),2)) return NULL;
        oaDerivedLayerParamp result= (oaDerivedLayerParam::create(p1.Data(),p2.Data()));
        return PyoaDerivedLayerParam_FromoaDerivedLayerParam(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDerivedLayerParam_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaDerivedLayerParam_static_create,METH_VARARGS,oaDerivedLayerParam_static_create_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDerivedLayerParam_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDerivedLayerParam_Type)<0) {
      printf("** PyType_Ready failed for: oaDerivedLayerParam\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDerivedLayerParam",
           (PyObject*)(&PyoaDerivedLayerParam_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDerivedLayerParam\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDerivedLayerParam_Type.tp_dict;
    for(method=oaDerivedLayerParam_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


// ==================================================================
// Array for class: oaDerivedLayerParam
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDerivedLayerParam_Array_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDerivedLayerParam_Array_Type);
    PyObject* gself = type->tp_alloc(type,0);
    if (gself == NULL) return gself;
    PyoaDerivedLayerParam_ArrayObject* self = (PyoaDerivedLayerParam_ArrayObject*)gself;
    self->borrow = 0;
    self->locks=NULL;
    static char *kwlist [] = { NULL } ;
    /* Case: () */ 
    {
        if (PyArg_ParseTuple(args,"")) {
            return gself;
        }
    }
    PyErr_Clear();
    /* Case: (int) */
    {
        int p1;
        if (PyArg_ParseTuple(args,(char*)"i",&p1)) {
            self->data.SetLen(p1);
            return gself;
        }
    }
    PyErr_Clear();
    /* Case: (oaDerivedLayerParam_Array) */
    {
        PyParamoaDerivedLayerParam_Array p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDerivedLayerParam_Array_Convert,&p1)) {
            self->data.TakeAway(p1);
            return gself;
        }
    }
    /* Error */
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDerivedLayerParam_Array, Choices are:\n"
        "    ()\n"
        "    (int)\n"
        "    (oaDerivedLayerParam_Array)\n"
    );
    Py_DECREF(gself);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDerivedLayerParam_Array_dealloc(PyObject* gself)
{
    PyoaDerivedLayerParam_ArrayObject* self = (PyoaDerivedLayerParam_ArrayObject*)gself;
    Py_XDECREF(self->locks);
    self->ob_type->tp_free(gself);
}

// ------------------------------------------------------------------
static PyObject*
oaDerivedLayerParam_Array_str(PyObject *ob)
{
    PyParamoaDerivedLayerParam_Array value;
    int convert_status=PyoaDerivedLayerParam_Array_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* lst=PyoaDerivedLayerParam_Array_CreateList(value);
    PyObject* result=PyObject_Str(lst);
    Py_DECREF(lst);
    return result;
}

// ------------------------------------------------------------------
static PyObject*
oaDerivedLayerParam_Array_repr(PyObject *ob)
{
    PyParamoaDerivedLayerParam_Array value;
    int convert_status=PyoaDerivedLayerParam_Array_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* lst=PyoaDerivedLayerParam_Array_CreateList(value);
    PyObject* result=PyObject_Repr(lst);
    Py_DECREF(lst);
    return result;
}

// ------------------------------------------------------------------
static int
oaDerivedLayerParam_Array_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDerivedLayerParam_Array p1;
    PyParamoaDerivedLayerParam_Array p2;
    int s1=PyoaDerivedLayerParam_Array_Convert(ob1,&p1);
    int s2=PyoaDerivedLayerParam_Array_Convert(ob2,&p2);
    assert(s1!=0);
    assert(s2!=0);
    PyObject* l1=PyoaDerivedLayerParam_Array_CreateList(p1);
    PyObject* l2=PyoaDerivedLayerParam_Array_CreateList(p2);
    int result=PyObject_Compare(l1,l2);
    Py_DECREF(l1);
    Py_DECREF(l2);
    return result;
}

// ------------------------------------------------------------------
int
PyoaDerivedLayerParam_Array_Convert(PyObject* ob,PyParamoaDerivedLayerParam_Array* result)
{
  Pyoa_ssize_t len,i;
  if (PyoaDerivedLayerParam_Array_Check(ob)) {
    PyoaDerivedLayerParam_ArrayObject* self = (PyoaDerivedLayerParam_ArrayObject*)ob;
    result->Borrow(self->data);
  }
  else if (PyList_Check(ob)) {
    len=PyList_Size(ob);
    result->SetLen(len);
    PyParamoaDerivedLayerParam data;
    for(i=0;i<len;i++) {
      PyObject* a=PyList_GetItem(ob,i);
      if (!PyoaDerivedLayerParam_Convert(a,&data)) return 0;
      result->SetItem(i,data.Data());
    }
  }
  else if (PyTuple_Check(ob)) {
    len=PyTuple_Size(ob);
    result->SetLen(len);
    PyParamoaDerivedLayerParam data;
    for(i=0;i<len;i++) {
      PyObject* a=PyTuple_GetItem(ob,i);
      if (!PyoaDerivedLayerParam_Convert(a,&data)) return 0;
      result->SetItem(i,data.Data());
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError,
      "Convertion of parameter to class: oaDerivedLayerParam_Array Failed");
    return 0;
  }
  return 1;
}

// ------------------------------------------------------------------
PyObject* PyoaDerivedLayerParam_Array_FromoaDerivedLayerParam_Array(const oaDerivedLayerParam_Array& value)
{
  PyObject* gself = PyoaDerivedLayerParam_Array_Type.tp_alloc(&PyoaDerivedLayerParam_Array_Type,0);
  if (gself == NULL) return gself;
  PyoaDerivedLayerParam_ArrayObject* self = (PyoaDerivedLayerParam_ArrayObject*)gself;
  self->data = value;
  self->borrow = 0;
  self->locks=NULL;
  return gself;
}

// ------------------------------------------------------------------
PyObject* PyoaDerivedLayerParam_Array_FromoaDerivedLayerParam_Array(PyTypeoaDerivedLayerParam* data,Pyoa_ssize_t len,PyObject* lock)
{
  PyObject* gself = PyoaDerivedLayerParam_Array_Type.tp_alloc(&PyoaDerivedLayerParam_Array_Type,0);
  if (gself == NULL) return gself;
  PyoaDerivedLayerParam_ArrayObject* self = (PyoaDerivedLayerParam_ArrayObject*)gself;
  self->data.Borrow(data,len);
  self->borrow = 1;
  self->locks=NULL;
  if (lock) PyoaLockObject(self->locks,lock);
  return gself;
}

// ------------------------------------------------------------------
PyObject* PyoaDerivedLayerParam_Array_CreateList(PyParamoaDerivedLayerParam_Array& value)
{
  Pyoa_ssize_t i;
  PyObject* lst=PyList_New(value.Len());
  for(i=0;i<value.Len();i++) {
    PyObject* ob=PyoaDerivedLayerParam_FromoaDerivedLayerParam(value.Data()[i]);
    PyList_SetItem(lst,i,ob);
  }
  return lst;
}

// ------------------------------------------------------------------
// Methods
// ------------------------------------------------------------------
static char oaDerivedLayerParam_Array_assign_doc[] = 
"Class: oaDerivedLayerParam_Array, Function: assign\n"
"  Paramegers: (oaDerivedLayerParam_Array)\n"
"    This function assigns the current value.\n"
;

static PyObject*
oaDerivedLayerParam_Array_assign(PyObject* ob, PyObject *args)
{
  PyoaDerivedLayerParam_ArrayObject* self=(PyoaDerivedLayerParam_ArrayObject*)ob;
  try {
    PyParamoaDerivedLayerParam_Array p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDerivedLayerParam_Array_Convert,&p1)) {
        self->data=p1;
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}
// ------------------------------------------------------------------
static char oaDerivedLayerParam_Array_list_doc[] = 
"Class: oaDerivedLayerParam_Array, Function: list\n"
"  Paramegers: ()\n"
"    This function returns the current value as a list.\n"
;

static PyObject*
oaDerivedLayerParam_Array_list(PyObject* ob, PyObject *args)
{
  PyoaDerivedLayerParam_ArrayObject* self=(PyoaDerivedLayerParam_ArrayObject*)ob;
  try {
    if (PyArg_ParseTuple(args,(char*)"")) {
      return PyoaDerivedLayerParam_Array_CreateList(self->data);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}
// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------
static PyMethodDef oaDerivedLayerParam_Array_methodlist[] = {
    {"assign",(PyCFunction)oaDerivedLayerParam_Array_assign,METH_VARARGS,oaDerivedLayerParam_Array_assign_doc},
    {"list",(PyCFunction)oaDerivedLayerParam_Array_list,METH_VARARGS,oaDerivedLayerParam_Array_list_doc},
   {NULL,NULL,0,NULL}
};

// ------------------------------------------------------------------
static PyObject*
oaDerivedLayerParam_Array_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaDerivedLayerParam_ArrayObject* self=(PyoaDerivedLayerParam_ArrayObject*)ob;
  try {
    PyParamoaDerivedLayerParam_Array data;
    int convert_status=PyoaDerivedLayerParam_Array_Convert(ob,&data);
    assert(convert_status!=0);
    if (index<0 || index>=data.Len()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    return PyoaDerivedLayerParam_FromoaDerivedLayerParam(data.GetItemPtr(index),1,self->locks);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static Pyoa_ssize_t
oaDerivedLayerParam_Array_index_get_length(PyObject* ob)
{
    PyParamoaDerivedLayerParam_Array data;
    int convert_status=PyoaDerivedLayerParam_Array_Convert(ob,&data);
    assert(convert_status!=0);
    return data.Len();
}

// ------------------------------------------------------------------
static int
oaDerivedLayerParam_Array_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaDerivedLayerParam_Array data;
    PyParamoaDerivedLayerParam dataitem;
    int convert_status=PyoaDerivedLayerParam_Array_Convert(ob,&data);
    assert(convert_status!=0);
    if (index<0 || index>=data.Len()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    if (PyoaDerivedLayerParam_Convert(value,&dataitem)==0) return -1;
    data.SetItem(index,dataitem.Data());
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return 0;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayerParam_Array_doc[] =
"Class: oaDerivedLayerParam_Array\n"
"  The oaDerivedLayerParam_Array utility class provides an array of oaDerivedLayerParam.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaDerivedLayerParam_Array()\n"
"    Signature: oaDerivedLayerParam_Array||\n"
"    This is the default constructor for the oaDerivedLayerParam_Array class. This constructor creates an empty oaDerivedLayerParam_Array.\n"
"  Paramegers: (oaDerivedLayerParam_Array)\n"
"    Calls: (const oaDerivedLayerParam_Array&)\n"
"    Signature: oaDerivedLayerParam_Array||cref-oaDerivedLayerParam_Array,\n"
;

// ------------------------------------------------------------------
static PySequenceMethods oaDerivedLayerParam_Array_as_sequence = {
    (Pyoa_inquiry)oaDerivedLayerParam_Array_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,              /* sq_concat */
    (Pyoa_intargfunc)0,              /* sq_repeat */
    (Pyoa_intargfunc)oaDerivedLayerParam_Array_index_get, /* sq_item */
    (Pyoa_intintargfunc)0,           /* sq_slice */
    (Pyoa_intobjargproc)oaDerivedLayerParam_Array_index_set,      /* sq_ass_item */
};

// ------------------------------------------------------------------
PyTypeObject PyoaDerivedLayerParam_Array_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDerivedLayerParam_Array",
    sizeof(PyoaDerivedLayerParam_ArrayObject),
    0,
    oaDerivedLayerParam_Array_dealloc, /* tp_dealloc */
    0,  /* tp_print */
    0,                                  /* tp_getattr */
    0,                                  /* tp_setattr */
    oaDerivedLayerParam_Array_compare,    /* tp_compare */
    oaDerivedLayerParam_Array_repr,      /* tp_repr */
    0,                                  /* tp_as_number */
    &oaDerivedLayerParam_Array_as_sequence,  /* tp_as_sequence */
    0,                                  /* tp_as_mapping */
    0,                                  /* tp_as_hash */
    0,                                  /* tp_as_call */
    oaDerivedLayerParam_Array_str,               /* tp_str */
    0,                                  /* tp_getattro */
    0,                                  /* tp_setattro */
    0,                                  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDerivedLayerParam_Array_doc, /* tp_doc */
    0,                                  /* tp_traverse */
    0,                                  /* tp_clear */
    0,                                  /* tp_richcompre */
    0,                                  /* tp_weaklistoffset */
    0,                                  /* tp_iter */
    0,                                  /* tp_iternext */
    oaDerivedLayerParam_Array_methodlist, /* tp_methods */
    0,                                  /* tp_members */
    0,                                  /* tp_getset */
    0,                                  /* tp_base */
    0,                                  /* tp_dict */
    0,                                  /* tp_descr_get */
    0,                                  /* tp_descr_set */
    0,                                  /* tp_dictoffset */
    0,                                  /* tp_init */
    PyType_GenericAlloc,        /* tp_alloc */
    oaDerivedLayerParam_Array_new, /* tp_new */
    _PyObject_Del,      /* tp_free */
};


// ------------------------------------------------------------------
int
PyoaDerivedLayerParam_Array_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDerivedLayerParam_Array_Type)<0) {
      printf("** PyType_Ready failed for: oaDerivedLayerParam_Array\n");
      return -1;
    }
    if (PyDict_SetItemString(mod_dict,"oaDerivedLayerParam_Array",
           (PyObject*)(&PyoaDerivedLayerParam_Array_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDerivedLayerParam_Array\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDerivedLayerParamArray
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDerivedLayerParamArray_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDerivedLayerParamArray_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDerivedLayerParamArrayObject* self = (PyoaDerivedLayerParamArrayObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaArrayBase_oaDerivedLayerParam*)  new oaDerivedLayerParamArray();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value = (oaArrayBase_oaDerivedLayerParam*)  new oaDerivedLayerParamArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaDerivedLayerParamArray)
    {
        PyParamoaDerivedLayerParamArray p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDerivedLayerParamArray_Convert,&p1)) {
            self->value=(oaArrayBase_oaDerivedLayerParam*)  new oaDerivedLayerParamArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDerivedLayerParamArray, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaDerivedLayerParamArray)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDerivedLayerParamArray_tp_dealloc(PyoaDerivedLayerParamArrayObject* self)
{
    if (!self->borrow) {
        delete (oaDerivedLayerParamArray*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDerivedLayerParamArray_tp_repr(PyObject *ob)
{
    PyParamoaDerivedLayerParamArray value;
    int convert_status=PyoaDerivedLayerParamArray_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[46];
    sprintf(buffer,"<oaDerivedLayerParamArray::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDerivedLayerParamArray_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDerivedLayerParamArray v1;
    PyParamoaDerivedLayerParamArray v2;
    int convert_status1=PyoaDerivedLayerParamArray_Convert(ob1,&v1);
    int convert_status2=PyoaDerivedLayerParamArray_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDerivedLayerParamArray_Convert(PyObject* ob,PyParamoaDerivedLayerParamArray* result)
{
    if (ob == NULL) return 1;
    if (PyoaDerivedLayerParamArray_Check(ob)) {
        result->SetData( (oaDerivedLayerParamArray*) ((PyoaDerivedLayerParamArrayObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDerivedLayerParamArray Failed");
    return 0;
}
int
PyoaDerivedLayerParamArray_ConvertAof(PyObject* ob,PyParamoaDerivedLayerParamArray* result)
{
    if (ob == NULL) return 1;
    if (ob==Py_None) {
        result->SetData(NULL);
        return 1;
    }
    if (PyoaDerivedLayerParamArray_Check(ob)) {
        result->SetData( (oaDerivedLayerParamArray*) ((PyoaDerivedLayerParamArrayObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDerivedLayerParamArray Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDerivedLayerParamArray_FromoaDerivedLayerParamArray(oaDerivedLayerParamArray* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaDerivedLayerParamArray_Type.tp_alloc(&PyoaDerivedLayerParamArray_Type,0);
        if (bself == NULL) return bself;
        PyoaDerivedLayerParamArrayObject* self = (PyoaDerivedLayerParamArrayObject*)bself;
        self->value = (oaArrayBase_oaDerivedLayerParam*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDerivedLayerParamArray_findParam_doc[] = 
"Class: oaDerivedLayerParamArray, Function: findParam\n"
"  Paramegers: (oaDerivedLayerParamDef)\n"
"    Calls: oaDerivedLayerParam* findParam(const oaDerivedLayerParamDef* def) const\n"
"    Signature: findParam|ptr-oaDerivedLayerParam|cptr-oaDerivedLayerParamDef,\n"
"    This function searches the derived layer param array for a parameter with the specified definition. If the definition is found, the parameter is returned, otherwise NULL is returned.\n"
"    def\n"
"    Todo\n"
"    Check description of member function. Add description of each parameter.\n"
;

static PyObject*
oaDerivedLayerParamArray_findParam(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayerParamArray data;
    int convert_status=PyoaDerivedLayerParamArray_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerParamArrayObject* self=(PyoaDerivedLayerParamArrayObject*)ob;

    PyParamoaDerivedLayerParamDef p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaDerivedLayerParamDef_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaDerivedLayerParamp result= (data.DataCall()->findParam(p1.Data()));
        return PyoaDerivedLayerParam_FromoaDerivedLayerParam(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaDerivedLayerParamArray_assign_doc[] = 
"Class: oaDerivedLayerParamArray, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDerivedLayerParamArray_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDerivedLayerParamArray data;
  int convert_status=PyoaDerivedLayerParamArray_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDerivedLayerParamArray p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDerivedLayerParamArray_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDerivedLayerParamArray_methodlist[] = {
    {"findParam",(PyCFunction)oaDerivedLayerParamArray_findParam,METH_VARARGS,oaDerivedLayerParamArray_findParam_doc},
    {"assign",(PyCFunction)oaDerivedLayerParamArray_tp_assign,METH_VARARGS,oaDerivedLayerParamArray_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDerivedLayerParamArray_doc[] = 
"Class: oaDerivedLayerParamArray\n"
"  This class represents an array of oaDerivedLayer parameters.\n"
"  Todo\n"
"  Add detailed description of class.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaDerivedLayerParamArray()\n"
"    Signature: oaDerivedLayerParamArray||simple-oaUInt4,\n"
"    This is the constructor for the oaDerivedLayerParamArray class.\n"
"    sizeIn\n"
"    Todo\n"
"    Check description of member function. Add description of each parameter.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaDerivedLayerParamArray(oaUInt4 sizeIn)\n"
"    Signature: oaDerivedLayerParamArray||simple-oaUInt4,\n"
"    This is the constructor for the oaDerivedLayerParamArray class.\n"
"    sizeIn\n"
"    Todo\n"
"    Check description of member function. Add description of each parameter.\n"
"  Paramegers: (oaDerivedLayerParamArray)\n"
"    Calls: (const oaDerivedLayerParamArray&)\n"
"    Signature: oaDerivedLayerParamArray||cref-oaDerivedLayerParamArray,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDerivedLayerParamArray_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDerivedLayerParamArray",
    sizeof(PyoaDerivedLayerParamArrayObject),
    0,
    (destructor)oaDerivedLayerParamArray_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDerivedLayerParamArray_tp_compare,	/* tp_compare */
    (reprfunc)oaDerivedLayerParamArray_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDerivedLayerParamArray_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDerivedLayerParamArray_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaArray_oaDerivedLayerParam_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDerivedLayerParamArray_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDerivedLayerParamArray_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDerivedLayerParamArray_Type)<0) {
      printf("** PyType_Ready failed for: oaDerivedLayerParamArray\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDerivedLayerParamArray",
           (PyObject*)(&PyoaDerivedLayerParamArray_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDerivedLayerParamArray\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDerivedLayerParamDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDerivedLayerParamDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDerivedLayerParamDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDerivedLayerParamDefObject* self = (PyoaDerivedLayerParamDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDerivedLayerParamDef)
    {
        PyParamoaDerivedLayerParamDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDerivedLayerParamDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDerivedLayerParamDef, Choices are:\n"
        "    (oaDerivedLayerParamDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDerivedLayerParamDef_tp_dealloc(PyoaDerivedLayerParamDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDerivedLayerParamDef_tp_repr(PyObject *ob)
{
    PyParamoaDerivedLayerParamDef value;
    int convert_status=PyoaDerivedLayerParamDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[44];
    sprintf(buffer,"<oaDerivedLayerParamDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDerivedLayerParamDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDerivedLayerParamDef v1;
    PyParamoaDerivedLayerParamDef v2;
    int convert_status1=PyoaDerivedLayerParamDef_Convert(ob1,&v1);
    int convert_status2=PyoaDerivedLayerParamDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDerivedLayerParamDef_Convert(PyObject* ob,PyParamoaDerivedLayerParamDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaDerivedLayerParamDef_Check(ob)) {
        result->SetData( (oaDerivedLayerParamDef**) ((PyoaDerivedLayerParamDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDerivedLayerParamDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDerivedLayerParamDef_FromoaDerivedLayerParamDef(oaDerivedLayerParamDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDerivedLayerParamDef* data=*value;
        PyObject* bself = PyoaDerivedLayerParamDef_Type.tp_alloc(&PyoaDerivedLayerParamDef_Type,0);
        if (bself == NULL) return bself;
        PyoaDerivedLayerParamDefObject* self = (PyoaDerivedLayerParamDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDerivedLayerParamDef_FromoaDerivedLayerParamDef(oaDerivedLayerParamDef* data)
{
    if (data) {
       PyObject* bself = PyoaDerivedLayerParamDef_Type.tp_alloc(&PyoaDerivedLayerParamDef_Type,0);
       if (bself == NULL) return bself;
       PyoaDerivedLayerParamDefObject* self = (PyoaDerivedLayerParamDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDerivedLayerParamDef_destroy_doc[] = 
"Class: oaDerivedLayerParamDef, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function destroys the derivedLayerParamDef. If any database currently references this definition, or if this is a built-in definition, an error is thrown.\n"
"    oacUnableToDestroyBuiltInType\n"
"    oacDerivedLayerParamDefHasReference\n"
"    Todo\n"
"    Check description of member function.\n"
;

static PyObject*
oaDerivedLayerParamDef_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayerParamDef data;
    int convert_status=PyoaDerivedLayerParamDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerParamDefObject* self=(PyoaDerivedLayerParamDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayerParamDef_getName_doc[] = 
"Class: oaDerivedLayerParamDef, Function: getName\n"
"  Paramegers: (oaString)\n"
"    Calls: void getName(oaString& name) const\n"
"    Signature: getName|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function returns the name of the derivedLayerParamDef.\n"
"    name\n"
"    The constant oaString name of the oaDerivedLayerParamDef.\n"
"    Todo\n"
"    Check description of member function. Add description of each parameter.\n"
;

static PyObject*
oaDerivedLayerParamDef_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayerParamDef data;
    int convert_status=PyoaDerivedLayerParamDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerParamDefObject* self=(PyoaDerivedLayerParamDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayerParamDef_getValueType_doc[] = 
"Class: oaDerivedLayerParamDef, Function: getValueType\n"
"  Paramegers: ()\n"
"    Calls: oaType getValueType() const\n"
"    Signature: getValueType|simple-oaType|\n"
"    BrowseData: 1\n"
"    This function returns the valueType of the derivedLayerParamDef.\n"
"    Todo\n"
"    Check description of member function.\n"
;

static PyObject*
oaDerivedLayerParamDef_getValueType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayerParamDef data;
    int convert_status=PyoaDerivedLayerParamDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerParamDefObject* self=(PyoaDerivedLayerParamDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaType* result= new oaType(data.DataCall()->getValueType());
        return PyoaType_FromoaType(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayerParamDef_remove_doc[] = 
"Class: oaDerivedLayerParamDef, Function: remove\n"
"  Paramegers: (oaTech)\n"
"    Calls: void remove(oaTech* tech)\n"
"    Signature: remove|void-void|ptr-oaTech,\n"
"    This function removes the derivedLayerParamDef from the specified tech database. If there are derived layers in the database that reference this definition, an oacDerivedLayerParamDefHasReference exception is thrown.\n"
"    tech\n"
"    The technology database containing the definition.\n"
"    oacDerivedLayerParamDefHasReference\n"
"    Todo\n"
"    Check function description.\n"
;

static PyObject*
oaDerivedLayerParamDef_remove(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayerParamDef data;
    int convert_status=PyoaDerivedLayerParamDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerParamDefObject* self=(PyoaDerivedLayerParamDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTech p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTech_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->remove(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayerParamDef_isNull_doc[] =
"Class: oaDerivedLayerParamDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDerivedLayerParamDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDerivedLayerParamDef data;
    int convert_status=PyoaDerivedLayerParamDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDerivedLayerParamDef_assign_doc[] = 
"Class: oaDerivedLayerParamDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDerivedLayerParamDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDerivedLayerParamDef data;
  int convert_status=PyoaDerivedLayerParamDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDerivedLayerParamDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDerivedLayerParamDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDerivedLayerParamDef_methodlist[] = {
    {"destroy",(PyCFunction)oaDerivedLayerParamDef_destroy,METH_VARARGS,oaDerivedLayerParamDef_destroy_doc},
    {"getName",(PyCFunction)oaDerivedLayerParamDef_getName,METH_VARARGS,oaDerivedLayerParamDef_getName_doc},
    {"getValueType",(PyCFunction)oaDerivedLayerParamDef_getValueType,METH_VARARGS,oaDerivedLayerParamDef_getValueType_doc},
    {"remove",(PyCFunction)oaDerivedLayerParamDef_remove,METH_VARARGS,oaDerivedLayerParamDef_remove_doc},
    {"isNull",(PyCFunction)oaDerivedLayerParamDef_tp_isNull,METH_VARARGS,oaDerivedLayerParamDef_isNull_doc},
    {"assign",(PyCFunction)oaDerivedLayerParamDef_tp_assign,METH_VARARGS,oaDerivedLayerParamDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDerivedLayerParamDef_doc[] = 
"Class: oaDerivedLayerParamDef\n"
"  The oaDerivedLayerParamDef object specifies a definition for a particular derived layer parameter. The definition contains a name and the valueType that is allowed for the parameter. The names for derived layer parameter definitions must be unique.\n"
"  The oaDerivedLayer ParamDef class can be observed by deriving from oaObserver<oa DerivedLayer ParamDef>.\n"
"  See Uniqueness of Session Objects for information about the requirement that session objects be unique.\n"
"Constructors:\n"
"  Paramegers: (oaDerivedLayerParamDef)\n"
"    Calls: (const oaDerivedLayerParamDef&)\n"
"    Signature: oaDerivedLayerParamDef||cref-oaDerivedLayerParamDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDerivedLayerParamDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDerivedLayerParamDef",
    sizeof(PyoaDerivedLayerParamDefObject),
    0,
    (destructor)oaDerivedLayerParamDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDerivedLayerParamDef_tp_compare,	/* tp_compare */
    (reprfunc)oaDerivedLayerParamDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDerivedLayerParamDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDerivedLayerParamDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaSessionObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDerivedLayerParamDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDerivedLayerParamDef_static_create_doc[] = 
"Class: oaDerivedLayerParamDef, Function: create\n"
"  Paramegers: (oaString,oaType)\n"
"    Calls: oaDerivedLayerParamDef* create(const oaString& name,oaType valueType)\n"
"    Signature: create|ptr-oaDerivedLayerParamDef|cref-oaString,simple-oaType,\n"
"    This function creates a new oaDerivedLayerParamDef. It is an error if the name of the derivedLayerParamDef already exists, and it is an error if the type specified is not an oaValue subtype.\n"
"    name\n"
"    The constant oaString name for this oaDerivedLayerParamDef.\n"
"    valueType\n"
"    An oaValue subtype.\n"
"    oacDerivedLayerParamDefExists\n"
"    oacInvalidValueType\n"
"    Todo\n"
"    Check description of member function. Add description of each parameter.\n"
;

static PyObject*
oaDerivedLayerParamDef_static_create(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaString p1;
    PyParamoaType p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaString_Convert,&p1,
          &PyoaType_Convert,&p2)) {
        oaDerivedLayerParamDefp result= (oaDerivedLayerParamDef::create(p1.Data(),p2.Data()));
        return PyoaDerivedLayerParamDef_FromoaDerivedLayerParamDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayerParamDef_static_find_doc[] = 
"Class: oaDerivedLayerParamDef, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDerivedLayerParamDef* find(const oaString& name)\n"
"    Signature: find|ptr-oaDerivedLayerParamDef|cref-oaString,\n"
"    This function finds the derived layer parameter definition by name. If the definition is not found, NULL is returned.\n"
"    name\n"
"    The name of the derived layer parameter definition to find.\n"
"    Todo\n"
"    Check description of member function. Check description of each parameter.\n"
;

static PyObject*
oaDerivedLayerParamDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        oaDerivedLayerParamDefp result= (oaDerivedLayerParamDef::find(p1.Data()));
        return PyoaDerivedLayerParamDef_FromoaDerivedLayerParamDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayerParamDef_static_get_doc[] = 
"Class: oaDerivedLayerParamDef, Function: get\n"
"  Paramegers: (oaDerivedLayerParamType)\n"
"    Calls: oaDerivedLayerParamDef* get(oaDerivedLayerParamType type)\n"
"    Signature: get|ptr-oaDerivedLayerParamDef|simple-oaDerivedLayerParamType,\n"
"    This function returns the built in derived layer parameter definition of the type specified.\n"
"    type\n"
"    An oaDerivedLayerParamType enum.\n"
"    Todo\n"
"    Check description of member function. Add description of each parameter.\n"
;

static PyObject*
oaDerivedLayerParamDef_static_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayerParamType p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaDerivedLayerParamType_Convert,&p1)) {
        oaDerivedLayerParamDefp result= (oaDerivedLayerParamDef::get(p1.Data()));
        return PyoaDerivedLayerParamDef_FromoaDerivedLayerParamDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDerivedLayerParamDef_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaDerivedLayerParamDef_static_create,METH_VARARGS,oaDerivedLayerParamDef_static_create_doc},
    {"static_find",(PyCFunction)oaDerivedLayerParamDef_static_find,METH_VARARGS,oaDerivedLayerParamDef_static_find_doc},
    {"static_get",(PyCFunction)oaDerivedLayerParamDef_static_get,METH_VARARGS,oaDerivedLayerParamDef_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDerivedLayerParamDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDerivedLayerParamDef_Type)<0) {
      printf("** PyType_Ready failed for: oaDerivedLayerParamDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDerivedLayerParamDef",
           (PyObject*)(&PyoaDerivedLayerParamDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDerivedLayerParamDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDerivedLayerParamDef_Type.tp_dict;
    for(method=oaDerivedLayerParamDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDerivedLayerParamModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaDerivedLayerParamModTypeEnum_Convert(PyObject* ob,PyParamoaDerivedLayerParamModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacSetValueDerivedLayerParamModType")==0) { result->SetData(oacSetValueDerivedLayerParamModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaDerivedLayerParamModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDerivedLayerParamModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaDerivedLayerParamModTypeEnum_FromoaDerivedLayerParamModTypeEnum(oaDerivedLayerParamModTypeEnum ob)
{
    if (ob==oacSetValueDerivedLayerParamModType) return PyString_FromString("oacSetValueDerivedLayerParamModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaDerivedLayerParamModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaDerivedLayerParamModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaDerivedLayerParamModTypeEnum_FromoaDerivedLayerParamModTypeEnum(oaDerivedLayerParamModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaDerivedLayerParamModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaDerivedLayerParamModTypeEnum_doc[] =
"Type convert function for enum: oaDerivedLayerParamModTypeEnum";
                               
static PyMethodDef PyoaDerivedLayerParamModTypeEnum_method =
  {"oaDerivedLayerParamModTypeEnum",(PyCFunction)PyoaDerivedLayerParamModTypeEnum_TypeFunction,METH_VARARGS,oaDerivedLayerParamModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaDerivedLayerParamModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacSetValueDerivedLayerParamModType");
    PyDict_SetItemString(mod_dict,"oacSetValueDerivedLayerParamModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaDerivedLayerParamModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaDerivedLayerParamModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaDerivedLayerParamModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDerivedLayerParamType
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDerivedLayerParamType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDerivedLayerParamType_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDerivedLayerParamTypeObject* self = (PyoaDerivedLayerParamTypeObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDerivedLayerParamTypeEnum)
    {
        PyParamoaDerivedLayerParamTypeEnum p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDerivedLayerParamTypeEnum_Convert,&p1)) {
            self->value =  new oaDerivedLayerParamType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            self->value =  new oaDerivedLayerParamType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaDerivedLayerParamType)
    {
        PyParamoaDerivedLayerParamType p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDerivedLayerParamType_Convert,&p1)) {
            self->value= new oaDerivedLayerParamType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDerivedLayerParamType, Choices are:\n"
        "    (oaDerivedLayerParamTypeEnum)\n"
        "    (oaString)\n"
        "    (oaDerivedLayerParamType)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDerivedLayerParamType_tp_dealloc(PyoaDerivedLayerParamTypeObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDerivedLayerParamType_tp_repr(PyObject *ob)
{
    PyParamoaDerivedLayerParamType value;
    int convert_status=PyoaDerivedLayerParamType_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    oaString sresult(value.DataCall()->getName());

    char addr[45];
    sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
    oaString buffer;
    buffer+=oaString("<oaDerivedLayerParamType::");
    buffer+=oaString(addr);
    buffer+=oaString("::");
    buffer+=oaString(sresult);
    buffer+=oaString(">");
    result=PyString_FromString((char*)(const char*)buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDerivedLayerParamType_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDerivedLayerParamType v1;
    PyParamoaDerivedLayerParamType v2;
    int convert_status1=PyoaDerivedLayerParamType_Convert(ob1,&v1);
    int convert_status2=PyoaDerivedLayerParamType_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDerivedLayerParamType_Convert(PyObject* ob,PyParamoaDerivedLayerParamType* result)
{
    if (ob == NULL) return 1;
    if (PyoaDerivedLayerParamType_Check(ob)) {
        result->SetData(  ((PyoaDerivedLayerParamTypeObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDerivedLayerParamType Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDerivedLayerParamType_FromoaDerivedLayerParamType(oaDerivedLayerParamType* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaDerivedLayerParamType_Type.tp_alloc(&PyoaDerivedLayerParamType_Type,0);
        if (bself == NULL) return bself;
        PyoaDerivedLayerParamTypeObject* self = (PyoaDerivedLayerParamTypeObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDerivedLayerParamType_getName_doc[] = 
"Class: oaDerivedLayerParamType, Function: getName\n"
"  Paramegers: ()\n"
"    Calls: const oaString& getName() const\n"
"    Signature: getName|cref-oaString|\n"
"    BrowseData: 1\n"
"    This function returns the string name of the oaDerivedLayerParamTypeEnum value that this oaDerivedLayerParamType object represents.\n"
;

static PyObject*
oaDerivedLayerParamType_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayerParamType data;
    int convert_status=PyoaDerivedLayerParamType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerParamTypeObject* self=(PyoaDerivedLayerParamTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaString result= (data.DataCall()->getName());
        return PyoaString_FromoaString(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDerivedLayerParamType_oaDerivedLayerParamTypeEnum_doc[] = 
"Class: oaDerivedLayerParamType, Function: oaDerivedLayerParamTypeEnum\n"
"  Paramegers: ()\n"
"    Calls: oaDerivedLayerParamTypeEnum oaDerivedLayerParamTypeEnum() const\n"
"    Signature: operator oaDerivedLayerParamTypeEnum|simple-oaDerivedLayerParamTypeEnum|\n"
"    BrowseData: 1\n"
"    This operator recasts this oaDerivedLayerParamType object to the oaDerivedLayerParamTypeEnum value it represents.\n"
;

static PyObject*
oaDerivedLayerParamType_oaDerivedLayerParamTypeEnum(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDerivedLayerParamType data;
    int convert_status=PyoaDerivedLayerParamType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDerivedLayerParamTypeObject* self=(PyoaDerivedLayerParamTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaDerivedLayerParamTypeEnum result= (data.DataCall()->operator oaDerivedLayerParamTypeEnum());
        return PyoaDerivedLayerParamTypeEnum_FromoaDerivedLayerParamTypeEnum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaDerivedLayerParamType_assign_doc[] = 
"Class: oaDerivedLayerParamType, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDerivedLayerParamType_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDerivedLayerParamType data;
  int convert_status=PyoaDerivedLayerParamType_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDerivedLayerParamType p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDerivedLayerParamType_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDerivedLayerParamType_methodlist[] = {
    {"getName",(PyCFunction)oaDerivedLayerParamType_getName,METH_VARARGS,oaDerivedLayerParamType_getName_doc},
    {"oaDerivedLayerParamTypeEnum",(PyCFunction)oaDerivedLayerParamType_oaDerivedLayerParamTypeEnum,METH_VARARGS,oaDerivedLayerParamType_oaDerivedLayerParamTypeEnum_doc},
    {"assign",(PyCFunction)oaDerivedLayerParamType_tp_assign,METH_VARARGS,oaDerivedLayerParamType_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDerivedLayerParamType_doc[] = 
"Class: oaDerivedLayerParamType\n"
"  oaDerivedLayerParamTypeEnum\n"
"  The oaDerivedLayerParamType class is an enum wrapper class for oaDerivedLayerParamTypeEnum values.\n"
"  See Enum Wrappers in the Programmers Guide for a discussion of enum wrappers.\n"
"Constructors:\n"
"  Paramegers: (oaDerivedLayerParamTypeEnum)\n"
"    Calls: oaDerivedLayerParamType(oaDerivedLayerParamTypeEnum valueIn)\n"
"    Signature: oaDerivedLayerParamType||simple-oaDerivedLayerParamTypeEnum,\n"
"    This oaDerivedLayerParamType constructor takes an oaDerivedLayerParamTypeEnum value as input.\n"
"    valueIn\n"
"    An oaDerivedLayerParamTypeEnum value.\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDerivedLayerParamType(const oaString& name)\n"
"    Signature: oaDerivedLayerParamType||cref-oaString,\n"
"    This oaDerivedLayerParamType constructor takes the string name of an oaDerivedLayerParamTypeEnum value as input.\n"
"    name\n"
"    The constant oaString name of an oaDerivedLayerParamTypeEnum value.\n"
"    oacInvalidDerivedLayerParamTypeName\n"
"  Paramegers: (oaDerivedLayerParamType)\n"
"    Calls: (const oaDerivedLayerParamType&)\n"
"    Signature: oaDerivedLayerParamType||cref-oaDerivedLayerParamType,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDerivedLayerParamType_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDerivedLayerParamType",
    sizeof(PyoaDerivedLayerParamTypeObject),
    0,
    (destructor)oaDerivedLayerParamType_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDerivedLayerParamType_tp_compare,	/* tp_compare */
    (reprfunc)oaDerivedLayerParamType_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDerivedLayerParamType_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDerivedLayerParamType_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDerivedLayerParamType_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDerivedLayerParamType_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDerivedLayerParamType_Type)<0) {
      printf("** PyType_Ready failed for: oaDerivedLayerParamType\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDerivedLayerParamType",
           (PyObject*)(&PyoaDerivedLayerParamType_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDerivedLayerParamType\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDerivedLayerParamTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaDerivedLayerParamTypeEnum_Convert(PyObject* ob,PyParamoaDerivedLayerParamTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacConnectivityTypeDerivedLayerParamType")==0) { result->SetData(oacConnectivityTypeDerivedLayerParamType); return 1;}
        if (strcasecmp(str,"oacSelectShapesInRangeDerivedLayerParamType")==0) { result->SetData(oacSelectShapesInRangeDerivedLayerParamType); return 1;}
        if (strcasecmp(str,"oacRangeDerivedLayerParamType")==0) { result->SetData(oacRangeDerivedLayerParamType); return 1;}
        if (strcasecmp(str,"oacAreaRangeDerivedLayerParamType")==0) { result->SetData(oacAreaRangeDerivedLayerParamType); return 1;}
        if (strcasecmp(str,"oacExclusiveDerivedLayerParamType")==0) { result->SetData(oacExclusiveDerivedLayerParamType); return 1;}
        if (strcasecmp(str,"oacDistanceDerivedLayerParamType")==0) { result->SetData(oacDistanceDerivedLayerParamType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaDerivedLayerParamTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDerivedLayerParamTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaDerivedLayerParamTypeEnum_FromoaDerivedLayerParamTypeEnum(oaDerivedLayerParamTypeEnum ob)
{
    if (ob==oacConnectivityTypeDerivedLayerParamType) return PyString_FromString("oacConnectivityTypeDerivedLayerParamType");
    if (ob==oacSelectShapesInRangeDerivedLayerParamType) return PyString_FromString("oacSelectShapesInRangeDerivedLayerParamType");
    if (ob==oacRangeDerivedLayerParamType) return PyString_FromString("oacRangeDerivedLayerParamType");
    if (ob==oacAreaRangeDerivedLayerParamType) return PyString_FromString("oacAreaRangeDerivedLayerParamType");
    if (ob==oacExclusiveDerivedLayerParamType) return PyString_FromString("oacExclusiveDerivedLayerParamType");
    if (ob==oacDistanceDerivedLayerParamType) return PyString_FromString("oacDistanceDerivedLayerParamType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaDerivedLayerParamTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaDerivedLayerParamTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaDerivedLayerParamTypeEnum_FromoaDerivedLayerParamTypeEnum(oaDerivedLayerParamTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaDerivedLayerParamTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaDerivedLayerParamTypeEnum_doc[] =
"Type convert function for enum: oaDerivedLayerParamTypeEnum";
                               
static PyMethodDef PyoaDerivedLayerParamTypeEnum_method =
  {"oaDerivedLayerParamTypeEnum",(PyCFunction)PyoaDerivedLayerParamTypeEnum_TypeFunction,METH_VARARGS,oaDerivedLayerParamTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaDerivedLayerParamTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacConnectivityTypeDerivedLayerParamType");
    PyDict_SetItemString(mod_dict,"oacConnectivityTypeDerivedLayerParamType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSelectShapesInRangeDerivedLayerParamType");
    PyDict_SetItemString(mod_dict,"oacSelectShapesInRangeDerivedLayerParamType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacRangeDerivedLayerParamType");
    PyDict_SetItemString(mod_dict,"oacRangeDerivedLayerParamType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAreaRangeDerivedLayerParamType");
    PyDict_SetItemString(mod_dict,"oacAreaRangeDerivedLayerParamType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacExclusiveDerivedLayerParamType");
    PyDict_SetItemString(mod_dict,"oacExclusiveDerivedLayerParamType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDistanceDerivedLayerParamType");
    PyDict_SetItemString(mod_dict,"oacDistanceDerivedLayerParamType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaDerivedLayerParamTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaDerivedLayerParamTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaDerivedLayerParamTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDesign
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDesign_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDesign_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDesignObject* self = (PyoaDesignObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDesign)
    {
        PyParamoaDesign p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDesign_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDesign, Choices are:\n"
        "    (oaDesign)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDesign_tp_dealloc(PyoaDesignObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDesign_tp_repr(PyObject *ob)
{
    PyParamoaDesign value;
    int convert_status=PyoaDesign_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaDesign::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaString sresult;
        oaString sep=" ";
        sep[(oaUInt4)0]=oacInternalHierDelimiter;
        oaScalarName name;
        oaString str;
        value.DataCall()->getLibName(name);
        name.get(str);
        sresult+=oaString(str);
        sresult+=sep;
        value.DataCall()->getCellName(name);
        name.get(str);
        sresult+=oaString(str);
        sresult+=sep;
        value.DataCall()->getViewName(name);
        name.get(str);
        sresult+=oaString(str);
    
        char addr[30];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaDesign::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDesign_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDesign v1;
    PyParamoaDesign v2;
    int convert_status1=PyoaDesign_Convert(ob1,&v1);
    int convert_status2=PyoaDesign_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDesign_Convert(PyObject* ob,PyParamoaDesign* result)
{
    if (ob == NULL) return 1;
    if (PyoaDesign_Check(ob)) {
        result->SetData( (oaDesign**) ((PyoaDesignObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDesign Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDesign_FromoaDesign(oaDesign** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDesign* data=*value;
        PyObject* bself = PyoaDesign_Type.tp_alloc(&PyoaDesign_Type,0);
        if (bself == NULL) return bself;
        PyoaDesignObject* self = (PyoaDesignObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDesign_FromoaDesign(oaDesign* data)
{
    if (data) {
       PyObject* bself = PyoaDesign_Type.tp_alloc(&PyoaDesign_Type,0);
       if (bself == NULL) return bself;
       PyoaDesignObject* self = (PyoaDesignObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDesign_calcVMSize_doc[] = 
"Class: oaDesign, Function: calcVMSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt8 calcVMSize() const\n"
"    Signature: calcVMSize|simple-oaUInt8|\n"
"    BrowseData: 1\n"
"    This function calculates and returns the amount of virtual memory this design is currently using.\n"
;

static PyObject*
oaDesign_calcVMSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt8 result= (data.DataCall()->calcVMSize());
        return PyoaUInt8_FromoaUInt8(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_close_doc[] = 
"Class: oaDesign, Function: close\n"
"  Paramegers: ()\n"
"    Calls: void close()\n"
"    Signature: close|void-void|\n"
"    BrowseData: 0\n"
"    This function is used to indicate that at least one portion of the application is finished with this oaDesign and no longer needs to use the pointers to it or the objects it contains.\n"
"    Each oaDesign has a reference count that is the sum of the calls to open() on it, plus the number of other open oaDesigns that have an InstHeader that refers to it, minus the number of calls to close() on it. Each successful call to close decrements the reference count on a design.\n"
"    When a close causes the reference count to decrement to 0, the design is purged or removed from memory. The pointer to it and the pointers to all the managed objects contained within the design become invalid. If this happens when the design has never been saved, then its cellView, cell and view are removed if they are otherwise empty. Use purge() to force this to happen even for a non-zero reference count.\n"
"    Applications are not required to close designs. If a design is not closed. it remains in memory until the process ends. Applications that want to reclaim memory used by open designs may use close() calls to indicate that they are done with the design. In this use model, calls to close() will match calls to open() . There should never be more calls to close() for a given design than calls to open() .\n"
;

static PyObject*
oaDesign_close(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->close();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_contains_doc[] = 
"Class: oaDesign, Function: contains\n"
"  Paramegers: (oaDesign)\n"
"    Calls: oaBoolean contains(oaDesign* design)\n"
"    Signature: contains|simple-oaBoolean|ptr-oaDesign,\n"
"    This function determines if this design contains a reference to the specified design .\n"
;

static PyObject*
oaDesign_contains(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDesign p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaDesign_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->contains(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_defineSuperMaster_doc[] = 
"Class: oaDesign, Function: defineSuperMaster\n"
"  Paramegers: (oaPcellDef,oaParamArray)\n"
"    Calls: void defineSuperMaster(oaPcellDef* def,const oaParamArray& pa)\n"
"    Signature: defineSuperMaster|void-void|ptr-oaPcellDef,cref-oaParamArray,\n"
"    oaDesign::defineSuperMaster\n"
"    This function creates or re-defines a superMaster design. The existing data in this design remains intact, and pCell parameters and new pcell evaluation interface information are bound to the design. It is a frequent practice for the superMaster to contain the implementation of the pCell with default parameter values.\n"
"    If this superMaster design already has existing subMasters, then those subMasters will be reevaluated. If this call has a different set of parameters than previously existed, or if this design was not previously a supermaster, then all instances bound to this supermaster will be realigned with new submasters as follows:\n"
"    if the instance has any parameters that no longer exist on the superMaster, those parameters are converted to properties on the instance\n"
"    if new parameters are added to this superMaster, then the properties on the instance will checked for a property of the same name which will then be converted to a parameter\n"
"    each instance will be assigned to a new subInstHeader reflecting its new parameterization\n"
"    the new subInstHeaders will be bound to an appropriate new subMaster\n"
"    Note that this process may result in a different grouping of instances to subMasters and a different number of subMasters.\n"
"    oacCannotModifyReadModeDesign\n"
"    oacInvalidSuperMaster\n"
"    oacPcellObserverBindFailed\n"
"    oacPcellInvalidPcellDef\n"
;

static PyObject*
oaDesign_defineSuperMaster(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaPcellDef p1;
    PyParamoaParamArray p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaPcellDef_ConvertAof,&p1,
          &PyoaParamArray_Convert,&p2)) {
        data.DataCall()->defineSuperMaster(p1.DataAof(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_enableTimeStamps_doc[] = 
"Class: oaDesign, Function: enableTimeStamps\n"
"  Paramegers: ()\n"
"    Calls: void enableTimeStamps()\n"
"    Signature: enableTimeStamps|void-void|simple-oaBoolean,\n"
"    BrowseData: 0\n"
"    This function enables or disables timeStamp modification on this design. By default, timeStamp modification is enabled.\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: void enableTimeStamps(oaBoolean value)\n"
"    Signature: enableTimeStamps|void-void|simple-oaBoolean,\n"
"    This function enables or disables timeStamp modification on this design. By default, timeStamp modification is enabled.\n"
;

static PyObject*
oaDesign_enableTimeStamps(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            data.DataCall()->enableTimeStamps();
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            data.DataCall()->enableTimeStamps(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDesign, function: enableTimeStamps, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_enableUndo_doc[] = 
"Class: oaDesign, Function: enableUndo\n"
"  Paramegers: ()\n"
"    Calls: void enableUndo()\n"
"    Signature: enableUndo|void-void|simple-oaBoolean,\n"
"    BrowseData: 0\n"
"    This function enables or disables undo for this design. If enabled, all changes made to this design are logged so that undo() can restore the design to earlier states. If disabled, all undo information is discarded, and changes are not logged.\n"
"    This function is deprecated. It is recommended that applications instead use the enableUndo function that allows specification of a model for undo operations.\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: void enableUndo(oaBoolean value)\n"
"    Signature: enableUndo|void-void|simple-oaBoolean,\n"
"    This function enables or disables undo for this design. If enabled, all changes made to this design are logged so that undo() can restore the design to earlier states. If disabled, all undo information is discarded, and changes are not logged.\n"
"    This function is deprecated. It is recommended that applications instead use the enableUndo function that allows specification of a model for undo operations.\n"
"  Paramegers: (oaBoolean,oaUndoModelEnum)\n"
"    Calls: void enableUndo(oaBoolean value,oaUndoModelEnum undoModel)\n"
"    Signature: enableUndo|void-void|simple-oaBoolean,simple-oaUndoModelEnum,\n"
"    oaDesign::enableUndo\n"
"    This function enables or disables undo for this design. If enabled, all changes made to this design are logged so that undo() can restore the design to earlier states. If disabled, all undo information is discarded, and changes are not logged. This function requires the caller to specify a particular model for undo (undoModel).\n"
"    OpenAccess supports two undo models:\n"
"    postCheckpoint model, in which checkpoints are set after an action.\n"
"    preCheckpoint model, in which checkpoints are set before an action.\n"
"    If postCheckpoint is specified, a call to undo must immediately follow a checkpoint or an exception is thrown.\n"
;

static PyObject*
oaDesign_enableUndo(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            data.DataCall()->enableUndo();
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            data.DataCall()->enableUndo(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean,oaUndoModelEnum)
    {
        PyParamoaBoolean p1;
        PyParamoaUndoModelEnum p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBoolean_Convert,&p1,
              &PyoaUndoModelEnum_Convert,&p2)) {
            data.DataCall()->enableUndo(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDesign, function: enableUndo, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
        "    (oaBoolean,oaUndoModelEnum)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_evalSuperMaster_doc[] = 
"Class: oaDesign, Function: evalSuperMaster\n"
"  Paramegers: ()\n"
"    Calls: void evalSuperMaster()\n"
"    Signature: evalSuperMaster|void-void|\n"
"    BrowseData: 0\n"
"    This function uses the default parameter values to populate the superMaster with the contents of the variant of this pCell that is built with those values. The resulting contents are added to any previous contents of the design.\n"
"    The primary purpose is to create some contents of the superMaster that are meaningful and viewed in a graphical viewer. This evaluation has no effect on or relationship to instances of this pCell.\n"
"    oacCannotModifyReadModeDesign\n"
"    oacInvalidSuperMaster\n"
"    oacPcellInvalidPcellDef\n"
;

static PyObject*
oaDesign_evalSuperMaster(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->evalSuperMaster();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_findParam_doc[] = 
"Class: oaDesign, Function: findParam\n"
"  Paramegers: (oaString,oaParam)\n"
"    Calls: oaBoolean findParam(const oaString& name,oaParam& param) const\n"
"    Signature: findParam|simple-oaBoolean|cref-oaString,ref-oaParam,\n"
"    This function searches the parameter list of this design for a parameter with the specified name . If found, it fills out param with the appropriate attributes and returns true. Otherwise, the function returns false.\n"
"    oacInvalidPcellMaster\n"
;

static PyObject*
oaDesign_findParam(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    PyParamoaParam p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaString_Convert,&p1,
          &PyoaParam_Convert,&p2)) {
        oaBoolean result= (data.DataCall()->findParam(p1.Data(),p2.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getAnalysisPoints_doc[] = 
"Class: oaDesign, Function: getAnalysisPoints\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaAnalysisPoint_oaDesign getAnalysisPoints() const\n"
"    Signature: getAnalysisPoints|simple-oaCollection_oaAnalysisPoint_oaDesign|\n"
"    BrowseData: 1\n"
"    This function returns a collection of analysisPoints in this design.\n"
;

static PyObject*
oaDesign_getAnalysisPoints(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaAnalysisPoint_oaDesign* result= new oaCollection_oaAnalysisPoint_oaDesign(data.DataCall()->getAnalysisPoints());
        return PyoaCollection_oaAnalysisPoint_oaDesign_FromoaCollection_oaAnalysisPoint_oaDesign(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getAnalysisPointsIter_doc[] = 
"Class: oaDesign, Function: getAnalysisPointsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaAnalysisPoint getAnalysisPointsIter() const\n"
"    Signature: getAnalysisPointsIter|simple-oaIter_oaAnalysisPoint|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of analysisPoints in this design.\n"
;

static PyObject*
oaDesign_getAnalysisPointsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaAnalysisPoint* result= new oaIter_oaAnalysisPoint(data.DataCall()->getAnalysisPoints());
        return PyoaIter_oaAnalysisPoint_FromoaIter_oaAnalysisPoint(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getAppDefsByDataType_doc[] = 
"Class: oaDesign, Function: getAppDefsByDataType\n"
"  Paramegers: (oaDesignDataType,oaDomain)\n"
"    Calls: oaCollection_oaAppDef_oaDesign getAppDefsByDataType(oaDesignDataType dataType,oaDomain domain) const\n"
"    Signature: getAppDefsByDataType|simple-oaCollection_oaAppDef_oaDesign|simple-oaDesignDataType,simple-oaDomain,\n"
"    This function returns a collection of oaAppDefs in this design for the specified dataType and domain.\n"
"    dataType\n"
"    The data type on which to search for appDefs.\n"
"    domain\n"
"    The domain on which to search for appDefs\n"
;

static PyObject*
oaDesign_getAppDefsByDataType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDesignDataType p1;
    PyParamoaDomain p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaDesignDataType_Convert,&p1,
          &PyoaDomain_Convert,&p2)) {
        oaCollection_oaAppDef_oaDesign* result= new oaCollection_oaAppDef_oaDesign(data.DataCall()->getAppDefsByDataType(p1.Data(),p2.Data()));
        return PyoaCollection_oaAppDef_oaDesign_FromoaCollection_oaAppDef_oaDesign(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getAppDefsByDataTypeIter_doc[] = 
"Class: oaDesign, Function: getAppDefsByDataTypeIter\n"
"  Paramegers: (oaDesignDataType,oaDomain)\n"
"    Calls: oaIter_oaAppDef getAppDefsByDataTypeIter(oaDesignDataType dataType,oaDomain domain) const\n"
"    Signature: getAppDefsByDataTypeIter|simple-oaIter_oaAppDef|simple-oaDesignDataType,simple-oaDomain,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of oaAppDefs in this design for the specified dataType and domain.\n"
"    dataType\n"
"    The data type on which to search for appDefs.\n"
"    domain\n"
"    The domain on which to search for appDefs\n"
;

static PyObject*
oaDesign_getAppDefsByDataTypeIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDesignDataType p1;
    PyParamoaDomain p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaDesignDataType_Convert,&p1,
          &PyoaDomain_Convert,&p2)) {
        oaIter_oaAppDef* result= new oaIter_oaAppDef(data.DataCall()->getAppDefsByDataType(p1.Data(),p2.Data()));
        return PyoaIter_oaAppDef_FromoaIter_oaAppDef(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getAppObjectDefs_doc[] = 
"Class: oaDesign, Function: getAppObjectDefs\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaAppObjectDef_oaDesign getAppObjectDefs() const\n"
"    Signature: getAppObjectDefs|simple-oaCollection_oaAppObjectDef_oaDesign|\n"
"    BrowseData: 1\n"
"    This returns a collection of the types of object extensions that are in use in this design. Object extensions are independent objects that are not tied to a built-in design object. See oaAppObjectDef for the usage of object extensions.\n"
;

static PyObject*
oaDesign_getAppObjectDefs(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaAppObjectDef_oaDesign* result= new oaCollection_oaAppObjectDef_oaDesign(data.DataCall()->getAppObjectDefs());
        return PyoaCollection_oaAppObjectDef_oaDesign_FromoaCollection_oaAppObjectDef_oaDesign(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getAppObjectDefsIter_doc[] = 
"Class: oaDesign, Function: getAppObjectDefsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaAppObjectDef getAppObjectDefsIter() const\n"
"    Signature: getAppObjectDefsIter|simple-oaIter_oaAppObjectDef|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This returns a collection of the types of object extensions that are in use in this design. Object extensions are independent objects that are not tied to a built-in design object. See oaAppObjectDef for the usage of object extensions.\n"
;

static PyObject*
oaDesign_getAppObjectDefsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaAppObjectDef* result= new oaIter_oaAppObjectDef(data.DataCall()->getAppObjectDefs());
        return PyoaIter_oaAppObjectDef_FromoaIter_oaAppObjectDef(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getAppObjects_doc[] = 
"Class: oaDesign, Function: getAppObjects\n"
"  Paramegers: (oaAppObjectDef)\n"
"    Calls: oaCollection_oaAppObject_oaDesign getAppObjects(const oaAppObjectDef* def) const\n"
"    Signature: getAppObjects|simple-oaCollection_oaAppObject_oaDesign|cptr-oaAppObjectDef,\n"
"    This function returns a collection of oaAppObjects in this design for the specified extension.\n"
;

static PyObject*
oaDesign_getAppObjects(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaAppObjectDef p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaAppObjectDef_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaCollection_oaAppObject_oaDesign* result= new oaCollection_oaAppObject_oaDesign(data.DataCall()->getAppObjects(p1.Data()));
        return PyoaCollection_oaAppObject_oaDesign_FromoaCollection_oaAppObject_oaDesign(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getAppObjectsIter_doc[] = 
"Class: oaDesign, Function: getAppObjectsIter\n"
"  Paramegers: (oaAppObjectDef)\n"
"    Calls: oaIter_oaAppObject getAppObjectsIter(const oaAppObjectDef* def) const\n"
"    Signature: getAppObjectsIter|simple-oaIter_oaAppObject|cptr-oaAppObjectDef,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of oaAppObjects in this design for the specified extension.\n"
;

static PyObject*
oaDesign_getAppObjectsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaAppObjectDef p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaAppObjectDef_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaIter_oaAppObject* result= new oaIter_oaAppObject(data.DataCall()->getAppObjects(p1.Data()));
        return PyoaIter_oaAppObject_FromoaIter_oaAppObject(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getCellName_doc[] = 
"Class: oaDesign, Function: getCellName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getCellName(oaScalarName& cellName) const\n"
"    Signature: getCellName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the name of the cell associated with this design in the form of an oaScalarName .\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getCellName(const oaNameSpace& ns,oaString& cellName) const\n"
"    Signature: getCellName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the cellName using the specified nameSpace.\n"
;

static PyObject*
oaDesign_getCellName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getCellName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getCellName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDesign, function: getCellName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getCellType_doc[] = 
"Class: oaDesign, Function: getCellType\n"
"  Paramegers: ()\n"
"    Calls: oaCellType getCellType() const\n"
"    Signature: getCellType|simple-oaCellType|\n"
"    BrowseData: 1\n"
"    This function returns the cellType for this design.\n"
;

static PyObject*
oaDesign_getCellType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCellType* result= new oaCellType(data.DataCall()->getCellType());
        return PyoaCellType_FromoaCellType(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getConstraintGroupHeaders_doc[] = 
"Class: oaDesign, Function: getConstraintGroupHeaders\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaConstraintGroupHeader_oaDesign getConstraintGroupHeaders() const\n"
"    Signature: getConstraintGroupHeaders|simple-oaCollection_oaConstraintGroupHeader_oaDesign|\n"
"    BrowseData: 1\n"
"    This function returns a collection of constraint group headers in this database.\n"
;

static PyObject*
oaDesign_getConstraintGroupHeaders(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaConstraintGroupHeader_oaDesign* result= new oaCollection_oaConstraintGroupHeader_oaDesign(data.DataCall()->getConstraintGroupHeaders());
        return PyoaCollection_oaConstraintGroupHeader_oaDesign_FromoaCollection_oaConstraintGroupHeader_oaDesign(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getConstraintGroupHeadersIter_doc[] = 
"Class: oaDesign, Function: getConstraintGroupHeadersIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaConstraintGroupHeader getConstraintGroupHeadersIter() const\n"
"    Signature: getConstraintGroupHeadersIter|simple-oaIter_oaConstraintGroupHeader|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of constraint group headers in this database.\n"
;

static PyObject*
oaDesign_getConstraintGroupHeadersIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaConstraintGroupHeader* result= new oaIter_oaConstraintGroupHeader(data.DataCall()->getConstraintGroupHeaders());
        return PyoaIter_oaConstraintGroupHeader_FromoaIter_oaConstraintGroupHeader(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getConstraintGroups_doc[] = 
"Class: oaDesign, Function: getConstraintGroups\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaConstraintGroup_oaDesign getConstraintGroups() const\n"
"    Signature: getConstraintGroups|simple-oaCollection_oaConstraintGroup_oaDesign|\n"
"    BrowseData: 1\n"
"    This function returns a collection of constraint groups in this database.\n"
;

static PyObject*
oaDesign_getConstraintGroups(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaConstraintGroup_oaDesign* result= new oaCollection_oaConstraintGroup_oaDesign(data.DataCall()->getConstraintGroups());
        return PyoaCollection_oaConstraintGroup_oaDesign_FromoaCollection_oaConstraintGroup_oaDesign(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getConstraintGroupsIter_doc[] = 
"Class: oaDesign, Function: getConstraintGroupsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaConstraintGroup getConstraintGroupsIter() const\n"
"    Signature: getConstraintGroupsIter|simple-oaIter_oaConstraintGroup|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of constraint groups in this database.\n"
;

static PyObject*
oaDesign_getConstraintGroupsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaConstraintGroup* result= new oaIter_oaConstraintGroup(data.DataCall()->getConstraintGroups());
        return PyoaIter_oaConstraintGroup_FromoaIter_oaConstraintGroup(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getConstraintParams_doc[] = 
"Class: oaDesign, Function: getConstraintParams\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaConstraintParam_oaDesign getConstraintParams() const\n"
"    Signature: getConstraintParams|simple-oaCollection_oaConstraintParam_oaDesign|\n"
"    BrowseData: 1\n"
"    This function returns a collection of constraint parameters in this database.\n"
;

static PyObject*
oaDesign_getConstraintParams(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaConstraintParam_oaDesign* result= new oaCollection_oaConstraintParam_oaDesign(data.DataCall()->getConstraintParams());
        return PyoaCollection_oaConstraintParam_oaDesign_FromoaCollection_oaConstraintParam_oaDesign(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getConstraintParamsIter_doc[] = 
"Class: oaDesign, Function: getConstraintParamsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaConstraintParam getConstraintParamsIter() const\n"
"    Signature: getConstraintParamsIter|simple-oaIter_oaConstraintParam|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of constraint parameters in this database.\n"
;

static PyObject*
oaDesign_getConstraintParamsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaConstraintParam* result= new oaIter_oaConstraintParam(data.DataCall()->getConstraintParams());
        return PyoaIter_oaConstraintParam_FromoaIter_oaConstraintParam(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getConstraints_doc[] = 
"Class: oaDesign, Function: getConstraints\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaConstraint_oaDesign getConstraints() const\n"
"    Signature: getConstraints|simple-oaCollection_oaConstraint_oaDesign|cptr-oaConstraintDef,\n"
"    BrowseData: 1\n"
"    This function returns a collection of constraints in this design database with the definition specified. If no definition is specified, all of the constraints are returned.\n"
"    def\n"
"    Optional constraint definition to search for\n"
"  Paramegers: (oaConstraintDef)\n"
"    Calls: oaCollection_oaConstraint_oaDesign getConstraints(const oaConstraintDef* def) const\n"
"    Signature: getConstraints|simple-oaCollection_oaConstraint_oaDesign|cptr-oaConstraintDef,\n"
"    This function returns a collection of constraints in this design database with the definition specified. If no definition is specified, all of the constraints are returned.\n"
"    def\n"
"    Optional constraint definition to search for\n"
;

static PyObject*
oaDesign_getConstraints(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaConstraint_oaDesign* result= new oaCollection_oaConstraint_oaDesign(data.DataCall()->getConstraints());
            return PyoaCollection_oaConstraint_oaDesign_FromoaCollection_oaConstraint_oaDesign(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaConstraintDef)
    {
        PyParamoaConstraintDef p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaConstraintDef_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaCollection_oaConstraint_oaDesign* result= new oaCollection_oaConstraint_oaDesign(data.DataCall()->getConstraints(p1.Data()));
            return PyoaCollection_oaConstraint_oaDesign_FromoaCollection_oaConstraint_oaDesign(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDesign, function: getConstraints, Choices are:\n"
        "    ()\n"
        "    (oaConstraintDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getConstraintsIter_doc[] = 
"Class: oaDesign, Function: getConstraintsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaConstraint getConstraintsIter() const\n"
"    Signature: getConstraintsIter|simple-oaIter_oaConstraint|cptr-oaConstraintDef,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of constraints in this design database with the definition specified. If no definition is specified, all of the constraints are returned.\n"
"    def\n"
"    Optional constraint definition to search for\n"
"  Paramegers: (oaConstraintDef)\n"
"    Calls: oaIter_oaConstraint getConstraintsIter(const oaConstraintDef* def) const\n"
"    Signature: getConstraintsIter|simple-oaIter_oaConstraint|cptr-oaConstraintDef,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of constraints in this design database with the definition specified. If no definition is specified, all of the constraints are returned.\n"
"    def\n"
"    Optional constraint definition to search for\n"
;

static PyObject*
oaDesign_getConstraintsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaConstraint* result= new oaIter_oaConstraint(data.DataCall()->getConstraints());
            return PyoaIter_oaConstraint_FromoaIter_oaConstraint(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaConstraintDef)
    {
        PyParamoaConstraintDef p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaConstraintDef_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaIter_oaConstraint* result= new oaIter_oaConstraint(data.DataCall()->getConstraints(p1.Data()));
            return PyoaIter_oaConstraint_FromoaIter_oaConstraint(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDesign, function: getConstraintsIter, Choices are:\n"
        "    ()\n"
        "    (oaConstraintDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getCpID_doc[] = 
"Class: oaDesign, Function: getCpID\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getCpID() const\n"
"    Signature: getCpID|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the ID of the last checkpoint set in this design. If the ID is not set on that checkpoint, this function returns UINT_MAX.\n"
;

static PyObject*
oaDesign_getCpID(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getCpID());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getCreateTime_doc[] = 
"Class: oaDesign, Function: getCreateTime\n"
"  Paramegers: ()\n"
"    Calls: oaTime getCreateTime() const\n"
"    Signature: getCreateTime|simple-oaTime|\n"
"    BrowseData: 1\n"
"    This function returns the time at which this design was created.\n"
;

static PyObject*
oaDesign_getCreateTime(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaTime result= (data.DataCall()->getCreateTime());
        return PyoaTime_FromoaTime(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getDefaultConstraintGroup_doc[] = 
"Class: oaDesign, Function: getDefaultConstraintGroup\n"
"  Paramegers: ()\n"
"    Calls: oaConstraintGroup* getDefaultConstraintGroup() const\n"
"    Signature: getDefaultConstraintGroup|ptr-oaConstraintGroup|\n"
"    BrowseData: 1\n"
"    This function returns the default constraint group for this design. If no constraints have been set on the default constraint group a new constraint group is created and returned.\n"
;

static PyObject*
oaDesign_getDefaultConstraintGroup(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaConstraintGroupp result= (data.DataCall()->getDefaultConstraintGroup());
        return PyoaConstraintGroup_FromoaConstraintGroup(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getGroups_doc[] = 
"Class: oaDesign, Function: getGroups\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaGroup_oaDesign getGroups() const\n"
"    Signature: getGroups|simple-oaCollection_oaGroup_oaDesign|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns the complete set of groups in the design database. The filter flags may be used to restrict the collection to groups in specific domains out of the module, block, occurrence domains, and the groups with no domain restriction on its members.\n"
"    The default value of the filterFlags restricts the collection to the groups with no domain specific membership. Multiple domain flags can be combined and passed in to this function.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaGroup_oaDesign getGroups(oaUInt4 filterFlags) const\n"
"    Signature: getGroups|simple-oaCollection_oaGroup_oaDesign|simple-oaUInt4,\n"
"    This function returns the complete set of groups in the design database. The filter flags may be used to restrict the collection to groups in specific domains out of the module, block, occurrence domains, and the groups with no domain restriction on its members.\n"
"    The default value of the filterFlags restricts the collection to the groups with no domain specific membership. Multiple domain flags can be combined and passed in to this function.\n"
;

static PyObject*
oaDesign_getGroups(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaGroup_oaDesign* result= new oaCollection_oaGroup_oaDesign(data.DataCall()->getGroups());
            return PyoaCollection_oaGroup_oaDesign_FromoaCollection_oaGroup_oaDesign(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaGroup_oaDesign* result= new oaCollection_oaGroup_oaDesign(data.DataCall()->getGroups(p1.Data()));
            return PyoaCollection_oaGroup_oaDesign_FromoaCollection_oaGroup_oaDesign(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDesign, function: getGroups, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getGroupsByName_doc[] = 
"Class: oaDesign, Function: getGroupsByName\n"
"  Paramegers: (oaString)\n"
"    Calls: oaCollection_oaGroup_oaDesign getGroupsByName(const oaString& name) const\n"
"    Signature: getGroupsByName|simple-oaCollection_oaGroup_oaDesign|cref-oaString,simple-oaUInt4,\n"
"    This function returns a collection of groups in this design with the specified name. The filter flags may be used to restrict the search to groups in one specific domain out of the module, block, and occurrence domains, or the groups with no domain restriction on its members.\n"
"    The default value of the filterFlags restricts the collection to the groups with no domain specific membership. Exception is thrown if multiple domain selection flags are enabled in the passed-in filter flags.\n"
"    oacInvalidGroupByNameIterFlags\n"
"  Paramegers: (oaString,oaUInt4)\n"
"    Calls: oaCollection_oaGroup_oaDesign getGroupsByName(const oaString& name,oaUInt4 filterFlags) const\n"
"    Signature: getGroupsByName|simple-oaCollection_oaGroup_oaDesign|cref-oaString,simple-oaUInt4,\n"
"    This function returns a collection of groups in this design with the specified name. The filter flags may be used to restrict the search to groups in one specific domain out of the module, block, and occurrence domains, or the groups with no domain restriction on its members.\n"
"    The default value of the filterFlags restricts the collection to the groups with no domain specific membership. Exception is thrown if multiple domain selection flags are enabled in the passed-in filter flags.\n"
"    oacInvalidGroupByNameIterFlags\n"
;

static PyObject*
oaDesign_getGroupsByName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaCollection_oaGroup_oaDesign* result= new oaCollection_oaGroup_oaDesign(data.DataCall()->getGroupsByName(p1.Data()));
            return PyoaCollection_oaGroup_oaDesign_FromoaCollection_oaGroup_oaDesign(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaUInt4)
    {
        PyParamoaString p1;
        PyParamoaUInt4 p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaUInt4_Convert,&p2)) {
            oaCollection_oaGroup_oaDesign* result= new oaCollection_oaGroup_oaDesign(data.DataCall()->getGroupsByName(p1.Data(),p2.Data()));
            return PyoaCollection_oaGroup_oaDesign_FromoaCollection_oaGroup_oaDesign(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDesign, function: getGroupsByName, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getGroupsByNameIter_doc[] = 
"Class: oaDesign, Function: getGroupsByNameIter\n"
"  Paramegers: (oaString)\n"
"    Calls: oaIter_oaGroup getGroupsByNameIter(const oaString& name) const\n"
"    Signature: getGroupsByNameIter|simple-oaIter_oaGroup|cref-oaString,simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of groups in this design with the specified name. The filter flags may be used to restrict the search to groups in one specific domain out of the module, block, and occurrence domains, or the groups with no domain restriction on its members.\n"
"    The default value of the filterFlags restricts the collection to the groups with no domain specific membership. Exception is thrown if multiple domain selection flags are enabled in the passed-in filter flags.\n"
"    oacInvalidGroupByNameIterFlags\n"
"  Paramegers: (oaString,oaUInt4)\n"
"    Calls: oaIter_oaGroup getGroupsByNameIter(const oaString& name,oaUInt4 filterFlags) const\n"
"    Signature: getGroupsByNameIter|simple-oaIter_oaGroup|cref-oaString,simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of groups in this design with the specified name. The filter flags may be used to restrict the search to groups in one specific domain out of the module, block, and occurrence domains, or the groups with no domain restriction on its members.\n"
"    The default value of the filterFlags restricts the collection to the groups with no domain specific membership. Exception is thrown if multiple domain selection flags are enabled in the passed-in filter flags.\n"
"    oacInvalidGroupByNameIterFlags\n"
;

static PyObject*
oaDesign_getGroupsByNameIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaIter_oaGroup* result= new oaIter_oaGroup(data.DataCall()->getGroupsByName(p1.Data()));
            return PyoaIter_oaGroup_FromoaIter_oaGroup(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaUInt4)
    {
        PyParamoaString p1;
        PyParamoaUInt4 p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaUInt4_Convert,&p2)) {
            oaIter_oaGroup* result= new oaIter_oaGroup(data.DataCall()->getGroupsByName(p1.Data(),p2.Data()));
            return PyoaIter_oaGroup_FromoaIter_oaGroup(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDesign, function: getGroupsByNameIter, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getGroupsIter_doc[] = 
"Class: oaDesign, Function: getGroupsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaGroup getGroupsIter() const\n"
"    Signature: getGroupsIter|simple-oaIter_oaGroup|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns the complete set of groups in the design database. The filter flags may be used to restrict the collection to groups in specific domains out of the module, block, occurrence domains, and the groups with no domain restriction on its members.\n"
"    The default value of the filterFlags restricts the collection to the groups with no domain specific membership. Multiple domain flags can be combined and passed in to this function.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaGroup getGroupsIter(oaUInt4 filterFlags) const\n"
"    Signature: getGroupsIter|simple-oaIter_oaGroup|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: This function returns the complete set of groups in the design database. The filter flags may be used to restrict the collection to groups in specific domains out of the module, block, occurrence domains, and the groups with no domain restriction on its members.\n"
"    The default value of the filterFlags restricts the collection to the groups with no domain specific membership. Multiple domain flags can be combined and passed in to this function.\n"
;

static PyObject*
oaDesign_getGroupsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaGroup* result= new oaIter_oaGroup(data.DataCall()->getGroups());
            return PyoaIter_oaGroup_FromoaIter_oaGroup(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaGroup* result= new oaIter_oaGroup(data.DataCall()->getGroups(p1.Data()));
            return PyoaIter_oaGroup_FromoaIter_oaGroup(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDesign, function: getGroupsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getLastSavedTime_doc[] = 
"Class: oaDesign, Function: getLastSavedTime\n"
"  Paramegers: ()\n"
"    Calls: oaTime getLastSavedTime() const\n"
"    Signature: getLastSavedTime|simple-oaTime|\n"
"    BrowseData: 1\n"
"    This function returns the time at which this design was last saved.\n"
"    oaTime The time since 00:00:00 GMT, Jan. 1, 1970, measured in seconds\n"
;

static PyObject*
oaDesign_getLastSavedTime(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaTime result= (data.DataCall()->getLastSavedTime());
        return PyoaTime_FromoaTime(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getLib_doc[] = 
"Class: oaDesign, Function: getLib\n"
"  Paramegers: ()\n"
"    Calls: oaLib* getLib() const\n"
"    Signature: getLib|ptr-oaLib|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the oaLib object associated with this database.\n"
"    oacCannotFindObjectForViaMaster\n"
;

static PyObject*
oaDesign_getLib(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaLibp result= (data.DataCall()->getLib());
        return PyoaLib_FromoaLib(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getLibName_doc[] = 
"Class: oaDesign, Function: getLibName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getLibName(oaScalarName& libName) const\n"
"    Signature: getLibName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the name of the library associated with this design in the form of an oaScalarName .\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getLibName(const oaNameSpace& ns,oaString& libName) const\n"
"    Signature: getLibName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the library name using the specified nameSpace.\n"
;

static PyObject*
oaDesign_getLibName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getLibName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getLibName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDesign, function: getLibName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getModInstHeaders_doc[] = 
"Class: oaDesign, Function: getModInstHeaders\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaModInstHeader_oaDesign getModInstHeaders() const\n"
"    Signature: getModInstHeaders|simple-oaCollection_oaModInstHeader_oaDesign|\n"
"    BrowseData: 1\n"
"    This function returns a collection of oaModInstHeaders -- module domain instHeaders (of design master) objects in this design.\n"
;

static PyObject*
oaDesign_getModInstHeaders(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaModInstHeader_oaDesign* result= new oaCollection_oaModInstHeader_oaDesign(data.DataCall()->getModInstHeaders());
        return PyoaCollection_oaModInstHeader_oaDesign_FromoaCollection_oaModInstHeader_oaDesign(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getModInstHeadersIter_doc[] = 
"Class: oaDesign, Function: getModInstHeadersIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaModInstHeader getModInstHeadersIter() const\n"
"    Signature: getModInstHeadersIter|simple-oaIter_oaModInstHeader|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of oaModInstHeaders -- module domain instHeaders (of design master) objects in this design.\n"
;

static PyObject*
oaDesign_getModInstHeadersIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaModInstHeader* result= new oaIter_oaModInstHeader(data.DataCall()->getModInstHeaders());
        return PyoaIter_oaModInstHeader_FromoaIter_oaModInstHeader(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getMode_doc[] = 
"Class: oaDesign, Function: getMode\n"
"  Paramegers: ()\n"
"    Calls: oaChar getMode() const\n"
"    Signature: getMode|simple-oaChar|\n"
"    BrowseData: 1\n"
"    This function returns the mode in which this design is currently opened.\n"
"    When this function is called on an oaDesign that is a pCell submaster, it may return a value of 's', which corresponds to a mode used internally by OpenAccess.\n"
;

static PyObject*
oaDesign_getMode(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaChar result= (data.DataCall()->getMode());
        return PyoaChar_FromoaChar(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getModules_doc[] = 
"Class: oaDesign, Function: getModules\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaModule_oaDesign getModules() const\n"
"    Signature: getModules|simple-oaCollection_oaModule_oaDesign|\n"
"    BrowseData: 1\n"
"    This function returns a collection of modules contained in this design.\n"
;

static PyObject*
oaDesign_getModules(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaModule_oaDesign* result= new oaCollection_oaModule_oaDesign(data.DataCall()->getModules());
        return PyoaCollection_oaModule_oaDesign_FromoaCollection_oaModule_oaDesign(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getModulesIter_doc[] = 
"Class: oaDesign, Function: getModulesIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaModule getModulesIter() const\n"
"    Signature: getModulesIter|simple-oaIter_oaModule|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of modules contained in this design.\n"
;

static PyObject*
oaDesign_getModulesIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaModule* result= new oaIter_oaModule(data.DataCall()->getModules());
        return PyoaIter_oaModule_FromoaIter_oaModule(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getNumUndoCpRecs_doc[] = 
"Class: oaDesign, Function: getNumUndoCpRecs\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumUndoCpRecs() const\n"
"    Signature: getNumUndoCpRecs|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of undo records on the most recent checkpoint saved for this design.\n"
;

static PyObject*
oaDesign_getNumUndoCpRecs(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumUndoCpRecs());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getParams_doc[] = 
"Class: oaDesign, Function: getParams\n"
"  Paramegers: (oaParamArray)\n"
"    Calls: void getParams(oaParamArray& params) const\n"
"    Signature: getParams|void-void|ref-oaParamArray,\n"
"    BrowseData: 0,oaParamArray\n"
"    This function fills out pArray with the parameters attached to this design. The pArray will include all parameters whether or not they were explicitly specified during creation of a subMaster (either from an oaDesign::open() or pcell evaluation). An exception will be thrown if the design is not a superMaster or a subMaster.\n"
"    oacInvalidPcellMaster\n"
"  Paramegers: (oaParamArray,oaBoolean)\n"
"    Calls: void getParams(oaParamArray& params,oaBoolean includeDefaults) const\n"
"    Signature: getParams|void-void|ref-oaParamArray,simple-oaBoolean,\n"
"    This function fills out pArray with the parameters attached to this design. If includeDefaults is true, pArray will contain all parameters whether or not they were explicitly specified during creation of a subMaster (either from an oaDesign::open() or pcell evaluation). If includeDefaults is false, only parameters that were specified during creation of the subMaster will returned in pArray . On a superMaster, an empty array will be returned in pArray if includeDefaults is false. An exception will be thrown if the design is not a superMaster or a subMaster.\n"
"    oacInvalidPcellMaster\n"
"  Paramegers: (oaViaParam)\n"
"    Calls: void getParams(oaViaParam& params) const\n"
"    Signature: getParams|void-void|ref-oaViaParam,\n"
"    BrowseData: 0,oaViaParam\n"
"    This function fills out the vParams with the viaParams attached to this design. An exception is thrown if this design is not a stdVia master.\n"
"    oacInvalidStdViaMaster\n"
;

static PyObject*
oaDesign_getParams(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaParamArray)
    {
        PyParamoaParamArray p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaParamArray_Convert,&p1)) {
            data.DataCall()->getParams(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaParamArray,oaBoolean)
    {
        PyParamoaParamArray p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaParamArray_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->getParams(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaViaParam)
    {
        PyParamoaViaParam p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaViaParam_Convert,&p1)) {
            data.DataCall()->getParams(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDesign, function: getParams, Choices are:\n"
        "    (oaParamArray)\n"
        "    (oaParamArray,oaBoolean)\n"
        "    (oaViaParam)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getPcellDef_doc[] = 
"Class: oaDesign, Function: getPcellDef\n"
"  Paramegers: ()\n"
"    Calls: oaPcellDef* getPcellDef() const\n"
"    Signature: getPcellDef|ptr-oaPcellDef|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to an oaPcellDef in this superMaster design.\n"
"    oacInvalidSuperMaster\n"
;

static PyObject*
oaDesign_getPcellDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaPcellDef* result=(data.DataCall()->getPcellDef());
        if (result==NULL) {
            Py_INCREF(Py_None);
            return Py_None;
        }
        return PyoaPcellDef_FromoaPcellDef(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getPcellEvaluatorName_doc[] = 
"Class: oaDesign, Function: getPcellEvaluatorName\n"
"  Paramegers: (oaString)\n"
"    Calls: void getPcellEvaluatorName(oaString& evalName) const\n"
"    Signature: getPcellEvaluatorName|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function returns the name of the pcell evaluator associated with this superMaster design.\n"
"    evalName\n"
"    the returned name of the pcell evaluator associated with this superMaster design\n"
"    oacInvalidSuperMaster\n"
;

static PyObject*
oaDesign_getPcellEvaluatorName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getPcellEvaluatorName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getReadInTime_doc[] = 
"Class: oaDesign, Function: getReadInTime\n"
"  Paramegers: ()\n"
"    Calls: oaTime getReadInTime() const\n"
"    Signature: getReadInTime|simple-oaTime|\n"
"    BrowseData: 1\n"
"    This function returns the time at which this design was read in from disk.\n"
"    oaTime The time since 00:00:00 GMT, Jan. 1, 1970, measured in seconds.\n"
;

static PyObject*
oaDesign_getReadInTime(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaTime result= (data.DataCall()->getReadInTime());
        return PyoaTime_FromoaTime(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getRefCount_doc[] = 
"Class: oaDesign, Function: getRefCount\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getRefCount() const\n"
"    Signature: getRefCount|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of times this design is opened without being closed. This number is incremented for each oaDesign::open that refers to this oaDesign. It is decremented for each oaDesign::close called on it. It is also incremented for each open oaDesign (not including this design) that has an InstHeader that refers to this design. See oaDesign::close for more details.\n"
"    oaUInt4\n"
;

static PyObject*
oaDesign_getRefCount(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getRefCount());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getSubMasters_doc[] = 
"Class: oaDesign, Function: getSubMasters\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaDesign_oaDesign getSubMasters() const\n"
"    Signature: getSubMasters|simple-oaCollection_oaDesign_oaDesign|\n"
"    BrowseData: 1\n"
"    This function returns a collection of subMasters in this design. An oacInvalidSuperMaster exception is thrown if the design is not a superMaster.\n"
"    oacInvalidSuperMaster\n"
;

static PyObject*
oaDesign_getSubMasters(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaDesign_oaDesign* result= new oaCollection_oaDesign_oaDesign(data.DataCall()->getSubMasters());
        return PyoaCollection_oaDesign_oaDesign_FromoaCollection_oaDesign_oaDesign(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getSubMastersIter_doc[] = 
"Class: oaDesign, Function: getSubMastersIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaDesign getSubMastersIter() const\n"
"    Signature: getSubMastersIter|simple-oaIter_oaDesign|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of subMasters in this design. An oacInvalidSuperMaster exception is thrown if the design is not a superMaster.\n"
"    oacInvalidSuperMaster\n"
;

static PyObject*
oaDesign_getSubMastersIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaDesign* result= new oaIter_oaDesign(data.DataCall()->getSubMasters());
        return PyoaIter_oaDesign_FromoaIter_oaDesign(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getSuperMaster_doc[] = 
"Class: oaDesign, Function: getSuperMaster\n"
"  Paramegers: ()\n"
"    Calls: oaDesign* getSuperMaster() const\n"
"    Signature: getSuperMaster|ptr-oaDesign|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to a pCell superMaster design.\n"
"    oacInvalidSubMaster\n"
;

static PyObject*
oaDesign_getSuperMaster(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaDesignp result= (data.DataCall()->getSuperMaster());
        return PyoaDesign_FromoaDesign(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getTech_doc[] = 
"Class: oaDesign, Function: getTech\n"
"  Paramegers: ()\n"
"    Calls: oaTech* getTech() const\n"
"    Signature: getTech|ptr-oaTech|\n"
"    BrowseData: 1\n"
"    This function returns the technology database associated with this design.\n"
"    oacCannotFindTechForDesign\n"
;

static PyObject*
oaDesign_getTech(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaTechp result= (data.DataCall()->getTech());
        return PyoaTech_FromoaTech(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getTimeStamp_doc[] = 
"Class: oaDesign, Function: getTimeStamp\n"
"  Paramegers: (oaDesignDataType)\n"
"    Calls: oaTimeStamp getTimeStamp(oaDesignDataType type) const\n"
"    Signature: getTimeStamp|simple-oaTimeStamp|simple-oaDesignDataType,\n"
"    This function returns the timeStamp value for the objects of the specified datatype in this design.\n"
"    If there are no objects of the given type in this design, a default value timeStamp will be returned.\n"
"    Timestamps are not available for the following types of design objects and it is an error if the given datatype is one of these values.\n"
"    oacParamDataType oacOccNetDataType oacOccBusNetDefDataType oacOccTermDataType oacBusTermDefDataType oacOccInstHeaderDataType oacOccModuleInstHeaderDataType oacOccInstDataType oacOccVectorInstDefDataType oacOccInstTermDataType oacOccConnectDefDataType oacOccAssignmentDataType oacOccOccurrenceDataType\n"
"    oacInvalidDataTypeForTimeStamp\n"
"  Paramegers: (oaAppObjectDef)\n"
"    Calls: oaTimeStamp getTimeStamp(oaAppObjectDef* def) const\n"
"    Signature: getTimeStamp|simple-oaTimeStamp|ptr-oaAppObjectDef,\n"
"    This function returns the timeStamp value for the application object in this design of the specified application object definition. If there's no such object in this database, the default value timeStamp will be returned.\n"
;

static PyObject*
oaDesign_getTimeStamp(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaDesignDataType)
    {
        PyParamoaDesignDataType p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDesignDataType_Convert,&p1)) {
            oaTimeStamp* result= new oaTimeStamp(data.DataCall()->getTimeStamp(p1.Data()));
            return PyoaTimeStamp_FromoaTimeStamp(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaAppObjectDef)
    {
        PyParamoaAppObjectDef p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaAppObjectDef_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaTimeStamp* result= new oaTimeStamp(data.DataCall()->getTimeStamp(p1.Data()));
            return PyoaTimeStamp_FromoaTimeStamp(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDesign, function: getTimeStamp, Choices are:\n"
        "    (oaDesignDataType)\n"
        "    (oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getTopBlock_doc[] = 
"Class: oaDesign, Function: getTopBlock\n"
"  Paramegers: ()\n"
"    Calls: oaBlock* getTopBlock() const\n"
"    Signature: getTopBlock|ptr-oaBlock|\n"
"    BrowseData: 1\n"
"    This function returns the block in this design. It will return null if there is no block in this design.\n"
"    Note that the name of this call reflects the future possibility of having an embedded block hierarchy in a single design. At this time there can\n"
"    only be one block in a design.\n"
;

static PyObject*
oaDesign_getTopBlock(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBlockp result= (data.DataCall()->getTopBlock());
        return PyoaBlock_FromoaBlock(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getTopModule_doc[] = 
"Class: oaDesign, Function: getTopModule\n"
"  Paramegers: ()\n"
"    Calls: oaModule* getTopModule() const\n"
"    Signature: getTopModule|ptr-oaModule|\n"
"    BrowseData: 1\n"
"    This function returns the top module of the module hierarchy in this design. It will return null if there are no modules in this design, or if none of the existing modules have been set to be the top.\n"
;

static PyObject*
oaDesign_getTopModule(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModulep result= (data.DataCall()->getTopModule());
        return PyoaModule_FromoaModule(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getTopOccurrence_doc[] = 
"Class: oaDesign, Function: getTopOccurrence\n"
"  Paramegers: ()\n"
"    Calls: oaOccurrence* getTopOccurrence() const\n"
"    Signature: getTopOccurrence|ptr-oaOccurrence|\n"
"    BrowseData: 1\n"
"    This function returns the top of the occurrence hierarchy that is rooted in this design. It will return null only if there is no top module and no block in this design.\n"
"    This is the occurrence that corresponds to this design's block if that exists, and to this design's top module if that exists.\n"
;

static PyObject*
oaDesign_getTopOccurrence(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaOccurrencep result= (data.DataCall()->getTopOccurrence());
        return PyoaOccurrence_FromoaOccurrence(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getUsedIn_doc[] = 
"Class: oaDesign, Function: getUsedIn\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaInstHeader_oaDesign getUsedIn() const\n"
"    Signature: getUsedIn|simple-oaCollection_oaInstHeader_oaDesign|\n"
"    BrowseData: 1\n"
"    This function returns a collection of instHeaders in other open designs that refer to this design as the master. It does not open any designs or return any information from designs that are only on disk. This function can be used to traverse \"up\" a design hierarchy that has been read in to memory.\n"
;

static PyObject*
oaDesign_getUsedIn(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaInstHeader_oaDesign* result= new oaCollection_oaInstHeader_oaDesign(data.DataCall()->getUsedIn());
        return PyoaCollection_oaInstHeader_oaDesign_FromoaCollection_oaInstHeader_oaDesign(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getUsedInIter_doc[] = 
"Class: oaDesign, Function: getUsedInIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaInstHeader getUsedInIter() const\n"
"    Signature: getUsedInIter|simple-oaIter_oaInstHeader|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of instHeaders in other open designs that refer to this design as the master. It does not open any designs or return any information from designs that are only on disk. This function can be used to traverse \"up\" a design hierarchy that has been read in to memory.\n"
;

static PyObject*
oaDesign_getUsedInIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaInstHeader* result= new oaIter_oaInstHeader(data.DataCall()->getUsedIn());
        return PyoaIter_oaInstHeader_FromoaIter_oaInstHeader(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getValues_doc[] = 
"Class: oaDesign, Function: getValues\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaValue_oaDesign getValues() const\n"
"    Signature: getValues|simple-oaCollection_oaValue_oaDesign|\n"
"    BrowseData: 1\n"
"    This function returns a collection of values in this database.\n"
;

static PyObject*
oaDesign_getValues(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaValue_oaDesign* result= new oaCollection_oaValue_oaDesign(data.DataCall()->getValues());
        return PyoaCollection_oaValue_oaDesign_FromoaCollection_oaValue_oaDesign(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getValuesIter_doc[] = 
"Class: oaDesign, Function: getValuesIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaValue getValuesIter() const\n"
"    Signature: getValuesIter|simple-oaIter_oaValue|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of values in this database.\n"
;

static PyObject*
oaDesign_getValuesIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaValue* result= new oaIter_oaValue(data.DataCall()->getValues());
        return PyoaIter_oaValue_FromoaIter_oaValue(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getViaHeaderUsedIn_doc[] = 
"Class: oaDesign, Function: getViaHeaderUsedIn\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaViaHeader_oaDesign getViaHeaderUsedIn() const\n"
"    Signature: getViaHeaderUsedIn|simple-oaCollection_oaViaHeader_oaDesign|\n"
"    BrowseData: 1\n"
"    This function returns a collection of viaHeaders in other opened designs that refer to this design as the master. It does not open any designs or return any information from designs that are only on disk. This function can be used to traverse \"up\" a design hierarchy that has been read in to memory.\n"
;

static PyObject*
oaDesign_getViaHeaderUsedIn(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaViaHeader_oaDesign* result= new oaCollection_oaViaHeader_oaDesign(data.DataCall()->getViaHeaderUsedIn());
        return PyoaCollection_oaViaHeader_oaDesign_FromoaCollection_oaViaHeader_oaDesign(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getViaHeaderUsedInIter_doc[] = 
"Class: oaDesign, Function: getViaHeaderUsedInIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaViaHeader getViaHeaderUsedInIter() const\n"
"    Signature: getViaHeaderUsedInIter|simple-oaIter_oaViaHeader|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of viaHeaders in other opened designs that refer to this design as the master. It does not open any designs or return any information from designs that are only on disk. This function can be used to traverse \"up\" a design hierarchy that has been read in to memory.\n"
;

static PyObject*
oaDesign_getViaHeaderUsedInIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaViaHeader* result= new oaIter_oaViaHeader(data.DataCall()->getViaHeaderUsedIn());
        return PyoaIter_oaViaHeader_FromoaIter_oaViaHeader(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getViewName_doc[] = 
"Class: oaDesign, Function: getViewName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getViewName(oaScalarName& viewName) const\n"
"    Signature: getViewName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the name of the view associated with this design in the form of an oaScalarName .\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getViewName(const oaNameSpace& ns,oaString& viewName) const\n"
"    Signature: getViewName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the name of the view associated with this design using the specified nameSpace.\n"
;

static PyObject*
oaDesign_getViewName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getViewName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getViewName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDesign, function: getViewName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_getViewType_doc[] = 
"Class: oaDesign, Function: getViewType\n"
"  Paramegers: ()\n"
"    Calls: oaViewType* getViewType() const\n"
"    Signature: getViewType|ptr-oaViewType|\n"
"    BrowseData: 1\n"
"    This function returns the viewType represented by this design. If the design is created as a follower in a cellView, the viewType will differ from that of the primary file in the cellView.\n"
;

static PyObject*
oaDesign_getViewType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaViewTypep result= (data.DataCall()->getViewType());
        return PyoaViewType_FromoaViewType(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_hasDefaultConstraintGroup_doc[] = 
"Class: oaDesign, Function: hasDefaultConstraintGroup\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean hasDefaultConstraintGroup() const\n"
"    Signature: hasDefaultConstraintGroup|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether or not there is a default constraint group for this design.\n"
;

static PyObject*
oaDesign_hasDefaultConstraintGroup(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->hasDefaultConstraintGroup());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_hasSymmetricConnectivity_doc[] = 
"Class: oaDesign, Function: hasSymmetricConnectivity\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean hasSymmetricConnectivity() const\n"
"    Signature: hasSymmetricConnectivity|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    oaDesign::hasSymmetricConnectivity\n"
"    This function returns true if this design contains exactly one module, which is a top module, and one block. If true is returned, it is an indication that the design's connectivity in both the block and module domains is the same, with possible exceptions for block-only objects and hidden block objects.\n"
;

static PyObject*
oaDesign_hasSymmetricConnectivity(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->hasSymmetricConnectivity());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_isInUndo_doc[] = 
"Class: oaDesign, Function: isInUndo\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isInUndo() const\n"
"    Signature: isInUndo|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this design is currently in undo or redo operation.\n"
"    true If this design is currently in an undo or redo operation; false If undo is not currently in an undo or redo operation.\n"
;

static PyObject*
oaDesign_isInUndo(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isInUndo());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_isModified_doc[] = 
"Class: oaDesign, Function: isModified\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isModified() const\n"
"    Signature: isModified|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean that indicates if this design has been modified but not saved.\n"
"    true If the design is modified but not saved false If the design has not been modified\n"
;

static PyObject*
oaDesign_isModified(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isModified());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_isScalarized_doc[] = 
"Class: oaDesign, Function: isScalarized\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isScalarized() const\n"
"    Signature: isScalarized|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether all the explicit, multibit connectivity in any domain of this design are scalarized. Explicit, multibit connectivity is represented by busNets, bundleNets, busTerms, bundleTerms, and vectorInsts that were explicitly created by applications.\n"
"    Explicit, multibit connectivity should be scalarized to insure that any of the corresponding bitNets, bitTerms, and bitInsts are promoted to the explicit state and are available for supporting implementation data. The corresponding multibit connectivity is demoted to the implicit state so that implementation can no longer be associated with them and to restrict explicit modifications that would cause inconsistencies with the single-bit connectivity.\n"
;

static PyObject*
oaDesign_isScalarized(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isScalarized());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_isStdViaMaster_doc[] = 
"Class: oaDesign, Function: isStdViaMaster\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isStdViaMaster() const\n"
"    Signature: isStdViaMaster|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns true if this design represents a stdVia master.\n"
;

static PyObject*
oaDesign_isStdViaMaster(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isStdViaMaster());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_isSubMaster_doc[] = 
"Class: oaDesign, Function: isSubMaster\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isSubMaster() const\n"
"    Signature: isSubMaster|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns true if this design represents a pCell subMaster.\n"
;

static PyObject*
oaDesign_isSubMaster(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isSubMaster());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_isSuperMaster_doc[] = 
"Class: oaDesign, Function: isSuperMaster\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isSuperMaster() const\n"
"    Signature: isSuperMaster|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns true if this design represents a pCell superMaster.\n"
;

static PyObject*
oaDesign_isSuperMaster(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isSuperMaster());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_isUndoEnabled_doc[] = 
"Class: oaDesign, Function: isUndoEnabled\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isUndoEnabled() const\n"
"    Signature: isUndoEnabled|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if undo is currently enabled for this design.\n"
"    true If undo is enabled for this design; false If undo is not enabled for this design\n"
;

static PyObject*
oaDesign_isUndoEnabled(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isUndoEnabled());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_minimizeVM_doc[] = 
"Class: oaDesign, Function: minimizeVM\n"
"  Paramegers: ()\n"
"    Calls: void minimizeVM()\n"
"    Signature: minimizeVM|void-void|\n"
"    BrowseData: 0\n"
"    This function minimizes the amount of virtual memory this design is currently using. It releases dynamically allocated data structures that can be rebuilt as needed.\n"
"    Applications can call this function after creating an oaDesign or making significant edits to an existing oaDesign, before starting a phase of processing that interacts with the design in different ways.\n"
"    This function should be called sparingly, as it can have a substantial impact on the performance of subsequent operations.\n"
;

static PyObject*
oaDesign_minimizeVM(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->minimizeVM();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_openHier_doc[] = 
"Class: oaDesign, Function: openHier\n"
"  Paramegers: ()\n"
"    Calls: void openHier()\n"
"    Signature: openHier|void-void|\n"
"    BrowseData: 0\n"
"    This function attempts to recursively open the entire design hierarchy, with this design used as the root.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void openHier(oaUInt4 numLevels)\n"
"    Signature: openHier|void-void|simple-oaUInt4,\n"
"    This function attempts to recursively open the design hierarchy numLevels deep, with this design as the root.\n"
;

static PyObject*
oaDesign_openHier(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            data.DataCall()->openHier();
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->openHier(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDesign, function: openHier, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_preAllocate_doc[] = 
"Class: oaDesign, Function: preAllocate\n"
"  Paramegers: (oaDesignDataTypeEnum,oaUInt4)\n"
"    Calls: void preAllocate(oaDesignDataTypeEnum dataType,oaUInt4 numObjs)\n"
"    Signature: preAllocate|void-void|simple-oaDesignDataTypeEnum,simple-oaUInt4,\n"
"    This function preallocates a specified number of objects of the specified dataType . This is useful for applications that know in advance approximately how many objects of a certain type need creating.\n"
;

static PyObject*
oaDesign_preAllocate(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDesignDataTypeEnum p1;
    PyParamoaUInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaDesignDataTypeEnum_Convert,&p1,
          &PyoaUInt4_Convert,&p2)) {
        data.DataCall()->preAllocate(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_purge_doc[] = 
"Class: oaDesign, Function: purge\n"
"  Paramegers: ()\n"
"    Calls: void purge()\n"
"    Signature: purge|void-void|\n"
"    BrowseData: 0\n"
"    This function closes and removes the design from memory, regardless of its reference count. All references to objects stored in this design become invalid.\n"
"    If the purged design is a pcell supermaster, all submasters will be purged as well.\n"
"    oacPurgeOnDesignBeingPurged\n"
;

static PyObject*
oaDesign_purge(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->purge();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_redo_doc[] = 
"Class: oaDesign, Function: redo\n"
"  Paramegers: ()\n"
"    Calls: void redo()\n"
"    Signature: redo|void-void|\n"
"    BrowseData: 0\n"
"    This function redoes the changes that were most recently undone. This call has an effect only if undo is enabled, undo() is called for this design, and there are no changes since the last undo() was performed. This call reinstates the changes removed by the last undo() call.\n"
"    If there is an enabled observer on the action that is completed as a result of the redo operation, that observer is called. In addition, there are observers for the redo operation itself. Refer to oaDesignUndoObserver for more information.\n"
"    undo()\n"
;

static PyObject*
oaDesign_redo(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->redo();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_reopen_doc[] = 
"Class: oaDesign, Function: reopen\n"
"  Paramegers: (oaChar)\n"
"    Calls: void reopen(oaChar mode)\n"
"    Signature: reopen|void-void|simple-oaChar,\n"
"    This function attempts to reopen this design using the specified access mode. The contents of the design can be reset or truncated depending upon the new access mode. This function changes the open mode of this design to mode .\n"
"    Note: The refCount of the design is not affected.\n"
"    mode\n"
"    The mode in which to open the design:\n"
"    'r' for read\n"
"    'w' for write\n"
"    'a' for append\n"
"    'A' for append in override mode, which is not typically used. Refer to Compatibility for OpenAccess Applications and Data in the Programmers Guide for more information.\n"
"    Note that scratch mode is used internally to create submasters for pcells and standard via masters.\n"
"    oacCannotDowngradeDatabase\n"
"    The database was opened in  A  mode and cannot be reopened in 'a' mode\n"
"    oacCannotSetModeToScratch\n"
"    oacCannotChangeFromScratchMode\n"
"    oacDataNotCompatibleOnOpenInAppendMode\n"
"    The design contains new features that are not understood by this version of OpenAccess and cannot be opened in append mode\n"
"    oacDataNotCompatibleOnOpenInEditableMode\n"
"    The design contains new features that are not understood by this version of OpenAccess and cannot be opened in 'a'ppend or 'A'ppend mode\n"
"    oacOpenOnDesignBeingPurged\n"
"    open()\n"
;

static PyObject*
oaDesign_reopen(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaChar p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaChar_Convert,&p1)) {
        data.DataCall()->reopen(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_revert_doc[] = 
"Class: oaDesign, Function: revert\n"
"  Paramegers: ()\n"
"    Calls: void revert()\n"
"    Signature: revert|void-void|\n"
"    BrowseData: 0\n"
"    This function returns the design to the state it was in when it was first opened. If it is open in read or append mode, the contents of the design are reloaded from disk. If the design is open in write mode, it is truncated so that it contains no data. The access mode of the design is not affected.\n"
"    If revert is called on a design in read or append mode, then the current copy on the disk is read. If this or a different process has changed it since the original open then the newer version will be present after the revert call.\n"
"    The revert call can throw any exception thrown by oaDesign::open() .\n"
;

static PyObject*
oaDesign_revert(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->revert();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_save_doc[] = 
"Class: oaDesign, Function: save\n"
"  Paramegers: ()\n"
"    Calls: void save()\n"
"    Signature: save|void-void|\n"
"    BrowseData: 0\n"
"    oaDesign::save\n"
"    This function saves the design to disk. The design remains open and all of its in-memory data remains valid including its undo data.\n"
"    oacSaveReadOnlyDesign\n"
"    oacSaveScratchModeDesign\n"
"    Cannot save a submaster\n"
"    oacDataNotCompatibleOnSave\n"
"    Design contains incompatible data and cannot be saved\n"
;

static PyObject*
oaDesign_save(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->save();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_saveAs_doc[] = 
"Class: oaDesign, Function: saveAs\n"
"  Paramegers: (oaScalarName,oaScalarName,oaScalarName)\n"
"    Calls: void saveAs(const oaScalarName& libNameIn,const oaScalarName& cellNameIn,const oaScalarName& viewNameIn)\n"
"    Signature: saveAs|void-void|cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,\n"
"    This function saves this design to disk using the specified library, cell, and view names. The design remains open and all of its in-memory data remains valid including its undo data.\n"
"    oacDataNotCompatibleOnSave\n"
"    Design contains incompatible data and cannot be saved\n"
;

static PyObject*
oaDesign_saveAs(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScalarName p1;
    PyParamoaScalarName p2;
    PyParamoaScalarName p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaScalarName_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaScalarName_Convert,&p3)) {
        data.DataCall()->saveAs(p1.Data(),p2.Data(),p3.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_scalarize_doc[] = 
"Class: oaDesign, Function: scalarize\n"
"  Paramegers: ()\n"
"    Calls: void scalarize()\n"
"    Signature: scalarize|void-void|\n"
"    BrowseData: 0\n"
"    oaDesign::scalarize\n"
"    This function promotes single-bit connectivity to the explicit state and demotes multibit connectivity to the implicit state. This function should be used to insure that all single-bit connectivity is available for supporting implementation data and to restrict explicit editing the multi-bit connectivity, which could lead to inconsistencies with the constituent bits.\n"
"    Single-bit connectivity is represented by bitNets (scalarNets and busNetBits), bitTerms (scalarTerms and busTermBits), bitInsts (scalarInsts and vectorInstBits), and single-bit connections.\n"
;

static PyObject*
oaDesign_scalarize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->scalarize();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_setCellType_doc[] = 
"Class: oaDesign, Function: setCellType\n"
"  Paramegers: (oaCellType)\n"
"    Calls: void setCellType(oaCellType cellType)\n"
"    Signature: setCellType|void-void|simple-oaCellType,\n"
"    This function sets the cell type for this design.\n"
"    oacInvalidMaster\n"
;

static PyObject*
oaDesign_setCellType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaCellType p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaCellType_Convert,&p1)) {
        data.DataCall()->setCellType(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_setCp_doc[] = 
"Class: oaDesign, Function: setCp\n"
"  Paramegers: ()\n"
"    Calls: void setCp()\n"
"    Signature: setCp|void-void|\n"
"    BrowseData: 0\n"
"    This function sets an undo checkpoint for this design. A checkpoint marks the current state of this design. Each call to undo() restores the contents of the design to a previous state when undo is enabled.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setCp(oaUInt4 checkPointID)\n"
"    Signature: setCp|void-void|simple-oaUInt4,\n"
"    This function sets an undo checkpoint for this design. A checkpoint marks the current state of this design. Each call to undo() restores the contents of the design to a previous state when undo is enabled. The checkpoint has a user-specified ID to assist in keeping track of checkpoints in this design and across multiple designs.\n"
;

static PyObject*
oaDesign_setCp(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            data.DataCall()->setCp();
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setCp(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDesign, function: setCp, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_setTopModule_doc[] = 
"Class: oaDesign, Function: setTopModule\n"
"  Paramegers: (oaModule)\n"
"    Calls: void setTopModule(oaModule* module)\n"
"    Signature: setTopModule|void-void|ptr-oaModule,simple-oaBoolean,\n"
"    oaDesign::setTopModule\n"
"    This function sets or resets the top module for this design. If a valid module is passed in, it will be set as the top module of this design, and a top block will be implicitly created if the visibleToBlock flag is true. Exceptions will be thrown if the module is invalid (for example, if it belongs to a different design), or if this design already has a top module or is block only. If a NULL pointer is passed in, the current top module will be unset, and the top block will be deleted if it exists.\n"
"  Paramegers: (oaModule,oaBoolean)\n"
"    Calls: void setTopModule(oaModule* module,oaBoolean visibleToBlock)\n"
"    Signature: setTopModule|void-void|ptr-oaModule,simple-oaBoolean,\n"
"    oaDesign::setTopModule\n"
"    This function sets or resets the top module for this design. If a valid module is passed in, it will be set as the top module of this design, and a top block will be implicitly created if the visibleToBlock flag is true. Exceptions will be thrown if the module is invalid (for example, if it belongs to a different design), or if this design already has a top module or is block only. If a NULL pointer is passed in, the current top module will be unset, and the top block will be deleted if it exists.\n"
;

static PyObject*
oaDesign_setTopModule(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaModule)
    {
        PyParamoaModule p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaModule_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->setTopModule(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaBoolean)
    {
        PyParamoaModule p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->setTopModule(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDesign, function: setTopModule, Choices are:\n"
        "    (oaModule)\n"
        "    (oaModule,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_undefineSuperMaster_doc[] = 
"Class: oaDesign, Function: undefineSuperMaster\n"
"  Paramegers: ()\n"
"    Calls: void undefineSuperMaster()\n"
"    Signature: undefineSuperMaster|void-void|\n"
"    BrowseData: 0\n"
"    oaDesign::undefineSuperMaster\n"
"    This function converts a pCell superMaster into a regular (non-pCell) design. The oaPcellDef is discarded and the parameters are converted to oaDesign properties.\n"
"    All submasters of this supermaster are destroyed, and all instances of those submasters become bound to the former superMaster (which is now neither a subMaster nor a superMaster) instance parameters are converted to properties. Other contents of the design are not affected.\n"
"    oacCannotModifyReadModeDesign\n"
"    oacInvalidSuperMaster\n"
;

static PyObject*
oaDesign_undefineSuperMaster(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->undefineSuperMaster();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_undo_doc[] = 
"Class: oaDesign, Function: undo\n"
"  Paramegers: ()\n"
"    Calls: void undo()\n"
"    Signature: undo|void-void|\n"
"    BrowseData: 0\n"
"    This function undoes the changes made to this database. This function goes back one checkpoint that is, to the most recent checkpoint added to this design. Undo reverses the changes saved in undo records. It starts from the most recent record, and covers all the undo records after the most recent checkpoint, or before if there's no record after the checkpoint.\n"
"    If there is an enabled observer on the action that is completed as a result of the undo operation, that observer is called. In addition, there are observers for the undo operation itself. Refer to oaDesignUndoObserver for more information.\n"
"    Note that only changes to managed objects in the oaDesign are undone. Utility objects that contain pointers to a managed object such as an oaRouteObjectArray are not affected.\n"
"    redo()\n"
;

static PyObject*
oaDesign_undo(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->undo();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_unsetCp_doc[] = 
"Class: oaDesign, Function: unsetCp\n"
"  Paramegers: ()\n"
"    Calls: void unsetCp()\n"
"    Signature: unsetCp|void-void|\n"
"    BrowseData: 0\n"
"    This function removes the last checkpoint in this design assuming that there are no actions after the last checkpoint. In other words, there are no undo records after the last checkpoint. Otherwise, an exception is thrown. (Refer to oaDesign::getNumUndoCpRecs() to get the number of undo records after the checkpoint.)\n"
"    oacUndoNotEnabled\n"
"    oacCannotUnsetNonEmptyCp\n"
;

static PyObject*
oaDesign_unsetCp(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObject* self=(PyoaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->unsetCp();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_isNull_doc[] =
"Class: oaDesign, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDesign_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDesign data;
    int convert_status=PyoaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDesign_assign_doc[] = 
"Class: oaDesign, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDesign_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDesign data;
  int convert_status=PyoaDesign_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDesign p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDesign_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDesign_methodlist[] = {
    {"calcVMSize",(PyCFunction)oaDesign_calcVMSize,METH_VARARGS,oaDesign_calcVMSize_doc},
    {"close",(PyCFunction)oaDesign_close,METH_VARARGS,oaDesign_close_doc},
    {"contains",(PyCFunction)oaDesign_contains,METH_VARARGS,oaDesign_contains_doc},
    {"defineSuperMaster",(PyCFunction)oaDesign_defineSuperMaster,METH_VARARGS,oaDesign_defineSuperMaster_doc},
    {"enableTimeStamps",(PyCFunction)oaDesign_enableTimeStamps,METH_VARARGS,oaDesign_enableTimeStamps_doc},
    {"enableUndo",(PyCFunction)oaDesign_enableUndo,METH_VARARGS,oaDesign_enableUndo_doc},
    {"evalSuperMaster",(PyCFunction)oaDesign_evalSuperMaster,METH_VARARGS,oaDesign_evalSuperMaster_doc},
    {"findParam",(PyCFunction)oaDesign_findParam,METH_VARARGS,oaDesign_findParam_doc},
    {"getAnalysisPoints",(PyCFunction)oaDesign_getAnalysisPoints,METH_VARARGS,oaDesign_getAnalysisPoints_doc},
    {"getAnalysisPointsIter",(PyCFunction)oaDesign_getAnalysisPointsIter,METH_VARARGS,oaDesign_getAnalysisPointsIter_doc},
    {"getAppDefsByDataType",(PyCFunction)oaDesign_getAppDefsByDataType,METH_VARARGS,oaDesign_getAppDefsByDataType_doc},
    {"getAppDefsByDataTypeIter",(PyCFunction)oaDesign_getAppDefsByDataTypeIter,METH_VARARGS,oaDesign_getAppDefsByDataTypeIter_doc},
    {"getAppObjectDefs",(PyCFunction)oaDesign_getAppObjectDefs,METH_VARARGS,oaDesign_getAppObjectDefs_doc},
    {"getAppObjectDefsIter",(PyCFunction)oaDesign_getAppObjectDefsIter,METH_VARARGS,oaDesign_getAppObjectDefsIter_doc},
    {"getAppObjects",(PyCFunction)oaDesign_getAppObjects,METH_VARARGS,oaDesign_getAppObjects_doc},
    {"getAppObjectsIter",(PyCFunction)oaDesign_getAppObjectsIter,METH_VARARGS,oaDesign_getAppObjectsIter_doc},
    {"getCellName",(PyCFunction)oaDesign_getCellName,METH_VARARGS,oaDesign_getCellName_doc},
    {"getCellType",(PyCFunction)oaDesign_getCellType,METH_VARARGS,oaDesign_getCellType_doc},
    {"getConstraintGroupHeaders",(PyCFunction)oaDesign_getConstraintGroupHeaders,METH_VARARGS,oaDesign_getConstraintGroupHeaders_doc},
    {"getConstraintGroupHeadersIter",(PyCFunction)oaDesign_getConstraintGroupHeadersIter,METH_VARARGS,oaDesign_getConstraintGroupHeadersIter_doc},
    {"getConstraintGroups",(PyCFunction)oaDesign_getConstraintGroups,METH_VARARGS,oaDesign_getConstraintGroups_doc},
    {"getConstraintGroupsIter",(PyCFunction)oaDesign_getConstraintGroupsIter,METH_VARARGS,oaDesign_getConstraintGroupsIter_doc},
    {"getConstraintParams",(PyCFunction)oaDesign_getConstraintParams,METH_VARARGS,oaDesign_getConstraintParams_doc},
    {"getConstraintParamsIter",(PyCFunction)oaDesign_getConstraintParamsIter,METH_VARARGS,oaDesign_getConstraintParamsIter_doc},
    {"getConstraints",(PyCFunction)oaDesign_getConstraints,METH_VARARGS,oaDesign_getConstraints_doc},
    {"getConstraintsIter",(PyCFunction)oaDesign_getConstraintsIter,METH_VARARGS,oaDesign_getConstraintsIter_doc},
    {"getCpID",(PyCFunction)oaDesign_getCpID,METH_VARARGS,oaDesign_getCpID_doc},
    {"getCreateTime",(PyCFunction)oaDesign_getCreateTime,METH_VARARGS,oaDesign_getCreateTime_doc},
    {"getDefaultConstraintGroup",(PyCFunction)oaDesign_getDefaultConstraintGroup,METH_VARARGS,oaDesign_getDefaultConstraintGroup_doc},
    {"getGroups",(PyCFunction)oaDesign_getGroups,METH_VARARGS,oaDesign_getGroups_doc},
    {"getGroupsByName",(PyCFunction)oaDesign_getGroupsByName,METH_VARARGS,oaDesign_getGroupsByName_doc},
    {"getGroupsByNameIter",(PyCFunction)oaDesign_getGroupsByNameIter,METH_VARARGS,oaDesign_getGroupsByNameIter_doc},
    {"getGroupsIter",(PyCFunction)oaDesign_getGroupsIter,METH_VARARGS,oaDesign_getGroupsIter_doc},
    {"getLastSavedTime",(PyCFunction)oaDesign_getLastSavedTime,METH_VARARGS,oaDesign_getLastSavedTime_doc},
    {"getLib",(PyCFunction)oaDesign_getLib,METH_VARARGS,oaDesign_getLib_doc},
    {"getLibName",(PyCFunction)oaDesign_getLibName,METH_VARARGS,oaDesign_getLibName_doc},
    {"getModInstHeaders",(PyCFunction)oaDesign_getModInstHeaders,METH_VARARGS,oaDesign_getModInstHeaders_doc},
    {"getModInstHeadersIter",(PyCFunction)oaDesign_getModInstHeadersIter,METH_VARARGS,oaDesign_getModInstHeadersIter_doc},
    {"getMode",(PyCFunction)oaDesign_getMode,METH_VARARGS,oaDesign_getMode_doc},
    {"getModules",(PyCFunction)oaDesign_getModules,METH_VARARGS,oaDesign_getModules_doc},
    {"getModulesIter",(PyCFunction)oaDesign_getModulesIter,METH_VARARGS,oaDesign_getModulesIter_doc},
    {"getNumUndoCpRecs",(PyCFunction)oaDesign_getNumUndoCpRecs,METH_VARARGS,oaDesign_getNumUndoCpRecs_doc},
    {"getParams",(PyCFunction)oaDesign_getParams,METH_VARARGS,oaDesign_getParams_doc},
    {"getPcellDef",(PyCFunction)oaDesign_getPcellDef,METH_VARARGS,oaDesign_getPcellDef_doc},
    {"getPcellEvaluatorName",(PyCFunction)oaDesign_getPcellEvaluatorName,METH_VARARGS,oaDesign_getPcellEvaluatorName_doc},
    {"getReadInTime",(PyCFunction)oaDesign_getReadInTime,METH_VARARGS,oaDesign_getReadInTime_doc},
    {"getRefCount",(PyCFunction)oaDesign_getRefCount,METH_VARARGS,oaDesign_getRefCount_doc},
    {"getSubMasters",(PyCFunction)oaDesign_getSubMasters,METH_VARARGS,oaDesign_getSubMasters_doc},
    {"getSubMastersIter",(PyCFunction)oaDesign_getSubMastersIter,METH_VARARGS,oaDesign_getSubMastersIter_doc},
    {"getSuperMaster",(PyCFunction)oaDesign_getSuperMaster,METH_VARARGS,oaDesign_getSuperMaster_doc},
    {"getTech",(PyCFunction)oaDesign_getTech,METH_VARARGS,oaDesign_getTech_doc},
    {"getTimeStamp",(PyCFunction)oaDesign_getTimeStamp,METH_VARARGS,oaDesign_getTimeStamp_doc},
    {"getTopBlock",(PyCFunction)oaDesign_getTopBlock,METH_VARARGS,oaDesign_getTopBlock_doc},
    {"getTopModule",(PyCFunction)oaDesign_getTopModule,METH_VARARGS,oaDesign_getTopModule_doc},
    {"getTopOccurrence",(PyCFunction)oaDesign_getTopOccurrence,METH_VARARGS,oaDesign_getTopOccurrence_doc},
    {"getUsedIn",(PyCFunction)oaDesign_getUsedIn,METH_VARARGS,oaDesign_getUsedIn_doc},
    {"getUsedInIter",(PyCFunction)oaDesign_getUsedInIter,METH_VARARGS,oaDesign_getUsedInIter_doc},
    {"getValues",(PyCFunction)oaDesign_getValues,METH_VARARGS,oaDesign_getValues_doc},
    {"getValuesIter",(PyCFunction)oaDesign_getValuesIter,METH_VARARGS,oaDesign_getValuesIter_doc},
    {"getViaHeaderUsedIn",(PyCFunction)oaDesign_getViaHeaderUsedIn,METH_VARARGS,oaDesign_getViaHeaderUsedIn_doc},
    {"getViaHeaderUsedInIter",(PyCFunction)oaDesign_getViaHeaderUsedInIter,METH_VARARGS,oaDesign_getViaHeaderUsedInIter_doc},
    {"getViewName",(PyCFunction)oaDesign_getViewName,METH_VARARGS,oaDesign_getViewName_doc},
    {"getViewType",(PyCFunction)oaDesign_getViewType,METH_VARARGS,oaDesign_getViewType_doc},
    {"hasDefaultConstraintGroup",(PyCFunction)oaDesign_hasDefaultConstraintGroup,METH_VARARGS,oaDesign_hasDefaultConstraintGroup_doc},
    {"hasSymmetricConnectivity",(PyCFunction)oaDesign_hasSymmetricConnectivity,METH_VARARGS,oaDesign_hasSymmetricConnectivity_doc},
    {"isInUndo",(PyCFunction)oaDesign_isInUndo,METH_VARARGS,oaDesign_isInUndo_doc},
    {"isModified",(PyCFunction)oaDesign_isModified,METH_VARARGS,oaDesign_isModified_doc},
    {"isScalarized",(PyCFunction)oaDesign_isScalarized,METH_VARARGS,oaDesign_isScalarized_doc},
    {"isStdViaMaster",(PyCFunction)oaDesign_isStdViaMaster,METH_VARARGS,oaDesign_isStdViaMaster_doc},
    {"isSubMaster",(PyCFunction)oaDesign_isSubMaster,METH_VARARGS,oaDesign_isSubMaster_doc},
    {"isSuperMaster",(PyCFunction)oaDesign_isSuperMaster,METH_VARARGS,oaDesign_isSuperMaster_doc},
    {"isUndoEnabled",(PyCFunction)oaDesign_isUndoEnabled,METH_VARARGS,oaDesign_isUndoEnabled_doc},
    {"minimizeVM",(PyCFunction)oaDesign_minimizeVM,METH_VARARGS,oaDesign_minimizeVM_doc},
    {"openHier",(PyCFunction)oaDesign_openHier,METH_VARARGS,oaDesign_openHier_doc},
    {"preAllocate",(PyCFunction)oaDesign_preAllocate,METH_VARARGS,oaDesign_preAllocate_doc},
    {"purge",(PyCFunction)oaDesign_purge,METH_VARARGS,oaDesign_purge_doc},
    {"redo",(PyCFunction)oaDesign_redo,METH_VARARGS,oaDesign_redo_doc},
    {"reopen",(PyCFunction)oaDesign_reopen,METH_VARARGS,oaDesign_reopen_doc},
    {"revert",(PyCFunction)oaDesign_revert,METH_VARARGS,oaDesign_revert_doc},
    {"save",(PyCFunction)oaDesign_save,METH_VARARGS,oaDesign_save_doc},
    {"saveAs",(PyCFunction)oaDesign_saveAs,METH_VARARGS,oaDesign_saveAs_doc},
    {"scalarize",(PyCFunction)oaDesign_scalarize,METH_VARARGS,oaDesign_scalarize_doc},
    {"setCellType",(PyCFunction)oaDesign_setCellType,METH_VARARGS,oaDesign_setCellType_doc},
    {"setCp",(PyCFunction)oaDesign_setCp,METH_VARARGS,oaDesign_setCp_doc},
    {"setTopModule",(PyCFunction)oaDesign_setTopModule,METH_VARARGS,oaDesign_setTopModule_doc},
    {"undefineSuperMaster",(PyCFunction)oaDesign_undefineSuperMaster,METH_VARARGS,oaDesign_undefineSuperMaster_doc},
    {"undo",(PyCFunction)oaDesign_undo,METH_VARARGS,oaDesign_undo_doc},
    {"unsetCp",(PyCFunction)oaDesign_unsetCp,METH_VARARGS,oaDesign_unsetCp_doc},
    {"isNull",(PyCFunction)oaDesign_tp_isNull,METH_VARARGS,oaDesign_isNull_doc},
    {"assign",(PyCFunction)oaDesign_tp_assign,METH_VARARGS,oaDesign_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDesign_doc[] = 
"Class: oaDesign\n"
"  An oaDesign is a database that holds all the design data that describes a part of a design. All netlists, schematics, layouts and other design representations live as a set of oaDesigns in OpenAccess. It is a container for the connectivity, geometry, hierarchy, parasitics, and floorplanning information about a design.\n"
"  Each oaDesign lives in a cellView in an OpenAccess library and is identified by the lib, cell, and view names for that oaCellView . It will be persistently represented as one or more files in that cellView. The information that the application needs is read from the database file when it is accessed through the OpenAccess API. A number of operations on each oaDesign, such as the first time it is opened, and when it is purged from memory, will trigger callbacks that may be registered with an oaObserver<oaDesign> object. See oaDesign Observer Notification, Binding, and Loading in the Programmers Guide for more information on using design observers.\n"
"  An oaDesign is the container for all classes that derive from oaDesignObject . An application can open an oaDesign explicitly with the open() call or implicitly by traversing from an oaInst to its master. All design database objects can be reached by traversing from the oaDesign to its contents.\n"
"  The design connectivity and hierarchy can be represented three distinct ways in an oaDesign. These are referred to as hierarchy domains, as follows:\n"
"  1) Block Domain: The oaDesign may contain an oaBlock , which holds all the design geometry, its physical connectivity and instances of other oaDesigns that lead down a design hierarchy. This is the block or physical domain.\n"
"  2) Module Domain: The oaDesign may contain a number of oaModule objects that define a logical hierarchy. Several levels of this module hierarchy may live in a single oaDesign. This is the module or logical domain.\n"
"  3) Occurrence Domain: In this domain every net and instance in the hierarchy has a unique representation, even when multiple instances of a module or a block cause the connectivity object to be reused. See OpenAccess Hierarchy Domains in the Programmers Guide for more information on this topic.\n"
"  All of these domains can be present in an oaDesign at the same time. The oaDesign also may contain parasitic data that provides an electrical model of the physical nets in the design.\n"
"  The oaDesign class can be observed by deriving from\n"
"  oaDesigns in the Context of pCell SuperMasters and SubMasters\n"
"  oaDesigns also may be created as both SuperMasters and SubMasters of pcells. To create a pcell, you create an oaDesign and then you call oaDesign::defineSuperMaster on that oaDesign to turn it into a pcell superMaster. The superMaster has a set of parameters with their default values.\n"
"  When an instance of a pcell superMaster is created, the call to create that instance may specify a param array that contains some or all of the parameters associated with the superMaster. The values in the paramArray specified for the instance are the  override  parameters that specify the non-default values for this particular instance.\n"
"  SubMasters are usually created by creating an instance of the pcell and traversing to the master of that instance, which is the pcell subMaster. This traversal process is explained below. SubMasters also can be explicitly created by calling oaDesign::open and specifying a set of param values. SubMasters are not stored on disk, and only exist in memory.\n"
"  When an application traverses to the master for the pcell instance, it will go to the subMaster oaDesign for that set of parameter values. The subMaster is created at run time by running the application s evaluation routine the first time the master is traversed to for a given parameter set for a given pcell.\n"
"  The caller must register a pcell evaluation routine by constructing an oaPcellObserver that has an override for the virtual function onPreEval() or onPostEval(). When OpenAccess needs to have a subMaster for a given parameterization of a superMaster, it calls the evaluator that has been registered for that superMaster.\n"
"Constructors:\n"
"  Paramegers: (oaDesign)\n"
"    Calls: (const oaDesign&)\n"
"    Signature: oaDesign||cref-oaDesign,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDesign_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDesign",
    sizeof(PyoaDesignObject),
    0,
    (destructor)oaDesign_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDesign_tp_compare,	/* tp_compare */
    (reprfunc)oaDesign_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDesign_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDesign_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaDesignObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDesign_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDesign_static_destroy_doc[] = 
"Class: oaDesign, Function: destroy\n"
"  Paramegers: (oaScalarName,oaScalarName,oaScalarName)\n"
"    Calls: void destroy(const oaScalarName& libNameIn,const oaScalarName& cellNameIn,const oaScalarName& viewNameIn)\n"
"    Signature: destroy|void-void|cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,\n"
"    oaDesign::destroy\n"
"    This function removes the on-disk design data. The design must exist, and must not currently be open.\n"
"    oacDestroyCannotFindDesign\n"
"    oacDestroyDesignOpen\n"
;

static PyObject*
oaDesign_static_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaScalarName p1;
    PyParamoaScalarName p2;
    PyParamoaScalarName p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaScalarName_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaScalarName_Convert,&p3)) {
        oaDesign::destroy(p1.Data(),p2.Data(),p3.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_static_exists_doc[] = 
"Class: oaDesign, Function: exists\n"
"  Paramegers: (oaScalarName,oaScalarName,oaScalarName)\n"
"    Calls: oaBoolean exists(const oaScalarName& libNameIn,const oaScalarName& cellNameIn,const oaScalarName& viewNameIn)\n"
"    Signature: exists|simple-oaBoolean|cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,\n"
"    This function returns true if a design is currently open with the specified library, cell, and view names, or if the design is found on disk. If the design is found on disk, the design must have a non-zero size.\n"
;

static PyObject*
oaDesign_static_exists(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaScalarName p1;
    PyParamoaScalarName p2;
    PyParamoaScalarName p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaScalarName_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaScalarName_Convert,&p3)) {
        oaBoolean result= (oaDesign::exists(p1.Data(),p2.Data(),p3.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_static_find_doc[] = 
"Class: oaDesign, Function: find\n"
"  Paramegers: (oaScalarName,oaScalarName,oaScalarName)\n"
"    Calls: oaDesign* find(const oaScalarName& libNameIn,const oaScalarName& cellNameIn,const oaScalarName& viewNameIn)\n"
"    Signature: find|ptr-oaDesign|cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,\n"
"    This function attempts to find a design with the specified library, cell, and view names. If the specified design is open, it is returned. Otherwise, NULL is returned. Calling find() does not increment the reference count for the design.\n"
;

static PyObject*
oaDesign_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaScalarName p1;
    PyParamoaScalarName p2;
    PyParamoaScalarName p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaScalarName_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaScalarName_Convert,&p3)) {
        oaDesignp result= (oaDesign::find(p1.Data(),p2.Data(),p3.Data()));
        return PyoaDesign_FromoaDesign(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_static_getOpenDesigns_doc[] = 
"Class: oaDesign, Function: getOpenDesigns\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaDesign_oaDesign getOpenDesigns()\n"
"    Signature: getOpenDesigns|simple-oaCollection_oaDesign_oaDesign|\n"
"    BrowseData: 1\n"
"    This function returns a collection of open designs.\n"
;

static PyObject*
oaDesign_static_getOpenDesigns(PyObject* ob, PyObject *args)
{
  try {
    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaDesign_oaDesign* result= new oaCollection_oaDesign_oaDesign(oaDesign::getOpenDesigns());
        return PyoaCollection_oaDesign_oaDesign_FromoaCollection_oaDesign_oaDesign(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_static_getOpenDesignsIter_doc[] = 
"Class: oaDesign, Function: getOpenDesignsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaDesign getOpenDesignsIter()\n"
"    Signature: getOpenDesignsIter|simple-oaIter_oaDesign|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of open designs.\n"
;

static PyObject*
oaDesign_static_getOpenDesignsIter(PyObject* ob, PyObject *args)
{
  try {
    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaDesign* result= new oaIter_oaDesign(oaDesign::getOpenDesigns());
        return PyoaIter_oaDesign_FromoaIter_oaDesign(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_static_getRevNumber_doc[] = 
"Class: oaDesign, Function: getRevNumber\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getRevNumber()\n"
"    Signature: getRevNumber|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the revision number of the internal format for the design format.\n"
"    oaUInt4\n"
;

static PyObject*
oaDesign_static_getRevNumber(PyObject* ob, PyObject *args)
{
  try {
    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (oaDesign::getRevNumber());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesign_static_open_doc[] = 
"Class: oaDesign, Function: open\n"
"  Paramegers: (oaScalarName,oaScalarName,oaScalarName,oaViewType,oaChar)\n"
"    Calls: oaDesign* open(const oaScalarName& libNameIn,const oaScalarName& cellNameIn,const oaScalarName& viewNameIn,const oaViewType* viewType,oaChar mode)\n"
"    Signature: open|ptr-oaDesign|cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cptr-oaViewType,simple-oaChar,\n"
"    oaDesign::open\n"
"    This function attempts to open the design with the specified library, cell, and view name with the specified access mode. If successful, the design is returned. This version opens the design using the viewType attribute of the oaViewType object pointed to by viewType .\n"
"    This version can be used to write a new design since it can assign a viewType to that design. When used to read or modify a design, it only succeeds if that design was previously created with the specified viewType. Typically, the design to be opened must be the primary file in the cellView. However, if the cellView has a non-design viewType, this function can be used to open a non-primary database. See OpenAccess Libraries and Design Management for more information about primary files.\n"
"    When you open a library for 'w'rite, 'a'ppend, or 'A'ppend with this function, the library container is temporarily locked. If another user attempts to use oaDesign::open to 'w'rite, 'a'ppend, or 'A'ppend to the library, an oacDesignCannotGetWriteAccess exception is thrown. This behavior protects against another process opening the same library for write or append access. Note that having a design open for write access does not interfere with another process reading the database.\n"
"    When you open a database in 'w'rite mode and then save the database, the mode changes to 'a'ppend. When you open a database in 'A'ppend mode and then save that database, the mode changes to 'a'ppend.\n"
"    After opening the library for 'w'rite, 'a'ppend, or 'A'ppend, OpenAccess creates a database file and a lock file for you. After this point, the access to the library container is once again opened for 'w'rite, 'a'ppend, or 'A'ppend mode to other users. However, anyone attempting to access the locked database file will get an oacCannotLockDatabase exception.\n"
"    Each open() increments the reference count on this design (see oaDesign::close for a further discussion).\n"
"    Note: Although users can construct their own oaViewTypes, when opening a design with this function, valid viewTypes are restricted to a subset of oaReservedViewTypes, namely, an oaReservedViewType object constructed with one of the following enumerated constants: oacMaskLayout , oacSchematic , oacSchematicSymbol , oacNetlist , or oacHierDesign . An exception is thrown if viewType is not one of these reserved design viewTypes.\n"
"    Standard practice is to call oaViewType::get(oaReservedViewType) to construct a oaViewType object using one of the valid reserved design viewType enumerated constants, then pass a pointer to the constructed oaViewType object to oaDesign::open() via the viewType parameter.\n"
"    libNameIn\n"
"    The name of an existing library\n"
"    cellNameIn\n"
"    The name of a cell\n"
"    viewNameIn\n"
"    The name of a view\n"
"    viewType\n"
"    A pointer to the viewType.\n"
"    mode\n"
"    The mode in which to open the design\n"
"    'r' for read\n"
"    'w' for write\n"
"    'a' for append\n"
"    'A' for append in override mode, which is not typically used. Refer to Compatibility for OpenAccess Applications and Data in the Programmers Guide for more information.\n"
"    oacCannotFindLibrary\n"
"    If the lib name doesn't exist, or in read mode if the cell or view doesn't exist\n"
"    oacOpenOnDesignBeingPurged\n"
"    oacOpenUndefinedModeDesign\n"
"    oacMismatchViewTypeForOpen\n"
"    oacCannotFindDesign\n"
"    oacDataNotCompatibleOnOpen\n"
"    The design contains new features that are not understood by this version of OpenAccess and cannot be opened\n"
"    oacDataNotCompatibleOnOpenInAppendMode\n"
"    The design contains new features that are not understood by this version of OpenAccess and cannot be opened in append mode\n"
"    oacDesignPrimaryFileDoesNotExist\n"
"    oacDesignFollowerFileDoesNotExist\n"
"    oacInvalidDatabaseFile\n"
"    oacFileNotWritable\n"
"    oacInvalidDesignViewType\n"
"    oacDesignCannotGetReadAccess\n"
"    oacLibAccessCannotUpgrade\n"
"    oacDesignHasReadNeedWriteAccess\n"
"    oacDesignCannotGetWriteAccess\n"
"    oacCorruptedDatabase\n"
"    oacCannotRepairCorruptedAppData\n"
"    oacCorruptedSteinerConnRoutes\n"
"    oacCorruptedMustJoinTerms\n"
"    oacCorruptedSupplySensitivityTerms\n"
"    oacCorruptedGroundSensitivityTerms\n"
"  Paramegers: (oaScalarName,oaScalarName,oaScalarName,oaChar)\n"
"    Calls: oaDesign* open(const oaScalarName& libNameIn,const oaScalarName& cellNameIn,const oaScalarName& viewNameIn,oaChar mode)\n"
"    Signature: open|ptr-oaDesign|cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,simple-oaChar,\n"
"    This function attempts to open the design with the specified library, cell, and view name with the specified access mode. If successful, the design is returned. This version looks for a design with any viewType.\n"
"    This version can be used to open existing designs for reading or modifying. An exception is thrown if this open function is called to create (write) a new design since each design requires the specification of a viewType when it is created.\n"
"    When you open a library for 'w'rite, 'a'ppend, or 'A'ppend with this function, the library container is temporarily locked. If another user attempts to use oaDesign::open to 'w'rite, 'a'ppend, or 'A'ppend to the library, an oacDesignCannotGetWriteAccess exception is thrown. This behavior protects against another process opening the same library for write or append access. Note that having a design open for write access does not interfere with another process reading the database.\n"
"    When you open a database in 'w'rite mode and then save the database, the mode changes to 'a'ppend. When you open a database in 'A'ppend mode and then save that database, the mode changes to 'a'ppend.\n"
"    After opening the library for 'w'rite, 'a'ppend, or 'A'ppend, OpenAccess creates a database file and a lock file for you. After this point, the access to the library container is once again opened for 'w'rite, 'a'ppend, or 'A'ppend mode to other users. However, anyone attempting to access the locked database file will get an oacCannotLockDatabase exception.\n"
"    Each open() increments the reference count on this design (see oaDesign::close for a further discussion).\n"
"    libNameIn\n"
"    The name of an existing library\n"
"    cellNameIn\n"
"    The name of an existing cell\n"
"    viewNameIn\n"
"    The name of an existing design\n"
"    mode\n"
"    The mode in which to open the existing design\n"
"    'r' for read\n"
"    'w' for write\n"
"    'a' for append\n"
"    'A' for append in override mode, which is not typically used. Refer to Compatibility for OpenAccess Applications and Data in the Programmers Guide for more information.\n"
"    Note: The design must already exist, even when opening for write.\n"
"    A pointer to an open design or throws an exception\n"
"    oacCannotFindLibrary\n"
"    If the lib name doesn't exist, or in read mode if the cell or view doesn't exist\n"
"    oacOpenOnDesignBeingPurged\n"
"    oacOpenUndefinedModeDesign\n"
"    The mode character is illegal\n"
"    oacInvalidDatabaseFile\n"
"    oacFileNotWritable\n"
"    oacCannotFindDesign\n"
"    oacDataNotCompatibleOnOpen\n"
"    The design contains new features that are not understood by this version of OpenAccess and cannot be opened\n"
"    oacDataNotCompatibleOnOpenInAppendMode\n"
"    The design contains new features that are not understood by this version of OpenAccess and cannot be opened in append mode\n"
"    oacDesignPrimaryFileDoesNotExist\n"
"    oacDesignFollowerFileDoesNotExist\n"
"    oacDesignCannotGetReadAccess\n"
"    oacLibAccessCannotUpgrade\n"
"    oacDesignHasReadNeedWriteAccess\n"
"    oacDesignCannotGetWriteAccess\n"
"    oacCorruptedDatabase\n"
"    oacCannotRepairCorruptedAppData\n"
"    oacCorruptedSteinerConnRoutes\n"
"    oacCorruptedMustJoinTerms\n"
"    oacCorruptedSupplySensitivityTerms\n"
"    oacCorruptedGroundSensitivityTerms\n"
"  Paramegers: (oaScalarName,oaScalarName,oaScalarName,oaParamArray)\n"
"    Calls: oaDesign* open(const oaScalarName& libNameIn,const oaScalarName& cellNameIn,const oaScalarName& viewNameIn,const oaParamArray& params)\n"
"    Signature: open|ptr-oaDesign|cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cref-oaParamArray,\n"
"    This function will find or create a submaster for the given supermaster oaDesign. If the submaster has already been created it will return it and increment its reference count (see oaDesign::close for a further discussion of reference counts).\n"
"    If the supermaster is in memory, but not the appropriate submaster, the submaster will be created. If the supermaster is not yet open it will search the given library location for an oaDesign of any viewType and open it in  r ead mode. Then it will create the appropriate submaster.\n"
"    oacCannotFindLibrary\n"
"    oacCannotFindDesign\n"
"    oacInvalidSuperMaster\n"
"    oacInvalidDatabaseFile\n"
"    oacCorruptedDatabase\n"
"    oacCannotRepairCorruptedAppData\n"
"    oacCorruptedSteinerConnRoutes\n"
"    oacCorruptedMustJoinTerms\n"
"    oacCorruptedSupplySensitivityTerms\n"
"    oacCorruptedGroundSensitivityTerms\n"
"  Paramegers: (oaStdViaDef)\n"
"    Calls: oaDesign* open(oaStdViaDef* viaDef)\n"
"    Signature: open|ptr-oaDesign|ptr-oaStdViaDef,ptr-oaViaParam,\n"
"    This function attempts to return the viaMaster associated with the specified stdViaDef object. If the viaMaster does not exist, one will be generated and returned. If the via parameter array is not specified, the default parameter associated with the given stdViaDef is used.\n"
"    viaDef\n"
"    The standard viaDef.\n"
"    params\n"
"    The via parameter array.\n"
"  Paramegers: (oaStdViaDef,oaViaParam)\n"
"    Calls: oaDesign* open(oaStdViaDef* viaDef,oaViaParam* params)\n"
"    Signature: open|ptr-oaDesign|ptr-oaStdViaDef,ptr-oaViaParam,\n"
"    This function attempts to return the viaMaster associated with the specified stdViaDef object. If the viaMaster does not exist, one will be generated and returned. If the via parameter array is not specified, the default parameter associated with the given stdViaDef is used.\n"
"    viaDef\n"
"    The standard viaDef.\n"
"    params\n"
"    The via parameter array.\n"
"  Paramegers: (oaCustomViaDef)\n"
"    Calls: oaDesign* open(oaCustomViaDef* viaDef)\n"
"    Signature: open|ptr-oaDesign|ptr-oaCustomViaDef,ptr-oaParamArray,\n"
"    This function attempts to open the design with associated with the specified customViaDef. If the parameter array is specified, the subMaster is returned. Exception is thrown if the parameter array is specified and the design is not a parameterized cell. An exception is thrown if no design exists.\n"
"    viaDef\n"
"    The custom viaDef\n"
"    params\n"
"    The parameter array\n"
"    oacCannotFindLibrary\n"
"    oacCannotFindDesign\n"
"  Paramegers: (oaCustomViaDef,oaParamArray)\n"
"    Calls: oaDesign* open(oaCustomViaDef* viaDef,oaParamArray* params)\n"
"    Signature: open|ptr-oaDesign|ptr-oaCustomViaDef,ptr-oaParamArray,\n"
"    This function attempts to open the design with associated with the specified customViaDef. If the parameter array is specified, the subMaster is returned. Exception is thrown if the parameter array is specified and the design is not a parameterized cell. An exception is thrown if no design exists.\n"
"    viaDef\n"
"    The custom viaDef\n"
"    params\n"
"    The parameter array\n"
"    oacCannotFindLibrary\n"
"    oacCannotFindDesign\n"
;

static PyObject*
oaDesign_static_open(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaScalarName,oaScalarName,oaScalarName,oaViewType,oaChar)
    {
        PyParamoaScalarName p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaViewType p4;
        PyParamoaChar p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaScalarName_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaViewType_Convert,&p4,
              &PyoaChar_Convert,&p5)) {
            if (!PyValidateDbObject(p4.Data(),4)) return NULL;
            oaDesignp result= (oaDesign::open(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
            return PyoaDesign_FromoaDesign(result);
        }
    }
    PyErr_Clear();
    // Case: (oaScalarName,oaScalarName,oaScalarName,oaChar)
    {
        PyParamoaScalarName p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaChar p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaScalarName_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaChar_Convert,&p4)) {
            oaDesignp result= (oaDesign::open(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaDesign_FromoaDesign(result);
        }
    }
    PyErr_Clear();
    // Case: (oaScalarName,oaScalarName,oaScalarName,oaParamArray)
    {
        PyParamoaScalarName p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaParamArray p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaScalarName_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaParamArray_Convert,&p4)) {
            oaDesignp result= (oaDesign::open(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaDesign_FromoaDesign(result);
        }
    }
    PyErr_Clear();
    // Case: (oaStdViaDef)
    {
        PyParamoaStdViaDef p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaStdViaDef_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaDesignp result= (oaDesign::open(p1.Data()));
            return PyoaDesign_FromoaDesign(result);
        }
    }
    PyErr_Clear();
    // Case: (oaStdViaDef,oaViaParam)
    {
        PyParamoaStdViaDef p1;
        PyParamoaViaParam p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaStdViaDef_Convert,&p1,
              &PyoaViaParam_ConvertAof,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaDesignp result= (oaDesign::open(p1.Data(),p2.DataAof()));
            return PyoaDesign_FromoaDesign(result);
        }
    }
    PyErr_Clear();
    // Case: (oaCustomViaDef)
    {
        PyParamoaCustomViaDef p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaCustomViaDef_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaDesignp result= (oaDesign::open(p1.Data()));
            return PyoaDesign_FromoaDesign(result);
        }
    }
    PyErr_Clear();
    // Case: (oaCustomViaDef,oaParamArray)
    {
        PyParamoaCustomViaDef p1;
        PyParamoaParamArray p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaCustomViaDef_Convert,&p1,
              &PyoaParamArray_ConvertAof,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaDesignp result= (oaDesign::open(p1.Data(),p2.DataAof()));
            return PyoaDesign_FromoaDesign(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDesign, function: open, Choices are:\n"
        "    (oaScalarName,oaScalarName,oaScalarName,oaViewType,oaChar)\n"
        "    (oaScalarName,oaScalarName,oaScalarName,oaChar)\n"
        "    (oaScalarName,oaScalarName,oaScalarName,oaParamArray)\n"
        "    (oaStdViaDef)\n"
        "    (oaStdViaDef,oaViaParam)\n"
        "    (oaCustomViaDef)\n"
        "    (oaCustomViaDef,oaParamArray)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDesign_staticmethodlist[] = {
    {"static_destroy",(PyCFunction)oaDesign_static_destroy,METH_VARARGS,oaDesign_static_destroy_doc},
    {"static_exists",(PyCFunction)oaDesign_static_exists,METH_VARARGS,oaDesign_static_exists_doc},
    {"static_find",(PyCFunction)oaDesign_static_find,METH_VARARGS,oaDesign_static_find_doc},
    {"static_getOpenDesigns",(PyCFunction)oaDesign_static_getOpenDesigns,METH_VARARGS,oaDesign_static_getOpenDesigns_doc},
    {"static_getOpenDesignsIter",(PyCFunction)oaDesign_static_getOpenDesignsIter,METH_VARARGS,oaDesign_static_getOpenDesignsIter_doc},
    {"static_getRevNumber",(PyCFunction)oaDesign_static_getRevNumber,METH_VARARGS,oaDesign_static_getRevNumber_doc},
    {"static_open",(PyCFunction)oaDesign_static_open,METH_VARARGS,oaDesign_static_open_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDesign_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDesign_Type)<0) {
      printf("** PyType_Ready failed for: oaDesign\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDesign",
           (PyObject*)(&PyoaDesign_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDesign\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDesign_Type.tp_dict;
    for(method=oaDesign_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDesignAttrType
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDesignAttrType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDesignAttrType_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDesignAttrTypeObject* self = (PyoaDesignAttrTypeObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDesignAttrTypeEnum)
    {
        PyParamoaDesignAttrTypeEnum p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDesignAttrTypeEnum_Convert,&p1)) {
            self->value = (oaAttrType*)  new oaDesignAttrType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            self->value = (oaAttrType*)  new oaDesignAttrType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaAttrType)
    {
        PyParamoaAttrType p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaAttrType_Convert,&p1)) {
            self->value = (oaAttrType*)  new oaDesignAttrType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaDesignAttrType)
    {
        PyParamoaDesignAttrType p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDesignAttrType_Convert,&p1)) {
            self->value=(oaAttrType*)  new oaDesignAttrType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDesignAttrType, Choices are:\n"
        "    (oaDesignAttrTypeEnum)\n"
        "    (oaString)\n"
        "    (oaAttrType)\n"
        "    (oaDesignAttrType)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDesignAttrType_tp_dealloc(PyoaDesignAttrTypeObject* self)
{
    if (!self->borrow) {
        delete (oaDesignAttrType*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDesignAttrType_tp_repr(PyObject *ob)
{
    PyParamoaDesignAttrType value;
    int convert_status=PyoaDesignAttrType_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    oaString sresult(value.DataCall()->getName());

    char addr[38];
    sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
    oaString buffer;
    buffer+=oaString("<oaDesignAttrType::");
    buffer+=oaString(addr);
    buffer+=oaString("::");
    buffer+=oaString(sresult);
    buffer+=oaString(">");
    result=PyString_FromString((char*)(const char*)buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDesignAttrType_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDesignAttrType v1;
    PyParamoaDesignAttrType v2;
    int convert_status1=PyoaDesignAttrType_Convert(ob1,&v1);
    int convert_status2=PyoaDesignAttrType_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDesignAttrType_Convert(PyObject* ob,PyParamoaDesignAttrType* result)
{
    if (ob == NULL) return 1;
    if (PyoaDesignAttrType_Check(ob)) {
        result->SetData( (oaDesignAttrType*) ((PyoaDesignAttrTypeObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDesignAttrType Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDesignAttrType_FromoaDesignAttrType(oaDesignAttrType* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaDesignAttrType_Type.tp_alloc(&PyoaDesignAttrType_Type,0);
        if (bself == NULL) return bself;
        PyoaDesignAttrTypeObject* self = (PyoaDesignAttrTypeObject*)bself;
        self->value = (oaAttrType*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDesignAttrType_getName_doc[] = 
"Class: oaDesignAttrType, Function: getName\n"
"  Paramegers: ()\n"
"    Calls: const oaString& getName() const\n"
"    Signature: getName|cref-oaString|\n"
"    BrowseData: 1\n"
"    This function returns the name string associated with the encapsulated #oaDesignAttrTypeEnum object.\n"
;

static PyObject*
oaDesignAttrType_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignAttrType data;
    int convert_status=PyoaDesignAttrType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignAttrTypeObject* self=(PyoaDesignAttrTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaString result= (data.DataCall()->getName());
        return PyoaString_FromoaString(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignAttrType_getValue_doc[] = 
"Class: oaDesignAttrType, Function: getValue\n"
"  Paramegers: ()\n"
"    Calls: oaDesignAttrTypeEnum getValue() const\n"
"    Signature: getValue|simple-oaDesignAttrTypeEnum|\n"
"    BrowseData: 1\n"
"    This operator casts this oaDesignAttrType object into the corresponding #oaDesignAttrTypeEnum value.\n"
;

static PyObject*
oaDesignAttrType_getValue(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignAttrType data;
    int convert_status=PyoaDesignAttrType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignAttrTypeObject* self=(PyoaDesignAttrTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaDesignAttrTypeEnum result= (data.DataCall()->getValue());
        return PyoaDesignAttrTypeEnum_FromoaDesignAttrTypeEnum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaDesignAttrType_assign_doc[] = 
"Class: oaDesignAttrType, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDesignAttrType_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDesignAttrType data;
  int convert_status=PyoaDesignAttrType_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDesignAttrType p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDesignAttrType_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDesignAttrType_methodlist[] = {
    {"getName",(PyCFunction)oaDesignAttrType_getName,METH_VARARGS,oaDesignAttrType_getName_doc},
    {"getValue",(PyCFunction)oaDesignAttrType_getValue,METH_VARARGS,oaDesignAttrType_getValue_doc},
    {"assign",(PyCFunction)oaDesignAttrType_tp_assign,METH_VARARGS,oaDesignAttrType_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDesignAttrType_doc[] = 
"Class: oaDesignAttrType\n"
"  The oaDesignAttrType class is an enum wrapper class for the different attributes of an oaDesign object that can be referenced by an oaAttrDisplay associated with an oaDesign or oaInstAttrDisplay .\n"
"  See Enum Wrappers in the Programmers Guide for a discussion of enum wrappers.\n"
"  oaDesignAttrTypeEnum\n"
"Constructors:\n"
"  Paramegers: (oaDesignAttrTypeEnum)\n"
"    Calls: oaDesignAttrType(oaDesignAttrTypeEnum valueIn)\n"
"    Signature: oaDesignAttrType||simple-oaDesignAttrTypeEnum,\n"
"    This function constructs an instance of an oaDesignAttrType class using the specified #oaDesignAttrTypeEnum value.\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDesignAttrType(const oaString& name)\n"
"    Signature: oaDesignAttrType||cref-oaString,\n"
"    This function constructs an instance of an oaDesignAttrType class using the #oaDesignAttrTypeEnum associated with the specified string name . This name must be defined in the legal set of names associated with #oaDesignAttrTypeEnum.\n"
"    oacInvalidDesignAttrTypeName\n"
"  Paramegers: (oaAttrType)\n"
"    Calls: oaDesignAttrType(oaAttrType attr)\n"
"    Signature: oaDesignAttrType||simple-oaAttrType,\n"
"    This function constructs an oaDesignAttrType class using the oaAttrType attribute value as input to support the class down-cast.\n"
"  Paramegers: (oaDesignAttrType)\n"
"    Calls: (const oaDesignAttrType&)\n"
"    Signature: oaDesignAttrType||cref-oaDesignAttrType,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDesignAttrType_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDesignAttrType",
    sizeof(PyoaDesignAttrTypeObject),
    0,
    (destructor)oaDesignAttrType_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDesignAttrType_tp_compare,	/* tp_compare */
    (reprfunc)oaDesignAttrType_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDesignAttrType_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDesignAttrType_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAttrType_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDesignAttrType_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDesignAttrType_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDesignAttrType_Type)<0) {
      printf("** PyType_Ready failed for: oaDesignAttrType\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDesignAttrType",
           (PyObject*)(&PyoaDesignAttrType_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDesignAttrType\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDesignAttrTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaDesignAttrTypeEnum_Convert(PyObject* ob,PyParamoaDesignAttrTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacLibNameDesignAttrType")==0) { result->SetData(oacLibNameDesignAttrType); return 1;}
        if (strcasecmp(str,"oacCellNameDesignAttrType")==0) { result->SetData(oacCellNameDesignAttrType); return 1;}
        if (strcasecmp(str,"oacViewNameDesignAttrType")==0) { result->SetData(oacViewNameDesignAttrType); return 1;}
        if (strcasecmp(str,"oacCellTypeDesignAttrType")==0) { result->SetData(oacCellTypeDesignAttrType); return 1;}
        if (strcasecmp(str,"oacLastSavedTimeDesignAttrType")==0) { result->SetData(oacLastSavedTimeDesignAttrType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaDesignAttrTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDesignAttrTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaDesignAttrTypeEnum_FromoaDesignAttrTypeEnum(oaDesignAttrTypeEnum ob)
{
    if (ob==oacLibNameDesignAttrType) return PyString_FromString("oacLibNameDesignAttrType");
    if (ob==oacCellNameDesignAttrType) return PyString_FromString("oacCellNameDesignAttrType");
    if (ob==oacViewNameDesignAttrType) return PyString_FromString("oacViewNameDesignAttrType");
    if (ob==oacCellTypeDesignAttrType) return PyString_FromString("oacCellTypeDesignAttrType");
    if (ob==oacLastSavedTimeDesignAttrType) return PyString_FromString("oacLastSavedTimeDesignAttrType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaDesignAttrTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaDesignAttrTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaDesignAttrTypeEnum_FromoaDesignAttrTypeEnum(oaDesignAttrTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaDesignAttrTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaDesignAttrTypeEnum_doc[] =
"Type convert function for enum: oaDesignAttrTypeEnum";
                               
static PyMethodDef PyoaDesignAttrTypeEnum_method =
  {"oaDesignAttrTypeEnum",(PyCFunction)PyoaDesignAttrTypeEnum_TypeFunction,METH_VARARGS,oaDesignAttrTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaDesignAttrTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacLibNameDesignAttrType");
    PyDict_SetItemString(mod_dict,"oacLibNameDesignAttrType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCellNameDesignAttrType");
    PyDict_SetItemString(mod_dict,"oacCellNameDesignAttrType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacViewNameDesignAttrType");
    PyDict_SetItemString(mod_dict,"oacViewNameDesignAttrType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCellTypeDesignAttrType");
    PyDict_SetItemString(mod_dict,"oacCellTypeDesignAttrType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLastSavedTimeDesignAttrType");
    PyDict_SetItemString(mod_dict,"oacLastSavedTimeDesignAttrType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaDesignAttrTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaDesignAttrTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaDesignAttrTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDesignCollTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaDesignCollTypeEnum_Convert(PyObject* ob,PyParamoaDesignCollTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacBaseDesignCollType")==0) { result->SetData(oacBaseDesignCollType); return 1;}
        if (strcasecmp(str,"oacSubMasterDesignCollType")==0) { result->SetData(oacSubMasterDesignCollType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaDesignCollTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDesignCollTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaDesignCollTypeEnum_FromoaDesignCollTypeEnum(oaDesignCollTypeEnum ob)
{
    if (ob==oacBaseDesignCollType) return PyString_FromString("oacBaseDesignCollType");
    if (ob==oacSubMasterDesignCollType) return PyString_FromString("oacSubMasterDesignCollType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaDesignCollTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaDesignCollTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaDesignCollTypeEnum_FromoaDesignCollTypeEnum(oaDesignCollTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaDesignCollTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaDesignCollTypeEnum_doc[] =
"Type convert function for enum: oaDesignCollTypeEnum";
                               
static PyMethodDef PyoaDesignCollTypeEnum_method =
  {"oaDesignCollTypeEnum",(PyCFunction)PyoaDesignCollTypeEnum_TypeFunction,METH_VARARGS,oaDesignCollTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaDesignCollTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacBaseDesignCollType");
    PyDict_SetItemString(mod_dict,"oacBaseDesignCollType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSubMasterDesignCollType");
    PyDict_SetItemString(mod_dict,"oacSubMasterDesignCollType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaDesignCollTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaDesignCollTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaDesignCollTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDesignCollection
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDesignCollection_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDesignCollection_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDesignCollectionObject* self = (PyoaDesignCollectionObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4,oaDesignCollTypeEnum)
    {
        PyParamoaUInt4 p1;
        PyParamoaDesignCollTypeEnum p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaDesignCollTypeEnum_Convert,&p2)) {
            self->value = (oaDatabaseCollection*)  new oaDesignCollection(p1.Data(),p2.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaDesignCollTypeEnum,oaDesign)
    {
        PyParamoaUInt4 p1;
        PyParamoaDesignCollTypeEnum p2;
        PyParamoaDesign p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaDesignCollTypeEnum_Convert,&p2,
              &PyoaDesign_Convert,&p3)) {
            if (!PyValidateDbObject(p3.Data(),3)) return NULL;
            self->value = (oaDatabaseCollection*)  new oaDesignCollection(p1.Data(),p2.Data(),p3.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaDesignCollection)
    {
        PyParamoaDesignCollection p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDesignCollection_Convert,&p1)) {
            self->value = (oaDatabaseCollection*)  new oaDesignCollection(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDesignCollection, Choices are:\n"
        "    (oaUInt4,oaDesignCollTypeEnum)\n"
        "    (oaUInt4,oaDesignCollTypeEnum,oaDesign)\n"
        "    (oaDesignCollection)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDesignCollection_tp_dealloc(PyoaDesignCollectionObject* self)
{
    if (!self->borrow) {
        delete (oaDesignCollection*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDesignCollection_tp_repr(PyObject *ob)
{
    PyParamoaDesignCollection value;
    int convert_status=PyoaDesignCollection_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[40];
    sprintf(buffer,"<oaDesignCollection::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDesignCollection_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDesignCollection v1;
    PyParamoaDesignCollection v2;
    int convert_status1=PyoaDesignCollection_Convert(ob1,&v1);
    int convert_status2=PyoaDesignCollection_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDesignCollection_Convert(PyObject* ob,PyParamoaDesignCollection* result)
{
    if (ob == NULL) return 1;
    if (PyoaDesignCollection_Check(ob)) {
        result->SetData( (oaDesignCollection*) ((PyoaDesignCollectionObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDesignCollection Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDesignCollection_FromoaDesignCollection(oaDesignCollection* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaDesignCollection_Type.tp_alloc(&PyoaDesignCollection_Type,0);
        if (bself == NULL) return bself;
        PyoaDesignCollectionObject* self = (PyoaDesignCollectionObject*)bself;
        self->value = (oaDatabaseCollection*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDesignCollection_getCount_doc[] = 
"Class: oaDesignCollection, Function: getCount\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getCount() const\n"
"    Signature: getCount|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    Function getCount\n"
;

static PyObject*
oaDesignCollection_getCount(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignCollection data;
    int convert_status=PyoaDesignCollection_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignCollectionObject* self=(PyoaDesignCollectionObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getCount());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignCollection_includes_doc[] = 
"Class: oaDesignCollection, Function: includes\n"
"  Paramegers: (oaDesign)\n"
"    Calls: oaBoolean includes(const oaDesign* design) const\n"
"    Signature: includes|simple-oaBoolean|cptr-oaDesign,\n"
"    Function includes\n"
;

static PyObject*
oaDesignCollection_includes(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignCollection data;
    int convert_status=PyoaDesignCollection_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignCollectionObject* self=(PyoaDesignCollectionObject*)ob;

    PyParamoaDesign p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaDesign_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->includes(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignCollection_isEmpty_doc[] = 
"Class: oaDesignCollection, Function: isEmpty\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isEmpty() const\n"
"    Signature: isEmpty|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    Function isEmpty\n"
;

static PyObject*
oaDesignCollection_isEmpty(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignCollection data;
    int convert_status=PyoaDesignCollection_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignCollectionObject* self=(PyoaDesignCollectionObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isEmpty());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaDesignCollection_assign_doc[] = 
"Class: oaDesignCollection, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDesignCollection_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDesignCollection data;
  int convert_status=PyoaDesignCollection_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDesignCollection p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDesignCollection_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDesignCollection_methodlist[] = {
    {"getCount",(PyCFunction)oaDesignCollection_getCount,METH_VARARGS,oaDesignCollection_getCount_doc},
    {"includes",(PyCFunction)oaDesignCollection_includes,METH_VARARGS,oaDesignCollection_includes_doc},
    {"isEmpty",(PyCFunction)oaDesignCollection_isEmpty,METH_VARARGS,oaDesignCollection_isEmpty_doc},
    {"assign",(PyCFunction)oaDesignCollection_tp_assign,METH_VARARGS,oaDesignCollection_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDesignCollection_doc[] = 
"Class: oaDesignCollection\n"
"  Class type oaDesignCollection\n"
"Constructors:\n"
"  Paramegers: (oaUInt4,oaDesignCollTypeEnum)\n"
"    Calls: oaDesignCollection(oaUInt4 dbIDIn,oaDesignCollTypeEnum tIn)\n"
"    Signature: oaDesignCollection||simple-oaUInt4,simple-oaDesignCollTypeEnum,cptr-oaDesign,\n"
"    Constructor oaDesignCollection\n"
"  Paramegers: (oaUInt4,oaDesignCollTypeEnum,oaDesign)\n"
"    Calls: oaDesignCollection(oaUInt4 dbIDIn,oaDesignCollTypeEnum tIn,const oaDesign* design)\n"
"    Signature: oaDesignCollection||simple-oaUInt4,simple-oaDesignCollTypeEnum,cptr-oaDesign,\n"
"    Constructor oaDesignCollection\n"
"  Paramegers: (oaDesignCollection)\n"
"    Calls: oaDesignCollection(const oaDesignCollection& c)\n"
"    Signature: oaDesignCollection||cref-oaDesignCollection,\n"
"    Constructor oaDesignCollection\n"
"  Paramegers: (oaDesignCollection)\n"
"    Calls: (const oaDesignCollection&)\n"
"    Signature: oaDesignCollection||cref-oaDesignCollection,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDesignCollection_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDesignCollection",
    sizeof(PyoaDesignCollectionObject),
    0,
    (destructor)oaDesignCollection_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDesignCollection_tp_compare,	/* tp_compare */
    (reprfunc)oaDesignCollection_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDesignCollection_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDesignCollection_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaDatabaseCollection_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDesignCollection_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDesignCollection_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDesignCollection_Type)<0) {
      printf("** PyType_Ready failed for: oaDesignCollection\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDesignCollection",
           (PyObject*)(&PyoaDesignCollection_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDesignCollection\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDesignDataType
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDesignDataType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDesignDataType_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDesignDataTypeObject* self = (PyoaDesignDataTypeObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDesignDataTypeEnum)
    {
        PyParamoaDesignDataTypeEnum p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDesignDataTypeEnum_Convert,&p1)) {
            self->value =  new oaDesignDataType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            self->value =  new oaDesignDataType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaDesignDataType)
    {
        PyParamoaDesignDataType p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDesignDataType_Convert,&p1)) {
            self->value= new oaDesignDataType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDesignDataType, Choices are:\n"
        "    (oaDesignDataTypeEnum)\n"
        "    (oaString)\n"
        "    (oaDesignDataType)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDesignDataType_tp_dealloc(PyoaDesignDataTypeObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDesignDataType_tp_repr(PyObject *ob)
{
    PyParamoaDesignDataType value;
    int convert_status=PyoaDesignDataType_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    oaString sresult(value.DataCall()->getName());

    char addr[38];
    sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
    oaString buffer;
    buffer+=oaString("<oaDesignDataType::");
    buffer+=oaString(addr);
    buffer+=oaString("::");
    buffer+=oaString(sresult);
    buffer+=oaString(">");
    result=PyString_FromString((char*)(const char*)buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDesignDataType_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDesignDataType v1;
    PyParamoaDesignDataType v2;
    int convert_status1=PyoaDesignDataType_Convert(ob1,&v1);
    int convert_status2=PyoaDesignDataType_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDesignDataType_Convert(PyObject* ob,PyParamoaDesignDataType* result)
{
    if (ob == NULL) return 1;
    if (PyoaDesignDataType_Check(ob)) {
        result->SetData(  ((PyoaDesignDataTypeObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDesignDataType Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDesignDataType_FromoaDesignDataType(oaDesignDataType* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaDesignDataType_Type.tp_alloc(&PyoaDesignDataType_Type,0);
        if (bself == NULL) return bself;
        PyoaDesignDataTypeObject* self = (PyoaDesignDataTypeObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDesignDataType_getName_doc[] = 
"Class: oaDesignDataType, Function: getName\n"
"  Paramegers: ()\n"
"    Calls: const oaString& getName() const\n"
"    Signature: getName|cref-oaString|\n"
"    BrowseData: 1\n"
"    This function returns the name string associated with the encapsulated #oaDesignDataTypeEnum object.\n"
;

static PyObject*
oaDesignDataType_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignDataType data;
    int convert_status=PyoaDesignDataType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignDataTypeObject* self=(PyoaDesignDataTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaString result= (data.DataCall()->getName());
        return PyoaString_FromoaString(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignDataType_oaDesignDataTypeEnum_doc[] = 
"Class: oaDesignDataType, Function: oaDesignDataTypeEnum\n"
"  Paramegers: ()\n"
"    Calls: oaDesignDataTypeEnum oaDesignDataTypeEnum() const\n"
"    Signature: operator oaDesignDataTypeEnum|simple-oaDesignDataTypeEnum|\n"
"    BrowseData: 1\n"
"    This operator casts this oaDesignDataType object into the corresponding #oaDesignDataTypeEnum value.\n"
;

static PyObject*
oaDesignDataType_oaDesignDataTypeEnum(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignDataType data;
    int convert_status=PyoaDesignDataType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignDataTypeObject* self=(PyoaDesignDataTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaDesignDataTypeEnum result= (data.DataCall()->operator oaDesignDataTypeEnum());
        return PyoaDesignDataTypeEnum_FromoaDesignDataTypeEnum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaDesignDataType_assign_doc[] = 
"Class: oaDesignDataType, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDesignDataType_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDesignDataType data;
  int convert_status=PyoaDesignDataType_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDesignDataType p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDesignDataType_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDesignDataType_methodlist[] = {
    {"getName",(PyCFunction)oaDesignDataType_getName,METH_VARARGS,oaDesignDataType_getName_doc},
    {"oaDesignDataTypeEnum",(PyCFunction)oaDesignDataType_oaDesignDataTypeEnum,METH_VARARGS,oaDesignDataType_oaDesignDataTypeEnum_doc},
    {"assign",(PyCFunction)oaDesignDataType_tp_assign,METH_VARARGS,oaDesignDataType_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDesignDataType_doc[] = 
"Class: oaDesignDataType\n"
"  The oaDesignDataType class encapsulates the enumerated values that describe the different types of data contained within a design. Applications must specify a dataType that indicates the type of data affected by the application definition.\n"
"  The oaDesignDataType class has values for each of the different classes of managed data contained within an oaDesign . These values are used for several calls that refer to whole classes of objects in an oaDesign . See oaDesign :: getTimeStamp and oaDesign::preAllocate .\n"
"  oaAppDef Tip: The oaDesignDataTypeEnum values also show which level of classes in the OpenAccess class hierarchy can be used to define AppDefs. For example, since there is a #oaDesignDataTypeEnum for oacShapeDataType but not for oacRectDataType or oacFigDataType , you know that it is the oaShape class that can be used as the template parameter for an oaAppDef . For more information, see Which Classes can be Extended? in the Extending the Database section of the Programmers Guide.\n"
"  Note that there are a few private data types that appear as #oaDesignDataTypeEnums that don t correspond to any public class. For example, oacTDLinkDataType and oacCMapLPDataType do not correspond to public managed objects.\n"
"  oaDesignDataTypeEnum\n"
"Constructors:\n"
"  Paramegers: (oaDesignDataTypeEnum)\n"
"    Calls: oaDesignDataType(oaDesignDataTypeEnum valueIn)\n"
"    Signature: oaDesignDataType||simple-oaDesignDataTypeEnum,\n"
"    oaDesignDataTypeEnum\n"
"    This function constructs an instance of an oaDesignDataType class using the specified enum value. The enum values are defined in #oaDesignDataTypeEnum.\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDesignDataType(const oaString& name)\n"
"    Signature: oaDesignDataType||cref-oaString,\n"
"    This function constructs an instance of an oaDesignDataType class using the #oaDesignDataTypeEnum associated with the specified string name . This name must be defined in the legal set of names associated with #oaDesignDataTypeEnum.\n"
"    oacInvalidDesignDataTypeName\n"
"  Paramegers: (oaDesignDataType)\n"
"    Calls: (const oaDesignDataType&)\n"
"    Signature: oaDesignDataType||cref-oaDesignDataType,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDesignDataType_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDesignDataType",
    sizeof(PyoaDesignDataTypeObject),
    0,
    (destructor)oaDesignDataType_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDesignDataType_tp_compare,	/* tp_compare */
    (reprfunc)oaDesignDataType_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDesignDataType_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDesignDataType_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDesignDataType_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDesignDataType_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDesignDataType_Type)<0) {
      printf("** PyType_Ready failed for: oaDesignDataType\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDesignDataType",
           (PyObject*)(&PyoaDesignDataType_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDesignDataType\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDesignDataTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaDesignDataTypeEnum_Convert(PyObject* ob,PyParamoaDesignDataTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacDesignDataType")==0) { result->SetData(oacDesignDataType); return 1;}
        if (strcasecmp(str,"oacAppObjectDataType")==0) { result->SetData(oacAppObjectDataType); return 1;}
        if (strcasecmp(str,"oacOccNetDataType")==0) { result->SetData(oacOccNetDataType); return 1;}
        if (strcasecmp(str,"oacOccBusNetDefDataType")==0) { result->SetData(oacOccBusNetDefDataType); return 1;}
        if (strcasecmp(str,"oacOccTermDataType")==0) { result->SetData(oacOccTermDataType); return 1;}
        if (strcasecmp(str,"oacOccBusTermDefDataType")==0) { result->SetData(oacOccBusTermDefDataType); return 1;}
        if (strcasecmp(str,"oacOccInstHeaderDataType")==0) { result->SetData(oacOccInstHeaderDataType); return 1;}
        if (strcasecmp(str,"oacOccModuleInstHeaderDataType")==0) { result->SetData(oacOccModuleInstHeaderDataType); return 1;}
        if (strcasecmp(str,"oacOccInstDataType")==0) { result->SetData(oacOccInstDataType); return 1;}
        if (strcasecmp(str,"oacOccVectorInstDefDataType")==0) { result->SetData(oacOccVectorInstDefDataType); return 1;}
        if (strcasecmp(str,"oacOccInstTermDataType")==0) { result->SetData(oacOccInstTermDataType); return 1;}
        if (strcasecmp(str,"oacOccConnectDefDataType")==0) { result->SetData(oacOccConnectDefDataType); return 1;}
        if (strcasecmp(str,"oacOccAssignmentDataType")==0) { result->SetData(oacOccAssignmentDataType); return 1;}
        if (strcasecmp(str,"oacOccOccurrenceDataType")==0) { result->SetData(oacOccOccurrenceDataType); return 1;}
        if (strcasecmp(str,"oacPropDataType")==0) { result->SetData(oacPropDataType); return 1;}
        if (strcasecmp(str,"oacGroupDataType")==0) { result->SetData(oacGroupDataType); return 1;}
        if (strcasecmp(str,"oacGroupMemDataType")==0) { result->SetData(oacGroupMemDataType); return 1;}
        if (strcasecmp(str,"oacAvatarDataType")==0) { result->SetData(oacAvatarDataType); return 1;}
        if (strcasecmp(str,"oacValueDataType")==0) { result->SetData(oacValueDataType); return 1;}
        if (strcasecmp(str,"oacConstraintParamDefDataType")==0) { result->SetData(oacConstraintParamDefDataType); return 1;}
        if (strcasecmp(str,"oacConstraintParamDataType")==0) { result->SetData(oacConstraintParamDataType); return 1;}
        if (strcasecmp(str,"oacConstraintDefDataType")==0) { result->SetData(oacConstraintDefDataType); return 1;}
        if (strcasecmp(str,"oacConstraintDataType")==0) { result->SetData(oacConstraintDataType); return 1;}
        if (strcasecmp(str,"oacConstraintGroupDataType")==0) { result->SetData(oacConstraintGroupDataType); return 1;}
        if (strcasecmp(str,"oacConstraintGroupMemDataType")==0) { result->SetData(oacConstraintGroupMemDataType); return 1;}
        if (strcasecmp(str,"oacConstraintGroupHeaderDataType")==0) { result->SetData(oacConstraintGroupHeaderDataType); return 1;}
        if (strcasecmp(str,"oacNetDataType")==0) { result->SetData(oacNetDataType); return 1;}
        if (strcasecmp(str,"oacBusNetDefDataType")==0) { result->SetData(oacBusNetDefDataType); return 1;}
        if (strcasecmp(str,"oacTermDataType")==0) { result->SetData(oacTermDataType); return 1;}
        if (strcasecmp(str,"oacBusTermDefDataType")==0) { result->SetData(oacBusTermDefDataType); return 1;}
        if (strcasecmp(str,"oacInstHeaderDataType")==0) { result->SetData(oacInstHeaderDataType); return 1;}
        if (strcasecmp(str,"oacModuleInstHeaderDataType")==0) { result->SetData(oacModuleInstHeaderDataType); return 1;}
        if (strcasecmp(str,"oacInstDataType")==0) { result->SetData(oacInstDataType); return 1;}
        if (strcasecmp(str,"oacVectorInstDefDataType")==0) { result->SetData(oacVectorInstDefDataType); return 1;}
        if (strcasecmp(str,"oacInstTermDataType")==0) { result->SetData(oacInstTermDataType); return 1;}
        if (strcasecmp(str,"oacConnectDefDataType")==0) { result->SetData(oacConnectDefDataType); return 1;}
        if (strcasecmp(str,"oacAssignmentDataType")==0) { result->SetData(oacAssignmentDataType); return 1;}
        if (strcasecmp(str,"oacOccurrenceDataType")==0) { result->SetData(oacOccurrenceDataType); return 1;}
        if (strcasecmp(str,"oacLPPHeaderDataType")==0) { result->SetData(oacLPPHeaderDataType); return 1;}
        if (strcasecmp(str,"oacLayerHeaderDataType")==0) { result->SetData(oacLayerHeaderDataType); return 1;}
        if (strcasecmp(str,"oacShapeDataType")==0) { result->SetData(oacShapeDataType); return 1;}
        if (strcasecmp(str,"oacRouteDataType")==0) { result->SetData(oacRouteDataType); return 1;}
        if (strcasecmp(str,"oacPinDataType")==0) { result->SetData(oacPinDataType); return 1;}
        if (strcasecmp(str,"oacTDLinkDataType")==0) { result->SetData(oacTDLinkDataType); return 1;}
        if (strcasecmp(str,"oacParamDataType")==0) { result->SetData(oacParamDataType); return 1;}
        if (strcasecmp(str,"oacMarkerDataType")==0) { result->SetData(oacMarkerDataType); return 1;}
        if (strcasecmp(str,"oacTrackPatternDataType")==0) { result->SetData(oacTrackPatternDataType); return 1;}
        if (strcasecmp(str,"oacMarkerMemDataType")==0) { result->SetData(oacMarkerMemDataType); return 1;}
        if (strcasecmp(str,"oacRowHeaderDataType")==0) { result->SetData(oacRowHeaderDataType); return 1;}
        if (strcasecmp(str,"oacRowDataType")==0) { result->SetData(oacRowDataType); return 1;}
        if (strcasecmp(str,"oacClusterDataType")==0) { result->SetData(oacClusterDataType); return 1;}
        if (strcasecmp(str,"oacBoundaryDataType")==0) { result->SetData(oacBoundaryDataType); return 1;}
        if (strcasecmp(str,"oacSteinerDataType")==0) { result->SetData(oacSteinerDataType); return 1;}
        if (strcasecmp(str,"oacScanChainDataType")==0) { result->SetData(oacScanChainDataType); return 1;}
        if (strcasecmp(str,"oacScanChainInstDataType")==0) { result->SetData(oacScanChainInstDataType); return 1;}
        if (strcasecmp(str,"oacScanChainSetDataType")==0) { result->SetData(oacScanChainSetDataType); return 1;}
        if (strcasecmp(str,"oacViaHeaderDataType")==0) { result->SetData(oacViaHeaderDataType); return 1;}
        if (strcasecmp(str,"oacGCellPatternDataType")==0) { result->SetData(oacGCellPatternDataType); return 1;}
        if (strcasecmp(str,"oacCMapDataType")==0) { result->SetData(oacCMapDataType); return 1;}
        if (strcasecmp(str,"oacCMapLPDataType")==0) { result->SetData(oacCMapLPDataType); return 1;}
        if (strcasecmp(str,"oacGCellDataType")==0) { result->SetData(oacGCellDataType); return 1;}
        if (strcasecmp(str,"oacViaParamDataType")==0) { result->SetData(oacViaParamDataType); return 1;}
        if (strcasecmp(str,"oacAnalysisPointDataType")==0) { result->SetData(oacAnalysisPointDataType); return 1;}
        if (strcasecmp(str,"oacAnalysisOpPointDataType")==0) { result->SetData(oacAnalysisOpPointDataType); return 1;}
        if (strcasecmp(str,"oacOpPointHeaderDataType")==0) { result->SetData(oacOpPointHeaderDataType); return 1;}
        if (strcasecmp(str,"oacBlockageDataType")==0) { result->SetData(oacBlockageDataType); return 1;}
        if (strcasecmp(str,"oacGuideDataType")==0) { result->SetData(oacGuideDataType); return 1;}
        if (strcasecmp(str,"oacParasiticNetworkDataType")==0) { result->SetData(oacParasiticNetworkDataType); return 1;}
        if (strcasecmp(str,"oacNodeDataType")==0) { result->SetData(oacNodeDataType); return 1;}
        if (strcasecmp(str,"oacDeviceDataType")==0) { result->SetData(oacDeviceDataType); return 1;}
        if (strcasecmp(str,"oacSubNetworkDataType")==0) { result->SetData(oacSubNetworkDataType); return 1;}
        if (strcasecmp(str,"oacSubNetworkMemDataType")==0) { result->SetData(oacSubNetworkMemDataType); return 1;}
        if (strcasecmp(str,"oacReducedModelDataType")==0) { result->SetData(oacReducedModelDataType); return 1;}
        if (strcasecmp(str,"oacElmoreDataType")==0) { result->SetData(oacElmoreDataType); return 1;}
        if (strcasecmp(str,"oacPoleResidueDataType")==0) { result->SetData(oacPoleResidueDataType); return 1;}
        if (strcasecmp(str,"oacBlockDataType")==0) { result->SetData(oacBlockDataType); return 1;}
        if (strcasecmp(str,"oacModuleDataType")==0) { result->SetData(oacModuleDataType); return 1;}
        if (strcasecmp(str,"oacOccHeaderDataType")==0) { result->SetData(oacOccHeaderDataType); return 1;}
        if (strcasecmp(str,"oacViaDataType")==0) { result->SetData(oacViaDataType); return 1;}
        if (strcasecmp(str,"oacSegStyleDataType")==0) { result->SetData(oacSegStyleDataType); return 1;}
        if (strcasecmp(str,"oacOccShapeDataType")==0) { result->SetData(oacOccShapeDataType); return 1;}
        if (strcasecmp(str,"oacHierPathDataType")==0) { result->SetData(oacHierPathDataType); return 1;}
        if (strcasecmp(str,"oacAnalysisPtSetDataType")==0) { result->SetData(oacAnalysisPtSetDataType); return 1;}
        if (strcasecmp(str,"oacDetailedNetworkDataType")==0) { result->SetData(oacDetailedNetworkDataType); return 1;}
        if (strcasecmp(str,"oacGlobalDataType")==0) { result->SetData(oacGlobalDataType); return 1;}
        if (strcasecmp(str,"oacGlobalMemDataType")==0) { result->SetData(oacGlobalMemDataType); return 1;}
        if (strcasecmp(str,"oacOccGlobalMemDataType")==0) { result->SetData(oacOccGlobalMemDataType); return 1;}
        if (strcasecmp(str,"oacFeatureDataType")==0) { result->SetData(oacFeatureDataType); return 1;}
        if (strcasecmp(str,"oacFeaturePolicyDataType")==0) { result->SetData(oacFeaturePolicyDataType); return 1;}
        if (strcasecmp(str,"oacFigGroupDataType")==0) { result->SetData(oacFigGroupDataType); return 1;}
        if (strcasecmp(str,"oacFigGroupMemDataType")==0) { result->SetData(oacFigGroupMemDataType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaDesignDataTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDesignDataTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaDesignDataTypeEnum_FromoaDesignDataTypeEnum(oaDesignDataTypeEnum ob)
{
    if (ob==oacDesignDataType) return PyString_FromString("oacDesignDataType");
    if (ob==oacAppObjectDataType) return PyString_FromString("oacAppObjectDataType");
    if (ob==oacOccNetDataType) return PyString_FromString("oacOccNetDataType");
    if (ob==oacOccBusNetDefDataType) return PyString_FromString("oacOccBusNetDefDataType");
    if (ob==oacOccTermDataType) return PyString_FromString("oacOccTermDataType");
    if (ob==oacOccBusTermDefDataType) return PyString_FromString("oacOccBusTermDefDataType");
    if (ob==oacOccInstHeaderDataType) return PyString_FromString("oacOccInstHeaderDataType");
    if (ob==oacOccModuleInstHeaderDataType) return PyString_FromString("oacOccModuleInstHeaderDataType");
    if (ob==oacOccInstDataType) return PyString_FromString("oacOccInstDataType");
    if (ob==oacOccVectorInstDefDataType) return PyString_FromString("oacOccVectorInstDefDataType");
    if (ob==oacOccInstTermDataType) return PyString_FromString("oacOccInstTermDataType");
    if (ob==oacOccConnectDefDataType) return PyString_FromString("oacOccConnectDefDataType");
    if (ob==oacOccAssignmentDataType) return PyString_FromString("oacOccAssignmentDataType");
    if (ob==oacOccOccurrenceDataType) return PyString_FromString("oacOccOccurrenceDataType");
    if (ob==oacPropDataType) return PyString_FromString("oacPropDataType");
    if (ob==oacGroupDataType) return PyString_FromString("oacGroupDataType");
    if (ob==oacGroupMemDataType) return PyString_FromString("oacGroupMemDataType");
    if (ob==oacAvatarDataType) return PyString_FromString("oacAvatarDataType");
    if (ob==oacValueDataType) return PyString_FromString("oacValueDataType");
    if (ob==oacConstraintParamDefDataType) return PyString_FromString("oacConstraintParamDefDataType");
    if (ob==oacConstraintParamDataType) return PyString_FromString("oacConstraintParamDataType");
    if (ob==oacConstraintDefDataType) return PyString_FromString("oacConstraintDefDataType");
    if (ob==oacConstraintDataType) return PyString_FromString("oacConstraintDataType");
    if (ob==oacConstraintGroupDataType) return PyString_FromString("oacConstraintGroupDataType");
    if (ob==oacConstraintGroupMemDataType) return PyString_FromString("oacConstraintGroupMemDataType");
    if (ob==oacConstraintGroupHeaderDataType) return PyString_FromString("oacConstraintGroupHeaderDataType");
    if (ob==oacNetDataType) return PyString_FromString("oacNetDataType");
    if (ob==oacBusNetDefDataType) return PyString_FromString("oacBusNetDefDataType");
    if (ob==oacTermDataType) return PyString_FromString("oacTermDataType");
    if (ob==oacBusTermDefDataType) return PyString_FromString("oacBusTermDefDataType");
    if (ob==oacInstHeaderDataType) return PyString_FromString("oacInstHeaderDataType");
    if (ob==oacModuleInstHeaderDataType) return PyString_FromString("oacModuleInstHeaderDataType");
    if (ob==oacInstDataType) return PyString_FromString("oacInstDataType");
    if (ob==oacVectorInstDefDataType) return PyString_FromString("oacVectorInstDefDataType");
    if (ob==oacInstTermDataType) return PyString_FromString("oacInstTermDataType");
    if (ob==oacConnectDefDataType) return PyString_FromString("oacConnectDefDataType");
    if (ob==oacAssignmentDataType) return PyString_FromString("oacAssignmentDataType");
    if (ob==oacOccurrenceDataType) return PyString_FromString("oacOccurrenceDataType");
    if (ob==oacLPPHeaderDataType) return PyString_FromString("oacLPPHeaderDataType");
    if (ob==oacLayerHeaderDataType) return PyString_FromString("oacLayerHeaderDataType");
    if (ob==oacShapeDataType) return PyString_FromString("oacShapeDataType");
    if (ob==oacRouteDataType) return PyString_FromString("oacRouteDataType");
    if (ob==oacPinDataType) return PyString_FromString("oacPinDataType");
    if (ob==oacTDLinkDataType) return PyString_FromString("oacTDLinkDataType");
    if (ob==oacParamDataType) return PyString_FromString("oacParamDataType");
    if (ob==oacMarkerDataType) return PyString_FromString("oacMarkerDataType");
    if (ob==oacTrackPatternDataType) return PyString_FromString("oacTrackPatternDataType");
    if (ob==oacMarkerMemDataType) return PyString_FromString("oacMarkerMemDataType");
    if (ob==oacRowHeaderDataType) return PyString_FromString("oacRowHeaderDataType");
    if (ob==oacRowDataType) return PyString_FromString("oacRowDataType");
    if (ob==oacClusterDataType) return PyString_FromString("oacClusterDataType");
    if (ob==oacBoundaryDataType) return PyString_FromString("oacBoundaryDataType");
    if (ob==oacSteinerDataType) return PyString_FromString("oacSteinerDataType");
    if (ob==oacScanChainDataType) return PyString_FromString("oacScanChainDataType");
    if (ob==oacScanChainInstDataType) return PyString_FromString("oacScanChainInstDataType");
    if (ob==oacScanChainSetDataType) return PyString_FromString("oacScanChainSetDataType");
    if (ob==oacViaHeaderDataType) return PyString_FromString("oacViaHeaderDataType");
    if (ob==oacGCellPatternDataType) return PyString_FromString("oacGCellPatternDataType");
    if (ob==oacCMapDataType) return PyString_FromString("oacCMapDataType");
    if (ob==oacCMapLPDataType) return PyString_FromString("oacCMapLPDataType");
    if (ob==oacGCellDataType) return PyString_FromString("oacGCellDataType");
    if (ob==oacViaParamDataType) return PyString_FromString("oacViaParamDataType");
    if (ob==oacAnalysisPointDataType) return PyString_FromString("oacAnalysisPointDataType");
    if (ob==oacAnalysisOpPointDataType) return PyString_FromString("oacAnalysisOpPointDataType");
    if (ob==oacOpPointHeaderDataType) return PyString_FromString("oacOpPointHeaderDataType");
    if (ob==oacBlockageDataType) return PyString_FromString("oacBlockageDataType");
    if (ob==oacGuideDataType) return PyString_FromString("oacGuideDataType");
    if (ob==oacParasiticNetworkDataType) return PyString_FromString("oacParasiticNetworkDataType");
    if (ob==oacNodeDataType) return PyString_FromString("oacNodeDataType");
    if (ob==oacDeviceDataType) return PyString_FromString("oacDeviceDataType");
    if (ob==oacSubNetworkDataType) return PyString_FromString("oacSubNetworkDataType");
    if (ob==oacSubNetworkMemDataType) return PyString_FromString("oacSubNetworkMemDataType");
    if (ob==oacReducedModelDataType) return PyString_FromString("oacReducedModelDataType");
    if (ob==oacElmoreDataType) return PyString_FromString("oacElmoreDataType");
    if (ob==oacPoleResidueDataType) return PyString_FromString("oacPoleResidueDataType");
    if (ob==oacBlockDataType) return PyString_FromString("oacBlockDataType");
    if (ob==oacModuleDataType) return PyString_FromString("oacModuleDataType");
    if (ob==oacOccHeaderDataType) return PyString_FromString("oacOccHeaderDataType");
    if (ob==oacViaDataType) return PyString_FromString("oacViaDataType");
    if (ob==oacSegStyleDataType) return PyString_FromString("oacSegStyleDataType");
    if (ob==oacOccShapeDataType) return PyString_FromString("oacOccShapeDataType");
    if (ob==oacHierPathDataType) return PyString_FromString("oacHierPathDataType");
    if (ob==oacAnalysisPtSetDataType) return PyString_FromString("oacAnalysisPtSetDataType");
    if (ob==oacDetailedNetworkDataType) return PyString_FromString("oacDetailedNetworkDataType");
    if (ob==oacGlobalDataType) return PyString_FromString("oacGlobalDataType");
    if (ob==oacGlobalMemDataType) return PyString_FromString("oacGlobalMemDataType");
    if (ob==oacOccGlobalMemDataType) return PyString_FromString("oacOccGlobalMemDataType");
    if (ob==oacFeatureDataType) return PyString_FromString("oacFeatureDataType");
    if (ob==oacFeaturePolicyDataType) return PyString_FromString("oacFeaturePolicyDataType");
    if (ob==oacFigGroupDataType) return PyString_FromString("oacFigGroupDataType");
    if (ob==oacFigGroupMemDataType) return PyString_FromString("oacFigGroupMemDataType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaDesignDataTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaDesignDataTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaDesignDataTypeEnum_FromoaDesignDataTypeEnum(oaDesignDataTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaDesignDataTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaDesignDataTypeEnum_doc[] =
"Type convert function for enum: oaDesignDataTypeEnum";
                               
static PyMethodDef PyoaDesignDataTypeEnum_method =
  {"oaDesignDataTypeEnum",(PyCFunction)PyoaDesignDataTypeEnum_TypeFunction,METH_VARARGS,oaDesignDataTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaDesignDataTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacDesignDataType");
    PyDict_SetItemString(mod_dict,"oacDesignDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAppObjectDataType");
    PyDict_SetItemString(mod_dict,"oacAppObjectDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOccNetDataType");
    PyDict_SetItemString(mod_dict,"oacOccNetDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOccBusNetDefDataType");
    PyDict_SetItemString(mod_dict,"oacOccBusNetDefDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOccTermDataType");
    PyDict_SetItemString(mod_dict,"oacOccTermDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOccBusTermDefDataType");
    PyDict_SetItemString(mod_dict,"oacOccBusTermDefDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOccInstHeaderDataType");
    PyDict_SetItemString(mod_dict,"oacOccInstHeaderDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOccModuleInstHeaderDataType");
    PyDict_SetItemString(mod_dict,"oacOccModuleInstHeaderDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOccInstDataType");
    PyDict_SetItemString(mod_dict,"oacOccInstDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOccVectorInstDefDataType");
    PyDict_SetItemString(mod_dict,"oacOccVectorInstDefDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOccInstTermDataType");
    PyDict_SetItemString(mod_dict,"oacOccInstTermDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOccConnectDefDataType");
    PyDict_SetItemString(mod_dict,"oacOccConnectDefDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOccAssignmentDataType");
    PyDict_SetItemString(mod_dict,"oacOccAssignmentDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOccOccurrenceDataType");
    PyDict_SetItemString(mod_dict,"oacOccOccurrenceDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPropDataType");
    PyDict_SetItemString(mod_dict,"oacPropDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacGroupDataType");
    PyDict_SetItemString(mod_dict,"oacGroupDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacGroupMemDataType");
    PyDict_SetItemString(mod_dict,"oacGroupMemDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAvatarDataType");
    PyDict_SetItemString(mod_dict,"oacAvatarDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacValueDataType");
    PyDict_SetItemString(mod_dict,"oacValueDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConstraintParamDefDataType");
    PyDict_SetItemString(mod_dict,"oacConstraintParamDefDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConstraintParamDataType");
    PyDict_SetItemString(mod_dict,"oacConstraintParamDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConstraintDefDataType");
    PyDict_SetItemString(mod_dict,"oacConstraintDefDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConstraintDataType");
    PyDict_SetItemString(mod_dict,"oacConstraintDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConstraintGroupDataType");
    PyDict_SetItemString(mod_dict,"oacConstraintGroupDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConstraintGroupMemDataType");
    PyDict_SetItemString(mod_dict,"oacConstraintGroupMemDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConstraintGroupHeaderDataType");
    PyDict_SetItemString(mod_dict,"oacConstraintGroupHeaderDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNetDataType");
    PyDict_SetItemString(mod_dict,"oacNetDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBusNetDefDataType");
    PyDict_SetItemString(mod_dict,"oacBusNetDefDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTermDataType");
    PyDict_SetItemString(mod_dict,"oacTermDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBusTermDefDataType");
    PyDict_SetItemString(mod_dict,"oacBusTermDefDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstHeaderDataType");
    PyDict_SetItemString(mod_dict,"oacInstHeaderDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacModuleInstHeaderDataType");
    PyDict_SetItemString(mod_dict,"oacModuleInstHeaderDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstDataType");
    PyDict_SetItemString(mod_dict,"oacInstDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacVectorInstDefDataType");
    PyDict_SetItemString(mod_dict,"oacVectorInstDefDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstTermDataType");
    PyDict_SetItemString(mod_dict,"oacInstTermDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConnectDefDataType");
    PyDict_SetItemString(mod_dict,"oacConnectDefDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAssignmentDataType");
    PyDict_SetItemString(mod_dict,"oacAssignmentDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOccurrenceDataType");
    PyDict_SetItemString(mod_dict,"oacOccurrenceDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLPPHeaderDataType");
    PyDict_SetItemString(mod_dict,"oacLPPHeaderDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLayerHeaderDataType");
    PyDict_SetItemString(mod_dict,"oacLayerHeaderDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacShapeDataType");
    PyDict_SetItemString(mod_dict,"oacShapeDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacRouteDataType");
    PyDict_SetItemString(mod_dict,"oacRouteDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPinDataType");
    PyDict_SetItemString(mod_dict,"oacPinDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTDLinkDataType");
    PyDict_SetItemString(mod_dict,"oacTDLinkDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacParamDataType");
    PyDict_SetItemString(mod_dict,"oacParamDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacMarkerDataType");
    PyDict_SetItemString(mod_dict,"oacMarkerDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTrackPatternDataType");
    PyDict_SetItemString(mod_dict,"oacTrackPatternDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacMarkerMemDataType");
    PyDict_SetItemString(mod_dict,"oacMarkerMemDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacRowHeaderDataType");
    PyDict_SetItemString(mod_dict,"oacRowHeaderDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacRowDataType");
    PyDict_SetItemString(mod_dict,"oacRowDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacClusterDataType");
    PyDict_SetItemString(mod_dict,"oacClusterDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBoundaryDataType");
    PyDict_SetItemString(mod_dict,"oacBoundaryDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSteinerDataType");
    PyDict_SetItemString(mod_dict,"oacSteinerDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacScanChainDataType");
    PyDict_SetItemString(mod_dict,"oacScanChainDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacScanChainInstDataType");
    PyDict_SetItemString(mod_dict,"oacScanChainInstDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacScanChainSetDataType");
    PyDict_SetItemString(mod_dict,"oacScanChainSetDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacViaHeaderDataType");
    PyDict_SetItemString(mod_dict,"oacViaHeaderDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacGCellPatternDataType");
    PyDict_SetItemString(mod_dict,"oacGCellPatternDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCMapDataType");
    PyDict_SetItemString(mod_dict,"oacCMapDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCMapLPDataType");
    PyDict_SetItemString(mod_dict,"oacCMapLPDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacGCellDataType");
    PyDict_SetItemString(mod_dict,"oacGCellDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacViaParamDataType");
    PyDict_SetItemString(mod_dict,"oacViaParamDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAnalysisPointDataType");
    PyDict_SetItemString(mod_dict,"oacAnalysisPointDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAnalysisOpPointDataType");
    PyDict_SetItemString(mod_dict,"oacAnalysisOpPointDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOpPointHeaderDataType");
    PyDict_SetItemString(mod_dict,"oacOpPointHeaderDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBlockageDataType");
    PyDict_SetItemString(mod_dict,"oacBlockageDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacGuideDataType");
    PyDict_SetItemString(mod_dict,"oacGuideDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacParasiticNetworkDataType");
    PyDict_SetItemString(mod_dict,"oacParasiticNetworkDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNodeDataType");
    PyDict_SetItemString(mod_dict,"oacNodeDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDeviceDataType");
    PyDict_SetItemString(mod_dict,"oacDeviceDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSubNetworkDataType");
    PyDict_SetItemString(mod_dict,"oacSubNetworkDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSubNetworkMemDataType");
    PyDict_SetItemString(mod_dict,"oacSubNetworkMemDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacReducedModelDataType");
    PyDict_SetItemString(mod_dict,"oacReducedModelDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacElmoreDataType");
    PyDict_SetItemString(mod_dict,"oacElmoreDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPoleResidueDataType");
    PyDict_SetItemString(mod_dict,"oacPoleResidueDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBlockDataType");
    PyDict_SetItemString(mod_dict,"oacBlockDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacModuleDataType");
    PyDict_SetItemString(mod_dict,"oacModuleDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOccHeaderDataType");
    PyDict_SetItemString(mod_dict,"oacOccHeaderDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacViaDataType");
    PyDict_SetItemString(mod_dict,"oacViaDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSegStyleDataType");
    PyDict_SetItemString(mod_dict,"oacSegStyleDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOccShapeDataType");
    PyDict_SetItemString(mod_dict,"oacOccShapeDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacHierPathDataType");
    PyDict_SetItemString(mod_dict,"oacHierPathDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAnalysisPtSetDataType");
    PyDict_SetItemString(mod_dict,"oacAnalysisPtSetDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDetailedNetworkDataType");
    PyDict_SetItemString(mod_dict,"oacDetailedNetworkDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacGlobalDataType");
    PyDict_SetItemString(mod_dict,"oacGlobalDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacGlobalMemDataType");
    PyDict_SetItemString(mod_dict,"oacGlobalMemDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOccGlobalMemDataType");
    PyDict_SetItemString(mod_dict,"oacOccGlobalMemDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacFeatureDataType");
    PyDict_SetItemString(mod_dict,"oacFeatureDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacFeaturePolicyDataType");
    PyDict_SetItemString(mod_dict,"oacFeaturePolicyDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacFigGroupDataType");
    PyDict_SetItemString(mod_dict,"oacFigGroupDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacFigGroupMemDataType");
    PyDict_SetItemString(mod_dict,"oacFigGroupMemDataType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaDesignDataTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaDesignDataTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaDesignDataTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDesignInst
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDesignInst_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDesignInst_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDesignInstObject* self = (PyoaDesignInstObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDesignInst)
    {
        PyParamoaDesignInst p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDesignInst_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDesignInst, Choices are:\n"
        "    (oaDesignInst)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDesignInst_tp_dealloc(PyoaDesignInstObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDesignInst_tp_repr(PyObject *ob)
{
    PyParamoaDesignInst value;
    int convert_status=PyoaDesignInst_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[34];
    sprintf(buffer,"<oaDesignInst::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDesignInst_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDesignInst v1;
    PyParamoaDesignInst v2;
    int convert_status1=PyoaDesignInst_Convert(ob1,&v1);
    int convert_status2=PyoaDesignInst_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDesignInst_Convert(PyObject* ob,PyParamoaDesignInst* result)
{
    if (ob == NULL) return 1;
    if (PyoaDesignInst_Check(ob)) {
        result->SetData( (oaDesignInst**) ((PyoaDesignInstObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDesignInst Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDesignInst_FromoaDesignInst(oaDesignInst** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDesignInst* data=*value;
        PyObject* bself = PyoaDesignInst_Type.tp_alloc(&PyoaDesignInst_Type,0);
        if (bself == NULL) return bself;
        PyoaDesignInstObject* self = (PyoaDesignInstObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDesignInst_FromoaDesignInst(oaDesignInst* data)
{
    if (data) {
       PyObject* bself = PyoaDesignInst_Type.tp_alloc(&PyoaDesignInst_Type,0);
       if (bself == NULL) return bself;
       PyoaDesignInstObject* self = (PyoaDesignInstObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDesignInst_destroy_doc[] = 
"Class: oaDesignInst, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function destroys this design instance, removing it from the database.\n"
;

static PyObject*
oaDesignInst_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignInst data;
    int convert_status=PyoaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignInstObject* self=(PyoaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignInst_getCellName_doc[] = 
"Class: oaDesignInst, Function: getCellName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getCellName(oaScalarName& name) const\n"
"    Signature: getCellName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the cell name associated with this design instance in the specified oaScalarName .\n"
"    name\n"
"    The string to fill out with the cell name.\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getCellName(const oaNameSpace& nameSpace,oaString& name) const\n"
"    Signature: getCellName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the cell name associated with this design instance in the nameSpace specified.\n"
"    nameSpace\n"
"    The name space in which to return the name.\n"
"    name\n"
"    The string to fill out with the cell name.\n"
;

static PyObject*
oaDesignInst_getCellName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignInst data;
    int convert_status=PyoaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignInstObject* self=(PyoaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getCellName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getCellName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDesignInst, function: getCellName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignInst_getLayerMapping_doc[] = 
"Class: oaDesignInst, Function: getLayerMapping\n"
"  Paramegers: (oaLayerMapArray)\n"
"    Calls: void getLayerMapping(oaLayerMapArray& layers) const\n"
"    Signature: getLayerMapping|void-void|ref-oaLayerMapArray,\n"
"    BrowseData: 0,oaLayerMapArray\n"
"    This function returns the mapping layers assoicated with this design instance. This function throws an exception if this design instance does not have any mapping layers.\n"
"    layers\n"
"    The returned mapping layers\n"
"    oacDesignInstInvalidMapLayer\n"
;

static PyObject*
oaDesignInst_getLayerMapping(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignInst data;
    int convert_status=PyoaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignInstObject* self=(PyoaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaLayerMapArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaLayerMapArray_Convert,&p1)) {
        data.DataCall()->getLayerMapping(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignInst_getLibName_doc[] = 
"Class: oaDesignInst, Function: getLibName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getLibName(oaScalarName& name) const\n"
"    Signature: getLibName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the library name associated with this design instance in the specified name.\n"
"    name\n"
"    The string to fill out with the library name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getLibName(const oaNameSpace& nameSpace,oaString& name) const\n"
"    Signature: getLibName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the library name associated with this design instance in the nameSpace specified.\n"
"    nameSpace\n"
"    The name space in which to return the name.\n"
"    name\n"
"    The string to fill out with the library name.\n"
;

static PyObject*
oaDesignInst_getLibName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignInst data;
    int convert_status=PyoaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignInstObject* self=(PyoaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getLibName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getLibName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDesignInst, function: getLibName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignInst_getMag_doc[] = 
"Class: oaDesignInst, Function: getMag\n"
"  Paramegers: ()\n"
"    Calls: oaFloat getMag() const\n"
"    Signature: getMag|simple-oaFloat|\n"
"    BrowseData: 1\n"
"    This function returns the magnification of this design instance\n"
;

static PyObject*
oaDesignInst_getMag(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignInst data;
    int convert_status=PyoaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignInstObject* self=(PyoaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaFloat result= (data.DataCall()->getMag());
        return PyoaFloat_FromoaFloat(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignInst_getName_doc[] = 
"Class: oaDesignInst, Function: getName\n"
"  Paramegers: (oaString)\n"
"    Calls: void getName(oaString& name) const\n"
"    Signature: getName|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function returns the name of this design instance in the specified name\n"
"    name\n"
"    The name to be filled out with the name of this design instance\n"
;

static PyObject*
oaDesignInst_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignInst data;
    int convert_status=PyoaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignInstObject* self=(PyoaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignInst_getOrient_doc[] = 
"Class: oaDesignInst, Function: getOrient\n"
"  Paramegers: ()\n"
"    Calls: oaOrient getOrient() const\n"
"    Signature: getOrient|simple-oaOrient|\n"
"    BrowseData: 1\n"
"    This function returns the orientation of this design instance\n"
;

static PyObject*
oaDesignInst_getOrient(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignInst data;
    int convert_status=PyoaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignInstObject* self=(PyoaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaOrient* result= new oaOrient(data.DataCall()->getOrient());
        return PyoaOrient_FromoaOrient(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignInst_getOrigin_doc[] = 
"Class: oaDesignInst, Function: getOrigin\n"
"  Paramegers: (oaPoint)\n"
"    Calls: void getOrigin(oaPoint& origin) const\n"
"    Signature: getOrigin|void-void|ref-oaPoint,\n"
"    BrowseData: 0,oaPoint\n"
"    This function fills out 'origin' with the origin of this design instance.\n"
"    origin\n"
"    The origin to be filled out\n"
;

static PyObject*
oaDesignInst_getOrigin(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignInst data;
    int convert_status=PyoaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignInstObject* self=(PyoaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaPoint p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaPoint_Convert,&p1)) {
        data.DataCall()->getOrigin(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignInst_getOwner_doc[] = 
"Class: oaDesignInst, Function: getOwner\n"
"  Paramegers: ()\n"
"    Calls: oaWaferObject* getOwner() const\n"
"    Signature: getOwner|ptr-oaWaferObject|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to object that owns this design instance. The owning object can be either an oaReticle or an oaFrame .\n"
;

static PyObject*
oaDesignInst_getOwner(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignInst data;
    int convert_status=PyoaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignInstObject* self=(PyoaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaWaferObjectp result= (data.DataCall()->getOwner());
        return PyoaWaferObject_FromoaWaferObject(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignInst_getReticleUsage_doc[] = 
"Class: oaDesignInst, Function: getReticleUsage\n"
"  Paramegers: ()\n"
"    Calls: oaReticleUsage getReticleUsage() const\n"
"    Signature: getReticleUsage|simple-oaReticleUsage|\n"
"    BrowseData: 1\n"
"    This function returns the reticle usage of this design instance.\n"
;

static PyObject*
oaDesignInst_getReticleUsage(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignInst data;
    int convert_status=PyoaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignInstObject* self=(PyoaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaReticleUsage* result= new oaReticleUsage(data.DataCall()->getReticleUsage());
        return PyoaReticleUsage_FromoaReticleUsage(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignInst_getTransform_doc[] = 
"Class: oaDesignInst, Function: getTransform\n"
"  Paramegers: (oaTransform)\n"
"    Calls: void getTransform(oaTransform& xform) const\n"
"    Signature: getTransform|void-void|ref-oaTransform,\n"
"    BrowseData: 0,oaTransform\n"
"    This function fills out 'xform' with the transform of this design instance.\n"
"    xform\n"
"    The transform to be filled out\n"
;

static PyObject*
oaDesignInst_getTransform(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignInst data;
    int convert_status=PyoaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignInstObject* self=(PyoaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTransform p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTransform_Convert,&p1)) {
        data.DataCall()->getTransform(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignInst_getViewName_doc[] = 
"Class: oaDesignInst, Function: getViewName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getViewName(oaScalarName& name) const\n"
"    Signature: getViewName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the view name associated with this design instance in the specified oaScalarName .\n"
"    name\n"
"    The string to fill out with the view name.\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getViewName(const oaNameSpace& nameSpace,oaString& name) const\n"
"    Signature: getViewName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the view name associated with this design instance in the nameSpace specified.\n"
"    nameSpace\n"
"    The name space in which to return the name.\n"
"    name\n"
"    The string to fill out with the view name.\n"
;

static PyObject*
oaDesignInst_getViewName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignInst data;
    int convert_status=PyoaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignInstObject* self=(PyoaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getViewName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getViewName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDesignInst, function: getViewName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignInst_hasLayerMapping_doc[] = 
"Class: oaDesignInst, Function: hasLayerMapping\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean hasLayerMapping() const\n"
"    Signature: hasLayerMapping|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether or not this design instance has any layer mapping.\n"
;

static PyObject*
oaDesignInst_hasLayerMapping(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignInst data;
    int convert_status=PyoaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignInstObject* self=(PyoaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->hasLayerMapping());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignInst_isPrintable_doc[] = 
"Class: oaDesignInst, Function: isPrintable\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isPrintable() const\n"
"    Signature: isPrintable|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether or not this design instance is printable.\n"
;

static PyObject*
oaDesignInst_isPrintable(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignInst data;
    int convert_status=PyoaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignInstObject* self=(PyoaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isPrintable());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignInst_setLayerMapping_doc[] = 
"Class: oaDesignInst, Function: setLayerMapping\n"
"  Paramegers: (oaLayerMapArray)\n"
"    Calls: void setLayerMapping(const oaLayerMapArray& layers)\n"
"    Signature: setLayerMapping|void-void|cref-oaLayerMapArray,\n"
"    This function sets the mapping layers of this design instance to the given layers.\n"
"    layers\n"
"    The mapping layers\n"
;

static PyObject*
oaDesignInst_setLayerMapping(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignInst data;
    int convert_status=PyoaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignInstObject* self=(PyoaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaLayerMapArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaLayerMapArray_Convert,&p1)) {
        data.DataCall()->setLayerMapping(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignInst_setMag_doc[] = 
"Class: oaDesignInst, Function: setMag\n"
"  Paramegers: (oaFloat)\n"
"    Calls: void setMag(oaFloat mag)\n"
"    Signature: setMag|void-void|simple-oaFloat,\n"
"    This function sets the magnification of this design instance to the specified value.\n"
"    mag\n"
"    The new magnification\n"
;

static PyObject*
oaDesignInst_setMag(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignInst data;
    int convert_status=PyoaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignInstObject* self=(PyoaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaFloat p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaFloat_Convert,&p1)) {
        data.DataCall()->setMag(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignInst_setName_doc[] = 
"Class: oaDesignInst, Function: setName\n"
"  Paramegers: (oaString)\n"
"    Calls: void setName(const oaString& name)\n"
"    Signature: setName|void-void|cref-oaString,\n"
"    This function sets the name of this design instance to the specified 'name'. An exception is thrown if another design instance already has the specified name.\n"
"    name\n"
"    The new name of the design instance\n"
"    oacDesignInstAlreadyExists\n"
;

static PyObject*
oaDesignInst_setName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignInst data;
    int convert_status=PyoaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignInstObject* self=(PyoaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->setName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignInst_setOrient_doc[] = 
"Class: oaDesignInst, Function: setOrient\n"
"  Paramegers: (oaOrient)\n"
"    Calls: void setOrient(oaOrient orient)\n"
"    Signature: setOrient|void-void|simple-oaOrient,\n"
"    This function sets the orientation for this design instance.\n"
"    orient\n"
"    The new orientation\n"
;

static PyObject*
oaDesignInst_setOrient(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignInst data;
    int convert_status=PyoaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignInstObject* self=(PyoaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaOrient p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOrient_Convert,&p1)) {
        data.DataCall()->setOrient(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignInst_setOrigin_doc[] = 
"Class: oaDesignInst, Function: setOrigin\n"
"  Paramegers: (oaPoint)\n"
"    Calls: void setOrigin(const oaPoint& origin)\n"
"    Signature: setOrigin|void-void|cref-oaPoint,\n"
"    This function sets the origin value for this design instance.\n"
"    origin\n"
"    The new origin\n"
;

static PyObject*
oaDesignInst_setOrigin(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignInst data;
    int convert_status=PyoaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignInstObject* self=(PyoaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaPoint p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaPoint_Convert,&p1)) {
        data.DataCall()->setOrigin(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignInst_setPrintable_doc[] = 
"Class: oaDesignInst, Function: setPrintable\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: void setPrintable(oaBoolean value)\n"
"    Signature: setPrintable|void-void|simple-oaBoolean,\n"
"    This function sets the isPrintable attribute of this design instance to the specified value.\n"
"    value\n"
"    The new value indicating whether or not this design instance is printable\n"
;

static PyObject*
oaDesignInst_setPrintable(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignInst data;
    int convert_status=PyoaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignInstObject* self=(PyoaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBoolean p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBoolean_Convert,&p1)) {
        data.DataCall()->setPrintable(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignInst_setReticleUsage_doc[] = 
"Class: oaDesignInst, Function: setReticleUsage\n"
"  Paramegers: (oaReticleUsage)\n"
"    Calls: void setReticleUsage(oaReticleUsage reticalUsage)\n"
"    Signature: setReticleUsage|void-void|simple-oaReticleUsage,\n"
"    This function sets the reticle usage of this design instance to the given reticle usage.\n"
"    reticalUsage\n"
"    The new reticle usage\n"
;

static PyObject*
oaDesignInst_setReticleUsage(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignInst data;
    int convert_status=PyoaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignInstObject* self=(PyoaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaReticleUsage p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaReticleUsage_Convert,&p1)) {
        data.DataCall()->setReticleUsage(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignInst_setTransform_doc[] = 
"Class: oaDesignInst, Function: setTransform\n"
"  Paramegers: (oaTransform)\n"
"    Calls: void setTransform(const oaTransform& xform)\n"
"    Signature: setTransform|void-void|cref-oaTransform,\n"
"    This function sets the transform for this design instance.\n"
"    xform\n"
"    The new transform\n"
;

static PyObject*
oaDesignInst_setTransform(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignInst data;
    int convert_status=PyoaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignInstObject* self=(PyoaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTransform p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTransform_Convert,&p1)) {
        data.DataCall()->setTransform(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignInst_isNull_doc[] =
"Class: oaDesignInst, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDesignInst_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDesignInst data;
    int convert_status=PyoaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDesignInst_assign_doc[] = 
"Class: oaDesignInst, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDesignInst_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDesignInst data;
  int convert_status=PyoaDesignInst_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDesignInst p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDesignInst_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDesignInst_methodlist[] = {
    {"destroy",(PyCFunction)oaDesignInst_destroy,METH_VARARGS,oaDesignInst_destroy_doc},
    {"getCellName",(PyCFunction)oaDesignInst_getCellName,METH_VARARGS,oaDesignInst_getCellName_doc},
    {"getLayerMapping",(PyCFunction)oaDesignInst_getLayerMapping,METH_VARARGS,oaDesignInst_getLayerMapping_doc},
    {"getLibName",(PyCFunction)oaDesignInst_getLibName,METH_VARARGS,oaDesignInst_getLibName_doc},
    {"getMag",(PyCFunction)oaDesignInst_getMag,METH_VARARGS,oaDesignInst_getMag_doc},
    {"getName",(PyCFunction)oaDesignInst_getName,METH_VARARGS,oaDesignInst_getName_doc},
    {"getOrient",(PyCFunction)oaDesignInst_getOrient,METH_VARARGS,oaDesignInst_getOrient_doc},
    {"getOrigin",(PyCFunction)oaDesignInst_getOrigin,METH_VARARGS,oaDesignInst_getOrigin_doc},
    {"getOwner",(PyCFunction)oaDesignInst_getOwner,METH_VARARGS,oaDesignInst_getOwner_doc},
    {"getReticleUsage",(PyCFunction)oaDesignInst_getReticleUsage,METH_VARARGS,oaDesignInst_getReticleUsage_doc},
    {"getTransform",(PyCFunction)oaDesignInst_getTransform,METH_VARARGS,oaDesignInst_getTransform_doc},
    {"getViewName",(PyCFunction)oaDesignInst_getViewName,METH_VARARGS,oaDesignInst_getViewName_doc},
    {"hasLayerMapping",(PyCFunction)oaDesignInst_hasLayerMapping,METH_VARARGS,oaDesignInst_hasLayerMapping_doc},
    {"isPrintable",(PyCFunction)oaDesignInst_isPrintable,METH_VARARGS,oaDesignInst_isPrintable_doc},
    {"setLayerMapping",(PyCFunction)oaDesignInst_setLayerMapping,METH_VARARGS,oaDesignInst_setLayerMapping_doc},
    {"setMag",(PyCFunction)oaDesignInst_setMag,METH_VARARGS,oaDesignInst_setMag_doc},
    {"setName",(PyCFunction)oaDesignInst_setName,METH_VARARGS,oaDesignInst_setName_doc},
    {"setOrient",(PyCFunction)oaDesignInst_setOrient,METH_VARARGS,oaDesignInst_setOrient_doc},
    {"setOrigin",(PyCFunction)oaDesignInst_setOrigin,METH_VARARGS,oaDesignInst_setOrigin_doc},
    {"setPrintable",(PyCFunction)oaDesignInst_setPrintable,METH_VARARGS,oaDesignInst_setPrintable_doc},
    {"setReticleUsage",(PyCFunction)oaDesignInst_setReticleUsage,METH_VARARGS,oaDesignInst_setReticleUsage_doc},
    {"setTransform",(PyCFunction)oaDesignInst_setTransform,METH_VARARGS,oaDesignInst_setTransform_doc},
    {"isNull",(PyCFunction)oaDesignInst_tp_isNull,METH_VARARGS,oaDesignInst_isNull_doc},
    {"assign",(PyCFunction)oaDesignInst_tp_assign,METH_VARARGS,oaDesignInst_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDesignInst_doc[] = 
"Class: oaDesignInst\n"
"  An oaDesignInst represents an instance of an oaDesign in either an oaFrame or an oaReticle . The instance specifies the actual geometry for printing on a reticle, and ultimately on a wafer. All of the geometry for a reticle is contained in oaDesignInsts that exist either directly in the oaReticle or in a hierarchy of oaFrames that are instantiated on the reticle.\n"
"  The layer numbers for the wafer, which are specified on the oaImage that points to the oaReticle , do not have to use the same layer numbers as the oaDesign databases that are instantiated on the reticle. The layer numbers for the oaDesign are specified in the oaTech that it is connected to. Different oaDesigns used on a given reticle may be connected to different oaTech databases. The oaDesignInst may contain a mapping from the various wafer layer numbers it is used with to the corresponding layer number in its oaDesign . If the oaDesignInst does not have a layer mapping, all layers from its oaDesign are applied to each layer of the reticle. This option is used for features such as alignment marks that are intended to appear on all reticles. \n"
"  The size of shapes contained in an instantiated oaDesign depends on several factors. The size of a shape starts with the size as specified by the coordinates of the shape in the design database and the DBUPerUU and oaUserUnitsType for that design database. The design database need not use the same values as the oaWafer . Then the size is scaled according to the product of all the magnification factors on the oaDesignInst and its parent oaFrameInsts. The result is the size of the feature on the Wafer. In addition, shapes are scaled by the scale factor on the oaReticle to get their size as printed on the oaReticle .\n"
"  The oaDesignInst class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaDesignInst)\n"
"    Calls: (const oaDesignInst&)\n"
"    Signature: oaDesignInst||cref-oaDesignInst,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDesignInst_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDesignInst",
    sizeof(PyoaDesignInstObject),
    0,
    (destructor)oaDesignInst_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDesignInst_tp_compare,	/* tp_compare */
    (reprfunc)oaDesignInst_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDesignInst_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDesignInst_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaWaferObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDesignInst_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDesignInst_static_create_doc[] = 
"Class: oaDesignInst, Function: create\n"
"  Paramegers: (oaReticle,oaString,oaScalarName,oaScalarName,oaScalarName,oaFloat,oaTransform,oaBoolean,oaReticleUsage)\n"
"    Calls: oaDesignInst* create(oaReticle* reticle,const oaString& name,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName,oaFloat magnification,const oaTransform& xform,oaBoolean isPrintable,oaReticleUsage reticleUsage)\n"
"    Signature: create|ptr-oaDesignInst|ptr-oaReticle,cref-oaString,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,simple-oaFloat,cref-oaTransform,simple-oaBoolean,simple-oaReticleUsage,\n"
"    This function creates an oaDesignInst object with the specified attributes.\n"
"    reticle\n"
"    The reticle in which the instance is instantiated\n"
"    name\n"
"    The name of the instance\n"
"    libName\n"
"    The library name of the master design\n"
"    cellName\n"
"    The cell name of the master design\n"
"    viewName\n"
"    The view name of the master design\n"
"    magnification\n"
"    The magnification value for the instance\n"
"    xform\n"
"    The transform for the instance\n"
"    isPrintable\n"
"    Whether the instance is printable\n"
"    reticleUsage\n"
"    The reticle usage for the instance\n"
"    oacDesignInstAlreadyExists\n"
"  Paramegers: (oaFrame,oaString,oaScalarName,oaScalarName,oaScalarName,oaFloat,oaTransform,oaBoolean,oaReticleUsage)\n"
"    Calls: oaDesignInst* create(oaFrame* frame,const oaString& name,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName,oaFloat magnification,const oaTransform& xform,oaBoolean isPrintable,oaReticleUsage reticleUsage)\n"
"    Signature: create|ptr-oaDesignInst|ptr-oaFrame,cref-oaString,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,simple-oaFloat,cref-oaTransform,simple-oaBoolean,simple-oaReticleUsage,\n"
"    This function creates an oaDesignInst object with the specified attributes.\n"
"    frame\n"
"    The frame in which the instance is instantiated\n"
"    name\n"
"    The name of the instance\n"
"    libName\n"
"    The library name of the master design\n"
"    cellName\n"
"    The cell name of the master design\n"
"    viewName\n"
"    The view name of the master design\n"
"    magnification\n"
"    The magnification value for the instance\n"
"    xform\n"
"    The transform for the instance\n"
"    isPrintable\n"
"    Whether the instance is printable\n"
"    reticleUsage\n"
"    The reticle usage for the instance\n"
"    oacDesignInstAlreadyExists\n"
;

static PyObject*
oaDesignInst_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaReticle,oaString,oaScalarName,oaScalarName,oaScalarName,oaFloat,oaTransform,oaBoolean,oaReticleUsage)
    {
        PyParamoaReticle p1;
        PyParamoaString p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        PyParamoaScalarName p5;
        PyParamoaFloat p6;
        PyParamoaTransform p7;
        PyParamoaBoolean p8;
        PyParamoaReticleUsage p9;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&O&",
              &PyoaReticle_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4,
              &PyoaScalarName_Convert,&p5,
              &PyoaFloat_Convert,&p6,
              &PyoaTransform_Convert,&p7,
              &PyoaBoolean_Convert,&p8,
              &PyoaReticleUsage_Convert,&p9)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaDesignInstp result= (oaDesignInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.Data(),p9.Data()));
            return PyoaDesignInst_FromoaDesignInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaFrame,oaString,oaScalarName,oaScalarName,oaScalarName,oaFloat,oaTransform,oaBoolean,oaReticleUsage)
    {
        PyParamoaFrame p1;
        PyParamoaString p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        PyParamoaScalarName p5;
        PyParamoaFloat p6;
        PyParamoaTransform p7;
        PyParamoaBoolean p8;
        PyParamoaReticleUsage p9;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&O&",
              &PyoaFrame_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4,
              &PyoaScalarName_Convert,&p5,
              &PyoaFloat_Convert,&p6,
              &PyoaTransform_Convert,&p7,
              &PyoaBoolean_Convert,&p8,
              &PyoaReticleUsage_Convert,&p9)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaDesignInstp result= (oaDesignInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.Data(),p9.Data()));
            return PyoaDesignInst_FromoaDesignInst(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDesignInst, function: create, Choices are:\n"
        "    (oaReticle,oaString,oaScalarName,oaScalarName,oaScalarName,oaFloat,oaTransform,oaBoolean,oaReticleUsage)\n"
        "    (oaFrame,oaString,oaScalarName,oaScalarName,oaScalarName,oaFloat,oaTransform,oaBoolean,oaReticleUsage)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignInst_static_find_doc[] = 
"Class: oaDesignInst, Function: find\n"
"  Paramegers: (oaWafer,oaString)\n"
"    Calls: oaDesignInst* find(const oaWafer* wafer,const oaString& name)\n"
"    Signature: find|ptr-oaDesignInst|cptr-oaWafer,cref-oaString,\n"
"    This function searches the specified wafer for a designInst with the given name. A pointer to the designInst is returned if found; otherwise, NULL is returned.\n"
"    wafer\n"
"    The wafer to search\n"
"    name\n"
"    The design instance name to find\n"
;

static PyObject*
oaDesignInst_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaWafer p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaWafer_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaDesignInstp result= (oaDesignInst::find(p1.Data(),p2.Data()));
        return PyoaDesignInst_FromoaDesignInst(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDesignInst_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaDesignInst_static_create,METH_VARARGS,oaDesignInst_static_create_doc},
    {"static_find",(PyCFunction)oaDesignInst_static_find,METH_VARARGS,oaDesignInst_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDesignInst_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDesignInst_Type)<0) {
      printf("** PyType_Ready failed for: oaDesignInst\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDesignInst",
           (PyObject*)(&PyoaDesignInst_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDesignInst\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDesignInst_Type.tp_dict;
    for(method=oaDesignInst_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDesignInstModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaDesignInstModTypeEnum_Convert(PyObject* ob,PyParamoaDesignInstModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacSetNameDesignInstModType")==0) { result->SetData(oacSetNameDesignInstModType); return 1;}
        if (strcasecmp(str,"oacSetMagDesignInstModType")==0) { result->SetData(oacSetMagDesignInstModType); return 1;}
        if (strcasecmp(str,"oacSetTransformDesignInstModType")==0) { result->SetData(oacSetTransformDesignInstModType); return 1;}
        if (strcasecmp(str,"oacSetPrintableDesignInstModType")==0) { result->SetData(oacSetPrintableDesignInstModType); return 1;}
        if (strcasecmp(str,"oacSetReticleUsageDesignInstModType")==0) { result->SetData(oacSetReticleUsageDesignInstModType); return 1;}
        if (strcasecmp(str,"oacSetMappingLayerDesignInstModType")==0) { result->SetData(oacSetMappingLayerDesignInstModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaDesignInstModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDesignInstModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaDesignInstModTypeEnum_FromoaDesignInstModTypeEnum(oaDesignInstModTypeEnum ob)
{
    if (ob==oacSetNameDesignInstModType) return PyString_FromString("oacSetNameDesignInstModType");
    if (ob==oacSetMagDesignInstModType) return PyString_FromString("oacSetMagDesignInstModType");
    if (ob==oacSetTransformDesignInstModType) return PyString_FromString("oacSetTransformDesignInstModType");
    if (ob==oacSetPrintableDesignInstModType) return PyString_FromString("oacSetPrintableDesignInstModType");
    if (ob==oacSetReticleUsageDesignInstModType) return PyString_FromString("oacSetReticleUsageDesignInstModType");
    if (ob==oacSetMappingLayerDesignInstModType) return PyString_FromString("oacSetMappingLayerDesignInstModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaDesignInstModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaDesignInstModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaDesignInstModTypeEnum_FromoaDesignInstModTypeEnum(oaDesignInstModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaDesignInstModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaDesignInstModTypeEnum_doc[] =
"Type convert function for enum: oaDesignInstModTypeEnum";
                               
static PyMethodDef PyoaDesignInstModTypeEnum_method =
  {"oaDesignInstModTypeEnum",(PyCFunction)PyoaDesignInstModTypeEnum_TypeFunction,METH_VARARGS,oaDesignInstModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaDesignInstModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacSetNameDesignInstModType");
    PyDict_SetItemString(mod_dict,"oacSetNameDesignInstModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetMagDesignInstModType");
    PyDict_SetItemString(mod_dict,"oacSetMagDesignInstModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetTransformDesignInstModType");
    PyDict_SetItemString(mod_dict,"oacSetTransformDesignInstModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetPrintableDesignInstModType");
    PyDict_SetItemString(mod_dict,"oacSetPrintableDesignInstModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetReticleUsageDesignInstModType");
    PyDict_SetItemString(mod_dict,"oacSetReticleUsageDesignInstModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetMappingLayerDesignInstModType");
    PyDict_SetItemString(mod_dict,"oacSetMappingLayerDesignInstModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaDesignInstModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaDesignInstModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaDesignInstModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDesignIter
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDesignIter_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDesignIter_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDesignIterObject* self = (PyoaDesignIterObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDesignCollection)
    {
        PyParamoaDesignCollection p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDesignCollection_Convert,&p1)) {
            self->value = (oaDatabaseIter*)  new oaDesignIter(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaDesignIter)
    {
        PyParamoaDesignIter p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDesignIter_Convert,&p1)) {
            self->value = (oaDatabaseIter*)  new oaDesignIter(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDesignIter, Choices are:\n"
        "    (oaDesignCollection)\n"
        "    (oaDesignIter)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDesignIter_tp_dealloc(PyoaDesignIterObject* self)
{
    if (!self->borrow) {
        delete (oaDesignIter*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDesignIter_tp_repr(PyObject *ob)
{
    PyParamoaDesignIter value;
    int convert_status=PyoaDesignIter_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[34];
    sprintf(buffer,"<oaDesignIter::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDesignIter_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDesignIter v1;
    PyParamoaDesignIter v2;
    int convert_status1=PyoaDesignIter_Convert(ob1,&v1);
    int convert_status2=PyoaDesignIter_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
static PyObject*
oaDesignIter_getiter(PyObject *self)
{
    Py_INCREF(self);
    return self;
}

// ------------------------------------------------------------------
static PyObject*
oaDesignIter_iternext(PyObject *self)
{
  try {
    PyParamoaDesignIter ob;
    int convert_status=PyoaDesignIter_Convert(self,&ob);
    assert(convert_status!=0);
    oaDesign* result;
    result=ob.DataCall()->getNext();
    if (result==NULL) {
       PyErr_SetObject(PyExc_StopIteration,Py_None);
       return NULL;
    }
    return PyoaDesign_FromoaDesign(result);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
int
PyoaDesignIter_Convert(PyObject* ob,PyParamoaDesignIter* result)
{
    if (ob == NULL) return 1;
    if (PyoaDesignIter_Check(ob)) {
        result->SetData( (oaDesignIter*) ((PyoaDesignIterObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDesignIter Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDesignIter_FromoaDesignIter(oaDesignIter* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaDesignIter_Type.tp_alloc(&PyoaDesignIter_Type,0);
        if (bself == NULL) return bself;
        PyoaDesignIterObject* self = (PyoaDesignIterObject*)bself;
        self->value = (oaDatabaseIter*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDesignIter_getNext_doc[] = 
"Class: oaDesignIter, Function: getNext\n"
"  Paramegers: ()\n"
"    Calls: oaDesign* getNext()\n"
"    Signature: getNext|ptr-oaDesign|\n"
"    BrowseData: 1\n"
"    Function getNext\n"
;

static PyObject*
oaDesignIter_getNext(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignIter data;
    int convert_status=PyoaDesignIter_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignIterObject* self=(PyoaDesignIterObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaDesignp result= (data.DataCall()->getNext());
        return PyoaDesign_FromoaDesign(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignIter_next_doc[] = 
"Class: oaDesignIter, Function: next\n"
"  Paramegers: ()\n"
"    Calls: oaDesign* next()\n"
"    Signature: next|ptr-oaDesign|,\n"
"    BrowseData: 1\n"
"    get next value or raise StopIteration\n"
;

static PyObject*
oaDesignIter_next(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignIter data;
    int convert_status=PyoaDesignIter_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignIterObject* self=(PyoaDesignIterObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaDesignp result= (data.DataCall()->getNext());
        if (result==NULL) {
            PyErr_SetObject(PyExc_StopIteration,Py_None);
            return NULL;
        }
        return PyoaDesign_FromoaDesign(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignIter_reset_doc[] = 
"Class: oaDesignIter, Function: reset\n"
"  Paramegers: ()\n"
"    Calls: void reset()\n"
"    Signature: reset|void-void|\n"
"    BrowseData: 0\n"
"    Function reset\n"
;

static PyObject*
oaDesignIter_reset(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignIter data;
    int convert_status=PyoaDesignIter_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignIterObject* self=(PyoaDesignIterObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->reset();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaDesignIter_assign_doc[] = 
"Class: oaDesignIter, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDesignIter_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDesignIter data;
  int convert_status=PyoaDesignIter_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDesignIter p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDesignIter_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDesignIter_methodlist[] = {
    {"getNext",(PyCFunction)oaDesignIter_getNext,METH_VARARGS,oaDesignIter_getNext_doc},
    {"next",(PyCFunction)oaDesignIter_next,METH_VARARGS,oaDesignIter_next_doc},
    {"reset",(PyCFunction)oaDesignIter_reset,METH_VARARGS,oaDesignIter_reset_doc},
    {"assign",(PyCFunction)oaDesignIter_tp_assign,METH_VARARGS,oaDesignIter_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDesignIter_doc[] = 
"Class: oaDesignIter\n"
"  Class type oaDesignIter\n"
"Constructors:\n"
"  Paramegers: (oaDesignCollection)\n"
"    Calls: oaDesignIter(const oaDesignCollection& c)\n"
"    Signature: oaDesignIter||cref-oaDesignCollection,\n"
"    Constructor oaDesignIter\n"
"  Paramegers: (oaDesignIter)\n"
"    Calls: oaDesignIter(const oaDesignIter& iterIn)\n"
"    Signature: oaDesignIter||cref-oaDesignIter,\n"
"    Constructor oaDesignIter\n"
"  Paramegers: (oaDesignIter)\n"
"    Calls: (const oaDesignIter&)\n"
"    Signature: oaDesignIter||cref-oaDesignIter,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDesignIter_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDesignIter",
    sizeof(PyoaDesignIterObject),
    0,
    (destructor)oaDesignIter_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDesignIter_tp_compare,	/* tp_compare */
    (reprfunc)oaDesignIter_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDesignIter_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    (getiterfunc)oaDesignIter_getiter,	/* tp_iter */
    (iternextfunc)oaDesignIter_iternext,	/* tp_iternext */
    oaDesignIter_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaDatabaseIter_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDesignIter_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDesignIter_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDesignIter_Type)<0) {
      printf("** PyType_Ready failed for: oaDesignIter\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDesignIter",
           (PyObject*)(&PyoaDesignIter_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDesignIter\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDesignIterTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaDesignIterTypeEnum_Convert(PyObject* ob,PyParamoaDesignIterTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacBaseDesignIterType")==0) { result->SetData(oacBaseDesignIterType); return 1;}
        if (strcasecmp(str,"oacSubMasterDesignIterType")==0) { result->SetData(oacSubMasterDesignIterType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaDesignIterTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDesignIterTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaDesignIterTypeEnum_FromoaDesignIterTypeEnum(oaDesignIterTypeEnum ob)
{
    if (ob==oacBaseDesignIterType) return PyString_FromString("oacBaseDesignIterType");
    if (ob==oacSubMasterDesignIterType) return PyString_FromString("oacSubMasterDesignIterType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaDesignIterTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaDesignIterTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaDesignIterTypeEnum_FromoaDesignIterTypeEnum(oaDesignIterTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaDesignIterTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaDesignIterTypeEnum_doc[] =
"Type convert function for enum: oaDesignIterTypeEnum";
                               
static PyMethodDef PyoaDesignIterTypeEnum_method =
  {"oaDesignIterTypeEnum",(PyCFunction)PyoaDesignIterTypeEnum_TypeFunction,METH_VARARGS,oaDesignIterTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaDesignIterTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacBaseDesignIterType");
    PyDict_SetItemString(mod_dict,"oacBaseDesignIterType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSubMasterDesignIterType");
    PyDict_SetItemString(mod_dict,"oacSubMasterDesignIterType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaDesignIterTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaDesignIterTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaDesignIterTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDesignModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaDesignModTypeEnum_Convert(PyObject* ob,PyParamoaDesignModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacSetCellTypeDesignModType")==0) { result->SetData(oacSetCellTypeDesignModType); return 1;}
        if (strcasecmp(str,"oacSetTopModDesignModType")==0) { result->SetData(oacSetTopModDesignModType); return 1;}
        if (strcasecmp(str,"oacSetDefaultConstraintGroupDesignModType")==0) { result->SetData(oacSetDefaultConstraintGroupDesignModType); return 1;}
        if (strcasecmp(str,"oacSetSymmetricConnectivityDesignModType")==0) { result->SetData(oacSetSymmetricConnectivityDesignModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaDesignModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDesignModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaDesignModTypeEnum_FromoaDesignModTypeEnum(oaDesignModTypeEnum ob)
{
    if (ob==oacSetCellTypeDesignModType) return PyString_FromString("oacSetCellTypeDesignModType");
    if (ob==oacSetTopModDesignModType) return PyString_FromString("oacSetTopModDesignModType");
    if (ob==oacSetDefaultConstraintGroupDesignModType) return PyString_FromString("oacSetDefaultConstraintGroupDesignModType");
    if (ob==oacSetSymmetricConnectivityDesignModType) return PyString_FromString("oacSetSymmetricConnectivityDesignModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaDesignModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaDesignModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaDesignModTypeEnum_FromoaDesignModTypeEnum(oaDesignModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaDesignModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaDesignModTypeEnum_doc[] =
"Type convert function for enum: oaDesignModTypeEnum";
                               
static PyMethodDef PyoaDesignModTypeEnum_method =
  {"oaDesignModTypeEnum",(PyCFunction)PyoaDesignModTypeEnum_TypeFunction,METH_VARARGS,oaDesignModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaDesignModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacSetCellTypeDesignModType");
    PyDict_SetItemString(mod_dict,"oacSetCellTypeDesignModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetTopModDesignModType");
    PyDict_SetItemString(mod_dict,"oacSetTopModDesignModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetDefaultConstraintGroupDesignModType");
    PyDict_SetItemString(mod_dict,"oacSetDefaultConstraintGroupDesignModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetSymmetricConnectivityDesignModType");
    PyDict_SetItemString(mod_dict,"oacSetSymmetricConnectivityDesignModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaDesignModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaDesignModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaDesignModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDesignMsgIds
// ==================================================================

// ------------------------------------------------------------------

int
PyoaDesignMsgIds_Convert(PyObject* ob,PyParamoaDesignMsgIds* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacInvalidDesign")==0) { result->SetData(oacInvalidDesign); return 1;}
        if (strcasecmp(str,"oacNotADesign")==0) { result->SetData(oacNotADesign); return 1;}
        if (strcasecmp(str,"oacSaveReadOnlyDesign")==0) { result->SetData(oacSaveReadOnlyDesign); return 1;}
        if (strcasecmp(str,"oacSaveScratchModeDesign")==0) { result->SetData(oacSaveScratchModeDesign); return 1;}
        if (strcasecmp(str,"oacOpenUndefinedModeDesign")==0) { result->SetData(oacOpenUndefinedModeDesign); return 1;}
        if (strcasecmp(str,"oacCannotFindDesign")==0) { result->SetData(oacCannotFindDesign); return 1;}
        if (strcasecmp(str,"oacDesignPrimaryFileDoesNotExist")==0) { result->SetData(oacDesignPrimaryFileDoesNotExist); return 1;}
        if (strcasecmp(str,"oacDesignFollowerFileDoesNotExist")==0) { result->SetData(oacDesignFollowerFileDoesNotExist); return 1;}
        if (strcasecmp(str,"oacDetailedParasiticsFileDoesNotExist")==0) { result->SetData(oacDetailedParasiticsFileDoesNotExist); return 1;}
        if (strcasecmp(str,"oacCannotSetModeToScratch")==0) { result->SetData(oacCannotSetModeToScratch); return 1;}
        if (strcasecmp(str,"oacCannotChangeFromScratchMode")==0) { result->SetData(oacCannotChangeFromScratchMode); return 1;}
        if (strcasecmp(str,"oacCannotModifyReadModeDesign")==0) { result->SetData(oacCannotModifyReadModeDesign); return 1;}
        if (strcasecmp(str,"oacOpenOnDesignBeingPurged")==0) { result->SetData(oacOpenOnDesignBeingPurged); return 1;}
        if (strcasecmp(str,"oacPurgeOnDesignBeingPurged")==0) { result->SetData(oacPurgeOnDesignBeingPurged); return 1;}
        if (strcasecmp(str,"oacInvalidDesignViewType")==0) { result->SetData(oacInvalidDesignViewType); return 1;}
        if (strcasecmp(str,"oacMismatchViewTypeForOpen")==0) { result->SetData(oacMismatchViewTypeForOpen); return 1;}
        if (strcasecmp(str,"oacObsoleteDesignMsg1016")==0) { result->SetData(oacObsoleteDesignMsg1016); return 1;}
        if (strcasecmp(str,"oacDestroyDesignOpen")==0) { result->SetData(oacDestroyDesignOpen); return 1;}
        if (strcasecmp(str,"oacDestroyCannotFindDesign")==0) { result->SetData(oacDestroyCannotFindDesign); return 1;}
        if (strcasecmp(str,"oacInvalidCellTypeName")==0) { result->SetData(oacInvalidCellTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidDesignAttrTypeName")==0) { result->SetData(oacInvalidDesignAttrTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidSymmetryName")==0) { result->SetData(oacInvalidSymmetryName); return 1;}
        if (strcasecmp(str,"oacCannotFindTechForDesign")==0) { result->SetData(oacCannotFindTechForDesign); return 1;}
        if (strcasecmp(str,"oacCannotFindObjectForViaMaster")==0) { result->SetData(oacCannotFindObjectForViaMaster); return 1;}
        if (strcasecmp(str,"oacObsoleteDesignMsg1024")==0) { result->SetData(oacObsoleteDesignMsg1024); return 1;}
        if (strcasecmp(str,"oacCannotFindLibrary")==0) { result->SetData(oacCannotFindLibrary); return 1;}
        if (strcasecmp(str,"oacInvalidRouteStatusTypeName")==0) { result->SetData(oacInvalidRouteStatusTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidBlock")==0) { result->SetData(oacInvalidBlock); return 1;}
        if (strcasecmp(str,"oacInvalidOccurrence")==0) { result->SetData(oacInvalidOccurrence); return 1;}
        if (strcasecmp(str,"oacInvalidShape")==0) { result->SetData(oacInvalidShape); return 1;}
        if (strcasecmp(str,"oacInvalidPath")==0) { result->SetData(oacInvalidPath); return 1;}
        if (strcasecmp(str,"oacInvalidPolygon")==0) { result->SetData(oacInvalidPolygon); return 1;}
        if (strcasecmp(str,"oacArcEllipseBBoxInvalid")==0) { result->SetData(oacArcEllipseBBoxInvalid); return 1;}
        if (strcasecmp(str,"oacArcAnglesInvalid")==0) { result->SetData(oacArcAnglesInvalid); return 1;}
        if (strcasecmp(str,"oacArcPointsColinear")==0) { result->SetData(oacArcPointsColinear); return 1;}
        if (strcasecmp(str,"oacArcTooLarge")==0) { result->SetData(oacArcTooLarge); return 1;}
        if (strcasecmp(str,"oacArcWrongNumIntercepts")==0) { result->SetData(oacArcWrongNumIntercepts); return 1;}
        if (strcasecmp(str,"oacDonutRadiiInvalid")==0) { result->SetData(oacDonutRadiiInvalid); return 1;}
        if (strcasecmp(str,"oacDonutNumSidesInvalid")==0) { result->SetData(oacDonutNumSidesInvalid); return 1;}
        if (strcasecmp(str,"oacEllipseBBoxInvalid")==0) { result->SetData(oacEllipseBBoxInvalid); return 1;}
        if (strcasecmp(str,"oacEllipseNumSidesInvalid")==0) { result->SetData(oacEllipseNumSidesInvalid); return 1;}
        if (strcasecmp(str,"oacInvalidPathExtensionValue")==0) { result->SetData(oacInvalidPathExtensionValue); return 1;}
        if (strcasecmp(str,"oacPathHasExtraPoints")==0) { result->SetData(oacPathHasExtraPoints); return 1;}
        if (strcasecmp(str,"oacPathTooFewPoints")==0) { result->SetData(oacPathTooFewPoints); return 1;}
        if (strcasecmp(str,"oacPolygonHasExtraPoints")==0) { result->SetData(oacPolygonHasExtraPoints); return 1;}
        if (strcasecmp(str,"oacPolygonTooFewPoints")==0) { result->SetData(oacPolygonTooFewPoints); return 1;}
        if (strcasecmp(str,"oacRectBBoxInvalid")==0) { result->SetData(oacRectBBoxInvalid); return 1;}
        if (strcasecmp(str,"oacArcNumSidesInvalid")==0) { result->SetData(oacArcNumSidesInvalid); return 1;}
        if (strcasecmp(str,"oacLineTooFewPoints")==0) { result->SetData(oacLineTooFewPoints); return 1;}
        if (strcasecmp(str,"oacCannotConvertPolygonToRect")==0) { result->SetData(oacCannotConvertPolygonToRect); return 1;}
        if (strcasecmp(str,"oacNetFigNotInSameBlock")==0) { result->SetData(oacNetFigNotInSameBlock); return 1;}
        if (strcasecmp(str,"oacNetEquivNetNotInSameBlock")==0) { result->SetData(oacNetEquivNetNotInSameBlock); return 1;}
        if (strcasecmp(str,"oacNetAndInstNotInSameDesign")==0) { result->SetData(oacNetAndInstNotInSameDesign); return 1;}
        if (strcasecmp(str,"oacTransferNetsNotInSameBlock")==0) { result->SetData(oacTransferNetsNotInSameBlock); return 1;}
        if (strcasecmp(str,"oacMergeNetsNotInSameBlock")==0) { result->SetData(oacMergeNetsNotInSameBlock); return 1;}
        if (strcasecmp(str,"oacMoveToNetNotInSameBlock")==0) { result->SetData(oacMoveToNetNotInSameBlock); return 1;}
        if (strcasecmp(str,"oacShieldNetNotInSameBlock")==0) { result->SetData(oacShieldNetNotInSameBlock); return 1;}
        if (strcasecmp(str,"oacOriginalNetNotInSameBlock")==0) { result->SetData(oacOriginalNetNotInSameBlock); return 1;}
        if (strcasecmp(str,"oacPinTermNotInSameBlock")==0) { result->SetData(oacPinTermNotInSameBlock); return 1;}
        if (strcasecmp(str,"oacInvalidBlockNetIterFlags")==0) { result->SetData(oacInvalidBlockNetIterFlags); return 1;}
        if (strcasecmp(str,"oacInvalidBlockTermIterFlags")==0) { result->SetData(oacInvalidBlockTermIterFlags); return 1;}
        if (strcasecmp(str,"oacInvalidInst")==0) { result->SetData(oacInvalidInst); return 1;}
        if (strcasecmp(str,"oacInvalidInstAttrTypeName")==0) { result->SetData(oacInvalidInstAttrTypeName); return 1;}
        if (strcasecmp(str,"oacInstNameOverlapsOtherInst")==0) { result->SetData(oacInstNameOverlapsOtherInst); return 1;}
        if (strcasecmp(str,"oacVectorInstNameMatchesAutoName")==0) { result->SetData(oacVectorInstNameMatchesAutoName); return 1;}
        if (strcasecmp(str,"oacVectorInstBitNameMatchesAutoName")==0) { result->SetData(oacVectorInstBitNameMatchesAutoName); return 1;}
        if (strcasecmp(str,"oacInstNameExists")==0) { result->SetData(oacInstNameExists); return 1;}
        if (strcasecmp(str,"oacInvalidArrayInstRows")==0) { result->SetData(oacInvalidArrayInstRows); return 1;}
        if (strcasecmp(str,"oacInvalidArrayInstCols")==0) { result->SetData(oacInvalidArrayInstCols); return 1;}
        if (strcasecmp(str,"oacCannotSetNameOfImplicitInst")==0) { result->SetData(oacCannotSetNameOfImplicitInst); return 1;}
        if (strcasecmp(str,"oacCannotDestroyImplicitInst")==0) { result->SetData(oacCannotDestroyImplicitInst); return 1;}
        if (strcasecmp(str,"oacCannotSetMasterImplicitInst")==0) { result->SetData(oacCannotSetMasterImplicitInst); return 1;}
        if (strcasecmp(str,"oacCannotSetParamsImplicitInst")==0) { result->SetData(oacCannotSetParamsImplicitInst); return 1;}
        if (strcasecmp(str,"oacCannotSetPlacementStatusImplicitInst")==0) { result->SetData(oacCannotSetPlacementStatusImplicitInst); return 1;}
        if (strcasecmp(str,"oacCannotSetPriorityImplicitInst")==0) { result->SetData(oacCannotSetPriorityImplicitInst); return 1;}
        if (strcasecmp(str,"oacCannotSetSourceImplicitInst")==0) { result->SetData(oacCannotSetSourceImplicitInst); return 1;}
        if (strcasecmp(str,"oacCannotSetUsageImplicitInst")==0) { result->SetData(oacCannotSetUsageImplicitInst); return 1;}
        if (strcasecmp(str,"oacCannotClusterImplicitInst")==0) { result->SetData(oacCannotClusterImplicitInst); return 1;}
        if (strcasecmp(str,"oacCannotScalarizeImplicitInst")==0) { result->SetData(oacCannotScalarizeImplicitInst); return 1;}
        if (strcasecmp(str,"oacCannotMoveImplicitInst")==0) { result->SetData(oacCannotMoveImplicitInst); return 1;}
        if (strcasecmp(str,"oacCannotCopyImplicitInst")==0) { result->SetData(oacCannotCopyImplicitInst); return 1;}
        if (strcasecmp(str,"oacCannotGetImplicitInstOccurrence")==0) { result->SetData(oacCannotGetImplicitInstOccurrence); return 1;}
        if (strcasecmp(str,"oacCannotGetVectorInstOccurrence")==0) { result->SetData(oacCannotGetVectorInstOccurrence); return 1;}
        if (strcasecmp(str,"oacInvalidBitIndexIntoInst")==0) { result->SetData(oacInvalidBitIndexIntoInst); return 1;}
        if (strcasecmp(str,"oacInstMustBeInUniqueOccHier")==0) { result->SetData(oacInstMustBeInUniqueOccHier); return 1;}
        if (strcasecmp(str,"oacInvalidVectorInstDef")==0) { result->SetData(oacInvalidVectorInstDef); return 1;}
        if (strcasecmp(str,"oacCannotDestroyImplicitVectorInstDef")==0) { result->SetData(oacCannotDestroyImplicitVectorInstDef); return 1;}
        if (strcasecmp(str,"oacVectorInstDefAlreadyExists")==0) { result->SetData(oacVectorInstDefAlreadyExists); return 1;}
        if (strcasecmp(str,"oacBitOrderVectorInstDefImplicit")==0) { result->SetData(oacBitOrderVectorInstDefImplicit); return 1;}
        if (strcasecmp(str,"oacCannotDestroyVectorInstDefWithInsts")==0) { result->SetData(oacCannotDestroyVectorInstDefWithInsts); return 1;}
        if (strcasecmp(str,"oacInvalidNetIndex")==0) { result->SetData(oacInvalidNetIndex); return 1;}
        if (strcasecmp(str,"oacInvalidNetPriority")==0) { result->SetData(oacInvalidNetPriority); return 1;}
        if (strcasecmp(str,"oacInvalidNet")==0) { result->SetData(oacInvalidNet); return 1;}
        if (strcasecmp(str,"oacInvalidRoutePatternTypeName")==0) { result->SetData(oacInvalidRoutePatternTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidNetAttrTypeName")==0) { result->SetData(oacInvalidNetAttrTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidConnStatusName")==0) { result->SetData(oacInvalidConnStatusName); return 1;}
        if (strcasecmp(str,"oacInvalidParasiticConfidenceValue")==0) { result->SetData(oacInvalidParasiticConfidenceValue); return 1;}
        if (strcasecmp(str,"oacBusNetNameMatchesAutoName")==0) { result->SetData(oacBusNetNameMatchesAutoName); return 1;}
        if (strcasecmp(str,"oacNetExists")==0) { result->SetData(oacNetExists); return 1;}
        if (strcasecmp(str,"oacScalarNetNameMatchesBusBaseName")==0) { result->SetData(oacScalarNetNameMatchesBusBaseName); return 1;}
        if (strcasecmp(str,"oacBusNetBaseNameMatchesScalarName")==0) { result->SetData(oacBusNetBaseNameMatchesScalarName); return 1;}
        if (strcasecmp(str,"oacInvalidBundleNetMemberIndex")==0) { result->SetData(oacInvalidBundleNetMemberIndex); return 1;}
        if (strcasecmp(str,"oacInvalidBusNetBitIndex")==0) { result->SetData(oacInvalidBusNetBitIndex); return 1;}
        if (strcasecmp(str,"oacCannotSetNameOfImplicitNet")==0) { result->SetData(oacCannotSetNameOfImplicitNet); return 1;}
        if (strcasecmp(str,"oacCannotSetNameOfNetInBundleNet")==0) { result->SetData(oacCannotSetNameOfNetInBundleNet); return 1;}
        if (strcasecmp(str,"oacCannotSetParasiticConfImplicitNet")==0) { result->SetData(oacCannotSetParasiticConfImplicitNet); return 1;}
        if (strcasecmp(str,"oacCannotScalarizeImplicitNet")==0) { result->SetData(oacCannotScalarizeImplicitNet); return 1;}
        if (strcasecmp(str,"oacCannotSetRangeOfImplicitBus")==0) { result->SetData(oacCannotSetRangeOfImplicitBus); return 1;}
        if (strcasecmp(str,"oacCannotSetRangeOfBusInBundleNet")==0) { result->SetData(oacCannotSetRangeOfBusInBundleNet); return 1;}
        if (strcasecmp(str,"oacCannotAddFigToImplicitNet")==0) { result->SetData(oacCannotAddFigToImplicitNet); return 1;}
        if (strcasecmp(str,"oacCannotDestroyImplicitNet")==0) { result->SetData(oacCannotDestroyImplicitNet); return 1;}
        if (strcasecmp(str,"oacCannotDestroyNetInNonUniqueSpan")==0) { result->SetData(oacCannotDestroyNetInNonUniqueSpan); return 1;}
        if (strcasecmp(str,"oacNetHasNoEquivNet")==0) { result->SetData(oacNetHasNoEquivNet); return 1;}
        if (strcasecmp(str,"oacCannotTransferNetWithTerm")==0) { result->SetData(oacCannotTransferNetWithTerm); return 1;}
        if (strcasecmp(str,"oacCannotTransferNetWithInstTerm")==0) { result->SetData(oacCannotTransferNetWithInstTerm); return 1;}
        if (strcasecmp(str,"oacCannotMergeNetsWithDiffNumBits")==0) { result->SetData(oacCannotMergeNetsWithDiffNumBits); return 1;}
        if (strcasecmp(str,"oacMergeNetsMustBeInUniqueOccHier")==0) { result->SetData(oacMergeNetsMustBeInUniqueOccHier); return 1;}
        if (strcasecmp(str,"oacTransferNetsMustBeInUniqueOccHier")==0) { result->SetData(oacTransferNetsMustBeInUniqueOccHier); return 1;}
        if (strcasecmp(str,"oacInvalidTermIndex")==0) { result->SetData(oacInvalidTermIndex); return 1;}
        if (strcasecmp(str,"oacInvalidTermTypeName")==0) { result->SetData(oacInvalidTermTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidRouteMethodName")==0) { result->SetData(oacInvalidRouteMethodName); return 1;}
        if (strcasecmp(str,"oacInvalidTermAttrTypeName")==0) { result->SetData(oacInvalidTermAttrTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidTerm")==0) { result->SetData(oacInvalidTerm); return 1;}
        if (strcasecmp(str,"oacCannotSetNameOfImplicitTerm")==0) { result->SetData(oacCannotSetNameOfImplicitTerm); return 1;}
        if (strcasecmp(str,"oacCannotSetNameOfTermInBundleTerm")==0) { result->SetData(oacCannotSetNameOfTermInBundleTerm); return 1;}
        if (strcasecmp(str,"oacCannotSetAntennaDataOnImplicitTerm")==0) { result->SetData(oacCannotSetAntennaDataOnImplicitTerm); return 1;}
        if (strcasecmp(str,"oacCannotScalarizeImplicitTerm")==0) { result->SetData(oacCannotScalarizeImplicitTerm); return 1;}
        if (strcasecmp(str,"oacInvalidPinConnectMethodName")==0) { result->SetData(oacInvalidPinConnectMethodName); return 1;}
        if (strcasecmp(str,"oacCannotCreateTermWithImplicitNet")==0) { result->SetData(oacCannotCreateTermWithImplicitNet); return 1;}
        if (strcasecmp(str,"oacCannotCreateTermWithBlockOnlyNet")==0) { result->SetData(oacCannotCreateTermWithBlockOnlyNet); return 1;}
        if (strcasecmp(str,"oacCannotMoveToImplicitNet")==0) { result->SetData(oacCannotMoveToImplicitNet); return 1;}
        if (strcasecmp(str,"oacCannotMoveToBlockOnlyNet")==0) { result->SetData(oacCannotMoveToBlockOnlyNet); return 1;}
        if (strcasecmp(str,"oacTermMustJoinTermNotInSameBlock")==0) { result->SetData(oacTermMustJoinTermNotInSameBlock); return 1;}
        if (strcasecmp(str,"oacTermMustJoinCannotBeImplicit")==0) { result->SetData(oacTermMustJoinCannotBeImplicit); return 1;}
        if (strcasecmp(str,"oacTermMustJoinSameNet")==0) { result->SetData(oacTermMustJoinSameNet); return 1;}
        if (strcasecmp(str,"oacTermSensitivityTermNotInSameBlock")==0) { result->SetData(oacTermSensitivityTermNotInSameBlock); return 1;}
        if (strcasecmp(str,"oacCannotSetIsInterfaceOfImplicitTerm")==0) { result->SetData(oacCannotSetIsInterfaceOfImplicitTerm); return 1;}
        if (strcasecmp(str,"oacTermNetMustBeInUniqueOccHier")==0) { result->SetData(oacTermNetMustBeInUniqueOccHier); return 1;}
        if (strcasecmp(str,"oacTermExists")==0) { result->SetData(oacTermExists); return 1;}
        if (strcasecmp(str,"oacTermMemberExists")==0) { result->SetData(oacTermMemberExists); return 1;}
        if (strcasecmp(str,"oacCannotSetPositionOfImplicitTerm")==0) { result->SetData(oacCannotSetPositionOfImplicitTerm); return 1;}
        if (strcasecmp(str,"oacCannotSetPositionOfBlockOnlyTerm")==0) { result->SetData(oacCannotSetPositionOfBlockOnlyTerm); return 1;}
        if (strcasecmp(str,"oacTermPositionAlreadyTaken")==0) { result->SetData(oacTermPositionAlreadyTaken); return 1;}
        if (strcasecmp(str,"oacScalarTermNameMatchesBusBaseName")==0) { result->SetData(oacScalarTermNameMatchesBusBaseName); return 1;}
        if (strcasecmp(str,"oacBusTermBaseNameMatchesScalarName")==0) { result->SetData(oacBusTermBaseNameMatchesScalarName); return 1;}
        if (strcasecmp(str,"oacInvalidBundleTermMemberIndex")==0) { result->SetData(oacInvalidBundleTermMemberIndex); return 1;}
        if (strcasecmp(str,"oacNetTermWidthMismatch")==0) { result->SetData(oacNetTermWidthMismatch); return 1;}
        if (strcasecmp(str,"oacCannotSetBusTermBitTermType")==0) { result->SetData(oacCannotSetBusTermBitTermType); return 1;}
        if (strcasecmp(str,"oacInvalidBusStartStopRange")==0) { result->SetData(oacInvalidBusStartStopRange); return 1;}
        if (strcasecmp(str,"oacCannotSetRouteMethodOnImplicitTerm")==0) { result->SetData(oacCannotSetRouteMethodOnImplicitTerm); return 1;}
        if (strcasecmp(str,"oacInvalidBitOrderName")==0) { result->SetData(oacInvalidBitOrderName); return 1;}
        if (strcasecmp(str,"oacInvalidBusNetDef")==0) { result->SetData(oacInvalidBusNetDef); return 1;}
        if (strcasecmp(str,"oacCannotDestroyImplicitBusNetDef")==0) { result->SetData(oacCannotDestroyImplicitBusNetDef); return 1;}
        if (strcasecmp(str,"oacBusNetDefAlreadyExists")==0) { result->SetData(oacBusNetDefAlreadyExists); return 1;}
        if (strcasecmp(str,"oacBitOrderBusNetDefImplicit")==0) { result->SetData(oacBitOrderBusNetDefImplicit); return 1;}
        if (strcasecmp(str,"oacCannotDestroyBusNetDefWithNets")==0) { result->SetData(oacCannotDestroyBusNetDefWithNets); return 1;}
        if (strcasecmp(str,"oacInvalidBusTermDef")==0) { result->SetData(oacInvalidBusTermDef); return 1;}
        if (strcasecmp(str,"oacCannotDestroyImplicitBusTermDef")==0) { result->SetData(oacCannotDestroyImplicitBusTermDef); return 1;}
        if (strcasecmp(str,"oacBusTermDefAlreadyExists")==0) { result->SetData(oacBusTermDefAlreadyExists); return 1;}
        if (strcasecmp(str,"oacBitOrderBusTermDefImplicit")==0) { result->SetData(oacBitOrderBusTermDefImplicit); return 1;}
        if (strcasecmp(str,"oacCannotDestroyBusTermDefWithTerms")==0) { result->SetData(oacCannotDestroyBusTermDefWithTerms); return 1;}
        if (strcasecmp(str,"oacInvalidLPPHeader")==0) { result->SetData(oacInvalidLPPHeader); return 1;}
        if (strcasecmp(str,"oacInvalidInstHeader")==0) { result->SetData(oacInvalidInstHeader); return 1;}
        if (strcasecmp(str,"oacInvalidInstTerm")==0) { result->SetData(oacInvalidInstTerm); return 1;}
        if (strcasecmp(str,"oacInvalidInstTermAttrTypeName")==0) { result->SetData(oacInvalidInstTermAttrTypeName); return 1;}
        if (strcasecmp(str,"oacTermNotInInstMasterForInstTerm")==0) { result->SetData(oacTermNotInInstMasterForInstTerm); return 1;}
        if (strcasecmp(str,"oacInstTermAlreadyExists")==0) { result->SetData(oacInstTermAlreadyExists); return 1;}
        if (strcasecmp(str,"oacNetInstTermWidthMismatchForInstTerm")==0) { result->SetData(oacNetInstTermWidthMismatchForInstTerm); return 1;}
        if (strcasecmp(str,"oacInstTermNetImplicit")==0) { result->SetData(oacInstTermNetImplicit); return 1;}
        if (strcasecmp(str,"oacInstTermMustBeByPosition")==0) { result->SetData(oacInstTermMustBeByPosition); return 1;}
        if (strcasecmp(str,"oacInstTermMustBeByName")==0) { result->SetData(oacInstTermMustBeByName); return 1;}
        if (strcasecmp(str,"oacInstTermConnectsByPosition")==0) { result->SetData(oacInstTermConnectsByPosition); return 1;}
        if (strcasecmp(str,"oacInstTermConnectsByName")==0) { result->SetData(oacInstTermConnectsByName); return 1;}
        if (strcasecmp(str,"oacInstTermInstUsesTermPosition")==0) { result->SetData(oacInstTermInstUsesTermPosition); return 1;}
        if (strcasecmp(str,"oacInstTermInstUsesTermName")==0) { result->SetData(oacInstTermInstUsesTermName); return 1;}
        if (strcasecmp(str,"oacInstTermInstImplicit")==0) { result->SetData(oacInstTermInstImplicit); return 1;}
        if (strcasecmp(str,"oacCannotDestroyImplicitInstTerm")==0) { result->SetData(oacCannotDestroyImplicitInstTerm); return 1;}
        if (strcasecmp(str,"oacCannotModifyImplicitInstTerm")==0) { result->SetData(oacCannotModifyImplicitInstTerm); return 1;}
        if (strcasecmp(str,"oacInstTermBitAlreadyExists")==0) { result->SetData(oacInstTermBitAlreadyExists); return 1;}
        if (strcasecmp(str,"oacCannotScalarizeImplicitInstTerm")==0) { result->SetData(oacCannotScalarizeImplicitInstTerm); return 1;}
        if (strcasecmp(str,"oacInstTermIterFlagNotApplicableOnNets")==0) { result->SetData(oacInstTermIterFlagNotApplicableOnNets); return 1;}
        if (strcasecmp(str,"oacInstTermMustBeInUniqueModule")==0) { result->SetData(oacInstTermMustBeInUniqueModule); return 1;}
        if (strcasecmp(str,"oacInstTermInstMustBeInUniqueOccHier")==0) { result->SetData(oacInstTermInstMustBeInUniqueOccHier); return 1;}
        if (strcasecmp(str,"oacInstTermNetMustBeInUniqueOccHier")==0) { result->SetData(oacInstTermNetMustBeInUniqueOccHier); return 1;}
        if (strcasecmp(str,"oacCannotModifyInstTermInNonUniqueHier")==0) { result->SetData(oacCannotModifyInstTermInNonUniqueHier); return 1;}
        if (strcasecmp(str,"oacInvalidRoute")==0) { result->SetData(oacInvalidRoute); return 1;}
        if (strcasecmp(str,"oacObjectNotValidForRoute")==0) { result->SetData(oacObjectNotValidForRoute); return 1;}
        if (strcasecmp(str,"oacInvalidRouteTopologyName")==0) { result->SetData(oacInvalidRouteTopologyName); return 1;}
        if (strcasecmp(str,"oacObjectAlreadyShieldsNet")==0) { result->SetData(oacObjectAlreadyShieldsNet); return 1;}
        if (strcasecmp(str,"oacRouteAndConnNotInSameBlock")==0) { result->SetData(oacRouteAndConnNotInSameBlock); return 1;}
        if (strcasecmp(str,"oacCannotSetRouteObjAsRouteConn")==0) { result->SetData(oacCannotSetRouteObjAsRouteConn); return 1;}
        if (strcasecmp(str,"oacInvalidRouteConnObj")==0) { result->SetData(oacInvalidRouteConnObj); return 1;}
        if (strcasecmp(str,"oacInvalidPin")==0) { result->SetData(oacInvalidPin); return 1;}
        if (strcasecmp(str,"oacPinExists")==0) { result->SetData(oacPinExists); return 1;}
        if (strcasecmp(str,"oacInvalidAccessDirForPin")==0) { result->SetData(oacInvalidAccessDirForPin); return 1;}
        if (strcasecmp(str,"oacTermCannotBeImplicit")==0) { result->SetData(oacTermCannotBeImplicit); return 1;}
        if (strcasecmp(str,"oacPinCannotUseImplicitInst")==0) { result->SetData(oacPinCannotUseImplicitInst); return 1;}
        if (strcasecmp(str,"oacInvalidSubMaster")==0) { result->SetData(oacInvalidSubMaster); return 1;}
        if (strcasecmp(str,"oacInvalidSuperMaster")==0) { result->SetData(oacInvalidSuperMaster); return 1;}
        if (strcasecmp(str,"oacInvalidMaster")==0) { result->SetData(oacInvalidMaster); return 1;}
        if (strcasecmp(str,"oacPcellObserverBindFailed")==0) { result->SetData(oacPcellObserverBindFailed); return 1;}
        if (strcasecmp(str,"oacPcellEvaluationFailed")==0) { result->SetData(oacPcellEvaluationFailed); return 1;}
        if (strcasecmp(str,"oacPcellInvalidPcellDef")==0) { result->SetData(oacPcellInvalidPcellDef); return 1;}
        if (strcasecmp(str,"oacPcellMasterNotBound")==0) { result->SetData(oacPcellMasterNotBound); return 1;}
        if (strcasecmp(str,"oacNotExistInDefaultParam")==0) { result->SetData(oacNotExistInDefaultParam); return 1;}
        if (strcasecmp(str,"oacInvalidDataTypeForParam")==0) { result->SetData(oacInvalidDataTypeForParam); return 1;}
        if (strcasecmp(str,"oacInvalidPcellMaster")==0) { result->SetData(oacInvalidPcellMaster); return 1;}
        if (strcasecmp(str,"oacPcellLinkExists")==0) { result->SetData(oacPcellLinkExists); return 1;}
        if (strcasecmp(str,"oacCannotDestroyIPcellWithLinkExist")==0) { result->SetData(oacCannotDestroyIPcellWithLinkExist); return 1;}
        if (strcasecmp(str,"oacCannotSaveUnboundSuperMaster")==0) { result->SetData(oacCannotSaveUnboundSuperMaster); return 1;}
        if (strcasecmp(str,"oacNonDesignTextDisplay")==0) { result->SetData(oacNonDesignTextDisplay); return 1;}
        if (strcasecmp(str,"oacNoMasterForTextDisplay")==0) { result->SetData(oacNoMasterForTextDisplay); return 1;}
        if (strcasecmp(str,"oacPropNotOnInstanceMaster")==0) { result->SetData(oacPropNotOnInstanceMaster); return 1;}
        if (strcasecmp(str,"oacTextNotInInstanceMaster")==0) { result->SetData(oacTextNotInInstanceMaster); return 1;}
        if (strcasecmp(str,"oacInvalidTextDisplayCopy")==0) { result->SetData(oacInvalidTextDisplayCopy); return 1;}
        if (strcasecmp(str,"oacInvalidTextDisplayFormatName")==0) { result->SetData(oacInvalidTextDisplayFormatName); return 1;}
        if (strcasecmp(str,"oacEvalTextLinkExists")==0) { result->SetData(oacEvalTextLinkExists); return 1;}
        if (strcasecmp(str,"oacCannotDestroyIEvalTextWithLinkExist")==0) { result->SetData(oacCannotDestroyIEvalTextWithLinkExist); return 1;}
        if (strcasecmp(str,"oacInvalidMarker")==0) { result->SetData(oacInvalidMarker); return 1;}
        if (strcasecmp(str,"oacInvalidMarkerMove")==0) { result->SetData(oacInvalidMarkerMove); return 1;}
        if (strcasecmp(str,"oacInvalidMarkerCopy")==0) { result->SetData(oacInvalidMarkerCopy); return 1;}
        if (strcasecmp(str,"oacObjMarkerNotInSameBlock")==0) { result->SetData(oacObjMarkerNotInSameBlock); return 1;}
        if (strcasecmp(str,"oacInvalidMarkerMemType")==0) { result->SetData(oacInvalidMarkerMemType); return 1;}
        if (strcasecmp(str,"oacInvalidTrackPattern")==0) { result->SetData(oacInvalidTrackPattern); return 1;}
        if (strcasecmp(str,"oacInvalidRow")==0) { result->SetData(oacInvalidRow); return 1;}
        if (strcasecmp(str,"oacInvalidRowHeader")==0) { result->SetData(oacInvalidRowHeader); return 1;}
        if (strcasecmp(str,"oacRowNameExists")==0) { result->SetData(oacRowNameExists); return 1;}
        if (strcasecmp(str,"oacInvalidAssignmentDef")==0) { result->SetData(oacInvalidAssignmentDef); return 1;}
        if (strcasecmp(str,"oacInvalidDataTypeForTimeStamp")==0) { result->SetData(oacInvalidDataTypeForTimeStamp); return 1;}
        if (strcasecmp(str,"oacInvalidAssignment")==0) { result->SetData(oacInvalidAssignment); return 1;}
        if (strcasecmp(str,"oacInstHasAssignment")==0) { result->SetData(oacInstHasAssignment); return 1;}
        if (strcasecmp(str,"oacInstAndAssignmentNotInSameBlock")==0) { result->SetData(oacInstAndAssignmentNotInSameBlock); return 1;}
        if (strcasecmp(str,"oacInvalidAssignmentAttrTypeName")==0) { result->SetData(oacInvalidAssignmentAttrTypeName); return 1;}
        if (strcasecmp(str,"oacCannotCreateAssignmentImplicitInst")==0) { result->SetData(oacCannotCreateAssignmentImplicitInst); return 1;}
        if (strcasecmp(str,"oacCannotSetAssignmentImplicitInst")==0) { result->SetData(oacCannotSetAssignmentImplicitInst); return 1;}
        if (strcasecmp(str,"oacInvalidCluster")==0) { result->SetData(oacInvalidCluster); return 1;}
        if (strcasecmp(str,"oacClusterNameExists")==0) { result->SetData(oacClusterNameExists); return 1;}
        if (strcasecmp(str,"oacInstAlreadyInCluster")==0) { result->SetData(oacInstAlreadyInCluster); return 1;}
        if (strcasecmp(str,"oacClusterAndInstNotSameBlock")==0) { result->SetData(oacClusterAndInstNotSameBlock); return 1;}
        if (strcasecmp(str,"oacClusterAlreadyHasParent")==0) { result->SetData(oacClusterAlreadyHasParent); return 1;}
        if (strcasecmp(str,"oacSameCluster")==0) { result->SetData(oacSameCluster); return 1;}
        if (strcasecmp(str,"oacInvalidChildCluster")==0) { result->SetData(oacInvalidChildCluster); return 1;}
        if (strcasecmp(str,"oacInvalidClusterTypeName")==0) { result->SetData(oacInvalidClusterTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidBoundary")==0) { result->SetData(oacInvalidBoundary); return 1;}
        if (strcasecmp(str,"oacInvalidBoundaryType")==0) { result->SetData(oacInvalidBoundaryType); return 1;}
        if (strcasecmp(str,"oacBoundaryHasExtraPoints")==0) { result->SetData(oacBoundaryHasExtraPoints); return 1;}
        if (strcasecmp(str,"oacBoundaryTooFewPoints")==0) { result->SetData(oacBoundaryTooFewPoints); return 1;}
        if (strcasecmp(str,"oacBoundaryNameExists")==0) { result->SetData(oacBoundaryNameExists); return 1;}
        if (strcasecmp(str,"oacPRBoundaryExists")==0) { result->SetData(oacPRBoundaryExists); return 1;}
        if (strcasecmp(str,"oacSnapBoundaryExists")==0) { result->SetData(oacSnapBoundaryExists); return 1;}
        if (strcasecmp(str,"oacSnapBoundaryNotRectangle")==0) { result->SetData(oacSnapBoundaryNotRectangle); return 1;}
        if (strcasecmp(str,"oacInterBlockBoundaryCopyInvalid")==0) { result->SetData(oacInterBlockBoundaryCopyInvalid); return 1;}
        if (strcasecmp(str,"oacIntraBlockBoundaryCopyInvalid")==0) { result->SetData(oacIntraBlockBoundaryCopyInvalid); return 1;}
        if (strcasecmp(str,"oacInvalidBlockageTypeName")==0) { result->SetData(oacInvalidBlockageTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidViaHeader")==0) { result->SetData(oacInvalidViaHeader); return 1;}
        if (strcasecmp(str,"oacInvalidStdViaHeader")==0) { result->SetData(oacInvalidStdViaHeader); return 1;}
        if (strcasecmp(str,"oacInvalidConnectDef")==0) { result->SetData(oacInvalidConnectDef); return 1;}
        if (strcasecmp(str,"oacNetAlreadyHasConnectDef")==0) { result->SetData(oacNetAlreadyHasConnectDef); return 1;}
        if (strcasecmp(str,"oacConnectDefImplicitNet")==0) { result->SetData(oacConnectDefImplicitNet); return 1;}
        if (strcasecmp(str,"oacTermAlreadyHasConnectDef")==0) { result->SetData(oacTermAlreadyHasConnectDef); return 1;}
        if (strcasecmp(str,"oacConnectDefImplicitTerm")==0) { result->SetData(oacConnectDefImplicitTerm); return 1;}
        if (strcasecmp(str,"oacInvalidScanChainInst")==0) { result->SetData(oacInvalidScanChainInst); return 1;}
        if (strcasecmp(str,"oacInvalidScanChainInstTerm")==0) { result->SetData(oacInvalidScanChainInstTerm); return 1;}
        if (strcasecmp(str,"oacInvalidScanChainSetTypeName")==0) { result->SetData(oacInvalidScanChainSetTypeName); return 1;}
        if (strcasecmp(str,"oacCannotSetMaxBits")==0) { result->SetData(oacCannotSetMaxBits); return 1;}
        if (strcasecmp(str,"oacInvalidScanChain")==0) { result->SetData(oacInvalidScanChain); return 1;}
        if (strcasecmp(str,"oacScanChainExists")==0) { result->SetData(oacScanChainExists); return 1;}
        if (strcasecmp(str,"oacInvalidScanChainName")==0) { result->SetData(oacInvalidScanChainName); return 1;}
        if (strcasecmp(str,"oacInvalidScanChainSet")==0) { result->SetData(oacInvalidScanChainSet); return 1;}
        if (strcasecmp(str,"oacErrorCanOnlyHaveOneUnorderedSet")==0) { result->SetData(oacErrorCanOnlyHaveOneUnorderedSet); return 1;}
        if (strcasecmp(str,"oacInvalidSteiner")==0) { result->SetData(oacInvalidSteiner); return 1;}
        if (strcasecmp(str,"oacCannotAddSteinerToNonBitNet")==0) { result->SetData(oacCannotAddSteinerToNonBitNet); return 1;}
        if (strcasecmp(str,"oacInvalidGCellPattern")==0) { result->SetData(oacInvalidGCellPattern); return 1;}
        if (strcasecmp(str,"oacInvalidCMap")==0) { result->SetData(oacInvalidCMap); return 1;}
        if (strcasecmp(str,"oacCMapLayerNotExists")==0) { result->SetData(oacCMapLayerNotExists); return 1;}
        if (strcasecmp(str,"oacInvalidAnalysisPoint")==0) { result->SetData(oacInvalidAnalysisPoint); return 1;}
        if (strcasecmp(str,"oacAnalysisPointNameExists")==0) { result->SetData(oacAnalysisPointNameExists); return 1;}
        if (strcasecmp(str,"oacInvalidAnalysisOpPoint")==0) { result->SetData(oacInvalidAnalysisOpPoint); return 1;}
        if (strcasecmp(str,"oacAnalysisOpPtOpPointNotInSameTech")==0) { result->SetData(oacAnalysisOpPtOpPointNotInSameTech); return 1;}
        if (strcasecmp(str,"oacInvalidOpPointHeader")==0) { result->SetData(oacInvalidOpPointHeader); return 1;}
        if (strcasecmp(str,"oacInvalidReducedModel")==0) { result->SetData(oacInvalidReducedModel); return 1;}
        if (strcasecmp(str,"oacInvalidDriverTermType")==0) { result->SetData(oacInvalidDriverTermType); return 1;}
        if (strcasecmp(str,"oacInvalidReceiverTermType")==0) { result->SetData(oacInvalidReceiverTermType); return 1;}
        if (strcasecmp(str,"oacReceiverNetDoesNotMatchDriverNet")==0) { result->SetData(oacReceiverNetDoesNotMatchDriverNet); return 1;}
        if (strcasecmp(str,"oacParasiticTermMustBeScalar")==0) { result->SetData(oacParasiticTermMustBeScalar); return 1;}
        if (strcasecmp(str,"oacParasiticInstTermMustBeScalar")==0) { result->SetData(oacParasiticInstTermMustBeScalar); return 1;}
        if (strcasecmp(str,"oacInvalidElmore")==0) { result->SetData(oacInvalidElmore); return 1;}
        if (strcasecmp(str,"oacInvalidPoleResidue")==0) { result->SetData(oacInvalidPoleResidue); return 1;}
        if (strcasecmp(str,"oacNotADetailedData")==0) { result->SetData(oacNotADetailedData); return 1;}
        if (strcasecmp(str,"oacInvalidParasiticNetwork")==0) { result->SetData(oacInvalidParasiticNetwork); return 1;}
        if (strcasecmp(str,"oacParasiticNetworkExists")==0) { result->SetData(oacParasiticNetworkExists); return 1;}
        if (strcasecmp(str,"oacNoParasiticNetworkToLoad")==0) { result->SetData(oacNoParasiticNetworkToLoad); return 1;}
        if (strcasecmp(str,"oacInvalidSubNetwork")==0) { result->SetData(oacInvalidSubNetwork); return 1;}
        if (strcasecmp(str,"oacSubNetworkNameExists")==0) { result->SetData(oacSubNetworkNameExists); return 1;}
        if (strcasecmp(str,"oacSubNetworkNodeNotSameDesign")==0) { result->SetData(oacSubNetworkNodeNotSameDesign); return 1;}
        if (strcasecmp(str,"oacSubNetworkNodeNotSameNetwork")==0) { result->SetData(oacSubNetworkNodeNotSameNetwork); return 1;}
        if (strcasecmp(str,"oacSubNetworkDeviceNotSameDesign")==0) { result->SetData(oacSubNetworkDeviceNotSameDesign); return 1;}
        if (strcasecmp(str,"oacSubNetworkNotShapeOrVia")==0) { result->SetData(oacSubNetworkNotShapeOrVia); return 1;}
        if (strcasecmp(str,"oacInvalidNode")==0) { result->SetData(oacInvalidNode); return 1;}
        if (strcasecmp(str,"oacInvalidNodeConnType")==0) { result->SetData(oacInvalidNodeConnType); return 1;}
        if (strcasecmp(str,"oacInvalidCouplingCapConnType")==0) { result->SetData(oacInvalidCouplingCapConnType); return 1;}
        if (strcasecmp(str,"oacNodeNameExists")==0) { result->SetData(oacNodeNameExists); return 1;}
        if (strcasecmp(str,"oacNodeIdExists")==0) { result->SetData(oacNodeIdExists); return 1;}
        if (strcasecmp(str,"oacInvalidEndpointTypeName")==0) { result->SetData(oacInvalidEndpointTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidDevice")==0) { result->SetData(oacInvalidDevice); return 1;}
        if (strcasecmp(str,"oacDeviceNameExists")==0) { result->SetData(oacDeviceNameExists); return 1;}
        if (strcasecmp(str,"oacLocalDeviceIdExists")==0) { result->SetData(oacLocalDeviceIdExists); return 1;}
        if (strcasecmp(str,"oacNonLocalDeviceIdExists")==0) { result->SetData(oacNonLocalDeviceIdExists); return 1;}
        if (strcasecmp(str,"oacNodesNotInSameDesign")==0) { result->SetData(oacNodesNotInSameDesign); return 1;}
        if (strcasecmp(str,"oacNodeNetNotInSameDesign")==0) { result->SetData(oacNodeNetNotInSameDesign); return 1;}
        if (strcasecmp(str,"oacNodeConnNotInSameDesign")==0) { result->SetData(oacNodeConnNotInSameDesign); return 1;}
        if (strcasecmp(str,"oacNodesNotInSameNetwork")==0) { result->SetData(oacNodesNotInSameNetwork); return 1;}
        if (strcasecmp(str,"oacInductorsNotInSameDesign")==0) { result->SetData(oacInductorsNotInSameDesign); return 1;}
        if (strcasecmp(str,"oacInductorNetNotInSameDesign")==0) { result->SetData(oacInductorNetNotInSameDesign); return 1;}
        if (strcasecmp(str,"oacInductorsNotInSameNetwork")==0) { result->SetData(oacInductorsNotInSameNetwork); return 1;}
        if (strcasecmp(str,"oacDeviceNotConnectedToNode")==0) { result->SetData(oacDeviceNotConnectedToNode); return 1;}
        if (strcasecmp(str,"oacNoConnForLocalCouplingCaps")==0) { result->SetData(oacNoConnForLocalCouplingCaps); return 1;}
        if (strcasecmp(str,"oacCouplingCapHasNoConn")==0) { result->SetData(oacCouplingCapHasNoConn); return 1;}
        if (strcasecmp(str,"oacCoupledNodeWithoutId")==0) { result->SetData(oacCoupledNodeWithoutId); return 1;}
        if (strcasecmp(str,"oacInvalidCouplingCapId")==0) { result->SetData(oacInvalidCouplingCapId); return 1;}
        if (strcasecmp(str,"oacCoupledInductorWithoutId")==0) { result->SetData(oacCoupledInductorWithoutId); return 1;}
        if (strcasecmp(str,"oacInvalidMutualInductorId")==0) { result->SetData(oacInvalidMutualInductorId); return 1;}
        if (strcasecmp(str,"oacInvalidDesignDataTypeName")==0) { result->SetData(oacInvalidDesignDataTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidFontName")==0) { result->SetData(oacInvalidFontName); return 1;}
        if (strcasecmp(str,"oacInvalidPlacementStatusTypeName")==0) { result->SetData(oacInvalidPlacementStatusTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidMarkerDeleteWhenTypeName")==0) { result->SetData(oacInvalidMarkerDeleteWhenTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidPathStyleName")==0) { result->SetData(oacInvalidPathStyleName); return 1;}
        if (strcasecmp(str,"oacInvalidSigTypeName")==0) { result->SetData(oacInvalidSigTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidSourceName")==0) { result->SetData(oacInvalidSourceName); return 1;}
        if (strcasecmp(str,"oacInvalidTextAlignName")==0) { result->SetData(oacInvalidTextAlignName); return 1;}
        if (strcasecmp(str,"oacInvalidLayerHeader")==0) { result->SetData(oacInvalidLayerHeader); return 1;}
        if (strcasecmp(str,"oacInvalidBlockage")==0) { result->SetData(oacInvalidBlockage); return 1;}
        if (strcasecmp(str,"oacBlockageHasExtraPoints")==0) { result->SetData(oacBlockageHasExtraPoints); return 1;}
        if (strcasecmp(str,"oacBlockageTooFewPoints")==0) { result->SetData(oacBlockageTooFewPoints); return 1;}
        if (strcasecmp(str,"oacCannotCopyBlockageWithOwner")==0) { result->SetData(oacCannotCopyBlockageWithOwner); return 1;}
        if (strcasecmp(str,"oacAreaHaloAlreadyExists")==0) { result->SetData(oacAreaHaloAlreadyExists); return 1;}
        if (strcasecmp(str,"oacInvalidLayerForLayerBlockage")==0) { result->SetData(oacInvalidLayerForLayerBlockage); return 1;}
        if (strcasecmp(str,"oacInvalidTypeForLayerBlockage")==0) { result->SetData(oacInvalidTypeForLayerBlockage); return 1;}
        if (strcasecmp(str,"oacInvalidGuide")==0) { result->SetData(oacInvalidGuide); return 1;}
        if (strcasecmp(str,"oacRouteOptimizerInternalError")==0) { result->SetData(oacRouteOptimizerInternalError); return 1;}
        if (strcasecmp(str,"oacCMapInvalidGCellPattern")==0) { result->SetData(oacCMapInvalidGCellPattern); return 1;}
        if (strcasecmp(str,"oacCMapInvalidGCellIndex")==0) { result->SetData(oacCMapInvalidGCellIndex); return 1;}
        if (strcasecmp(str,"oacInvalidModule")==0) { result->SetData(oacInvalidModule); return 1;}
        if (strcasecmp(str,"oacModuleExists")==0) { result->SetData(oacModuleExists); return 1;}
        if (strcasecmp(str,"oacModuleNotDerived")==0) { result->SetData(oacModuleNotDerived); return 1;}
        if (strcasecmp(str,"oacModuleNotDerivedFromModule")==0) { result->SetData(oacModuleNotDerivedFromModule); return 1;}
        if (strcasecmp(str,"oacInvalidBlockDomainVisibilityName")==0) { result->SetData(oacInvalidBlockDomainVisibilityName); return 1;}
        if (strcasecmp(str,"oacTopBlockAlreadyExists")==0) { result->SetData(oacTopBlockAlreadyExists); return 1;}
        if (strcasecmp(str,"oacTopModuleAlreadyExists")==0) { result->SetData(oacTopModuleAlreadyExists); return 1;}
        if (strcasecmp(str,"oacDesignIsBlockDomainSpecific")==0) { result->SetData(oacDesignIsBlockDomainSpecific); return 1;}
        if (strcasecmp(str,"oacDesignIsModuleDomainSpecific")==0) { result->SetData(oacDesignIsModuleDomainSpecific); return 1;}
        if (strcasecmp(str,"oacInvalidModInst")==0) { result->SetData(oacInvalidModInst); return 1;}
        if (strcasecmp(str,"oacInvalidModDesignInst")==0) { result->SetData(oacInvalidModDesignInst); return 1;}
        if (strcasecmp(str,"oacInvalidModModuleInst")==0) { result->SetData(oacInvalidModModuleInst); return 1;}
        if (strcasecmp(str,"oacInvalidModInstHeader")==0) { result->SetData(oacInvalidModInstHeader); return 1;}
        if (strcasecmp(str,"oacInvalidModModuleInstHeader")==0) { result->SetData(oacInvalidModModuleInstHeader); return 1;}
        if (strcasecmp(str,"oacInvalidModNet")==0) { result->SetData(oacInvalidModNet); return 1;}
        if (strcasecmp(str,"oacInvalidModTerm")==0) { result->SetData(oacInvalidModTerm); return 1;}
        if (strcasecmp(str,"oacInvalidModInstTerm")==0) { result->SetData(oacInvalidModInstTerm); return 1;}
        if (strcasecmp(str,"oacInvalidModBusNetDef")==0) { result->SetData(oacInvalidModBusNetDef); return 1;}
        if (strcasecmp(str,"oacInvalidModBusTermDef")==0) { result->SetData(oacInvalidModBusTermDef); return 1;}
        if (strcasecmp(str,"oacInvalidModVectorInstDef")==0) { result->SetData(oacInvalidModVectorInstDef); return 1;}
        if (strcasecmp(str,"oacInvalidModConnectDef")==0) { result->SetData(oacInvalidModConnectDef); return 1;}
        if (strcasecmp(str,"oacInvalidModAssignment")==0) { result->SetData(oacInvalidModAssignment); return 1;}
        if (strcasecmp(str,"oacInvalidOccObject")==0) { result->SetData(oacInvalidOccObject); return 1;}
        if (strcasecmp(str,"oacInvalidOccInst")==0) { result->SetData(oacInvalidOccInst); return 1;}
        if (strcasecmp(str,"oacInvalidOccDesignInst")==0) { result->SetData(oacInvalidOccDesignInst); return 1;}
        if (strcasecmp(str,"oacInvalidOccModuleInst")==0) { result->SetData(oacInvalidOccModuleInst); return 1;}
        if (strcasecmp(str,"oacInvalidOccInstHeader")==0) { result->SetData(oacInvalidOccInstHeader); return 1;}
        if (strcasecmp(str,"oacInvalidOccModuleInstHeader")==0) { result->SetData(oacInvalidOccModuleInstHeader); return 1;}
        if (strcasecmp(str,"oacInvalidOccNet")==0) { result->SetData(oacInvalidOccNet); return 1;}
        if (strcasecmp(str,"oacInvalidOccTerm")==0) { result->SetData(oacInvalidOccTerm); return 1;}
        if (strcasecmp(str,"oacInvalidOccInstTerm")==0) { result->SetData(oacInvalidOccInstTerm); return 1;}
        if (strcasecmp(str,"oacInvalidOccBusNetDef")==0) { result->SetData(oacInvalidOccBusNetDef); return 1;}
        if (strcasecmp(str,"oacInvalidOccBusTermDef")==0) { result->SetData(oacInvalidOccBusTermDef); return 1;}
        if (strcasecmp(str,"oacInvalidOccVectorInstDef")==0) { result->SetData(oacInvalidOccVectorInstDef); return 1;}
        if (strcasecmp(str,"oacInvalidOccConnectDef")==0) { result->SetData(oacInvalidOccConnectDef); return 1;}
        if (strcasecmp(str,"oacInvalidOccAssignment")==0) { result->SetData(oacInvalidOccAssignment); return 1;}
        if (strcasecmp(str,"oacBusDefIsModuleDomainSpecific")==0) { result->SetData(oacBusDefIsModuleDomainSpecific); return 1;}
        if (strcasecmp(str,"oacBusDefIsBlockDomainSpecific")==0) { result->SetData(oacBusDefIsBlockDomainSpecific); return 1;}
        if (strcasecmp(str,"oacVectorDefIsModuleDomainSpecific")==0) { result->SetData(oacVectorDefIsModuleDomainSpecific); return 1;}
        if (strcasecmp(str,"oacVectorDefIsBlockDomainSpecific")==0) { result->SetData(oacVectorDefIsBlockDomainSpecific); return 1;}
        if (strcasecmp(str,"oacVectorDefInstMustBeModuleInst")==0) { result->SetData(oacVectorDefInstMustBeModuleInst); return 1;}
        if (strcasecmp(str,"oacVectorDefInstMustBeDesignInst")==0) { result->SetData(oacVectorDefInstMustBeDesignInst); return 1;}
        if (strcasecmp(str,"oacImplicitModuleNetExists")==0) { result->SetData(oacImplicitModuleNetExists); return 1;}
        if (strcasecmp(str,"oacImplicitBlockNetExists")==0) { result->SetData(oacImplicitBlockNetExists); return 1;}
        if (strcasecmp(str,"oacImplicitModuleTermExists")==0) { result->SetData(oacImplicitModuleTermExists); return 1;}
        if (strcasecmp(str,"oacImplicitBlockTermExists")==0) { result->SetData(oacImplicitBlockTermExists); return 1;}
        if (strcasecmp(str,"oacInvalidRowSpacingTypeName")==0) { result->SetData(oacInvalidRowSpacingTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidCoreRowFlipTypeName")==0) { result->SetData(oacInvalidCoreRowFlipTypeName); return 1;}
        if (strcasecmp(str,"oacCoreBoxSpecNoSiteDef")==0) { result->SetData(oacCoreBoxSpecNoSiteDef); return 1;}
        if (strcasecmp(str,"oacCoreBoxSpecInvalidRowNumber")==0) { result->SetData(oacCoreBoxSpecInvalidRowNumber); return 1;}
        if (strcasecmp(str,"oacInvalidModuleNetIterFlags")==0) { result->SetData(oacInvalidModuleNetIterFlags); return 1;}
        if (strcasecmp(str,"oacInvalidModuleTermIterFlags")==0) { result->SetData(oacInvalidModuleTermIterFlags); return 1;}
        if (strcasecmp(str,"oacInvalidOccurrenceNetIterFlags")==0) { result->SetData(oacInvalidOccurrenceNetIterFlags); return 1;}
        if (strcasecmp(str,"oacInvalidOccurrenceTermIterFlags")==0) { result->SetData(oacInvalidOccurrenceTermIterFlags); return 1;}
        if (strcasecmp(str,"oacInvalidGroupByNameIterFlags")==0) { result->SetData(oacInvalidGroupByNameIterFlags); return 1;}
        if (strcasecmp(str,"oacInvalidBlockageDensityValue")==0) { result->SetData(oacInvalidBlockageDensityValue); return 1;}
        if (strcasecmp(str,"oacInvalidBlockageTypeForDensity")==0) { result->SetData(oacInvalidBlockageTypeForDensity); return 1;}
        if (strcasecmp(str,"oacInvalidBlockageOwner")==0) { result->SetData(oacInvalidBlockageOwner); return 1;}
        if (strcasecmp(str,"oacModulesNotInSameDesign")==0) { result->SetData(oacModulesNotInSameDesign); return 1;}
        if (strcasecmp(str,"oacInvalidTopOccurrence")==0) { result->SetData(oacInvalidTopOccurrence); return 1;}
        if (strcasecmp(str,"oacModuleAndOccurrenceNotInSameDesign")==0) { result->SetData(oacModuleAndOccurrenceNotInSameDesign); return 1;}
        if (strcasecmp(str,"oacInvalidMarkerSeverityTypeName")==0) { result->SetData(oacInvalidMarkerSeverityTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidHierBundleNetName")==0) { result->SetData(oacInvalidHierBundleNetName); return 1;}
        if (strcasecmp(str,"oacNetAndInstNotInSameModule")==0) { result->SetData(oacNetAndInstNotInSameModule); return 1;}
        if (strcasecmp(str,"oacInvalidHierInstName")==0) { result->SetData(oacInvalidHierInstName); return 1;}
        if (strcasecmp(str,"oacInvalidHierNetName")==0) { result->SetData(oacInvalidHierNetName); return 1;}
        if (strcasecmp(str,"oacInvalidHierTermName")==0) { result->SetData(oacInvalidHierTermName); return 1;}
        if (strcasecmp(str,"oacCannotMoveDerivedBlockage")==0) { result->SetData(oacCannotMoveDerivedBlockage); return 1;}
        if (strcasecmp(str,"oacCannotCopyDerivedBlockage")==0) { result->SetData(oacCannotCopyDerivedBlockage); return 1;}
        if (strcasecmp(str,"oacInvalidReducedModelDomain")==0) { result->SetData(oacInvalidReducedModelDomain); return 1;}
        if (strcasecmp(str,"oacInvalidReducedModelObjectType")==0) { result->SetData(oacInvalidReducedModelObjectType); return 1;}
        if (strcasecmp(str,"oacDriverReceiverNotInSameDomain")==0) { result->SetData(oacDriverReceiverNotInSameDomain); return 1;}
        if (strcasecmp(str,"oacObjectNetworkNotInSameDomain")==0) { result->SetData(oacObjectNetworkNotInSameDomain); return 1;}
        if (strcasecmp(str,"oacDeviceNetNotInSameDomain")==0) { result->SetData(oacDeviceNetNotInSameDomain); return 1;}
        if (strcasecmp(str,"oacNetworkConnNotInSameDomain")==0) { result->SetData(oacNetworkConnNotInSameDomain); return 1;}
        if (strcasecmp(str,"oacConnNodeNotInSameDomain")==0) { result->SetData(oacConnNodeNotInSameDomain); return 1;}
        if (strcasecmp(str,"oacObjectAlreadyOnMarker")==0) { result->SetData(oacObjectAlreadyOnMarker); return 1;}
        if (strcasecmp(str,"oacMoveToNetNotInSameDesign")==0) { result->SetData(oacMoveToNetNotInSameDesign); return 1;}
        if (strcasecmp(str,"oacNetEquivNetNotInSameDesign")==0) { result->SetData(oacNetEquivNetNotInSameDesign); return 1;}
        if (strcasecmp(str,"oacInvalidModuleEmbedMaster")==0) { result->SetData(oacInvalidModuleEmbedMaster); return 1;}
        if (strcasecmp(str,"oacModuleDetachDesignExists")==0) { result->SetData(oacModuleDetachDesignExists); return 1;}
        if (strcasecmp(str,"oacInvalidVia")==0) { result->SetData(oacInvalidVia); return 1;}
        if (strcasecmp(str,"oacCannotAddViaToNonBitNet")==0) { result->SetData(oacCannotAddViaToNonBitNet); return 1;}
        if (strcasecmp(str,"oacInvalidEndStyleName")==0) { result->SetData(oacInvalidEndStyleName); return 1;}
        if (strcasecmp(str,"oacInvalidSegStyleBeginExtValue")==0) { result->SetData(oacInvalidSegStyleBeginExtValue); return 1;}
        if (strcasecmp(str,"oacInvalidSegStyleEndExtValue")==0) { result->SetData(oacInvalidSegStyleEndExtValue); return 1;}
        if (strcasecmp(str,"oacInvalidPathSegPoints")==0) { result->SetData(oacInvalidPathSegPoints); return 1;}
        if (strcasecmp(str,"oacInvalidPathSegTransformAngle")==0) { result->SetData(oacInvalidPathSegTransformAngle); return 1;}
        if (strcasecmp(str,"oacCannotSetBlockageOwner")==0) { result->SetData(oacCannotSetBlockageOwner); return 1;}
        if (strcasecmp(str,"oacCannotSetBlockagePushedDown")==0) { result->SetData(oacCannotSetBlockagePushedDown); return 1;}
        if (strcasecmp(str,"oacInvalidRef")==0) { result->SetData(oacInvalidRef); return 1;}
        if (strcasecmp(str,"oacInvalidRefHeader")==0) { result->SetData(oacInvalidRefHeader); return 1;}
        if (strcasecmp(str,"oacCannotModifyImplicitRef")==0) { result->SetData(oacCannotModifyImplicitRef); return 1;}
        if (strcasecmp(str,"oacInvalidOccShape")==0) { result->SetData(oacInvalidOccShape); return 1;}
        if (strcasecmp(str,"oacInvalidViaDirectionTypeName")==0) { result->SetData(oacInvalidViaDirectionTypeName); return 1;}
        if (strcasecmp(str,"oacParamsSuppliedForNonPCellViaMaster")==0) { result->SetData(oacParamsSuppliedForNonPCellViaMaster); return 1;}
        if (strcasecmp(str,"oacParamsSuppliedForNonPCellInstMaster")==0) { result->SetData(oacParamsSuppliedForNonPCellInstMaster); return 1;}
        if (strcasecmp(str,"oacCannotRemoveRouteFigFromNet")==0) { result->SetData(oacCannotRemoveRouteFigFromNet); return 1;}
        if (strcasecmp(str,"oacCannotAddRouteFigToNet")==0) { result->SetData(oacCannotAddRouteFigToNet); return 1;}
        if (strcasecmp(str,"oacCannotAddPinFigToNet")==0) { result->SetData(oacCannotAddPinFigToNet); return 1;}
        if (strcasecmp(str,"oacCannotAddInstToNet")==0) { result->SetData(oacCannotAddInstToNet); return 1;}
        if (strcasecmp(str,"oacCannotAddRouteFigToPin")==0) { result->SetData(oacCannotAddRouteFigToPin); return 1;}
        if (strcasecmp(str,"oacCannotAddNetFigToPin")==0) { result->SetData(oacCannotAddNetFigToPin); return 1;}
        if (strcasecmp(str,"oacCannotAddPinFigToRoute")==0) { result->SetData(oacCannotAddPinFigToRoute); return 1;}
        if (strcasecmp(str,"oacRouteAndObjectNotInSameBlock")==0) { result->SetData(oacRouteAndObjectNotInSameBlock); return 1;}
        if (strcasecmp(str,"oacCannotAddRouteConnFigToRoute")==0) { result->SetData(oacCannotAddRouteConnFigToRoute); return 1;}
        if (strcasecmp(str,"oacCannotAddFigToRouteOnDifferentNet")==0) { result->SetData(oacCannotAddFigToRouteOnDifferentNet); return 1;}
        if (strcasecmp(str,"oacCannotAddSameFigToRouteAgain")==0) { result->SetData(oacCannotAddSameFigToRouteAgain); return 1;}
        if (strcasecmp(str,"oacPinAndFigNotInSameBlock")==0) { result->SetData(oacPinAndFigNotInSameBlock); return 1;}
        if (strcasecmp(str,"oacInvalidStdViaMaster")==0) { result->SetData(oacInvalidStdViaMaster); return 1;}
        if (strcasecmp(str,"oacInvalidHierPath")==0) { result->SetData(oacInvalidHierPath); return 1;}
        if (strcasecmp(str,"oacCannotLockDatabase")==0) { result->SetData(oacCannotLockDatabase); return 1;}
        if (strcasecmp(str,"oacCannotFindSpecAssignedDefOccNet")==0) { result->SetData(oacCannotFindSpecAssignedDefOccNet); return 1;}
        if (strcasecmp(str,"oacCannotFindSpecAssignedOccNet")==0) { result->SetData(oacCannotFindSpecAssignedOccNet); return 1;}
        if (strcasecmp(str,"oacCannotCreateBlockageWithImplicitInst")==0) { result->SetData(oacCannotCreateBlockageWithImplicitInst); return 1;}
        if (strcasecmp(str,"oacCannotAddBlockageToImplicitInst")==0) { result->SetData(oacCannotAddBlockageToImplicitInst); return 1;}
        if (strcasecmp(str,"oacDesignCannotGetReadAccess")==0) { result->SetData(oacDesignCannotGetReadAccess); return 1;}
        if (strcasecmp(str,"oacDesignCannotGetWriteAccess")==0) { result->SetData(oacDesignCannotGetWriteAccess); return 1;}
        if (strcasecmp(str,"oacDesignHasReadNeedWriteAccess")==0) { result->SetData(oacDesignHasReadNeedWriteAccess); return 1;}
        if (strcasecmp(str,"oacParasiticsDataCannotGetReadAccess")==0) { result->SetData(oacParasiticsDataCannotGetReadAccess); return 1;}
        if (strcasecmp(str,"oacParasiticsDataCannotGetWriteAccess")==0) { result->SetData(oacParasiticsDataCannotGetWriteAccess); return 1;}
        if (strcasecmp(str,"oacParasiticsDataHasReadNeedWriteAccess")==0) { result->SetData(oacParasiticsDataHasReadNeedWriteAccess); return 1;}
        if (strcasecmp(str,"oacParasiticNetworkPartitionNameExists")==0) { result->SetData(oacParasiticNetworkPartitionNameExists); return 1;}
        if (strcasecmp(str,"oacParasiticNetworkPartialLoaded")==0) { result->SetData(oacParasiticNetworkPartialLoaded); return 1;}
        if (strcasecmp(str,"oacCustomEndStyleNotAllowed")==0) { result->SetData(oacCustomEndStyleNotAllowed); return 1;}
        if (strcasecmp(str,"oacEvenWidthRequiredForSegStyle")==0) { result->SetData(oacEvenWidthRequiredForSegStyle); return 1;}
        if (strcasecmp(str,"oacCustomEndStyleNotAllowedForBegin")==0) { result->SetData(oacCustomEndStyleNotAllowedForBegin); return 1;}
        if (strcasecmp(str,"oacOnlyCustomEndStyleAllowedForEnd")==0) { result->SetData(oacOnlyCustomEndStyleAllowedForEnd); return 1;}
        if (strcasecmp(str,"oacCustomEndStyleNotAllowedForEnd")==0) { result->SetData(oacCustomEndStyleNotAllowedForEnd); return 1;}
        if (strcasecmp(str,"oacOnlyCustomEndStyleAllowedForBegin")==0) { result->SetData(oacOnlyCustomEndStyleAllowedForBegin); return 1;}
        if (strcasecmp(str,"oacOnlyCustomEndStylesAllowed")==0) { result->SetData(oacOnlyCustomEndStylesAllowed); return 1;}
        if (strcasecmp(str,"oacCannotChangeWidthForBothCustomEnds")==0) { result->SetData(oacCannotChangeWidthForBothCustomEnds); return 1;}
        if (strcasecmp(str,"oacUndoNotEnabled")==0) { result->SetData(oacUndoNotEnabled); return 1;}
        if (strcasecmp(str,"oacRegionQueryAlreadyInitialized")==0) { result->SetData(oacRegionQueryAlreadyInitialized); return 1;}
        if (strcasecmp(str,"oacRegionQueryNotInitialized")==0) { result->SetData(oacRegionQueryNotInitialized); return 1;}
        if (strcasecmp(str,"oacRegionQueryFailedToGetPlugIn")==0) { result->SetData(oacRegionQueryFailedToGetPlugIn); return 1;}
        if (strcasecmp(str,"oacInvalidDesignObject")==0) { result->SetData(oacInvalidDesignObject); return 1;}
        if (strcasecmp(str,"oacRowZeroNumSitesNotAllowed")==0) { result->SetData(oacRowZeroNumSitesNotAllowed); return 1;}
        if (strcasecmp(str,"oacModuleDetachRequiresUndoToBeDisabled")==0) { result->SetData(oacModuleDetachRequiresUndoToBeDisabled); return 1;}
        if (strcasecmp(str,"oacOccDestroyRequiresUndoToBeDisabled")==0) { result->SetData(oacOccDestroyRequiresUndoToBeDisabled); return 1;}
        if (strcasecmp(str,"oacDriverAnalysisPointNotInSameDesign")==0) { result->SetData(oacDriverAnalysisPointNotInSameDesign); return 1;}
        if (strcasecmp(str,"oacDriverReceiverNotInSameDesign")==0) { result->SetData(oacDriverReceiverNotInSameDesign); return 1;}
        if (strcasecmp(str,"oacInvalidNodeIdSpecified")==0) { result->SetData(oacInvalidNodeIdSpecified); return 1;}
        if (strcasecmp(str,"oacInvalidDeviceIdSpecified")==0) { result->SetData(oacInvalidDeviceIdSpecified); return 1;}
        if (strcasecmp(str,"oacDesignHasNoTopBlock")==0) { result->SetData(oacDesignHasNoTopBlock); return 1;}
        if (strcasecmp(str,"oacAncestorNodeWithoutId")==0) { result->SetData(oacAncestorNodeWithoutId); return 1;}
        if (strcasecmp(str,"oacAncestorInductorWithoutId")==0) { result->SetData(oacAncestorInductorWithoutId); return 1;}
        if (strcasecmp(str,"oacNodesNotInRelatedPartitions")==0) { result->SetData(oacNodesNotInRelatedPartitions); return 1;}
        if (strcasecmp(str,"oacInductorsNotInRelatedPartitions")==0) { result->SetData(oacInductorsNotInRelatedPartitions); return 1;}
        if (strcasecmp(str,"oacViaDefNotInTechAssociatedWithDesign")==0) { result->SetData(oacViaDefNotInTechAssociatedWithDesign); return 1;}
        if (strcasecmp(str,"oacSiteDefNotInTechAssociatedWithDesign")==0) { result->SetData(oacSiteDefNotInTechAssociatedWithDesign); return 1;}
        if (strcasecmp(str,"oacObsoleteDesignMsg1493")==0) { result->SetData(oacObsoleteDesignMsg1493); return 1;}
        if (strcasecmp(str,"oacScriptEngineLinkExists")==0) { result->SetData(oacScriptEngineLinkExists); return 1;}
        if (strcasecmp(str,"oacPcellEvaluatorNotFound")==0) { result->SetData(oacPcellEvaluatorNotFound); return 1;}
        if (strcasecmp(str,"oacCannotCopyPcellInst")==0) { result->SetData(oacCannotCopyPcellInst); return 1;}
        if (strcasecmp(str,"oacCannotMovePcellInst")==0) { result->SetData(oacCannotMovePcellInst); return 1;}
        if (strcasecmp(str,"oacCannotSetConnStatusImplicitNet")==0) { result->SetData(oacCannotSetConnStatusImplicitNet); return 1;}
        if (strcasecmp(str,"oacCannotSetOriginalNetImplicitNet")==0) { result->SetData(oacCannotSetOriginalNetImplicitNet); return 1;}
        if (strcasecmp(str,"oacImplicitNetCannotBeOriginalNet")==0) { result->SetData(oacImplicitNetCannotBeOriginalNet); return 1;}
        if (strcasecmp(str,"oacCannotSetVoltageImplicitNet")==0) { result->SetData(oacCannotSetVoltageImplicitNet); return 1;}
        if (strcasecmp(str,"oacCannotSetRoutePattenImplicitNet")==0) { result->SetData(oacCannotSetRoutePattenImplicitNet); return 1;}
        if (strcasecmp(str,"oacCannotShieldImplicitNet")==0) { result->SetData(oacCannotShieldImplicitNet); return 1;}
        if (strcasecmp(str,"oacImplicitNetCannotShieldNet")==0) { result->SetData(oacImplicitNetCannotShieldNet); return 1;}
        if (strcasecmp(str,"oacNetSetBaseNameConflictsInTerms")==0) { result->SetData(oacNetSetBaseNameConflictsInTerms); return 1;}
        if (strcasecmp(str,"oacNetSetBaseNameConflictsInInstTerms")==0) { result->SetData(oacNetSetBaseNameConflictsInInstTerms); return 1;}
        if (strcasecmp(str,"oacNetSetRangeConflictsWithOtherNets")==0) { result->SetData(oacNetSetRangeConflictsWithOtherNets); return 1;}
        if (strcasecmp(str,"oacCannotRenameToImplicitBusNet")==0) { result->SetData(oacCannotRenameToImplicitBusNet); return 1;}
        if (strcasecmp(str,"oacCannotRenameToImplicitBusTerm")==0) { result->SetData(oacCannotRenameToImplicitBusTerm); return 1;}
        if (strcasecmp(str,"oacCannotCreateBlockOnlyInModuleDesign")==0) { result->SetData(oacCannotCreateBlockOnlyInModuleDesign); return 1;}
        if (strcasecmp(str,"oacInvalidScanChainObject")==0) { result->SetData(oacInvalidScanChainObject); return 1;}
        if (strcasecmp(str,"oacInvalidInstTermBitIndex")==0) { result->SetData(oacInvalidInstTermBitIndex); return 1;}
        if (strcasecmp(str,"oacInstTermNetMismatchInRepeatedMembers")==0) { result->SetData(oacInstTermNetMismatchInRepeatedMembers); return 1;}
        if (strcasecmp(str,"oacInvalidNetName")==0) { result->SetData(oacInvalidNetName); return 1;}
        if (strcasecmp(str,"oacInvalidTermName")==0) { result->SetData(oacInvalidTermName); return 1;}
        if (strcasecmp(str,"oacCannotHideImplicitInstTerm")==0) { result->SetData(oacCannotHideImplicitInstTerm); return 1;}
        if (strcasecmp(str,"oacCannotHideBlockOnlyInstTerm")==0) { result->SetData(oacCannotHideBlockOnlyInstTerm); return 1;}
        if (strcasecmp(str,"oacCannotDestroyImplicitTerm")==0) { result->SetData(oacCannotDestroyImplicitTerm); return 1;}
        if (strcasecmp(str,"oacInvalidNodeConnNet")==0) { result->SetData(oacInvalidNodeConnNet); return 1;}
        if (strcasecmp(str,"oacCannotChangeUndoModel")==0) { result->SetData(oacCannotChangeUndoModel); return 1;}
        if (strcasecmp(str,"oacCannotUnsetNonEmptyCp")==0) { result->SetData(oacCannotUnsetNonEmptyCp); return 1;}
        if (strcasecmp(str,"oacCannotUndoWithoutCpInPostModel")==0) { result->SetData(oacCannotUndoWithoutCpInPostModel); return 1;}
        if (strcasecmp(str,"oacInstTermBatchCreateHasInstTerms")==0) { result->SetData(oacInstTermBatchCreateHasInstTerms); return 1;}
        if (strcasecmp(str,"oacInvalidGlobalNet")==0) { result->SetData(oacInvalidGlobalNet); return 1;}
        if (strcasecmp(str,"oacInvalidFigGroup")==0) { result->SetData(oacInvalidFigGroup); return 1;}
        if (strcasecmp(str,"oacInvalidFigGroupStatusTypeName")==0) { result->SetData(oacInvalidFigGroupStatusTypeName); return 1;}
        if (strcasecmp(str,"oacFigAlreadyInFigGroup")==0) { result->SetData(oacFigAlreadyInFigGroup); return 1;}
        if (strcasecmp(str,"oacFigGroupNameExists")==0) { result->SetData(oacFigGroupNameExists); return 1;}
        if (strcasecmp(str,"oacInvalidFigGroupTypeForMemberMove")==0) { result->SetData(oacInvalidFigGroupTypeForMemberMove); return 1;}
        if (strcasecmp(str,"oacFigGroupMemberNotInSameFigGroup")==0) { result->SetData(oacFigGroupMemberNotInSameFigGroup); return 1;}
        if (strcasecmp(str,"oacFigGroupMemberNotInSameDB")==0) { result->SetData(oacFigGroupMemberNotInSameDB); return 1;}
        if (strcasecmp(str,"oacFigGroupCircularMembership")==0) { result->SetData(oacFigGroupCircularMembership); return 1;}
        if (strcasecmp(str,"oacConstraintGroupNotInTechAssociatedWithDesign")==0) { result->SetData(oacConstraintGroupNotInTechAssociatedWithDesign); return 1;}
        if (strcasecmp(str,"oacInvalidBuiltInTechConstraintGroupInDesign")==0) { result->SetData(oacInvalidBuiltInTechConstraintGroupInDesign); return 1;}
        if (strcasecmp(str,"oacInvalidDefaultTechConstraintGroupInDesign")==0) { result->SetData(oacInvalidDefaultTechConstraintGroupInDesign); return 1;}
        if (strcasecmp(str,"oacBindViaToIncorrectViaDefOnCopy")==0) { result->SetData(oacBindViaToIncorrectViaDefOnCopy); return 1;}
        if (strcasecmp(str,"oacBindViaToIncorrectViaDefOnMove")==0) { result->SetData(oacBindViaToIncorrectViaDefOnMove); return 1;}
        if (strcasecmp(str,"oacBindRowToIncorrectSiteDefOnCopy")==0) { result->SetData(oacBindRowToIncorrectSiteDefOnCopy); return 1;}
        if (strcasecmp(str,"oacBindRowToIncorrectSiteDefOnMove")==0) { result->SetData(oacBindRowToIncorrectSiteDefOnMove); return 1;}
        if (strcasecmp(str,"oacConflictingSiteDefsInTechAssociatedWithDesign")==0) { result->SetData(oacConflictingSiteDefsInTechAssociatedWithDesign); return 1;}
        if (strcasecmp(str,"oacConflictingViaDefsInTechAssociatedWithDesign")==0) { result->SetData(oacConflictingViaDefsInTechAssociatedWithDesign); return 1;}
        if (strcasecmp(str,"oacConflictingOpPointsInTechAssociatedWithDesign")==0) { result->SetData(oacConflictingOpPointsInTechAssociatedWithDesign); return 1;}
        if (strcasecmp(str,"oacTextLinkAlreadyInitialized")==0) { result->SetData(oacTextLinkAlreadyInitialized); return 1;}
        if (strcasecmp(str,"oacFailedToGetTextPlugIn")==0) { result->SetData(oacFailedToGetTextPlugIn); return 1;}
        if (strcasecmp(str,"oacFailedToInitTextPlugIn")==0) { result->SetData(oacFailedToInitTextPlugIn); return 1;}
        if (strcasecmp(str,"oacCannotUnsetGlobalStateOfNetInTopModule")==0) { result->SetData(oacCannotUnsetGlobalStateOfNetInTopModule); return 1;}
        if (strcasecmp(str,"oacTermHasNoMustJoinTerm")==0) { result->SetData(oacTermHasNoMustJoinTerm); return 1;}
        if (strcasecmp(str,"oacInvalidFigGroupMem")==0) { result->SetData(oacInvalidFigGroupMem); return 1;}
        if (strcasecmp(str,"oacInvalidFig")==0) { result->SetData(oacInvalidFig); return 1;}
        if (strcasecmp(str,"oacInvalidBlockObject")==0) { result->SetData(oacInvalidBlockObject); return 1;}
        if (strcasecmp(str,"oacCannotUndoUniquify")==0) { result->SetData(oacCannotUndoUniquify); return 1;}
        if (strcasecmp(str,"oacCannotCopyMoveUnboundViaToStrangerDesign")==0) { result->SetData(oacCannotCopyMoveUnboundViaToStrangerDesign); return 1;}
        if (strcasecmp(str,"oacCannotCopyMoveUnboundRowToStrangerDesign")==0) { result->SetData(oacCannotCopyMoveUnboundRowToStrangerDesign); return 1;}
        if (strcasecmp(str,"oacCorruptedMustJoinTerms")==0) { result->SetData(oacCorruptedMustJoinTerms); return 1;}
        if (strcasecmp(str,"oacCorruptedSupplySensitivityTerms")==0) { result->SetData(oacCorruptedSupplySensitivityTerms); return 1;}
        if (strcasecmp(str,"oacCorruptedGroundSensitivityTerms")==0) { result->SetData(oacCorruptedGroundSensitivityTerms); return 1;}
        if (strcasecmp(str,"oacCorruptedSteinerConnRoutes")==0) { result->SetData(oacCorruptedSteinerConnRoutes); return 1;}
        if (strcasecmp(str,"oacPaddingForLaterDMRelease1")==0) { result->SetData(oacPaddingForLaterDMRelease1); return 1;}
        if (strcasecmp(str,"oacPaddingForLaterDMRelease2")==0) { result->SetData(oacPaddingForLaterDMRelease2); return 1;}
        if (strcasecmp(str,"oacPaddingForLaterDMRelease3")==0) { result->SetData(oacPaddingForLaterDMRelease3); return 1;}
        if (strcasecmp(str,"oacPaddingForLaterDMRelease4")==0) { result->SetData(oacPaddingForLaterDMRelease4); return 1;}
        if (strcasecmp(str,"oacPaddingForLaterDMRelease5")==0) { result->SetData(oacPaddingForLaterDMRelease5); return 1;}
        if (strcasecmp(str,"oacPaddingForLaterDMRelease6")==0) { result->SetData(oacPaddingForLaterDMRelease6); return 1;}
        if (strcasecmp(str,"oacPaddingForLaterDMRelease7")==0) { result->SetData(oacPaddingForLaterDMRelease7); return 1;}
        if (strcasecmp(str,"oacPaddingForLaterDMRelease8")==0) { result->SetData(oacPaddingForLaterDMRelease8); return 1;}
        if (strcasecmp(str,"oacPaddingForLaterDMRelease9")==0) { result->SetData(oacPaddingForLaterDMRelease9); return 1;}
        if (strcasecmp(str,"oacPaddingForLaterDMRelease10")==0) { result->SetData(oacPaddingForLaterDMRelease10); return 1;}
        if (strcasecmp(str,"oacPaddingForLaterDMRelease11")==0) { result->SetData(oacPaddingForLaterDMRelease11); return 1;}
        if (strcasecmp(str,"oacPaddingForLaterDMRelease12")==0) { result->SetData(oacPaddingForLaterDMRelease12); return 1;}
        if (strcasecmp(str,"oacPaddingForLaterDMRelease13")==0) { result->SetData(oacPaddingForLaterDMRelease13); return 1;}
        if (strcasecmp(str,"oacPaddingForLaterDMRelease14")==0) { result->SetData(oacPaddingForLaterDMRelease14); return 1;}
        if (strcasecmp(str,"oacPaddingForLaterDMRelease15")==0) { result->SetData(oacPaddingForLaterDMRelease15); return 1;}
        if (strcasecmp(str,"oacInstTermAlreadyInScanChain")==0) { result->SetData(oacInstTermAlreadyInScanChain); return 1;}
        if (strcasecmp(str,"oacScanChainInstTermsNotOnSameInst")==0) { result->SetData(oacScanChainInstTermsNotOnSameInst); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaDesignMsgIds)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDesignMsgIds Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaDesignMsgIds_FromoaDesignMsgIds(oaDesignMsgIds ob)
{
    if (ob==oacInvalidDesign) return PyString_FromString("oacInvalidDesign");
    if (ob==oacNotADesign) return PyString_FromString("oacNotADesign");
    if (ob==oacSaveReadOnlyDesign) return PyString_FromString("oacSaveReadOnlyDesign");
    if (ob==oacSaveScratchModeDesign) return PyString_FromString("oacSaveScratchModeDesign");
    if (ob==oacOpenUndefinedModeDesign) return PyString_FromString("oacOpenUndefinedModeDesign");
    if (ob==oacCannotFindDesign) return PyString_FromString("oacCannotFindDesign");
    if (ob==oacDesignPrimaryFileDoesNotExist) return PyString_FromString("oacDesignPrimaryFileDoesNotExist");
    if (ob==oacDesignFollowerFileDoesNotExist) return PyString_FromString("oacDesignFollowerFileDoesNotExist");
    if (ob==oacDetailedParasiticsFileDoesNotExist) return PyString_FromString("oacDetailedParasiticsFileDoesNotExist");
    if (ob==oacCannotSetModeToScratch) return PyString_FromString("oacCannotSetModeToScratch");
    if (ob==oacCannotChangeFromScratchMode) return PyString_FromString("oacCannotChangeFromScratchMode");
    if (ob==oacCannotModifyReadModeDesign) return PyString_FromString("oacCannotModifyReadModeDesign");
    if (ob==oacOpenOnDesignBeingPurged) return PyString_FromString("oacOpenOnDesignBeingPurged");
    if (ob==oacPurgeOnDesignBeingPurged) return PyString_FromString("oacPurgeOnDesignBeingPurged");
    if (ob==oacInvalidDesignViewType) return PyString_FromString("oacInvalidDesignViewType");
    if (ob==oacMismatchViewTypeForOpen) return PyString_FromString("oacMismatchViewTypeForOpen");
    if (ob==oacObsoleteDesignMsg1016) return PyString_FromString("oacObsoleteDesignMsg1016");
    if (ob==oacDestroyDesignOpen) return PyString_FromString("oacDestroyDesignOpen");
    if (ob==oacDestroyCannotFindDesign) return PyString_FromString("oacDestroyCannotFindDesign");
    if (ob==oacInvalidCellTypeName) return PyString_FromString("oacInvalidCellTypeName");
    if (ob==oacInvalidDesignAttrTypeName) return PyString_FromString("oacInvalidDesignAttrTypeName");
    if (ob==oacInvalidSymmetryName) return PyString_FromString("oacInvalidSymmetryName");
    if (ob==oacCannotFindTechForDesign) return PyString_FromString("oacCannotFindTechForDesign");
    if (ob==oacCannotFindObjectForViaMaster) return PyString_FromString("oacCannotFindObjectForViaMaster");
    if (ob==oacObsoleteDesignMsg1024) return PyString_FromString("oacObsoleteDesignMsg1024");
    if (ob==oacCannotFindLibrary) return PyString_FromString("oacCannotFindLibrary");
    if (ob==oacInvalidRouteStatusTypeName) return PyString_FromString("oacInvalidRouteStatusTypeName");
    if (ob==oacInvalidBlock) return PyString_FromString("oacInvalidBlock");
    if (ob==oacInvalidOccurrence) return PyString_FromString("oacInvalidOccurrence");
    if (ob==oacInvalidShape) return PyString_FromString("oacInvalidShape");
    if (ob==oacInvalidPath) return PyString_FromString("oacInvalidPath");
    if (ob==oacInvalidPolygon) return PyString_FromString("oacInvalidPolygon");
    if (ob==oacArcEllipseBBoxInvalid) return PyString_FromString("oacArcEllipseBBoxInvalid");
    if (ob==oacArcAnglesInvalid) return PyString_FromString("oacArcAnglesInvalid");
    if (ob==oacArcPointsColinear) return PyString_FromString("oacArcPointsColinear");
    if (ob==oacArcTooLarge) return PyString_FromString("oacArcTooLarge");
    if (ob==oacArcWrongNumIntercepts) return PyString_FromString("oacArcWrongNumIntercepts");
    if (ob==oacDonutRadiiInvalid) return PyString_FromString("oacDonutRadiiInvalid");
    if (ob==oacDonutNumSidesInvalid) return PyString_FromString("oacDonutNumSidesInvalid");
    if (ob==oacEllipseBBoxInvalid) return PyString_FromString("oacEllipseBBoxInvalid");
    if (ob==oacEllipseNumSidesInvalid) return PyString_FromString("oacEllipseNumSidesInvalid");
    if (ob==oacInvalidPathExtensionValue) return PyString_FromString("oacInvalidPathExtensionValue");
    if (ob==oacPathHasExtraPoints) return PyString_FromString("oacPathHasExtraPoints");
    if (ob==oacPathTooFewPoints) return PyString_FromString("oacPathTooFewPoints");
    if (ob==oacPolygonHasExtraPoints) return PyString_FromString("oacPolygonHasExtraPoints");
    if (ob==oacPolygonTooFewPoints) return PyString_FromString("oacPolygonTooFewPoints");
    if (ob==oacRectBBoxInvalid) return PyString_FromString("oacRectBBoxInvalid");
    if (ob==oacArcNumSidesInvalid) return PyString_FromString("oacArcNumSidesInvalid");
    if (ob==oacLineTooFewPoints) return PyString_FromString("oacLineTooFewPoints");
    if (ob==oacCannotConvertPolygonToRect) return PyString_FromString("oacCannotConvertPolygonToRect");
    if (ob==oacNetFigNotInSameBlock) return PyString_FromString("oacNetFigNotInSameBlock");
    if (ob==oacNetEquivNetNotInSameBlock) return PyString_FromString("oacNetEquivNetNotInSameBlock");
    if (ob==oacNetAndInstNotInSameDesign) return PyString_FromString("oacNetAndInstNotInSameDesign");
    if (ob==oacTransferNetsNotInSameBlock) return PyString_FromString("oacTransferNetsNotInSameBlock");
    if (ob==oacMergeNetsNotInSameBlock) return PyString_FromString("oacMergeNetsNotInSameBlock");
    if (ob==oacMoveToNetNotInSameBlock) return PyString_FromString("oacMoveToNetNotInSameBlock");
    if (ob==oacShieldNetNotInSameBlock) return PyString_FromString("oacShieldNetNotInSameBlock");
    if (ob==oacOriginalNetNotInSameBlock) return PyString_FromString("oacOriginalNetNotInSameBlock");
    if (ob==oacPinTermNotInSameBlock) return PyString_FromString("oacPinTermNotInSameBlock");
    if (ob==oacInvalidBlockNetIterFlags) return PyString_FromString("oacInvalidBlockNetIterFlags");
    if (ob==oacInvalidBlockTermIterFlags) return PyString_FromString("oacInvalidBlockTermIterFlags");
    if (ob==oacInvalidInst) return PyString_FromString("oacInvalidInst");
    if (ob==oacInvalidInstAttrTypeName) return PyString_FromString("oacInvalidInstAttrTypeName");
    if (ob==oacInstNameOverlapsOtherInst) return PyString_FromString("oacInstNameOverlapsOtherInst");
    if (ob==oacVectorInstNameMatchesAutoName) return PyString_FromString("oacVectorInstNameMatchesAutoName");
    if (ob==oacVectorInstBitNameMatchesAutoName) return PyString_FromString("oacVectorInstBitNameMatchesAutoName");
    if (ob==oacInstNameExists) return PyString_FromString("oacInstNameExists");
    if (ob==oacInvalidArrayInstRows) return PyString_FromString("oacInvalidArrayInstRows");
    if (ob==oacInvalidArrayInstCols) return PyString_FromString("oacInvalidArrayInstCols");
    if (ob==oacCannotSetNameOfImplicitInst) return PyString_FromString("oacCannotSetNameOfImplicitInst");
    if (ob==oacCannotDestroyImplicitInst) return PyString_FromString("oacCannotDestroyImplicitInst");
    if (ob==oacCannotSetMasterImplicitInst) return PyString_FromString("oacCannotSetMasterImplicitInst");
    if (ob==oacCannotSetParamsImplicitInst) return PyString_FromString("oacCannotSetParamsImplicitInst");
    if (ob==oacCannotSetPlacementStatusImplicitInst) return PyString_FromString("oacCannotSetPlacementStatusImplicitInst");
    if (ob==oacCannotSetPriorityImplicitInst) return PyString_FromString("oacCannotSetPriorityImplicitInst");
    if (ob==oacCannotSetSourceImplicitInst) return PyString_FromString("oacCannotSetSourceImplicitInst");
    if (ob==oacCannotSetUsageImplicitInst) return PyString_FromString("oacCannotSetUsageImplicitInst");
    if (ob==oacCannotClusterImplicitInst) return PyString_FromString("oacCannotClusterImplicitInst");
    if (ob==oacCannotScalarizeImplicitInst) return PyString_FromString("oacCannotScalarizeImplicitInst");
    if (ob==oacCannotMoveImplicitInst) return PyString_FromString("oacCannotMoveImplicitInst");
    if (ob==oacCannotCopyImplicitInst) return PyString_FromString("oacCannotCopyImplicitInst");
    if (ob==oacCannotGetImplicitInstOccurrence) return PyString_FromString("oacCannotGetImplicitInstOccurrence");
    if (ob==oacCannotGetVectorInstOccurrence) return PyString_FromString("oacCannotGetVectorInstOccurrence");
    if (ob==oacInvalidBitIndexIntoInst) return PyString_FromString("oacInvalidBitIndexIntoInst");
    if (ob==oacInstMustBeInUniqueOccHier) return PyString_FromString("oacInstMustBeInUniqueOccHier");
    if (ob==oacInvalidVectorInstDef) return PyString_FromString("oacInvalidVectorInstDef");
    if (ob==oacCannotDestroyImplicitVectorInstDef) return PyString_FromString("oacCannotDestroyImplicitVectorInstDef");
    if (ob==oacVectorInstDefAlreadyExists) return PyString_FromString("oacVectorInstDefAlreadyExists");
    if (ob==oacBitOrderVectorInstDefImplicit) return PyString_FromString("oacBitOrderVectorInstDefImplicit");
    if (ob==oacCannotDestroyVectorInstDefWithInsts) return PyString_FromString("oacCannotDestroyVectorInstDefWithInsts");
    if (ob==oacInvalidNetIndex) return PyString_FromString("oacInvalidNetIndex");
    if (ob==oacInvalidNetPriority) return PyString_FromString("oacInvalidNetPriority");
    if (ob==oacInvalidNet) return PyString_FromString("oacInvalidNet");
    if (ob==oacInvalidRoutePatternTypeName) return PyString_FromString("oacInvalidRoutePatternTypeName");
    if (ob==oacInvalidNetAttrTypeName) return PyString_FromString("oacInvalidNetAttrTypeName");
    if (ob==oacInvalidConnStatusName) return PyString_FromString("oacInvalidConnStatusName");
    if (ob==oacInvalidParasiticConfidenceValue) return PyString_FromString("oacInvalidParasiticConfidenceValue");
    if (ob==oacBusNetNameMatchesAutoName) return PyString_FromString("oacBusNetNameMatchesAutoName");
    if (ob==oacNetExists) return PyString_FromString("oacNetExists");
    if (ob==oacScalarNetNameMatchesBusBaseName) return PyString_FromString("oacScalarNetNameMatchesBusBaseName");
    if (ob==oacBusNetBaseNameMatchesScalarName) return PyString_FromString("oacBusNetBaseNameMatchesScalarName");
    if (ob==oacInvalidBundleNetMemberIndex) return PyString_FromString("oacInvalidBundleNetMemberIndex");
    if (ob==oacInvalidBusNetBitIndex) return PyString_FromString("oacInvalidBusNetBitIndex");
    if (ob==oacCannotSetNameOfImplicitNet) return PyString_FromString("oacCannotSetNameOfImplicitNet");
    if (ob==oacCannotSetNameOfNetInBundleNet) return PyString_FromString("oacCannotSetNameOfNetInBundleNet");
    if (ob==oacCannotSetParasiticConfImplicitNet) return PyString_FromString("oacCannotSetParasiticConfImplicitNet");
    if (ob==oacCannotScalarizeImplicitNet) return PyString_FromString("oacCannotScalarizeImplicitNet");
    if (ob==oacCannotSetRangeOfImplicitBus) return PyString_FromString("oacCannotSetRangeOfImplicitBus");
    if (ob==oacCannotSetRangeOfBusInBundleNet) return PyString_FromString("oacCannotSetRangeOfBusInBundleNet");
    if (ob==oacCannotAddFigToImplicitNet) return PyString_FromString("oacCannotAddFigToImplicitNet");
    if (ob==oacCannotDestroyImplicitNet) return PyString_FromString("oacCannotDestroyImplicitNet");
    if (ob==oacCannotDestroyNetInNonUniqueSpan) return PyString_FromString("oacCannotDestroyNetInNonUniqueSpan");
    if (ob==oacNetHasNoEquivNet) return PyString_FromString("oacNetHasNoEquivNet");
    if (ob==oacCannotTransferNetWithTerm) return PyString_FromString("oacCannotTransferNetWithTerm");
    if (ob==oacCannotTransferNetWithInstTerm) return PyString_FromString("oacCannotTransferNetWithInstTerm");
    if (ob==oacCannotMergeNetsWithDiffNumBits) return PyString_FromString("oacCannotMergeNetsWithDiffNumBits");
    if (ob==oacMergeNetsMustBeInUniqueOccHier) return PyString_FromString("oacMergeNetsMustBeInUniqueOccHier");
    if (ob==oacTransferNetsMustBeInUniqueOccHier) return PyString_FromString("oacTransferNetsMustBeInUniqueOccHier");
    if (ob==oacInvalidTermIndex) return PyString_FromString("oacInvalidTermIndex");
    if (ob==oacInvalidTermTypeName) return PyString_FromString("oacInvalidTermTypeName");
    if (ob==oacInvalidRouteMethodName) return PyString_FromString("oacInvalidRouteMethodName");
    if (ob==oacInvalidTermAttrTypeName) return PyString_FromString("oacInvalidTermAttrTypeName");
    if (ob==oacInvalidTerm) return PyString_FromString("oacInvalidTerm");
    if (ob==oacCannotSetNameOfImplicitTerm) return PyString_FromString("oacCannotSetNameOfImplicitTerm");
    if (ob==oacCannotSetNameOfTermInBundleTerm) return PyString_FromString("oacCannotSetNameOfTermInBundleTerm");
    if (ob==oacCannotSetAntennaDataOnImplicitTerm) return PyString_FromString("oacCannotSetAntennaDataOnImplicitTerm");
    if (ob==oacCannotScalarizeImplicitTerm) return PyString_FromString("oacCannotScalarizeImplicitTerm");
    if (ob==oacInvalidPinConnectMethodName) return PyString_FromString("oacInvalidPinConnectMethodName");
    if (ob==oacCannotCreateTermWithImplicitNet) return PyString_FromString("oacCannotCreateTermWithImplicitNet");
    if (ob==oacCannotCreateTermWithBlockOnlyNet) return PyString_FromString("oacCannotCreateTermWithBlockOnlyNet");
    if (ob==oacCannotMoveToImplicitNet) return PyString_FromString("oacCannotMoveToImplicitNet");
    if (ob==oacCannotMoveToBlockOnlyNet) return PyString_FromString("oacCannotMoveToBlockOnlyNet");
    if (ob==oacTermMustJoinTermNotInSameBlock) return PyString_FromString("oacTermMustJoinTermNotInSameBlock");
    if (ob==oacTermMustJoinCannotBeImplicit) return PyString_FromString("oacTermMustJoinCannotBeImplicit");
    if (ob==oacTermMustJoinSameNet) return PyString_FromString("oacTermMustJoinSameNet");
    if (ob==oacTermSensitivityTermNotInSameBlock) return PyString_FromString("oacTermSensitivityTermNotInSameBlock");
    if (ob==oacCannotSetIsInterfaceOfImplicitTerm) return PyString_FromString("oacCannotSetIsInterfaceOfImplicitTerm");
    if (ob==oacTermNetMustBeInUniqueOccHier) return PyString_FromString("oacTermNetMustBeInUniqueOccHier");
    if (ob==oacTermExists) return PyString_FromString("oacTermExists");
    if (ob==oacTermMemberExists) return PyString_FromString("oacTermMemberExists");
    if (ob==oacCannotSetPositionOfImplicitTerm) return PyString_FromString("oacCannotSetPositionOfImplicitTerm");
    if (ob==oacCannotSetPositionOfBlockOnlyTerm) return PyString_FromString("oacCannotSetPositionOfBlockOnlyTerm");
    if (ob==oacTermPositionAlreadyTaken) return PyString_FromString("oacTermPositionAlreadyTaken");
    if (ob==oacScalarTermNameMatchesBusBaseName) return PyString_FromString("oacScalarTermNameMatchesBusBaseName");
    if (ob==oacBusTermBaseNameMatchesScalarName) return PyString_FromString("oacBusTermBaseNameMatchesScalarName");
    if (ob==oacInvalidBundleTermMemberIndex) return PyString_FromString("oacInvalidBundleTermMemberIndex");
    if (ob==oacNetTermWidthMismatch) return PyString_FromString("oacNetTermWidthMismatch");
    if (ob==oacCannotSetBusTermBitTermType) return PyString_FromString("oacCannotSetBusTermBitTermType");
    if (ob==oacInvalidBusStartStopRange) return PyString_FromString("oacInvalidBusStartStopRange");
    if (ob==oacCannotSetRouteMethodOnImplicitTerm) return PyString_FromString("oacCannotSetRouteMethodOnImplicitTerm");
    if (ob==oacInvalidBitOrderName) return PyString_FromString("oacInvalidBitOrderName");
    if (ob==oacInvalidBusNetDef) return PyString_FromString("oacInvalidBusNetDef");
    if (ob==oacCannotDestroyImplicitBusNetDef) return PyString_FromString("oacCannotDestroyImplicitBusNetDef");
    if (ob==oacBusNetDefAlreadyExists) return PyString_FromString("oacBusNetDefAlreadyExists");
    if (ob==oacBitOrderBusNetDefImplicit) return PyString_FromString("oacBitOrderBusNetDefImplicit");
    if (ob==oacCannotDestroyBusNetDefWithNets) return PyString_FromString("oacCannotDestroyBusNetDefWithNets");
    if (ob==oacInvalidBusTermDef) return PyString_FromString("oacInvalidBusTermDef");
    if (ob==oacCannotDestroyImplicitBusTermDef) return PyString_FromString("oacCannotDestroyImplicitBusTermDef");
    if (ob==oacBusTermDefAlreadyExists) return PyString_FromString("oacBusTermDefAlreadyExists");
    if (ob==oacBitOrderBusTermDefImplicit) return PyString_FromString("oacBitOrderBusTermDefImplicit");
    if (ob==oacCannotDestroyBusTermDefWithTerms) return PyString_FromString("oacCannotDestroyBusTermDefWithTerms");
    if (ob==oacInvalidLPPHeader) return PyString_FromString("oacInvalidLPPHeader");
    if (ob==oacInvalidInstHeader) return PyString_FromString("oacInvalidInstHeader");
    if (ob==oacInvalidInstTerm) return PyString_FromString("oacInvalidInstTerm");
    if (ob==oacInvalidInstTermAttrTypeName) return PyString_FromString("oacInvalidInstTermAttrTypeName");
    if (ob==oacTermNotInInstMasterForInstTerm) return PyString_FromString("oacTermNotInInstMasterForInstTerm");
    if (ob==oacInstTermAlreadyExists) return PyString_FromString("oacInstTermAlreadyExists");
    if (ob==oacNetInstTermWidthMismatchForInstTerm) return PyString_FromString("oacNetInstTermWidthMismatchForInstTerm");
    if (ob==oacInstTermNetImplicit) return PyString_FromString("oacInstTermNetImplicit");
    if (ob==oacInstTermMustBeByPosition) return PyString_FromString("oacInstTermMustBeByPosition");
    if (ob==oacInstTermMustBeByName) return PyString_FromString("oacInstTermMustBeByName");
    if (ob==oacInstTermConnectsByPosition) return PyString_FromString("oacInstTermConnectsByPosition");
    if (ob==oacInstTermConnectsByName) return PyString_FromString("oacInstTermConnectsByName");
    if (ob==oacInstTermInstUsesTermPosition) return PyString_FromString("oacInstTermInstUsesTermPosition");
    if (ob==oacInstTermInstUsesTermName) return PyString_FromString("oacInstTermInstUsesTermName");
    if (ob==oacInstTermInstImplicit) return PyString_FromString("oacInstTermInstImplicit");
    if (ob==oacCannotDestroyImplicitInstTerm) return PyString_FromString("oacCannotDestroyImplicitInstTerm");
    if (ob==oacCannotModifyImplicitInstTerm) return PyString_FromString("oacCannotModifyImplicitInstTerm");
    if (ob==oacInstTermBitAlreadyExists) return PyString_FromString("oacInstTermBitAlreadyExists");
    if (ob==oacCannotScalarizeImplicitInstTerm) return PyString_FromString("oacCannotScalarizeImplicitInstTerm");
    if (ob==oacInstTermIterFlagNotApplicableOnNets) return PyString_FromString("oacInstTermIterFlagNotApplicableOnNets");
    if (ob==oacInstTermMustBeInUniqueModule) return PyString_FromString("oacInstTermMustBeInUniqueModule");
    if (ob==oacInstTermInstMustBeInUniqueOccHier) return PyString_FromString("oacInstTermInstMustBeInUniqueOccHier");
    if (ob==oacInstTermNetMustBeInUniqueOccHier) return PyString_FromString("oacInstTermNetMustBeInUniqueOccHier");
    if (ob==oacCannotModifyInstTermInNonUniqueHier) return PyString_FromString("oacCannotModifyInstTermInNonUniqueHier");
    if (ob==oacInvalidRoute) return PyString_FromString("oacInvalidRoute");
    if (ob==oacObjectNotValidForRoute) return PyString_FromString("oacObjectNotValidForRoute");
    if (ob==oacInvalidRouteTopologyName) return PyString_FromString("oacInvalidRouteTopologyName");
    if (ob==oacObjectAlreadyShieldsNet) return PyString_FromString("oacObjectAlreadyShieldsNet");
    if (ob==oacRouteAndConnNotInSameBlock) return PyString_FromString("oacRouteAndConnNotInSameBlock");
    if (ob==oacCannotSetRouteObjAsRouteConn) return PyString_FromString("oacCannotSetRouteObjAsRouteConn");
    if (ob==oacInvalidRouteConnObj) return PyString_FromString("oacInvalidRouteConnObj");
    if (ob==oacInvalidPin) return PyString_FromString("oacInvalidPin");
    if (ob==oacPinExists) return PyString_FromString("oacPinExists");
    if (ob==oacInvalidAccessDirForPin) return PyString_FromString("oacInvalidAccessDirForPin");
    if (ob==oacTermCannotBeImplicit) return PyString_FromString("oacTermCannotBeImplicit");
    if (ob==oacPinCannotUseImplicitInst) return PyString_FromString("oacPinCannotUseImplicitInst");
    if (ob==oacInvalidSubMaster) return PyString_FromString("oacInvalidSubMaster");
    if (ob==oacInvalidSuperMaster) return PyString_FromString("oacInvalidSuperMaster");
    if (ob==oacInvalidMaster) return PyString_FromString("oacInvalidMaster");
    if (ob==oacPcellObserverBindFailed) return PyString_FromString("oacPcellObserverBindFailed");
    if (ob==oacPcellEvaluationFailed) return PyString_FromString("oacPcellEvaluationFailed");
    if (ob==oacPcellInvalidPcellDef) return PyString_FromString("oacPcellInvalidPcellDef");
    if (ob==oacPcellMasterNotBound) return PyString_FromString("oacPcellMasterNotBound");
    if (ob==oacNotExistInDefaultParam) return PyString_FromString("oacNotExistInDefaultParam");
    if (ob==oacInvalidDataTypeForParam) return PyString_FromString("oacInvalidDataTypeForParam");
    if (ob==oacInvalidPcellMaster) return PyString_FromString("oacInvalidPcellMaster");
    if (ob==oacPcellLinkExists) return PyString_FromString("oacPcellLinkExists");
    if (ob==oacCannotDestroyIPcellWithLinkExist) return PyString_FromString("oacCannotDestroyIPcellWithLinkExist");
    if (ob==oacCannotSaveUnboundSuperMaster) return PyString_FromString("oacCannotSaveUnboundSuperMaster");
    if (ob==oacNonDesignTextDisplay) return PyString_FromString("oacNonDesignTextDisplay");
    if (ob==oacNoMasterForTextDisplay) return PyString_FromString("oacNoMasterForTextDisplay");
    if (ob==oacPropNotOnInstanceMaster) return PyString_FromString("oacPropNotOnInstanceMaster");
    if (ob==oacTextNotInInstanceMaster) return PyString_FromString("oacTextNotInInstanceMaster");
    if (ob==oacInvalidTextDisplayCopy) return PyString_FromString("oacInvalidTextDisplayCopy");
    if (ob==oacInvalidTextDisplayFormatName) return PyString_FromString("oacInvalidTextDisplayFormatName");
    if (ob==oacEvalTextLinkExists) return PyString_FromString("oacEvalTextLinkExists");
    if (ob==oacCannotDestroyIEvalTextWithLinkExist) return PyString_FromString("oacCannotDestroyIEvalTextWithLinkExist");
    if (ob==oacInvalidMarker) return PyString_FromString("oacInvalidMarker");
    if (ob==oacInvalidMarkerMove) return PyString_FromString("oacInvalidMarkerMove");
    if (ob==oacInvalidMarkerCopy) return PyString_FromString("oacInvalidMarkerCopy");
    if (ob==oacObjMarkerNotInSameBlock) return PyString_FromString("oacObjMarkerNotInSameBlock");
    if (ob==oacInvalidMarkerMemType) return PyString_FromString("oacInvalidMarkerMemType");
    if (ob==oacInvalidTrackPattern) return PyString_FromString("oacInvalidTrackPattern");
    if (ob==oacInvalidRow) return PyString_FromString("oacInvalidRow");
    if (ob==oacInvalidRowHeader) return PyString_FromString("oacInvalidRowHeader");
    if (ob==oacRowNameExists) return PyString_FromString("oacRowNameExists");
    if (ob==oacInvalidAssignmentDef) return PyString_FromString("oacInvalidAssignmentDef");
    if (ob==oacInvalidDataTypeForTimeStamp) return PyString_FromString("oacInvalidDataTypeForTimeStamp");
    if (ob==oacInvalidAssignment) return PyString_FromString("oacInvalidAssignment");
    if (ob==oacInstHasAssignment) return PyString_FromString("oacInstHasAssignment");
    if (ob==oacInstAndAssignmentNotInSameBlock) return PyString_FromString("oacInstAndAssignmentNotInSameBlock");
    if (ob==oacInvalidAssignmentAttrTypeName) return PyString_FromString("oacInvalidAssignmentAttrTypeName");
    if (ob==oacCannotCreateAssignmentImplicitInst) return PyString_FromString("oacCannotCreateAssignmentImplicitInst");
    if (ob==oacCannotSetAssignmentImplicitInst) return PyString_FromString("oacCannotSetAssignmentImplicitInst");
    if (ob==oacInvalidCluster) return PyString_FromString("oacInvalidCluster");
    if (ob==oacClusterNameExists) return PyString_FromString("oacClusterNameExists");
    if (ob==oacInstAlreadyInCluster) return PyString_FromString("oacInstAlreadyInCluster");
    if (ob==oacClusterAndInstNotSameBlock) return PyString_FromString("oacClusterAndInstNotSameBlock");
    if (ob==oacClusterAlreadyHasParent) return PyString_FromString("oacClusterAlreadyHasParent");
    if (ob==oacSameCluster) return PyString_FromString("oacSameCluster");
    if (ob==oacInvalidChildCluster) return PyString_FromString("oacInvalidChildCluster");
    if (ob==oacInvalidClusterTypeName) return PyString_FromString("oacInvalidClusterTypeName");
    if (ob==oacInvalidBoundary) return PyString_FromString("oacInvalidBoundary");
    if (ob==oacInvalidBoundaryType) return PyString_FromString("oacInvalidBoundaryType");
    if (ob==oacBoundaryHasExtraPoints) return PyString_FromString("oacBoundaryHasExtraPoints");
    if (ob==oacBoundaryTooFewPoints) return PyString_FromString("oacBoundaryTooFewPoints");
    if (ob==oacBoundaryNameExists) return PyString_FromString("oacBoundaryNameExists");
    if (ob==oacPRBoundaryExists) return PyString_FromString("oacPRBoundaryExists");
    if (ob==oacSnapBoundaryExists) return PyString_FromString("oacSnapBoundaryExists");
    if (ob==oacSnapBoundaryNotRectangle) return PyString_FromString("oacSnapBoundaryNotRectangle");
    if (ob==oacInterBlockBoundaryCopyInvalid) return PyString_FromString("oacInterBlockBoundaryCopyInvalid");
    if (ob==oacIntraBlockBoundaryCopyInvalid) return PyString_FromString("oacIntraBlockBoundaryCopyInvalid");
    if (ob==oacInvalidBlockageTypeName) return PyString_FromString("oacInvalidBlockageTypeName");
    if (ob==oacInvalidViaHeader) return PyString_FromString("oacInvalidViaHeader");
    if (ob==oacInvalidStdViaHeader) return PyString_FromString("oacInvalidStdViaHeader");
    if (ob==oacInvalidConnectDef) return PyString_FromString("oacInvalidConnectDef");
    if (ob==oacNetAlreadyHasConnectDef) return PyString_FromString("oacNetAlreadyHasConnectDef");
    if (ob==oacConnectDefImplicitNet) return PyString_FromString("oacConnectDefImplicitNet");
    if (ob==oacTermAlreadyHasConnectDef) return PyString_FromString("oacTermAlreadyHasConnectDef");
    if (ob==oacConnectDefImplicitTerm) return PyString_FromString("oacConnectDefImplicitTerm");
    if (ob==oacInvalidScanChainInst) return PyString_FromString("oacInvalidScanChainInst");
    if (ob==oacInvalidScanChainInstTerm) return PyString_FromString("oacInvalidScanChainInstTerm");
    if (ob==oacInvalidScanChainSetTypeName) return PyString_FromString("oacInvalidScanChainSetTypeName");
    if (ob==oacCannotSetMaxBits) return PyString_FromString("oacCannotSetMaxBits");
    if (ob==oacInvalidScanChain) return PyString_FromString("oacInvalidScanChain");
    if (ob==oacScanChainExists) return PyString_FromString("oacScanChainExists");
    if (ob==oacInvalidScanChainName) return PyString_FromString("oacInvalidScanChainName");
    if (ob==oacInvalidScanChainSet) return PyString_FromString("oacInvalidScanChainSet");
    if (ob==oacErrorCanOnlyHaveOneUnorderedSet) return PyString_FromString("oacErrorCanOnlyHaveOneUnorderedSet");
    if (ob==oacInvalidSteiner) return PyString_FromString("oacInvalidSteiner");
    if (ob==oacCannotAddSteinerToNonBitNet) return PyString_FromString("oacCannotAddSteinerToNonBitNet");
    if (ob==oacInvalidGCellPattern) return PyString_FromString("oacInvalidGCellPattern");
    if (ob==oacInvalidCMap) return PyString_FromString("oacInvalidCMap");
    if (ob==oacCMapLayerNotExists) return PyString_FromString("oacCMapLayerNotExists");
    if (ob==oacInvalidAnalysisPoint) return PyString_FromString("oacInvalidAnalysisPoint");
    if (ob==oacAnalysisPointNameExists) return PyString_FromString("oacAnalysisPointNameExists");
    if (ob==oacInvalidAnalysisOpPoint) return PyString_FromString("oacInvalidAnalysisOpPoint");
    if (ob==oacAnalysisOpPtOpPointNotInSameTech) return PyString_FromString("oacAnalysisOpPtOpPointNotInSameTech");
    if (ob==oacInvalidOpPointHeader) return PyString_FromString("oacInvalidOpPointHeader");
    if (ob==oacInvalidReducedModel) return PyString_FromString("oacInvalidReducedModel");
    if (ob==oacInvalidDriverTermType) return PyString_FromString("oacInvalidDriverTermType");
    if (ob==oacInvalidReceiverTermType) return PyString_FromString("oacInvalidReceiverTermType");
    if (ob==oacReceiverNetDoesNotMatchDriverNet) return PyString_FromString("oacReceiverNetDoesNotMatchDriverNet");
    if (ob==oacParasiticTermMustBeScalar) return PyString_FromString("oacParasiticTermMustBeScalar");
    if (ob==oacParasiticInstTermMustBeScalar) return PyString_FromString("oacParasiticInstTermMustBeScalar");
    if (ob==oacInvalidElmore) return PyString_FromString("oacInvalidElmore");
    if (ob==oacInvalidPoleResidue) return PyString_FromString("oacInvalidPoleResidue");
    if (ob==oacNotADetailedData) return PyString_FromString("oacNotADetailedData");
    if (ob==oacInvalidParasiticNetwork) return PyString_FromString("oacInvalidParasiticNetwork");
    if (ob==oacParasiticNetworkExists) return PyString_FromString("oacParasiticNetworkExists");
    if (ob==oacNoParasiticNetworkToLoad) return PyString_FromString("oacNoParasiticNetworkToLoad");
    if (ob==oacInvalidSubNetwork) return PyString_FromString("oacInvalidSubNetwork");
    if (ob==oacSubNetworkNameExists) return PyString_FromString("oacSubNetworkNameExists");
    if (ob==oacSubNetworkNodeNotSameDesign) return PyString_FromString("oacSubNetworkNodeNotSameDesign");
    if (ob==oacSubNetworkNodeNotSameNetwork) return PyString_FromString("oacSubNetworkNodeNotSameNetwork");
    if (ob==oacSubNetworkDeviceNotSameDesign) return PyString_FromString("oacSubNetworkDeviceNotSameDesign");
    if (ob==oacSubNetworkNotShapeOrVia) return PyString_FromString("oacSubNetworkNotShapeOrVia");
    if (ob==oacInvalidNode) return PyString_FromString("oacInvalidNode");
    if (ob==oacInvalidNodeConnType) return PyString_FromString("oacInvalidNodeConnType");
    if (ob==oacInvalidCouplingCapConnType) return PyString_FromString("oacInvalidCouplingCapConnType");
    if (ob==oacNodeNameExists) return PyString_FromString("oacNodeNameExists");
    if (ob==oacNodeIdExists) return PyString_FromString("oacNodeIdExists");
    if (ob==oacInvalidEndpointTypeName) return PyString_FromString("oacInvalidEndpointTypeName");
    if (ob==oacInvalidDevice) return PyString_FromString("oacInvalidDevice");
    if (ob==oacDeviceNameExists) return PyString_FromString("oacDeviceNameExists");
    if (ob==oacLocalDeviceIdExists) return PyString_FromString("oacLocalDeviceIdExists");
    if (ob==oacNonLocalDeviceIdExists) return PyString_FromString("oacNonLocalDeviceIdExists");
    if (ob==oacNodesNotInSameDesign) return PyString_FromString("oacNodesNotInSameDesign");
    if (ob==oacNodeNetNotInSameDesign) return PyString_FromString("oacNodeNetNotInSameDesign");
    if (ob==oacNodeConnNotInSameDesign) return PyString_FromString("oacNodeConnNotInSameDesign");
    if (ob==oacNodesNotInSameNetwork) return PyString_FromString("oacNodesNotInSameNetwork");
    if (ob==oacInductorsNotInSameDesign) return PyString_FromString("oacInductorsNotInSameDesign");
    if (ob==oacInductorNetNotInSameDesign) return PyString_FromString("oacInductorNetNotInSameDesign");
    if (ob==oacInductorsNotInSameNetwork) return PyString_FromString("oacInductorsNotInSameNetwork");
    if (ob==oacDeviceNotConnectedToNode) return PyString_FromString("oacDeviceNotConnectedToNode");
    if (ob==oacNoConnForLocalCouplingCaps) return PyString_FromString("oacNoConnForLocalCouplingCaps");
    if (ob==oacCouplingCapHasNoConn) return PyString_FromString("oacCouplingCapHasNoConn");
    if (ob==oacCoupledNodeWithoutId) return PyString_FromString("oacCoupledNodeWithoutId");
    if (ob==oacInvalidCouplingCapId) return PyString_FromString("oacInvalidCouplingCapId");
    if (ob==oacCoupledInductorWithoutId) return PyString_FromString("oacCoupledInductorWithoutId");
    if (ob==oacInvalidMutualInductorId) return PyString_FromString("oacInvalidMutualInductorId");
    if (ob==oacInvalidDesignDataTypeName) return PyString_FromString("oacInvalidDesignDataTypeName");
    if (ob==oacInvalidFontName) return PyString_FromString("oacInvalidFontName");
    if (ob==oacInvalidPlacementStatusTypeName) return PyString_FromString("oacInvalidPlacementStatusTypeName");
    if (ob==oacInvalidMarkerDeleteWhenTypeName) return PyString_FromString("oacInvalidMarkerDeleteWhenTypeName");
    if (ob==oacInvalidPathStyleName) return PyString_FromString("oacInvalidPathStyleName");
    if (ob==oacInvalidSigTypeName) return PyString_FromString("oacInvalidSigTypeName");
    if (ob==oacInvalidSourceName) return PyString_FromString("oacInvalidSourceName");
    if (ob==oacInvalidTextAlignName) return PyString_FromString("oacInvalidTextAlignName");
    if (ob==oacInvalidLayerHeader) return PyString_FromString("oacInvalidLayerHeader");
    if (ob==oacInvalidBlockage) return PyString_FromString("oacInvalidBlockage");
    if (ob==oacBlockageHasExtraPoints) return PyString_FromString("oacBlockageHasExtraPoints");
    if (ob==oacBlockageTooFewPoints) return PyString_FromString("oacBlockageTooFewPoints");
    if (ob==oacCannotCopyBlockageWithOwner) return PyString_FromString("oacCannotCopyBlockageWithOwner");
    if (ob==oacAreaHaloAlreadyExists) return PyString_FromString("oacAreaHaloAlreadyExists");
    if (ob==oacInvalidLayerForLayerBlockage) return PyString_FromString("oacInvalidLayerForLayerBlockage");
    if (ob==oacInvalidTypeForLayerBlockage) return PyString_FromString("oacInvalidTypeForLayerBlockage");
    if (ob==oacInvalidGuide) return PyString_FromString("oacInvalidGuide");
    if (ob==oacRouteOptimizerInternalError) return PyString_FromString("oacRouteOptimizerInternalError");
    if (ob==oacCMapInvalidGCellPattern) return PyString_FromString("oacCMapInvalidGCellPattern");
    if (ob==oacCMapInvalidGCellIndex) return PyString_FromString("oacCMapInvalidGCellIndex");
    if (ob==oacInvalidModule) return PyString_FromString("oacInvalidModule");
    if (ob==oacModuleExists) return PyString_FromString("oacModuleExists");
    if (ob==oacModuleNotDerived) return PyString_FromString("oacModuleNotDerived");
    if (ob==oacModuleNotDerivedFromModule) return PyString_FromString("oacModuleNotDerivedFromModule");
    if (ob==oacInvalidBlockDomainVisibilityName) return PyString_FromString("oacInvalidBlockDomainVisibilityName");
    if (ob==oacTopBlockAlreadyExists) return PyString_FromString("oacTopBlockAlreadyExists");
    if (ob==oacTopModuleAlreadyExists) return PyString_FromString("oacTopModuleAlreadyExists");
    if (ob==oacDesignIsBlockDomainSpecific) return PyString_FromString("oacDesignIsBlockDomainSpecific");
    if (ob==oacDesignIsModuleDomainSpecific) return PyString_FromString("oacDesignIsModuleDomainSpecific");
    if (ob==oacInvalidModInst) return PyString_FromString("oacInvalidModInst");
    if (ob==oacInvalidModDesignInst) return PyString_FromString("oacInvalidModDesignInst");
    if (ob==oacInvalidModModuleInst) return PyString_FromString("oacInvalidModModuleInst");
    if (ob==oacInvalidModInstHeader) return PyString_FromString("oacInvalidModInstHeader");
    if (ob==oacInvalidModModuleInstHeader) return PyString_FromString("oacInvalidModModuleInstHeader");
    if (ob==oacInvalidModNet) return PyString_FromString("oacInvalidModNet");
    if (ob==oacInvalidModTerm) return PyString_FromString("oacInvalidModTerm");
    if (ob==oacInvalidModInstTerm) return PyString_FromString("oacInvalidModInstTerm");
    if (ob==oacInvalidModBusNetDef) return PyString_FromString("oacInvalidModBusNetDef");
    if (ob==oacInvalidModBusTermDef) return PyString_FromString("oacInvalidModBusTermDef");
    if (ob==oacInvalidModVectorInstDef) return PyString_FromString("oacInvalidModVectorInstDef");
    if (ob==oacInvalidModConnectDef) return PyString_FromString("oacInvalidModConnectDef");
    if (ob==oacInvalidModAssignment) return PyString_FromString("oacInvalidModAssignment");
    if (ob==oacInvalidOccObject) return PyString_FromString("oacInvalidOccObject");
    if (ob==oacInvalidOccInst) return PyString_FromString("oacInvalidOccInst");
    if (ob==oacInvalidOccDesignInst) return PyString_FromString("oacInvalidOccDesignInst");
    if (ob==oacInvalidOccModuleInst) return PyString_FromString("oacInvalidOccModuleInst");
    if (ob==oacInvalidOccInstHeader) return PyString_FromString("oacInvalidOccInstHeader");
    if (ob==oacInvalidOccModuleInstHeader) return PyString_FromString("oacInvalidOccModuleInstHeader");
    if (ob==oacInvalidOccNet) return PyString_FromString("oacInvalidOccNet");
    if (ob==oacInvalidOccTerm) return PyString_FromString("oacInvalidOccTerm");
    if (ob==oacInvalidOccInstTerm) return PyString_FromString("oacInvalidOccInstTerm");
    if (ob==oacInvalidOccBusNetDef) return PyString_FromString("oacInvalidOccBusNetDef");
    if (ob==oacInvalidOccBusTermDef) return PyString_FromString("oacInvalidOccBusTermDef");
    if (ob==oacInvalidOccVectorInstDef) return PyString_FromString("oacInvalidOccVectorInstDef");
    if (ob==oacInvalidOccConnectDef) return PyString_FromString("oacInvalidOccConnectDef");
    if (ob==oacInvalidOccAssignment) return PyString_FromString("oacInvalidOccAssignment");
    if (ob==oacBusDefIsModuleDomainSpecific) return PyString_FromString("oacBusDefIsModuleDomainSpecific");
    if (ob==oacBusDefIsBlockDomainSpecific) return PyString_FromString("oacBusDefIsBlockDomainSpecific");
    if (ob==oacVectorDefIsModuleDomainSpecific) return PyString_FromString("oacVectorDefIsModuleDomainSpecific");
    if (ob==oacVectorDefIsBlockDomainSpecific) return PyString_FromString("oacVectorDefIsBlockDomainSpecific");
    if (ob==oacVectorDefInstMustBeModuleInst) return PyString_FromString("oacVectorDefInstMustBeModuleInst");
    if (ob==oacVectorDefInstMustBeDesignInst) return PyString_FromString("oacVectorDefInstMustBeDesignInst");
    if (ob==oacImplicitModuleNetExists) return PyString_FromString("oacImplicitModuleNetExists");
    if (ob==oacImplicitBlockNetExists) return PyString_FromString("oacImplicitBlockNetExists");
    if (ob==oacImplicitModuleTermExists) return PyString_FromString("oacImplicitModuleTermExists");
    if (ob==oacImplicitBlockTermExists) return PyString_FromString("oacImplicitBlockTermExists");
    if (ob==oacInvalidRowSpacingTypeName) return PyString_FromString("oacInvalidRowSpacingTypeName");
    if (ob==oacInvalidCoreRowFlipTypeName) return PyString_FromString("oacInvalidCoreRowFlipTypeName");
    if (ob==oacCoreBoxSpecNoSiteDef) return PyString_FromString("oacCoreBoxSpecNoSiteDef");
    if (ob==oacCoreBoxSpecInvalidRowNumber) return PyString_FromString("oacCoreBoxSpecInvalidRowNumber");
    if (ob==oacInvalidModuleNetIterFlags) return PyString_FromString("oacInvalidModuleNetIterFlags");
    if (ob==oacInvalidModuleTermIterFlags) return PyString_FromString("oacInvalidModuleTermIterFlags");
    if (ob==oacInvalidOccurrenceNetIterFlags) return PyString_FromString("oacInvalidOccurrenceNetIterFlags");
    if (ob==oacInvalidOccurrenceTermIterFlags) return PyString_FromString("oacInvalidOccurrenceTermIterFlags");
    if (ob==oacInvalidGroupByNameIterFlags) return PyString_FromString("oacInvalidGroupByNameIterFlags");
    if (ob==oacInvalidBlockageDensityValue) return PyString_FromString("oacInvalidBlockageDensityValue");
    if (ob==oacInvalidBlockageTypeForDensity) return PyString_FromString("oacInvalidBlockageTypeForDensity");
    if (ob==oacInvalidBlockageOwner) return PyString_FromString("oacInvalidBlockageOwner");
    if (ob==oacModulesNotInSameDesign) return PyString_FromString("oacModulesNotInSameDesign");
    if (ob==oacInvalidTopOccurrence) return PyString_FromString("oacInvalidTopOccurrence");
    if (ob==oacModuleAndOccurrenceNotInSameDesign) return PyString_FromString("oacModuleAndOccurrenceNotInSameDesign");
    if (ob==oacInvalidMarkerSeverityTypeName) return PyString_FromString("oacInvalidMarkerSeverityTypeName");
    if (ob==oacInvalidHierBundleNetName) return PyString_FromString("oacInvalidHierBundleNetName");
    if (ob==oacNetAndInstNotInSameModule) return PyString_FromString("oacNetAndInstNotInSameModule");
    if (ob==oacInvalidHierInstName) return PyString_FromString("oacInvalidHierInstName");
    if (ob==oacInvalidHierNetName) return PyString_FromString("oacInvalidHierNetName");
    if (ob==oacInvalidHierTermName) return PyString_FromString("oacInvalidHierTermName");
    if (ob==oacCannotMoveDerivedBlockage) return PyString_FromString("oacCannotMoveDerivedBlockage");
    if (ob==oacCannotCopyDerivedBlockage) return PyString_FromString("oacCannotCopyDerivedBlockage");
    if (ob==oacInvalidReducedModelDomain) return PyString_FromString("oacInvalidReducedModelDomain");
    if (ob==oacInvalidReducedModelObjectType) return PyString_FromString("oacInvalidReducedModelObjectType");
    if (ob==oacDriverReceiverNotInSameDomain) return PyString_FromString("oacDriverReceiverNotInSameDomain");
    if (ob==oacObjectNetworkNotInSameDomain) return PyString_FromString("oacObjectNetworkNotInSameDomain");
    if (ob==oacDeviceNetNotInSameDomain) return PyString_FromString("oacDeviceNetNotInSameDomain");
    if (ob==oacNetworkConnNotInSameDomain) return PyString_FromString("oacNetworkConnNotInSameDomain");
    if (ob==oacConnNodeNotInSameDomain) return PyString_FromString("oacConnNodeNotInSameDomain");
    if (ob==oacObjectAlreadyOnMarker) return PyString_FromString("oacObjectAlreadyOnMarker");
    if (ob==oacMoveToNetNotInSameDesign) return PyString_FromString("oacMoveToNetNotInSameDesign");
    if (ob==oacNetEquivNetNotInSameDesign) return PyString_FromString("oacNetEquivNetNotInSameDesign");
    if (ob==oacInvalidModuleEmbedMaster) return PyString_FromString("oacInvalidModuleEmbedMaster");
    if (ob==oacModuleDetachDesignExists) return PyString_FromString("oacModuleDetachDesignExists");
    if (ob==oacInvalidVia) return PyString_FromString("oacInvalidVia");
    if (ob==oacCannotAddViaToNonBitNet) return PyString_FromString("oacCannotAddViaToNonBitNet");
    if (ob==oacInvalidEndStyleName) return PyString_FromString("oacInvalidEndStyleName");
    if (ob==oacInvalidSegStyleBeginExtValue) return PyString_FromString("oacInvalidSegStyleBeginExtValue");
    if (ob==oacInvalidSegStyleEndExtValue) return PyString_FromString("oacInvalidSegStyleEndExtValue");
    if (ob==oacInvalidPathSegPoints) return PyString_FromString("oacInvalidPathSegPoints");
    if (ob==oacInvalidPathSegTransformAngle) return PyString_FromString("oacInvalidPathSegTransformAngle");
    if (ob==oacCannotSetBlockageOwner) return PyString_FromString("oacCannotSetBlockageOwner");
    if (ob==oacCannotSetBlockagePushedDown) return PyString_FromString("oacCannotSetBlockagePushedDown");
    if (ob==oacInvalidRef) return PyString_FromString("oacInvalidRef");
    if (ob==oacInvalidRefHeader) return PyString_FromString("oacInvalidRefHeader");
    if (ob==oacCannotModifyImplicitRef) return PyString_FromString("oacCannotModifyImplicitRef");
    if (ob==oacInvalidOccShape) return PyString_FromString("oacInvalidOccShape");
    if (ob==oacInvalidViaDirectionTypeName) return PyString_FromString("oacInvalidViaDirectionTypeName");
    if (ob==oacParamsSuppliedForNonPCellViaMaster) return PyString_FromString("oacParamsSuppliedForNonPCellViaMaster");
    if (ob==oacParamsSuppliedForNonPCellInstMaster) return PyString_FromString("oacParamsSuppliedForNonPCellInstMaster");
    if (ob==oacCannotRemoveRouteFigFromNet) return PyString_FromString("oacCannotRemoveRouteFigFromNet");
    if (ob==oacCannotAddRouteFigToNet) return PyString_FromString("oacCannotAddRouteFigToNet");
    if (ob==oacCannotAddPinFigToNet) return PyString_FromString("oacCannotAddPinFigToNet");
    if (ob==oacCannotAddInstToNet) return PyString_FromString("oacCannotAddInstToNet");
    if (ob==oacCannotAddRouteFigToPin) return PyString_FromString("oacCannotAddRouteFigToPin");
    if (ob==oacCannotAddNetFigToPin) return PyString_FromString("oacCannotAddNetFigToPin");
    if (ob==oacCannotAddPinFigToRoute) return PyString_FromString("oacCannotAddPinFigToRoute");
    if (ob==oacRouteAndObjectNotInSameBlock) return PyString_FromString("oacRouteAndObjectNotInSameBlock");
    if (ob==oacCannotAddRouteConnFigToRoute) return PyString_FromString("oacCannotAddRouteConnFigToRoute");
    if (ob==oacCannotAddFigToRouteOnDifferentNet) return PyString_FromString("oacCannotAddFigToRouteOnDifferentNet");
    if (ob==oacCannotAddSameFigToRouteAgain) return PyString_FromString("oacCannotAddSameFigToRouteAgain");
    if (ob==oacPinAndFigNotInSameBlock) return PyString_FromString("oacPinAndFigNotInSameBlock");
    if (ob==oacInvalidStdViaMaster) return PyString_FromString("oacInvalidStdViaMaster");
    if (ob==oacInvalidHierPath) return PyString_FromString("oacInvalidHierPath");
    if (ob==oacCannotLockDatabase) return PyString_FromString("oacCannotLockDatabase");
    if (ob==oacCannotFindSpecAssignedDefOccNet) return PyString_FromString("oacCannotFindSpecAssignedDefOccNet");
    if (ob==oacCannotFindSpecAssignedOccNet) return PyString_FromString("oacCannotFindSpecAssignedOccNet");
    if (ob==oacCannotCreateBlockageWithImplicitInst) return PyString_FromString("oacCannotCreateBlockageWithImplicitInst");
    if (ob==oacCannotAddBlockageToImplicitInst) return PyString_FromString("oacCannotAddBlockageToImplicitInst");
    if (ob==oacDesignCannotGetReadAccess) return PyString_FromString("oacDesignCannotGetReadAccess");
    if (ob==oacDesignCannotGetWriteAccess) return PyString_FromString("oacDesignCannotGetWriteAccess");
    if (ob==oacDesignHasReadNeedWriteAccess) return PyString_FromString("oacDesignHasReadNeedWriteAccess");
    if (ob==oacParasiticsDataCannotGetReadAccess) return PyString_FromString("oacParasiticsDataCannotGetReadAccess");
    if (ob==oacParasiticsDataCannotGetWriteAccess) return PyString_FromString("oacParasiticsDataCannotGetWriteAccess");
    if (ob==oacParasiticsDataHasReadNeedWriteAccess) return PyString_FromString("oacParasiticsDataHasReadNeedWriteAccess");
    if (ob==oacParasiticNetworkPartitionNameExists) return PyString_FromString("oacParasiticNetworkPartitionNameExists");
    if (ob==oacParasiticNetworkPartialLoaded) return PyString_FromString("oacParasiticNetworkPartialLoaded");
    if (ob==oacCustomEndStyleNotAllowed) return PyString_FromString("oacCustomEndStyleNotAllowed");
    if (ob==oacEvenWidthRequiredForSegStyle) return PyString_FromString("oacEvenWidthRequiredForSegStyle");
    if (ob==oacCustomEndStyleNotAllowedForBegin) return PyString_FromString("oacCustomEndStyleNotAllowedForBegin");
    if (ob==oacOnlyCustomEndStyleAllowedForEnd) return PyString_FromString("oacOnlyCustomEndStyleAllowedForEnd");
    if (ob==oacCustomEndStyleNotAllowedForEnd) return PyString_FromString("oacCustomEndStyleNotAllowedForEnd");
    if (ob==oacOnlyCustomEndStyleAllowedForBegin) return PyString_FromString("oacOnlyCustomEndStyleAllowedForBegin");
    if (ob==oacOnlyCustomEndStylesAllowed) return PyString_FromString("oacOnlyCustomEndStylesAllowed");
    if (ob==oacCannotChangeWidthForBothCustomEnds) return PyString_FromString("oacCannotChangeWidthForBothCustomEnds");
    if (ob==oacUndoNotEnabled) return PyString_FromString("oacUndoNotEnabled");
    if (ob==oacRegionQueryAlreadyInitialized) return PyString_FromString("oacRegionQueryAlreadyInitialized");
    if (ob==oacRegionQueryNotInitialized) return PyString_FromString("oacRegionQueryNotInitialized");
    if (ob==oacRegionQueryFailedToGetPlugIn) return PyString_FromString("oacRegionQueryFailedToGetPlugIn");
    if (ob==oacInvalidDesignObject) return PyString_FromString("oacInvalidDesignObject");
    if (ob==oacRowZeroNumSitesNotAllowed) return PyString_FromString("oacRowZeroNumSitesNotAllowed");
    if (ob==oacModuleDetachRequiresUndoToBeDisabled) return PyString_FromString("oacModuleDetachRequiresUndoToBeDisabled");
    if (ob==oacOccDestroyRequiresUndoToBeDisabled) return PyString_FromString("oacOccDestroyRequiresUndoToBeDisabled");
    if (ob==oacDriverAnalysisPointNotInSameDesign) return PyString_FromString("oacDriverAnalysisPointNotInSameDesign");
    if (ob==oacDriverReceiverNotInSameDesign) return PyString_FromString("oacDriverReceiverNotInSameDesign");
    if (ob==oacInvalidNodeIdSpecified) return PyString_FromString("oacInvalidNodeIdSpecified");
    if (ob==oacInvalidDeviceIdSpecified) return PyString_FromString("oacInvalidDeviceIdSpecified");
    if (ob==oacDesignHasNoTopBlock) return PyString_FromString("oacDesignHasNoTopBlock");
    if (ob==oacAncestorNodeWithoutId) return PyString_FromString("oacAncestorNodeWithoutId");
    if (ob==oacAncestorInductorWithoutId) return PyString_FromString("oacAncestorInductorWithoutId");
    if (ob==oacNodesNotInRelatedPartitions) return PyString_FromString("oacNodesNotInRelatedPartitions");
    if (ob==oacInductorsNotInRelatedPartitions) return PyString_FromString("oacInductorsNotInRelatedPartitions");
    if (ob==oacViaDefNotInTechAssociatedWithDesign) return PyString_FromString("oacViaDefNotInTechAssociatedWithDesign");
    if (ob==oacSiteDefNotInTechAssociatedWithDesign) return PyString_FromString("oacSiteDefNotInTechAssociatedWithDesign");
    if (ob==oacObsoleteDesignMsg1493) return PyString_FromString("oacObsoleteDesignMsg1493");
    if (ob==oacScriptEngineLinkExists) return PyString_FromString("oacScriptEngineLinkExists");
    if (ob==oacPcellEvaluatorNotFound) return PyString_FromString("oacPcellEvaluatorNotFound");
    if (ob==oacCannotCopyPcellInst) return PyString_FromString("oacCannotCopyPcellInst");
    if (ob==oacCannotMovePcellInst) return PyString_FromString("oacCannotMovePcellInst");
    if (ob==oacCannotSetConnStatusImplicitNet) return PyString_FromString("oacCannotSetConnStatusImplicitNet");
    if (ob==oacCannotSetOriginalNetImplicitNet) return PyString_FromString("oacCannotSetOriginalNetImplicitNet");
    if (ob==oacImplicitNetCannotBeOriginalNet) return PyString_FromString("oacImplicitNetCannotBeOriginalNet");
    if (ob==oacCannotSetVoltageImplicitNet) return PyString_FromString("oacCannotSetVoltageImplicitNet");
    if (ob==oacCannotSetRoutePattenImplicitNet) return PyString_FromString("oacCannotSetRoutePattenImplicitNet");
    if (ob==oacCannotShieldImplicitNet) return PyString_FromString("oacCannotShieldImplicitNet");
    if (ob==oacImplicitNetCannotShieldNet) return PyString_FromString("oacImplicitNetCannotShieldNet");
    if (ob==oacNetSetBaseNameConflictsInTerms) return PyString_FromString("oacNetSetBaseNameConflictsInTerms");
    if (ob==oacNetSetBaseNameConflictsInInstTerms) return PyString_FromString("oacNetSetBaseNameConflictsInInstTerms");
    if (ob==oacNetSetRangeConflictsWithOtherNets) return PyString_FromString("oacNetSetRangeConflictsWithOtherNets");
    if (ob==oacCannotRenameToImplicitBusNet) return PyString_FromString("oacCannotRenameToImplicitBusNet");
    if (ob==oacCannotRenameToImplicitBusTerm) return PyString_FromString("oacCannotRenameToImplicitBusTerm");
    if (ob==oacCannotCreateBlockOnlyInModuleDesign) return PyString_FromString("oacCannotCreateBlockOnlyInModuleDesign");
    if (ob==oacInvalidScanChainObject) return PyString_FromString("oacInvalidScanChainObject");
    if (ob==oacInvalidInstTermBitIndex) return PyString_FromString("oacInvalidInstTermBitIndex");
    if (ob==oacInstTermNetMismatchInRepeatedMembers) return PyString_FromString("oacInstTermNetMismatchInRepeatedMembers");
    if (ob==oacInvalidNetName) return PyString_FromString("oacInvalidNetName");
    if (ob==oacInvalidTermName) return PyString_FromString("oacInvalidTermName");
    if (ob==oacCannotHideImplicitInstTerm) return PyString_FromString("oacCannotHideImplicitInstTerm");
    if (ob==oacCannotHideBlockOnlyInstTerm) return PyString_FromString("oacCannotHideBlockOnlyInstTerm");
    if (ob==oacCannotDestroyImplicitTerm) return PyString_FromString("oacCannotDestroyImplicitTerm");
    if (ob==oacInvalidNodeConnNet) return PyString_FromString("oacInvalidNodeConnNet");
    if (ob==oacCannotChangeUndoModel) return PyString_FromString("oacCannotChangeUndoModel");
    if (ob==oacCannotUnsetNonEmptyCp) return PyString_FromString("oacCannotUnsetNonEmptyCp");
    if (ob==oacCannotUndoWithoutCpInPostModel) return PyString_FromString("oacCannotUndoWithoutCpInPostModel");
    if (ob==oacInstTermBatchCreateHasInstTerms) return PyString_FromString("oacInstTermBatchCreateHasInstTerms");
    if (ob==oacInvalidGlobalNet) return PyString_FromString("oacInvalidGlobalNet");
    if (ob==oacInvalidFigGroup) return PyString_FromString("oacInvalidFigGroup");
    if (ob==oacInvalidFigGroupStatusTypeName) return PyString_FromString("oacInvalidFigGroupStatusTypeName");
    if (ob==oacFigAlreadyInFigGroup) return PyString_FromString("oacFigAlreadyInFigGroup");
    if (ob==oacFigGroupNameExists) return PyString_FromString("oacFigGroupNameExists");
    if (ob==oacInvalidFigGroupTypeForMemberMove) return PyString_FromString("oacInvalidFigGroupTypeForMemberMove");
    if (ob==oacFigGroupMemberNotInSameFigGroup) return PyString_FromString("oacFigGroupMemberNotInSameFigGroup");
    if (ob==oacFigGroupMemberNotInSameDB) return PyString_FromString("oacFigGroupMemberNotInSameDB");
    if (ob==oacFigGroupCircularMembership) return PyString_FromString("oacFigGroupCircularMembership");
    if (ob==oacConstraintGroupNotInTechAssociatedWithDesign) return PyString_FromString("oacConstraintGroupNotInTechAssociatedWithDesign");
    if (ob==oacInvalidBuiltInTechConstraintGroupInDesign) return PyString_FromString("oacInvalidBuiltInTechConstraintGroupInDesign");
    if (ob==oacInvalidDefaultTechConstraintGroupInDesign) return PyString_FromString("oacInvalidDefaultTechConstraintGroupInDesign");
    if (ob==oacBindViaToIncorrectViaDefOnCopy) return PyString_FromString("oacBindViaToIncorrectViaDefOnCopy");
    if (ob==oacBindViaToIncorrectViaDefOnMove) return PyString_FromString("oacBindViaToIncorrectViaDefOnMove");
    if (ob==oacBindRowToIncorrectSiteDefOnCopy) return PyString_FromString("oacBindRowToIncorrectSiteDefOnCopy");
    if (ob==oacBindRowToIncorrectSiteDefOnMove) return PyString_FromString("oacBindRowToIncorrectSiteDefOnMove");
    if (ob==oacConflictingSiteDefsInTechAssociatedWithDesign) return PyString_FromString("oacConflictingSiteDefsInTechAssociatedWithDesign");
    if (ob==oacConflictingViaDefsInTechAssociatedWithDesign) return PyString_FromString("oacConflictingViaDefsInTechAssociatedWithDesign");
    if (ob==oacConflictingOpPointsInTechAssociatedWithDesign) return PyString_FromString("oacConflictingOpPointsInTechAssociatedWithDesign");
    if (ob==oacTextLinkAlreadyInitialized) return PyString_FromString("oacTextLinkAlreadyInitialized");
    if (ob==oacFailedToGetTextPlugIn) return PyString_FromString("oacFailedToGetTextPlugIn");
    if (ob==oacFailedToInitTextPlugIn) return PyString_FromString("oacFailedToInitTextPlugIn");
    if (ob==oacCannotUnsetGlobalStateOfNetInTopModule) return PyString_FromString("oacCannotUnsetGlobalStateOfNetInTopModule");
    if (ob==oacTermHasNoMustJoinTerm) return PyString_FromString("oacTermHasNoMustJoinTerm");
    if (ob==oacInvalidFigGroupMem) return PyString_FromString("oacInvalidFigGroupMem");
    if (ob==oacInvalidFig) return PyString_FromString("oacInvalidFig");
    if (ob==oacInvalidBlockObject) return PyString_FromString("oacInvalidBlockObject");
    if (ob==oacCannotUndoUniquify) return PyString_FromString("oacCannotUndoUniquify");
    if (ob==oacCannotCopyMoveUnboundViaToStrangerDesign) return PyString_FromString("oacCannotCopyMoveUnboundViaToStrangerDesign");
    if (ob==oacCannotCopyMoveUnboundRowToStrangerDesign) return PyString_FromString("oacCannotCopyMoveUnboundRowToStrangerDesign");
    if (ob==oacCorruptedMustJoinTerms) return PyString_FromString("oacCorruptedMustJoinTerms");
    if (ob==oacCorruptedSupplySensitivityTerms) return PyString_FromString("oacCorruptedSupplySensitivityTerms");
    if (ob==oacCorruptedGroundSensitivityTerms) return PyString_FromString("oacCorruptedGroundSensitivityTerms");
    if (ob==oacCorruptedSteinerConnRoutes) return PyString_FromString("oacCorruptedSteinerConnRoutes");
    if (ob==oacPaddingForLaterDMRelease1) return PyString_FromString("oacPaddingForLaterDMRelease1");
    if (ob==oacPaddingForLaterDMRelease2) return PyString_FromString("oacPaddingForLaterDMRelease2");
    if (ob==oacPaddingForLaterDMRelease3) return PyString_FromString("oacPaddingForLaterDMRelease3");
    if (ob==oacPaddingForLaterDMRelease4) return PyString_FromString("oacPaddingForLaterDMRelease4");
    if (ob==oacPaddingForLaterDMRelease5) return PyString_FromString("oacPaddingForLaterDMRelease5");
    if (ob==oacPaddingForLaterDMRelease6) return PyString_FromString("oacPaddingForLaterDMRelease6");
    if (ob==oacPaddingForLaterDMRelease7) return PyString_FromString("oacPaddingForLaterDMRelease7");
    if (ob==oacPaddingForLaterDMRelease8) return PyString_FromString("oacPaddingForLaterDMRelease8");
    if (ob==oacPaddingForLaterDMRelease9) return PyString_FromString("oacPaddingForLaterDMRelease9");
    if (ob==oacPaddingForLaterDMRelease10) return PyString_FromString("oacPaddingForLaterDMRelease10");
    if (ob==oacPaddingForLaterDMRelease11) return PyString_FromString("oacPaddingForLaterDMRelease11");
    if (ob==oacPaddingForLaterDMRelease12) return PyString_FromString("oacPaddingForLaterDMRelease12");
    if (ob==oacPaddingForLaterDMRelease13) return PyString_FromString("oacPaddingForLaterDMRelease13");
    if (ob==oacPaddingForLaterDMRelease14) return PyString_FromString("oacPaddingForLaterDMRelease14");
    if (ob==oacPaddingForLaterDMRelease15) return PyString_FromString("oacPaddingForLaterDMRelease15");
    if (ob==oacInstTermAlreadyInScanChain) return PyString_FromString("oacInstTermAlreadyInScanChain");
    if (ob==oacScanChainInstTermsNotOnSameInst) return PyString_FromString("oacScanChainInstTermsNotOnSameInst");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaDesignMsgIds_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaDesignMsgIds e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaDesignMsgIds_FromoaDesignMsgIds(oaDesignMsgIds(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaDesignMsgIds_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaDesignMsgIds_doc[] =
"Type convert function for enum: oaDesignMsgIds";
                               
static PyMethodDef PyoaDesignMsgIds_method =
  {"oaDesignMsgIds",(PyCFunction)PyoaDesignMsgIds_TypeFunction,METH_VARARGS,oaDesignMsgIds_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaDesignMsgIds_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacInvalidDesign");
    PyDict_SetItemString(mod_dict,"oacInvalidDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNotADesign");
    PyDict_SetItemString(mod_dict,"oacNotADesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSaveReadOnlyDesign");
    PyDict_SetItemString(mod_dict,"oacSaveReadOnlyDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSaveScratchModeDesign");
    PyDict_SetItemString(mod_dict,"oacSaveScratchModeDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOpenUndefinedModeDesign");
    PyDict_SetItemString(mod_dict,"oacOpenUndefinedModeDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotFindDesign");
    PyDict_SetItemString(mod_dict,"oacCannotFindDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDesignPrimaryFileDoesNotExist");
    PyDict_SetItemString(mod_dict,"oacDesignPrimaryFileDoesNotExist",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDesignFollowerFileDoesNotExist");
    PyDict_SetItemString(mod_dict,"oacDesignFollowerFileDoesNotExist",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDetailedParasiticsFileDoesNotExist");
    PyDict_SetItemString(mod_dict,"oacDetailedParasiticsFileDoesNotExist",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetModeToScratch");
    PyDict_SetItemString(mod_dict,"oacCannotSetModeToScratch",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotChangeFromScratchMode");
    PyDict_SetItemString(mod_dict,"oacCannotChangeFromScratchMode",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotModifyReadModeDesign");
    PyDict_SetItemString(mod_dict,"oacCannotModifyReadModeDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOpenOnDesignBeingPurged");
    PyDict_SetItemString(mod_dict,"oacOpenOnDesignBeingPurged",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPurgeOnDesignBeingPurged");
    PyDict_SetItemString(mod_dict,"oacPurgeOnDesignBeingPurged",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDesignViewType");
    PyDict_SetItemString(mod_dict,"oacInvalidDesignViewType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacMismatchViewTypeForOpen");
    PyDict_SetItemString(mod_dict,"oacMismatchViewTypeForOpen",value);
    Py_DECREF(value);
    value=PyString_FromString("oacObsoleteDesignMsg1016");
    PyDict_SetItemString(mod_dict,"oacObsoleteDesignMsg1016",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDestroyDesignOpen");
    PyDict_SetItemString(mod_dict,"oacDestroyDesignOpen",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDestroyCannotFindDesign");
    PyDict_SetItemString(mod_dict,"oacDestroyCannotFindDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidCellTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidCellTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDesignAttrTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidDesignAttrTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidSymmetryName");
    PyDict_SetItemString(mod_dict,"oacInvalidSymmetryName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotFindTechForDesign");
    PyDict_SetItemString(mod_dict,"oacCannotFindTechForDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotFindObjectForViaMaster");
    PyDict_SetItemString(mod_dict,"oacCannotFindObjectForViaMaster",value);
    Py_DECREF(value);
    value=PyString_FromString("oacObsoleteDesignMsg1024");
    PyDict_SetItemString(mod_dict,"oacObsoleteDesignMsg1024",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotFindLibrary");
    PyDict_SetItemString(mod_dict,"oacCannotFindLibrary",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidRouteStatusTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidRouteStatusTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidBlock");
    PyDict_SetItemString(mod_dict,"oacInvalidBlock",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidOccurrence");
    PyDict_SetItemString(mod_dict,"oacInvalidOccurrence",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidShape");
    PyDict_SetItemString(mod_dict,"oacInvalidShape",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidPath");
    PyDict_SetItemString(mod_dict,"oacInvalidPath",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidPolygon");
    PyDict_SetItemString(mod_dict,"oacInvalidPolygon",value);
    Py_DECREF(value);
    value=PyString_FromString("oacArcEllipseBBoxInvalid");
    PyDict_SetItemString(mod_dict,"oacArcEllipseBBoxInvalid",value);
    Py_DECREF(value);
    value=PyString_FromString("oacArcAnglesInvalid");
    PyDict_SetItemString(mod_dict,"oacArcAnglesInvalid",value);
    Py_DECREF(value);
    value=PyString_FromString("oacArcPointsColinear");
    PyDict_SetItemString(mod_dict,"oacArcPointsColinear",value);
    Py_DECREF(value);
    value=PyString_FromString("oacArcTooLarge");
    PyDict_SetItemString(mod_dict,"oacArcTooLarge",value);
    Py_DECREF(value);
    value=PyString_FromString("oacArcWrongNumIntercepts");
    PyDict_SetItemString(mod_dict,"oacArcWrongNumIntercepts",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDonutRadiiInvalid");
    PyDict_SetItemString(mod_dict,"oacDonutRadiiInvalid",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDonutNumSidesInvalid");
    PyDict_SetItemString(mod_dict,"oacDonutNumSidesInvalid",value);
    Py_DECREF(value);
    value=PyString_FromString("oacEllipseBBoxInvalid");
    PyDict_SetItemString(mod_dict,"oacEllipseBBoxInvalid",value);
    Py_DECREF(value);
    value=PyString_FromString("oacEllipseNumSidesInvalid");
    PyDict_SetItemString(mod_dict,"oacEllipseNumSidesInvalid",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidPathExtensionValue");
    PyDict_SetItemString(mod_dict,"oacInvalidPathExtensionValue",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPathHasExtraPoints");
    PyDict_SetItemString(mod_dict,"oacPathHasExtraPoints",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPathTooFewPoints");
    PyDict_SetItemString(mod_dict,"oacPathTooFewPoints",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPolygonHasExtraPoints");
    PyDict_SetItemString(mod_dict,"oacPolygonHasExtraPoints",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPolygonTooFewPoints");
    PyDict_SetItemString(mod_dict,"oacPolygonTooFewPoints",value);
    Py_DECREF(value);
    value=PyString_FromString("oacRectBBoxInvalid");
    PyDict_SetItemString(mod_dict,"oacRectBBoxInvalid",value);
    Py_DECREF(value);
    value=PyString_FromString("oacArcNumSidesInvalid");
    PyDict_SetItemString(mod_dict,"oacArcNumSidesInvalid",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLineTooFewPoints");
    PyDict_SetItemString(mod_dict,"oacLineTooFewPoints",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotConvertPolygonToRect");
    PyDict_SetItemString(mod_dict,"oacCannotConvertPolygonToRect",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNetFigNotInSameBlock");
    PyDict_SetItemString(mod_dict,"oacNetFigNotInSameBlock",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNetEquivNetNotInSameBlock");
    PyDict_SetItemString(mod_dict,"oacNetEquivNetNotInSameBlock",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNetAndInstNotInSameDesign");
    PyDict_SetItemString(mod_dict,"oacNetAndInstNotInSameDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTransferNetsNotInSameBlock");
    PyDict_SetItemString(mod_dict,"oacTransferNetsNotInSameBlock",value);
    Py_DECREF(value);
    value=PyString_FromString("oacMergeNetsNotInSameBlock");
    PyDict_SetItemString(mod_dict,"oacMergeNetsNotInSameBlock",value);
    Py_DECREF(value);
    value=PyString_FromString("oacMoveToNetNotInSameBlock");
    PyDict_SetItemString(mod_dict,"oacMoveToNetNotInSameBlock",value);
    Py_DECREF(value);
    value=PyString_FromString("oacShieldNetNotInSameBlock");
    PyDict_SetItemString(mod_dict,"oacShieldNetNotInSameBlock",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOriginalNetNotInSameBlock");
    PyDict_SetItemString(mod_dict,"oacOriginalNetNotInSameBlock",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPinTermNotInSameBlock");
    PyDict_SetItemString(mod_dict,"oacPinTermNotInSameBlock",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidBlockNetIterFlags");
    PyDict_SetItemString(mod_dict,"oacInvalidBlockNetIterFlags",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidBlockTermIterFlags");
    PyDict_SetItemString(mod_dict,"oacInvalidBlockTermIterFlags",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidInst");
    PyDict_SetItemString(mod_dict,"oacInvalidInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidInstAttrTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidInstAttrTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstNameOverlapsOtherInst");
    PyDict_SetItemString(mod_dict,"oacInstNameOverlapsOtherInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacVectorInstNameMatchesAutoName");
    PyDict_SetItemString(mod_dict,"oacVectorInstNameMatchesAutoName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacVectorInstBitNameMatchesAutoName");
    PyDict_SetItemString(mod_dict,"oacVectorInstBitNameMatchesAutoName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstNameExists");
    PyDict_SetItemString(mod_dict,"oacInstNameExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidArrayInstRows");
    PyDict_SetItemString(mod_dict,"oacInvalidArrayInstRows",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidArrayInstCols");
    PyDict_SetItemString(mod_dict,"oacInvalidArrayInstCols",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetNameOfImplicitInst");
    PyDict_SetItemString(mod_dict,"oacCannotSetNameOfImplicitInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotDestroyImplicitInst");
    PyDict_SetItemString(mod_dict,"oacCannotDestroyImplicitInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetMasterImplicitInst");
    PyDict_SetItemString(mod_dict,"oacCannotSetMasterImplicitInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetParamsImplicitInst");
    PyDict_SetItemString(mod_dict,"oacCannotSetParamsImplicitInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetPlacementStatusImplicitInst");
    PyDict_SetItemString(mod_dict,"oacCannotSetPlacementStatusImplicitInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetPriorityImplicitInst");
    PyDict_SetItemString(mod_dict,"oacCannotSetPriorityImplicitInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetSourceImplicitInst");
    PyDict_SetItemString(mod_dict,"oacCannotSetSourceImplicitInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetUsageImplicitInst");
    PyDict_SetItemString(mod_dict,"oacCannotSetUsageImplicitInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotClusterImplicitInst");
    PyDict_SetItemString(mod_dict,"oacCannotClusterImplicitInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotScalarizeImplicitInst");
    PyDict_SetItemString(mod_dict,"oacCannotScalarizeImplicitInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotMoveImplicitInst");
    PyDict_SetItemString(mod_dict,"oacCannotMoveImplicitInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotCopyImplicitInst");
    PyDict_SetItemString(mod_dict,"oacCannotCopyImplicitInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotGetImplicitInstOccurrence");
    PyDict_SetItemString(mod_dict,"oacCannotGetImplicitInstOccurrence",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotGetVectorInstOccurrence");
    PyDict_SetItemString(mod_dict,"oacCannotGetVectorInstOccurrence",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidBitIndexIntoInst");
    PyDict_SetItemString(mod_dict,"oacInvalidBitIndexIntoInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstMustBeInUniqueOccHier");
    PyDict_SetItemString(mod_dict,"oacInstMustBeInUniqueOccHier",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidVectorInstDef");
    PyDict_SetItemString(mod_dict,"oacInvalidVectorInstDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotDestroyImplicitVectorInstDef");
    PyDict_SetItemString(mod_dict,"oacCannotDestroyImplicitVectorInstDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacVectorInstDefAlreadyExists");
    PyDict_SetItemString(mod_dict,"oacVectorInstDefAlreadyExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBitOrderVectorInstDefImplicit");
    PyDict_SetItemString(mod_dict,"oacBitOrderVectorInstDefImplicit",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotDestroyVectorInstDefWithInsts");
    PyDict_SetItemString(mod_dict,"oacCannotDestroyVectorInstDefWithInsts",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidNetIndex");
    PyDict_SetItemString(mod_dict,"oacInvalidNetIndex",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidNetPriority");
    PyDict_SetItemString(mod_dict,"oacInvalidNetPriority",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidNet");
    PyDict_SetItemString(mod_dict,"oacInvalidNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidRoutePatternTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidRoutePatternTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidNetAttrTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidNetAttrTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidConnStatusName");
    PyDict_SetItemString(mod_dict,"oacInvalidConnStatusName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidParasiticConfidenceValue");
    PyDict_SetItemString(mod_dict,"oacInvalidParasiticConfidenceValue",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBusNetNameMatchesAutoName");
    PyDict_SetItemString(mod_dict,"oacBusNetNameMatchesAutoName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNetExists");
    PyDict_SetItemString(mod_dict,"oacNetExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacScalarNetNameMatchesBusBaseName");
    PyDict_SetItemString(mod_dict,"oacScalarNetNameMatchesBusBaseName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBusNetBaseNameMatchesScalarName");
    PyDict_SetItemString(mod_dict,"oacBusNetBaseNameMatchesScalarName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidBundleNetMemberIndex");
    PyDict_SetItemString(mod_dict,"oacInvalidBundleNetMemberIndex",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidBusNetBitIndex");
    PyDict_SetItemString(mod_dict,"oacInvalidBusNetBitIndex",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetNameOfImplicitNet");
    PyDict_SetItemString(mod_dict,"oacCannotSetNameOfImplicitNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetNameOfNetInBundleNet");
    PyDict_SetItemString(mod_dict,"oacCannotSetNameOfNetInBundleNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetParasiticConfImplicitNet");
    PyDict_SetItemString(mod_dict,"oacCannotSetParasiticConfImplicitNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotScalarizeImplicitNet");
    PyDict_SetItemString(mod_dict,"oacCannotScalarizeImplicitNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetRangeOfImplicitBus");
    PyDict_SetItemString(mod_dict,"oacCannotSetRangeOfImplicitBus",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetRangeOfBusInBundleNet");
    PyDict_SetItemString(mod_dict,"oacCannotSetRangeOfBusInBundleNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotAddFigToImplicitNet");
    PyDict_SetItemString(mod_dict,"oacCannotAddFigToImplicitNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotDestroyImplicitNet");
    PyDict_SetItemString(mod_dict,"oacCannotDestroyImplicitNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotDestroyNetInNonUniqueSpan");
    PyDict_SetItemString(mod_dict,"oacCannotDestroyNetInNonUniqueSpan",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNetHasNoEquivNet");
    PyDict_SetItemString(mod_dict,"oacNetHasNoEquivNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotTransferNetWithTerm");
    PyDict_SetItemString(mod_dict,"oacCannotTransferNetWithTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotTransferNetWithInstTerm");
    PyDict_SetItemString(mod_dict,"oacCannotTransferNetWithInstTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotMergeNetsWithDiffNumBits");
    PyDict_SetItemString(mod_dict,"oacCannotMergeNetsWithDiffNumBits",value);
    Py_DECREF(value);
    value=PyString_FromString("oacMergeNetsMustBeInUniqueOccHier");
    PyDict_SetItemString(mod_dict,"oacMergeNetsMustBeInUniqueOccHier",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTransferNetsMustBeInUniqueOccHier");
    PyDict_SetItemString(mod_dict,"oacTransferNetsMustBeInUniqueOccHier",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidTermIndex");
    PyDict_SetItemString(mod_dict,"oacInvalidTermIndex",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidTermTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidTermTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidRouteMethodName");
    PyDict_SetItemString(mod_dict,"oacInvalidRouteMethodName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidTermAttrTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidTermAttrTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidTerm");
    PyDict_SetItemString(mod_dict,"oacInvalidTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetNameOfImplicitTerm");
    PyDict_SetItemString(mod_dict,"oacCannotSetNameOfImplicitTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetNameOfTermInBundleTerm");
    PyDict_SetItemString(mod_dict,"oacCannotSetNameOfTermInBundleTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetAntennaDataOnImplicitTerm");
    PyDict_SetItemString(mod_dict,"oacCannotSetAntennaDataOnImplicitTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotScalarizeImplicitTerm");
    PyDict_SetItemString(mod_dict,"oacCannotScalarizeImplicitTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidPinConnectMethodName");
    PyDict_SetItemString(mod_dict,"oacInvalidPinConnectMethodName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotCreateTermWithImplicitNet");
    PyDict_SetItemString(mod_dict,"oacCannotCreateTermWithImplicitNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotCreateTermWithBlockOnlyNet");
    PyDict_SetItemString(mod_dict,"oacCannotCreateTermWithBlockOnlyNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotMoveToImplicitNet");
    PyDict_SetItemString(mod_dict,"oacCannotMoveToImplicitNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotMoveToBlockOnlyNet");
    PyDict_SetItemString(mod_dict,"oacCannotMoveToBlockOnlyNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTermMustJoinTermNotInSameBlock");
    PyDict_SetItemString(mod_dict,"oacTermMustJoinTermNotInSameBlock",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTermMustJoinCannotBeImplicit");
    PyDict_SetItemString(mod_dict,"oacTermMustJoinCannotBeImplicit",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTermMustJoinSameNet");
    PyDict_SetItemString(mod_dict,"oacTermMustJoinSameNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTermSensitivityTermNotInSameBlock");
    PyDict_SetItemString(mod_dict,"oacTermSensitivityTermNotInSameBlock",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetIsInterfaceOfImplicitTerm");
    PyDict_SetItemString(mod_dict,"oacCannotSetIsInterfaceOfImplicitTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTermNetMustBeInUniqueOccHier");
    PyDict_SetItemString(mod_dict,"oacTermNetMustBeInUniqueOccHier",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTermExists");
    PyDict_SetItemString(mod_dict,"oacTermExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTermMemberExists");
    PyDict_SetItemString(mod_dict,"oacTermMemberExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetPositionOfImplicitTerm");
    PyDict_SetItemString(mod_dict,"oacCannotSetPositionOfImplicitTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetPositionOfBlockOnlyTerm");
    PyDict_SetItemString(mod_dict,"oacCannotSetPositionOfBlockOnlyTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTermPositionAlreadyTaken");
    PyDict_SetItemString(mod_dict,"oacTermPositionAlreadyTaken",value);
    Py_DECREF(value);
    value=PyString_FromString("oacScalarTermNameMatchesBusBaseName");
    PyDict_SetItemString(mod_dict,"oacScalarTermNameMatchesBusBaseName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBusTermBaseNameMatchesScalarName");
    PyDict_SetItemString(mod_dict,"oacBusTermBaseNameMatchesScalarName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidBundleTermMemberIndex");
    PyDict_SetItemString(mod_dict,"oacInvalidBundleTermMemberIndex",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNetTermWidthMismatch");
    PyDict_SetItemString(mod_dict,"oacNetTermWidthMismatch",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetBusTermBitTermType");
    PyDict_SetItemString(mod_dict,"oacCannotSetBusTermBitTermType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidBusStartStopRange");
    PyDict_SetItemString(mod_dict,"oacInvalidBusStartStopRange",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetRouteMethodOnImplicitTerm");
    PyDict_SetItemString(mod_dict,"oacCannotSetRouteMethodOnImplicitTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidBitOrderName");
    PyDict_SetItemString(mod_dict,"oacInvalidBitOrderName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidBusNetDef");
    PyDict_SetItemString(mod_dict,"oacInvalidBusNetDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotDestroyImplicitBusNetDef");
    PyDict_SetItemString(mod_dict,"oacCannotDestroyImplicitBusNetDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBusNetDefAlreadyExists");
    PyDict_SetItemString(mod_dict,"oacBusNetDefAlreadyExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBitOrderBusNetDefImplicit");
    PyDict_SetItemString(mod_dict,"oacBitOrderBusNetDefImplicit",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotDestroyBusNetDefWithNets");
    PyDict_SetItemString(mod_dict,"oacCannotDestroyBusNetDefWithNets",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidBusTermDef");
    PyDict_SetItemString(mod_dict,"oacInvalidBusTermDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotDestroyImplicitBusTermDef");
    PyDict_SetItemString(mod_dict,"oacCannotDestroyImplicitBusTermDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBusTermDefAlreadyExists");
    PyDict_SetItemString(mod_dict,"oacBusTermDefAlreadyExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBitOrderBusTermDefImplicit");
    PyDict_SetItemString(mod_dict,"oacBitOrderBusTermDefImplicit",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotDestroyBusTermDefWithTerms");
    PyDict_SetItemString(mod_dict,"oacCannotDestroyBusTermDefWithTerms",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidLPPHeader");
    PyDict_SetItemString(mod_dict,"oacInvalidLPPHeader",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidInstHeader");
    PyDict_SetItemString(mod_dict,"oacInvalidInstHeader",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidInstTerm");
    PyDict_SetItemString(mod_dict,"oacInvalidInstTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidInstTermAttrTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidInstTermAttrTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTermNotInInstMasterForInstTerm");
    PyDict_SetItemString(mod_dict,"oacTermNotInInstMasterForInstTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstTermAlreadyExists");
    PyDict_SetItemString(mod_dict,"oacInstTermAlreadyExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNetInstTermWidthMismatchForInstTerm");
    PyDict_SetItemString(mod_dict,"oacNetInstTermWidthMismatchForInstTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstTermNetImplicit");
    PyDict_SetItemString(mod_dict,"oacInstTermNetImplicit",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstTermMustBeByPosition");
    PyDict_SetItemString(mod_dict,"oacInstTermMustBeByPosition",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstTermMustBeByName");
    PyDict_SetItemString(mod_dict,"oacInstTermMustBeByName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstTermConnectsByPosition");
    PyDict_SetItemString(mod_dict,"oacInstTermConnectsByPosition",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstTermConnectsByName");
    PyDict_SetItemString(mod_dict,"oacInstTermConnectsByName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstTermInstUsesTermPosition");
    PyDict_SetItemString(mod_dict,"oacInstTermInstUsesTermPosition",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstTermInstUsesTermName");
    PyDict_SetItemString(mod_dict,"oacInstTermInstUsesTermName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstTermInstImplicit");
    PyDict_SetItemString(mod_dict,"oacInstTermInstImplicit",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotDestroyImplicitInstTerm");
    PyDict_SetItemString(mod_dict,"oacCannotDestroyImplicitInstTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotModifyImplicitInstTerm");
    PyDict_SetItemString(mod_dict,"oacCannotModifyImplicitInstTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstTermBitAlreadyExists");
    PyDict_SetItemString(mod_dict,"oacInstTermBitAlreadyExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotScalarizeImplicitInstTerm");
    PyDict_SetItemString(mod_dict,"oacCannotScalarizeImplicitInstTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstTermIterFlagNotApplicableOnNets");
    PyDict_SetItemString(mod_dict,"oacInstTermIterFlagNotApplicableOnNets",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstTermMustBeInUniqueModule");
    PyDict_SetItemString(mod_dict,"oacInstTermMustBeInUniqueModule",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstTermInstMustBeInUniqueOccHier");
    PyDict_SetItemString(mod_dict,"oacInstTermInstMustBeInUniqueOccHier",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstTermNetMustBeInUniqueOccHier");
    PyDict_SetItemString(mod_dict,"oacInstTermNetMustBeInUniqueOccHier",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotModifyInstTermInNonUniqueHier");
    PyDict_SetItemString(mod_dict,"oacCannotModifyInstTermInNonUniqueHier",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidRoute");
    PyDict_SetItemString(mod_dict,"oacInvalidRoute",value);
    Py_DECREF(value);
    value=PyString_FromString("oacObjectNotValidForRoute");
    PyDict_SetItemString(mod_dict,"oacObjectNotValidForRoute",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidRouteTopologyName");
    PyDict_SetItemString(mod_dict,"oacInvalidRouteTopologyName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacObjectAlreadyShieldsNet");
    PyDict_SetItemString(mod_dict,"oacObjectAlreadyShieldsNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacRouteAndConnNotInSameBlock");
    PyDict_SetItemString(mod_dict,"oacRouteAndConnNotInSameBlock",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetRouteObjAsRouteConn");
    PyDict_SetItemString(mod_dict,"oacCannotSetRouteObjAsRouteConn",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidRouteConnObj");
    PyDict_SetItemString(mod_dict,"oacInvalidRouteConnObj",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidPin");
    PyDict_SetItemString(mod_dict,"oacInvalidPin",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPinExists");
    PyDict_SetItemString(mod_dict,"oacPinExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidAccessDirForPin");
    PyDict_SetItemString(mod_dict,"oacInvalidAccessDirForPin",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTermCannotBeImplicit");
    PyDict_SetItemString(mod_dict,"oacTermCannotBeImplicit",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPinCannotUseImplicitInst");
    PyDict_SetItemString(mod_dict,"oacPinCannotUseImplicitInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidSubMaster");
    PyDict_SetItemString(mod_dict,"oacInvalidSubMaster",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidSuperMaster");
    PyDict_SetItemString(mod_dict,"oacInvalidSuperMaster",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidMaster");
    PyDict_SetItemString(mod_dict,"oacInvalidMaster",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPcellObserverBindFailed");
    PyDict_SetItemString(mod_dict,"oacPcellObserverBindFailed",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPcellEvaluationFailed");
    PyDict_SetItemString(mod_dict,"oacPcellEvaluationFailed",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPcellInvalidPcellDef");
    PyDict_SetItemString(mod_dict,"oacPcellInvalidPcellDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPcellMasterNotBound");
    PyDict_SetItemString(mod_dict,"oacPcellMasterNotBound",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNotExistInDefaultParam");
    PyDict_SetItemString(mod_dict,"oacNotExistInDefaultParam",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDataTypeForParam");
    PyDict_SetItemString(mod_dict,"oacInvalidDataTypeForParam",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidPcellMaster");
    PyDict_SetItemString(mod_dict,"oacInvalidPcellMaster",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPcellLinkExists");
    PyDict_SetItemString(mod_dict,"oacPcellLinkExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotDestroyIPcellWithLinkExist");
    PyDict_SetItemString(mod_dict,"oacCannotDestroyIPcellWithLinkExist",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSaveUnboundSuperMaster");
    PyDict_SetItemString(mod_dict,"oacCannotSaveUnboundSuperMaster",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNonDesignTextDisplay");
    PyDict_SetItemString(mod_dict,"oacNonDesignTextDisplay",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNoMasterForTextDisplay");
    PyDict_SetItemString(mod_dict,"oacNoMasterForTextDisplay",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPropNotOnInstanceMaster");
    PyDict_SetItemString(mod_dict,"oacPropNotOnInstanceMaster",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTextNotInInstanceMaster");
    PyDict_SetItemString(mod_dict,"oacTextNotInInstanceMaster",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidTextDisplayCopy");
    PyDict_SetItemString(mod_dict,"oacInvalidTextDisplayCopy",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidTextDisplayFormatName");
    PyDict_SetItemString(mod_dict,"oacInvalidTextDisplayFormatName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacEvalTextLinkExists");
    PyDict_SetItemString(mod_dict,"oacEvalTextLinkExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotDestroyIEvalTextWithLinkExist");
    PyDict_SetItemString(mod_dict,"oacCannotDestroyIEvalTextWithLinkExist",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidMarker");
    PyDict_SetItemString(mod_dict,"oacInvalidMarker",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidMarkerMove");
    PyDict_SetItemString(mod_dict,"oacInvalidMarkerMove",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidMarkerCopy");
    PyDict_SetItemString(mod_dict,"oacInvalidMarkerCopy",value);
    Py_DECREF(value);
    value=PyString_FromString("oacObjMarkerNotInSameBlock");
    PyDict_SetItemString(mod_dict,"oacObjMarkerNotInSameBlock",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidMarkerMemType");
    PyDict_SetItemString(mod_dict,"oacInvalidMarkerMemType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidTrackPattern");
    PyDict_SetItemString(mod_dict,"oacInvalidTrackPattern",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidRow");
    PyDict_SetItemString(mod_dict,"oacInvalidRow",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidRowHeader");
    PyDict_SetItemString(mod_dict,"oacInvalidRowHeader",value);
    Py_DECREF(value);
    value=PyString_FromString("oacRowNameExists");
    PyDict_SetItemString(mod_dict,"oacRowNameExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidAssignmentDef");
    PyDict_SetItemString(mod_dict,"oacInvalidAssignmentDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDataTypeForTimeStamp");
    PyDict_SetItemString(mod_dict,"oacInvalidDataTypeForTimeStamp",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidAssignment");
    PyDict_SetItemString(mod_dict,"oacInvalidAssignment",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstHasAssignment");
    PyDict_SetItemString(mod_dict,"oacInstHasAssignment",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstAndAssignmentNotInSameBlock");
    PyDict_SetItemString(mod_dict,"oacInstAndAssignmentNotInSameBlock",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidAssignmentAttrTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidAssignmentAttrTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotCreateAssignmentImplicitInst");
    PyDict_SetItemString(mod_dict,"oacCannotCreateAssignmentImplicitInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetAssignmentImplicitInst");
    PyDict_SetItemString(mod_dict,"oacCannotSetAssignmentImplicitInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidCluster");
    PyDict_SetItemString(mod_dict,"oacInvalidCluster",value);
    Py_DECREF(value);
    value=PyString_FromString("oacClusterNameExists");
    PyDict_SetItemString(mod_dict,"oacClusterNameExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstAlreadyInCluster");
    PyDict_SetItemString(mod_dict,"oacInstAlreadyInCluster",value);
    Py_DECREF(value);
    value=PyString_FromString("oacClusterAndInstNotSameBlock");
    PyDict_SetItemString(mod_dict,"oacClusterAndInstNotSameBlock",value);
    Py_DECREF(value);
    value=PyString_FromString("oacClusterAlreadyHasParent");
    PyDict_SetItemString(mod_dict,"oacClusterAlreadyHasParent",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSameCluster");
    PyDict_SetItemString(mod_dict,"oacSameCluster",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidChildCluster");
    PyDict_SetItemString(mod_dict,"oacInvalidChildCluster",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidClusterTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidClusterTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidBoundary");
    PyDict_SetItemString(mod_dict,"oacInvalidBoundary",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidBoundaryType");
    PyDict_SetItemString(mod_dict,"oacInvalidBoundaryType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBoundaryHasExtraPoints");
    PyDict_SetItemString(mod_dict,"oacBoundaryHasExtraPoints",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBoundaryTooFewPoints");
    PyDict_SetItemString(mod_dict,"oacBoundaryTooFewPoints",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBoundaryNameExists");
    PyDict_SetItemString(mod_dict,"oacBoundaryNameExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPRBoundaryExists");
    PyDict_SetItemString(mod_dict,"oacPRBoundaryExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSnapBoundaryExists");
    PyDict_SetItemString(mod_dict,"oacSnapBoundaryExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSnapBoundaryNotRectangle");
    PyDict_SetItemString(mod_dict,"oacSnapBoundaryNotRectangle",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInterBlockBoundaryCopyInvalid");
    PyDict_SetItemString(mod_dict,"oacInterBlockBoundaryCopyInvalid",value);
    Py_DECREF(value);
    value=PyString_FromString("oacIntraBlockBoundaryCopyInvalid");
    PyDict_SetItemString(mod_dict,"oacIntraBlockBoundaryCopyInvalid",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidBlockageTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidBlockageTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidViaHeader");
    PyDict_SetItemString(mod_dict,"oacInvalidViaHeader",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidStdViaHeader");
    PyDict_SetItemString(mod_dict,"oacInvalidStdViaHeader",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidConnectDef");
    PyDict_SetItemString(mod_dict,"oacInvalidConnectDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNetAlreadyHasConnectDef");
    PyDict_SetItemString(mod_dict,"oacNetAlreadyHasConnectDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConnectDefImplicitNet");
    PyDict_SetItemString(mod_dict,"oacConnectDefImplicitNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTermAlreadyHasConnectDef");
    PyDict_SetItemString(mod_dict,"oacTermAlreadyHasConnectDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConnectDefImplicitTerm");
    PyDict_SetItemString(mod_dict,"oacConnectDefImplicitTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidScanChainInst");
    PyDict_SetItemString(mod_dict,"oacInvalidScanChainInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidScanChainInstTerm");
    PyDict_SetItemString(mod_dict,"oacInvalidScanChainInstTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidScanChainSetTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidScanChainSetTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetMaxBits");
    PyDict_SetItemString(mod_dict,"oacCannotSetMaxBits",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidScanChain");
    PyDict_SetItemString(mod_dict,"oacInvalidScanChain",value);
    Py_DECREF(value);
    value=PyString_FromString("oacScanChainExists");
    PyDict_SetItemString(mod_dict,"oacScanChainExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidScanChainName");
    PyDict_SetItemString(mod_dict,"oacInvalidScanChainName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidScanChainSet");
    PyDict_SetItemString(mod_dict,"oacInvalidScanChainSet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacErrorCanOnlyHaveOneUnorderedSet");
    PyDict_SetItemString(mod_dict,"oacErrorCanOnlyHaveOneUnorderedSet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidSteiner");
    PyDict_SetItemString(mod_dict,"oacInvalidSteiner",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotAddSteinerToNonBitNet");
    PyDict_SetItemString(mod_dict,"oacCannotAddSteinerToNonBitNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidGCellPattern");
    PyDict_SetItemString(mod_dict,"oacInvalidGCellPattern",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidCMap");
    PyDict_SetItemString(mod_dict,"oacInvalidCMap",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCMapLayerNotExists");
    PyDict_SetItemString(mod_dict,"oacCMapLayerNotExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidAnalysisPoint");
    PyDict_SetItemString(mod_dict,"oacInvalidAnalysisPoint",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAnalysisPointNameExists");
    PyDict_SetItemString(mod_dict,"oacAnalysisPointNameExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidAnalysisOpPoint");
    PyDict_SetItemString(mod_dict,"oacInvalidAnalysisOpPoint",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAnalysisOpPtOpPointNotInSameTech");
    PyDict_SetItemString(mod_dict,"oacAnalysisOpPtOpPointNotInSameTech",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidOpPointHeader");
    PyDict_SetItemString(mod_dict,"oacInvalidOpPointHeader",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidReducedModel");
    PyDict_SetItemString(mod_dict,"oacInvalidReducedModel",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDriverTermType");
    PyDict_SetItemString(mod_dict,"oacInvalidDriverTermType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidReceiverTermType");
    PyDict_SetItemString(mod_dict,"oacInvalidReceiverTermType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacReceiverNetDoesNotMatchDriverNet");
    PyDict_SetItemString(mod_dict,"oacReceiverNetDoesNotMatchDriverNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacParasiticTermMustBeScalar");
    PyDict_SetItemString(mod_dict,"oacParasiticTermMustBeScalar",value);
    Py_DECREF(value);
    value=PyString_FromString("oacParasiticInstTermMustBeScalar");
    PyDict_SetItemString(mod_dict,"oacParasiticInstTermMustBeScalar",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidElmore");
    PyDict_SetItemString(mod_dict,"oacInvalidElmore",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidPoleResidue");
    PyDict_SetItemString(mod_dict,"oacInvalidPoleResidue",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNotADetailedData");
    PyDict_SetItemString(mod_dict,"oacNotADetailedData",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidParasiticNetwork");
    PyDict_SetItemString(mod_dict,"oacInvalidParasiticNetwork",value);
    Py_DECREF(value);
    value=PyString_FromString("oacParasiticNetworkExists");
    PyDict_SetItemString(mod_dict,"oacParasiticNetworkExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNoParasiticNetworkToLoad");
    PyDict_SetItemString(mod_dict,"oacNoParasiticNetworkToLoad",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidSubNetwork");
    PyDict_SetItemString(mod_dict,"oacInvalidSubNetwork",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSubNetworkNameExists");
    PyDict_SetItemString(mod_dict,"oacSubNetworkNameExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSubNetworkNodeNotSameDesign");
    PyDict_SetItemString(mod_dict,"oacSubNetworkNodeNotSameDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSubNetworkNodeNotSameNetwork");
    PyDict_SetItemString(mod_dict,"oacSubNetworkNodeNotSameNetwork",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSubNetworkDeviceNotSameDesign");
    PyDict_SetItemString(mod_dict,"oacSubNetworkDeviceNotSameDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSubNetworkNotShapeOrVia");
    PyDict_SetItemString(mod_dict,"oacSubNetworkNotShapeOrVia",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidNode");
    PyDict_SetItemString(mod_dict,"oacInvalidNode",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidNodeConnType");
    PyDict_SetItemString(mod_dict,"oacInvalidNodeConnType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidCouplingCapConnType");
    PyDict_SetItemString(mod_dict,"oacInvalidCouplingCapConnType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNodeNameExists");
    PyDict_SetItemString(mod_dict,"oacNodeNameExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNodeIdExists");
    PyDict_SetItemString(mod_dict,"oacNodeIdExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidEndpointTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidEndpointTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDevice");
    PyDict_SetItemString(mod_dict,"oacInvalidDevice",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDeviceNameExists");
    PyDict_SetItemString(mod_dict,"oacDeviceNameExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLocalDeviceIdExists");
    PyDict_SetItemString(mod_dict,"oacLocalDeviceIdExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNonLocalDeviceIdExists");
    PyDict_SetItemString(mod_dict,"oacNonLocalDeviceIdExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNodesNotInSameDesign");
    PyDict_SetItemString(mod_dict,"oacNodesNotInSameDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNodeNetNotInSameDesign");
    PyDict_SetItemString(mod_dict,"oacNodeNetNotInSameDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNodeConnNotInSameDesign");
    PyDict_SetItemString(mod_dict,"oacNodeConnNotInSameDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNodesNotInSameNetwork");
    PyDict_SetItemString(mod_dict,"oacNodesNotInSameNetwork",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInductorsNotInSameDesign");
    PyDict_SetItemString(mod_dict,"oacInductorsNotInSameDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInductorNetNotInSameDesign");
    PyDict_SetItemString(mod_dict,"oacInductorNetNotInSameDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInductorsNotInSameNetwork");
    PyDict_SetItemString(mod_dict,"oacInductorsNotInSameNetwork",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDeviceNotConnectedToNode");
    PyDict_SetItemString(mod_dict,"oacDeviceNotConnectedToNode",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNoConnForLocalCouplingCaps");
    PyDict_SetItemString(mod_dict,"oacNoConnForLocalCouplingCaps",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCouplingCapHasNoConn");
    PyDict_SetItemString(mod_dict,"oacCouplingCapHasNoConn",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCoupledNodeWithoutId");
    PyDict_SetItemString(mod_dict,"oacCoupledNodeWithoutId",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidCouplingCapId");
    PyDict_SetItemString(mod_dict,"oacInvalidCouplingCapId",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCoupledInductorWithoutId");
    PyDict_SetItemString(mod_dict,"oacCoupledInductorWithoutId",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidMutualInductorId");
    PyDict_SetItemString(mod_dict,"oacInvalidMutualInductorId",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDesignDataTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidDesignDataTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidFontName");
    PyDict_SetItemString(mod_dict,"oacInvalidFontName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidPlacementStatusTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidPlacementStatusTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidMarkerDeleteWhenTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidMarkerDeleteWhenTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidPathStyleName");
    PyDict_SetItemString(mod_dict,"oacInvalidPathStyleName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidSigTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidSigTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidSourceName");
    PyDict_SetItemString(mod_dict,"oacInvalidSourceName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidTextAlignName");
    PyDict_SetItemString(mod_dict,"oacInvalidTextAlignName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidLayerHeader");
    PyDict_SetItemString(mod_dict,"oacInvalidLayerHeader",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidBlockage");
    PyDict_SetItemString(mod_dict,"oacInvalidBlockage",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBlockageHasExtraPoints");
    PyDict_SetItemString(mod_dict,"oacBlockageHasExtraPoints",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBlockageTooFewPoints");
    PyDict_SetItemString(mod_dict,"oacBlockageTooFewPoints",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotCopyBlockageWithOwner");
    PyDict_SetItemString(mod_dict,"oacCannotCopyBlockageWithOwner",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAreaHaloAlreadyExists");
    PyDict_SetItemString(mod_dict,"oacAreaHaloAlreadyExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidLayerForLayerBlockage");
    PyDict_SetItemString(mod_dict,"oacInvalidLayerForLayerBlockage",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidTypeForLayerBlockage");
    PyDict_SetItemString(mod_dict,"oacInvalidTypeForLayerBlockage",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidGuide");
    PyDict_SetItemString(mod_dict,"oacInvalidGuide",value);
    Py_DECREF(value);
    value=PyString_FromString("oacRouteOptimizerInternalError");
    PyDict_SetItemString(mod_dict,"oacRouteOptimizerInternalError",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCMapInvalidGCellPattern");
    PyDict_SetItemString(mod_dict,"oacCMapInvalidGCellPattern",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCMapInvalidGCellIndex");
    PyDict_SetItemString(mod_dict,"oacCMapInvalidGCellIndex",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidModule");
    PyDict_SetItemString(mod_dict,"oacInvalidModule",value);
    Py_DECREF(value);
    value=PyString_FromString("oacModuleExists");
    PyDict_SetItemString(mod_dict,"oacModuleExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacModuleNotDerived");
    PyDict_SetItemString(mod_dict,"oacModuleNotDerived",value);
    Py_DECREF(value);
    value=PyString_FromString("oacModuleNotDerivedFromModule");
    PyDict_SetItemString(mod_dict,"oacModuleNotDerivedFromModule",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidBlockDomainVisibilityName");
    PyDict_SetItemString(mod_dict,"oacInvalidBlockDomainVisibilityName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTopBlockAlreadyExists");
    PyDict_SetItemString(mod_dict,"oacTopBlockAlreadyExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTopModuleAlreadyExists");
    PyDict_SetItemString(mod_dict,"oacTopModuleAlreadyExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDesignIsBlockDomainSpecific");
    PyDict_SetItemString(mod_dict,"oacDesignIsBlockDomainSpecific",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDesignIsModuleDomainSpecific");
    PyDict_SetItemString(mod_dict,"oacDesignIsModuleDomainSpecific",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidModInst");
    PyDict_SetItemString(mod_dict,"oacInvalidModInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidModDesignInst");
    PyDict_SetItemString(mod_dict,"oacInvalidModDesignInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidModModuleInst");
    PyDict_SetItemString(mod_dict,"oacInvalidModModuleInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidModInstHeader");
    PyDict_SetItemString(mod_dict,"oacInvalidModInstHeader",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidModModuleInstHeader");
    PyDict_SetItemString(mod_dict,"oacInvalidModModuleInstHeader",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidModNet");
    PyDict_SetItemString(mod_dict,"oacInvalidModNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidModTerm");
    PyDict_SetItemString(mod_dict,"oacInvalidModTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidModInstTerm");
    PyDict_SetItemString(mod_dict,"oacInvalidModInstTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidModBusNetDef");
    PyDict_SetItemString(mod_dict,"oacInvalidModBusNetDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidModBusTermDef");
    PyDict_SetItemString(mod_dict,"oacInvalidModBusTermDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidModVectorInstDef");
    PyDict_SetItemString(mod_dict,"oacInvalidModVectorInstDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidModConnectDef");
    PyDict_SetItemString(mod_dict,"oacInvalidModConnectDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidModAssignment");
    PyDict_SetItemString(mod_dict,"oacInvalidModAssignment",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidOccObject");
    PyDict_SetItemString(mod_dict,"oacInvalidOccObject",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidOccInst");
    PyDict_SetItemString(mod_dict,"oacInvalidOccInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidOccDesignInst");
    PyDict_SetItemString(mod_dict,"oacInvalidOccDesignInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidOccModuleInst");
    PyDict_SetItemString(mod_dict,"oacInvalidOccModuleInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidOccInstHeader");
    PyDict_SetItemString(mod_dict,"oacInvalidOccInstHeader",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidOccModuleInstHeader");
    PyDict_SetItemString(mod_dict,"oacInvalidOccModuleInstHeader",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidOccNet");
    PyDict_SetItemString(mod_dict,"oacInvalidOccNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidOccTerm");
    PyDict_SetItemString(mod_dict,"oacInvalidOccTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidOccInstTerm");
    PyDict_SetItemString(mod_dict,"oacInvalidOccInstTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidOccBusNetDef");
    PyDict_SetItemString(mod_dict,"oacInvalidOccBusNetDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidOccBusTermDef");
    PyDict_SetItemString(mod_dict,"oacInvalidOccBusTermDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidOccVectorInstDef");
    PyDict_SetItemString(mod_dict,"oacInvalidOccVectorInstDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidOccConnectDef");
    PyDict_SetItemString(mod_dict,"oacInvalidOccConnectDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidOccAssignment");
    PyDict_SetItemString(mod_dict,"oacInvalidOccAssignment",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBusDefIsModuleDomainSpecific");
    PyDict_SetItemString(mod_dict,"oacBusDefIsModuleDomainSpecific",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBusDefIsBlockDomainSpecific");
    PyDict_SetItemString(mod_dict,"oacBusDefIsBlockDomainSpecific",value);
    Py_DECREF(value);
    value=PyString_FromString("oacVectorDefIsModuleDomainSpecific");
    PyDict_SetItemString(mod_dict,"oacVectorDefIsModuleDomainSpecific",value);
    Py_DECREF(value);
    value=PyString_FromString("oacVectorDefIsBlockDomainSpecific");
    PyDict_SetItemString(mod_dict,"oacVectorDefIsBlockDomainSpecific",value);
    Py_DECREF(value);
    value=PyString_FromString("oacVectorDefInstMustBeModuleInst");
    PyDict_SetItemString(mod_dict,"oacVectorDefInstMustBeModuleInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacVectorDefInstMustBeDesignInst");
    PyDict_SetItemString(mod_dict,"oacVectorDefInstMustBeDesignInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacImplicitModuleNetExists");
    PyDict_SetItemString(mod_dict,"oacImplicitModuleNetExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacImplicitBlockNetExists");
    PyDict_SetItemString(mod_dict,"oacImplicitBlockNetExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacImplicitModuleTermExists");
    PyDict_SetItemString(mod_dict,"oacImplicitModuleTermExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacImplicitBlockTermExists");
    PyDict_SetItemString(mod_dict,"oacImplicitBlockTermExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidRowSpacingTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidRowSpacingTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidCoreRowFlipTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidCoreRowFlipTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCoreBoxSpecNoSiteDef");
    PyDict_SetItemString(mod_dict,"oacCoreBoxSpecNoSiteDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCoreBoxSpecInvalidRowNumber");
    PyDict_SetItemString(mod_dict,"oacCoreBoxSpecInvalidRowNumber",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidModuleNetIterFlags");
    PyDict_SetItemString(mod_dict,"oacInvalidModuleNetIterFlags",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidModuleTermIterFlags");
    PyDict_SetItemString(mod_dict,"oacInvalidModuleTermIterFlags",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidOccurrenceNetIterFlags");
    PyDict_SetItemString(mod_dict,"oacInvalidOccurrenceNetIterFlags",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidOccurrenceTermIterFlags");
    PyDict_SetItemString(mod_dict,"oacInvalidOccurrenceTermIterFlags",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidGroupByNameIterFlags");
    PyDict_SetItemString(mod_dict,"oacInvalidGroupByNameIterFlags",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidBlockageDensityValue");
    PyDict_SetItemString(mod_dict,"oacInvalidBlockageDensityValue",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidBlockageTypeForDensity");
    PyDict_SetItemString(mod_dict,"oacInvalidBlockageTypeForDensity",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidBlockageOwner");
    PyDict_SetItemString(mod_dict,"oacInvalidBlockageOwner",value);
    Py_DECREF(value);
    value=PyString_FromString("oacModulesNotInSameDesign");
    PyDict_SetItemString(mod_dict,"oacModulesNotInSameDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidTopOccurrence");
    PyDict_SetItemString(mod_dict,"oacInvalidTopOccurrence",value);
    Py_DECREF(value);
    value=PyString_FromString("oacModuleAndOccurrenceNotInSameDesign");
    PyDict_SetItemString(mod_dict,"oacModuleAndOccurrenceNotInSameDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidMarkerSeverityTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidMarkerSeverityTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidHierBundleNetName");
    PyDict_SetItemString(mod_dict,"oacInvalidHierBundleNetName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNetAndInstNotInSameModule");
    PyDict_SetItemString(mod_dict,"oacNetAndInstNotInSameModule",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidHierInstName");
    PyDict_SetItemString(mod_dict,"oacInvalidHierInstName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidHierNetName");
    PyDict_SetItemString(mod_dict,"oacInvalidHierNetName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidHierTermName");
    PyDict_SetItemString(mod_dict,"oacInvalidHierTermName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotMoveDerivedBlockage");
    PyDict_SetItemString(mod_dict,"oacCannotMoveDerivedBlockage",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotCopyDerivedBlockage");
    PyDict_SetItemString(mod_dict,"oacCannotCopyDerivedBlockage",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidReducedModelDomain");
    PyDict_SetItemString(mod_dict,"oacInvalidReducedModelDomain",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidReducedModelObjectType");
    PyDict_SetItemString(mod_dict,"oacInvalidReducedModelObjectType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDriverReceiverNotInSameDomain");
    PyDict_SetItemString(mod_dict,"oacDriverReceiverNotInSameDomain",value);
    Py_DECREF(value);
    value=PyString_FromString("oacObjectNetworkNotInSameDomain");
    PyDict_SetItemString(mod_dict,"oacObjectNetworkNotInSameDomain",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDeviceNetNotInSameDomain");
    PyDict_SetItemString(mod_dict,"oacDeviceNetNotInSameDomain",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNetworkConnNotInSameDomain");
    PyDict_SetItemString(mod_dict,"oacNetworkConnNotInSameDomain",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConnNodeNotInSameDomain");
    PyDict_SetItemString(mod_dict,"oacConnNodeNotInSameDomain",value);
    Py_DECREF(value);
    value=PyString_FromString("oacObjectAlreadyOnMarker");
    PyDict_SetItemString(mod_dict,"oacObjectAlreadyOnMarker",value);
    Py_DECREF(value);
    value=PyString_FromString("oacMoveToNetNotInSameDesign");
    PyDict_SetItemString(mod_dict,"oacMoveToNetNotInSameDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNetEquivNetNotInSameDesign");
    PyDict_SetItemString(mod_dict,"oacNetEquivNetNotInSameDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidModuleEmbedMaster");
    PyDict_SetItemString(mod_dict,"oacInvalidModuleEmbedMaster",value);
    Py_DECREF(value);
    value=PyString_FromString("oacModuleDetachDesignExists");
    PyDict_SetItemString(mod_dict,"oacModuleDetachDesignExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidVia");
    PyDict_SetItemString(mod_dict,"oacInvalidVia",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotAddViaToNonBitNet");
    PyDict_SetItemString(mod_dict,"oacCannotAddViaToNonBitNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidEndStyleName");
    PyDict_SetItemString(mod_dict,"oacInvalidEndStyleName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidSegStyleBeginExtValue");
    PyDict_SetItemString(mod_dict,"oacInvalidSegStyleBeginExtValue",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidSegStyleEndExtValue");
    PyDict_SetItemString(mod_dict,"oacInvalidSegStyleEndExtValue",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidPathSegPoints");
    PyDict_SetItemString(mod_dict,"oacInvalidPathSegPoints",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidPathSegTransformAngle");
    PyDict_SetItemString(mod_dict,"oacInvalidPathSegTransformAngle",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetBlockageOwner");
    PyDict_SetItemString(mod_dict,"oacCannotSetBlockageOwner",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetBlockagePushedDown");
    PyDict_SetItemString(mod_dict,"oacCannotSetBlockagePushedDown",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidRef");
    PyDict_SetItemString(mod_dict,"oacInvalidRef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidRefHeader");
    PyDict_SetItemString(mod_dict,"oacInvalidRefHeader",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotModifyImplicitRef");
    PyDict_SetItemString(mod_dict,"oacCannotModifyImplicitRef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidOccShape");
    PyDict_SetItemString(mod_dict,"oacInvalidOccShape",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidViaDirectionTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidViaDirectionTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacParamsSuppliedForNonPCellViaMaster");
    PyDict_SetItemString(mod_dict,"oacParamsSuppliedForNonPCellViaMaster",value);
    Py_DECREF(value);
    value=PyString_FromString("oacParamsSuppliedForNonPCellInstMaster");
    PyDict_SetItemString(mod_dict,"oacParamsSuppliedForNonPCellInstMaster",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotRemoveRouteFigFromNet");
    PyDict_SetItemString(mod_dict,"oacCannotRemoveRouteFigFromNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotAddRouteFigToNet");
    PyDict_SetItemString(mod_dict,"oacCannotAddRouteFigToNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotAddPinFigToNet");
    PyDict_SetItemString(mod_dict,"oacCannotAddPinFigToNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotAddInstToNet");
    PyDict_SetItemString(mod_dict,"oacCannotAddInstToNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotAddRouteFigToPin");
    PyDict_SetItemString(mod_dict,"oacCannotAddRouteFigToPin",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotAddNetFigToPin");
    PyDict_SetItemString(mod_dict,"oacCannotAddNetFigToPin",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotAddPinFigToRoute");
    PyDict_SetItemString(mod_dict,"oacCannotAddPinFigToRoute",value);
    Py_DECREF(value);
    value=PyString_FromString("oacRouteAndObjectNotInSameBlock");
    PyDict_SetItemString(mod_dict,"oacRouteAndObjectNotInSameBlock",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotAddRouteConnFigToRoute");
    PyDict_SetItemString(mod_dict,"oacCannotAddRouteConnFigToRoute",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotAddFigToRouteOnDifferentNet");
    PyDict_SetItemString(mod_dict,"oacCannotAddFigToRouteOnDifferentNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotAddSameFigToRouteAgain");
    PyDict_SetItemString(mod_dict,"oacCannotAddSameFigToRouteAgain",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPinAndFigNotInSameBlock");
    PyDict_SetItemString(mod_dict,"oacPinAndFigNotInSameBlock",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidStdViaMaster");
    PyDict_SetItemString(mod_dict,"oacInvalidStdViaMaster",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidHierPath");
    PyDict_SetItemString(mod_dict,"oacInvalidHierPath",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotLockDatabase");
    PyDict_SetItemString(mod_dict,"oacCannotLockDatabase",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotFindSpecAssignedDefOccNet");
    PyDict_SetItemString(mod_dict,"oacCannotFindSpecAssignedDefOccNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotFindSpecAssignedOccNet");
    PyDict_SetItemString(mod_dict,"oacCannotFindSpecAssignedOccNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotCreateBlockageWithImplicitInst");
    PyDict_SetItemString(mod_dict,"oacCannotCreateBlockageWithImplicitInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotAddBlockageToImplicitInst");
    PyDict_SetItemString(mod_dict,"oacCannotAddBlockageToImplicitInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDesignCannotGetReadAccess");
    PyDict_SetItemString(mod_dict,"oacDesignCannotGetReadAccess",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDesignCannotGetWriteAccess");
    PyDict_SetItemString(mod_dict,"oacDesignCannotGetWriteAccess",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDesignHasReadNeedWriteAccess");
    PyDict_SetItemString(mod_dict,"oacDesignHasReadNeedWriteAccess",value);
    Py_DECREF(value);
    value=PyString_FromString("oacParasiticsDataCannotGetReadAccess");
    PyDict_SetItemString(mod_dict,"oacParasiticsDataCannotGetReadAccess",value);
    Py_DECREF(value);
    value=PyString_FromString("oacParasiticsDataCannotGetWriteAccess");
    PyDict_SetItemString(mod_dict,"oacParasiticsDataCannotGetWriteAccess",value);
    Py_DECREF(value);
    value=PyString_FromString("oacParasiticsDataHasReadNeedWriteAccess");
    PyDict_SetItemString(mod_dict,"oacParasiticsDataHasReadNeedWriteAccess",value);
    Py_DECREF(value);
    value=PyString_FromString("oacParasiticNetworkPartitionNameExists");
    PyDict_SetItemString(mod_dict,"oacParasiticNetworkPartitionNameExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacParasiticNetworkPartialLoaded");
    PyDict_SetItemString(mod_dict,"oacParasiticNetworkPartialLoaded",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCustomEndStyleNotAllowed");
    PyDict_SetItemString(mod_dict,"oacCustomEndStyleNotAllowed",value);
    Py_DECREF(value);
    value=PyString_FromString("oacEvenWidthRequiredForSegStyle");
    PyDict_SetItemString(mod_dict,"oacEvenWidthRequiredForSegStyle",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCustomEndStyleNotAllowedForBegin");
    PyDict_SetItemString(mod_dict,"oacCustomEndStyleNotAllowedForBegin",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOnlyCustomEndStyleAllowedForEnd");
    PyDict_SetItemString(mod_dict,"oacOnlyCustomEndStyleAllowedForEnd",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCustomEndStyleNotAllowedForEnd");
    PyDict_SetItemString(mod_dict,"oacCustomEndStyleNotAllowedForEnd",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOnlyCustomEndStyleAllowedForBegin");
    PyDict_SetItemString(mod_dict,"oacOnlyCustomEndStyleAllowedForBegin",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOnlyCustomEndStylesAllowed");
    PyDict_SetItemString(mod_dict,"oacOnlyCustomEndStylesAllowed",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotChangeWidthForBothCustomEnds");
    PyDict_SetItemString(mod_dict,"oacCannotChangeWidthForBothCustomEnds",value);
    Py_DECREF(value);
    value=PyString_FromString("oacUndoNotEnabled");
    PyDict_SetItemString(mod_dict,"oacUndoNotEnabled",value);
    Py_DECREF(value);
    value=PyString_FromString("oacRegionQueryAlreadyInitialized");
    PyDict_SetItemString(mod_dict,"oacRegionQueryAlreadyInitialized",value);
    Py_DECREF(value);
    value=PyString_FromString("oacRegionQueryNotInitialized");
    PyDict_SetItemString(mod_dict,"oacRegionQueryNotInitialized",value);
    Py_DECREF(value);
    value=PyString_FromString("oacRegionQueryFailedToGetPlugIn");
    PyDict_SetItemString(mod_dict,"oacRegionQueryFailedToGetPlugIn",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDesignObject");
    PyDict_SetItemString(mod_dict,"oacInvalidDesignObject",value);
    Py_DECREF(value);
    value=PyString_FromString("oacRowZeroNumSitesNotAllowed");
    PyDict_SetItemString(mod_dict,"oacRowZeroNumSitesNotAllowed",value);
    Py_DECREF(value);
    value=PyString_FromString("oacModuleDetachRequiresUndoToBeDisabled");
    PyDict_SetItemString(mod_dict,"oacModuleDetachRequiresUndoToBeDisabled",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOccDestroyRequiresUndoToBeDisabled");
    PyDict_SetItemString(mod_dict,"oacOccDestroyRequiresUndoToBeDisabled",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDriverAnalysisPointNotInSameDesign");
    PyDict_SetItemString(mod_dict,"oacDriverAnalysisPointNotInSameDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDriverReceiverNotInSameDesign");
    PyDict_SetItemString(mod_dict,"oacDriverReceiverNotInSameDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidNodeIdSpecified");
    PyDict_SetItemString(mod_dict,"oacInvalidNodeIdSpecified",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDeviceIdSpecified");
    PyDict_SetItemString(mod_dict,"oacInvalidDeviceIdSpecified",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDesignHasNoTopBlock");
    PyDict_SetItemString(mod_dict,"oacDesignHasNoTopBlock",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAncestorNodeWithoutId");
    PyDict_SetItemString(mod_dict,"oacAncestorNodeWithoutId",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAncestorInductorWithoutId");
    PyDict_SetItemString(mod_dict,"oacAncestorInductorWithoutId",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNodesNotInRelatedPartitions");
    PyDict_SetItemString(mod_dict,"oacNodesNotInRelatedPartitions",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInductorsNotInRelatedPartitions");
    PyDict_SetItemString(mod_dict,"oacInductorsNotInRelatedPartitions",value);
    Py_DECREF(value);
    value=PyString_FromString("oacViaDefNotInTechAssociatedWithDesign");
    PyDict_SetItemString(mod_dict,"oacViaDefNotInTechAssociatedWithDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSiteDefNotInTechAssociatedWithDesign");
    PyDict_SetItemString(mod_dict,"oacSiteDefNotInTechAssociatedWithDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacObsoleteDesignMsg1493");
    PyDict_SetItemString(mod_dict,"oacObsoleteDesignMsg1493",value);
    Py_DECREF(value);
    value=PyString_FromString("oacScriptEngineLinkExists");
    PyDict_SetItemString(mod_dict,"oacScriptEngineLinkExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPcellEvaluatorNotFound");
    PyDict_SetItemString(mod_dict,"oacPcellEvaluatorNotFound",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotCopyPcellInst");
    PyDict_SetItemString(mod_dict,"oacCannotCopyPcellInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotMovePcellInst");
    PyDict_SetItemString(mod_dict,"oacCannotMovePcellInst",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetConnStatusImplicitNet");
    PyDict_SetItemString(mod_dict,"oacCannotSetConnStatusImplicitNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetOriginalNetImplicitNet");
    PyDict_SetItemString(mod_dict,"oacCannotSetOriginalNetImplicitNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacImplicitNetCannotBeOriginalNet");
    PyDict_SetItemString(mod_dict,"oacImplicitNetCannotBeOriginalNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetVoltageImplicitNet");
    PyDict_SetItemString(mod_dict,"oacCannotSetVoltageImplicitNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotSetRoutePattenImplicitNet");
    PyDict_SetItemString(mod_dict,"oacCannotSetRoutePattenImplicitNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotShieldImplicitNet");
    PyDict_SetItemString(mod_dict,"oacCannotShieldImplicitNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacImplicitNetCannotShieldNet");
    PyDict_SetItemString(mod_dict,"oacImplicitNetCannotShieldNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNetSetBaseNameConflictsInTerms");
    PyDict_SetItemString(mod_dict,"oacNetSetBaseNameConflictsInTerms",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNetSetBaseNameConflictsInInstTerms");
    PyDict_SetItemString(mod_dict,"oacNetSetBaseNameConflictsInInstTerms",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNetSetRangeConflictsWithOtherNets");
    PyDict_SetItemString(mod_dict,"oacNetSetRangeConflictsWithOtherNets",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotRenameToImplicitBusNet");
    PyDict_SetItemString(mod_dict,"oacCannotRenameToImplicitBusNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotRenameToImplicitBusTerm");
    PyDict_SetItemString(mod_dict,"oacCannotRenameToImplicitBusTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotCreateBlockOnlyInModuleDesign");
    PyDict_SetItemString(mod_dict,"oacCannotCreateBlockOnlyInModuleDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidScanChainObject");
    PyDict_SetItemString(mod_dict,"oacInvalidScanChainObject",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidInstTermBitIndex");
    PyDict_SetItemString(mod_dict,"oacInvalidInstTermBitIndex",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstTermNetMismatchInRepeatedMembers");
    PyDict_SetItemString(mod_dict,"oacInstTermNetMismatchInRepeatedMembers",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidNetName");
    PyDict_SetItemString(mod_dict,"oacInvalidNetName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidTermName");
    PyDict_SetItemString(mod_dict,"oacInvalidTermName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotHideImplicitInstTerm");
    PyDict_SetItemString(mod_dict,"oacCannotHideImplicitInstTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotHideBlockOnlyInstTerm");
    PyDict_SetItemString(mod_dict,"oacCannotHideBlockOnlyInstTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotDestroyImplicitTerm");
    PyDict_SetItemString(mod_dict,"oacCannotDestroyImplicitTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidNodeConnNet");
    PyDict_SetItemString(mod_dict,"oacInvalidNodeConnNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotChangeUndoModel");
    PyDict_SetItemString(mod_dict,"oacCannotChangeUndoModel",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotUnsetNonEmptyCp");
    PyDict_SetItemString(mod_dict,"oacCannotUnsetNonEmptyCp",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotUndoWithoutCpInPostModel");
    PyDict_SetItemString(mod_dict,"oacCannotUndoWithoutCpInPostModel",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstTermBatchCreateHasInstTerms");
    PyDict_SetItemString(mod_dict,"oacInstTermBatchCreateHasInstTerms",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidGlobalNet");
    PyDict_SetItemString(mod_dict,"oacInvalidGlobalNet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidFigGroup");
    PyDict_SetItemString(mod_dict,"oacInvalidFigGroup",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidFigGroupStatusTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidFigGroupStatusTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacFigAlreadyInFigGroup");
    PyDict_SetItemString(mod_dict,"oacFigAlreadyInFigGroup",value);
    Py_DECREF(value);
    value=PyString_FromString("oacFigGroupNameExists");
    PyDict_SetItemString(mod_dict,"oacFigGroupNameExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidFigGroupTypeForMemberMove");
    PyDict_SetItemString(mod_dict,"oacInvalidFigGroupTypeForMemberMove",value);
    Py_DECREF(value);
    value=PyString_FromString("oacFigGroupMemberNotInSameFigGroup");
    PyDict_SetItemString(mod_dict,"oacFigGroupMemberNotInSameFigGroup",value);
    Py_DECREF(value);
    value=PyString_FromString("oacFigGroupMemberNotInSameDB");
    PyDict_SetItemString(mod_dict,"oacFigGroupMemberNotInSameDB",value);
    Py_DECREF(value);
    value=PyString_FromString("oacFigGroupCircularMembership");
    PyDict_SetItemString(mod_dict,"oacFigGroupCircularMembership",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConstraintGroupNotInTechAssociatedWithDesign");
    PyDict_SetItemString(mod_dict,"oacConstraintGroupNotInTechAssociatedWithDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidBuiltInTechConstraintGroupInDesign");
    PyDict_SetItemString(mod_dict,"oacInvalidBuiltInTechConstraintGroupInDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDefaultTechConstraintGroupInDesign");
    PyDict_SetItemString(mod_dict,"oacInvalidDefaultTechConstraintGroupInDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBindViaToIncorrectViaDefOnCopy");
    PyDict_SetItemString(mod_dict,"oacBindViaToIncorrectViaDefOnCopy",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBindViaToIncorrectViaDefOnMove");
    PyDict_SetItemString(mod_dict,"oacBindViaToIncorrectViaDefOnMove",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBindRowToIncorrectSiteDefOnCopy");
    PyDict_SetItemString(mod_dict,"oacBindRowToIncorrectSiteDefOnCopy",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBindRowToIncorrectSiteDefOnMove");
    PyDict_SetItemString(mod_dict,"oacBindRowToIncorrectSiteDefOnMove",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConflictingSiteDefsInTechAssociatedWithDesign");
    PyDict_SetItemString(mod_dict,"oacConflictingSiteDefsInTechAssociatedWithDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConflictingViaDefsInTechAssociatedWithDesign");
    PyDict_SetItemString(mod_dict,"oacConflictingViaDefsInTechAssociatedWithDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConflictingOpPointsInTechAssociatedWithDesign");
    PyDict_SetItemString(mod_dict,"oacConflictingOpPointsInTechAssociatedWithDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTextLinkAlreadyInitialized");
    PyDict_SetItemString(mod_dict,"oacTextLinkAlreadyInitialized",value);
    Py_DECREF(value);
    value=PyString_FromString("oacFailedToGetTextPlugIn");
    PyDict_SetItemString(mod_dict,"oacFailedToGetTextPlugIn",value);
    Py_DECREF(value);
    value=PyString_FromString("oacFailedToInitTextPlugIn");
    PyDict_SetItemString(mod_dict,"oacFailedToInitTextPlugIn",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotUnsetGlobalStateOfNetInTopModule");
    PyDict_SetItemString(mod_dict,"oacCannotUnsetGlobalStateOfNetInTopModule",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTermHasNoMustJoinTerm");
    PyDict_SetItemString(mod_dict,"oacTermHasNoMustJoinTerm",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidFigGroupMem");
    PyDict_SetItemString(mod_dict,"oacInvalidFigGroupMem",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidFig");
    PyDict_SetItemString(mod_dict,"oacInvalidFig",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidBlockObject");
    PyDict_SetItemString(mod_dict,"oacInvalidBlockObject",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotUndoUniquify");
    PyDict_SetItemString(mod_dict,"oacCannotUndoUniquify",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotCopyMoveUnboundViaToStrangerDesign");
    PyDict_SetItemString(mod_dict,"oacCannotCopyMoveUnboundViaToStrangerDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotCopyMoveUnboundRowToStrangerDesign");
    PyDict_SetItemString(mod_dict,"oacCannotCopyMoveUnboundRowToStrangerDesign",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCorruptedMustJoinTerms");
    PyDict_SetItemString(mod_dict,"oacCorruptedMustJoinTerms",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCorruptedSupplySensitivityTerms");
    PyDict_SetItemString(mod_dict,"oacCorruptedSupplySensitivityTerms",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCorruptedGroundSensitivityTerms");
    PyDict_SetItemString(mod_dict,"oacCorruptedGroundSensitivityTerms",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCorruptedSteinerConnRoutes");
    PyDict_SetItemString(mod_dict,"oacCorruptedSteinerConnRoutes",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPaddingForLaterDMRelease1");
    PyDict_SetItemString(mod_dict,"oacPaddingForLaterDMRelease1",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPaddingForLaterDMRelease2");
    PyDict_SetItemString(mod_dict,"oacPaddingForLaterDMRelease2",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPaddingForLaterDMRelease3");
    PyDict_SetItemString(mod_dict,"oacPaddingForLaterDMRelease3",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPaddingForLaterDMRelease4");
    PyDict_SetItemString(mod_dict,"oacPaddingForLaterDMRelease4",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPaddingForLaterDMRelease5");
    PyDict_SetItemString(mod_dict,"oacPaddingForLaterDMRelease5",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPaddingForLaterDMRelease6");
    PyDict_SetItemString(mod_dict,"oacPaddingForLaterDMRelease6",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPaddingForLaterDMRelease7");
    PyDict_SetItemString(mod_dict,"oacPaddingForLaterDMRelease7",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPaddingForLaterDMRelease8");
    PyDict_SetItemString(mod_dict,"oacPaddingForLaterDMRelease8",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPaddingForLaterDMRelease9");
    PyDict_SetItemString(mod_dict,"oacPaddingForLaterDMRelease9",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPaddingForLaterDMRelease10");
    PyDict_SetItemString(mod_dict,"oacPaddingForLaterDMRelease10",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPaddingForLaterDMRelease11");
    PyDict_SetItemString(mod_dict,"oacPaddingForLaterDMRelease11",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPaddingForLaterDMRelease12");
    PyDict_SetItemString(mod_dict,"oacPaddingForLaterDMRelease12",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPaddingForLaterDMRelease13");
    PyDict_SetItemString(mod_dict,"oacPaddingForLaterDMRelease13",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPaddingForLaterDMRelease14");
    PyDict_SetItemString(mod_dict,"oacPaddingForLaterDMRelease14",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPaddingForLaterDMRelease15");
    PyDict_SetItemString(mod_dict,"oacPaddingForLaterDMRelease15",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInstTermAlreadyInScanChain");
    PyDict_SetItemString(mod_dict,"oacInstTermAlreadyInScanChain",value);
    Py_DECREF(value);
    value=PyString_FromString("oacScanChainInstTermsNotOnSameInst");
    PyDict_SetItemString(mod_dict,"oacScanChainInstTermsNotOnSameInst",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaDesignMsgIds_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaDesignMsgIds",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaDesignMsgIds\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDesignObject
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDesignObject_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDesignObject_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDesignObjectObject* self = (PyoaDesignObjectObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDesignObject)
    {
        PyParamoaDesignObject p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDesignObject_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDesignObject, Choices are:\n"
        "    (oaDesignObject)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDesignObject_tp_dealloc(PyoaDesignObjectObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDesignObject_tp_repr(PyObject *ob)
{
    PyParamoaDesignObject value;
    int convert_status=PyoaDesignObject_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[36];
    sprintf(buffer,"<oaDesignObject::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDesignObject_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDesignObject v1;
    PyParamoaDesignObject v2;
    int convert_status1=PyoaDesignObject_Convert(ob1,&v1);
    int convert_status2=PyoaDesignObject_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDesignObject_Convert(PyObject* ob,PyParamoaDesignObject* result)
{
    if (ob == NULL) return 1;
    if (PyoaDesignObject_Check(ob)) {
        result->SetData( (oaDesignObject**) ((PyoaDesignObjectObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDesignObject Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDesignObject_FromoaDesignObject(oaDesignObject** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDesignObject* data=*value;
        if (data->getType()==oacOpPointHeaderType) return PyoaOpPointHeader_FromoaOpPointHeader((oaOpPointHeader**)value,borrow,lock);
        if (data->isDevice()) return PyoaDevice_FromoaDevice((oaDevice**)value,borrow,lock);
        if (data->isReducedModel()) return PyoaReducedModel_FromoaReducedModel((oaReducedModel**)value,borrow,lock);
        if (data->isOccObject()) return PyoaOccObject_FromoaOccObject((oaOccObject**)value,borrow,lock);
        if (data->isNode()) return PyoaNode_FromoaNode((oaNode**)value,borrow,lock);
        if (data->getType()==oacPoleResidueType) return PyoaPoleResidue_FromoaPoleResidue((oaPoleResidue**)value,borrow,lock);
        if (data->getType()==oacAnalysisOpPointType) return PyoaAnalysisOpPoint_FromoaAnalysisOpPoint((oaAnalysisOpPoint**)value,borrow,lock);
        if (data->getType()==oacElmoreType) return PyoaElmore_FromoaElmore((oaElmore**)value,borrow,lock);
        if (data->isModObject()) return PyoaModObject_FromoaModObject((oaModObject**)value,borrow,lock);
        if (data->getType()==oacDesignType) return PyoaDesign_FromoaDesign((oaDesign**)value,borrow,lock);
        if (data->getType()==oacAnalysisPointType) return PyoaAnalysisPoint_FromoaAnalysisPoint((oaAnalysisPoint**)value,borrow,lock);
        if (data->getType()==oacParasiticNetworkType) return PyoaParasiticNetwork_FromoaParasiticNetwork((oaParasiticNetwork**)value,borrow,lock);
        if (data->isBlockObject()) return PyoaBlockObject_FromoaBlockObject((oaBlockObject**)value,borrow,lock);
        if (data->getType()==oacSubNetworkType) return PyoaSubNetwork_FromoaSubNetwork((oaSubNetwork**)value,borrow,lock);
        PyObject* bself = PyoaDesignObject_Type.tp_alloc(&PyoaDesignObject_Type,0);
        if (bself == NULL) return bself;
        PyoaDesignObjectObject* self = (PyoaDesignObjectObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDesignObject_FromoaDesignObject(oaDesignObject* data)
{
    if (data) {
        if (data->getType()==oacOpPointHeaderType) return PyoaOpPointHeader_FromoaOpPointHeader((oaOpPointHeader*)data);
        if (data->isDevice()) return PyoaDevice_FromoaDevice((oaDevice*)data);
        if (data->isReducedModel()) return PyoaReducedModel_FromoaReducedModel((oaReducedModel*)data);
        if (data->isOccObject()) return PyoaOccObject_FromoaOccObject((oaOccObject*)data);
        if (data->isNode()) return PyoaNode_FromoaNode((oaNode*)data);
        if (data->getType()==oacPoleResidueType) return PyoaPoleResidue_FromoaPoleResidue((oaPoleResidue*)data);
        if (data->getType()==oacAnalysisOpPointType) return PyoaAnalysisOpPoint_FromoaAnalysisOpPoint((oaAnalysisOpPoint*)data);
        if (data->getType()==oacElmoreType) return PyoaElmore_FromoaElmore((oaElmore*)data);
        if (data->isModObject()) return PyoaModObject_FromoaModObject((oaModObject*)data);
        if (data->getType()==oacDesignType) return PyoaDesign_FromoaDesign((oaDesign*)data);
        if (data->getType()==oacAnalysisPointType) return PyoaAnalysisPoint_FromoaAnalysisPoint((oaAnalysisPoint*)data);
        if (data->getType()==oacParasiticNetworkType) return PyoaParasiticNetwork_FromoaParasiticNetwork((oaParasiticNetwork*)data);
        if (data->isBlockObject()) return PyoaBlockObject_FromoaBlockObject((oaBlockObject*)data);
        if (data->getType()==oacSubNetworkType) return PyoaSubNetwork_FromoaSubNetwork((oaSubNetwork*)data);
       PyObject* bself = PyoaDesignObject_Type.tp_alloc(&PyoaDesignObject_Type,0);
       if (bself == NULL) return bself;
       PyoaDesignObjectObject* self = (PyoaDesignObjectObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDesignObject_getDesign_doc[] = 
"Class: oaDesignObject, Function: getDesign\n"
"  Paramegers: ()\n"
"    Calls: oaDesign* getDesign() const\n"
"    Signature: getDesign|ptr-oaDesign|\n"
"    BrowseData: 1\n"
"    This function returns the design that contains the oaDesignObject.\n"
"    This returns the same value as oaObject::getDatabase , but this is more convenient where the object is known to be an oaDesignObject.\n"
;

static PyObject*
oaDesignObject_getDesign(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignObject data;
    int convert_status=PyoaDesignObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObjectObject* self=(PyoaDesignObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaDesignp result= (data.DataCall()->getDesign());
        return PyoaDesign_FromoaDesign(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignObject_isBlockObject_doc[] = 
"Class: oaDesignObject, Function: isBlockObject\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isBlockObject() const\n"
"    Signature: isBlockObject|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object lives in the block domain. All objects that describe the physical hierarchy are block objects. See oaBlockObject for more.\n"
;

static PyObject*
oaDesignObject_isBlockObject(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignObject data;
    int convert_status=PyoaDesignObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObjectObject* self=(PyoaDesignObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isBlockObject());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignObject_isDevice_doc[] = 
"Class: oaDesignObject, Function: isDevice\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isDevice() const\n"
"    Signature: isDevice|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object is an instance of one of the classes derived from the oaDevice class. The function returns a boolean value of true if the oaDesignObject is a parasitic device.\n"
;

static PyObject*
oaDesignObject_isDevice(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignObject data;
    int convert_status=PyoaDesignObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObjectObject* self=(PyoaDesignObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isDevice());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignObject_isModObject_doc[] = 
"Class: oaDesignObject, Function: isModObject\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isModObject() const\n"
"    Signature: isModObject|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object lives in the module domain. All objects that describe the purely logical hierarchy are module objects. See oaModObject for more.\n"
;

static PyObject*
oaDesignObject_isModObject(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignObject data;
    int convert_status=PyoaDesignObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObjectObject* self=(PyoaDesignObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isModObject());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignObject_isNode_doc[] = 
"Class: oaDesignObject, Function: isNode\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isNode() const\n"
"    Signature: isNode|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object is an instance of one of the classes derived from the oaNode class. The function returns a boolean value of true if the oaDesignObject is a parasitic node.\n"
;

static PyObject*
oaDesignObject_isNode(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignObject data;
    int convert_status=PyoaDesignObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObjectObject* self=(PyoaDesignObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isNode());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignObject_isOccObject_doc[] = 
"Class: oaDesignObject, Function: isOccObject\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isOccObject() const\n"
"    Signature: isOccObject|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object lives in the occurrence domain. All instance, net and terminal related objects in either the module domain or the block domain are reflected as corresponding objects in the occurrence domain. The occurrence objects are unfolded so that there are distinct instances of them for every path thru the hierarchy to the object.\n"
"    See oaOccObject for more.\n"
;

static PyObject*
oaDesignObject_isOccObject(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignObject data;
    int convert_status=PyoaDesignObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObjectObject* self=(PyoaDesignObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isOccObject());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignObject_isReducedModel_doc[] = 
"Class: oaDesignObject, Function: isReducedModel\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isReducedModel() const\n"
"    Signature: isReducedModel|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object is an instance of one of the classes derived from the oaReducedModel class. The function returns a boolean value of true if the oaDesignObject is a reduced parasitic model.\n"
;

static PyObject*
oaDesignObject_isReducedModel(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignObject data;
    int convert_status=PyoaDesignObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObjectObject* self=(PyoaDesignObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isReducedModel());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignObject_isStdDevice_doc[] = 
"Class: oaDesignObject, Function: isStdDevice\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isStdDevice() const\n"
"    Signature: isStdDevice|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object is an instance of one of the classes derived from the oaStdDevice class. The function returns a boolean value of true if the oaDesignObject is a standard parasitic device.\n"
;

static PyObject*
oaDesignObject_isStdDevice(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignObject data;
    int convert_status=PyoaDesignObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObjectObject* self=(PyoaDesignObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isStdDevice());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignObject_isNull_doc[] =
"Class: oaDesignObject, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDesignObject_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDesignObject data;
    int convert_status=PyoaDesignObject_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDesignObject_assign_doc[] = 
"Class: oaDesignObject, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDesignObject_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDesignObject data;
  int convert_status=PyoaDesignObject_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDesignObject p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDesignObject_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDesignObject_methodlist[] = {
    {"getDesign",(PyCFunction)oaDesignObject_getDesign,METH_VARARGS,oaDesignObject_getDesign_doc},
    {"isBlockObject",(PyCFunction)oaDesignObject_isBlockObject,METH_VARARGS,oaDesignObject_isBlockObject_doc},
    {"isDevice",(PyCFunction)oaDesignObject_isDevice,METH_VARARGS,oaDesignObject_isDevice_doc},
    {"isModObject",(PyCFunction)oaDesignObject_isModObject,METH_VARARGS,oaDesignObject_isModObject_doc},
    {"isNode",(PyCFunction)oaDesignObject_isNode,METH_VARARGS,oaDesignObject_isNode_doc},
    {"isOccObject",(PyCFunction)oaDesignObject_isOccObject,METH_VARARGS,oaDesignObject_isOccObject_doc},
    {"isReducedModel",(PyCFunction)oaDesignObject_isReducedModel,METH_VARARGS,oaDesignObject_isReducedModel_doc},
    {"isStdDevice",(PyCFunction)oaDesignObject_isStdDevice,METH_VARARGS,oaDesignObject_isStdDevice_doc},
    {"isNull",(PyCFunction)oaDesignObject_tp_isNull,METH_VARARGS,oaDesignObject_isNull_doc},
    {"assign",(PyCFunction)oaDesignObject_tp_assign,METH_VARARGS,oaDesignObject_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDesignObject_doc[] = 
"Class: oaDesignObject\n"
"  This is the abstract base class for all managed objects that are specific to oaDesigns.\n"
"  There is a substantial tree of classes derived from oaDesignObject. For most of these classes, an oaDesignObject can be classified using its oaType value. See oaObject::getType for more information. For the classes derived from oaDesignObject that are base classes, oaDesignObject has functions to test for membership in that base class.\n"
"  Note that oaProp , oaGroup , and oaAppObject instances can be stored in an oaDesign even though they are not oaDesignObjects. These classes may appear in every database, so they are classified only as oaObjects.\n"
"  Note that a number of classes that were direct descendants of oaDesignObject before OpenAccess version 2.1 are now descended from oaBlockObject .\n"
"Constructors:\n"
"  Paramegers: (oaDesignObject)\n"
"    Calls: (const oaDesignObject&)\n"
"    Signature: oaDesignObject||cref-oaDesignObject,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDesignObject_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDesignObject",
    sizeof(PyoaDesignObjectObject),
    0,
    (destructor)oaDesignObject_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDesignObject_tp_compare,	/* tp_compare */
    (reprfunc)oaDesignObject_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDesignObject_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDesignObject_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDesignObject_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDesignObject_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDesignObject_Type)<0) {
      printf("** PyType_Ready failed for: oaDesignObject\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDesignObject",
           (PyObject*)(&PyoaDesignObject_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDesignObject\n");
       return -1;
    }
    return 0;
}


// ==================================================================
// Array for class: oaDesignObject
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDesignObject_Array_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDesignObject_Array_Type);
    PyObject* gself = type->tp_alloc(type,0);
    if (gself == NULL) return gself;
    PyoaDesignObject_ArrayObject* self = (PyoaDesignObject_ArrayObject*)gself;
    self->borrow = 0;
    self->locks=NULL;
    static char *kwlist [] = { NULL } ;
    /* Case: () */ 
    {
        if (PyArg_ParseTuple(args,"")) {
            return gself;
        }
    }
    PyErr_Clear();
    /* Case: (int) */
    {
        int p1;
        if (PyArg_ParseTuple(args,(char*)"i",&p1)) {
            self->data.SetLen(p1);
            return gself;
        }
    }
    PyErr_Clear();
    /* Case: (oaDesignObject_Array) */
    {
        PyParamoaDesignObject_Array p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDesignObject_Array_Convert,&p1)) {
            self->data.TakeAway(p1);
            return gself;
        }
    }
    /* Error */
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDesignObject_Array, Choices are:\n"
        "    ()\n"
        "    (int)\n"
        "    (oaDesignObject_Array)\n"
    );
    Py_DECREF(gself);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDesignObject_Array_dealloc(PyObject* gself)
{
    PyoaDesignObject_ArrayObject* self = (PyoaDesignObject_ArrayObject*)gself;
    Py_XDECREF(self->locks);
    self->ob_type->tp_free(gself);
}

// ------------------------------------------------------------------
static PyObject*
oaDesignObject_Array_str(PyObject *ob)
{
    PyParamoaDesignObject_Array value;
    int convert_status=PyoaDesignObject_Array_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* lst=PyoaDesignObject_Array_CreateList(value);
    PyObject* result=PyObject_Str(lst);
    Py_DECREF(lst);
    return result;
}

// ------------------------------------------------------------------
static PyObject*
oaDesignObject_Array_repr(PyObject *ob)
{
    PyParamoaDesignObject_Array value;
    int convert_status=PyoaDesignObject_Array_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* lst=PyoaDesignObject_Array_CreateList(value);
    PyObject* result=PyObject_Repr(lst);
    Py_DECREF(lst);
    return result;
}

// ------------------------------------------------------------------
static int
oaDesignObject_Array_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDesignObject_Array p1;
    PyParamoaDesignObject_Array p2;
    int s1=PyoaDesignObject_Array_Convert(ob1,&p1);
    int s2=PyoaDesignObject_Array_Convert(ob2,&p2);
    assert(s1!=0);
    assert(s2!=0);
    PyObject* l1=PyoaDesignObject_Array_CreateList(p1);
    PyObject* l2=PyoaDesignObject_Array_CreateList(p2);
    int result=PyObject_Compare(l1,l2);
    Py_DECREF(l1);
    Py_DECREF(l2);
    return result;
}

// ------------------------------------------------------------------
int
PyoaDesignObject_Array_Convert(PyObject* ob,PyParamoaDesignObject_Array* result)
{
  Pyoa_ssize_t len,i;
  if (PyoaDesignObject_Array_Check(ob)) {
    PyoaDesignObject_ArrayObject* self = (PyoaDesignObject_ArrayObject*)ob;
    result->Borrow(self->data);
  }
  else if (PyList_Check(ob)) {
    len=PyList_Size(ob);
    result->SetLen(len);
    PyParamoaDesignObject data;
    for(i=0;i<len;i++) {
      PyObject* a=PyList_GetItem(ob,i);
      if (!PyoaDesignObject_Convert(a,&data)) return 0;
      result->SetItem(i,data.Data());
    }
  }
  else if (PyTuple_Check(ob)) {
    len=PyTuple_Size(ob);
    result->SetLen(len);
    PyParamoaDesignObject data;
    for(i=0;i<len;i++) {
      PyObject* a=PyTuple_GetItem(ob,i);
      if (!PyoaDesignObject_Convert(a,&data)) return 0;
      result->SetItem(i,data.Data());
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError,
      "Convertion of parameter to class: oaDesignObject_Array Failed");
    return 0;
  }
  return 1;
}

// ------------------------------------------------------------------
PyObject* PyoaDesignObject_Array_FromoaDesignObject_Array(const oaDesignObject_Array& value)
{
  PyObject* gself = PyoaDesignObject_Array_Type.tp_alloc(&PyoaDesignObject_Array_Type,0);
  if (gself == NULL) return gself;
  PyoaDesignObject_ArrayObject* self = (PyoaDesignObject_ArrayObject*)gself;
  self->data = value;
  self->borrow = 0;
  self->locks=NULL;
  return gself;
}

// ------------------------------------------------------------------
PyObject* PyoaDesignObject_Array_FromoaDesignObject_Array(PyTypeoaDesignObject* data,Pyoa_ssize_t len,PyObject* lock)
{
  PyObject* gself = PyoaDesignObject_Array_Type.tp_alloc(&PyoaDesignObject_Array_Type,0);
  if (gself == NULL) return gself;
  PyoaDesignObject_ArrayObject* self = (PyoaDesignObject_ArrayObject*)gself;
  self->data.Borrow(data,len);
  self->borrow = 1;
  self->locks=NULL;
  if (lock) PyoaLockObject(self->locks,lock);
  return gself;
}

// ------------------------------------------------------------------
PyObject* PyoaDesignObject_Array_CreateList(PyParamoaDesignObject_Array& value)
{
  Pyoa_ssize_t i;
  PyObject* lst=PyList_New(value.Len());
  for(i=0;i<value.Len();i++) {
    PyObject* ob=PyoaDesignObject_FromoaDesignObject(value.Data()[i]);
    PyList_SetItem(lst,i,ob);
  }
  return lst;
}

// ------------------------------------------------------------------
// Methods
// ------------------------------------------------------------------
static char oaDesignObject_Array_assign_doc[] = 
"Class: oaDesignObject_Array, Function: assign\n"
"  Paramegers: (oaDesignObject_Array)\n"
"    This function assigns the current value.\n"
;

static PyObject*
oaDesignObject_Array_assign(PyObject* ob, PyObject *args)
{
  PyoaDesignObject_ArrayObject* self=(PyoaDesignObject_ArrayObject*)ob;
  try {
    PyParamoaDesignObject_Array p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDesignObject_Array_Convert,&p1)) {
        self->data=p1;
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}
// ------------------------------------------------------------------
static char oaDesignObject_Array_list_doc[] = 
"Class: oaDesignObject_Array, Function: list\n"
"  Paramegers: ()\n"
"    This function returns the current value as a list.\n"
;

static PyObject*
oaDesignObject_Array_list(PyObject* ob, PyObject *args)
{
  PyoaDesignObject_ArrayObject* self=(PyoaDesignObject_ArrayObject*)ob;
  try {
    if (PyArg_ParseTuple(args,(char*)"")) {
      return PyoaDesignObject_Array_CreateList(self->data);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}
// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------
static PyMethodDef oaDesignObject_Array_methodlist[] = {
    {"assign",(PyCFunction)oaDesignObject_Array_assign,METH_VARARGS,oaDesignObject_Array_assign_doc},
    {"list",(PyCFunction)oaDesignObject_Array_list,METH_VARARGS,oaDesignObject_Array_list_doc},
   {NULL,NULL,0,NULL}
};

// ------------------------------------------------------------------
static PyObject*
oaDesignObject_Array_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaDesignObject_ArrayObject* self=(PyoaDesignObject_ArrayObject*)ob;
  try {
    PyParamoaDesignObject_Array data;
    int convert_status=PyoaDesignObject_Array_Convert(ob,&data);
    assert(convert_status!=0);
    if (index<0 || index>=data.Len()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    return PyoaDesignObject_FromoaDesignObject(data.GetItemPtr(index),1,self->locks);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static Pyoa_ssize_t
oaDesignObject_Array_index_get_length(PyObject* ob)
{
    PyParamoaDesignObject_Array data;
    int convert_status=PyoaDesignObject_Array_Convert(ob,&data);
    assert(convert_status!=0);
    return data.Len();
}

// ------------------------------------------------------------------
static int
oaDesignObject_Array_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaDesignObject_Array data;
    PyParamoaDesignObject dataitem;
    int convert_status=PyoaDesignObject_Array_Convert(ob,&data);
    assert(convert_status!=0);
    if (index<0 || index>=data.Len()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    if (PyoaDesignObject_Convert(value,&dataitem)==0) return -1;
    data.SetItem(index,dataitem.Data());
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return 0;
  }
}

// ------------------------------------------------------------------
static char oaDesignObject_Array_doc[] =
"Class: oaDesignObject_Array\n"
"  The oaDesignObject_Array utility class provides an array of oaDesignObject.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaDesignObject_Array()\n"
"    Signature: oaDesignObject_Array||\n"
"    This is the default constructor for the oaDesignObject_Array class. This constructor creates an empty oaDesignObject_Array.\n"
"  Paramegers: (oaDesignObject_Array)\n"
"    Calls: (const oaDesignObject_Array&)\n"
"    Signature: oaDesignObject_Array||cref-oaDesignObject_Array,\n"
;

// ------------------------------------------------------------------
static PySequenceMethods oaDesignObject_Array_as_sequence = {
    (Pyoa_inquiry)oaDesignObject_Array_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,              /* sq_concat */
    (Pyoa_intargfunc)0,              /* sq_repeat */
    (Pyoa_intargfunc)oaDesignObject_Array_index_get, /* sq_item */
    (Pyoa_intintargfunc)0,           /* sq_slice */
    (Pyoa_intobjargproc)oaDesignObject_Array_index_set,      /* sq_ass_item */
};

// ------------------------------------------------------------------
PyTypeObject PyoaDesignObject_Array_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDesignObject_Array",
    sizeof(PyoaDesignObject_ArrayObject),
    0,
    oaDesignObject_Array_dealloc, /* tp_dealloc */
    0,  /* tp_print */
    0,                                  /* tp_getattr */
    0,                                  /* tp_setattr */
    oaDesignObject_Array_compare,    /* tp_compare */
    oaDesignObject_Array_repr,      /* tp_repr */
    0,                                  /* tp_as_number */
    &oaDesignObject_Array_as_sequence,  /* tp_as_sequence */
    0,                                  /* tp_as_mapping */
    0,                                  /* tp_as_hash */
    0,                                  /* tp_as_call */
    oaDesignObject_Array_str,               /* tp_str */
    0,                                  /* tp_getattro */
    0,                                  /* tp_setattro */
    0,                                  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDesignObject_Array_doc, /* tp_doc */
    0,                                  /* tp_traverse */
    0,                                  /* tp_clear */
    0,                                  /* tp_richcompre */
    0,                                  /* tp_weaklistoffset */
    0,                                  /* tp_iter */
    0,                                  /* tp_iternext */
    oaDesignObject_Array_methodlist, /* tp_methods */
    0,                                  /* tp_members */
    0,                                  /* tp_getset */
    0,                                  /* tp_base */
    0,                                  /* tp_dict */
    0,                                  /* tp_descr_get */
    0,                                  /* tp_descr_set */
    0,                                  /* tp_dictoffset */
    0,                                  /* tp_init */
    PyType_GenericAlloc,        /* tp_alloc */
    oaDesignObject_Array_new, /* tp_new */
    _PyObject_Del,      /* tp_free */
};


// ------------------------------------------------------------------
int
PyoaDesignObject_Array_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDesignObject_Array_Type)<0) {
      printf("** PyType_Ready failed for: oaDesignObject_Array\n");
      return -1;
    }
    if (PyDict_SetItemString(mod_dict,"oaDesignObject_Array",
           (PyObject*)(&PyoaDesignObject_Array_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDesignObject_Array\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDesignObjectIter
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDesignObjectIter_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDesignObjectIter_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDesignObjectIterObject* self = (PyoaDesignObjectIterObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaCollection_oaDesignObject_oaNode)
    {
        PyParamoaCollection_oaDesignObject_oaNode p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaCollection_oaDesignObject_oaNode_Convert,&p1)) {
            self->value =  new oaDesignObjectIter(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaCollection_oaDesignObject_oaParasiticNetwork)
    {
        PyParamoaCollection_oaDesignObject_oaParasiticNetwork p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaCollection_oaDesignObject_oaParasiticNetwork_Convert,&p1)) {
            self->value =  new oaDesignObjectIter(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaDesignObjectIter)
    {
        PyParamoaDesignObjectIter p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDesignObjectIter_Convert,&p1)) {
            self->value =  new oaDesignObjectIter(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDesignObjectIter, Choices are:\n"
        "    (oaCollection_oaDesignObject_oaNode)\n"
        "    (oaCollection_oaDesignObject_oaParasiticNetwork)\n"
        "    (oaDesignObjectIter)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDesignObjectIter_tp_dealloc(PyoaDesignObjectIterObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDesignObjectIter_tp_repr(PyObject *ob)
{
    PyParamoaDesignObjectIter value;
    int convert_status=PyoaDesignObjectIter_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[40];
    sprintf(buffer,"<oaDesignObjectIter::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDesignObjectIter_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDesignObjectIter v1;
    PyParamoaDesignObjectIter v2;
    int convert_status1=PyoaDesignObjectIter_Convert(ob1,&v1);
    int convert_status2=PyoaDesignObjectIter_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
static PyObject*
oaDesignObjectIter_getiter(PyObject *self)
{
    Py_INCREF(self);
    return self;
}

// ------------------------------------------------------------------
static PyObject*
oaDesignObjectIter_iternext(PyObject *self)
{
  try {
    PyParamoaDesignObjectIter ob;
    int convert_status=PyoaDesignObjectIter_Convert(self,&ob);
    assert(convert_status!=0);
    oaDesignObject* result;
    result=ob.DataCall()->getNext();
    if (result==NULL) {
       PyErr_SetObject(PyExc_StopIteration,Py_None);
       return NULL;
    }
    return PyoaDesignObject_FromoaDesignObject(result);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
int
PyoaDesignObjectIter_Convert(PyObject* ob,PyParamoaDesignObjectIter* result)
{
    if (ob == NULL) return 1;
    if (PyoaDesignObjectIter_Check(ob)) {
        result->SetData(  ((PyoaDesignObjectIterObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDesignObjectIter Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDesignObjectIter_FromoaDesignObjectIter(oaDesignObjectIter* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaDesignObjectIter_Type.tp_alloc(&PyoaDesignObjectIter_Type,0);
        if (bself == NULL) return bself;
        PyoaDesignObjectIterObject* self = (PyoaDesignObjectIterObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDesignObjectIter_getNext_doc[] = 
"Class: oaDesignObjectIter, Function: getNext\n"
"  Paramegers: ()\n"
"    Calls: oaDesignObject* getNext()\n"
"    Signature: getNext|ptr-oaDesignObject|\n"
"    BrowseData: 1\n"
"    Function getNext\n"
;

static PyObject*
oaDesignObjectIter_getNext(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignObjectIter data;
    int convert_status=PyoaDesignObjectIter_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObjectIterObject* self=(PyoaDesignObjectIterObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaDesignObjectp result= (data.DataCall()->getNext());
        return PyoaDesignObject_FromoaDesignObject(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignObjectIter_next_doc[] = 
"Class: oaDesignObjectIter, Function: next\n"
"  Paramegers: ()\n"
"    Calls: oaDesignObject* next()\n"
"    Signature: next|ptr-oaDesignObject|,\n"
"    BrowseData: 1\n"
"    get next value or raise StopIteration\n"
;

static PyObject*
oaDesignObjectIter_next(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignObjectIter data;
    int convert_status=PyoaDesignObjectIter_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObjectIterObject* self=(PyoaDesignObjectIterObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaDesignObjectp result= (data.DataCall()->getNext());
        if (result==NULL) {
            PyErr_SetObject(PyExc_StopIteration,Py_None);
            return NULL;
        }
        return PyoaDesignObject_FromoaDesignObject(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignObjectIter_reset_doc[] = 
"Class: oaDesignObjectIter, Function: reset\n"
"  Paramegers: ()\n"
"    Calls: void reset()\n"
"    Signature: reset|void-void|\n"
"    BrowseData: 0\n"
"    Function reset\n"
;

static PyObject*
oaDesignObjectIter_reset(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignObjectIter data;
    int convert_status=PyoaDesignObjectIter_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignObjectIterObject* self=(PyoaDesignObjectIterObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->reset();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaDesignObjectIter_assign_doc[] = 
"Class: oaDesignObjectIter, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDesignObjectIter_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDesignObjectIter data;
  int convert_status=PyoaDesignObjectIter_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDesignObjectIter p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDesignObjectIter_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDesignObjectIter_methodlist[] = {
    {"getNext",(PyCFunction)oaDesignObjectIter_getNext,METH_VARARGS,oaDesignObjectIter_getNext_doc},
    {"next",(PyCFunction)oaDesignObjectIter_next,METH_VARARGS,oaDesignObjectIter_next_doc},
    {"reset",(PyCFunction)oaDesignObjectIter_reset,METH_VARARGS,oaDesignObjectIter_reset_doc},
    {"assign",(PyCFunction)oaDesignObjectIter_tp_assign,METH_VARARGS,oaDesignObjectIter_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDesignObjectIter_doc[] = 
"Class: oaDesignObjectIter\n"
"  Class type oaDesignObjectIter\n"
"Constructors:\n"
"  Paramegers: (oaCollection_oaDesignObject_oaNode)\n"
"    Calls: oaDesignObjectIter(const oaCollection_oaDesignObject_oaNode& c)\n"
"    Signature: oaDesignObjectIter||cref-oaCollection_oaDesignObject_oaNode,\n"
"    Constructor oaDesignObjectIter\n"
"  Paramegers: (oaCollection_oaDesignObject_oaParasiticNetwork)\n"
"    Calls: oaDesignObjectIter(const oaCollection_oaDesignObject_oaParasiticNetwork& c)\n"
"    Signature: oaDesignObjectIter||cref-oaCollection_oaDesignObject_oaParasiticNetwork,\n"
"    Constructor oaDesignObjectIter\n"
"  Paramegers: (oaDesignObjectIter)\n"
"    Calls: oaDesignObjectIter(const oaDesignObjectIter& iter)\n"
"    Signature: oaDesignObjectIter||cref-oaDesignObjectIter,\n"
"    Constructor oaDesignObjectIter\n"
"  Paramegers: (oaDesignObjectIter)\n"
"    Calls: (const oaDesignObjectIter&)\n"
"    Signature: oaDesignObjectIter||cref-oaDesignObjectIter,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDesignObjectIter_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDesignObjectIter",
    sizeof(PyoaDesignObjectIterObject),
    0,
    (destructor)oaDesignObjectIter_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDesignObjectIter_tp_compare,	/* tp_compare */
    (reprfunc)oaDesignObjectIter_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDesignObjectIter_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    (getiterfunc)oaDesignObjectIter_getiter,	/* tp_iter */
    (iternextfunc)oaDesignObjectIter_iternext,	/* tp_iternext */
    oaDesignObjectIter_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDesignObjectIter_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDesignObjectIter_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDesignObjectIter_Type)<0) {
      printf("** PyType_Ready failed for: oaDesignObjectIter\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDesignObjectIter",
           (PyObject*)(&PyoaDesignObjectIter_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDesignObjectIter\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDesignUndoObserver
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDesignUndoObserver_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDesignUndoObserver_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDesignUndoObserverObject* self = (PyoaDesignUndoObserverObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value =  new oaDesignUndoObserver(p1.Data());
            }
            else {
                pyv_oaDesignUndoObserver* p=new pyv_oaDesignUndoObserver(p1.Data());
                p->pyob=self;
                self->value= p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value =  new oaDesignUndoObserver(p1.Data(),p2.Data());
            }
            else {
                pyv_oaDesignUndoObserver* p=new pyv_oaDesignUndoObserver(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDesignUndoObserver, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDesignUndoObserver_tp_dealloc(PyoaDesignUndoObserverObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDesignUndoObserver_tp_repr(PyObject *ob)
{
    PyParamoaDesignUndoObserver value;
    int convert_status=PyoaDesignUndoObserver_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaDesignUndoObserver::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDesignUndoObserver_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDesignUndoObserver v1;
    PyParamoaDesignUndoObserver v2;
    int convert_status1=PyoaDesignUndoObserver_Convert(ob1,&v1);
    int convert_status2=PyoaDesignUndoObserver_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDesignUndoObserver_Convert(PyObject* ob,PyParamoaDesignUndoObserver* result)
{
    if (ob == NULL) return 1;
    if (PyoaDesignUndoObserver_Check(ob)) {
        result->SetData(  ((PyoaDesignUndoObserverObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDesignUndoObserver Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDesignUndoObserver_FromoaDesignUndoObserver(oaDesignUndoObserver* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaDesignUndoObserver_Type.tp_alloc(&PyoaDesignUndoObserver_Type,0);
        if (bself == NULL) return bself;
        PyoaDesignUndoObserverObject* self = (PyoaDesignUndoObserverObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaDesignUndoObserver::pyv_oaDesignUndoObserver(oaUInt4 p1)
 : pyob(NULL),
   oaDesignUndoObserver(p1)
{
}

// ------------------------------------------------------------------
pyv_oaDesignUndoObserver::pyv_oaDesignUndoObserver(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaDesignUndoObserver(p1,p2)
{
}

// ------------------------------------------------------------------
void pyv_oaDesignUndoObserver::onEndRedo(oaDesign* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onEndRedo");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaDesignUndoObserver::onEndRedo was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaDesign_FromoaDesign(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaDesignUndoObserver::onEndRedo had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaDesignUndoObserver::onEndUndo(oaDesign* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onEndUndo");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaDesignUndoObserver::onEndUndo was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaDesign_FromoaDesign(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaDesignUndoObserver::onEndUndo had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaDesignUndoObserver::onStartRedo(oaDesign* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onStartRedo");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaDesignUndoObserver::onStartRedo was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaDesign_FromoaDesign(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaDesignUndoObserver::onStartRedo had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaDesignUndoObserver::onStartUndo(oaDesign* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onStartUndo");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaDesignUndoObserver::onStartUndo was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaDesign_FromoaDesign(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaDesignUndoObserver::onStartUndo had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDesignUndoObserver_enable_doc[] = 
"Class: oaDesignUndoObserver, Function: enable\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: void enable(oaBoolean enabledIn)\n"
"    Signature: enable|void-void|simple-oaBoolean,\n"
"    This function activates or deactivates this observer.\n"
"    enabledIn\n"
"    Indicates whether to make this observer active or inactive\n"
;

static PyObject*
oaDesignUndoObserver_enable(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignUndoObserver data;
    int convert_status=PyoaDesignUndoObserver_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignUndoObserverObject* self=(PyoaDesignUndoObserverObject*)ob;

    PyParamoaBoolean p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBoolean_Convert,&p1)) {
        data.DataCall()->enable(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignUndoObserver_isEnabled_doc[] = 
"Class: oaDesignUndoObserver, Function: isEnabled\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isEnabled()\n"
"    Signature: isEnabled|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value indicating whether this observer is active.\n"
;

static PyObject*
oaDesignUndoObserver_isEnabled(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignUndoObserver data;
    int convert_status=PyoaDesignUndoObserver_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignUndoObserverObject* self=(PyoaDesignUndoObserverObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isEnabled());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignUndoObserver_onEndRedo_doc[] = 
"Class: oaDesignUndoObserver, Function: onEndRedo\n"
"  Paramegers: (oaDesign)\n"
"    Calls: virtual void onEndRedo(oaDesign* design)\n"
"    Signature: onEndRedo|void-void|ptr-oaDesign,\n"
"    This function is called just after the undo mechanism finishes redoing changes to the specified design . The application's derived class should implement this function to receive notification when a redo event has occurred.\n"
;

static PyObject*
oaDesignUndoObserver_onEndRedo(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignUndoObserver data;
    int convert_status=PyoaDesignUndoObserver_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignUndoObserverObject* self=(PyoaDesignUndoObserverObject*)ob;

    PyParamoaDesign p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaDesign_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaDesignUndoObserver::onEndRedo(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignUndoObserver_onEndUndo_doc[] = 
"Class: oaDesignUndoObserver, Function: onEndUndo\n"
"  Paramegers: (oaDesign)\n"
"    Calls: virtual void onEndUndo(oaDesign* design)\n"
"    Signature: onEndUndo|void-void|ptr-oaDesign,\n"
"    This function is called just after the undo mechanism finishes undoing changes to the specified design . The application's derived class should implement this function to receive notification when an undo event occurs.\n"
;

static PyObject*
oaDesignUndoObserver_onEndUndo(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignUndoObserver data;
    int convert_status=PyoaDesignUndoObserver_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignUndoObserverObject* self=(PyoaDesignUndoObserverObject*)ob;

    PyParamoaDesign p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaDesign_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaDesignUndoObserver::onEndUndo(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignUndoObserver_onStartRedo_doc[] = 
"Class: oaDesignUndoObserver, Function: onStartRedo\n"
"  Paramegers: (oaDesign)\n"
"    Calls: virtual void onStartRedo(oaDesign* design)\n"
"    Signature: onStartRedo|void-void|ptr-oaDesign,\n"
"    This function is called just before the undo mechanism redoes changes to the specified design . The application's derived class should implement this function to receive notification when a redo event is about to occur.\n"
;

static PyObject*
oaDesignUndoObserver_onStartRedo(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignUndoObserver data;
    int convert_status=PyoaDesignUndoObserver_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignUndoObserverObject* self=(PyoaDesignUndoObserverObject*)ob;

    PyParamoaDesign p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaDesign_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaDesignUndoObserver::onStartRedo(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDesignUndoObserver_onStartUndo_doc[] = 
"Class: oaDesignUndoObserver, Function: onStartUndo\n"
"  Paramegers: (oaDesign)\n"
"    Calls: virtual void onStartUndo(oaDesign* design)\n"
"    Signature: onStartUndo|void-void|ptr-oaDesign,\n"
"    This function is called just before the undo mechanism undoes changes to the specified design . The application's derived class should implement this function to receive notification when an undo event is about to occur.\n"
;

static PyObject*
oaDesignUndoObserver_onStartUndo(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignUndoObserver data;
    int convert_status=PyoaDesignUndoObserver_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDesignUndoObserverObject* self=(PyoaDesignUndoObserverObject*)ob;

    PyParamoaDesign p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaDesign_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaDesignUndoObserver::onStartUndo(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaDesignUndoObserver_assign_doc[] = 
"Class: oaDesignUndoObserver, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDesignUndoObserver_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDesignUndoObserver data;
  int convert_status=PyoaDesignUndoObserver_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDesignUndoObserver p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDesignUndoObserver_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDesignUndoObserver_methodlist[] = {
    {"enable",(PyCFunction)oaDesignUndoObserver_enable,METH_VARARGS,oaDesignUndoObserver_enable_doc},
    {"isEnabled",(PyCFunction)oaDesignUndoObserver_isEnabled,METH_VARARGS,oaDesignUndoObserver_isEnabled_doc},
    {"onEndRedo",(PyCFunction)oaDesignUndoObserver_onEndRedo,METH_VARARGS,oaDesignUndoObserver_onEndRedo_doc},
    {"onEndUndo",(PyCFunction)oaDesignUndoObserver_onEndUndo,METH_VARARGS,oaDesignUndoObserver_onEndUndo_doc},
    {"onStartRedo",(PyCFunction)oaDesignUndoObserver_onStartRedo,METH_VARARGS,oaDesignUndoObserver_onStartRedo_doc},
    {"onStartUndo",(PyCFunction)oaDesignUndoObserver_onStartUndo,METH_VARARGS,oaDesignUndoObserver_onStartUndo_doc},
    {"assign",(PyCFunction)oaDesignUndoObserver_tp_assign,METH_VARARGS,oaDesignUndoObserver_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDesignUndoObserver_doc[] = 
"Class: oaDesignUndoObserver\n"
"  The oaDesignUndoObserver class implements an observer for actions associated with undo and redo functions. Applications that need to receive notification of these actions should derive from this class and implement the appropriate observer functions.\n"
"  See oaObserver for a general description of how callbacks are used.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaDesignUndoObserver(oaUInt4 priorityIn)\n"
"    Signature: oaDesignUndoObserver||simple-oaUInt4,simple-oaBoolean,\n"
"    This function constructs an oaDesignUndoObserver callback object.\n"
"    priorityIn\n"
"    The priority value of the callback object\n"
"    enabledIn\n"
"    Indicates if this callback is activated\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaDesignUndoObserver(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaDesignUndoObserver||simple-oaUInt4,simple-oaBoolean,\n"
"    This function constructs an oaDesignUndoObserver callback object.\n"
"    priorityIn\n"
"    The priority value of the callback object\n"
"    enabledIn\n"
"    Indicates if this callback is activated\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDesignUndoObserver_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDesignUndoObserver",
    sizeof(PyoaDesignUndoObserverObject),
    0,
    (destructor)oaDesignUndoObserver_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDesignUndoObserver_tp_compare,	/* tp_compare */
    (reprfunc)oaDesignUndoObserver_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDesignUndoObserver_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDesignUndoObserver_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDesignUndoObserver_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDesignUndoObserver_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDesignUndoObserver_Type)<0) {
      printf("** PyType_Ready failed for: oaDesignUndoObserver\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDesignUndoObserver",
           (PyObject*)(&PyoaDesignUndoObserver_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDesignUndoObserver\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDetachVisibilityEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaDetachVisibilityEnum_Convert(PyObject* ob,PyParamoaDetachVisibilityEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacInheritFromSourceModuleDetachVisibility")==0) { result->SetData(oacInheritFromSourceModuleDetachVisibility); return 1;}
        if (strcasecmp(str,"oacVisibleToBlockDomainDetachVisibility")==0) { result->SetData(oacVisibleToBlockDomainDetachVisibility); return 1;}
        if (strcasecmp(str,"oacExcludeFromBlockDomainDetachVisibility")==0) { result->SetData(oacExcludeFromBlockDomainDetachVisibility); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaDetachVisibilityEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDetachVisibilityEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaDetachVisibilityEnum_FromoaDetachVisibilityEnum(oaDetachVisibilityEnum ob)
{
    if (ob==oacInheritFromSourceModuleDetachVisibility) return PyString_FromString("oacInheritFromSourceModuleDetachVisibility");
    if (ob==oacVisibleToBlockDomainDetachVisibility) return PyString_FromString("oacVisibleToBlockDomainDetachVisibility");
    if (ob==oacExcludeFromBlockDomainDetachVisibility) return PyString_FromString("oacExcludeFromBlockDomainDetachVisibility");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaDetachVisibilityEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaDetachVisibilityEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaDetachVisibilityEnum_FromoaDetachVisibilityEnum(oaDetachVisibilityEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaDetachVisibilityEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaDetachVisibilityEnum_doc[] =
"Type convert function for enum: oaDetachVisibilityEnum";
                               
static PyMethodDef PyoaDetachVisibilityEnum_method =
  {"oaDetachVisibilityEnum",(PyCFunction)PyoaDetachVisibilityEnum_TypeFunction,METH_VARARGS,oaDetachVisibilityEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaDetachVisibilityEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacInheritFromSourceModuleDetachVisibility");
    PyDict_SetItemString(mod_dict,"oacInheritFromSourceModuleDetachVisibility",value);
    Py_DECREF(value);
    value=PyString_FromString("oacVisibleToBlockDomainDetachVisibility");
    PyDict_SetItemString(mod_dict,"oacVisibleToBlockDomainDetachVisibility",value);
    Py_DECREF(value);
    value=PyString_FromString("oacExcludeFromBlockDomainDetachVisibility");
    PyDict_SetItemString(mod_dict,"oacExcludeFromBlockDomainDetachVisibility",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaDetachVisibilityEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaDetachVisibilityEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaDetachVisibilityEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDevice
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDevice_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDevice_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDeviceObject* self = (PyoaDeviceObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDevice)
    {
        PyParamoaDevice p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDevice_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDevice, Choices are:\n"
        "    (oaDevice)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDevice_tp_dealloc(PyoaDeviceObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDevice_tp_repr(PyObject *ob)
{
    PyParamoaDevice value;
    int convert_status=PyoaDevice_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[30];
    sprintf(buffer,"<oaDevice::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDevice_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDevice v1;
    PyParamoaDevice v2;
    int convert_status1=PyoaDevice_Convert(ob1,&v1);
    int convert_status2=PyoaDevice_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDevice_Convert(PyObject* ob,PyParamoaDevice* result)
{
    if (ob == NULL) return 1;
    if (PyoaDevice_Check(ob)) {
        result->SetData( (oaDevice**) ((PyoaDeviceObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDevice Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDevice_FromoaDevice(oaDevice** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDevice* data=*value;
        if (data->isStdDevice()) return PyoaStdDevice_FromoaStdDevice((oaStdDevice**)value,borrow,lock);
        if (data->getType()==oacMutualInductorType) return PyoaMutualInductor_FromoaMutualInductor((oaMutualInductor**)value,borrow,lock);
        if (data->getType()==oacSeriesRLType) return PyoaSeriesRL_FromoaSeriesRL((oaSeriesRL**)value,borrow,lock);
        PyObject* bself = PyoaDevice_Type.tp_alloc(&PyoaDevice_Type,0);
        if (bself == NULL) return bself;
        PyoaDeviceObject* self = (PyoaDeviceObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDevice_FromoaDevice(oaDevice* data)
{
    if (data) {
        if (data->isStdDevice()) return PyoaStdDevice_FromoaStdDevice((oaStdDevice*)data);
        if (data->getType()==oacMutualInductorType) return PyoaMutualInductor_FromoaMutualInductor((oaMutualInductor*)data);
        if (data->getType()==oacSeriesRLType) return PyoaSeriesRL_FromoaSeriesRL((oaSeriesRL*)data);
       PyObject* bself = PyoaDevice_Type.tp_alloc(&PyoaDevice_Type,0);
       if (bself == NULL) return bself;
       PyoaDeviceObject* self = (PyoaDeviceObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDevice_addToSubNetwork_doc[] = 
"Class: oaDevice, Function: addToSubNetwork\n"
"  Paramegers: (oaSubNetwork)\n"
"    Calls: void addToSubNetwork(oaSubNetwork* subNetwork)\n"
"    Signature: addToSubNetwork|void-void|ptr-oaSubNetwork,\n"
"    This function adds this device to the specified subNetwork .\n"
"    subNetwork\n"
"    The sub-network to which this device is to be added\n"
"    oacSubNetworkDeviceNotSameDesign\n"
;

static PyObject*
oaDevice_addToSubNetwork(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDevice data;
    int convert_status=PyoaDevice_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDeviceObject* self=(PyoaDeviceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaSubNetwork p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaSubNetwork_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->addToSubNetwork(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDevice_destroy_doc[] = 
"Class: oaDevice, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function destroys this device.\n"
;

static PyObject*
oaDevice_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDevice data;
    int convert_status=PyoaDevice_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDeviceObject* self=(PyoaDeviceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDevice_getId_doc[] = 
"Class: oaDevice, Function: getId\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getId() const\n"
"    Signature: getId|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the optional ID if one was assigned to the device when it was created.\n"
;

static PyObject*
oaDevice_getId(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDevice data;
    int convert_status=PyoaDevice_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDeviceObject* self=(PyoaDeviceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getId());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDevice_getName_doc[] = 
"Class: oaDevice, Function: getName\n"
"  Paramegers: (oaString)\n"
"    Calls: void getName(oaString& name) const\n"
"    Signature: getName|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function returns the name of this device. If no name has been set, an empty string is returned.\n"
"    name\n"
"    A reference to an oaString object to be populated with the name of this device\n"
;

static PyObject*
oaDevice_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDevice data;
    int convert_status=PyoaDevice_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDeviceObject* self=(PyoaDeviceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDevice_getParasiticNetwork_doc[] = 
"Class: oaDevice, Function: getParasiticNetwork\n"
"  Paramegers: ()\n"
"    Calls: oaParasiticNetwork* getParasiticNetwork() const\n"
"    Signature: getParasiticNetwork|ptr-oaParasiticNetwork|\n"
"    BrowseData: 1\n"
"    This function returns the parasiticNetwork to which this device belongs.\n"
;

static PyObject*
oaDevice_getParasiticNetwork(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDevice data;
    int convert_status=PyoaDevice_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDeviceObject* self=(PyoaDeviceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaParasiticNetworkp result= (data.DataCall()->getParasiticNetwork());
        return PyoaParasiticNetwork_FromoaParasiticNetwork(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDevice_getSubNetworks_doc[] = 
"Class: oaDevice, Function: getSubNetworks\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaSubNetwork_oaDevice getSubNetworks() const\n"
"    Signature: getSubNetworks|simple-oaCollection_oaSubNetwork_oaDevice|\n"
"    BrowseData: 1\n"
"    This function returns a collection of the subNetworks to which this device belongs.\n"
;

static PyObject*
oaDevice_getSubNetworks(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDevice data;
    int convert_status=PyoaDevice_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDeviceObject* self=(PyoaDeviceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaSubNetwork_oaDevice* result= new oaCollection_oaSubNetwork_oaDevice(data.DataCall()->getSubNetworks());
        return PyoaCollection_oaSubNetwork_oaDevice_FromoaCollection_oaSubNetwork_oaDevice(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDevice_getSubNetworksIter_doc[] = 
"Class: oaDevice, Function: getSubNetworksIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaSubNetwork getSubNetworksIter() const\n"
"    Signature: getSubNetworksIter|simple-oaIter_oaSubNetwork|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of the subNetworks to which this device belongs.\n"
;

static PyObject*
oaDevice_getSubNetworksIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDevice data;
    int convert_status=PyoaDevice_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDeviceObject* self=(PyoaDeviceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaSubNetwork* result= new oaIter_oaSubNetwork(data.DataCall()->getSubNetworks());
        return PyoaIter_oaSubNetwork_FromoaIter_oaSubNetwork(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDevice_hasId_doc[] = 
"Class: oaDevice, Function: hasId\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean hasId() const\n"
"    Signature: hasId|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether or not this device has a user-specified ID associated with it.\n"
;

static PyObject*
oaDevice_hasId(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDevice data;
    int convert_status=PyoaDevice_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDeviceObject* self=(PyoaDeviceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->hasId());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDevice_removeFromSubNetwork_doc[] = 
"Class: oaDevice, Function: removeFromSubNetwork\n"
"  Paramegers: (oaSubNetwork)\n"
"    Calls: void removeFromSubNetwork(oaSubNetwork* subNetwork)\n"
"    Signature: removeFromSubNetwork|void-void|ptr-oaSubNetwork,\n"
"    This function removes this node from the specified subNetwork .\n"
"    subNetwork\n"
"    The sub-network from which this node is to be removed\n"
;

static PyObject*
oaDevice_removeFromSubNetwork(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDevice data;
    int convert_status=PyoaDevice_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDeviceObject* self=(PyoaDeviceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaSubNetwork p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaSubNetwork_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->removeFromSubNetwork(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDevice_setName_doc[] = 
"Class: oaDevice, Function: setName\n"
"  Paramegers: (oaString)\n"
"    Calls: void setName(const oaString& name)\n"
"    Signature: setName|void-void|cref-oaString,\n"
"    This function sets the name of this device.\n"
"    name\n"
"    A reference to an oaString object that holds the new name for this device\n"
"    oacDeviceNameExists\n"
;

static PyObject*
oaDevice_setName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDevice data;
    int convert_status=PyoaDevice_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDeviceObject* self=(PyoaDeviceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->setName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDevice_isNull_doc[] =
"Class: oaDevice, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDevice_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDevice data;
    int convert_status=PyoaDevice_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDevice_assign_doc[] = 
"Class: oaDevice, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDevice_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDevice data;
  int convert_status=PyoaDevice_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDevice p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDevice_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDevice_methodlist[] = {
    {"addToSubNetwork",(PyCFunction)oaDevice_addToSubNetwork,METH_VARARGS,oaDevice_addToSubNetwork_doc},
    {"destroy",(PyCFunction)oaDevice_destroy,METH_VARARGS,oaDevice_destroy_doc},
    {"getId",(PyCFunction)oaDevice_getId,METH_VARARGS,oaDevice_getId_doc},
    {"getName",(PyCFunction)oaDevice_getName,METH_VARARGS,oaDevice_getName_doc},
    {"getParasiticNetwork",(PyCFunction)oaDevice_getParasiticNetwork,METH_VARARGS,oaDevice_getParasiticNetwork_doc},
    {"getSubNetworks",(PyCFunction)oaDevice_getSubNetworks,METH_VARARGS,oaDevice_getSubNetworks_doc},
    {"getSubNetworksIter",(PyCFunction)oaDevice_getSubNetworksIter,METH_VARARGS,oaDevice_getSubNetworksIter_doc},
    {"hasId",(PyCFunction)oaDevice_hasId,METH_VARARGS,oaDevice_hasId_doc},
    {"removeFromSubNetwork",(PyCFunction)oaDevice_removeFromSubNetwork,METH_VARARGS,oaDevice_removeFromSubNetwork_doc},
    {"setName",(PyCFunction)oaDevice_setName,METH_VARARGS,oaDevice_setName_doc},
    {"isNull",(PyCFunction)oaDevice_tp_isNull,METH_VARARGS,oaDevice_isNull_doc},
    {"assign",(PyCFunction)oaDevice_tp_assign,METH_VARARGS,oaDevice_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDevice_doc[] = 
"Class: oaDevice\n"
"  The oaDevice class is an abstract base class for parasitic devices contained within an oaParasiticNetwork . A device represents an instance of a particular type of parasitic element, such as a resistor, capacitor, or inductor.\n"
"  Devices are managed objects, but they can be loaded from disk into memory (and unloaded from memory back to disk) on request as part of the parasitic network to which they belong. Therefore, database clients must be careful not to dereference a pointer to a device after the parasitic network to which it belongs has been unloaded.\n"
"  There are a variety of different device types, many of which have two endpoints. Each endpoint connects directly to an oaNode object. This is in contrast to connections between instances and nets, where an additional object ( oaInstTerm ) is used to represent the connection. Most parasitic devices are symmetrical and do not have distinct information associated with each endpoint. Because devices are among the most numerous of database objects, there is a substantial capacity improvement by using a different connectivity model for devices than for instances.\n"
"  Two types of devices do not have two endpoints connected to nodes. An oaMutualInductor represents an electromagnetic relationship between two inductors (between devices rather than nodes). An oaCouplingCap that couples between two different parasitic networks can connect directly to an instTerm or term in the other network, rather than to a node.\n"
"  Most parasitic devices have one value for each analysis point that the parasitic network represents. Each value reflects the parasitic effect applicable to the operating points associated with the corresponding analysis point. The oaSeriesRL device has two values for each analysis point, one resistance and one capacitance. The oaSeriesRL device can be used to improve capacity when a resistor and an inductor are connected in series and the node between them is not of interest.\n"
"  From an electrical standpoint, a coupling capacitor can connect two different nodes in the same parasitic network, or it can connect two nodes in different networks. In OpenAccess, a particular coupling relationship between two different networks is represented separately for each of the networks, with an oaCouplingCap device in each network. This allows each network to be loaded independently and efficiently. Applications must explicitly create and destroy each oaCouplingCap in the pair for a given coupling relationship.\n"
"  Mutual inductors are handled in a similar fashion. A mutual inductor relates two different inductors, which can be in the same network or in different networks. When the inductors are in different networks, each network has its own mutual inductor device. Applications must explicitly create and destroy each mutual inductor in the pair for a given coupling relationship.\n"
"  Devices can have an integer ID that is chosen by the client that creates them. The ID is usually optional, but IDs are required for inductors that are referenced by a mutual inductor, as well as for coupling caps and mutual inductors. For coupling caps and mutual inductors that connect two different parasitic networks, the same ID can be specified when creating each device in the pair, which allows applications to match up the devices.\n"
"  Any ID specified for local devices contained within a single network must be unique across all local devices in that network, regardless of type. Similarly, any ID specified for couplingCaps and mutual inductors that couple from a given network to a different network must be unique across all non-local devices in the given network. The getUniqueId() functions can be called to obtain consecutive IDs for local devices and non-local devices.\n"
"  Devices can also have a name, which is an optional string chosen by the client that creates them. This is primarily useful for small custom designs, as assigning a separate name to every parasitic device in large digital designs is prohibitively expensive. Device names must be unique within the same network,\n"
"  Undo, properties, and groups are not supported for oaDevice. Extensions on oaDevice (and interPointer extensions that refer to an oaDevice) are only accessible while the oaDevice is loaded.\n"
"  The oaDevice class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaDevice)\n"
"    Calls: (const oaDevice&)\n"
"    Signature: oaDevice||cref-oaDevice,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDevice_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDevice",
    sizeof(PyoaDeviceObject),
    0,
    (destructor)oaDevice_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDevice_tp_compare,	/* tp_compare */
    (reprfunc)oaDevice_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDevice_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDevice_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaDesignObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDevice_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDevice_static_find_doc[] = 
"Class: oaDevice, Function: find\n"
"  Paramegers: (oaParasiticNetwork,oaUInt4,oaBoolean)\n"
"    Calls: oaDevice* find(const oaParasiticNetwork* network,oaUInt4 id,oaBoolean local)\n"
"    Signature: find|ptr-oaDevice|cptr-oaParasiticNetwork,simple-oaUInt4,simple-oaBoolean,\n"
"    This function finds and returns the device with the specified id within network . Local devices contained with network will be considered when local is true. CouplingCaps and mutual inductors in network that couple to other networks will be considered when local is false.\n"
"    network\n"
"    The parasitic network to search for the device\n"
"    id\n"
"    The id of the device to look for\n"
"    local\n"
"    A boolean indicating if the search is to be restricted to devices local to the network\n"
"  Paramegers: (oaParasiticNetwork,oaString)\n"
"    Calls: oaDevice* find(const oaParasiticNetwork* network,const oaString& name)\n"
"    Signature: find|ptr-oaDevice|cptr-oaParasiticNetwork,cref-oaString,\n"
"    This function finds and returns the device with the specified name .\n"
"    network\n"
"    The parasitic network to search for the device\n"
"    name\n"
"    The name of the device to look for\n"
;

static PyObject*
oaDevice_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaParasiticNetwork,oaUInt4,oaBoolean)
    {
        PyParamoaParasiticNetwork p1;
        PyParamoaUInt4 p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaParasiticNetwork_Convert,&p1,
              &PyoaUInt4_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaDevicep result= (oaDevice::find(p1.Data(),p2.Data(),p3.Data()));
            return PyoaDevice_FromoaDevice(result);
        }
    }
    PyErr_Clear();
    // Case: (oaParasiticNetwork,oaString)
    {
        PyParamoaParasiticNetwork p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaParasiticNetwork_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaDevicep result= (oaDevice::find(p1.Data(),p2.Data()));
            return PyoaDevice_FromoaDevice(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDevice, function: find, Choices are:\n"
        "    (oaParasiticNetwork,oaUInt4,oaBoolean)\n"
        "    (oaParasiticNetwork,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDevice_static_getUniqueId_doc[] = 
"Class: oaDevice, Function: getUniqueId\n"
"  Paramegers: (oaParasiticNetwork)\n"
"    Calls: oaUInt4 getUniqueId(oaParasiticNetwork* network)\n"
"    Signature: getUniqueId|simple-oaUInt4|ptr-oaParasiticNetwork,\n"
"    This function returns a unique integer ID for a local device in the specified network .\n"
"    network\n"
"    The parasitic network to determine the potential unique ID for this device\n"
"  Paramegers: (oaDesign)\n"
"    Calls: oaUInt4 getUniqueId(oaDesign* design)\n"
"    Signature: getUniqueId|simple-oaUInt4|ptr-oaDesign,\n"
"    This function returns a unique integer ID for a coupling cap or mutual inductor that couples between two different networks in the specified design .\n"
"    design\n"
"    The design to use\n"
;

static PyObject*
oaDevice_static_getUniqueId(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaParasiticNetwork)
    {
        PyParamoaParasiticNetwork p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaParasiticNetwork_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaUInt4 result= (oaDevice::getUniqueId(p1.Data()));
            return PyoaUInt4_FromoaUInt4(result);
        }
    }
    PyErr_Clear();
    // Case: (oaDesign)
    {
        PyParamoaDesign p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDesign_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaUInt4 result= (oaDevice::getUniqueId(p1.Data()));
            return PyoaUInt4_FromoaUInt4(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDevice, function: getUniqueId, Choices are:\n"
        "    (oaParasiticNetwork)\n"
        "    (oaDesign)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDevice_static_isValidName_doc[] = 
"Class: oaDevice, Function: isValidName\n"
"  Paramegers: (oaParasiticNetwork,oaString)\n"
"    Calls: oaBoolean isValidName(const oaParasiticNetwork* network,const oaString& name)\n"
"    Signature: isValidName|simple-oaBoolean|cptr-oaParasiticNetwork,cref-oaString,\n"
"    This function returns a boolean value that indicates if the specified name is valid for a new oaDevice in the specified network .\n"
"    network\n"
"    The parasitic network in whose domain the name is to be validated\n"
"    name\n"
"    A reference to an oaString object holding the name to be validated\n"
;

static PyObject*
oaDevice_static_isValidName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaParasiticNetwork_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (oaDevice::isValidName(p1.Data(),p2.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDevice_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDevice_static_find,METH_VARARGS,oaDevice_static_find_doc},
    {"static_getUniqueId",(PyCFunction)oaDevice_static_getUniqueId,METH_VARARGS,oaDevice_static_getUniqueId_doc},
    {"static_isValidName",(PyCFunction)oaDevice_static_isValidName,METH_VARARGS,oaDevice_static_isValidName_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDevice_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDevice_Type)<0) {
      printf("** PyType_Ready failed for: oaDevice\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDevice",
           (PyObject*)(&PyoaDevice_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDevice\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDevice_Type.tp_dict;
    for(method=oaDevice_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDeviceModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaDeviceModTypeEnum_Convert(PyObject* ob,PyParamoaDeviceModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacSetNameDeviceModType")==0) { result->SetData(oacSetNameDeviceModType); return 1;}
        if (strcasecmp(str,"oacSetValueDeviceModType")==0) { result->SetData(oacSetValueDeviceModType); return 1;}
        if (strcasecmp(str,"oacAddToSubNetworkDeviceModType")==0) { result->SetData(oacAddToSubNetworkDeviceModType); return 1;}
        if (strcasecmp(str,"oacRemoveFromSubNetworkDeviceModType")==0) { result->SetData(oacRemoveFromSubNetworkDeviceModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaDeviceModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDeviceModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaDeviceModTypeEnum_FromoaDeviceModTypeEnum(oaDeviceModTypeEnum ob)
{
    if (ob==oacSetNameDeviceModType) return PyString_FromString("oacSetNameDeviceModType");
    if (ob==oacSetValueDeviceModType) return PyString_FromString("oacSetValueDeviceModType");
    if (ob==oacAddToSubNetworkDeviceModType) return PyString_FromString("oacAddToSubNetworkDeviceModType");
    if (ob==oacRemoveFromSubNetworkDeviceModType) return PyString_FromString("oacRemoveFromSubNetworkDeviceModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaDeviceModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaDeviceModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaDeviceModTypeEnum_FromoaDeviceModTypeEnum(oaDeviceModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaDeviceModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaDeviceModTypeEnum_doc[] =
"Type convert function for enum: oaDeviceModTypeEnum";
                               
static PyMethodDef PyoaDeviceModTypeEnum_method =
  {"oaDeviceModTypeEnum",(PyCFunction)PyoaDeviceModTypeEnum_TypeFunction,METH_VARARGS,oaDeviceModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaDeviceModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacSetNameDeviceModType");
    PyDict_SetItemString(mod_dict,"oacSetNameDeviceModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetValueDeviceModType");
    PyDict_SetItemString(mod_dict,"oacSetValueDeviceModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAddToSubNetworkDeviceModType");
    PyDict_SetItemString(mod_dict,"oacAddToSubNetworkDeviceModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacRemoveFromSubNetworkDeviceModType");
    PyDict_SetItemString(mod_dict,"oacRemoveFromSubNetworkDeviceModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaDeviceModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaDeviceModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaDeviceModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDiode
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDiode_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDiode_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDiodeObject* self = (PyoaDiodeObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDiode)
    {
        PyParamoaDiode p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDiode_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDiode, Choices are:\n"
        "    (oaDiode)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDiode_tp_dealloc(PyoaDiodeObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDiode_tp_repr(PyObject *ob)
{
    PyParamoaDiode value;
    int convert_status=PyoaDiode_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[29];
    sprintf(buffer,"<oaDiode::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDiode_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDiode v1;
    PyParamoaDiode v2;
    int convert_status1=PyoaDiode_Convert(ob1,&v1);
    int convert_status2=PyoaDiode_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDiode_Convert(PyObject* ob,PyParamoaDiode* result)
{
    if (ob == NULL) return 1;
    if (PyoaDiode_Check(ob)) {
        result->SetData( (oaDiode**) ((PyoaDiodeObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDiode Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDiode_FromoaDiode(oaDiode** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDiode* data=*value;
        PyObject* bself = PyoaDiode_Type.tp_alloc(&PyoaDiode_Type,0);
        if (bself == NULL) return bself;
        PyoaDiodeObject* self = (PyoaDiodeObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDiode_FromoaDiode(oaDiode* data)
{
    if (data) {
       PyObject* bself = PyoaDiode_Type.tp_alloc(&PyoaDiode_Type,0);
       if (bself == NULL) return bself;
       PyoaDiodeObject* self = (PyoaDiodeObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDiode_doc[] = 
"Class: oaDiode\n"
"  The oaDiode class represents an ideal clamping diode in a parasitic network for a net. Each diode object has one value for each analysis point that the parasitic network represents. Each value specifies the cut-in voltage, below which no current will flow through the diode.\n"
"Constructors:\n"
"  Paramegers: (oaDiode)\n"
"    Calls: (const oaDiode&)\n"
"    Signature: oaDiode||cref-oaDiode,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDiode_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDiode",
    sizeof(PyoaDiodeObject),
    0,
    (destructor)oaDiode_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDiode_tp_compare,	/* tp_compare */
    (reprfunc)oaDiode_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDiode_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdDevice_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDiode_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDiode_static_create_doc[] = 
"Class: oaDiode, Function: create\n"
"  Paramegers: (oaNode,oaNode)\n"
"    Calls: oaDiode* create(oaNode* fromNode,oaNode* toNode)\n"
"    Signature: create|ptr-oaDiode|ptr-oaNode,ptr-oaNode,\n"
"    This function creates a diode belonging to the parasitic network containing fromNode and toNode . Diodes have a polarity, and therefore the assignment of the endpoints of the diode is significant; current flows through the diode from fromNode to toNode . An exception will be thrown if fromNode and toNode do not belong to the same network. The device created will not have an ID associated with it. The hasId() function will return false for these devices and the getId() function will return an oacInvalidDeviceID value.\n"
"    Diodes can be created between nodes in different partitions of the same root parasitic network, where one of the partitions must be an ancestor of the other. In this case, the diode will be created in the lower level partition, and the node in the higher level partition must have an id so that it can be found when loading the lower level partition.\n"
"    fromNode\n"
"    The starting node for the diode\n"
"    toNode\n"
"    The ending node for the diode\n"
"    oacNodesNotInSameDesign\n"
"    oacNodesNotInSameNetwork\n"
"    oacNodesNotInRelatedPartitions\n"
"    oacAncestorNodeWithoutId\n"
"  Paramegers: (oaNode,oaNode,oaUInt4)\n"
"    Calls: oaDiode* create(oaNode* fromNode,oaNode* toNode,oaUInt4 id)\n"
"    Signature: create|ptr-oaDiode|ptr-oaNode,ptr-oaNode,simple-oaUInt4,\n"
"    This function creates a diode that belongs to the parasitic network containing fromNode and toNode . Diodes have a polarity, so the assignment of endpoints of the diode is significant: current flows through the diode from fromNode to toNode . An exception will be thrown if fromNode and toNode do not belong to the same network. An explicit unique ID id is required to be specified. An exception will be thrown if the id is the reserved oacInvalidDeviceID value or if a device with the specified id value already exists. The hasId() function will return true for devices created with this function and the getId() function will return the user-specified id.\n"
"    Diodes can be created between nodes in different partitions of the same root parasitic network, where one of the partitions must be an ancestor of the other. In this case, the diode will be created in the lower level partition, and the node in the higher level partition must have an id so that it can be found when loading the lower level partition.\n"
"    fromNode\n"
"    The starting node for the diode\n"
"    toNode\n"
"    The ending node for the diode\n"
"    id\n"
"    The unique ID to be assigned to the diode created\n"
"    oacInvalidDeviceIdSpecified\n"
"    oacLocalDeviceIdExists\n"
"    oacNodesNotInSameDesign\n"
"    oacNodesNotInSameNetwork\n"
"    oacNodesNotInRelatedPartitions\n"
"    oacAncestorNodeWithoutId\n"
;

static PyObject*
oaDiode_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaNode,oaNode)
    {
        PyParamoaNode p1;
        PyParamoaNode p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNode_Convert,&p1,
              &PyoaNode_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDiodep result= (oaDiode::create(p1.Data(),p2.Data()));
            return PyoaDiode_FromoaDiode(result);
        }
    }
    PyErr_Clear();
    // Case: (oaNode,oaNode,oaUInt4)
    {
        PyParamoaNode p1;
        PyParamoaNode p2;
        PyParamoaUInt4 p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaNode_Convert,&p1,
              &PyoaNode_Convert,&p2,
              &PyoaUInt4_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDiodep result= (oaDiode::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaDiode_FromoaDiode(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDiode, function: create, Choices are:\n"
        "    (oaNode,oaNode)\n"
        "    (oaNode,oaNode,oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDiode_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaDiode_static_create,METH_VARARGS,oaDiode_static_create_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDiode_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDiode_Type)<0) {
      printf("** PyType_Ready failed for: oaDiode\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDiode",
           (PyObject*)(&PyoaDiode_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDiode\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDiode_Type.tp_dict;
    for(method=oaDiode_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}

