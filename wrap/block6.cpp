
/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBooleanAppDef_oaSteiner
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaSteiner_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBooleanAppDef_oaSteiner_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBooleanAppDef_oaSteinerObject* self = (PyoaBooleanAppDef_oaSteinerObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBooleanAppDef_oaSteiner)
    {
        PyParamoaBooleanAppDef_oaSteiner p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBooleanAppDef_oaSteiner_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBooleanAppDef_oaSteiner, Choices are:\n"
        "    (oaBooleanAppDef_oaSteiner)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBooleanAppDef_oaSteiner_tp_dealloc(PyoaBooleanAppDef_oaSteinerObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaSteiner_tp_repr(PyObject *ob)
{
    PyParamoaBooleanAppDef_oaSteiner value;
    int convert_status=PyoaBooleanAppDef_oaSteiner_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[47];
    sprintf(buffer,"<oaBooleanAppDef_oaSteiner::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBooleanAppDef_oaSteiner_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBooleanAppDef_oaSteiner v1;
    PyParamoaBooleanAppDef_oaSteiner v2;
    int convert_status1=PyoaBooleanAppDef_oaSteiner_Convert(ob1,&v1);
    int convert_status2=PyoaBooleanAppDef_oaSteiner_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBooleanAppDef_oaSteiner_Convert(PyObject* ob,PyParamoaBooleanAppDef_oaSteiner* result)
{
    if (ob == NULL) return 1;
    if (PyoaBooleanAppDef_oaSteiner_Check(ob)) {
        result->SetData( (oaBooleanAppDef_oaSteiner**) ((PyoaBooleanAppDef_oaSteinerObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBooleanAppDef_oaSteiner Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaSteiner_FromoaBooleanAppDef_oaSteiner(oaBooleanAppDef_oaSteiner** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBooleanAppDef_oaSteiner* data=*value;
        PyObject* bself = PyoaBooleanAppDef_oaSteiner_Type.tp_alloc(&PyoaBooleanAppDef_oaSteiner_Type,0);
        if (bself == NULL) return bself;
        PyoaBooleanAppDef_oaSteinerObject* self = (PyoaBooleanAppDef_oaSteinerObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaSteiner_FromoaBooleanAppDef_oaSteiner(oaBooleanAppDef_oaSteiner* data)
{
    if (data) {
       PyObject* bself = PyoaBooleanAppDef_oaSteiner_Type.tp_alloc(&PyoaBooleanAppDef_oaSteiner_Type,0);
       if (bself == NULL) return bself;
       PyoaBooleanAppDef_oaSteinerObject* self = (PyoaBooleanAppDef_oaSteinerObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaSteiner_get_doc[] = 
"Class: oaBooleanAppDef_oaSteiner, Function: get\n"
"  Paramegers: (oaSteiner)\n"
"    Calls: oaBoolean get(const oaSteiner* object)\n"
"    Signature: get|simple-oaBoolean|cptr-oaSteiner,\n"
"    This function returns the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to get the value for this extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaSteiner_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaSteiner data;
    int convert_status=PyoaBooleanAppDef_oaSteiner_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaSteinerObject* self=(PyoaBooleanAppDef_oaSteinerObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaSteiner p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaSteiner_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->get(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaSteiner_getDefault_doc[] = 
"Class: oaBooleanAppDef_oaSteiner, Function: getDefault\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean getDefault() const\n"
"    Signature: getDefault|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns the default value for this boolean extension.\n"
;

static PyObject*
oaBooleanAppDef_oaSteiner_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaSteiner data;
    int convert_status=PyoaBooleanAppDef_oaSteiner_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaSteinerObject* self=(PyoaBooleanAppDef_oaSteinerObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->getDefault());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaSteiner_set_doc[] = 
"Class: oaBooleanAppDef_oaSteiner, Function: set\n"
"  Paramegers: (oaSteiner,oaBoolean)\n"
"    Calls: void set(oaSteiner* object,oaBoolean value)\n"
"    Signature: set|void-void|ptr-oaSteiner,simple-oaBoolean,\n"
"    This function sets the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to set the value for this extension\n"
"    value\n"
"    The value of the extension to set on the object\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaSteiner_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaSteiner data;
    int convert_status=PyoaBooleanAppDef_oaSteiner_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaSteinerObject* self=(PyoaBooleanAppDef_oaSteinerObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaSteiner p1;
    PyParamoaBoolean p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaSteiner_Convert,&p1,
          &PyoaBoolean_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaSteiner_isNull_doc[] =
"Class: oaBooleanAppDef_oaSteiner, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBooleanAppDef_oaSteiner_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBooleanAppDef_oaSteiner data;
    int convert_status=PyoaBooleanAppDef_oaSteiner_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBooleanAppDef_oaSteiner_assign_doc[] = 
"Class: oaBooleanAppDef_oaSteiner, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBooleanAppDef_oaSteiner_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBooleanAppDef_oaSteiner data;
  int convert_status=PyoaBooleanAppDef_oaSteiner_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBooleanAppDef_oaSteiner p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBooleanAppDef_oaSteiner_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBooleanAppDef_oaSteiner_methodlist[] = {
    {"get",(PyCFunction)oaBooleanAppDef_oaSteiner_get,METH_VARARGS,oaBooleanAppDef_oaSteiner_get_doc},
    {"getDefault",(PyCFunction)oaBooleanAppDef_oaSteiner_getDefault,METH_VARARGS,oaBooleanAppDef_oaSteiner_getDefault_doc},
    {"set",(PyCFunction)oaBooleanAppDef_oaSteiner_set,METH_VARARGS,oaBooleanAppDef_oaSteiner_set_doc},
    {"isNull",(PyCFunction)oaBooleanAppDef_oaSteiner_tp_isNull,METH_VARARGS,oaBooleanAppDef_oaSteiner_isNull_doc},
    {"assign",(PyCFunction)oaBooleanAppDef_oaSteiner_tp_assign,METH_VARARGS,oaBooleanAppDef_oaSteiner_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaSteiner_doc[] = 
"Class: oaBooleanAppDef_oaSteiner\n"
"  The oaBooleanAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  Once created, a boolean field is added to each object of the specified dataType, with the specified default value. Applications can use the new data field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaBooleanAppDef_oaSteiner)\n"
"    Calls: (const oaBooleanAppDef_oaSteiner&)\n"
"    Signature: oaBooleanAppDef_oaSteiner||cref-oaBooleanAppDef_oaSteiner,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBooleanAppDef_oaSteiner_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBooleanAppDef_oaSteiner",
    sizeof(PyoaBooleanAppDef_oaSteinerObject),
    0,
    (destructor)oaBooleanAppDef_oaSteiner_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBooleanAppDef_oaSteiner_tp_compare,	/* tp_compare */
    (reprfunc)oaBooleanAppDef_oaSteiner_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBooleanAppDef_oaSteiner_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBooleanAppDef_oaSteiner_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBooleanAppDef_oaSteiner_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaSteiner_static_find_doc[] = 
"Class: oaBooleanAppDef_oaSteiner, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaSteiner* find(const oaString& name)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaSteiner|cref-oaString,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaSteiner* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaSteiner|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaBooleanAppDef_oaSteiner_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaSteinerp result= (oaBooleanAppDef_oaSteiner::find(p1.Data()));
            return PyoaBooleanAppDef_oaSteiner_FromoaBooleanAppDef_oaSteiner(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaSteinerp result= (oaBooleanAppDef_oaSteiner::find(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaSteiner_FromoaBooleanAppDef_oaSteiner(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaSteiner, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaSteiner_static_get_doc[] = 
"Class: oaBooleanAppDef_oaSteiner, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaSteiner* get(const oaString& name)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaSteiner|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaSteiner* get(const oaString& name,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaSteiner|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaSteiner* get(const oaString& name,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaSteiner|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaSteiner* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaSteiner|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaSteiner* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaSteiner|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaSteiner* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaSteiner|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
;

static PyObject*
oaBooleanAppDef_oaSteiner_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaSteinerp result= (oaBooleanAppDef_oaSteiner::get(p1.Data()));
            return PyoaBooleanAppDef_oaSteiner_FromoaBooleanAppDef_oaSteiner(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaBooleanAppDef_oaSteinerp result= (oaBooleanAppDef_oaSteiner::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaSteiner_FromoaBooleanAppDef_oaSteiner(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaBooleanAppDef_oaSteinerp result= (oaBooleanAppDef_oaSteiner::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaSteiner_FromoaBooleanAppDef_oaSteiner(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaSteinerp result= (oaBooleanAppDef_oaSteiner::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaSteiner_FromoaBooleanAppDef_oaSteiner(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaSteinerp result= (oaBooleanAppDef_oaSteiner::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaSteiner_FromoaBooleanAppDef_oaSteiner(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaSteinerp result= (oaBooleanAppDef_oaSteiner::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBooleanAppDef_oaSteiner_FromoaBooleanAppDef_oaSteiner(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaSteiner, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,oaBoolean,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBooleanAppDef_oaSteiner_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaBooleanAppDef_oaSteiner_static_find,METH_VARARGS,oaBooleanAppDef_oaSteiner_static_find_doc},
    {"static_get",(PyCFunction)oaBooleanAppDef_oaSteiner_static_get,METH_VARARGS,oaBooleanAppDef_oaSteiner_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBooleanAppDef_oaSteiner_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBooleanAppDef_oaSteiner_Type)<0) {
      printf("** PyType_Ready failed for: oaBooleanAppDef_oaSteiner\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBooleanAppDef_oaSteiner",
           (PyObject*)(&PyoaBooleanAppDef_oaSteiner_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBooleanAppDef_oaSteiner\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBooleanAppDef_oaSteiner_Type.tp_dict;
    for(method=oaBooleanAppDef_oaSteiner_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBooleanAppDef_oaStepperMap
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaStepperMap_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBooleanAppDef_oaStepperMap_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBooleanAppDef_oaStepperMapObject* self = (PyoaBooleanAppDef_oaStepperMapObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBooleanAppDef_oaStepperMap)
    {
        PyParamoaBooleanAppDef_oaStepperMap p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBooleanAppDef_oaStepperMap_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBooleanAppDef_oaStepperMap, Choices are:\n"
        "    (oaBooleanAppDef_oaStepperMap)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBooleanAppDef_oaStepperMap_tp_dealloc(PyoaBooleanAppDef_oaStepperMapObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaStepperMap_tp_repr(PyObject *ob)
{
    PyParamoaBooleanAppDef_oaStepperMap value;
    int convert_status=PyoaBooleanAppDef_oaStepperMap_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[50];
    sprintf(buffer,"<oaBooleanAppDef_oaStepperMap::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBooleanAppDef_oaStepperMap_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBooleanAppDef_oaStepperMap v1;
    PyParamoaBooleanAppDef_oaStepperMap v2;
    int convert_status1=PyoaBooleanAppDef_oaStepperMap_Convert(ob1,&v1);
    int convert_status2=PyoaBooleanAppDef_oaStepperMap_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBooleanAppDef_oaStepperMap_Convert(PyObject* ob,PyParamoaBooleanAppDef_oaStepperMap* result)
{
    if (ob == NULL) return 1;
    if (PyoaBooleanAppDef_oaStepperMap_Check(ob)) {
        result->SetData( (oaBooleanAppDef_oaStepperMap**) ((PyoaBooleanAppDef_oaStepperMapObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBooleanAppDef_oaStepperMap Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaStepperMap_FromoaBooleanAppDef_oaStepperMap(oaBooleanAppDef_oaStepperMap** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBooleanAppDef_oaStepperMap* data=*value;
        PyObject* bself = PyoaBooleanAppDef_oaStepperMap_Type.tp_alloc(&PyoaBooleanAppDef_oaStepperMap_Type,0);
        if (bself == NULL) return bself;
        PyoaBooleanAppDef_oaStepperMapObject* self = (PyoaBooleanAppDef_oaStepperMapObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaStepperMap_FromoaBooleanAppDef_oaStepperMap(oaBooleanAppDef_oaStepperMap* data)
{
    if (data) {
       PyObject* bself = PyoaBooleanAppDef_oaStepperMap_Type.tp_alloc(&PyoaBooleanAppDef_oaStepperMap_Type,0);
       if (bself == NULL) return bself;
       PyoaBooleanAppDef_oaStepperMapObject* self = (PyoaBooleanAppDef_oaStepperMapObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaStepperMap_get_doc[] = 
"Class: oaBooleanAppDef_oaStepperMap, Function: get\n"
"  Paramegers: (oaStepperMap)\n"
"    Calls: oaBoolean get(const oaStepperMap* object)\n"
"    Signature: get|simple-oaBoolean|cptr-oaStepperMap,\n"
"    This function returns the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to get the value for this extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaStepperMap_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaStepperMap data;
    int convert_status=PyoaBooleanAppDef_oaStepperMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaStepperMapObject* self=(PyoaBooleanAppDef_oaStepperMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaStepperMap p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaStepperMap_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->get(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaStepperMap_getDefault_doc[] = 
"Class: oaBooleanAppDef_oaStepperMap, Function: getDefault\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean getDefault() const\n"
"    Signature: getDefault|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns the default value for this boolean extension.\n"
;

static PyObject*
oaBooleanAppDef_oaStepperMap_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaStepperMap data;
    int convert_status=PyoaBooleanAppDef_oaStepperMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaStepperMapObject* self=(PyoaBooleanAppDef_oaStepperMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->getDefault());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaStepperMap_set_doc[] = 
"Class: oaBooleanAppDef_oaStepperMap, Function: set\n"
"  Paramegers: (oaStepperMap,oaBoolean)\n"
"    Calls: void set(oaStepperMap* object,oaBoolean value)\n"
"    Signature: set|void-void|ptr-oaStepperMap,simple-oaBoolean,\n"
"    This function sets the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to set the value for this extension\n"
"    value\n"
"    The value of the extension to set on the object\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaStepperMap_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaStepperMap data;
    int convert_status=PyoaBooleanAppDef_oaStepperMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaStepperMapObject* self=(PyoaBooleanAppDef_oaStepperMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaStepperMap p1;
    PyParamoaBoolean p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaStepperMap_Convert,&p1,
          &PyoaBoolean_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaStepperMap_isNull_doc[] =
"Class: oaBooleanAppDef_oaStepperMap, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBooleanAppDef_oaStepperMap_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBooleanAppDef_oaStepperMap data;
    int convert_status=PyoaBooleanAppDef_oaStepperMap_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBooleanAppDef_oaStepperMap_assign_doc[] = 
"Class: oaBooleanAppDef_oaStepperMap, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBooleanAppDef_oaStepperMap_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBooleanAppDef_oaStepperMap data;
  int convert_status=PyoaBooleanAppDef_oaStepperMap_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBooleanAppDef_oaStepperMap p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBooleanAppDef_oaStepperMap_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBooleanAppDef_oaStepperMap_methodlist[] = {
    {"get",(PyCFunction)oaBooleanAppDef_oaStepperMap_get,METH_VARARGS,oaBooleanAppDef_oaStepperMap_get_doc},
    {"getDefault",(PyCFunction)oaBooleanAppDef_oaStepperMap_getDefault,METH_VARARGS,oaBooleanAppDef_oaStepperMap_getDefault_doc},
    {"set",(PyCFunction)oaBooleanAppDef_oaStepperMap_set,METH_VARARGS,oaBooleanAppDef_oaStepperMap_set_doc},
    {"isNull",(PyCFunction)oaBooleanAppDef_oaStepperMap_tp_isNull,METH_VARARGS,oaBooleanAppDef_oaStepperMap_isNull_doc},
    {"assign",(PyCFunction)oaBooleanAppDef_oaStepperMap_tp_assign,METH_VARARGS,oaBooleanAppDef_oaStepperMap_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaStepperMap_doc[] = 
"Class: oaBooleanAppDef_oaStepperMap\n"
"  The oaBooleanAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  Once created, a boolean field is added to each object of the specified dataType, with the specified default value. Applications can use the new data field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaBooleanAppDef_oaStepperMap)\n"
"    Calls: (const oaBooleanAppDef_oaStepperMap&)\n"
"    Signature: oaBooleanAppDef_oaStepperMap||cref-oaBooleanAppDef_oaStepperMap,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBooleanAppDef_oaStepperMap_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBooleanAppDef_oaStepperMap",
    sizeof(PyoaBooleanAppDef_oaStepperMapObject),
    0,
    (destructor)oaBooleanAppDef_oaStepperMap_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBooleanAppDef_oaStepperMap_tp_compare,	/* tp_compare */
    (reprfunc)oaBooleanAppDef_oaStepperMap_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBooleanAppDef_oaStepperMap_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBooleanAppDef_oaStepperMap_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBooleanAppDef_oaStepperMap_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaStepperMap_static_find_doc[] = 
"Class: oaBooleanAppDef_oaStepperMap, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaStepperMap* find(const oaString& name)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaStepperMap|cref-oaString,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaStepperMap* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaStepperMap|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaBooleanAppDef_oaStepperMap_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaStepperMapp result= (oaBooleanAppDef_oaStepperMap::find(p1.Data()));
            return PyoaBooleanAppDef_oaStepperMap_FromoaBooleanAppDef_oaStepperMap(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaStepperMapp result= (oaBooleanAppDef_oaStepperMap::find(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaStepperMap_FromoaBooleanAppDef_oaStepperMap(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaStepperMap, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaStepperMap_static_get_doc[] = 
"Class: oaBooleanAppDef_oaStepperMap, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaStepperMap* get(const oaString& name)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaStepperMap|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaStepperMap* get(const oaString& name,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaStepperMap|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaStepperMap* get(const oaString& name,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaStepperMap|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaStepperMap* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaStepperMap|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaStepperMap* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaStepperMap|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaStepperMap* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaStepperMap|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
;

static PyObject*
oaBooleanAppDef_oaStepperMap_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaStepperMapp result= (oaBooleanAppDef_oaStepperMap::get(p1.Data()));
            return PyoaBooleanAppDef_oaStepperMap_FromoaBooleanAppDef_oaStepperMap(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaBooleanAppDef_oaStepperMapp result= (oaBooleanAppDef_oaStepperMap::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaStepperMap_FromoaBooleanAppDef_oaStepperMap(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaBooleanAppDef_oaStepperMapp result= (oaBooleanAppDef_oaStepperMap::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaStepperMap_FromoaBooleanAppDef_oaStepperMap(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaStepperMapp result= (oaBooleanAppDef_oaStepperMap::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaStepperMap_FromoaBooleanAppDef_oaStepperMap(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaStepperMapp result= (oaBooleanAppDef_oaStepperMap::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaStepperMap_FromoaBooleanAppDef_oaStepperMap(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaStepperMapp result= (oaBooleanAppDef_oaStepperMap::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBooleanAppDef_oaStepperMap_FromoaBooleanAppDef_oaStepperMap(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaStepperMap, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,oaBoolean,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBooleanAppDef_oaStepperMap_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaBooleanAppDef_oaStepperMap_static_find,METH_VARARGS,oaBooleanAppDef_oaStepperMap_static_find_doc},
    {"static_get",(PyCFunction)oaBooleanAppDef_oaStepperMap_static_get,METH_VARARGS,oaBooleanAppDef_oaStepperMap_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBooleanAppDef_oaStepperMap_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBooleanAppDef_oaStepperMap_Type)<0) {
      printf("** PyType_Ready failed for: oaBooleanAppDef_oaStepperMap\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBooleanAppDef_oaStepperMap",
           (PyObject*)(&PyoaBooleanAppDef_oaStepperMap_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBooleanAppDef_oaStepperMap\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBooleanAppDef_oaStepperMap_Type.tp_dict;
    for(method=oaBooleanAppDef_oaStepperMap_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBooleanAppDef_oaTech
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaTech_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBooleanAppDef_oaTech_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBooleanAppDef_oaTechObject* self = (PyoaBooleanAppDef_oaTechObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBooleanAppDef_oaTech)
    {
        PyParamoaBooleanAppDef_oaTech p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBooleanAppDef_oaTech_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBooleanAppDef_oaTech, Choices are:\n"
        "    (oaBooleanAppDef_oaTech)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBooleanAppDef_oaTech_tp_dealloc(PyoaBooleanAppDef_oaTechObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaTech_tp_repr(PyObject *ob)
{
    PyParamoaBooleanAppDef_oaTech value;
    int convert_status=PyoaBooleanAppDef_oaTech_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[44];
    sprintf(buffer,"<oaBooleanAppDef_oaTech::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBooleanAppDef_oaTech_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBooleanAppDef_oaTech v1;
    PyParamoaBooleanAppDef_oaTech v2;
    int convert_status1=PyoaBooleanAppDef_oaTech_Convert(ob1,&v1);
    int convert_status2=PyoaBooleanAppDef_oaTech_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBooleanAppDef_oaTech_Convert(PyObject* ob,PyParamoaBooleanAppDef_oaTech* result)
{
    if (ob == NULL) return 1;
    if (PyoaBooleanAppDef_oaTech_Check(ob)) {
        result->SetData( (oaBooleanAppDef_oaTech**) ((PyoaBooleanAppDef_oaTechObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBooleanAppDef_oaTech Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaTech_FromoaBooleanAppDef_oaTech(oaBooleanAppDef_oaTech** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBooleanAppDef_oaTech* data=*value;
        PyObject* bself = PyoaBooleanAppDef_oaTech_Type.tp_alloc(&PyoaBooleanAppDef_oaTech_Type,0);
        if (bself == NULL) return bself;
        PyoaBooleanAppDef_oaTechObject* self = (PyoaBooleanAppDef_oaTechObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaTech_FromoaBooleanAppDef_oaTech(oaBooleanAppDef_oaTech* data)
{
    if (data) {
       PyObject* bself = PyoaBooleanAppDef_oaTech_Type.tp_alloc(&PyoaBooleanAppDef_oaTech_Type,0);
       if (bself == NULL) return bself;
       PyoaBooleanAppDef_oaTechObject* self = (PyoaBooleanAppDef_oaTechObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTech_get_doc[] = 
"Class: oaBooleanAppDef_oaTech, Function: get\n"
"  Paramegers: (oaTech)\n"
"    Calls: oaBoolean get(const oaTech* object)\n"
"    Signature: get|simple-oaBoolean|cptr-oaTech,\n"
"    This function returns the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to get the value for this extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaTech_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaTech data;
    int convert_status=PyoaBooleanAppDef_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaTechObject* self=(PyoaBooleanAppDef_oaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTech p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTech_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->get(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTech_getDefault_doc[] = 
"Class: oaBooleanAppDef_oaTech, Function: getDefault\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean getDefault() const\n"
"    Signature: getDefault|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns the default value for this boolean extension.\n"
;

static PyObject*
oaBooleanAppDef_oaTech_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaTech data;
    int convert_status=PyoaBooleanAppDef_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaTechObject* self=(PyoaBooleanAppDef_oaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->getDefault());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTech_set_doc[] = 
"Class: oaBooleanAppDef_oaTech, Function: set\n"
"  Paramegers: (oaTech,oaBoolean)\n"
"    Calls: void set(oaTech* object,oaBoolean value)\n"
"    Signature: set|void-void|ptr-oaTech,simple-oaBoolean,\n"
"    This function sets the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to set the value for this extension\n"
"    value\n"
"    The value of the extension to set on the object\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaTech_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaTech data;
    int convert_status=PyoaBooleanAppDef_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaTechObject* self=(PyoaBooleanAppDef_oaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTech p1;
    PyParamoaBoolean p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTech_Convert,&p1,
          &PyoaBoolean_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTech_isNull_doc[] =
"Class: oaBooleanAppDef_oaTech, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBooleanAppDef_oaTech_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBooleanAppDef_oaTech data;
    int convert_status=PyoaBooleanAppDef_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBooleanAppDef_oaTech_assign_doc[] = 
"Class: oaBooleanAppDef_oaTech, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBooleanAppDef_oaTech_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBooleanAppDef_oaTech data;
  int convert_status=PyoaBooleanAppDef_oaTech_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBooleanAppDef_oaTech p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBooleanAppDef_oaTech_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBooleanAppDef_oaTech_methodlist[] = {
    {"get",(PyCFunction)oaBooleanAppDef_oaTech_get,METH_VARARGS,oaBooleanAppDef_oaTech_get_doc},
    {"getDefault",(PyCFunction)oaBooleanAppDef_oaTech_getDefault,METH_VARARGS,oaBooleanAppDef_oaTech_getDefault_doc},
    {"set",(PyCFunction)oaBooleanAppDef_oaTech_set,METH_VARARGS,oaBooleanAppDef_oaTech_set_doc},
    {"isNull",(PyCFunction)oaBooleanAppDef_oaTech_tp_isNull,METH_VARARGS,oaBooleanAppDef_oaTech_isNull_doc},
    {"assign",(PyCFunction)oaBooleanAppDef_oaTech_tp_assign,METH_VARARGS,oaBooleanAppDef_oaTech_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTech_doc[] = 
"Class: oaBooleanAppDef_oaTech\n"
"  The oaBooleanAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  Once created, a boolean field is added to each object of the specified dataType, with the specified default value. Applications can use the new data field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaBooleanAppDef_oaTech)\n"
"    Calls: (const oaBooleanAppDef_oaTech&)\n"
"    Signature: oaBooleanAppDef_oaTech||cref-oaBooleanAppDef_oaTech,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBooleanAppDef_oaTech_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBooleanAppDef_oaTech",
    sizeof(PyoaBooleanAppDef_oaTechObject),
    0,
    (destructor)oaBooleanAppDef_oaTech_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBooleanAppDef_oaTech_tp_compare,	/* tp_compare */
    (reprfunc)oaBooleanAppDef_oaTech_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBooleanAppDef_oaTech_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBooleanAppDef_oaTech_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBooleanAppDef_oaTech_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTech_static_find_doc[] = 
"Class: oaBooleanAppDef_oaTech, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaTech* find(const oaString& name)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaTech|cref-oaString,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaTech* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaTech|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaBooleanAppDef_oaTech_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaTechp result= (oaBooleanAppDef_oaTech::find(p1.Data()));
            return PyoaBooleanAppDef_oaTech_FromoaBooleanAppDef_oaTech(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaTechp result= (oaBooleanAppDef_oaTech::find(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaTech_FromoaBooleanAppDef_oaTech(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaTech, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTech_static_get_doc[] = 
"Class: oaBooleanAppDef_oaTech, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaTech* get(const oaString& name)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTech|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaTech* get(const oaString& name,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTech|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaTech* get(const oaString& name,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTech|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaTech* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTech|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaTech* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTech|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaTech* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTech|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
;

static PyObject*
oaBooleanAppDef_oaTech_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaTechp result= (oaBooleanAppDef_oaTech::get(p1.Data()));
            return PyoaBooleanAppDef_oaTech_FromoaBooleanAppDef_oaTech(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaBooleanAppDef_oaTechp result= (oaBooleanAppDef_oaTech::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaTech_FromoaBooleanAppDef_oaTech(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaBooleanAppDef_oaTechp result= (oaBooleanAppDef_oaTech::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaTech_FromoaBooleanAppDef_oaTech(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaTechp result= (oaBooleanAppDef_oaTech::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaTech_FromoaBooleanAppDef_oaTech(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaTechp result= (oaBooleanAppDef_oaTech::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaTech_FromoaBooleanAppDef_oaTech(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaTechp result= (oaBooleanAppDef_oaTech::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBooleanAppDef_oaTech_FromoaBooleanAppDef_oaTech(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaTech, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,oaBoolean,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBooleanAppDef_oaTech_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaBooleanAppDef_oaTech_static_find,METH_VARARGS,oaBooleanAppDef_oaTech_static_find_doc},
    {"static_get",(PyCFunction)oaBooleanAppDef_oaTech_static_get,METH_VARARGS,oaBooleanAppDef_oaTech_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBooleanAppDef_oaTech_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBooleanAppDef_oaTech_Type)<0) {
      printf("** PyType_Ready failed for: oaBooleanAppDef_oaTech\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBooleanAppDef_oaTech",
           (PyObject*)(&PyoaBooleanAppDef_oaTech_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBooleanAppDef_oaTech\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBooleanAppDef_oaTech_Type.tp_dict;
    for(method=oaBooleanAppDef_oaTech_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBooleanAppDef_oaTechHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaTechHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBooleanAppDef_oaTechHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBooleanAppDef_oaTechHeaderObject* self = (PyoaBooleanAppDef_oaTechHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBooleanAppDef_oaTechHeader)
    {
        PyParamoaBooleanAppDef_oaTechHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBooleanAppDef_oaTechHeader_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBooleanAppDef_oaTechHeader, Choices are:\n"
        "    (oaBooleanAppDef_oaTechHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBooleanAppDef_oaTechHeader_tp_dealloc(PyoaBooleanAppDef_oaTechHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaTechHeader_tp_repr(PyObject *ob)
{
    PyParamoaBooleanAppDef_oaTechHeader value;
    int convert_status=PyoaBooleanAppDef_oaTechHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[50];
    sprintf(buffer,"<oaBooleanAppDef_oaTechHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBooleanAppDef_oaTechHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBooleanAppDef_oaTechHeader v1;
    PyParamoaBooleanAppDef_oaTechHeader v2;
    int convert_status1=PyoaBooleanAppDef_oaTechHeader_Convert(ob1,&v1);
    int convert_status2=PyoaBooleanAppDef_oaTechHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBooleanAppDef_oaTechHeader_Convert(PyObject* ob,PyParamoaBooleanAppDef_oaTechHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaBooleanAppDef_oaTechHeader_Check(ob)) {
        result->SetData( (oaBooleanAppDef_oaTechHeader**) ((PyoaBooleanAppDef_oaTechHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBooleanAppDef_oaTechHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaTechHeader_FromoaBooleanAppDef_oaTechHeader(oaBooleanAppDef_oaTechHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBooleanAppDef_oaTechHeader* data=*value;
        PyObject* bself = PyoaBooleanAppDef_oaTechHeader_Type.tp_alloc(&PyoaBooleanAppDef_oaTechHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaBooleanAppDef_oaTechHeaderObject* self = (PyoaBooleanAppDef_oaTechHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaTechHeader_FromoaBooleanAppDef_oaTechHeader(oaBooleanAppDef_oaTechHeader* data)
{
    if (data) {
       PyObject* bself = PyoaBooleanAppDef_oaTechHeader_Type.tp_alloc(&PyoaBooleanAppDef_oaTechHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaBooleanAppDef_oaTechHeaderObject* self = (PyoaBooleanAppDef_oaTechHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTechHeader_get_doc[] = 
"Class: oaBooleanAppDef_oaTechHeader, Function: get\n"
"  Paramegers: (oaTechHeader)\n"
"    Calls: oaBoolean get(const oaTechHeader* object)\n"
"    Signature: get|simple-oaBoolean|cptr-oaTechHeader,\n"
"    This function returns the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to get the value for this extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaTechHeader_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaTechHeader data;
    int convert_status=PyoaBooleanAppDef_oaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaTechHeaderObject* self=(PyoaBooleanAppDef_oaTechHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechHeader p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTechHeader_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->get(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTechHeader_getDefault_doc[] = 
"Class: oaBooleanAppDef_oaTechHeader, Function: getDefault\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean getDefault() const\n"
"    Signature: getDefault|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns the default value for this boolean extension.\n"
;

static PyObject*
oaBooleanAppDef_oaTechHeader_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaTechHeader data;
    int convert_status=PyoaBooleanAppDef_oaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaTechHeaderObject* self=(PyoaBooleanAppDef_oaTechHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->getDefault());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTechHeader_set_doc[] = 
"Class: oaBooleanAppDef_oaTechHeader, Function: set\n"
"  Paramegers: (oaTechHeader,oaBoolean)\n"
"    Calls: void set(oaTechHeader* object,oaBoolean value)\n"
"    Signature: set|void-void|ptr-oaTechHeader,simple-oaBoolean,\n"
"    This function sets the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to set the value for this extension\n"
"    value\n"
"    The value of the extension to set on the object\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaTechHeader_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaTechHeader data;
    int convert_status=PyoaBooleanAppDef_oaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaTechHeaderObject* self=(PyoaBooleanAppDef_oaTechHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechHeader p1;
    PyParamoaBoolean p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTechHeader_Convert,&p1,
          &PyoaBoolean_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTechHeader_isNull_doc[] =
"Class: oaBooleanAppDef_oaTechHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBooleanAppDef_oaTechHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBooleanAppDef_oaTechHeader data;
    int convert_status=PyoaBooleanAppDef_oaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBooleanAppDef_oaTechHeader_assign_doc[] = 
"Class: oaBooleanAppDef_oaTechHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBooleanAppDef_oaTechHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBooleanAppDef_oaTechHeader data;
  int convert_status=PyoaBooleanAppDef_oaTechHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBooleanAppDef_oaTechHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBooleanAppDef_oaTechHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBooleanAppDef_oaTechHeader_methodlist[] = {
    {"get",(PyCFunction)oaBooleanAppDef_oaTechHeader_get,METH_VARARGS,oaBooleanAppDef_oaTechHeader_get_doc},
    {"getDefault",(PyCFunction)oaBooleanAppDef_oaTechHeader_getDefault,METH_VARARGS,oaBooleanAppDef_oaTechHeader_getDefault_doc},
    {"set",(PyCFunction)oaBooleanAppDef_oaTechHeader_set,METH_VARARGS,oaBooleanAppDef_oaTechHeader_set_doc},
    {"isNull",(PyCFunction)oaBooleanAppDef_oaTechHeader_tp_isNull,METH_VARARGS,oaBooleanAppDef_oaTechHeader_isNull_doc},
    {"assign",(PyCFunction)oaBooleanAppDef_oaTechHeader_tp_assign,METH_VARARGS,oaBooleanAppDef_oaTechHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTechHeader_doc[] = 
"Class: oaBooleanAppDef_oaTechHeader\n"
"  The oaBooleanAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  Once created, a boolean field is added to each object of the specified dataType, with the specified default value. Applications can use the new data field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaBooleanAppDef_oaTechHeader)\n"
"    Calls: (const oaBooleanAppDef_oaTechHeader&)\n"
"    Signature: oaBooleanAppDef_oaTechHeader||cref-oaBooleanAppDef_oaTechHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBooleanAppDef_oaTechHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBooleanAppDef_oaTechHeader",
    sizeof(PyoaBooleanAppDef_oaTechHeaderObject),
    0,
    (destructor)oaBooleanAppDef_oaTechHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBooleanAppDef_oaTechHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaBooleanAppDef_oaTechHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBooleanAppDef_oaTechHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBooleanAppDef_oaTechHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBooleanAppDef_oaTechHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTechHeader_static_find_doc[] = 
"Class: oaBooleanAppDef_oaTechHeader, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaTechHeader* find(const oaString& name)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaTechHeader|cref-oaString,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaTechHeader* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaTechHeader|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaBooleanAppDef_oaTechHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaTechHeaderp result= (oaBooleanAppDef_oaTechHeader::find(p1.Data()));
            return PyoaBooleanAppDef_oaTechHeader_FromoaBooleanAppDef_oaTechHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaTechHeaderp result= (oaBooleanAppDef_oaTechHeader::find(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaTechHeader_FromoaBooleanAppDef_oaTechHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaTechHeader, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTechHeader_static_get_doc[] = 
"Class: oaBooleanAppDef_oaTechHeader, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaTechHeader* get(const oaString& name)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTechHeader|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaTechHeader* get(const oaString& name,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTechHeader|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaTechHeader* get(const oaString& name,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTechHeader|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaTechHeader* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTechHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaTechHeader* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTechHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaTechHeader* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTechHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
;

static PyObject*
oaBooleanAppDef_oaTechHeader_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaTechHeaderp result= (oaBooleanAppDef_oaTechHeader::get(p1.Data()));
            return PyoaBooleanAppDef_oaTechHeader_FromoaBooleanAppDef_oaTechHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaBooleanAppDef_oaTechHeaderp result= (oaBooleanAppDef_oaTechHeader::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaTechHeader_FromoaBooleanAppDef_oaTechHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaBooleanAppDef_oaTechHeaderp result= (oaBooleanAppDef_oaTechHeader::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaTechHeader_FromoaBooleanAppDef_oaTechHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaTechHeaderp result= (oaBooleanAppDef_oaTechHeader::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaTechHeader_FromoaBooleanAppDef_oaTechHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaTechHeaderp result= (oaBooleanAppDef_oaTechHeader::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaTechHeader_FromoaBooleanAppDef_oaTechHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaTechHeaderp result= (oaBooleanAppDef_oaTechHeader::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBooleanAppDef_oaTechHeader_FromoaBooleanAppDef_oaTechHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaTechHeader, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,oaBoolean,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBooleanAppDef_oaTechHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaBooleanAppDef_oaTechHeader_static_find,METH_VARARGS,oaBooleanAppDef_oaTechHeader_static_find_doc},
    {"static_get",(PyCFunction)oaBooleanAppDef_oaTechHeader_static_get,METH_VARARGS,oaBooleanAppDef_oaTechHeader_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBooleanAppDef_oaTechHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBooleanAppDef_oaTechHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaBooleanAppDef_oaTechHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBooleanAppDef_oaTechHeader",
           (PyObject*)(&PyoaBooleanAppDef_oaTechHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBooleanAppDef_oaTechHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBooleanAppDef_oaTechHeader_Type.tp_dict;
    for(method=oaBooleanAppDef_oaTechHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBooleanAppDef_oaTechLayerHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaTechLayerHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBooleanAppDef_oaTechLayerHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBooleanAppDef_oaTechLayerHeaderObject* self = (PyoaBooleanAppDef_oaTechLayerHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBooleanAppDef_oaTechLayerHeader)
    {
        PyParamoaBooleanAppDef_oaTechLayerHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBooleanAppDef_oaTechLayerHeader_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBooleanAppDef_oaTechLayerHeader, Choices are:\n"
        "    (oaBooleanAppDef_oaTechLayerHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBooleanAppDef_oaTechLayerHeader_tp_dealloc(PyoaBooleanAppDef_oaTechLayerHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaTechLayerHeader_tp_repr(PyObject *ob)
{
    PyParamoaBooleanAppDef_oaTechLayerHeader value;
    int convert_status=PyoaBooleanAppDef_oaTechLayerHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[55];
    sprintf(buffer,"<oaBooleanAppDef_oaTechLayerHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBooleanAppDef_oaTechLayerHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBooleanAppDef_oaTechLayerHeader v1;
    PyParamoaBooleanAppDef_oaTechLayerHeader v2;
    int convert_status1=PyoaBooleanAppDef_oaTechLayerHeader_Convert(ob1,&v1);
    int convert_status2=PyoaBooleanAppDef_oaTechLayerHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBooleanAppDef_oaTechLayerHeader_Convert(PyObject* ob,PyParamoaBooleanAppDef_oaTechLayerHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaBooleanAppDef_oaTechLayerHeader_Check(ob)) {
        result->SetData( (oaBooleanAppDef_oaTechLayerHeader**) ((PyoaBooleanAppDef_oaTechLayerHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBooleanAppDef_oaTechLayerHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaTechLayerHeader_FromoaBooleanAppDef_oaTechLayerHeader(oaBooleanAppDef_oaTechLayerHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBooleanAppDef_oaTechLayerHeader* data=*value;
        PyObject* bself = PyoaBooleanAppDef_oaTechLayerHeader_Type.tp_alloc(&PyoaBooleanAppDef_oaTechLayerHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaBooleanAppDef_oaTechLayerHeaderObject* self = (PyoaBooleanAppDef_oaTechLayerHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaTechLayerHeader_FromoaBooleanAppDef_oaTechLayerHeader(oaBooleanAppDef_oaTechLayerHeader* data)
{
    if (data) {
       PyObject* bself = PyoaBooleanAppDef_oaTechLayerHeader_Type.tp_alloc(&PyoaBooleanAppDef_oaTechLayerHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaBooleanAppDef_oaTechLayerHeaderObject* self = (PyoaBooleanAppDef_oaTechLayerHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTechLayerHeader_get_doc[] = 
"Class: oaBooleanAppDef_oaTechLayerHeader, Function: get\n"
"  Paramegers: (oaTechLayerHeader)\n"
"    Calls: oaBoolean get(const oaTechLayerHeader* object)\n"
"    Signature: get|simple-oaBoolean|cptr-oaTechLayerHeader,\n"
"    This function returns the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to get the value for this extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaTechLayerHeader_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaTechLayerHeader data;
    int convert_status=PyoaBooleanAppDef_oaTechLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaTechLayerHeaderObject* self=(PyoaBooleanAppDef_oaTechLayerHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechLayerHeader p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTechLayerHeader_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->get(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTechLayerHeader_getDefault_doc[] = 
"Class: oaBooleanAppDef_oaTechLayerHeader, Function: getDefault\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean getDefault() const\n"
"    Signature: getDefault|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns the default value for this boolean extension.\n"
;

static PyObject*
oaBooleanAppDef_oaTechLayerHeader_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaTechLayerHeader data;
    int convert_status=PyoaBooleanAppDef_oaTechLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaTechLayerHeaderObject* self=(PyoaBooleanAppDef_oaTechLayerHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->getDefault());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTechLayerHeader_set_doc[] = 
"Class: oaBooleanAppDef_oaTechLayerHeader, Function: set\n"
"  Paramegers: (oaTechLayerHeader,oaBoolean)\n"
"    Calls: void set(oaTechLayerHeader* object,oaBoolean value)\n"
"    Signature: set|void-void|ptr-oaTechLayerHeader,simple-oaBoolean,\n"
"    This function sets the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to set the value for this extension\n"
"    value\n"
"    The value of the extension to set on the object\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaTechLayerHeader_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaTechLayerHeader data;
    int convert_status=PyoaBooleanAppDef_oaTechLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaTechLayerHeaderObject* self=(PyoaBooleanAppDef_oaTechLayerHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechLayerHeader p1;
    PyParamoaBoolean p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTechLayerHeader_Convert,&p1,
          &PyoaBoolean_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTechLayerHeader_isNull_doc[] =
"Class: oaBooleanAppDef_oaTechLayerHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBooleanAppDef_oaTechLayerHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBooleanAppDef_oaTechLayerHeader data;
    int convert_status=PyoaBooleanAppDef_oaTechLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBooleanAppDef_oaTechLayerHeader_assign_doc[] = 
"Class: oaBooleanAppDef_oaTechLayerHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBooleanAppDef_oaTechLayerHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBooleanAppDef_oaTechLayerHeader data;
  int convert_status=PyoaBooleanAppDef_oaTechLayerHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBooleanAppDef_oaTechLayerHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBooleanAppDef_oaTechLayerHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBooleanAppDef_oaTechLayerHeader_methodlist[] = {
    {"get",(PyCFunction)oaBooleanAppDef_oaTechLayerHeader_get,METH_VARARGS,oaBooleanAppDef_oaTechLayerHeader_get_doc},
    {"getDefault",(PyCFunction)oaBooleanAppDef_oaTechLayerHeader_getDefault,METH_VARARGS,oaBooleanAppDef_oaTechLayerHeader_getDefault_doc},
    {"set",(PyCFunction)oaBooleanAppDef_oaTechLayerHeader_set,METH_VARARGS,oaBooleanAppDef_oaTechLayerHeader_set_doc},
    {"isNull",(PyCFunction)oaBooleanAppDef_oaTechLayerHeader_tp_isNull,METH_VARARGS,oaBooleanAppDef_oaTechLayerHeader_isNull_doc},
    {"assign",(PyCFunction)oaBooleanAppDef_oaTechLayerHeader_tp_assign,METH_VARARGS,oaBooleanAppDef_oaTechLayerHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTechLayerHeader_doc[] = 
"Class: oaBooleanAppDef_oaTechLayerHeader\n"
"  The oaBooleanAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  Once created, a boolean field is added to each object of the specified dataType, with the specified default value. Applications can use the new data field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaBooleanAppDef_oaTechLayerHeader)\n"
"    Calls: (const oaBooleanAppDef_oaTechLayerHeader&)\n"
"    Signature: oaBooleanAppDef_oaTechLayerHeader||cref-oaBooleanAppDef_oaTechLayerHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBooleanAppDef_oaTechLayerHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBooleanAppDef_oaTechLayerHeader",
    sizeof(PyoaBooleanAppDef_oaTechLayerHeaderObject),
    0,
    (destructor)oaBooleanAppDef_oaTechLayerHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBooleanAppDef_oaTechLayerHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaBooleanAppDef_oaTechLayerHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBooleanAppDef_oaTechLayerHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBooleanAppDef_oaTechLayerHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBooleanAppDef_oaTechLayerHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTechLayerHeader_static_find_doc[] = 
"Class: oaBooleanAppDef_oaTechLayerHeader, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaTechLayerHeader* find(const oaString& name)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaTechLayerHeader|cref-oaString,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaTechLayerHeader* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaTechLayerHeader|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaBooleanAppDef_oaTechLayerHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaTechLayerHeaderp result= (oaBooleanAppDef_oaTechLayerHeader::find(p1.Data()));
            return PyoaBooleanAppDef_oaTechLayerHeader_FromoaBooleanAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaTechLayerHeaderp result= (oaBooleanAppDef_oaTechLayerHeader::find(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaTechLayerHeader_FromoaBooleanAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaTechLayerHeader, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTechLayerHeader_static_get_doc[] = 
"Class: oaBooleanAppDef_oaTechLayerHeader, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaTechLayerHeader* get(const oaString& name)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTechLayerHeader|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaTechLayerHeader* get(const oaString& name,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTechLayerHeader|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaTechLayerHeader* get(const oaString& name,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTechLayerHeader|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaTechLayerHeader* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTechLayerHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaTechLayerHeader* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTechLayerHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaTechLayerHeader* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTechLayerHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
;

static PyObject*
oaBooleanAppDef_oaTechLayerHeader_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaTechLayerHeaderp result= (oaBooleanAppDef_oaTechLayerHeader::get(p1.Data()));
            return PyoaBooleanAppDef_oaTechLayerHeader_FromoaBooleanAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaBooleanAppDef_oaTechLayerHeaderp result= (oaBooleanAppDef_oaTechLayerHeader::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaTechLayerHeader_FromoaBooleanAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaBooleanAppDef_oaTechLayerHeaderp result= (oaBooleanAppDef_oaTechLayerHeader::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaTechLayerHeader_FromoaBooleanAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaTechLayerHeaderp result= (oaBooleanAppDef_oaTechLayerHeader::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaTechLayerHeader_FromoaBooleanAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaTechLayerHeaderp result= (oaBooleanAppDef_oaTechLayerHeader::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaTechLayerHeader_FromoaBooleanAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaTechLayerHeaderp result= (oaBooleanAppDef_oaTechLayerHeader::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBooleanAppDef_oaTechLayerHeader_FromoaBooleanAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaTechLayerHeader, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,oaBoolean,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBooleanAppDef_oaTechLayerHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaBooleanAppDef_oaTechLayerHeader_static_find,METH_VARARGS,oaBooleanAppDef_oaTechLayerHeader_static_find_doc},
    {"static_get",(PyCFunction)oaBooleanAppDef_oaTechLayerHeader_static_get,METH_VARARGS,oaBooleanAppDef_oaTechLayerHeader_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBooleanAppDef_oaTechLayerHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBooleanAppDef_oaTechLayerHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaBooleanAppDef_oaTechLayerHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBooleanAppDef_oaTechLayerHeader",
           (PyObject*)(&PyoaBooleanAppDef_oaTechLayerHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBooleanAppDef_oaTechLayerHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBooleanAppDef_oaTechLayerHeader_Type.tp_dict;
    for(method=oaBooleanAppDef_oaTechLayerHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBooleanAppDef_oaTechViaDefHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaTechViaDefHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBooleanAppDef_oaTechViaDefHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBooleanAppDef_oaTechViaDefHeaderObject* self = (PyoaBooleanAppDef_oaTechViaDefHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBooleanAppDef_oaTechViaDefHeader)
    {
        PyParamoaBooleanAppDef_oaTechViaDefHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBooleanAppDef_oaTechViaDefHeader_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBooleanAppDef_oaTechViaDefHeader, Choices are:\n"
        "    (oaBooleanAppDef_oaTechViaDefHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBooleanAppDef_oaTechViaDefHeader_tp_dealloc(PyoaBooleanAppDef_oaTechViaDefHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaTechViaDefHeader_tp_repr(PyObject *ob)
{
    PyParamoaBooleanAppDef_oaTechViaDefHeader value;
    int convert_status=PyoaBooleanAppDef_oaTechViaDefHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[56];
    sprintf(buffer,"<oaBooleanAppDef_oaTechViaDefHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBooleanAppDef_oaTechViaDefHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBooleanAppDef_oaTechViaDefHeader v1;
    PyParamoaBooleanAppDef_oaTechViaDefHeader v2;
    int convert_status1=PyoaBooleanAppDef_oaTechViaDefHeader_Convert(ob1,&v1);
    int convert_status2=PyoaBooleanAppDef_oaTechViaDefHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBooleanAppDef_oaTechViaDefHeader_Convert(PyObject* ob,PyParamoaBooleanAppDef_oaTechViaDefHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaBooleanAppDef_oaTechViaDefHeader_Check(ob)) {
        result->SetData( (oaBooleanAppDef_oaTechViaDefHeader**) ((PyoaBooleanAppDef_oaTechViaDefHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBooleanAppDef_oaTechViaDefHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaTechViaDefHeader_FromoaBooleanAppDef_oaTechViaDefHeader(oaBooleanAppDef_oaTechViaDefHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBooleanAppDef_oaTechViaDefHeader* data=*value;
        PyObject* bself = PyoaBooleanAppDef_oaTechViaDefHeader_Type.tp_alloc(&PyoaBooleanAppDef_oaTechViaDefHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaBooleanAppDef_oaTechViaDefHeaderObject* self = (PyoaBooleanAppDef_oaTechViaDefHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaTechViaDefHeader_FromoaBooleanAppDef_oaTechViaDefHeader(oaBooleanAppDef_oaTechViaDefHeader* data)
{
    if (data) {
       PyObject* bself = PyoaBooleanAppDef_oaTechViaDefHeader_Type.tp_alloc(&PyoaBooleanAppDef_oaTechViaDefHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaBooleanAppDef_oaTechViaDefHeaderObject* self = (PyoaBooleanAppDef_oaTechViaDefHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTechViaDefHeader_get_doc[] = 
"Class: oaBooleanAppDef_oaTechViaDefHeader, Function: get\n"
"  Paramegers: (oaTechViaDefHeader)\n"
"    Calls: oaBoolean get(const oaTechViaDefHeader* object)\n"
"    Signature: get|simple-oaBoolean|cptr-oaTechViaDefHeader,\n"
"    This function returns the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to get the value for this extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaTechViaDefHeader_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaTechViaDefHeader data;
    int convert_status=PyoaBooleanAppDef_oaTechViaDefHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaTechViaDefHeaderObject* self=(PyoaBooleanAppDef_oaTechViaDefHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechViaDefHeader p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTechViaDefHeader_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->get(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTechViaDefHeader_getDefault_doc[] = 
"Class: oaBooleanAppDef_oaTechViaDefHeader, Function: getDefault\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean getDefault() const\n"
"    Signature: getDefault|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns the default value for this boolean extension.\n"
;

static PyObject*
oaBooleanAppDef_oaTechViaDefHeader_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaTechViaDefHeader data;
    int convert_status=PyoaBooleanAppDef_oaTechViaDefHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaTechViaDefHeaderObject* self=(PyoaBooleanAppDef_oaTechViaDefHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->getDefault());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTechViaDefHeader_set_doc[] = 
"Class: oaBooleanAppDef_oaTechViaDefHeader, Function: set\n"
"  Paramegers: (oaTechViaDefHeader,oaBoolean)\n"
"    Calls: void set(oaTechViaDefHeader* object,oaBoolean value)\n"
"    Signature: set|void-void|ptr-oaTechViaDefHeader,simple-oaBoolean,\n"
"    This function sets the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to set the value for this extension\n"
"    value\n"
"    The value of the extension to set on the object\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaTechViaDefHeader_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaTechViaDefHeader data;
    int convert_status=PyoaBooleanAppDef_oaTechViaDefHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaTechViaDefHeaderObject* self=(PyoaBooleanAppDef_oaTechViaDefHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechViaDefHeader p1;
    PyParamoaBoolean p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTechViaDefHeader_Convert,&p1,
          &PyoaBoolean_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTechViaDefHeader_isNull_doc[] =
"Class: oaBooleanAppDef_oaTechViaDefHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBooleanAppDef_oaTechViaDefHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBooleanAppDef_oaTechViaDefHeader data;
    int convert_status=PyoaBooleanAppDef_oaTechViaDefHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBooleanAppDef_oaTechViaDefHeader_assign_doc[] = 
"Class: oaBooleanAppDef_oaTechViaDefHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBooleanAppDef_oaTechViaDefHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBooleanAppDef_oaTechViaDefHeader data;
  int convert_status=PyoaBooleanAppDef_oaTechViaDefHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBooleanAppDef_oaTechViaDefHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBooleanAppDef_oaTechViaDefHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBooleanAppDef_oaTechViaDefHeader_methodlist[] = {
    {"get",(PyCFunction)oaBooleanAppDef_oaTechViaDefHeader_get,METH_VARARGS,oaBooleanAppDef_oaTechViaDefHeader_get_doc},
    {"getDefault",(PyCFunction)oaBooleanAppDef_oaTechViaDefHeader_getDefault,METH_VARARGS,oaBooleanAppDef_oaTechViaDefHeader_getDefault_doc},
    {"set",(PyCFunction)oaBooleanAppDef_oaTechViaDefHeader_set,METH_VARARGS,oaBooleanAppDef_oaTechViaDefHeader_set_doc},
    {"isNull",(PyCFunction)oaBooleanAppDef_oaTechViaDefHeader_tp_isNull,METH_VARARGS,oaBooleanAppDef_oaTechViaDefHeader_isNull_doc},
    {"assign",(PyCFunction)oaBooleanAppDef_oaTechViaDefHeader_tp_assign,METH_VARARGS,oaBooleanAppDef_oaTechViaDefHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTechViaDefHeader_doc[] = 
"Class: oaBooleanAppDef_oaTechViaDefHeader\n"
"  The oaBooleanAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  Once created, a boolean field is added to each object of the specified dataType, with the specified default value. Applications can use the new data field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaBooleanAppDef_oaTechViaDefHeader)\n"
"    Calls: (const oaBooleanAppDef_oaTechViaDefHeader&)\n"
"    Signature: oaBooleanAppDef_oaTechViaDefHeader||cref-oaBooleanAppDef_oaTechViaDefHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBooleanAppDef_oaTechViaDefHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBooleanAppDef_oaTechViaDefHeader",
    sizeof(PyoaBooleanAppDef_oaTechViaDefHeaderObject),
    0,
    (destructor)oaBooleanAppDef_oaTechViaDefHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBooleanAppDef_oaTechViaDefHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaBooleanAppDef_oaTechViaDefHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBooleanAppDef_oaTechViaDefHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBooleanAppDef_oaTechViaDefHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBooleanAppDef_oaTechViaDefHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTechViaDefHeader_static_find_doc[] = 
"Class: oaBooleanAppDef_oaTechViaDefHeader, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaTechViaDefHeader* find(const oaString& name)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaTechViaDefHeader|cref-oaString,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaTechViaDefHeader* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaTechViaDefHeader|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaBooleanAppDef_oaTechViaDefHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaTechViaDefHeaderp result= (oaBooleanAppDef_oaTechViaDefHeader::find(p1.Data()));
            return PyoaBooleanAppDef_oaTechViaDefHeader_FromoaBooleanAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaTechViaDefHeaderp result= (oaBooleanAppDef_oaTechViaDefHeader::find(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaTechViaDefHeader_FromoaBooleanAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaTechViaDefHeader, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTechViaDefHeader_static_get_doc[] = 
"Class: oaBooleanAppDef_oaTechViaDefHeader, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaTechViaDefHeader* get(const oaString& name)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTechViaDefHeader|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaTechViaDefHeader* get(const oaString& name,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTechViaDefHeader|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaTechViaDefHeader* get(const oaString& name,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTechViaDefHeader|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaTechViaDefHeader* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTechViaDefHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaTechViaDefHeader* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTechViaDefHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaTechViaDefHeader* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTechViaDefHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
;

static PyObject*
oaBooleanAppDef_oaTechViaDefHeader_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaTechViaDefHeaderp result= (oaBooleanAppDef_oaTechViaDefHeader::get(p1.Data()));
            return PyoaBooleanAppDef_oaTechViaDefHeader_FromoaBooleanAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaBooleanAppDef_oaTechViaDefHeaderp result= (oaBooleanAppDef_oaTechViaDefHeader::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaTechViaDefHeader_FromoaBooleanAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaBooleanAppDef_oaTechViaDefHeaderp result= (oaBooleanAppDef_oaTechViaDefHeader::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaTechViaDefHeader_FromoaBooleanAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaTechViaDefHeaderp result= (oaBooleanAppDef_oaTechViaDefHeader::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaTechViaDefHeader_FromoaBooleanAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaTechViaDefHeaderp result= (oaBooleanAppDef_oaTechViaDefHeader::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaTechViaDefHeader_FromoaBooleanAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaTechViaDefHeaderp result= (oaBooleanAppDef_oaTechViaDefHeader::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBooleanAppDef_oaTechViaDefHeader_FromoaBooleanAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaTechViaDefHeader, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,oaBoolean,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBooleanAppDef_oaTechViaDefHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaBooleanAppDef_oaTechViaDefHeader_static_find,METH_VARARGS,oaBooleanAppDef_oaTechViaDefHeader_static_find_doc},
    {"static_get",(PyCFunction)oaBooleanAppDef_oaTechViaDefHeader_static_get,METH_VARARGS,oaBooleanAppDef_oaTechViaDefHeader_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBooleanAppDef_oaTechViaDefHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBooleanAppDef_oaTechViaDefHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaBooleanAppDef_oaTechViaDefHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBooleanAppDef_oaTechViaDefHeader",
           (PyObject*)(&PyoaBooleanAppDef_oaTechViaDefHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBooleanAppDef_oaTechViaDefHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBooleanAppDef_oaTechViaDefHeader_Type.tp_dict;
    for(method=oaBooleanAppDef_oaTechViaDefHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBooleanAppDef_oaTerm
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaTerm_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBooleanAppDef_oaTerm_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBooleanAppDef_oaTermObject* self = (PyoaBooleanAppDef_oaTermObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBooleanAppDef_oaTerm)
    {
        PyParamoaBooleanAppDef_oaTerm p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBooleanAppDef_oaTerm_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBooleanAppDef_oaTerm, Choices are:\n"
        "    (oaBooleanAppDef_oaTerm)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBooleanAppDef_oaTerm_tp_dealloc(PyoaBooleanAppDef_oaTermObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaTerm_tp_repr(PyObject *ob)
{
    PyParamoaBooleanAppDef_oaTerm value;
    int convert_status=PyoaBooleanAppDef_oaTerm_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[44];
    sprintf(buffer,"<oaBooleanAppDef_oaTerm::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBooleanAppDef_oaTerm_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBooleanAppDef_oaTerm v1;
    PyParamoaBooleanAppDef_oaTerm v2;
    int convert_status1=PyoaBooleanAppDef_oaTerm_Convert(ob1,&v1);
    int convert_status2=PyoaBooleanAppDef_oaTerm_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBooleanAppDef_oaTerm_Convert(PyObject* ob,PyParamoaBooleanAppDef_oaTerm* result)
{
    if (ob == NULL) return 1;
    if (PyoaBooleanAppDef_oaTerm_Check(ob)) {
        result->SetData( (oaBooleanAppDef_oaTerm**) ((PyoaBooleanAppDef_oaTermObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBooleanAppDef_oaTerm Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaTerm_FromoaBooleanAppDef_oaTerm(oaBooleanAppDef_oaTerm** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBooleanAppDef_oaTerm* data=*value;
        PyObject* bself = PyoaBooleanAppDef_oaTerm_Type.tp_alloc(&PyoaBooleanAppDef_oaTerm_Type,0);
        if (bself == NULL) return bself;
        PyoaBooleanAppDef_oaTermObject* self = (PyoaBooleanAppDef_oaTermObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaTerm_FromoaBooleanAppDef_oaTerm(oaBooleanAppDef_oaTerm* data)
{
    if (data) {
       PyObject* bself = PyoaBooleanAppDef_oaTerm_Type.tp_alloc(&PyoaBooleanAppDef_oaTerm_Type,0);
       if (bself == NULL) return bself;
       PyoaBooleanAppDef_oaTermObject* self = (PyoaBooleanAppDef_oaTermObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTerm_get_doc[] = 
"Class: oaBooleanAppDef_oaTerm, Function: get\n"
"  Paramegers: (oaTerm)\n"
"    Calls: oaBoolean get(const oaTerm* object)\n"
"    Signature: get|simple-oaBoolean|cptr-oaTerm,\n"
"    This function returns the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to get the value for this extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaTerm_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaTerm data;
    int convert_status=PyoaBooleanAppDef_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaTermObject* self=(PyoaBooleanAppDef_oaTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTerm p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTerm_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->get(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTerm_getDefault_doc[] = 
"Class: oaBooleanAppDef_oaTerm, Function: getDefault\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean getDefault() const\n"
"    Signature: getDefault|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns the default value for this boolean extension.\n"
;

static PyObject*
oaBooleanAppDef_oaTerm_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaTerm data;
    int convert_status=PyoaBooleanAppDef_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaTermObject* self=(PyoaBooleanAppDef_oaTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->getDefault());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTerm_set_doc[] = 
"Class: oaBooleanAppDef_oaTerm, Function: set\n"
"  Paramegers: (oaTerm,oaBoolean)\n"
"    Calls: void set(oaTerm* object,oaBoolean value)\n"
"    Signature: set|void-void|ptr-oaTerm,simple-oaBoolean,\n"
"    This function sets the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to set the value for this extension\n"
"    value\n"
"    The value of the extension to set on the object\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaTerm_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaTerm data;
    int convert_status=PyoaBooleanAppDef_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaTermObject* self=(PyoaBooleanAppDef_oaTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTerm p1;
    PyParamoaBoolean p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTerm_Convert,&p1,
          &PyoaBoolean_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTerm_isNull_doc[] =
"Class: oaBooleanAppDef_oaTerm, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBooleanAppDef_oaTerm_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBooleanAppDef_oaTerm data;
    int convert_status=PyoaBooleanAppDef_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBooleanAppDef_oaTerm_assign_doc[] = 
"Class: oaBooleanAppDef_oaTerm, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBooleanAppDef_oaTerm_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBooleanAppDef_oaTerm data;
  int convert_status=PyoaBooleanAppDef_oaTerm_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBooleanAppDef_oaTerm p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBooleanAppDef_oaTerm_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBooleanAppDef_oaTerm_methodlist[] = {
    {"get",(PyCFunction)oaBooleanAppDef_oaTerm_get,METH_VARARGS,oaBooleanAppDef_oaTerm_get_doc},
    {"getDefault",(PyCFunction)oaBooleanAppDef_oaTerm_getDefault,METH_VARARGS,oaBooleanAppDef_oaTerm_getDefault_doc},
    {"set",(PyCFunction)oaBooleanAppDef_oaTerm_set,METH_VARARGS,oaBooleanAppDef_oaTerm_set_doc},
    {"isNull",(PyCFunction)oaBooleanAppDef_oaTerm_tp_isNull,METH_VARARGS,oaBooleanAppDef_oaTerm_isNull_doc},
    {"assign",(PyCFunction)oaBooleanAppDef_oaTerm_tp_assign,METH_VARARGS,oaBooleanAppDef_oaTerm_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTerm_doc[] = 
"Class: oaBooleanAppDef_oaTerm\n"
"  The oaBooleanAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  Once created, a boolean field is added to each object of the specified dataType, with the specified default value. Applications can use the new data field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaBooleanAppDef_oaTerm)\n"
"    Calls: (const oaBooleanAppDef_oaTerm&)\n"
"    Signature: oaBooleanAppDef_oaTerm||cref-oaBooleanAppDef_oaTerm,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBooleanAppDef_oaTerm_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBooleanAppDef_oaTerm",
    sizeof(PyoaBooleanAppDef_oaTermObject),
    0,
    (destructor)oaBooleanAppDef_oaTerm_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBooleanAppDef_oaTerm_tp_compare,	/* tp_compare */
    (reprfunc)oaBooleanAppDef_oaTerm_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBooleanAppDef_oaTerm_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBooleanAppDef_oaTerm_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBooleanAppDef_oaTerm_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTerm_static_find_doc[] = 
"Class: oaBooleanAppDef_oaTerm, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaTerm* find(const oaString& name)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaTerm|cref-oaString,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaTerm* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaTerm|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaBooleanAppDef_oaTerm_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaTermp result= (oaBooleanAppDef_oaTerm::find(p1.Data()));
            return PyoaBooleanAppDef_oaTerm_FromoaBooleanAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaTermp result= (oaBooleanAppDef_oaTerm::find(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaTerm_FromoaBooleanAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaTerm, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTerm_static_get_doc[] = 
"Class: oaBooleanAppDef_oaTerm, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaTerm* get(const oaString& name)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTerm|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaTerm* get(const oaString& name,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTerm|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaTerm* get(const oaString& name,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTerm|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaTerm* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTerm|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaTerm* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTerm|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaTerm* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTerm|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
;

static PyObject*
oaBooleanAppDef_oaTerm_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaTermp result= (oaBooleanAppDef_oaTerm::get(p1.Data()));
            return PyoaBooleanAppDef_oaTerm_FromoaBooleanAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaBooleanAppDef_oaTermp result= (oaBooleanAppDef_oaTerm::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaTerm_FromoaBooleanAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaBooleanAppDef_oaTermp result= (oaBooleanAppDef_oaTerm::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaTerm_FromoaBooleanAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaTermp result= (oaBooleanAppDef_oaTerm::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaTerm_FromoaBooleanAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaTermp result= (oaBooleanAppDef_oaTerm::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaTerm_FromoaBooleanAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaTermp result= (oaBooleanAppDef_oaTerm::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBooleanAppDef_oaTerm_FromoaBooleanAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaTerm, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,oaBoolean,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBooleanAppDef_oaTerm_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaBooleanAppDef_oaTerm_static_find,METH_VARARGS,oaBooleanAppDef_oaTerm_static_find_doc},
    {"static_get",(PyCFunction)oaBooleanAppDef_oaTerm_static_get,METH_VARARGS,oaBooleanAppDef_oaTerm_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBooleanAppDef_oaTerm_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBooleanAppDef_oaTerm_Type)<0) {
      printf("** PyType_Ready failed for: oaBooleanAppDef_oaTerm\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBooleanAppDef_oaTerm",
           (PyObject*)(&PyoaBooleanAppDef_oaTerm_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBooleanAppDef_oaTerm\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBooleanAppDef_oaTerm_Type.tp_dict;
    for(method=oaBooleanAppDef_oaTerm_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBooleanAppDef_oaTrackPattern
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaTrackPattern_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBooleanAppDef_oaTrackPattern_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBooleanAppDef_oaTrackPatternObject* self = (PyoaBooleanAppDef_oaTrackPatternObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBooleanAppDef_oaTrackPattern)
    {
        PyParamoaBooleanAppDef_oaTrackPattern p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBooleanAppDef_oaTrackPattern_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBooleanAppDef_oaTrackPattern, Choices are:\n"
        "    (oaBooleanAppDef_oaTrackPattern)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBooleanAppDef_oaTrackPattern_tp_dealloc(PyoaBooleanAppDef_oaTrackPatternObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaTrackPattern_tp_repr(PyObject *ob)
{
    PyParamoaBooleanAppDef_oaTrackPattern value;
    int convert_status=PyoaBooleanAppDef_oaTrackPattern_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[52];
    sprintf(buffer,"<oaBooleanAppDef_oaTrackPattern::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBooleanAppDef_oaTrackPattern_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBooleanAppDef_oaTrackPattern v1;
    PyParamoaBooleanAppDef_oaTrackPattern v2;
    int convert_status1=PyoaBooleanAppDef_oaTrackPattern_Convert(ob1,&v1);
    int convert_status2=PyoaBooleanAppDef_oaTrackPattern_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBooleanAppDef_oaTrackPattern_Convert(PyObject* ob,PyParamoaBooleanAppDef_oaTrackPattern* result)
{
    if (ob == NULL) return 1;
    if (PyoaBooleanAppDef_oaTrackPattern_Check(ob)) {
        result->SetData( (oaBooleanAppDef_oaTrackPattern**) ((PyoaBooleanAppDef_oaTrackPatternObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBooleanAppDef_oaTrackPattern Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaTrackPattern_FromoaBooleanAppDef_oaTrackPattern(oaBooleanAppDef_oaTrackPattern** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBooleanAppDef_oaTrackPattern* data=*value;
        PyObject* bself = PyoaBooleanAppDef_oaTrackPattern_Type.tp_alloc(&PyoaBooleanAppDef_oaTrackPattern_Type,0);
        if (bself == NULL) return bself;
        PyoaBooleanAppDef_oaTrackPatternObject* self = (PyoaBooleanAppDef_oaTrackPatternObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaTrackPattern_FromoaBooleanAppDef_oaTrackPattern(oaBooleanAppDef_oaTrackPattern* data)
{
    if (data) {
       PyObject* bself = PyoaBooleanAppDef_oaTrackPattern_Type.tp_alloc(&PyoaBooleanAppDef_oaTrackPattern_Type,0);
       if (bself == NULL) return bself;
       PyoaBooleanAppDef_oaTrackPatternObject* self = (PyoaBooleanAppDef_oaTrackPatternObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTrackPattern_get_doc[] = 
"Class: oaBooleanAppDef_oaTrackPattern, Function: get\n"
"  Paramegers: (oaTrackPattern)\n"
"    Calls: oaBoolean get(const oaTrackPattern* object)\n"
"    Signature: get|simple-oaBoolean|cptr-oaTrackPattern,\n"
"    This function returns the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to get the value for this extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaTrackPattern_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaTrackPattern data;
    int convert_status=PyoaBooleanAppDef_oaTrackPattern_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaTrackPatternObject* self=(PyoaBooleanAppDef_oaTrackPatternObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTrackPattern p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTrackPattern_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->get(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTrackPattern_getDefault_doc[] = 
"Class: oaBooleanAppDef_oaTrackPattern, Function: getDefault\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean getDefault() const\n"
"    Signature: getDefault|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns the default value for this boolean extension.\n"
;

static PyObject*
oaBooleanAppDef_oaTrackPattern_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaTrackPattern data;
    int convert_status=PyoaBooleanAppDef_oaTrackPattern_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaTrackPatternObject* self=(PyoaBooleanAppDef_oaTrackPatternObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->getDefault());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTrackPattern_set_doc[] = 
"Class: oaBooleanAppDef_oaTrackPattern, Function: set\n"
"  Paramegers: (oaTrackPattern,oaBoolean)\n"
"    Calls: void set(oaTrackPattern* object,oaBoolean value)\n"
"    Signature: set|void-void|ptr-oaTrackPattern,simple-oaBoolean,\n"
"    This function sets the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to set the value for this extension\n"
"    value\n"
"    The value of the extension to set on the object\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaTrackPattern_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaTrackPattern data;
    int convert_status=PyoaBooleanAppDef_oaTrackPattern_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaTrackPatternObject* self=(PyoaBooleanAppDef_oaTrackPatternObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTrackPattern p1;
    PyParamoaBoolean p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTrackPattern_Convert,&p1,
          &PyoaBoolean_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTrackPattern_isNull_doc[] =
"Class: oaBooleanAppDef_oaTrackPattern, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBooleanAppDef_oaTrackPattern_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBooleanAppDef_oaTrackPattern data;
    int convert_status=PyoaBooleanAppDef_oaTrackPattern_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBooleanAppDef_oaTrackPattern_assign_doc[] = 
"Class: oaBooleanAppDef_oaTrackPattern, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBooleanAppDef_oaTrackPattern_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBooleanAppDef_oaTrackPattern data;
  int convert_status=PyoaBooleanAppDef_oaTrackPattern_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBooleanAppDef_oaTrackPattern p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBooleanAppDef_oaTrackPattern_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBooleanAppDef_oaTrackPattern_methodlist[] = {
    {"get",(PyCFunction)oaBooleanAppDef_oaTrackPattern_get,METH_VARARGS,oaBooleanAppDef_oaTrackPattern_get_doc},
    {"getDefault",(PyCFunction)oaBooleanAppDef_oaTrackPattern_getDefault,METH_VARARGS,oaBooleanAppDef_oaTrackPattern_getDefault_doc},
    {"set",(PyCFunction)oaBooleanAppDef_oaTrackPattern_set,METH_VARARGS,oaBooleanAppDef_oaTrackPattern_set_doc},
    {"isNull",(PyCFunction)oaBooleanAppDef_oaTrackPattern_tp_isNull,METH_VARARGS,oaBooleanAppDef_oaTrackPattern_isNull_doc},
    {"assign",(PyCFunction)oaBooleanAppDef_oaTrackPattern_tp_assign,METH_VARARGS,oaBooleanAppDef_oaTrackPattern_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTrackPattern_doc[] = 
"Class: oaBooleanAppDef_oaTrackPattern\n"
"  The oaBooleanAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  Once created, a boolean field is added to each object of the specified dataType, with the specified default value. Applications can use the new data field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaBooleanAppDef_oaTrackPattern)\n"
"    Calls: (const oaBooleanAppDef_oaTrackPattern&)\n"
"    Signature: oaBooleanAppDef_oaTrackPattern||cref-oaBooleanAppDef_oaTrackPattern,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBooleanAppDef_oaTrackPattern_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBooleanAppDef_oaTrackPattern",
    sizeof(PyoaBooleanAppDef_oaTrackPatternObject),
    0,
    (destructor)oaBooleanAppDef_oaTrackPattern_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBooleanAppDef_oaTrackPattern_tp_compare,	/* tp_compare */
    (reprfunc)oaBooleanAppDef_oaTrackPattern_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBooleanAppDef_oaTrackPattern_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBooleanAppDef_oaTrackPattern_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBooleanAppDef_oaTrackPattern_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTrackPattern_static_find_doc[] = 
"Class: oaBooleanAppDef_oaTrackPattern, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaTrackPattern* find(const oaString& name)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaTrackPattern|cref-oaString,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaTrackPattern* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaTrackPattern|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaBooleanAppDef_oaTrackPattern_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaTrackPatternp result= (oaBooleanAppDef_oaTrackPattern::find(p1.Data()));
            return PyoaBooleanAppDef_oaTrackPattern_FromoaBooleanAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaTrackPatternp result= (oaBooleanAppDef_oaTrackPattern::find(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaTrackPattern_FromoaBooleanAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaTrackPattern, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaTrackPattern_static_get_doc[] = 
"Class: oaBooleanAppDef_oaTrackPattern, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaTrackPattern* get(const oaString& name)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTrackPattern|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaTrackPattern* get(const oaString& name,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTrackPattern|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaTrackPattern* get(const oaString& name,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTrackPattern|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaTrackPattern* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTrackPattern|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaTrackPattern* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTrackPattern|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaTrackPattern* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaTrackPattern|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
;

static PyObject*
oaBooleanAppDef_oaTrackPattern_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaTrackPatternp result= (oaBooleanAppDef_oaTrackPattern::get(p1.Data()));
            return PyoaBooleanAppDef_oaTrackPattern_FromoaBooleanAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaBooleanAppDef_oaTrackPatternp result= (oaBooleanAppDef_oaTrackPattern::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaTrackPattern_FromoaBooleanAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaBooleanAppDef_oaTrackPatternp result= (oaBooleanAppDef_oaTrackPattern::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaTrackPattern_FromoaBooleanAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaTrackPatternp result= (oaBooleanAppDef_oaTrackPattern::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaTrackPattern_FromoaBooleanAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaTrackPatternp result= (oaBooleanAppDef_oaTrackPattern::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaTrackPattern_FromoaBooleanAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaTrackPatternp result= (oaBooleanAppDef_oaTrackPattern::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBooleanAppDef_oaTrackPattern_FromoaBooleanAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaTrackPattern, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,oaBoolean,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBooleanAppDef_oaTrackPattern_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaBooleanAppDef_oaTrackPattern_static_find,METH_VARARGS,oaBooleanAppDef_oaTrackPattern_static_find_doc},
    {"static_get",(PyCFunction)oaBooleanAppDef_oaTrackPattern_static_get,METH_VARARGS,oaBooleanAppDef_oaTrackPattern_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBooleanAppDef_oaTrackPattern_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBooleanAppDef_oaTrackPattern_Type)<0) {
      printf("** PyType_Ready failed for: oaBooleanAppDef_oaTrackPattern\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBooleanAppDef_oaTrackPattern",
           (PyObject*)(&PyoaBooleanAppDef_oaTrackPattern_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBooleanAppDef_oaTrackPattern\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBooleanAppDef_oaTrackPattern_Type.tp_dict;
    for(method=oaBooleanAppDef_oaTrackPattern_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBooleanAppDef_oaValue
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaValue_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBooleanAppDef_oaValue_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBooleanAppDef_oaValueObject* self = (PyoaBooleanAppDef_oaValueObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBooleanAppDef_oaValue)
    {
        PyParamoaBooleanAppDef_oaValue p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBooleanAppDef_oaValue_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBooleanAppDef_oaValue, Choices are:\n"
        "    (oaBooleanAppDef_oaValue)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBooleanAppDef_oaValue_tp_dealloc(PyoaBooleanAppDef_oaValueObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaValue_tp_repr(PyObject *ob)
{
    PyParamoaBooleanAppDef_oaValue value;
    int convert_status=PyoaBooleanAppDef_oaValue_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[45];
    sprintf(buffer,"<oaBooleanAppDef_oaValue::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBooleanAppDef_oaValue_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBooleanAppDef_oaValue v1;
    PyParamoaBooleanAppDef_oaValue v2;
    int convert_status1=PyoaBooleanAppDef_oaValue_Convert(ob1,&v1);
    int convert_status2=PyoaBooleanAppDef_oaValue_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBooleanAppDef_oaValue_Convert(PyObject* ob,PyParamoaBooleanAppDef_oaValue* result)
{
    if (ob == NULL) return 1;
    if (PyoaBooleanAppDef_oaValue_Check(ob)) {
        result->SetData( (oaBooleanAppDef_oaValue**) ((PyoaBooleanAppDef_oaValueObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBooleanAppDef_oaValue Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaValue_FromoaBooleanAppDef_oaValue(oaBooleanAppDef_oaValue** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBooleanAppDef_oaValue* data=*value;
        PyObject* bself = PyoaBooleanAppDef_oaValue_Type.tp_alloc(&PyoaBooleanAppDef_oaValue_Type,0);
        if (bself == NULL) return bself;
        PyoaBooleanAppDef_oaValueObject* self = (PyoaBooleanAppDef_oaValueObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaValue_FromoaBooleanAppDef_oaValue(oaBooleanAppDef_oaValue* data)
{
    if (data) {
       PyObject* bself = PyoaBooleanAppDef_oaValue_Type.tp_alloc(&PyoaBooleanAppDef_oaValue_Type,0);
       if (bself == NULL) return bself;
       PyoaBooleanAppDef_oaValueObject* self = (PyoaBooleanAppDef_oaValueObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaValue_get_doc[] = 
"Class: oaBooleanAppDef_oaValue, Function: get\n"
"  Paramegers: (oaValue)\n"
"    Calls: oaBoolean get(const oaValue* object)\n"
"    Signature: get|simple-oaBoolean|cptr-oaValue,\n"
"    This function returns the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to get the value for this extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaValue_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaValue data;
    int convert_status=PyoaBooleanAppDef_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaValueObject* self=(PyoaBooleanAppDef_oaValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaValue p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaValue_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->get(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaValue_getDefault_doc[] = 
"Class: oaBooleanAppDef_oaValue, Function: getDefault\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean getDefault() const\n"
"    Signature: getDefault|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns the default value for this boolean extension.\n"
;

static PyObject*
oaBooleanAppDef_oaValue_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaValue data;
    int convert_status=PyoaBooleanAppDef_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaValueObject* self=(PyoaBooleanAppDef_oaValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->getDefault());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaValue_set_doc[] = 
"Class: oaBooleanAppDef_oaValue, Function: set\n"
"  Paramegers: (oaValue,oaBoolean)\n"
"    Calls: void set(oaValue* object,oaBoolean value)\n"
"    Signature: set|void-void|ptr-oaValue,simple-oaBoolean,\n"
"    This function sets the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to set the value for this extension\n"
"    value\n"
"    The value of the extension to set on the object\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaValue_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaValue data;
    int convert_status=PyoaBooleanAppDef_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaValueObject* self=(PyoaBooleanAppDef_oaValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaValue p1;
    PyParamoaBoolean p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaValue_Convert,&p1,
          &PyoaBoolean_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaValue_isNull_doc[] =
"Class: oaBooleanAppDef_oaValue, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBooleanAppDef_oaValue_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBooleanAppDef_oaValue data;
    int convert_status=PyoaBooleanAppDef_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBooleanAppDef_oaValue_assign_doc[] = 
"Class: oaBooleanAppDef_oaValue, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBooleanAppDef_oaValue_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBooleanAppDef_oaValue data;
  int convert_status=PyoaBooleanAppDef_oaValue_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBooleanAppDef_oaValue p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBooleanAppDef_oaValue_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBooleanAppDef_oaValue_methodlist[] = {
    {"get",(PyCFunction)oaBooleanAppDef_oaValue_get,METH_VARARGS,oaBooleanAppDef_oaValue_get_doc},
    {"getDefault",(PyCFunction)oaBooleanAppDef_oaValue_getDefault,METH_VARARGS,oaBooleanAppDef_oaValue_getDefault_doc},
    {"set",(PyCFunction)oaBooleanAppDef_oaValue_set,METH_VARARGS,oaBooleanAppDef_oaValue_set_doc},
    {"isNull",(PyCFunction)oaBooleanAppDef_oaValue_tp_isNull,METH_VARARGS,oaBooleanAppDef_oaValue_isNull_doc},
    {"assign",(PyCFunction)oaBooleanAppDef_oaValue_tp_assign,METH_VARARGS,oaBooleanAppDef_oaValue_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaValue_doc[] = 
"Class: oaBooleanAppDef_oaValue\n"
"  The oaBooleanAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  Once created, a boolean field is added to each object of the specified dataType, with the specified default value. Applications can use the new data field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaBooleanAppDef_oaValue)\n"
"    Calls: (const oaBooleanAppDef_oaValue&)\n"
"    Signature: oaBooleanAppDef_oaValue||cref-oaBooleanAppDef_oaValue,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBooleanAppDef_oaValue_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBooleanAppDef_oaValue",
    sizeof(PyoaBooleanAppDef_oaValueObject),
    0,
    (destructor)oaBooleanAppDef_oaValue_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBooleanAppDef_oaValue_tp_compare,	/* tp_compare */
    (reprfunc)oaBooleanAppDef_oaValue_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBooleanAppDef_oaValue_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBooleanAppDef_oaValue_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBooleanAppDef_oaValue_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaValue_static_find_doc[] = 
"Class: oaBooleanAppDef_oaValue, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaValue* find(const oaString& name)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaValue|cref-oaString,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaValue* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaValue|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaBooleanAppDef_oaValue_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaValuep result= (oaBooleanAppDef_oaValue::find(p1.Data()));
            return PyoaBooleanAppDef_oaValue_FromoaBooleanAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaValuep result= (oaBooleanAppDef_oaValue::find(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaValue_FromoaBooleanAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaValue, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaValue_static_get_doc[] = 
"Class: oaBooleanAppDef_oaValue, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaValue* get(const oaString& name)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaValue|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaValue* get(const oaString& name,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaValue|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaValue* get(const oaString& name,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaValue|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaValue* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaValue|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaValue* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaValue|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaValue* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaValue|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
;

static PyObject*
oaBooleanAppDef_oaValue_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaValuep result= (oaBooleanAppDef_oaValue::get(p1.Data()));
            return PyoaBooleanAppDef_oaValue_FromoaBooleanAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaBooleanAppDef_oaValuep result= (oaBooleanAppDef_oaValue::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaValue_FromoaBooleanAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaBooleanAppDef_oaValuep result= (oaBooleanAppDef_oaValue::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaValue_FromoaBooleanAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaValuep result= (oaBooleanAppDef_oaValue::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaValue_FromoaBooleanAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaValuep result= (oaBooleanAppDef_oaValue::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaValue_FromoaBooleanAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaValuep result= (oaBooleanAppDef_oaValue::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBooleanAppDef_oaValue_FromoaBooleanAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaValue, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,oaBoolean,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBooleanAppDef_oaValue_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaBooleanAppDef_oaValue_static_find,METH_VARARGS,oaBooleanAppDef_oaValue_static_find_doc},
    {"static_get",(PyCFunction)oaBooleanAppDef_oaValue_static_get,METH_VARARGS,oaBooleanAppDef_oaValue_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBooleanAppDef_oaValue_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBooleanAppDef_oaValue_Type)<0) {
      printf("** PyType_Ready failed for: oaBooleanAppDef_oaValue\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBooleanAppDef_oaValue",
           (PyObject*)(&PyoaBooleanAppDef_oaValue_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBooleanAppDef_oaValue\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBooleanAppDef_oaValue_Type.tp_dict;
    for(method=oaBooleanAppDef_oaValue_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBooleanAppDef_oaVectorInstDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaVectorInstDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBooleanAppDef_oaVectorInstDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBooleanAppDef_oaVectorInstDefObject* self = (PyoaBooleanAppDef_oaVectorInstDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBooleanAppDef_oaVectorInstDef)
    {
        PyParamoaBooleanAppDef_oaVectorInstDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBooleanAppDef_oaVectorInstDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBooleanAppDef_oaVectorInstDef, Choices are:\n"
        "    (oaBooleanAppDef_oaVectorInstDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBooleanAppDef_oaVectorInstDef_tp_dealloc(PyoaBooleanAppDef_oaVectorInstDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaVectorInstDef_tp_repr(PyObject *ob)
{
    PyParamoaBooleanAppDef_oaVectorInstDef value;
    int convert_status=PyoaBooleanAppDef_oaVectorInstDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[53];
    sprintf(buffer,"<oaBooleanAppDef_oaVectorInstDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBooleanAppDef_oaVectorInstDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBooleanAppDef_oaVectorInstDef v1;
    PyParamoaBooleanAppDef_oaVectorInstDef v2;
    int convert_status1=PyoaBooleanAppDef_oaVectorInstDef_Convert(ob1,&v1);
    int convert_status2=PyoaBooleanAppDef_oaVectorInstDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBooleanAppDef_oaVectorInstDef_Convert(PyObject* ob,PyParamoaBooleanAppDef_oaVectorInstDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaBooleanAppDef_oaVectorInstDef_Check(ob)) {
        result->SetData( (oaBooleanAppDef_oaVectorInstDef**) ((PyoaBooleanAppDef_oaVectorInstDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBooleanAppDef_oaVectorInstDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaVectorInstDef_FromoaBooleanAppDef_oaVectorInstDef(oaBooleanAppDef_oaVectorInstDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBooleanAppDef_oaVectorInstDef* data=*value;
        PyObject* bself = PyoaBooleanAppDef_oaVectorInstDef_Type.tp_alloc(&PyoaBooleanAppDef_oaVectorInstDef_Type,0);
        if (bself == NULL) return bself;
        PyoaBooleanAppDef_oaVectorInstDefObject* self = (PyoaBooleanAppDef_oaVectorInstDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaVectorInstDef_FromoaBooleanAppDef_oaVectorInstDef(oaBooleanAppDef_oaVectorInstDef* data)
{
    if (data) {
       PyObject* bself = PyoaBooleanAppDef_oaVectorInstDef_Type.tp_alloc(&PyoaBooleanAppDef_oaVectorInstDef_Type,0);
       if (bself == NULL) return bself;
       PyoaBooleanAppDef_oaVectorInstDefObject* self = (PyoaBooleanAppDef_oaVectorInstDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaVectorInstDef_get_doc[] = 
"Class: oaBooleanAppDef_oaVectorInstDef, Function: get\n"
"  Paramegers: (oaVectorInstDef)\n"
"    Calls: oaBoolean get(const oaVectorInstDef* object)\n"
"    Signature: get|simple-oaBoolean|cptr-oaVectorInstDef,\n"
"    This function returns the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to get the value for this extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaVectorInstDef_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaVectorInstDef data;
    int convert_status=PyoaBooleanAppDef_oaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaVectorInstDefObject* self=(PyoaBooleanAppDef_oaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaVectorInstDef p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaVectorInstDef_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->get(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaVectorInstDef_getDefault_doc[] = 
"Class: oaBooleanAppDef_oaVectorInstDef, Function: getDefault\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean getDefault() const\n"
"    Signature: getDefault|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns the default value for this boolean extension.\n"
;

static PyObject*
oaBooleanAppDef_oaVectorInstDef_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaVectorInstDef data;
    int convert_status=PyoaBooleanAppDef_oaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaVectorInstDefObject* self=(PyoaBooleanAppDef_oaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->getDefault());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaVectorInstDef_set_doc[] = 
"Class: oaBooleanAppDef_oaVectorInstDef, Function: set\n"
"  Paramegers: (oaVectorInstDef,oaBoolean)\n"
"    Calls: void set(oaVectorInstDef* object,oaBoolean value)\n"
"    Signature: set|void-void|ptr-oaVectorInstDef,simple-oaBoolean,\n"
"    This function sets the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to set the value for this extension\n"
"    value\n"
"    The value of the extension to set on the object\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaVectorInstDef_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaVectorInstDef data;
    int convert_status=PyoaBooleanAppDef_oaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaVectorInstDefObject* self=(PyoaBooleanAppDef_oaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaVectorInstDef p1;
    PyParamoaBoolean p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaVectorInstDef_Convert,&p1,
          &PyoaBoolean_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaVectorInstDef_isNull_doc[] =
"Class: oaBooleanAppDef_oaVectorInstDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBooleanAppDef_oaVectorInstDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBooleanAppDef_oaVectorInstDef data;
    int convert_status=PyoaBooleanAppDef_oaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBooleanAppDef_oaVectorInstDef_assign_doc[] = 
"Class: oaBooleanAppDef_oaVectorInstDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBooleanAppDef_oaVectorInstDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBooleanAppDef_oaVectorInstDef data;
  int convert_status=PyoaBooleanAppDef_oaVectorInstDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBooleanAppDef_oaVectorInstDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBooleanAppDef_oaVectorInstDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBooleanAppDef_oaVectorInstDef_methodlist[] = {
    {"get",(PyCFunction)oaBooleanAppDef_oaVectorInstDef_get,METH_VARARGS,oaBooleanAppDef_oaVectorInstDef_get_doc},
    {"getDefault",(PyCFunction)oaBooleanAppDef_oaVectorInstDef_getDefault,METH_VARARGS,oaBooleanAppDef_oaVectorInstDef_getDefault_doc},
    {"set",(PyCFunction)oaBooleanAppDef_oaVectorInstDef_set,METH_VARARGS,oaBooleanAppDef_oaVectorInstDef_set_doc},
    {"isNull",(PyCFunction)oaBooleanAppDef_oaVectorInstDef_tp_isNull,METH_VARARGS,oaBooleanAppDef_oaVectorInstDef_isNull_doc},
    {"assign",(PyCFunction)oaBooleanAppDef_oaVectorInstDef_tp_assign,METH_VARARGS,oaBooleanAppDef_oaVectorInstDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaVectorInstDef_doc[] = 
"Class: oaBooleanAppDef_oaVectorInstDef\n"
"  The oaBooleanAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  Once created, a boolean field is added to each object of the specified dataType, with the specified default value. Applications can use the new data field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaBooleanAppDef_oaVectorInstDef)\n"
"    Calls: (const oaBooleanAppDef_oaVectorInstDef&)\n"
"    Signature: oaBooleanAppDef_oaVectorInstDef||cref-oaBooleanAppDef_oaVectorInstDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBooleanAppDef_oaVectorInstDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBooleanAppDef_oaVectorInstDef",
    sizeof(PyoaBooleanAppDef_oaVectorInstDefObject),
    0,
    (destructor)oaBooleanAppDef_oaVectorInstDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBooleanAppDef_oaVectorInstDef_tp_compare,	/* tp_compare */
    (reprfunc)oaBooleanAppDef_oaVectorInstDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBooleanAppDef_oaVectorInstDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBooleanAppDef_oaVectorInstDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBooleanAppDef_oaVectorInstDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaVectorInstDef_static_find_doc[] = 
"Class: oaBooleanAppDef_oaVectorInstDef, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaVectorInstDef* find(const oaString& name)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaVectorInstDef|cref-oaString,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaVectorInstDef* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaVectorInstDef|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaBooleanAppDef_oaVectorInstDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaVectorInstDefp result= (oaBooleanAppDef_oaVectorInstDef::find(p1.Data()));
            return PyoaBooleanAppDef_oaVectorInstDef_FromoaBooleanAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaVectorInstDefp result= (oaBooleanAppDef_oaVectorInstDef::find(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaVectorInstDef_FromoaBooleanAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaVectorInstDef, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaVectorInstDef_static_get_doc[] = 
"Class: oaBooleanAppDef_oaVectorInstDef, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaVectorInstDef* get(const oaString& name)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaVectorInstDef|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaVectorInstDef* get(const oaString& name,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaVectorInstDef|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaVectorInstDef* get(const oaString& name,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaVectorInstDef|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaVectorInstDef* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaVectorInstDef|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaVectorInstDef* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaVectorInstDef|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaVectorInstDef* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaVectorInstDef|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
;

static PyObject*
oaBooleanAppDef_oaVectorInstDef_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaVectorInstDefp result= (oaBooleanAppDef_oaVectorInstDef::get(p1.Data()));
            return PyoaBooleanAppDef_oaVectorInstDef_FromoaBooleanAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaBooleanAppDef_oaVectorInstDefp result= (oaBooleanAppDef_oaVectorInstDef::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaVectorInstDef_FromoaBooleanAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaBooleanAppDef_oaVectorInstDefp result= (oaBooleanAppDef_oaVectorInstDef::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaVectorInstDef_FromoaBooleanAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaVectorInstDefp result= (oaBooleanAppDef_oaVectorInstDef::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaVectorInstDef_FromoaBooleanAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaVectorInstDefp result= (oaBooleanAppDef_oaVectorInstDef::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaVectorInstDef_FromoaBooleanAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaVectorInstDefp result= (oaBooleanAppDef_oaVectorInstDef::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBooleanAppDef_oaVectorInstDef_FromoaBooleanAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaVectorInstDef, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,oaBoolean,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBooleanAppDef_oaVectorInstDef_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaBooleanAppDef_oaVectorInstDef_static_find,METH_VARARGS,oaBooleanAppDef_oaVectorInstDef_static_find_doc},
    {"static_get",(PyCFunction)oaBooleanAppDef_oaVectorInstDef_static_get,METH_VARARGS,oaBooleanAppDef_oaVectorInstDef_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBooleanAppDef_oaVectorInstDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBooleanAppDef_oaVectorInstDef_Type)<0) {
      printf("** PyType_Ready failed for: oaBooleanAppDef_oaVectorInstDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBooleanAppDef_oaVectorInstDef",
           (PyObject*)(&PyoaBooleanAppDef_oaVectorInstDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBooleanAppDef_oaVectorInstDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBooleanAppDef_oaVectorInstDef_Type.tp_dict;
    for(method=oaBooleanAppDef_oaVectorInstDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBooleanAppDef_oaVia
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaVia_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBooleanAppDef_oaVia_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBooleanAppDef_oaViaObject* self = (PyoaBooleanAppDef_oaViaObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBooleanAppDef_oaVia)
    {
        PyParamoaBooleanAppDef_oaVia p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBooleanAppDef_oaVia_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBooleanAppDef_oaVia, Choices are:\n"
        "    (oaBooleanAppDef_oaVia)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBooleanAppDef_oaVia_tp_dealloc(PyoaBooleanAppDef_oaViaObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaVia_tp_repr(PyObject *ob)
{
    PyParamoaBooleanAppDef_oaVia value;
    int convert_status=PyoaBooleanAppDef_oaVia_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaBooleanAppDef_oaVia::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBooleanAppDef_oaVia_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBooleanAppDef_oaVia v1;
    PyParamoaBooleanAppDef_oaVia v2;
    int convert_status1=PyoaBooleanAppDef_oaVia_Convert(ob1,&v1);
    int convert_status2=PyoaBooleanAppDef_oaVia_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBooleanAppDef_oaVia_Convert(PyObject* ob,PyParamoaBooleanAppDef_oaVia* result)
{
    if (ob == NULL) return 1;
    if (PyoaBooleanAppDef_oaVia_Check(ob)) {
        result->SetData( (oaBooleanAppDef_oaVia**) ((PyoaBooleanAppDef_oaViaObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBooleanAppDef_oaVia Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaVia_FromoaBooleanAppDef_oaVia(oaBooleanAppDef_oaVia** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBooleanAppDef_oaVia* data=*value;
        PyObject* bself = PyoaBooleanAppDef_oaVia_Type.tp_alloc(&PyoaBooleanAppDef_oaVia_Type,0);
        if (bself == NULL) return bself;
        PyoaBooleanAppDef_oaViaObject* self = (PyoaBooleanAppDef_oaViaObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaVia_FromoaBooleanAppDef_oaVia(oaBooleanAppDef_oaVia* data)
{
    if (data) {
       PyObject* bself = PyoaBooleanAppDef_oaVia_Type.tp_alloc(&PyoaBooleanAppDef_oaVia_Type,0);
       if (bself == NULL) return bself;
       PyoaBooleanAppDef_oaViaObject* self = (PyoaBooleanAppDef_oaViaObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaVia_get_doc[] = 
"Class: oaBooleanAppDef_oaVia, Function: get\n"
"  Paramegers: (oaVia)\n"
"    Calls: oaBoolean get(const oaVia* object)\n"
"    Signature: get|simple-oaBoolean|cptr-oaVia,\n"
"    This function returns the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to get the value for this extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaVia_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaVia data;
    int convert_status=PyoaBooleanAppDef_oaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaViaObject* self=(PyoaBooleanAppDef_oaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaVia p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaVia_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->get(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaVia_getDefault_doc[] = 
"Class: oaBooleanAppDef_oaVia, Function: getDefault\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean getDefault() const\n"
"    Signature: getDefault|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns the default value for this boolean extension.\n"
;

static PyObject*
oaBooleanAppDef_oaVia_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaVia data;
    int convert_status=PyoaBooleanAppDef_oaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaViaObject* self=(PyoaBooleanAppDef_oaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->getDefault());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaVia_set_doc[] = 
"Class: oaBooleanAppDef_oaVia, Function: set\n"
"  Paramegers: (oaVia,oaBoolean)\n"
"    Calls: void set(oaVia* object,oaBoolean value)\n"
"    Signature: set|void-void|ptr-oaVia,simple-oaBoolean,\n"
"    This function sets the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to set the value for this extension\n"
"    value\n"
"    The value of the extension to set on the object\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaVia_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaVia data;
    int convert_status=PyoaBooleanAppDef_oaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaViaObject* self=(PyoaBooleanAppDef_oaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaVia p1;
    PyParamoaBoolean p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaVia_Convert,&p1,
          &PyoaBoolean_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaVia_isNull_doc[] =
"Class: oaBooleanAppDef_oaVia, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBooleanAppDef_oaVia_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBooleanAppDef_oaVia data;
    int convert_status=PyoaBooleanAppDef_oaVia_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBooleanAppDef_oaVia_assign_doc[] = 
"Class: oaBooleanAppDef_oaVia, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBooleanAppDef_oaVia_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBooleanAppDef_oaVia data;
  int convert_status=PyoaBooleanAppDef_oaVia_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBooleanAppDef_oaVia p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBooleanAppDef_oaVia_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBooleanAppDef_oaVia_methodlist[] = {
    {"get",(PyCFunction)oaBooleanAppDef_oaVia_get,METH_VARARGS,oaBooleanAppDef_oaVia_get_doc},
    {"getDefault",(PyCFunction)oaBooleanAppDef_oaVia_getDefault,METH_VARARGS,oaBooleanAppDef_oaVia_getDefault_doc},
    {"set",(PyCFunction)oaBooleanAppDef_oaVia_set,METH_VARARGS,oaBooleanAppDef_oaVia_set_doc},
    {"isNull",(PyCFunction)oaBooleanAppDef_oaVia_tp_isNull,METH_VARARGS,oaBooleanAppDef_oaVia_isNull_doc},
    {"assign",(PyCFunction)oaBooleanAppDef_oaVia_tp_assign,METH_VARARGS,oaBooleanAppDef_oaVia_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaVia_doc[] = 
"Class: oaBooleanAppDef_oaVia\n"
"  The oaBooleanAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  Once created, a boolean field is added to each object of the specified dataType, with the specified default value. Applications can use the new data field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaBooleanAppDef_oaVia)\n"
"    Calls: (const oaBooleanAppDef_oaVia&)\n"
"    Signature: oaBooleanAppDef_oaVia||cref-oaBooleanAppDef_oaVia,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBooleanAppDef_oaVia_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBooleanAppDef_oaVia",
    sizeof(PyoaBooleanAppDef_oaViaObject),
    0,
    (destructor)oaBooleanAppDef_oaVia_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBooleanAppDef_oaVia_tp_compare,	/* tp_compare */
    (reprfunc)oaBooleanAppDef_oaVia_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBooleanAppDef_oaVia_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBooleanAppDef_oaVia_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBooleanAppDef_oaVia_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaVia_static_find_doc[] = 
"Class: oaBooleanAppDef_oaVia, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaVia* find(const oaString& name)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaVia|cref-oaString,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaVia* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaVia|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaBooleanAppDef_oaVia_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaViap result= (oaBooleanAppDef_oaVia::find(p1.Data()));
            return PyoaBooleanAppDef_oaVia_FromoaBooleanAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaViap result= (oaBooleanAppDef_oaVia::find(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaVia_FromoaBooleanAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaVia, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaVia_static_get_doc[] = 
"Class: oaBooleanAppDef_oaVia, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaVia* get(const oaString& name)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaVia|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaVia* get(const oaString& name,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaVia|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaVia* get(const oaString& name,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaVia|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaVia* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaVia|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaVia* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaVia|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaVia* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaVia|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
;

static PyObject*
oaBooleanAppDef_oaVia_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaViap result= (oaBooleanAppDef_oaVia::get(p1.Data()));
            return PyoaBooleanAppDef_oaVia_FromoaBooleanAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaBooleanAppDef_oaViap result= (oaBooleanAppDef_oaVia::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaVia_FromoaBooleanAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaBooleanAppDef_oaViap result= (oaBooleanAppDef_oaVia::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaVia_FromoaBooleanAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaViap result= (oaBooleanAppDef_oaVia::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaVia_FromoaBooleanAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaViap result= (oaBooleanAppDef_oaVia::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaVia_FromoaBooleanAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaViap result= (oaBooleanAppDef_oaVia::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBooleanAppDef_oaVia_FromoaBooleanAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaVia, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,oaBoolean,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBooleanAppDef_oaVia_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaBooleanAppDef_oaVia_static_find,METH_VARARGS,oaBooleanAppDef_oaVia_static_find_doc},
    {"static_get",(PyCFunction)oaBooleanAppDef_oaVia_static_get,METH_VARARGS,oaBooleanAppDef_oaVia_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBooleanAppDef_oaVia_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBooleanAppDef_oaVia_Type)<0) {
      printf("** PyType_Ready failed for: oaBooleanAppDef_oaVia\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBooleanAppDef_oaVia",
           (PyObject*)(&PyoaBooleanAppDef_oaVia_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBooleanAppDef_oaVia\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBooleanAppDef_oaVia_Type.tp_dict;
    for(method=oaBooleanAppDef_oaVia_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBooleanAppDef_oaViaDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaViaDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBooleanAppDef_oaViaDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBooleanAppDef_oaViaDefObject* self = (PyoaBooleanAppDef_oaViaDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBooleanAppDef_oaViaDef)
    {
        PyParamoaBooleanAppDef_oaViaDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBooleanAppDef_oaViaDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBooleanAppDef_oaViaDef, Choices are:\n"
        "    (oaBooleanAppDef_oaViaDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBooleanAppDef_oaViaDef_tp_dealloc(PyoaBooleanAppDef_oaViaDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaViaDef_tp_repr(PyObject *ob)
{
    PyParamoaBooleanAppDef_oaViaDef value;
    int convert_status=PyoaBooleanAppDef_oaViaDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[46];
    sprintf(buffer,"<oaBooleanAppDef_oaViaDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBooleanAppDef_oaViaDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBooleanAppDef_oaViaDef v1;
    PyParamoaBooleanAppDef_oaViaDef v2;
    int convert_status1=PyoaBooleanAppDef_oaViaDef_Convert(ob1,&v1);
    int convert_status2=PyoaBooleanAppDef_oaViaDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBooleanAppDef_oaViaDef_Convert(PyObject* ob,PyParamoaBooleanAppDef_oaViaDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaBooleanAppDef_oaViaDef_Check(ob)) {
        result->SetData( (oaBooleanAppDef_oaViaDef**) ((PyoaBooleanAppDef_oaViaDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBooleanAppDef_oaViaDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaViaDef_FromoaBooleanAppDef_oaViaDef(oaBooleanAppDef_oaViaDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBooleanAppDef_oaViaDef* data=*value;
        PyObject* bself = PyoaBooleanAppDef_oaViaDef_Type.tp_alloc(&PyoaBooleanAppDef_oaViaDef_Type,0);
        if (bself == NULL) return bself;
        PyoaBooleanAppDef_oaViaDefObject* self = (PyoaBooleanAppDef_oaViaDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaViaDef_FromoaBooleanAppDef_oaViaDef(oaBooleanAppDef_oaViaDef* data)
{
    if (data) {
       PyObject* bself = PyoaBooleanAppDef_oaViaDef_Type.tp_alloc(&PyoaBooleanAppDef_oaViaDef_Type,0);
       if (bself == NULL) return bself;
       PyoaBooleanAppDef_oaViaDefObject* self = (PyoaBooleanAppDef_oaViaDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaViaDef_get_doc[] = 
"Class: oaBooleanAppDef_oaViaDef, Function: get\n"
"  Paramegers: (oaViaDef)\n"
"    Calls: oaBoolean get(const oaViaDef* object)\n"
"    Signature: get|simple-oaBoolean|cptr-oaViaDef,\n"
"    This function returns the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to get the value for this extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaViaDef_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaViaDef data;
    int convert_status=PyoaBooleanAppDef_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaViaDefObject* self=(PyoaBooleanAppDef_oaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaDef p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaViaDef_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->get(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaViaDef_getDefault_doc[] = 
"Class: oaBooleanAppDef_oaViaDef, Function: getDefault\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean getDefault() const\n"
"    Signature: getDefault|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns the default value for this boolean extension.\n"
;

static PyObject*
oaBooleanAppDef_oaViaDef_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaViaDef data;
    int convert_status=PyoaBooleanAppDef_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaViaDefObject* self=(PyoaBooleanAppDef_oaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->getDefault());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaViaDef_set_doc[] = 
"Class: oaBooleanAppDef_oaViaDef, Function: set\n"
"  Paramegers: (oaViaDef,oaBoolean)\n"
"    Calls: void set(oaViaDef* object,oaBoolean value)\n"
"    Signature: set|void-void|ptr-oaViaDef,simple-oaBoolean,\n"
"    This function sets the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to set the value for this extension\n"
"    value\n"
"    The value of the extension to set on the object\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaViaDef_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaViaDef data;
    int convert_status=PyoaBooleanAppDef_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaViaDefObject* self=(PyoaBooleanAppDef_oaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaDef p1;
    PyParamoaBoolean p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViaDef_Convert,&p1,
          &PyoaBoolean_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaViaDef_isNull_doc[] =
"Class: oaBooleanAppDef_oaViaDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBooleanAppDef_oaViaDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBooleanAppDef_oaViaDef data;
    int convert_status=PyoaBooleanAppDef_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBooleanAppDef_oaViaDef_assign_doc[] = 
"Class: oaBooleanAppDef_oaViaDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBooleanAppDef_oaViaDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBooleanAppDef_oaViaDef data;
  int convert_status=PyoaBooleanAppDef_oaViaDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBooleanAppDef_oaViaDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBooleanAppDef_oaViaDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBooleanAppDef_oaViaDef_methodlist[] = {
    {"get",(PyCFunction)oaBooleanAppDef_oaViaDef_get,METH_VARARGS,oaBooleanAppDef_oaViaDef_get_doc},
    {"getDefault",(PyCFunction)oaBooleanAppDef_oaViaDef_getDefault,METH_VARARGS,oaBooleanAppDef_oaViaDef_getDefault_doc},
    {"set",(PyCFunction)oaBooleanAppDef_oaViaDef_set,METH_VARARGS,oaBooleanAppDef_oaViaDef_set_doc},
    {"isNull",(PyCFunction)oaBooleanAppDef_oaViaDef_tp_isNull,METH_VARARGS,oaBooleanAppDef_oaViaDef_isNull_doc},
    {"assign",(PyCFunction)oaBooleanAppDef_oaViaDef_tp_assign,METH_VARARGS,oaBooleanAppDef_oaViaDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaViaDef_doc[] = 
"Class: oaBooleanAppDef_oaViaDef\n"
"  The oaBooleanAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  Once created, a boolean field is added to each object of the specified dataType, with the specified default value. Applications can use the new data field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaBooleanAppDef_oaViaDef)\n"
"    Calls: (const oaBooleanAppDef_oaViaDef&)\n"
"    Signature: oaBooleanAppDef_oaViaDef||cref-oaBooleanAppDef_oaViaDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBooleanAppDef_oaViaDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBooleanAppDef_oaViaDef",
    sizeof(PyoaBooleanAppDef_oaViaDefObject),
    0,
    (destructor)oaBooleanAppDef_oaViaDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBooleanAppDef_oaViaDef_tp_compare,	/* tp_compare */
    (reprfunc)oaBooleanAppDef_oaViaDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBooleanAppDef_oaViaDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBooleanAppDef_oaViaDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBooleanAppDef_oaViaDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaViaDef_static_find_doc[] = 
"Class: oaBooleanAppDef_oaViaDef, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaViaDef* find(const oaString& name)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaViaDef|cref-oaString,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaViaDef* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaViaDef|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaBooleanAppDef_oaViaDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaViaDefp result= (oaBooleanAppDef_oaViaDef::find(p1.Data()));
            return PyoaBooleanAppDef_oaViaDef_FromoaBooleanAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaViaDefp result= (oaBooleanAppDef_oaViaDef::find(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaViaDef_FromoaBooleanAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaViaDef, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaViaDef_static_get_doc[] = 
"Class: oaBooleanAppDef_oaViaDef, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaViaDef* get(const oaString& name)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaViaDef|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaViaDef* get(const oaString& name,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaViaDef|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaViaDef* get(const oaString& name,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaViaDef|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaViaDef* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaViaDef|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaViaDef* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaViaDef|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaViaDef* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaViaDef|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
;

static PyObject*
oaBooleanAppDef_oaViaDef_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaViaDefp result= (oaBooleanAppDef_oaViaDef::get(p1.Data()));
            return PyoaBooleanAppDef_oaViaDef_FromoaBooleanAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaBooleanAppDef_oaViaDefp result= (oaBooleanAppDef_oaViaDef::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaViaDef_FromoaBooleanAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaBooleanAppDef_oaViaDefp result= (oaBooleanAppDef_oaViaDef::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaViaDef_FromoaBooleanAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaViaDefp result= (oaBooleanAppDef_oaViaDef::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaViaDef_FromoaBooleanAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaViaDefp result= (oaBooleanAppDef_oaViaDef::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaViaDef_FromoaBooleanAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaViaDefp result= (oaBooleanAppDef_oaViaDef::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBooleanAppDef_oaViaDef_FromoaBooleanAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaViaDef, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,oaBoolean,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBooleanAppDef_oaViaDef_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaBooleanAppDef_oaViaDef_static_find,METH_VARARGS,oaBooleanAppDef_oaViaDef_static_find_doc},
    {"static_get",(PyCFunction)oaBooleanAppDef_oaViaDef_static_get,METH_VARARGS,oaBooleanAppDef_oaViaDef_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBooleanAppDef_oaViaDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBooleanAppDef_oaViaDef_Type)<0) {
      printf("** PyType_Ready failed for: oaBooleanAppDef_oaViaDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBooleanAppDef_oaViaDef",
           (PyObject*)(&PyoaBooleanAppDef_oaViaDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBooleanAppDef_oaViaDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBooleanAppDef_oaViaDef_Type.tp_dict;
    for(method=oaBooleanAppDef_oaViaDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBooleanAppDef_oaViaHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaViaHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBooleanAppDef_oaViaHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBooleanAppDef_oaViaHeaderObject* self = (PyoaBooleanAppDef_oaViaHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBooleanAppDef_oaViaHeader)
    {
        PyParamoaBooleanAppDef_oaViaHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBooleanAppDef_oaViaHeader_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBooleanAppDef_oaViaHeader, Choices are:\n"
        "    (oaBooleanAppDef_oaViaHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBooleanAppDef_oaViaHeader_tp_dealloc(PyoaBooleanAppDef_oaViaHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaViaHeader_tp_repr(PyObject *ob)
{
    PyParamoaBooleanAppDef_oaViaHeader value;
    int convert_status=PyoaBooleanAppDef_oaViaHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[49];
    sprintf(buffer,"<oaBooleanAppDef_oaViaHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBooleanAppDef_oaViaHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBooleanAppDef_oaViaHeader v1;
    PyParamoaBooleanAppDef_oaViaHeader v2;
    int convert_status1=PyoaBooleanAppDef_oaViaHeader_Convert(ob1,&v1);
    int convert_status2=PyoaBooleanAppDef_oaViaHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBooleanAppDef_oaViaHeader_Convert(PyObject* ob,PyParamoaBooleanAppDef_oaViaHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaBooleanAppDef_oaViaHeader_Check(ob)) {
        result->SetData( (oaBooleanAppDef_oaViaHeader**) ((PyoaBooleanAppDef_oaViaHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBooleanAppDef_oaViaHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaViaHeader_FromoaBooleanAppDef_oaViaHeader(oaBooleanAppDef_oaViaHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBooleanAppDef_oaViaHeader* data=*value;
        PyObject* bself = PyoaBooleanAppDef_oaViaHeader_Type.tp_alloc(&PyoaBooleanAppDef_oaViaHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaBooleanAppDef_oaViaHeaderObject* self = (PyoaBooleanAppDef_oaViaHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaViaHeader_FromoaBooleanAppDef_oaViaHeader(oaBooleanAppDef_oaViaHeader* data)
{
    if (data) {
       PyObject* bself = PyoaBooleanAppDef_oaViaHeader_Type.tp_alloc(&PyoaBooleanAppDef_oaViaHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaBooleanAppDef_oaViaHeaderObject* self = (PyoaBooleanAppDef_oaViaHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaViaHeader_get_doc[] = 
"Class: oaBooleanAppDef_oaViaHeader, Function: get\n"
"  Paramegers: (oaViaHeader)\n"
"    Calls: oaBoolean get(const oaViaHeader* object)\n"
"    Signature: get|simple-oaBoolean|cptr-oaViaHeader,\n"
"    This function returns the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to get the value for this extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaViaHeader_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaViaHeader data;
    int convert_status=PyoaBooleanAppDef_oaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaViaHeaderObject* self=(PyoaBooleanAppDef_oaViaHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaHeader p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaViaHeader_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->get(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaViaHeader_getDefault_doc[] = 
"Class: oaBooleanAppDef_oaViaHeader, Function: getDefault\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean getDefault() const\n"
"    Signature: getDefault|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns the default value for this boolean extension.\n"
;

static PyObject*
oaBooleanAppDef_oaViaHeader_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaViaHeader data;
    int convert_status=PyoaBooleanAppDef_oaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaViaHeaderObject* self=(PyoaBooleanAppDef_oaViaHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->getDefault());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaViaHeader_set_doc[] = 
"Class: oaBooleanAppDef_oaViaHeader, Function: set\n"
"  Paramegers: (oaViaHeader,oaBoolean)\n"
"    Calls: void set(oaViaHeader* object,oaBoolean value)\n"
"    Signature: set|void-void|ptr-oaViaHeader,simple-oaBoolean,\n"
"    This function sets the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to set the value for this extension\n"
"    value\n"
"    The value of the extension to set on the object\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaViaHeader_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaViaHeader data;
    int convert_status=PyoaBooleanAppDef_oaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaViaHeaderObject* self=(PyoaBooleanAppDef_oaViaHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaHeader p1;
    PyParamoaBoolean p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViaHeader_Convert,&p1,
          &PyoaBoolean_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaViaHeader_isNull_doc[] =
"Class: oaBooleanAppDef_oaViaHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBooleanAppDef_oaViaHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBooleanAppDef_oaViaHeader data;
    int convert_status=PyoaBooleanAppDef_oaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBooleanAppDef_oaViaHeader_assign_doc[] = 
"Class: oaBooleanAppDef_oaViaHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBooleanAppDef_oaViaHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBooleanAppDef_oaViaHeader data;
  int convert_status=PyoaBooleanAppDef_oaViaHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBooleanAppDef_oaViaHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBooleanAppDef_oaViaHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBooleanAppDef_oaViaHeader_methodlist[] = {
    {"get",(PyCFunction)oaBooleanAppDef_oaViaHeader_get,METH_VARARGS,oaBooleanAppDef_oaViaHeader_get_doc},
    {"getDefault",(PyCFunction)oaBooleanAppDef_oaViaHeader_getDefault,METH_VARARGS,oaBooleanAppDef_oaViaHeader_getDefault_doc},
    {"set",(PyCFunction)oaBooleanAppDef_oaViaHeader_set,METH_VARARGS,oaBooleanAppDef_oaViaHeader_set_doc},
    {"isNull",(PyCFunction)oaBooleanAppDef_oaViaHeader_tp_isNull,METH_VARARGS,oaBooleanAppDef_oaViaHeader_isNull_doc},
    {"assign",(PyCFunction)oaBooleanAppDef_oaViaHeader_tp_assign,METH_VARARGS,oaBooleanAppDef_oaViaHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaViaHeader_doc[] = 
"Class: oaBooleanAppDef_oaViaHeader\n"
"  The oaBooleanAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  Once created, a boolean field is added to each object of the specified dataType, with the specified default value. Applications can use the new data field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaBooleanAppDef_oaViaHeader)\n"
"    Calls: (const oaBooleanAppDef_oaViaHeader&)\n"
"    Signature: oaBooleanAppDef_oaViaHeader||cref-oaBooleanAppDef_oaViaHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBooleanAppDef_oaViaHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBooleanAppDef_oaViaHeader",
    sizeof(PyoaBooleanAppDef_oaViaHeaderObject),
    0,
    (destructor)oaBooleanAppDef_oaViaHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBooleanAppDef_oaViaHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaBooleanAppDef_oaViaHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBooleanAppDef_oaViaHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBooleanAppDef_oaViaHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBooleanAppDef_oaViaHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaViaHeader_static_find_doc[] = 
"Class: oaBooleanAppDef_oaViaHeader, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaViaHeader* find(const oaString& name)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaViaHeader|cref-oaString,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaViaHeader* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaViaHeader|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaBooleanAppDef_oaViaHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaViaHeaderp result= (oaBooleanAppDef_oaViaHeader::find(p1.Data()));
            return PyoaBooleanAppDef_oaViaHeader_FromoaBooleanAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaViaHeaderp result= (oaBooleanAppDef_oaViaHeader::find(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaViaHeader_FromoaBooleanAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaViaHeader, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaViaHeader_static_get_doc[] = 
"Class: oaBooleanAppDef_oaViaHeader, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaViaHeader* get(const oaString& name)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaViaHeader|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaViaHeader* get(const oaString& name,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaViaHeader|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaViaHeader* get(const oaString& name,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaViaHeader|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaViaHeader* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaViaHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaViaHeader* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaViaHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaViaHeader* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaViaHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
;

static PyObject*
oaBooleanAppDef_oaViaHeader_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaViaHeaderp result= (oaBooleanAppDef_oaViaHeader::get(p1.Data()));
            return PyoaBooleanAppDef_oaViaHeader_FromoaBooleanAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaBooleanAppDef_oaViaHeaderp result= (oaBooleanAppDef_oaViaHeader::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaViaHeader_FromoaBooleanAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaBooleanAppDef_oaViaHeaderp result= (oaBooleanAppDef_oaViaHeader::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaViaHeader_FromoaBooleanAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaViaHeaderp result= (oaBooleanAppDef_oaViaHeader::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaViaHeader_FromoaBooleanAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaViaHeaderp result= (oaBooleanAppDef_oaViaHeader::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaViaHeader_FromoaBooleanAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaViaHeaderp result= (oaBooleanAppDef_oaViaHeader::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBooleanAppDef_oaViaHeader_FromoaBooleanAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaViaHeader, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,oaBoolean,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBooleanAppDef_oaViaHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaBooleanAppDef_oaViaHeader_static_find,METH_VARARGS,oaBooleanAppDef_oaViaHeader_static_find_doc},
    {"static_get",(PyCFunction)oaBooleanAppDef_oaViaHeader_static_get,METH_VARARGS,oaBooleanAppDef_oaViaHeader_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBooleanAppDef_oaViaHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBooleanAppDef_oaViaHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaBooleanAppDef_oaViaHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBooleanAppDef_oaViaHeader",
           (PyObject*)(&PyoaBooleanAppDef_oaViaHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBooleanAppDef_oaViaHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBooleanAppDef_oaViaHeader_Type.tp_dict;
    for(method=oaBooleanAppDef_oaViaHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBooleanAppDef_oaViaSpec
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaViaSpec_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBooleanAppDef_oaViaSpec_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBooleanAppDef_oaViaSpecObject* self = (PyoaBooleanAppDef_oaViaSpecObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBooleanAppDef_oaViaSpec)
    {
        PyParamoaBooleanAppDef_oaViaSpec p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBooleanAppDef_oaViaSpec_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBooleanAppDef_oaViaSpec, Choices are:\n"
        "    (oaBooleanAppDef_oaViaSpec)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBooleanAppDef_oaViaSpec_tp_dealloc(PyoaBooleanAppDef_oaViaSpecObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaViaSpec_tp_repr(PyObject *ob)
{
    PyParamoaBooleanAppDef_oaViaSpec value;
    int convert_status=PyoaBooleanAppDef_oaViaSpec_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[47];
    sprintf(buffer,"<oaBooleanAppDef_oaViaSpec::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBooleanAppDef_oaViaSpec_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBooleanAppDef_oaViaSpec v1;
    PyParamoaBooleanAppDef_oaViaSpec v2;
    int convert_status1=PyoaBooleanAppDef_oaViaSpec_Convert(ob1,&v1);
    int convert_status2=PyoaBooleanAppDef_oaViaSpec_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBooleanAppDef_oaViaSpec_Convert(PyObject* ob,PyParamoaBooleanAppDef_oaViaSpec* result)
{
    if (ob == NULL) return 1;
    if (PyoaBooleanAppDef_oaViaSpec_Check(ob)) {
        result->SetData( (oaBooleanAppDef_oaViaSpec**) ((PyoaBooleanAppDef_oaViaSpecObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBooleanAppDef_oaViaSpec Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaViaSpec_FromoaBooleanAppDef_oaViaSpec(oaBooleanAppDef_oaViaSpec** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBooleanAppDef_oaViaSpec* data=*value;
        PyObject* bself = PyoaBooleanAppDef_oaViaSpec_Type.tp_alloc(&PyoaBooleanAppDef_oaViaSpec_Type,0);
        if (bself == NULL) return bself;
        PyoaBooleanAppDef_oaViaSpecObject* self = (PyoaBooleanAppDef_oaViaSpecObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaViaSpec_FromoaBooleanAppDef_oaViaSpec(oaBooleanAppDef_oaViaSpec* data)
{
    if (data) {
       PyObject* bself = PyoaBooleanAppDef_oaViaSpec_Type.tp_alloc(&PyoaBooleanAppDef_oaViaSpec_Type,0);
       if (bself == NULL) return bself;
       PyoaBooleanAppDef_oaViaSpecObject* self = (PyoaBooleanAppDef_oaViaSpecObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaViaSpec_get_doc[] = 
"Class: oaBooleanAppDef_oaViaSpec, Function: get\n"
"  Paramegers: (oaViaSpec)\n"
"    Calls: oaBoolean get(const oaViaSpec* object)\n"
"    Signature: get|simple-oaBoolean|cptr-oaViaSpec,\n"
"    This function returns the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to get the value for this extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaViaSpec_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaViaSpec data;
    int convert_status=PyoaBooleanAppDef_oaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaViaSpecObject* self=(PyoaBooleanAppDef_oaViaSpecObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaSpec p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaViaSpec_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->get(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaViaSpec_getDefault_doc[] = 
"Class: oaBooleanAppDef_oaViaSpec, Function: getDefault\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean getDefault() const\n"
"    Signature: getDefault|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns the default value for this boolean extension.\n"
;

static PyObject*
oaBooleanAppDef_oaViaSpec_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaViaSpec data;
    int convert_status=PyoaBooleanAppDef_oaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaViaSpecObject* self=(PyoaBooleanAppDef_oaViaSpecObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->getDefault());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaViaSpec_set_doc[] = 
"Class: oaBooleanAppDef_oaViaSpec, Function: set\n"
"  Paramegers: (oaViaSpec,oaBoolean)\n"
"    Calls: void set(oaViaSpec* object,oaBoolean value)\n"
"    Signature: set|void-void|ptr-oaViaSpec,simple-oaBoolean,\n"
"    This function sets the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to set the value for this extension\n"
"    value\n"
"    The value of the extension to set on the object\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaViaSpec_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaViaSpec data;
    int convert_status=PyoaBooleanAppDef_oaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaViaSpecObject* self=(PyoaBooleanAppDef_oaViaSpecObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaSpec p1;
    PyParamoaBoolean p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViaSpec_Convert,&p1,
          &PyoaBoolean_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaViaSpec_isNull_doc[] =
"Class: oaBooleanAppDef_oaViaSpec, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBooleanAppDef_oaViaSpec_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBooleanAppDef_oaViaSpec data;
    int convert_status=PyoaBooleanAppDef_oaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBooleanAppDef_oaViaSpec_assign_doc[] = 
"Class: oaBooleanAppDef_oaViaSpec, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBooleanAppDef_oaViaSpec_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBooleanAppDef_oaViaSpec data;
  int convert_status=PyoaBooleanAppDef_oaViaSpec_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBooleanAppDef_oaViaSpec p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBooleanAppDef_oaViaSpec_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBooleanAppDef_oaViaSpec_methodlist[] = {
    {"get",(PyCFunction)oaBooleanAppDef_oaViaSpec_get,METH_VARARGS,oaBooleanAppDef_oaViaSpec_get_doc},
    {"getDefault",(PyCFunction)oaBooleanAppDef_oaViaSpec_getDefault,METH_VARARGS,oaBooleanAppDef_oaViaSpec_getDefault_doc},
    {"set",(PyCFunction)oaBooleanAppDef_oaViaSpec_set,METH_VARARGS,oaBooleanAppDef_oaViaSpec_set_doc},
    {"isNull",(PyCFunction)oaBooleanAppDef_oaViaSpec_tp_isNull,METH_VARARGS,oaBooleanAppDef_oaViaSpec_isNull_doc},
    {"assign",(PyCFunction)oaBooleanAppDef_oaViaSpec_tp_assign,METH_VARARGS,oaBooleanAppDef_oaViaSpec_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaViaSpec_doc[] = 
"Class: oaBooleanAppDef_oaViaSpec\n"
"  The oaBooleanAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  Once created, a boolean field is added to each object of the specified dataType, with the specified default value. Applications can use the new data field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaBooleanAppDef_oaViaSpec)\n"
"    Calls: (const oaBooleanAppDef_oaViaSpec&)\n"
"    Signature: oaBooleanAppDef_oaViaSpec||cref-oaBooleanAppDef_oaViaSpec,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBooleanAppDef_oaViaSpec_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBooleanAppDef_oaViaSpec",
    sizeof(PyoaBooleanAppDef_oaViaSpecObject),
    0,
    (destructor)oaBooleanAppDef_oaViaSpec_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBooleanAppDef_oaViaSpec_tp_compare,	/* tp_compare */
    (reprfunc)oaBooleanAppDef_oaViaSpec_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBooleanAppDef_oaViaSpec_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBooleanAppDef_oaViaSpec_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBooleanAppDef_oaViaSpec_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaViaSpec_static_find_doc[] = 
"Class: oaBooleanAppDef_oaViaSpec, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaViaSpec* find(const oaString& name)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaViaSpec|cref-oaString,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaViaSpec* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaViaSpec|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaBooleanAppDef_oaViaSpec_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaViaSpecp result= (oaBooleanAppDef_oaViaSpec::find(p1.Data()));
            return PyoaBooleanAppDef_oaViaSpec_FromoaBooleanAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaViaSpecp result= (oaBooleanAppDef_oaViaSpec::find(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaViaSpec_FromoaBooleanAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaViaSpec, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaViaSpec_static_get_doc[] = 
"Class: oaBooleanAppDef_oaViaSpec, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaViaSpec* get(const oaString& name)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaViaSpec|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaViaSpec* get(const oaString& name,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaViaSpec|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaViaSpec* get(const oaString& name,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaViaSpec|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaViaSpec* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaViaSpec|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaViaSpec* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaViaSpec|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaViaSpec* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaViaSpec|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
;

static PyObject*
oaBooleanAppDef_oaViaSpec_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaViaSpecp result= (oaBooleanAppDef_oaViaSpec::get(p1.Data()));
            return PyoaBooleanAppDef_oaViaSpec_FromoaBooleanAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaBooleanAppDef_oaViaSpecp result= (oaBooleanAppDef_oaViaSpec::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaViaSpec_FromoaBooleanAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaBooleanAppDef_oaViaSpecp result= (oaBooleanAppDef_oaViaSpec::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaViaSpec_FromoaBooleanAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaViaSpecp result= (oaBooleanAppDef_oaViaSpec::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaViaSpec_FromoaBooleanAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaViaSpecp result= (oaBooleanAppDef_oaViaSpec::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaViaSpec_FromoaBooleanAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaViaSpecp result= (oaBooleanAppDef_oaViaSpec::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBooleanAppDef_oaViaSpec_FromoaBooleanAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaViaSpec, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,oaBoolean,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBooleanAppDef_oaViaSpec_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaBooleanAppDef_oaViaSpec_static_find,METH_VARARGS,oaBooleanAppDef_oaViaSpec_static_find_doc},
    {"static_get",(PyCFunction)oaBooleanAppDef_oaViaSpec_static_get,METH_VARARGS,oaBooleanAppDef_oaViaSpec_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBooleanAppDef_oaViaSpec_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBooleanAppDef_oaViaSpec_Type)<0) {
      printf("** PyType_Ready failed for: oaBooleanAppDef_oaViaSpec\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBooleanAppDef_oaViaSpec",
           (PyObject*)(&PyoaBooleanAppDef_oaViaSpec_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBooleanAppDef_oaViaSpec\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBooleanAppDef_oaViaSpec_Type.tp_dict;
    for(method=oaBooleanAppDef_oaViaSpec_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBooleanAppDef_oaView
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaView_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBooleanAppDef_oaView_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBooleanAppDef_oaViewObject* self = (PyoaBooleanAppDef_oaViewObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBooleanAppDef_oaView)
    {
        PyParamoaBooleanAppDef_oaView p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBooleanAppDef_oaView_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBooleanAppDef_oaView, Choices are:\n"
        "    (oaBooleanAppDef_oaView)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBooleanAppDef_oaView_tp_dealloc(PyoaBooleanAppDef_oaViewObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaView_tp_repr(PyObject *ob)
{
    PyParamoaBooleanAppDef_oaView value;
    int convert_status=PyoaBooleanAppDef_oaView_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[44];
    sprintf(buffer,"<oaBooleanAppDef_oaView::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBooleanAppDef_oaView_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBooleanAppDef_oaView v1;
    PyParamoaBooleanAppDef_oaView v2;
    int convert_status1=PyoaBooleanAppDef_oaView_Convert(ob1,&v1);
    int convert_status2=PyoaBooleanAppDef_oaView_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBooleanAppDef_oaView_Convert(PyObject* ob,PyParamoaBooleanAppDef_oaView* result)
{
    if (ob == NULL) return 1;
    if (PyoaBooleanAppDef_oaView_Check(ob)) {
        result->SetData( (oaBooleanAppDef_oaView**) ((PyoaBooleanAppDef_oaViewObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBooleanAppDef_oaView Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaView_FromoaBooleanAppDef_oaView(oaBooleanAppDef_oaView** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBooleanAppDef_oaView* data=*value;
        PyObject* bself = PyoaBooleanAppDef_oaView_Type.tp_alloc(&PyoaBooleanAppDef_oaView_Type,0);
        if (bself == NULL) return bself;
        PyoaBooleanAppDef_oaViewObject* self = (PyoaBooleanAppDef_oaViewObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaView_FromoaBooleanAppDef_oaView(oaBooleanAppDef_oaView* data)
{
    if (data) {
       PyObject* bself = PyoaBooleanAppDef_oaView_Type.tp_alloc(&PyoaBooleanAppDef_oaView_Type,0);
       if (bself == NULL) return bself;
       PyoaBooleanAppDef_oaViewObject* self = (PyoaBooleanAppDef_oaViewObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaView_get_doc[] = 
"Class: oaBooleanAppDef_oaView, Function: get\n"
"  Paramegers: (oaView)\n"
"    Calls: oaBoolean get(const oaView* object)\n"
"    Signature: get|simple-oaBoolean|cptr-oaView,\n"
"    This function returns the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to get the value for this extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaView_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaView data;
    int convert_status=PyoaBooleanAppDef_oaView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaViewObject* self=(PyoaBooleanAppDef_oaViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaView p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaView_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->get(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaView_getDefault_doc[] = 
"Class: oaBooleanAppDef_oaView, Function: getDefault\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean getDefault() const\n"
"    Signature: getDefault|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns the default value for this boolean extension.\n"
;

static PyObject*
oaBooleanAppDef_oaView_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaView data;
    int convert_status=PyoaBooleanAppDef_oaView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaViewObject* self=(PyoaBooleanAppDef_oaViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->getDefault());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaView_set_doc[] = 
"Class: oaBooleanAppDef_oaView, Function: set\n"
"  Paramegers: (oaView,oaBoolean)\n"
"    Calls: void set(oaView* object,oaBoolean value)\n"
"    Signature: set|void-void|ptr-oaView,simple-oaBoolean,\n"
"    This function sets the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to set the value for this extension\n"
"    value\n"
"    The value of the extension to set on the object\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaView_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaView data;
    int convert_status=PyoaBooleanAppDef_oaView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaViewObject* self=(PyoaBooleanAppDef_oaViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaView p1;
    PyParamoaBoolean p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaView_Convert,&p1,
          &PyoaBoolean_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaView_isNull_doc[] =
"Class: oaBooleanAppDef_oaView, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBooleanAppDef_oaView_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBooleanAppDef_oaView data;
    int convert_status=PyoaBooleanAppDef_oaView_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBooleanAppDef_oaView_assign_doc[] = 
"Class: oaBooleanAppDef_oaView, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBooleanAppDef_oaView_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBooleanAppDef_oaView data;
  int convert_status=PyoaBooleanAppDef_oaView_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBooleanAppDef_oaView p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBooleanAppDef_oaView_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBooleanAppDef_oaView_methodlist[] = {
    {"get",(PyCFunction)oaBooleanAppDef_oaView_get,METH_VARARGS,oaBooleanAppDef_oaView_get_doc},
    {"getDefault",(PyCFunction)oaBooleanAppDef_oaView_getDefault,METH_VARARGS,oaBooleanAppDef_oaView_getDefault_doc},
    {"set",(PyCFunction)oaBooleanAppDef_oaView_set,METH_VARARGS,oaBooleanAppDef_oaView_set_doc},
    {"isNull",(PyCFunction)oaBooleanAppDef_oaView_tp_isNull,METH_VARARGS,oaBooleanAppDef_oaView_isNull_doc},
    {"assign",(PyCFunction)oaBooleanAppDef_oaView_tp_assign,METH_VARARGS,oaBooleanAppDef_oaView_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaView_doc[] = 
"Class: oaBooleanAppDef_oaView\n"
"  The oaBooleanAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  Once created, a boolean field is added to each object of the specified dataType, with the specified default value. Applications can use the new data field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaBooleanAppDef_oaView)\n"
"    Calls: (const oaBooleanAppDef_oaView&)\n"
"    Signature: oaBooleanAppDef_oaView||cref-oaBooleanAppDef_oaView,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBooleanAppDef_oaView_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBooleanAppDef_oaView",
    sizeof(PyoaBooleanAppDef_oaViewObject),
    0,
    (destructor)oaBooleanAppDef_oaView_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBooleanAppDef_oaView_tp_compare,	/* tp_compare */
    (reprfunc)oaBooleanAppDef_oaView_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBooleanAppDef_oaView_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBooleanAppDef_oaView_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBooleanAppDef_oaView_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaView_static_find_doc[] = 
"Class: oaBooleanAppDef_oaView, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaView* find(const oaString& name)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaView|cref-oaString,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaView* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaView|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaBooleanAppDef_oaView_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaViewp result= (oaBooleanAppDef_oaView::find(p1.Data()));
            return PyoaBooleanAppDef_oaView_FromoaBooleanAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaViewp result= (oaBooleanAppDef_oaView::find(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaView_FromoaBooleanAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaView, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaView_static_get_doc[] = 
"Class: oaBooleanAppDef_oaView, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaView* get(const oaString& name)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaView|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaView* get(const oaString& name,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaView|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaView* get(const oaString& name,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaView|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaView* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaView|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaView* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaView|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaView* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaView|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
;

static PyObject*
oaBooleanAppDef_oaView_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaViewp result= (oaBooleanAppDef_oaView::get(p1.Data()));
            return PyoaBooleanAppDef_oaView_FromoaBooleanAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaBooleanAppDef_oaViewp result= (oaBooleanAppDef_oaView::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaView_FromoaBooleanAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaBooleanAppDef_oaViewp result= (oaBooleanAppDef_oaView::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaView_FromoaBooleanAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaViewp result= (oaBooleanAppDef_oaView::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaView_FromoaBooleanAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaViewp result= (oaBooleanAppDef_oaView::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaView_FromoaBooleanAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaViewp result= (oaBooleanAppDef_oaView::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBooleanAppDef_oaView_FromoaBooleanAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaView, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,oaBoolean,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBooleanAppDef_oaView_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaBooleanAppDef_oaView_static_find,METH_VARARGS,oaBooleanAppDef_oaView_static_find_doc},
    {"static_get",(PyCFunction)oaBooleanAppDef_oaView_static_get,METH_VARARGS,oaBooleanAppDef_oaView_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBooleanAppDef_oaView_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBooleanAppDef_oaView_Type)<0) {
      printf("** PyType_Ready failed for: oaBooleanAppDef_oaView\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBooleanAppDef_oaView",
           (PyObject*)(&PyoaBooleanAppDef_oaView_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBooleanAppDef_oaView\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBooleanAppDef_oaView_Type.tp_dict;
    for(method=oaBooleanAppDef_oaView_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBooleanAppDef_oaWafer
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaWafer_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBooleanAppDef_oaWafer_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBooleanAppDef_oaWaferObject* self = (PyoaBooleanAppDef_oaWaferObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBooleanAppDef_oaWafer)
    {
        PyParamoaBooleanAppDef_oaWafer p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBooleanAppDef_oaWafer_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBooleanAppDef_oaWafer, Choices are:\n"
        "    (oaBooleanAppDef_oaWafer)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBooleanAppDef_oaWafer_tp_dealloc(PyoaBooleanAppDef_oaWaferObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaWafer_tp_repr(PyObject *ob)
{
    PyParamoaBooleanAppDef_oaWafer value;
    int convert_status=PyoaBooleanAppDef_oaWafer_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[45];
    sprintf(buffer,"<oaBooleanAppDef_oaWafer::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBooleanAppDef_oaWafer_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBooleanAppDef_oaWafer v1;
    PyParamoaBooleanAppDef_oaWafer v2;
    int convert_status1=PyoaBooleanAppDef_oaWafer_Convert(ob1,&v1);
    int convert_status2=PyoaBooleanAppDef_oaWafer_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBooleanAppDef_oaWafer_Convert(PyObject* ob,PyParamoaBooleanAppDef_oaWafer* result)
{
    if (ob == NULL) return 1;
    if (PyoaBooleanAppDef_oaWafer_Check(ob)) {
        result->SetData( (oaBooleanAppDef_oaWafer**) ((PyoaBooleanAppDef_oaWaferObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBooleanAppDef_oaWafer Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaWafer_FromoaBooleanAppDef_oaWafer(oaBooleanAppDef_oaWafer** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBooleanAppDef_oaWafer* data=*value;
        PyObject* bself = PyoaBooleanAppDef_oaWafer_Type.tp_alloc(&PyoaBooleanAppDef_oaWafer_Type,0);
        if (bself == NULL) return bself;
        PyoaBooleanAppDef_oaWaferObject* self = (PyoaBooleanAppDef_oaWaferObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaWafer_FromoaBooleanAppDef_oaWafer(oaBooleanAppDef_oaWafer* data)
{
    if (data) {
       PyObject* bself = PyoaBooleanAppDef_oaWafer_Type.tp_alloc(&PyoaBooleanAppDef_oaWafer_Type,0);
       if (bself == NULL) return bself;
       PyoaBooleanAppDef_oaWaferObject* self = (PyoaBooleanAppDef_oaWaferObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaWafer_get_doc[] = 
"Class: oaBooleanAppDef_oaWafer, Function: get\n"
"  Paramegers: (oaWafer)\n"
"    Calls: oaBoolean get(const oaWafer* object)\n"
"    Signature: get|simple-oaBoolean|cptr-oaWafer,\n"
"    This function returns the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to get the value for this extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaWafer_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaWafer data;
    int convert_status=PyoaBooleanAppDef_oaWafer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaWaferObject* self=(PyoaBooleanAppDef_oaWaferObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWafer p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaWafer_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->get(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaWafer_getDefault_doc[] = 
"Class: oaBooleanAppDef_oaWafer, Function: getDefault\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean getDefault() const\n"
"    Signature: getDefault|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns the default value for this boolean extension.\n"
;

static PyObject*
oaBooleanAppDef_oaWafer_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaWafer data;
    int convert_status=PyoaBooleanAppDef_oaWafer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaWaferObject* self=(PyoaBooleanAppDef_oaWaferObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->getDefault());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaWafer_set_doc[] = 
"Class: oaBooleanAppDef_oaWafer, Function: set\n"
"  Paramegers: (oaWafer,oaBoolean)\n"
"    Calls: void set(oaWafer* object,oaBoolean value)\n"
"    Signature: set|void-void|ptr-oaWafer,simple-oaBoolean,\n"
"    This function sets the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to set the value for this extension\n"
"    value\n"
"    The value of the extension to set on the object\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaWafer_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaWafer data;
    int convert_status=PyoaBooleanAppDef_oaWafer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaWaferObject* self=(PyoaBooleanAppDef_oaWaferObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWafer p1;
    PyParamoaBoolean p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaWafer_Convert,&p1,
          &PyoaBoolean_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaWafer_isNull_doc[] =
"Class: oaBooleanAppDef_oaWafer, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBooleanAppDef_oaWafer_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBooleanAppDef_oaWafer data;
    int convert_status=PyoaBooleanAppDef_oaWafer_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBooleanAppDef_oaWafer_assign_doc[] = 
"Class: oaBooleanAppDef_oaWafer, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBooleanAppDef_oaWafer_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBooleanAppDef_oaWafer data;
  int convert_status=PyoaBooleanAppDef_oaWafer_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBooleanAppDef_oaWafer p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBooleanAppDef_oaWafer_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBooleanAppDef_oaWafer_methodlist[] = {
    {"get",(PyCFunction)oaBooleanAppDef_oaWafer_get,METH_VARARGS,oaBooleanAppDef_oaWafer_get_doc},
    {"getDefault",(PyCFunction)oaBooleanAppDef_oaWafer_getDefault,METH_VARARGS,oaBooleanAppDef_oaWafer_getDefault_doc},
    {"set",(PyCFunction)oaBooleanAppDef_oaWafer_set,METH_VARARGS,oaBooleanAppDef_oaWafer_set_doc},
    {"isNull",(PyCFunction)oaBooleanAppDef_oaWafer_tp_isNull,METH_VARARGS,oaBooleanAppDef_oaWafer_isNull_doc},
    {"assign",(PyCFunction)oaBooleanAppDef_oaWafer_tp_assign,METH_VARARGS,oaBooleanAppDef_oaWafer_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaWafer_doc[] = 
"Class: oaBooleanAppDef_oaWafer\n"
"  The oaBooleanAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  Once created, a boolean field is added to each object of the specified dataType, with the specified default value. Applications can use the new data field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaBooleanAppDef_oaWafer)\n"
"    Calls: (const oaBooleanAppDef_oaWafer&)\n"
"    Signature: oaBooleanAppDef_oaWafer||cref-oaBooleanAppDef_oaWafer,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBooleanAppDef_oaWafer_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBooleanAppDef_oaWafer",
    sizeof(PyoaBooleanAppDef_oaWaferObject),
    0,
    (destructor)oaBooleanAppDef_oaWafer_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBooleanAppDef_oaWafer_tp_compare,	/* tp_compare */
    (reprfunc)oaBooleanAppDef_oaWafer_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBooleanAppDef_oaWafer_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBooleanAppDef_oaWafer_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBooleanAppDef_oaWafer_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaWafer_static_find_doc[] = 
"Class: oaBooleanAppDef_oaWafer, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaWafer* find(const oaString& name)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaWafer|cref-oaString,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaWafer* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaWafer|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaBooleanAppDef_oaWafer_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaWaferp result= (oaBooleanAppDef_oaWafer::find(p1.Data()));
            return PyoaBooleanAppDef_oaWafer_FromoaBooleanAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaWaferp result= (oaBooleanAppDef_oaWafer::find(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaWafer_FromoaBooleanAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaWafer, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaWafer_static_get_doc[] = 
"Class: oaBooleanAppDef_oaWafer, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaWafer* get(const oaString& name)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaWafer|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaWafer* get(const oaString& name,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaWafer|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaWafer* get(const oaString& name,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaWafer|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaWafer* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaWafer|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaWafer* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaWafer|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaWafer* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaWafer|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
;

static PyObject*
oaBooleanAppDef_oaWafer_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaWaferp result= (oaBooleanAppDef_oaWafer::get(p1.Data()));
            return PyoaBooleanAppDef_oaWafer_FromoaBooleanAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaBooleanAppDef_oaWaferp result= (oaBooleanAppDef_oaWafer::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaWafer_FromoaBooleanAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaBooleanAppDef_oaWaferp result= (oaBooleanAppDef_oaWafer::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaWafer_FromoaBooleanAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaWaferp result= (oaBooleanAppDef_oaWafer::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaWafer_FromoaBooleanAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaWaferp result= (oaBooleanAppDef_oaWafer::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaWafer_FromoaBooleanAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaWaferp result= (oaBooleanAppDef_oaWafer::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBooleanAppDef_oaWafer_FromoaBooleanAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaWafer, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,oaBoolean,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBooleanAppDef_oaWafer_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaBooleanAppDef_oaWafer_static_find,METH_VARARGS,oaBooleanAppDef_oaWafer_static_find_doc},
    {"static_get",(PyCFunction)oaBooleanAppDef_oaWafer_static_get,METH_VARARGS,oaBooleanAppDef_oaWafer_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBooleanAppDef_oaWafer_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBooleanAppDef_oaWafer_Type)<0) {
      printf("** PyType_Ready failed for: oaBooleanAppDef_oaWafer\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBooleanAppDef_oaWafer",
           (PyObject*)(&PyoaBooleanAppDef_oaWafer_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBooleanAppDef_oaWafer\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBooleanAppDef_oaWafer_Type.tp_dict;
    for(method=oaBooleanAppDef_oaWafer_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBooleanAppDef_oaWaferDesc
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaWaferDesc_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBooleanAppDef_oaWaferDesc_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBooleanAppDef_oaWaferDescObject* self = (PyoaBooleanAppDef_oaWaferDescObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBooleanAppDef_oaWaferDesc)
    {
        PyParamoaBooleanAppDef_oaWaferDesc p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBooleanAppDef_oaWaferDesc_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBooleanAppDef_oaWaferDesc, Choices are:\n"
        "    (oaBooleanAppDef_oaWaferDesc)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBooleanAppDef_oaWaferDesc_tp_dealloc(PyoaBooleanAppDef_oaWaferDescObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaWaferDesc_tp_repr(PyObject *ob)
{
    PyParamoaBooleanAppDef_oaWaferDesc value;
    int convert_status=PyoaBooleanAppDef_oaWaferDesc_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[49];
    sprintf(buffer,"<oaBooleanAppDef_oaWaferDesc::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBooleanAppDef_oaWaferDesc_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBooleanAppDef_oaWaferDesc v1;
    PyParamoaBooleanAppDef_oaWaferDesc v2;
    int convert_status1=PyoaBooleanAppDef_oaWaferDesc_Convert(ob1,&v1);
    int convert_status2=PyoaBooleanAppDef_oaWaferDesc_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBooleanAppDef_oaWaferDesc_Convert(PyObject* ob,PyParamoaBooleanAppDef_oaWaferDesc* result)
{
    if (ob == NULL) return 1;
    if (PyoaBooleanAppDef_oaWaferDesc_Check(ob)) {
        result->SetData( (oaBooleanAppDef_oaWaferDesc**) ((PyoaBooleanAppDef_oaWaferDescObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBooleanAppDef_oaWaferDesc Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaWaferDesc_FromoaBooleanAppDef_oaWaferDesc(oaBooleanAppDef_oaWaferDesc** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBooleanAppDef_oaWaferDesc* data=*value;
        PyObject* bself = PyoaBooleanAppDef_oaWaferDesc_Type.tp_alloc(&PyoaBooleanAppDef_oaWaferDesc_Type,0);
        if (bself == NULL) return bself;
        PyoaBooleanAppDef_oaWaferDescObject* self = (PyoaBooleanAppDef_oaWaferDescObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaWaferDesc_FromoaBooleanAppDef_oaWaferDesc(oaBooleanAppDef_oaWaferDesc* data)
{
    if (data) {
       PyObject* bself = PyoaBooleanAppDef_oaWaferDesc_Type.tp_alloc(&PyoaBooleanAppDef_oaWaferDesc_Type,0);
       if (bself == NULL) return bself;
       PyoaBooleanAppDef_oaWaferDescObject* self = (PyoaBooleanAppDef_oaWaferDescObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaWaferDesc_get_doc[] = 
"Class: oaBooleanAppDef_oaWaferDesc, Function: get\n"
"  Paramegers: (oaWaferDesc)\n"
"    Calls: oaBoolean get(const oaWaferDesc* object)\n"
"    Signature: get|simple-oaBoolean|cptr-oaWaferDesc,\n"
"    This function returns the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to get the value for this extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaWaferDesc_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaWaferDesc data;
    int convert_status=PyoaBooleanAppDef_oaWaferDesc_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaWaferDescObject* self=(PyoaBooleanAppDef_oaWaferDescObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWaferDesc p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaWaferDesc_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->get(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaWaferDesc_getDefault_doc[] = 
"Class: oaBooleanAppDef_oaWaferDesc, Function: getDefault\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean getDefault() const\n"
"    Signature: getDefault|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns the default value for this boolean extension.\n"
;

static PyObject*
oaBooleanAppDef_oaWaferDesc_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaWaferDesc data;
    int convert_status=PyoaBooleanAppDef_oaWaferDesc_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaWaferDescObject* self=(PyoaBooleanAppDef_oaWaferDescObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->getDefault());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaWaferDesc_set_doc[] = 
"Class: oaBooleanAppDef_oaWaferDesc, Function: set\n"
"  Paramegers: (oaWaferDesc,oaBoolean)\n"
"    Calls: void set(oaWaferDesc* object,oaBoolean value)\n"
"    Signature: set|void-void|ptr-oaWaferDesc,simple-oaBoolean,\n"
"    This function sets the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to set the value for this extension\n"
"    value\n"
"    The value of the extension to set on the object\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaWaferDesc_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaWaferDesc data;
    int convert_status=PyoaBooleanAppDef_oaWaferDesc_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaWaferDescObject* self=(PyoaBooleanAppDef_oaWaferDescObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWaferDesc p1;
    PyParamoaBoolean p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaWaferDesc_Convert,&p1,
          &PyoaBoolean_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaWaferDesc_isNull_doc[] =
"Class: oaBooleanAppDef_oaWaferDesc, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBooleanAppDef_oaWaferDesc_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBooleanAppDef_oaWaferDesc data;
    int convert_status=PyoaBooleanAppDef_oaWaferDesc_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBooleanAppDef_oaWaferDesc_assign_doc[] = 
"Class: oaBooleanAppDef_oaWaferDesc, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBooleanAppDef_oaWaferDesc_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBooleanAppDef_oaWaferDesc data;
  int convert_status=PyoaBooleanAppDef_oaWaferDesc_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBooleanAppDef_oaWaferDesc p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBooleanAppDef_oaWaferDesc_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBooleanAppDef_oaWaferDesc_methodlist[] = {
    {"get",(PyCFunction)oaBooleanAppDef_oaWaferDesc_get,METH_VARARGS,oaBooleanAppDef_oaWaferDesc_get_doc},
    {"getDefault",(PyCFunction)oaBooleanAppDef_oaWaferDesc_getDefault,METH_VARARGS,oaBooleanAppDef_oaWaferDesc_getDefault_doc},
    {"set",(PyCFunction)oaBooleanAppDef_oaWaferDesc_set,METH_VARARGS,oaBooleanAppDef_oaWaferDesc_set_doc},
    {"isNull",(PyCFunction)oaBooleanAppDef_oaWaferDesc_tp_isNull,METH_VARARGS,oaBooleanAppDef_oaWaferDesc_isNull_doc},
    {"assign",(PyCFunction)oaBooleanAppDef_oaWaferDesc_tp_assign,METH_VARARGS,oaBooleanAppDef_oaWaferDesc_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaWaferDesc_doc[] = 
"Class: oaBooleanAppDef_oaWaferDesc\n"
"  The oaBooleanAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  Once created, a boolean field is added to each object of the specified dataType, with the specified default value. Applications can use the new data field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaBooleanAppDef_oaWaferDesc)\n"
"    Calls: (const oaBooleanAppDef_oaWaferDesc&)\n"
"    Signature: oaBooleanAppDef_oaWaferDesc||cref-oaBooleanAppDef_oaWaferDesc,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBooleanAppDef_oaWaferDesc_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBooleanAppDef_oaWaferDesc",
    sizeof(PyoaBooleanAppDef_oaWaferDescObject),
    0,
    (destructor)oaBooleanAppDef_oaWaferDesc_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBooleanAppDef_oaWaferDesc_tp_compare,	/* tp_compare */
    (reprfunc)oaBooleanAppDef_oaWaferDesc_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBooleanAppDef_oaWaferDesc_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBooleanAppDef_oaWaferDesc_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBooleanAppDef_oaWaferDesc_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaWaferDesc_static_find_doc[] = 
"Class: oaBooleanAppDef_oaWaferDesc, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaWaferDesc* find(const oaString& name)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaWaferDesc|cref-oaString,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaWaferDesc* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaWaferDesc|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaBooleanAppDef_oaWaferDesc_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaWaferDescp result= (oaBooleanAppDef_oaWaferDesc::find(p1.Data()));
            return PyoaBooleanAppDef_oaWaferDesc_FromoaBooleanAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaWaferDescp result= (oaBooleanAppDef_oaWaferDesc::find(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaWaferDesc_FromoaBooleanAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaWaferDesc, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaWaferDesc_static_get_doc[] = 
"Class: oaBooleanAppDef_oaWaferDesc, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaWaferDesc* get(const oaString& name)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaWaferDesc|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaWaferDesc* get(const oaString& name,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaWaferDesc|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaWaferDesc* get(const oaString& name,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaWaferDesc|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaWaferDesc* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaWaferDesc|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaWaferDesc* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaWaferDesc|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaWaferDesc* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaWaferDesc|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
;

static PyObject*
oaBooleanAppDef_oaWaferDesc_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaWaferDescp result= (oaBooleanAppDef_oaWaferDesc::get(p1.Data()));
            return PyoaBooleanAppDef_oaWaferDesc_FromoaBooleanAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaBooleanAppDef_oaWaferDescp result= (oaBooleanAppDef_oaWaferDesc::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaWaferDesc_FromoaBooleanAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaBooleanAppDef_oaWaferDescp result= (oaBooleanAppDef_oaWaferDesc::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaWaferDesc_FromoaBooleanAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaWaferDescp result= (oaBooleanAppDef_oaWaferDesc::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaWaferDesc_FromoaBooleanAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaWaferDescp result= (oaBooleanAppDef_oaWaferDesc::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaWaferDesc_FromoaBooleanAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaWaferDescp result= (oaBooleanAppDef_oaWaferDesc::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBooleanAppDef_oaWaferDesc_FromoaBooleanAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaWaferDesc, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,oaBoolean,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBooleanAppDef_oaWaferDesc_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaBooleanAppDef_oaWaferDesc_static_find,METH_VARARGS,oaBooleanAppDef_oaWaferDesc_static_find_doc},
    {"static_get",(PyCFunction)oaBooleanAppDef_oaWaferDesc_static_get,METH_VARARGS,oaBooleanAppDef_oaWaferDesc_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBooleanAppDef_oaWaferDesc_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBooleanAppDef_oaWaferDesc_Type)<0) {
      printf("** PyType_Ready failed for: oaBooleanAppDef_oaWaferDesc\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBooleanAppDef_oaWaferDesc",
           (PyObject*)(&PyoaBooleanAppDef_oaWaferDesc_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBooleanAppDef_oaWaferDesc\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBooleanAppDef_oaWaferDesc_Type.tp_dict;
    for(method=oaBooleanAppDef_oaWaferDesc_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBooleanAppDef_oaWaferFeature
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaWaferFeature_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBooleanAppDef_oaWaferFeature_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBooleanAppDef_oaWaferFeatureObject* self = (PyoaBooleanAppDef_oaWaferFeatureObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBooleanAppDef_oaWaferFeature)
    {
        PyParamoaBooleanAppDef_oaWaferFeature p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBooleanAppDef_oaWaferFeature_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBooleanAppDef_oaWaferFeature, Choices are:\n"
        "    (oaBooleanAppDef_oaWaferFeature)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBooleanAppDef_oaWaferFeature_tp_dealloc(PyoaBooleanAppDef_oaWaferFeatureObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBooleanAppDef_oaWaferFeature_tp_repr(PyObject *ob)
{
    PyParamoaBooleanAppDef_oaWaferFeature value;
    int convert_status=PyoaBooleanAppDef_oaWaferFeature_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[52];
    sprintf(buffer,"<oaBooleanAppDef_oaWaferFeature::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBooleanAppDef_oaWaferFeature_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBooleanAppDef_oaWaferFeature v1;
    PyParamoaBooleanAppDef_oaWaferFeature v2;
    int convert_status1=PyoaBooleanAppDef_oaWaferFeature_Convert(ob1,&v1);
    int convert_status2=PyoaBooleanAppDef_oaWaferFeature_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBooleanAppDef_oaWaferFeature_Convert(PyObject* ob,PyParamoaBooleanAppDef_oaWaferFeature* result)
{
    if (ob == NULL) return 1;
    if (PyoaBooleanAppDef_oaWaferFeature_Check(ob)) {
        result->SetData( (oaBooleanAppDef_oaWaferFeature**) ((PyoaBooleanAppDef_oaWaferFeatureObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBooleanAppDef_oaWaferFeature Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaWaferFeature_FromoaBooleanAppDef_oaWaferFeature(oaBooleanAppDef_oaWaferFeature** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBooleanAppDef_oaWaferFeature* data=*value;
        PyObject* bself = PyoaBooleanAppDef_oaWaferFeature_Type.tp_alloc(&PyoaBooleanAppDef_oaWaferFeature_Type,0);
        if (bself == NULL) return bself;
        PyoaBooleanAppDef_oaWaferFeatureObject* self = (PyoaBooleanAppDef_oaWaferFeatureObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanAppDef_oaWaferFeature_FromoaBooleanAppDef_oaWaferFeature(oaBooleanAppDef_oaWaferFeature* data)
{
    if (data) {
       PyObject* bself = PyoaBooleanAppDef_oaWaferFeature_Type.tp_alloc(&PyoaBooleanAppDef_oaWaferFeature_Type,0);
       if (bself == NULL) return bself;
       PyoaBooleanAppDef_oaWaferFeatureObject* self = (PyoaBooleanAppDef_oaWaferFeatureObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaWaferFeature_get_doc[] = 
"Class: oaBooleanAppDef_oaWaferFeature, Function: get\n"
"  Paramegers: (oaWaferFeature)\n"
"    Calls: oaBoolean get(const oaWaferFeature* object)\n"
"    Signature: get|simple-oaBoolean|cptr-oaWaferFeature,\n"
"    This function returns the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to get the value for this extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaWaferFeature_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaWaferFeature data;
    int convert_status=PyoaBooleanAppDef_oaWaferFeature_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaWaferFeatureObject* self=(PyoaBooleanAppDef_oaWaferFeatureObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWaferFeature p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaWaferFeature_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->get(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaWaferFeature_getDefault_doc[] = 
"Class: oaBooleanAppDef_oaWaferFeature, Function: getDefault\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean getDefault() const\n"
"    Signature: getDefault|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns the default value for this boolean extension.\n"
;

static PyObject*
oaBooleanAppDef_oaWaferFeature_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaWaferFeature data;
    int convert_status=PyoaBooleanAppDef_oaWaferFeature_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaWaferFeatureObject* self=(PyoaBooleanAppDef_oaWaferFeatureObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->getDefault());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaWaferFeature_set_doc[] = 
"Class: oaBooleanAppDef_oaWaferFeature, Function: set\n"
"  Paramegers: (oaWaferFeature,oaBoolean)\n"
"    Calls: void set(oaWaferFeature* object,oaBoolean value)\n"
"    Signature: set|void-void|ptr-oaWaferFeature,simple-oaBoolean,\n"
"    This function sets the value of this Boolean AppDef.\n"
"    object\n"
"    The object on which to set the value for this extension\n"
"    value\n"
"    The value of the extension to set on the object\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaBooleanAppDef_oaWaferFeature_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanAppDef_oaWaferFeature data;
    int convert_status=PyoaBooleanAppDef_oaWaferFeature_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanAppDef_oaWaferFeatureObject* self=(PyoaBooleanAppDef_oaWaferFeatureObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWaferFeature p1;
    PyParamoaBoolean p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaWaferFeature_Convert,&p1,
          &PyoaBoolean_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaWaferFeature_isNull_doc[] =
"Class: oaBooleanAppDef_oaWaferFeature, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBooleanAppDef_oaWaferFeature_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBooleanAppDef_oaWaferFeature data;
    int convert_status=PyoaBooleanAppDef_oaWaferFeature_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBooleanAppDef_oaWaferFeature_assign_doc[] = 
"Class: oaBooleanAppDef_oaWaferFeature, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBooleanAppDef_oaWaferFeature_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBooleanAppDef_oaWaferFeature data;
  int convert_status=PyoaBooleanAppDef_oaWaferFeature_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBooleanAppDef_oaWaferFeature p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBooleanAppDef_oaWaferFeature_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBooleanAppDef_oaWaferFeature_methodlist[] = {
    {"get",(PyCFunction)oaBooleanAppDef_oaWaferFeature_get,METH_VARARGS,oaBooleanAppDef_oaWaferFeature_get_doc},
    {"getDefault",(PyCFunction)oaBooleanAppDef_oaWaferFeature_getDefault,METH_VARARGS,oaBooleanAppDef_oaWaferFeature_getDefault_doc},
    {"set",(PyCFunction)oaBooleanAppDef_oaWaferFeature_set,METH_VARARGS,oaBooleanAppDef_oaWaferFeature_set_doc},
    {"isNull",(PyCFunction)oaBooleanAppDef_oaWaferFeature_tp_isNull,METH_VARARGS,oaBooleanAppDef_oaWaferFeature_isNull_doc},
    {"assign",(PyCFunction)oaBooleanAppDef_oaWaferFeature_tp_assign,METH_VARARGS,oaBooleanAppDef_oaWaferFeature_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaWaferFeature_doc[] = 
"Class: oaBooleanAppDef_oaWaferFeature\n"
"  The oaBooleanAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  Once created, a boolean field is added to each object of the specified dataType, with the specified default value. Applications can use the new data field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaBooleanAppDef_oaWaferFeature)\n"
"    Calls: (const oaBooleanAppDef_oaWaferFeature&)\n"
"    Signature: oaBooleanAppDef_oaWaferFeature||cref-oaBooleanAppDef_oaWaferFeature,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBooleanAppDef_oaWaferFeature_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBooleanAppDef_oaWaferFeature",
    sizeof(PyoaBooleanAppDef_oaWaferFeatureObject),
    0,
    (destructor)oaBooleanAppDef_oaWaferFeature_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBooleanAppDef_oaWaferFeature_tp_compare,	/* tp_compare */
    (reprfunc)oaBooleanAppDef_oaWaferFeature_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBooleanAppDef_oaWaferFeature_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBooleanAppDef_oaWaferFeature_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBooleanAppDef_oaWaferFeature_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaWaferFeature_static_find_doc[] = 
"Class: oaBooleanAppDef_oaWaferFeature, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaWaferFeature* find(const oaString& name)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaWaferFeature|cref-oaString,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaWaferFeature* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaBooleanAppDef_oaWaferFeature|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaBooleanAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaBooleanAppDef_oaWaferFeature_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaWaferFeaturep result= (oaBooleanAppDef_oaWaferFeature::find(p1.Data()));
            return PyoaBooleanAppDef_oaWaferFeature_FromoaBooleanAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaWaferFeaturep result= (oaBooleanAppDef_oaWaferFeature::find(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaWaferFeature_FromoaBooleanAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaWaferFeature, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanAppDef_oaWaferFeature_static_get_doc[] = 
"Class: oaBooleanAppDef_oaWaferFeature, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBooleanAppDef_oaWaferFeature* get(const oaString& name)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaWaferFeature|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaWaferFeature* get(const oaString& name,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaWaferFeature|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaWaferFeature* get(const oaString& name,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaWaferFeature|cref-oaString,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, and the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaBooleanAppDef_oaWaferFeature* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaWaferFeature|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaWaferFeature* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaWaferFeature|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
"    Calls: oaBooleanAppDef_oaWaferFeature* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaBooleanAppDef_oaWaferFeature|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,simple-oaBoolean,\n"
"    This function constructs a boolean extension with the given name, associated with the given appObject and with the specified default value.\n"
"    name\n"
"    The name of the boolean extension to create\n"
"    objDef\n"
"    The oaAppObjectDef with which to associate the new extension\n"
"    defValue\n"
"    The default value for the extension to create\n"
"    persist\n"
"    The persistency of the extension to create\n"
"    oacAppDefExists\n"
;

static PyObject*
oaBooleanAppDef_oaWaferFeature_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaBooleanAppDef_oaWaferFeaturep result= (oaBooleanAppDef_oaWaferFeature::get(p1.Data()));
            return PyoaBooleanAppDef_oaWaferFeature_FromoaBooleanAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaBooleanAppDef_oaWaferFeaturep result= (oaBooleanAppDef_oaWaferFeature::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaWaferFeature_FromoaBooleanAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaBooleanAppDef_oaWaferFeaturep result= (oaBooleanAppDef_oaWaferFeature::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaWaferFeature_FromoaBooleanAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaWaferFeaturep result= (oaBooleanAppDef_oaWaferFeature::get(p1.Data(),p2.Data()));
            return PyoaBooleanAppDef_oaWaferFeature_FromoaBooleanAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaWaferFeaturep result= (oaBooleanAppDef_oaWaferFeature::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBooleanAppDef_oaWaferFeature_FromoaBooleanAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaBooleanAppDef_oaWaferFeaturep result= (oaBooleanAppDef_oaWaferFeature::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBooleanAppDef_oaWaferFeature_FromoaBooleanAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBooleanAppDef_oaWaferFeature, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,oaBoolean,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,oaBoolean,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBooleanAppDef_oaWaferFeature_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaBooleanAppDef_oaWaferFeature_static_find,METH_VARARGS,oaBooleanAppDef_oaWaferFeature_static_find_doc},
    {"static_get",(PyCFunction)oaBooleanAppDef_oaWaferFeature_static_get,METH_VARARGS,oaBooleanAppDef_oaWaferFeature_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBooleanAppDef_oaWaferFeature_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBooleanAppDef_oaWaferFeature_Type)<0) {
      printf("** PyType_Ready failed for: oaBooleanAppDef_oaWaferFeature\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBooleanAppDef_oaWaferFeature",
           (PyObject*)(&PyoaBooleanAppDef_oaWaferFeature_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBooleanAppDef_oaWaferFeature\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBooleanAppDef_oaWaferFeature_Type.tp_dict;
    for(method=oaBooleanAppDef_oaWaferFeature_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBooleanProp
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBooleanProp_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBooleanProp_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBooleanPropObject* self = (PyoaBooleanPropObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBooleanProp)
    {
        PyParamoaBooleanProp p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBooleanProp_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBooleanProp, Choices are:\n"
        "    (oaBooleanProp)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBooleanProp_tp_dealloc(PyoaBooleanPropObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBooleanProp_tp_repr(PyObject *ob)
{
    PyParamoaBooleanProp value;
    int convert_status=PyoaBooleanProp_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaBooleanProp::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaString sresult;
        value.DataCall()->getName(sresult);
    
        char addr[35];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaBooleanProp::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBooleanProp_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBooleanProp v1;
    PyParamoaBooleanProp v2;
    int convert_status1=PyoaBooleanProp_Convert(ob1,&v1);
    int convert_status2=PyoaBooleanProp_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBooleanProp_Convert(PyObject* ob,PyParamoaBooleanProp* result)
{
    if (ob == NULL) return 1;
    if (PyoaBooleanProp_Check(ob)) {
        result->SetData( (oaBooleanProp**) ((PyoaBooleanPropObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBooleanProp Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanProp_FromoaBooleanProp(oaBooleanProp** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBooleanProp* data=*value;
        PyObject* bself = PyoaBooleanProp_Type.tp_alloc(&PyoaBooleanProp_Type,0);
        if (bself == NULL) return bself;
        PyoaBooleanPropObject* self = (PyoaBooleanPropObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanProp_FromoaBooleanProp(oaBooleanProp* data)
{
    if (data) {
       PyObject* bself = PyoaBooleanProp_Type.tp_alloc(&PyoaBooleanProp_Type,0);
       if (bself == NULL) return bself;
       PyoaBooleanPropObject* self = (PyoaBooleanPropObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanProp_getValue_doc[] = 
"Class: oaBooleanProp, Function: getValue\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean getValue() const\n"
"    Signature: getValue|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns the value of the property.\n"
;

static PyObject*
oaBooleanProp_getValue(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanProp data;
    int convert_status=PyoaBooleanProp_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanPropObject* self=(PyoaBooleanPropObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->getValue());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanProp_setValue_doc[] = 
"Class: oaBooleanProp, Function: setValue\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: void setValue(oaBoolean value)\n"
"    Signature: setValue|void-void|simple-oaBoolean,\n"
"    This function sets this property to the specified value.\n"
"    value\n"
"    The property value to set\n"
;

static PyObject*
oaBooleanProp_setValue(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanProp data;
    int convert_status=PyoaBooleanProp_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanPropObject* self=(PyoaBooleanPropObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBoolean p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBoolean_Convert,&p1)) {
        data.DataCall()->setValue(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanProp_isNull_doc[] =
"Class: oaBooleanProp, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBooleanProp_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBooleanProp data;
    int convert_status=PyoaBooleanProp_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBooleanProp_assign_doc[] = 
"Class: oaBooleanProp, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBooleanProp_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBooleanProp data;
  int convert_status=PyoaBooleanProp_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBooleanProp p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBooleanProp_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBooleanProp_methodlist[] = {
    {"getValue",(PyCFunction)oaBooleanProp_getValue,METH_VARARGS,oaBooleanProp_getValue_doc},
    {"setValue",(PyCFunction)oaBooleanProp_setValue,METH_VARARGS,oaBooleanProp_setValue_doc},
    {"isNull",(PyCFunction)oaBooleanProp_tp_isNull,METH_VARARGS,oaBooleanProp_isNull_doc},
    {"assign",(PyCFunction)oaBooleanProp_tp_assign,METH_VARARGS,oaBooleanProp_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanProp_doc[] = 
"Class: oaBooleanProp\n"
"  The oaBooleanProp is a property that has a boolean (true or false) value.\n"
"  Properties are application-defined values that can be added to any managed object in oaDesign , oaTech , and oaWafer databases except for the following paged objects: oaDevice , oaNode , oaParasiticNetwork , and oaSubNetwork .\n"
"  To create properties on DM Objects, create the corresponding oaDMData object (using oaLibDMData::open , oaCellDMData::open , oaViewDMData::open , or oaCellViewDMData::open ), then create properties on that oaDMData object.\n"
"  See oaProp for a general discussion of properties.\n"
"Constructors:\n"
"  Paramegers: (oaBooleanProp)\n"
"    Calls: (const oaBooleanProp&)\n"
"    Signature: oaBooleanProp||cref-oaBooleanProp,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBooleanProp_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBooleanProp",
    sizeof(PyoaBooleanPropObject),
    0,
    (destructor)oaBooleanProp_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBooleanProp_tp_compare,	/* tp_compare */
    (reprfunc)oaBooleanProp_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBooleanProp_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBooleanProp_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaProp_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBooleanProp_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanProp_static_create_doc[] = 
"Class: oaBooleanProp, Function: create\n"
"  Paramegers: (oaObject,oaString,oaBoolean)\n"
"    Calls: oaBooleanProp* create(oaObject* object,const oaString& name,oaBoolean value)\n"
"    Signature: create|ptr-oaBooleanProp|ptr-oaObject,cref-oaString,simple-oaBoolean,\n"
"    This function creates a boolean property with the specified attributes.\n"
"    object\n"
"    The object to which to attach the property\n"
"    name\n"
"    The property name\n"
"    value\n"
"    The property value\n"
"    A pointer to the oaBooleanProp\n"
"    oacPropNameUsed\n"
"    oacInvalidObjForProp\n"
;

static PyObject*
oaBooleanProp_static_create(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObject p1;
    PyParamoaString p2;
    PyParamoaBoolean p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaObject_Convert,&p1,
          &PyoaString_Convert,&p2,
          &PyoaBoolean_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBooleanPropp result= (oaBooleanProp::create(p1.Data(),p2.Data(),p3.Data()));
        return PyoaBooleanProp_FromoaBooleanProp(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBooleanProp_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaBooleanProp_static_create,METH_VARARGS,oaBooleanProp_static_create_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBooleanProp_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBooleanProp_Type)<0) {
      printf("** PyType_Ready failed for: oaBooleanProp\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBooleanProp",
           (PyObject*)(&PyoaBooleanProp_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBooleanProp\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBooleanProp_Type.tp_dict;
    for(method=oaBooleanProp_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBooleanValue
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBooleanValue_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBooleanValue_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBooleanValueObject* self = (PyoaBooleanValueObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBooleanValue)
    {
        PyParamoaBooleanValue p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBooleanValue_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBooleanValue, Choices are:\n"
        "    (oaBooleanValue)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBooleanValue_tp_dealloc(PyoaBooleanValueObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBooleanValue_tp_repr(PyObject *ob)
{
    PyParamoaBooleanValue value;
    int convert_status=PyoaBooleanValue_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[36];
    sprintf(buffer,"<oaBooleanValue::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBooleanValue_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBooleanValue v1;
    PyParamoaBooleanValue v2;
    int convert_status1=PyoaBooleanValue_Convert(ob1,&v1);
    int convert_status2=PyoaBooleanValue_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBooleanValue_Convert(PyObject* ob,PyParamoaBooleanValue* result)
{
    if (ob == NULL) return 1;
    if (PyoaBooleanValue_Check(ob)) {
        result->SetData( (oaBooleanValue**) ((PyoaBooleanValueObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBooleanValue Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanValue_FromoaBooleanValue(oaBooleanValue** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBooleanValue* data=*value;
        PyObject* bself = PyoaBooleanValue_Type.tp_alloc(&PyoaBooleanValue_Type,0);
        if (bself == NULL) return bself;
        PyoaBooleanValueObject* self = (PyoaBooleanValueObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBooleanValue_FromoaBooleanValue(oaBooleanValue* data)
{
    if (data) {
       PyObject* bself = PyoaBooleanValue_Type.tp_alloc(&PyoaBooleanValue_Type,0);
       if (bself == NULL) return bself;
       PyoaBooleanValueObject* self = (PyoaBooleanValueObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanValue_get_doc[] = 
"Class: oaBooleanValue, Function: get\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean get() const\n"
"    Signature: get|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns the boolean for this value.\n"
;

static PyObject*
oaBooleanValue_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanValue data;
    int convert_status=PyoaBooleanValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanValueObject* self=(PyoaBooleanValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->get());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanValue_set_doc[] = 
"Class: oaBooleanValue, Function: set\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: void set(oaBoolean value)\n"
"    Signature: set|void-void|simple-oaBoolean,\n"
"    This function sets this value to the specified boolean value.\n"
"    value\n"
"    The boolean value to set.\n"
;

static PyObject*
oaBooleanValue_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBooleanValue data;
    int convert_status=PyoaBooleanValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBooleanValueObject* self=(PyoaBooleanValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBoolean p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBoolean_Convert,&p1)) {
        data.DataCall()->set(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBooleanValue_isNull_doc[] =
"Class: oaBooleanValue, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBooleanValue_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBooleanValue data;
    int convert_status=PyoaBooleanValue_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBooleanValue_assign_doc[] = 
"Class: oaBooleanValue, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBooleanValue_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBooleanValue data;
  int convert_status=PyoaBooleanValue_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBooleanValue p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBooleanValue_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBooleanValue_methodlist[] = {
    {"get",(PyCFunction)oaBooleanValue_get,METH_VARARGS,oaBooleanValue_get_doc},
    {"set",(PyCFunction)oaBooleanValue_set,METH_VARARGS,oaBooleanValue_set_doc},
    {"isNull",(PyCFunction)oaBooleanValue_tp_isNull,METH_VARARGS,oaBooleanValue_isNull_doc},
    {"assign",(PyCFunction)oaBooleanValue_tp_assign,METH_VARARGS,oaBooleanValue_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanValue_doc[] = 
"Class: oaBooleanValue\n"
"  The oaBooleanValue class represents a boolean value.\n"
"  See oaValue for a discussion of the usage of all of the oaValue subclasses.\n"
"Constructors:\n"
"  Paramegers: (oaBooleanValue)\n"
"    Calls: (const oaBooleanValue&)\n"
"    Signature: oaBooleanValue||cref-oaBooleanValue,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBooleanValue_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBooleanValue",
    sizeof(PyoaBooleanValueObject),
    0,
    (destructor)oaBooleanValue_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBooleanValue_tp_compare,	/* tp_compare */
    (reprfunc)oaBooleanValue_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBooleanValue_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBooleanValue_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaValue_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBooleanValue_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBooleanValue_static_create_doc[] = 
"Class: oaBooleanValue, Function: create\n"
"  Paramegers: (oaObject,oaBoolean)\n"
"    Calls: oaBooleanValue* create(oaObject* database,oaBoolean value)\n"
"    Signature: create|ptr-oaBooleanValue|ptr-oaObject,simple-oaBoolean,\n"
"    This function creates a boolean value in the database specified.\n"
"    database\n"
"    The database in which to create the value.\n"
"    value\n"
"    The boolean value.\n"
"    oacInvalidDatabase\n"
;

static PyObject*
oaBooleanValue_static_create(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObject p1;
    PyParamoaBoolean p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaObject_Convert,&p1,
          &PyoaBoolean_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBooleanValuep result= (oaBooleanValue::create(p1.Data(),p2.Data()));
        return PyoaBooleanValue_FromoaBooleanValue(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBooleanValue_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaBooleanValue_static_create,METH_VARARGS,oaBooleanValue_static_create_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBooleanValue_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBooleanValue_Type)<0) {
      printf("** PyType_Ready failed for: oaBooleanValue\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBooleanValue",
           (PyObject*)(&PyoaBooleanValue_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBooleanValue\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBooleanValue_Type.tp_dict;
    for(method=oaBooleanValue_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBoundary
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBoundary_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBoundary_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBoundaryObject* self = (PyoaBoundaryObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBoundary)
    {
        PyParamoaBoundary p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBoundary_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBoundary, Choices are:\n"
        "    (oaBoundary)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBoundary_tp_dealloc(PyoaBoundaryObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBoundary_tp_repr(PyObject *ob)
{
    PyParamoaBoundary value;
    int convert_status=PyoaBoundary_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[32];
    sprintf(buffer,"<oaBoundary::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBoundary_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBoundary v1;
    PyParamoaBoundary v2;
    int convert_status1=PyoaBoundary_Convert(ob1,&v1);
    int convert_status2=PyoaBoundary_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBoundary_Convert(PyObject* ob,PyParamoaBoundary* result)
{
    if (ob == NULL) return 1;
    if (PyoaBoundary_Check(ob)) {
        result->SetData( (oaBoundary**) ((PyoaBoundaryObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBoundary Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBoundary_FromoaBoundary(oaBoundary** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBoundary* data=*value;
        if (data->getType()==oacPRBoundaryType) return PyoaPRBoundary_FromoaPRBoundary((oaPRBoundary**)value,borrow,lock);
        if (data->getType()==oacAreaBoundaryType) return PyoaAreaBoundary_FromoaAreaBoundary((oaAreaBoundary**)value,borrow,lock);
        if (data->getType()==oacSnapBoundaryType) return PyoaSnapBoundary_FromoaSnapBoundary((oaSnapBoundary**)value,borrow,lock);
        if (data->getType()==oacClusterBoundaryType) return PyoaClusterBoundary_FromoaClusterBoundary((oaClusterBoundary**)value,borrow,lock);
        PyObject* bself = PyoaBoundary_Type.tp_alloc(&PyoaBoundary_Type,0);
        if (bself == NULL) return bself;
        PyoaBoundaryObject* self = (PyoaBoundaryObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBoundary_FromoaBoundary(oaBoundary* data)
{
    if (data) {
        if (data->getType()==oacPRBoundaryType) return PyoaPRBoundary_FromoaPRBoundary((oaPRBoundary*)data);
        if (data->getType()==oacAreaBoundaryType) return PyoaAreaBoundary_FromoaAreaBoundary((oaAreaBoundary*)data);
        if (data->getType()==oacSnapBoundaryType) return PyoaSnapBoundary_FromoaSnapBoundary((oaSnapBoundary*)data);
        if (data->getType()==oacClusterBoundaryType) return PyoaClusterBoundary_FromoaClusterBoundary((oaClusterBoundary*)data);
       PyObject* bself = PyoaBoundary_Type.tp_alloc(&PyoaBoundary_Type,0);
       if (bself == NULL) return bself;
       PyoaBoundaryObject* self = (PyoaBoundaryObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBoundary_getDefaultConstraintGroup_doc[] = 
"Class: oaBoundary, Function: getDefaultConstraintGroup\n"
"  Paramegers: ()\n"
"    Calls: oaConstraintGroup* getDefaultConstraintGroup() const\n"
"    Signature: getDefaultConstraintGroup|ptr-oaConstraintGroup|\n"
"    BrowseData: 1\n"
"    This function returns the default constraint group for this boundary. If no constraints have been set on the default constraint group, a new constraint group is created and returned.\n"
;

static PyObject*
oaBoundary_getDefaultConstraintGroup(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBoundary data;
    int convert_status=PyoaBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoundaryObject* self=(PyoaBoundaryObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaConstraintGroupp result= (data.DataCall()->getDefaultConstraintGroup());
        return PyoaConstraintGroup_FromoaConstraintGroup(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBoundary_getEdgeNames_doc[] = 
"Class: oaBoundary, Function: getEdgeNames\n"
"  Paramegers: ([oaString])\n"
"    Calls: void getEdgeNames(oaString* edgeNames) const\n"
"    Signature: getEdgeNames|void-void|ptr-oaString,\n"
"    This function fills out the edgeNames array with the names of each edge of this boundary.\n"
;

static PyObject*
oaBoundary_getEdgeNames(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBoundary data;
    int convert_status=PyoaBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoundaryObject* self=(PyoaBoundaryObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Array_Convert,&p1)) {
        if (!(data.Data()->getNumEdges()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of edges does not match number of points");
            return NULL;
        }
        data.DataCall()->getEdgeNames(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBoundary_getNumEdges_doc[] = 
"Class: oaBoundary, Function: getNumEdges\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumEdges() const\n"
"    Signature: getNumEdges|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of edges in this boundary.\n"
;

static PyObject*
oaBoundary_getNumEdges(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBoundary data;
    int convert_status=PyoaBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoundaryObject* self=(PyoaBoundaryObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumEdges());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBoundary_getPoints_doc[] = 
"Class: oaBoundary, Function: getPoints\n"
"  Paramegers: (oaPointArray)\n"
"    Calls: void getPoints(oaPointArray& points) const\n"
"    Signature: getPoints|void-void|ref-oaPointArray,\n"
"    BrowseData: 0,oaPointArray\n"
"    This function fills out the given pointArray with the points of this boundary.\n"
;

static PyObject*
oaBoundary_getPoints(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBoundary data;
    int convert_status=PyoaBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoundaryObject* self=(PyoaBoundaryObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaPointArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaPointArray_Convert,&p1)) {
        data.DataCall()->getPoints(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBoundary_hasDefaultConstraintGroup_doc[] = 
"Class: oaBoundary, Function: hasDefaultConstraintGroup\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean hasDefaultConstraintGroup() const\n"
"    Signature: hasDefaultConstraintGroup|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether there is a default constraint group for this boundary.\n"
;

static PyObject*
oaBoundary_hasDefaultConstraintGroup(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBoundary data;
    int convert_status=PyoaBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoundaryObject* self=(PyoaBoundaryObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->hasDefaultConstraintGroup());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBoundary_setEdges_doc[] = 
"Class: oaBoundary, Function: setEdges\n"
"  Paramegers: (oaPointArray)\n"
"    Calls: void setEdges(const oaPointArray& points)\n"
"    Signature: setEdges|void-void|cref-oaPointArray,cptr-oaString,\n"
"    This function sets the point array and edge names of this boundary to the specified points and edgeNames respectively. If boundary edgeNames are not supplied, the edges are automatically named using the form EDGE_ n , where n starts at zero and increments by one.\n"
"    Note: If edgeNames is specified, the number of edge names is equal to the number of points.\n"
"    Also note: The order of the points actually set on the oaBoundary is not guaranteed to be the same as the order of points passed to the setEdges() function. Consequently, the order of points returned by a subsequent oaBoundary::getPoints() may be different from the order of points specified in points .\n"
"    oacBoundaryHasExtraPoints\n"
"    oacBoundaryTooFewPoints\n"
"  Paramegers: (oaPointArray,[oaString])\n"
"    Calls: void setEdges(const oaPointArray& points,const oaString* edgeNames)\n"
"    Signature: setEdges|void-void|cref-oaPointArray,cptr-oaString,\n"
"    This function sets the point array and edge names of this boundary to the specified points and edgeNames respectively. If boundary edgeNames are not supplied, the edges are automatically named using the form EDGE_ n , where n starts at zero and increments by one.\n"
"    Note: If edgeNames is specified, the number of edge names is equal to the number of points.\n"
"    Also note: The order of the points actually set on the oaBoundary is not guaranteed to be the same as the order of points passed to the setEdges() function. Consequently, the order of points returned by a subsequent oaBoundary::getPoints() may be different from the order of points specified in points .\n"
"    oacBoundaryHasExtraPoints\n"
"    oacBoundaryTooFewPoints\n"
;

static PyObject*
oaBoundary_setEdges(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBoundary data;
    int convert_status=PyoaBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoundaryObject* self=(PyoaBoundaryObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaPointArray)
    {
        PyParamoaPointArray p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaPointArray_Convert,&p1)) {
            data.DataCall()->setEdges(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaPointArray,[oaString])
    {
        PyParamoaPointArray p1;
        PyParamoaString_Array p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaPointArray_Convert,&p1,
              &PyoaString_Array_Convert,&p2)) {
            if (!(p1.Data().getNumElements()==p2.Len())) {
                PyErr_SetString(PyExc_TypeError,
                    "number of edges does not match number of points");
                return NULL;
            }
            data.DataCall()->setEdges(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBoundary, function: setEdges, Choices are:\n"
        "    (oaPointArray)\n"
        "    (oaPointArray,[oaString])\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBoundary_transform_doc[] = 
"Class: oaBoundary, Function: transform\n"
"  Paramegers: (oaDouble,oaDouble)\n"
"    Calls: void transform(oaDouble scale,oaDouble angle)\n"
"    Signature: transform|void-void|simple-oaDouble,simple-oaDouble,\n"
"    This function transforms this boundary by the specified scale factor and rotation angle .\n"
;

static PyObject*
oaBoundary_transform(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBoundary data;
    int convert_status=PyoaBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoundaryObject* self=(PyoaBoundaryObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDouble p1;
    PyParamoaDouble p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaDouble_Convert,&p1,
          &PyoaDouble_Convert,&p2)) {
        data.DataCall()->transform(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBoundary_isNull_doc[] =
"Class: oaBoundary, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBoundary_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBoundary data;
    int convert_status=PyoaBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBoundary_assign_doc[] = 
"Class: oaBoundary, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBoundary_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBoundary data;
  int convert_status=PyoaBoundary_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBoundary p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBoundary_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBoundary_methodlist[] = {
    {"getDefaultConstraintGroup",(PyCFunction)oaBoundary_getDefaultConstraintGroup,METH_VARARGS,oaBoundary_getDefaultConstraintGroup_doc},
    {"getEdgeNames",(PyCFunction)oaBoundary_getEdgeNames,METH_VARARGS,oaBoundary_getEdgeNames_doc},
    {"getNumEdges",(PyCFunction)oaBoundary_getNumEdges,METH_VARARGS,oaBoundary_getNumEdges_doc},
    {"getPoints",(PyCFunction)oaBoundary_getPoints,METH_VARARGS,oaBoundary_getPoints_doc},
    {"hasDefaultConstraintGroup",(PyCFunction)oaBoundary_hasDefaultConstraintGroup,METH_VARARGS,oaBoundary_hasDefaultConstraintGroup_doc},
    {"setEdges",(PyCFunction)oaBoundary_setEdges,METH_VARARGS,oaBoundary_setEdges_doc},
    {"transform",(PyCFunction)oaBoundary_transform,METH_VARARGS,oaBoundary_transform_doc},
    {"isNull",(PyCFunction)oaBoundary_tp_isNull,METH_VARARGS,oaBoundary_isNull_doc},
    {"assign",(PyCFunction)oaBoundary_tp_assign,METH_VARARGS,oaBoundary_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBoundary_doc[] = 
"Class: oaBoundary\n"
"  The oaBoundary class is an abstract base for all types of boundary classes. In general, all types of boundaries are used to define an enclosed area. Boundaries include a polygonal outline. Each segment of the boundary can have a name associated with it.\n"
"  Two coincident and three collinear points are illegal, and if detected, cause an exception to be thrown. You can use oaPointArray::compress() to remove these combinations.\n"
"  The oaBoundary class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaBoundary)\n"
"    Calls: (const oaBoundary&)\n"
"    Signature: oaBoundary||cref-oaBoundary,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBoundary_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBoundary",
    sizeof(PyoaBoundaryObject),
    0,
    (destructor)oaBoundary_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBoundary_tp_compare,	/* tp_compare */
    (reprfunc)oaBoundary_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBoundary_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBoundary_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaFig_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBoundary_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBoundary_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBoundary_Type)<0) {
      printf("** PyType_Ready failed for: oaBoundary\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBoundary",
           (PyObject*)(&PyoaBoundary_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBoundary\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBoundaryModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaBoundaryModTypeEnum_Convert(PyObject* ob,PyParamoaBoundaryModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacSetPointsBoundaryModType")==0) { result->SetData(oacSetPointsBoundaryModType); return 1;}
        if (strcasecmp(str,"oacSetEdgesBoundaryModType")==0) { result->SetData(oacSetEdgesBoundaryModType); return 1;}
        if (strcasecmp(str,"oacSetNameBoundaryModType")==0) { result->SetData(oacSetNameBoundaryModType); return 1;}
        if (strcasecmp(str,"oacSetOwnerBoundaryModType")==0) { result->SetData(oacSetOwnerBoundaryModType); return 1;}
        if (strcasecmp(str,"oacSetLPPBoundaryModType")==0) { result->SetData(oacSetLPPBoundaryModType); return 1;}
        if (strcasecmp(str,"oacSetTypeBoundaryModType")==0) { result->SetData(oacSetTypeBoundaryModType); return 1;}
        if (strcasecmp(str,"oacSetCoreBoxBoundaryModType")==0) { result->SetData(oacSetCoreBoxBoundaryModType); return 1;}
        if (strcasecmp(str,"oacSetIOBoxBoundaryModType")==0) { result->SetData(oacSetIOBoxBoundaryModType); return 1;}
        if (strcasecmp(str,"oacSetDefaultConstraintGroupBoundaryModType")==0) { result->SetData(oacSetDefaultConstraintGroupBoundaryModType); return 1;}
        if (strcasecmp(str,"oacAddToFigGroupBoundaryModType")==0) { result->SetData(oacAddToFigGroupBoundaryModType); return 1;}
        if (strcasecmp(str,"oacRemoveFromFigGroupBoundaryModType")==0) { result->SetData(oacRemoveFromFigGroupBoundaryModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaBoundaryModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBoundaryModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaBoundaryModTypeEnum_FromoaBoundaryModTypeEnum(oaBoundaryModTypeEnum ob)
{
    if (ob==oacSetPointsBoundaryModType) return PyString_FromString("oacSetPointsBoundaryModType");
    if (ob==oacSetEdgesBoundaryModType) return PyString_FromString("oacSetEdgesBoundaryModType");
    if (ob==oacSetNameBoundaryModType) return PyString_FromString("oacSetNameBoundaryModType");
    if (ob==oacSetOwnerBoundaryModType) return PyString_FromString("oacSetOwnerBoundaryModType");
    if (ob==oacSetLPPBoundaryModType) return PyString_FromString("oacSetLPPBoundaryModType");
    if (ob==oacSetTypeBoundaryModType) return PyString_FromString("oacSetTypeBoundaryModType");
    if (ob==oacSetCoreBoxBoundaryModType) return PyString_FromString("oacSetCoreBoxBoundaryModType");
    if (ob==oacSetIOBoxBoundaryModType) return PyString_FromString("oacSetIOBoxBoundaryModType");
    if (ob==oacSetDefaultConstraintGroupBoundaryModType) return PyString_FromString("oacSetDefaultConstraintGroupBoundaryModType");
    if (ob==oacAddToFigGroupBoundaryModType) return PyString_FromString("oacAddToFigGroupBoundaryModType");
    if (ob==oacRemoveFromFigGroupBoundaryModType) return PyString_FromString("oacRemoveFromFigGroupBoundaryModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaBoundaryModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaBoundaryModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaBoundaryModTypeEnum_FromoaBoundaryModTypeEnum(oaBoundaryModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaBoundaryModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaBoundaryModTypeEnum_doc[] =
"Type convert function for enum: oaBoundaryModTypeEnum";
                               
static PyMethodDef PyoaBoundaryModTypeEnum_method =
  {"oaBoundaryModTypeEnum",(PyCFunction)PyoaBoundaryModTypeEnum_TypeFunction,METH_VARARGS,oaBoundaryModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaBoundaryModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacSetPointsBoundaryModType");
    PyDict_SetItemString(mod_dict,"oacSetPointsBoundaryModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetEdgesBoundaryModType");
    PyDict_SetItemString(mod_dict,"oacSetEdgesBoundaryModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetNameBoundaryModType");
    PyDict_SetItemString(mod_dict,"oacSetNameBoundaryModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetOwnerBoundaryModType");
    PyDict_SetItemString(mod_dict,"oacSetOwnerBoundaryModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetLPPBoundaryModType");
    PyDict_SetItemString(mod_dict,"oacSetLPPBoundaryModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetTypeBoundaryModType");
    PyDict_SetItemString(mod_dict,"oacSetTypeBoundaryModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetCoreBoxBoundaryModType");
    PyDict_SetItemString(mod_dict,"oacSetCoreBoxBoundaryModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetIOBoxBoundaryModType");
    PyDict_SetItemString(mod_dict,"oacSetIOBoxBoundaryModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetDefaultConstraintGroupBoundaryModType");
    PyDict_SetItemString(mod_dict,"oacSetDefaultConstraintGroupBoundaryModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAddToFigGroupBoundaryModType");
    PyDict_SetItemString(mod_dict,"oacAddToFigGroupBoundaryModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacRemoveFromFigGroupBoundaryModType");
    PyDict_SetItemString(mod_dict,"oacRemoveFromFigGroupBoundaryModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaBoundaryModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaBoundaryModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaBoundaryModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBoundaryQuery
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBoundaryQuery_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBoundaryQuery_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBoundaryQueryObject* self = (PyoaBoundaryQueryObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    if (is_raw) {
        PyErr_SetString(PyExc_TypeError,
            "No Constructor for pure-virtual class: oaBoundaryQuery");
    }
    else {
        pyv_oaBoundaryQuery* p = new pyv_oaBoundaryQuery();
        p->pyob=self;
        self->value= (oaRegionQuery*)  p;
        return bself;
    }
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBoundaryQuery_tp_dealloc(PyoaBoundaryQueryObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBoundaryQuery_tp_repr(PyObject *ob)
{
    PyParamoaBoundaryQuery value;
    int convert_status=PyoaBoundaryQuery_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[37];
    sprintf(buffer,"<oaBoundaryQuery::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBoundaryQuery_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBoundaryQuery v1;
    PyParamoaBoundaryQuery v2;
    int convert_status1=PyoaBoundaryQuery_Convert(ob1,&v1);
    int convert_status2=PyoaBoundaryQuery_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBoundaryQuery_Convert(PyObject* ob,PyParamoaBoundaryQuery* result)
{
    if (ob == NULL) return 1;
    if (PyoaBoundaryQuery_Check(ob)) {
        result->SetData( (oaBoundaryQuery*) ((PyoaBoundaryQueryObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBoundaryQuery Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBoundaryQuery_FromoaBoundaryQuery(oaBoundaryQuery* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaBoundaryQuery_Type.tp_alloc(&PyoaBoundaryQuery_Type,0);
        if (bself == NULL) return bself;
        PyoaBoundaryQueryObject* self = (PyoaBoundaryQueryObject*)bself;
        self->value = (oaRegionQuery*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaBoundaryQuery::pyv_oaBoundaryQuery()
 : pyob(NULL),
   oaBoundaryQuery()
{
}

// ------------------------------------------------------------------
pyv_oaBoundaryQuery::pyv_oaBoundaryQuery(const oaBoundaryQuery& p)
 : pyob(NULL),
   oaBoundaryQuery(p)
{
}

// ------------------------------------------------------------------
void pyv_oaBoundaryQuery::queryBoundary(oaBoundary* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"queryBoundary");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaBoundaryQuery::queryBoundary was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaBoundary_FromoaBoundary(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaBoundaryQuery::queryBoundary had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaBoundaryQuery::endRef(oaRef* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"endRef");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaBoundaryQuery::endRef was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaRef_FromoaRef(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaBoundaryQuery::endRef had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaBoundaryQuery::endRef(oaRef* p1,oaUInt4 p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"endRef");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaBoundaryQuery::endRef was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaRef_FromoaRef(p1));
    PyTuple_SetItem(args,1,PyoaUInt4_FromoaUInt4(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaBoundaryQuery::endRef had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaBoundaryQuery::endRef(oaRef* p1,oaUInt4 p2,oaUInt4 p3)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"endRef");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaBoundaryQuery::endRef was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(3);
    PyTuple_SetItem(args,0,PyoaRef_FromoaRef(p1));
    PyTuple_SetItem(args,1,PyoaUInt4_FromoaUInt4(p2));
    PyTuple_SetItem(args,2,PyoaUInt4_FromoaUInt4(p3));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaBoundaryQuery::endRef had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
oaBoolean pyv_oaBoundaryQuery::startRef(oaRef* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"startRef");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaBoundaryQuery::startRef was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaRef_FromoaRef(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaBoundaryQuery::startRef had an error.");
    }
    PyParamoaBoolean rv;
    if (PyoaBoolean_Convert(result,&rv)==0) {
        throw oaPythonException("Python Virtual Function oaBoolean::startRef has incorrect return type.");
    }
    Py_DECREF(result);
    return rv.Data();
}

// ------------------------------------------------------------------
oaBoolean pyv_oaBoundaryQuery::startRef(oaRef* p1,oaUInt4 p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"startRef");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaBoundaryQuery::startRef was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaRef_FromoaRef(p1));
    PyTuple_SetItem(args,1,PyoaUInt4_FromoaUInt4(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaBoundaryQuery::startRef had an error.");
    }
    PyParamoaBoolean rv;
    if (PyoaBoolean_Convert(result,&rv)==0) {
        throw oaPythonException("Python Virtual Function oaBoolean::startRef has incorrect return type.");
    }
    Py_DECREF(result);
    return rv.Data();
}

// ------------------------------------------------------------------
oaBoolean pyv_oaBoundaryQuery::startRef(oaRef* p1,oaUInt4 p2,oaUInt4 p3)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"startRef");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaBoundaryQuery::startRef was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(3);
    PyTuple_SetItem(args,0,PyoaRef_FromoaRef(p1));
    PyTuple_SetItem(args,1,PyoaUInt4_FromoaUInt4(p2));
    PyTuple_SetItem(args,2,PyoaUInt4_FromoaUInt4(p3));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaBoundaryQuery::startRef had an error.");
    }
    PyParamoaBoolean rv;
    if (PyoaBoolean_Convert(result,&rv)==0) {
        throw oaPythonException("Python Virtual Function oaBoolean::startRef has incorrect return type.");
    }
    Py_DECREF(result);
    return rv.Data();
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBoundaryQuery_query_doc[] = 
"Class: oaBoundaryQuery, Function: query\n"
"  Paramegers: (oaDesign,oaBox)\n"
"    Calls: void query(oaDesign* topDesign,const oaBox& region)\n"
"    Signature: query|void-void|ptr-oaDesign,cref-oaBox,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating boundaries in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    region\n"
"    The region of interest\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to stop the querying\n"
"  Paramegers: (oaDesign,oaBox,oaDist)\n"
"    Calls: void query(oaDesign* topDesign,const oaBox& region,oaDist filterSize)\n"
"    Signature: query|void-void|ptr-oaDesign,cref-oaBox,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating boundaries in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    region\n"
"    The region of interest\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to stop the querying\n"
"  Paramegers: (oaDesign,oaBox,oaDist,oaUInt4)\n"
"    Calls: void query(oaDesign* topDesign,const oaBox& region,oaDist filterSize,oaUInt4 startLevel)\n"
"    Signature: query|void-void|ptr-oaDesign,cref-oaBox,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating boundaries in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    region\n"
"    The region of interest\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to stop the querying\n"
"  Paramegers: (oaDesign,oaBox,oaDist,oaUInt4,oaUInt4)\n"
"    Calls: void query(oaDesign* topDesign,const oaBox& region,oaDist filterSize,oaUInt4 startLevel,oaUInt4 stopLevel)\n"
"    Signature: query|void-void|ptr-oaDesign,cref-oaBox,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating boundaries in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    region\n"
"    The region of interest\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to stop the querying\n"
"  Paramegers: (oaDesign,oaBox,oaTransform)\n"
"    Calls: void query(oaDesign* topDesign,const oaBox& region,const oaTransform& xform)\n"
"    Signature: query|void-void|ptr-oaDesign,cref-oaBox,cref-oaTransform,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating boundaries in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    region\n"
"    The region of interest\n"
"    xform\n"
"    The current transform that is applied to the design\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize.\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying.\n"
"    stopLevel\n"
"    The level of block hierarchy to stop the querying.\n"
"  Paramegers: (oaDesign,oaBox,oaTransform,oaDist)\n"
"    Calls: void query(oaDesign* topDesign,const oaBox& region,const oaTransform& xform,oaDist filterSize)\n"
"    Signature: query|void-void|ptr-oaDesign,cref-oaBox,cref-oaTransform,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating boundaries in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    region\n"
"    The region of interest\n"
"    xform\n"
"    The current transform that is applied to the design\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize.\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying.\n"
"    stopLevel\n"
"    The level of block hierarchy to stop the querying.\n"
"  Paramegers: (oaDesign,oaBox,oaTransform,oaDist,oaUInt4)\n"
"    Calls: void query(oaDesign* topDesign,const oaBox& region,const oaTransform& xform,oaDist filterSize,oaUInt4 startLevel)\n"
"    Signature: query|void-void|ptr-oaDesign,cref-oaBox,cref-oaTransform,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating boundaries in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    region\n"
"    The region of interest\n"
"    xform\n"
"    The current transform that is applied to the design\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize.\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying.\n"
"    stopLevel\n"
"    The level of block hierarchy to stop the querying.\n"
"  Paramegers: (oaDesign,oaBox,oaTransform,oaDist,oaUInt4,oaUInt4)\n"
"    Calls: void query(oaDesign* topDesign,const oaBox& region,const oaTransform& xform,oaDist filterSize,oaUInt4 startLevel,oaUInt4 stopLevel)\n"
"    Signature: query|void-void|ptr-oaDesign,cref-oaBox,cref-oaTransform,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating boundaries in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    region\n"
"    The region of interest\n"
"    xform\n"
"    The current transform that is applied to the design\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize.\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying.\n"
"    stopLevel\n"
"    The level of block hierarchy to stop the querying.\n"
;

static PyObject*
oaBoundaryQuery_query(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBoundaryQuery data;
    int convert_status=PyoaBoundaryQuery_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoundaryQueryObject* self=(PyoaBoundaryQueryObject*)ob;

    // Case: (oaDesign,oaBox)
    {
        PyParamoaDesign p1;
        PyParamoaBox p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaBox_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaBox,oaDist)
    {
        PyParamoaDesign p1;
        PyParamoaBox p2;
        PyParamoaDist p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaBox_Convert,&p2,
              &PyoaDist_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaBox,oaDist,oaUInt4)
    {
        PyParamoaDesign p1;
        PyParamoaBox p2;
        PyParamoaDist p3;
        PyParamoaUInt4 p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaBox_Convert,&p2,
              &PyoaDist_Convert,&p3,
              &PyoaUInt4_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaBox,oaDist,oaUInt4,oaUInt4)
    {
        PyParamoaDesign p1;
        PyParamoaBox p2;
        PyParamoaDist p3;
        PyParamoaUInt4 p4;
        PyParamoaUInt4 p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaBox_Convert,&p2,
              &PyoaDist_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaUInt4_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaBox,oaTransform)
    {
        PyParamoaDesign p1;
        PyParamoaBox p2;
        PyParamoaTransform p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaBox_Convert,&p2,
              &PyoaTransform_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaBox,oaTransform,oaDist)
    {
        PyParamoaDesign p1;
        PyParamoaBox p2;
        PyParamoaTransform p3;
        PyParamoaDist p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaBox_Convert,&p2,
              &PyoaTransform_Convert,&p3,
              &PyoaDist_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaBox,oaTransform,oaDist,oaUInt4)
    {
        PyParamoaDesign p1;
        PyParamoaBox p2;
        PyParamoaTransform p3;
        PyParamoaDist p4;
        PyParamoaUInt4 p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaBox_Convert,&p2,
              &PyoaTransform_Convert,&p3,
              &PyoaDist_Convert,&p4,
              &PyoaUInt4_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaBox,oaTransform,oaDist,oaUInt4,oaUInt4)
    {
        PyParamoaDesign p1;
        PyParamoaBox p2;
        PyParamoaTransform p3;
        PyParamoaDist p4;
        PyParamoaUInt4 p5;
        PyParamoaUInt4 p6;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaBox_Convert,&p2,
              &PyoaTransform_Convert,&p3,
              &PyoaDist_Convert,&p4,
              &PyoaUInt4_Convert,&p5,
              &PyoaUInt4_Convert,&p6)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBoundaryQuery, function: query, Choices are:\n"
        "    (oaDesign,oaBox)\n"
        "    (oaDesign,oaBox,oaDist)\n"
        "    (oaDesign,oaBox,oaDist,oaUInt4)\n"
        "    (oaDesign,oaBox,oaDist,oaUInt4,oaUInt4)\n"
        "    (oaDesign,oaBox,oaTransform)\n"
        "    (oaDesign,oaBox,oaTransform,oaDist)\n"
        "    (oaDesign,oaBox,oaTransform,oaDist,oaUInt4)\n"
        "    (oaDesign,oaBox,oaTransform,oaDist,oaUInt4,oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBoundaryQuery_queryBoundary_doc[] = 
"Class: oaBoundaryQuery, Function: queryBoundary\n"
"  Paramegers: (oaBoundary)\n"
"    Calls: virtual void queryBoundary(oaBoundary* boundary)\n"
"    Signature: queryBoundary|void-void|ptr-oaBoundary,\n"
"    This function processes each result of the boundary query.\n"
"    boundary\n"
"    Pointer to the oaBoundary object that is being queried.\n"
;

static PyObject*
oaBoundaryQuery_queryBoundary(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBoundaryQuery data;
    int convert_status=PyoaBoundaryQuery_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoundaryQueryObject* self=(PyoaBoundaryQueryObject*)ob;

    PyParamoaBoundary p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBoundary_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        PyErr_SetString(PyExc_TypeError,
            "Call to Pure-Virtual Function class: oaBoundaryQuery, function: queryBoundary");
            return NULL;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaBoundaryQuery_assign_doc[] = 
"Class: oaBoundaryQuery, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBoundaryQuery_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBoundaryQuery data;
  int convert_status=PyoaBoundaryQuery_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBoundaryQuery p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBoundaryQuery_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBoundaryQuery_methodlist[] = {
    {"query",(PyCFunction)oaBoundaryQuery_query,METH_VARARGS,oaBoundaryQuery_query_doc},
    {"queryBoundary",(PyCFunction)oaBoundaryQuery_queryBoundary,METH_VARARGS,oaBoundaryQuery_queryBoundary_doc},
    {"assign",(PyCFunction)oaBoundaryQuery_tp_assign,METH_VARARGS,oaBoundaryQuery_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBoundaryQuery_doc[] = 
"Class: oaBoundaryQuery\n"
"  The oaBoundaryQuery class implements functionality to query a specified region in a design hierarchy and quickly return all boundaries that overlap the region.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaBoundaryQuery()\n"
"    Signature: oaBoundaryQuery||\n"
"    The constructor for oaBoundaryQuery.\n"
"  Paramegers: (oaBoundaryQuery)\n"
"    Calls: (const oaBoundaryQuery&)\n"
"    Signature: oaBoundaryQuery||cref-oaBoundaryQuery,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBoundaryQuery_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBoundaryQuery",
    sizeof(PyoaBoundaryQueryObject),
    0,
    (destructor)oaBoundaryQuery_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBoundaryQuery_tp_compare,	/* tp_compare */
    (reprfunc)oaBoundaryQuery_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBoundaryQuery_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBoundaryQuery_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaRegionQuery_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBoundaryQuery_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBoundaryQuery_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBoundaryQuery_Type)<0) {
      printf("** PyType_Ready failed for: oaBoundaryQuery\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBoundaryQuery",
           (PyObject*)(&PyoaBoundaryQuery_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBoundaryQuery\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBox
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBox_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBox_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBoxObject* self = (PyoaBoxObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaBox();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaCoord,oaCoord,oaCoord,oaCoord)
    {
        PyParamoaCoord p1;
        PyParamoaCoord p2;
        PyParamoaCoord p3;
        PyParamoaCoord p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaCoord_Convert,&p1,
              &PyoaCoord_Convert,&p2,
              &PyoaCoord_Convert,&p3,
              &PyoaCoord_Convert,&p4)) {
            self->value =  new oaBox(p1.Data(),p2.Data(),p3.Data(),p4.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaPoint,oaPoint)
    {
        PyParamoaPoint p1;
        PyParamoaPoint p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaPoint_Convert,&p1,
              &PyoaPoint_Convert,&p2)) {
            self->value =  new oaBox(p1.Data(),p2.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaPoint,oaUInt4)
    {
        PyParamoaPoint p1;
        PyParamoaUInt4 p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaPoint_Convert,&p1,
              &PyoaUInt4_Convert,&p2)) {
            self->value =  new oaBox(p1.Data(),p2.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaBox,oaTransform)
    {
        PyParamoaBox p1;
        PyParamoaTransform p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBox_Convert,&p1,
              &PyoaTransform_Convert,&p2)) {
            self->value =  new oaBox(p1.Data(),p2.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaBox)
    {
        PyParamoaBox p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBox_Convert,&p1)) {
            self->value= new oaBox(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBox, Choices are:\n"
        "    ()\n"
        "    (oaCoord,oaCoord,oaCoord,oaCoord)\n"
        "    (oaPoint,oaPoint)\n"
        "    (oaPoint,oaUInt4)\n"
        "    (oaBox,oaTransform)\n"
        "    (oaBox)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBox_tp_dealloc(PyoaBoxObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBox_tp_repr(PyObject *ob)
{
    PyParamoaBox value;
    int convert_status=PyoaBox_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    oaChar sresult[128];
    sprintf(sresult,"[[%d,%d],[%d,%d]]",value.DataCall()->left(),value.DataCall()->bottom(),value.DataCall()->right(),value.DataCall()->top());

    char addr[27];
    sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
    oaString buffer;
    buffer+=oaString("<oaBox::");
    buffer+=oaString(addr);
    buffer+=oaString("::");
    buffer+=oaString(sresult);
    buffer+=oaString(">");
    result=PyString_FromString((char*)(const char*)buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBox_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBox v1;
    PyParamoaBox v2;
    int convert_status1=PyoaBox_Convert(ob1,&v1);
    int convert_status2=PyoaBox_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    if (v1.Data()==v2.Data()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBox_Convert(PyObject* ob,PyParamoaBox* result)
{
    if (ob == NULL) return 1;
    if (PyoaBox_Check(ob)) {
        result->SetData(  ((PyoaBoxObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBox Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBox_FromoaBox(oaBox* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaBox_Type.tp_alloc(&PyoaBox_Type,0);
        if (bself == NULL) return bself;
        PyoaBoxObject* self = (PyoaBoxObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBox_FromoaBox(const oaBox& data)
{
    PyObject* bself = PyoaBox_Type.tp_alloc(&PyoaBox_Type,0);
    if (bself == NULL) return bself;
    PyoaBoxObject* self = (PyoaBoxObject*)bself;
    self->value =  new oaBox(data);
    self->borrow = 0;
    self->locks = NULL;
    return bself;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBox_bottom_doc[] = 
"Class: oaBox, Function: bottom\n"
"  Paramegers: ()\n"
"    Calls: oaCoord& bottom()\n"
"    Signature: bottom|ref-oaCoord|\n"
"    BrowseData: 1\n"
"    This function returns a reference to the bottom coordinate attribute of this box. You can change the value of the attribute bottom .\n"
;

static PyObject*
oaBox_bottom(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaCoord* result=&(data.DataCall()->bottom());
        return PyoaCoord_FromoaCoord(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_contains_doc[] = 
"Class: oaBox, Function: contains\n"
"  Paramegers: (oaBox)\n"
"    Calls: oaBoolean contains(const oaBox& box) const\n"
"    Signature: contains|simple-oaBoolean|cref-oaBox,simple-oaBoolean,\n"
"    This function returns a boolean value indicating whether this box completely overlaps the specified box. The incEdges argument determines if the specified box is considered contained in this box if the edges are touching.\n"
"    box\n"
"    The box to check\n"
"    incEdges\n"
"    A boolean value that determines if the box is considered contained if the box is fully enclosed but touches the edge of this box\n"
"    true if the boxes overlap false if the boxes do not overlap; if incEdges is set to true, a value of true is also returned if the box is fully enclosed but touches the edge of this box.\n"
"  Paramegers: (oaBox,oaBoolean)\n"
"    Calls: oaBoolean contains(const oaBox& box,oaBoolean incEdges) const\n"
"    Signature: contains|simple-oaBoolean|cref-oaBox,simple-oaBoolean,\n"
"    This function returns a boolean value indicating whether this box completely overlaps the specified box. The incEdges argument determines if the specified box is considered contained in this box if the edges are touching.\n"
"    box\n"
"    The box to check\n"
"    incEdges\n"
"    A boolean value that determines if the box is considered contained if the box is fully enclosed but touches the edge of this box\n"
"    true if the boxes overlap false if the boxes do not overlap; if incEdges is set to true, a value of true is also returned if the box is fully enclosed but touches the edge of this box.\n"
"  Paramegers: (oaPoint)\n"
"    Calls: oaBoolean contains(const oaPoint& point) const\n"
"    Signature: contains|simple-oaBoolean|cref-oaPoint,simple-oaBoolean,\n"
"    This function returns a boolean value indicating whether the specified point is within or touching the box. The incEdges argument determines if the specified point is considered within this box if the point is on the edge of this box.\n"
"    point\n"
"    The point to check\n"
"    incEdges\n"
"    A boolean value that determines if the function returns true if the point touches the edge of this box\n"
"    true if the point is within the box false if the point is not within the box; if incEdges is set to true, a value of true is also returned if the point is on the edge of the box\n"
"  Paramegers: (oaPoint,oaBoolean)\n"
"    Calls: oaBoolean contains(const oaPoint& point,oaBoolean incEdges) const\n"
"    Signature: contains|simple-oaBoolean|cref-oaPoint,simple-oaBoolean,\n"
"    This function returns a boolean value indicating whether the specified point is within or touching the box. The incEdges argument determines if the specified point is considered within this box if the point is on the edge of this box.\n"
"    point\n"
"    The point to check\n"
"    incEdges\n"
"    A boolean value that determines if the function returns true if the point touches the edge of this box\n"
"    true if the point is within the box false if the point is not within the box; if incEdges is set to true, a value of true is also returned if the point is on the edge of the box\n"
;

static PyObject*
oaBox_contains(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    // Case: (oaBox)
    {
        PyParamoaBox p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBox_Convert,&p1)) {
            oaBoolean result= (data.DataCall()->contains(p1.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBox,oaBoolean)
    {
        PyParamoaBox p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBox_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->contains(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaPoint)
    {
        PyParamoaPoint p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaPoint_Convert,&p1)) {
            oaBoolean result= (data.DataCall()->contains(p1.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaPoint,oaBoolean)
    {
        PyParamoaPoint p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaPoint_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->contains(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBox, function: contains, Choices are:\n"
        "    (oaBox)\n"
        "    (oaBox,oaBoolean)\n"
        "    (oaPoint)\n"
        "    (oaPoint,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_distanceFrom2_doc[] = 
"Class: oaBox, Function: distanceFrom2\n"
"  Paramegers: (oaPoint)\n"
"    Calls: oaDouble distanceFrom2(const oaPoint& point) const\n"
"    Signature: distanceFrom2|simple-oaDouble|cref-oaPoint,\n"
"    This function returns the square of the distance from the specified point to the closest point on the boundary of this box.\n"
"    Note: The result of this function is meaningful only for non-inverted boxes.\n"
"    point\n"
"    The point to check\n"
"    The square of the distance from the specified point to the closest point on the boundary of this box\n"
;

static PyObject*
oaBox_distanceFrom2(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    PyParamoaPoint p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaPoint_Convert,&p1)) {
        oaDouble result= (data.DataCall()->distanceFrom2(p1.Data()));
        return PyoaDouble_FromoaDouble(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_fix_doc[] = 
"Class: oaBox, Function: fix\n"
"  Paramegers: (oaBox)\n"
"    Calls: void fix(oaBox& result) const\n"
"    Signature: fix|void-void|ref-oaBox,\n"
"    BrowseData: 0,oaBox\n"
"    This function verifies that this box is not inverted by checking that the left coordinate is less than or equal to the right coordinate, and that the bottom coordinate is less than or equal to the top coordinate. If the box is inverted, the coordinates are swapped and the corrected box is stored in result , which must not be the original box. The original box is not changed.\n"
"    result\n"
"    The updated version of this box\n"
"  Paramegers: ()\n"
"    Calls: void fix()\n"
"    Signature: fix|void-void|\n"
"    BrowseData: 0\n"
"    This function verifies this box is not inverted by checking that the left coordinate is less than or equal to the right coordinate, and the bottom coordinate is less than or equal to the top coordinate. If the box is inverted, the coordinates are swapped. The original box is modified to reflect the new coordinates.\n"
;

static PyObject*
oaBox_fix(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    // Case: (oaBox)
    {
        PyParamoaBox p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBox_Convert,&p1)) {
            data.DataCall()->fix(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            data.DataCall()->fix();
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBox, function: fix, Choices are:\n"
        "    (oaBox)\n"
        "    ()\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_getCenter_doc[] = 
"Class: oaBox, Function: getCenter\n"
"  Paramegers: (oaPoint)\n"
"    Calls: void getCenter(oaPoint& result) const\n"
"    Signature: getCenter|void-void|ref-oaPoint,\n"
"    BrowseData: 0,oaPoint\n"
"    This function calculates the center of this box and stores the resulting point in the specified location.\n"
"    result\n"
"    The storage location of the oaPoint that represents the center of this box\n"
;

static PyObject*
oaBox_getCenter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    PyParamoaPoint p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaPoint_Convert,&p1)) {
        data.DataCall()->getCenter(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_getHeight_doc[] = 
"Class: oaBox, Function: getHeight\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getHeight() const\n"
"    Signature: getHeight|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the height of this oaBox.\n"
"    Note: The result of this function is meaningful only for non-inverted boxes.\n"
;

static PyObject*
oaBox_getHeight(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getHeight());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_getLowerRight_doc[] = 
"Class: oaBox, Function: getLowerRight\n"
"  Paramegers: (oaPoint)\n"
"    Calls: void getLowerRight(oaPoint& result) const\n"
"    Signature: getLowerRight|void-void|ref-oaPoint,\n"
"    BrowseData: 0,oaPoint\n"
"    This function calculates the lower right corner of this box and stores the resulting point in the specified location.\n"
"    result\n"
"    The storage location of the oaPoint that represents the lower-right corner of this box\n"
;

static PyObject*
oaBox_getLowerRight(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    PyParamoaPoint p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaPoint_Convert,&p1)) {
        data.DataCall()->getLowerRight(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_getUpperLeft_doc[] = 
"Class: oaBox, Function: getUpperLeft\n"
"  Paramegers: (oaPoint)\n"
"    Calls: void getUpperLeft(oaPoint& result) const\n"
"    Signature: getUpperLeft|void-void|ref-oaPoint,\n"
"    BrowseData: 0,oaPoint\n"
"    This function calculates the upper-left corner of this box and stores the resulting point in the specified location.\n"
"    result\n"
"    The storage location of the oaPoint that represents the upper-left corner of this box\n"
;

static PyObject*
oaBox_getUpperLeft(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    PyParamoaPoint p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaPoint_Convert,&p1)) {
        data.DataCall()->getUpperLeft(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_getWidth_doc[] = 
"Class: oaBox, Function: getWidth\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getWidth() const\n"
"    Signature: getWidth|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the width of this oaBox.\n"
"    Note: The result of this function is meaningful only for non-inverted boxes.\n"
;

static PyObject*
oaBox_getWidth(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getWidth());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_hasNoArea_doc[] = 
"Class: oaBox, Function: hasNoArea\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean hasNoArea() const\n"
"    Signature: hasNoArea|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value indicating whether this box has a zero area. This value is true if either the left and right coordinates are equal, or the bottom and top coordinates are equal.\n"
"    true if this box has a zero area false if this box has a non-zero area\n"
;

static PyObject*
oaBox_hasNoArea(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->hasNoArea());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_init_doc[] = 
"Class: oaBox, Function: init\n"
"  Paramegers: ()\n"
"    Calls: void init()\n"
"    Signature: init|void-void|\n"
"    BrowseData: 0\n"
"    This function sets the left and bottom coordinates of this bounding box to the extreme positive values and the right and top coordinates to the extreme negative values. This inverted value is useful as an initial condition when you want to merge several boxes.\n"
;

static PyObject*
oaBox_init(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->init();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_intersection_doc[] = 
"Class: oaBox, Function: intersection\n"
"  Paramegers: (oaBox,oaBox)\n"
"    Calls: void intersection(const oaBox& box,oaBox& result) const\n"
"    Signature: intersection|void-void|cref-oaBox,ref-oaBox,\n"
"    This function calculates the intersection between this box and the specified box. The result is stored in the specified location. If the boxes do not intersect, the result is an inverted value.\n"
"    Note: The result of this function is meaningful only for non-inverted boxes.\n"
"    box\n"
"    The box to check for an intersection\n"
"    result\n"
"    The storage location for the resulting box\n"
"  Paramegers: (oaBox)\n"
"    Calls: void intersection(const oaBox& box)\n"
"    Signature: intersection|void-void|cref-oaBox,\n"
"    This function calculates the intersection between this box and the specified box. The result is stored in place of the original. If the boxes do not intersect, the result is an inverted box.\n"
"    Note: The result of this function is meaningful only for non-inverted boxes.\n"
"    box\n"
"    The box to check\n"
;

static PyObject*
oaBox_intersection(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    // Case: (oaBox,oaBox)
    {
        PyParamoaBox p1;
        PyParamoaBox p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBox_Convert,&p1,
              &PyoaBox_Convert,&p2)) {
            data.DataCall()->intersection(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaBox)
    {
        PyParamoaBox p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBox_Convert,&p1)) {
            data.DataCall()->intersection(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBox, function: intersection, Choices are:\n"
        "    (oaBox,oaBox)\n"
        "    (oaBox)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_isInverted_doc[] = 
"Class: oaBox, Function: isInverted\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isInverted() const\n"
"    Signature: isInverted|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value indicating whether this box has an inverted height or width value.\n"
"    true if this box has either an inverted height or width value false if both the height and width values are not inverted\n"
;

static PyObject*
oaBox_isInverted(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isInverted());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_left_doc[] = 
"Class: oaBox, Function: left\n"
"  Paramegers: ()\n"
"    Calls: oaCoord& left()\n"
"    Signature: left|ref-oaCoord|\n"
"    BrowseData: 1\n"
"    This function returns a reference to the left coordinate attribute of this box. You can change the value of the attribute left .\n"
;

static PyObject*
oaBox_left(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaCoord* result=&(data.DataCall()->left());
        return PyoaCoord_FromoaCoord(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_lowerLeft_doc[] = 
"Class: oaBox, Function: lowerLeft\n"
"  Paramegers: ()\n"
"    Calls: oaPoint& lowerLeft()\n"
"    Signature: lowerLeft|ref-oaPoint|\n"
"    BrowseData: 1\n"
"    This function returns a reference to the lower-left point of this box. You can change the value of the left and bottom attributes.\n"
;

static PyObject*
oaBox_lowerLeft(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaPoint* result=&(data.DataCall()->lowerLeft());
        return PyoaPoint_FromoaPoint(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_makeInvertedZero_doc[] = 
"Class: oaBox, Function: makeInvertedZero\n"
"  Paramegers: ()\n"
"    Calls: void makeInvertedZero()\n"
"    Signature: makeInvertedZero|void-void|\n"
"    BrowseData: 0\n"
"    This function sets all coordinates of this box to zero if the box was inverted.\n"
;

static PyObject*
oaBox_makeInvertedZero(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->makeInvertedZero();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_makeZero_doc[] = 
"Class: oaBox, Function: makeZero\n"
"  Paramegers: ()\n"
"    Calls: void makeZero()\n"
"    Signature: makeZero|void-void|\n"
"    BrowseData: 0\n"
"    This function sets all coordinates of this box to zero.\n"
;

static PyObject*
oaBox_makeZero(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->makeZero();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_merge_doc[] = 
"Class: oaBox, Function: merge\n"
"  Paramegers: (oaBox,oaBox)\n"
"    Calls: void merge(const oaBox& box,oaBox& result) const\n"
"    Signature: merge|void-void|cref-oaBox,ref-oaBox,\n"
"    This function calculates the union of this box with the specified box and stores the result in the specified location.\n"
"    box\n"
"    The box to merge\n"
"    result\n"
"    The storage location of the merge result\n"
"  Paramegers: (oaBox)\n"
"    Calls: void merge(const oaBox& box)\n"
"    Signature: merge|void-void|cref-oaBox,\n"
"    This function calculates the union of this box with the specified box and stores the result in place of the original box.\n"
"    box\n"
"    The box to merge\n"
"  Paramegers: (oaPoint,oaBox)\n"
"    Calls: void merge(const oaPoint& point,oaBox& result) const\n"
"    Signature: merge|void-void|cref-oaPoint,ref-oaBox,\n"
"    This function calculates the union of this box with the specified point and stores the result in the specified location.\n"
"    point\n"
"    The oaPoint to merge\n"
"    result\n"
"    The storage location of the result\n"
"  Paramegers: (oaPoint)\n"
"    Calls: void merge(const oaPoint& point)\n"
"    Signature: merge|void-void|cref-oaPoint,\n"
"    This function calculates the union of this box with the specified point and stores the result in the original box.\n"
"    point\n"
"    The oaPoint to merge\n"
;

static PyObject*
oaBox_merge(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    // Case: (oaBox,oaBox)
    {
        PyParamoaBox p1;
        PyParamoaBox p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBox_Convert,&p1,
              &PyoaBox_Convert,&p2)) {
            data.DataCall()->merge(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaBox)
    {
        PyParamoaBox p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBox_Convert,&p1)) {
            data.DataCall()->merge(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaPoint,oaBox)
    {
        PyParamoaPoint p1;
        PyParamoaBox p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaPoint_Convert,&p1,
              &PyoaBox_Convert,&p2)) {
            data.DataCall()->merge(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaPoint)
    {
        PyParamoaPoint p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaPoint_Convert,&p1)) {
            data.DataCall()->merge(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBox, function: merge, Choices are:\n"
        "    (oaBox,oaBox)\n"
        "    (oaBox)\n"
        "    (oaPoint,oaBox)\n"
        "    (oaPoint)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_overlaps_doc[] = 
"Class: oaBox, Function: overlaps\n"
"  Paramegers: (oaBox)\n"
"    Calls: oaBoolean overlaps(const oaBox& box) const\n"
"    Signature: overlaps|simple-oaBoolean|cref-oaBox,simple-oaBoolean,\n"
"    This function returns a boolean value indicating whether or not this box overlaps or touches the specified box. The argument 'incEdges' specifies whether the box is considered to overlap this box if it touches the edge.\n"
"    true if this box overlaps the specified box.\n"
"  Paramegers: (oaBox,oaBoolean)\n"
"    Calls: oaBoolean overlaps(const oaBox& box,oaBoolean incEdges) const\n"
"    Signature: overlaps|simple-oaBoolean|cref-oaBox,simple-oaBoolean,\n"
"    This function returns a boolean value indicating whether or not this box overlaps or touches the specified box. The argument 'incEdges' specifies whether the box is considered to overlap this box if it touches the edge.\n"
"    true if this box overlaps the specified box.\n"
"  Paramegers: (oaSegment)\n"
"    Calls: oaBoolean overlaps(const oaSegment& seg) const\n"
"    Signature: overlaps|simple-oaBoolean|cref-oaSegment,simple-oaBoolean,\n"
"    This function returns a boolean value indicating whether this box overlaps, touches, or contains the specified segment. The argument 'incEdges' specifies whether the segment is considered to overlap this box if it touches the edge.\n"
"    true if this box overlaps the specified segment.\n"
"  Paramegers: (oaSegment,oaBoolean)\n"
"    Calls: oaBoolean overlaps(const oaSegment& seg,oaBoolean incEdges) const\n"
"    Signature: overlaps|simple-oaBoolean|cref-oaSegment,simple-oaBoolean,\n"
"    This function returns a boolean value indicating whether this box overlaps, touches, or contains the specified segment. The argument 'incEdges' specifies whether the segment is considered to overlap this box if it touches the edge.\n"
"    true if this box overlaps the specified segment.\n"
;

static PyObject*
oaBox_overlaps(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    // Case: (oaBox)
    {
        PyParamoaBox p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBox_Convert,&p1)) {
            oaBoolean result= (data.DataCall()->overlaps(p1.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBox,oaBoolean)
    {
        PyParamoaBox p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBox_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->overlaps(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaSegment)
    {
        PyParamoaSegment p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSegment_Convert,&p1)) {
            oaBoolean result= (data.DataCall()->overlaps(p1.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaSegment,oaBoolean)
    {
        PyParamoaSegment p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaSegment_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->overlaps(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBox, function: overlaps, Choices are:\n"
        "    (oaBox)\n"
        "    (oaBox,oaBoolean)\n"
        "    (oaSegment)\n"
        "    (oaSegment,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_right_doc[] = 
"Class: oaBox, Function: right\n"
"  Paramegers: ()\n"
"    Calls: oaCoord& right()\n"
"    Signature: right|ref-oaCoord|\n"
"    BrowseData: 1\n"
"    This function returns a reference to the right coordinate attribute of this box. You can change the value of the attribute right .\n"
;

static PyObject*
oaBox_right(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaCoord* result=&(data.DataCall()->right());
        return PyoaCoord_FromoaCoord(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_scale_doc[] = 
"Class: oaBox, Function: scale\n"
"  Paramegers: (oaFloat)\n"
"    Calls: void scale(oaFloat scale)\n"
"    Signature: scale|void-void|simple-oaFloat,\n"
"    This function scales this box, keeping its center the same. The resulting box will be scaled as precisely as it can be presented by integer coordinates. The original box is modified to reflect this change.\n"
"    Note: The result of this function is valid only for non-inverted boxes.\n"
"    scale\n"
"    The scale factor by which the box dimensions are multiplied\n"
;

static PyObject*
oaBox_scale(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    PyParamoaFloat p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaFloat_Convert,&p1)) {
        data.DataCall()->scale(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_set_doc[] = 
"Class: oaBox, Function: set\n"
"  Paramegers: ()\n"
"    Calls: void set()\n"
"    Signature: set|void-void|simple-oaCoord,simple-oaCoord,simple-oaCoord,simple-oaCoord,\n"
"    BrowseData: 0\n"
"    This function sets this box to the specified coordinates. The coordinates specify the left, bottom, right, and top sides of the box. All coordinates have default values that set the left and bottom coordinates to the most extreme positive values, and the right and top coordinates to the most extreme negative values. This is known as an inverted box and can be used to indicate a box that is uninitialized.\n"
"    Note: The isInverted() function returns true after calling set() without any arguments.\n"
"    leftIn\n"
"    The new left side coordinate\n"
"    bottomIn\n"
"    The new bottom side coordinate\n"
"    rightIn\n"
"    The new right side coordinate\n"
"    topIn\n"
"    The new top side coordinate\n"
"  Paramegers: (oaCoord)\n"
"    Calls: void set(oaCoord leftIn)\n"
"    Signature: set|void-void|simple-oaCoord,simple-oaCoord,simple-oaCoord,simple-oaCoord,\n"
"    This function sets this box to the specified coordinates. The coordinates specify the left, bottom, right, and top sides of the box. All coordinates have default values that set the left and bottom coordinates to the most extreme positive values, and the right and top coordinates to the most extreme negative values. This is known as an inverted box and can be used to indicate a box that is uninitialized.\n"
"    Note: The isInverted() function returns true after calling set() without any arguments.\n"
"    leftIn\n"
"    The new left side coordinate\n"
"    bottomIn\n"
"    The new bottom side coordinate\n"
"    rightIn\n"
"    The new right side coordinate\n"
"    topIn\n"
"    The new top side coordinate\n"
"  Paramegers: (oaCoord,oaCoord)\n"
"    Calls: void set(oaCoord leftIn,oaCoord bottomIn)\n"
"    Signature: set|void-void|simple-oaCoord,simple-oaCoord,simple-oaCoord,simple-oaCoord,\n"
"    This function sets this box to the specified coordinates. The coordinates specify the left, bottom, right, and top sides of the box. All coordinates have default values that set the left and bottom coordinates to the most extreme positive values, and the right and top coordinates to the most extreme negative values. This is known as an inverted box and can be used to indicate a box that is uninitialized.\n"
"    Note: The isInverted() function returns true after calling set() without any arguments.\n"
"    leftIn\n"
"    The new left side coordinate\n"
"    bottomIn\n"
"    The new bottom side coordinate\n"
"    rightIn\n"
"    The new right side coordinate\n"
"    topIn\n"
"    The new top side coordinate\n"
"  Paramegers: (oaCoord,oaCoord,oaCoord)\n"
"    Calls: void set(oaCoord leftIn,oaCoord bottomIn,oaCoord rightIn)\n"
"    Signature: set|void-void|simple-oaCoord,simple-oaCoord,simple-oaCoord,simple-oaCoord,\n"
"    This function sets this box to the specified coordinates. The coordinates specify the left, bottom, right, and top sides of the box. All coordinates have default values that set the left and bottom coordinates to the most extreme positive values, and the right and top coordinates to the most extreme negative values. This is known as an inverted box and can be used to indicate a box that is uninitialized.\n"
"    Note: The isInverted() function returns true after calling set() without any arguments.\n"
"    leftIn\n"
"    The new left side coordinate\n"
"    bottomIn\n"
"    The new bottom side coordinate\n"
"    rightIn\n"
"    The new right side coordinate\n"
"    topIn\n"
"    The new top side coordinate\n"
"  Paramegers: (oaCoord,oaCoord,oaCoord,oaCoord)\n"
"    Calls: void set(oaCoord leftIn,oaCoord bottomIn,oaCoord rightIn,oaCoord topIn)\n"
"    Signature: set|void-void|simple-oaCoord,simple-oaCoord,simple-oaCoord,simple-oaCoord,\n"
"    This function sets this box to the specified coordinates. The coordinates specify the left, bottom, right, and top sides of the box. All coordinates have default values that set the left and bottom coordinates to the most extreme positive values, and the right and top coordinates to the most extreme negative values. This is known as an inverted box and can be used to indicate a box that is uninitialized.\n"
"    Note: The isInverted() function returns true after calling set() without any arguments.\n"
"    leftIn\n"
"    The new left side coordinate\n"
"    bottomIn\n"
"    The new bottom side coordinate\n"
"    rightIn\n"
"    The new right side coordinate\n"
"    topIn\n"
"    The new top side coordinate\n"
"  Paramegers: (oaPoint,oaPoint)\n"
"    Calls: void set(const oaPoint& lowerLeftIn,const oaPoint& upperRightIn)\n"
"    Signature: set|void-void|cref-oaPoint,cref-oaPoint,\n"
"    This function sets this box to the specified lower-left and upper-right points.\n"
"    lowerLeftIn\n"
"    The new lower-left point\n"
"    upperRightIn\n"
"    The new upper-right point\n"
"  Paramegers: (oaPoint,oaUInt4)\n"
"    Calls: void set(const oaPoint& center,oaUInt4 size)\n"
"    Signature: set|void-void|cref-oaPoint,simple-oaUInt4,\n"
"    This function sets this box to a square that is centered about the specified oaPoint with each side set to the specified size from the center.\n"
"    center\n"
"    The oaPoint at which the box is centered\n"
"    size\n"
"    The spacing from each side to the center of the box\n"
"  Paramegers: (oaBox,oaTransform)\n"
"    Calls: void set(const oaBox& box,const oaTransform& xform)\n"
"    Signature: set|void-void|cref-oaBox,cref-oaTransform,\n"
"    This function sets this box to a transformed copy of the specified box.\n"
"    box\n"
"    The box to copy\n"
"    xform\n"
"    The transform to apply to the specified box\n"
;

static PyObject*
oaBox_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            data.DataCall()->set();
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaCoord)
    {
        PyParamoaCoord p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaCoord_Convert,&p1)) {
            data.DataCall()->set(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaCoord,oaCoord)
    {
        PyParamoaCoord p1;
        PyParamoaCoord p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaCoord_Convert,&p1,
              &PyoaCoord_Convert,&p2)) {
            data.DataCall()->set(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaCoord,oaCoord,oaCoord)
    {
        PyParamoaCoord p1;
        PyParamoaCoord p2;
        PyParamoaCoord p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaCoord_Convert,&p1,
              &PyoaCoord_Convert,&p2,
              &PyoaCoord_Convert,&p3)) {
            data.DataCall()->set(p1.Data(),p2.Data(),p3.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaCoord,oaCoord,oaCoord,oaCoord)
    {
        PyParamoaCoord p1;
        PyParamoaCoord p2;
        PyParamoaCoord p3;
        PyParamoaCoord p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaCoord_Convert,&p1,
              &PyoaCoord_Convert,&p2,
              &PyoaCoord_Convert,&p3,
              &PyoaCoord_Convert,&p4)) {
            data.DataCall()->set(p1.Data(),p2.Data(),p3.Data(),p4.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaPoint,oaPoint)
    {
        PyParamoaPoint p1;
        PyParamoaPoint p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaPoint_Convert,&p1,
              &PyoaPoint_Convert,&p2)) {
            data.DataCall()->set(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaPoint,oaUInt4)
    {
        PyParamoaPoint p1;
        PyParamoaUInt4 p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaPoint_Convert,&p1,
              &PyoaUInt4_Convert,&p2)) {
            data.DataCall()->set(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaBox,oaTransform)
    {
        PyParamoaBox p1;
        PyParamoaTransform p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBox_Convert,&p1,
              &PyoaTransform_Convert,&p2)) {
            data.DataCall()->set(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBox, function: set, Choices are:\n"
        "    ()\n"
        "    (oaCoord)\n"
        "    (oaCoord,oaCoord)\n"
        "    (oaCoord,oaCoord,oaCoord)\n"
        "    (oaCoord,oaCoord,oaCoord,oaCoord)\n"
        "    (oaPoint,oaPoint)\n"
        "    (oaPoint,oaUInt4)\n"
        "    (oaBox,oaTransform)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_toPoints_doc[] = 
"Class: oaBox, Function: toPoints\n"
"  Paramegers: ([oaPoint])\n"
"    Calls: void toPoints(oaPoint* points) const\n"
"    Signature: toPoints|void-void|ptr-oaPoint,\n"
"    This function fills out points with the four points that define this box. It is assumed that points are already allocated and the points are at least four points in length. The points are written in clockwise order starting from the lower left point.\n"
"    points\n"
"    A pre-allocated array in which the points are stored\n"
;

static PyObject*
oaBox_toPoints(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    PyParamoaPoint_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaPoint_Array_Convert,&p1)) {
        if (!(p1.Len()!=4)) {
            PyErr_SetString(PyExc_TypeError,
                "number of points must be 4");
            return NULL;
        }
        data.DataCall()->toPoints(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_top_doc[] = 
"Class: oaBox, Function: top\n"
"  Paramegers: ()\n"
"    Calls: oaCoord& top()\n"
"    Signature: top|ref-oaCoord|\n"
"    BrowseData: 1\n"
"    This function returns a reference to the top coordinate attribute of this box. You can change the value of the attribute top .\n"
;

static PyObject*
oaBox_top(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaCoord* result=&(data.DataCall()->top());
        return PyoaCoord_FromoaCoord(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_transform_doc[] = 
"Class: oaBox, Function: transform\n"
"  Paramegers: (oaTransform,oaBox)\n"
"    Calls: void transform(const oaTransform& xform,oaBox& result) const\n"
"    Signature: transform|void-void|cref-oaTransform,ref-oaBox,\n"
"    This function transforms this box by the specified transform and stores the result in the specified location, which may be the original box.\n"
"    xform\n"
"    The transform to apply\n"
"    result\n"
"    The storage location for the transformed box\n"
"  Paramegers: (oaTransform)\n"
"    Calls: void transform(const oaTransform& xform)\n"
"    Signature: transform|void-void|cref-oaTransform,\n"
"    This function transforms this box by the specified transform. The original box is modified to reflect this transform.\n"
"    xform\n"
"    The transform to apply\n"
"  Paramegers: (oaPoint,oaBox)\n"
"    Calls: void transform(const oaPoint& offset,oaBox& result) const\n"
"    Signature: transform|void-void|cref-oaPoint,ref-oaBox,\n"
"    This function transforms this box by the specified offset and stores the result in the specified location, which may be the original box.\n"
"    offset\n"
"    The offset to apply\n"
"    result\n"
"    The storage location for the transformed box\n"
"  Paramegers: (oaPoint)\n"
"    Calls: void transform(const oaPoint& offset)\n"
"    Signature: transform|void-void|cref-oaPoint,\n"
"    This function transforms this box by the specified offset. The original box is modified to reflect this transform.\n"
"    offset\n"
"    The offset to apply\n"
"  Paramegers: (oaDouble,oaDouble,oaBox)\n"
"    Calls: void transform(oaDouble scale,oaDouble angle,oaBox& result) const\n"
"    Signature: transform|void-void|simple-oaDouble,simple-oaDouble,ref-oaBox,\n"
"    This function transforms this box by the specified scale factor and rotation angle and stores the resulting transform in result , which may be the original box. The angle can be an arbitrary angle, and the result of the transform will be exact if the angle specified is orthogonal. If the angle is non-orthogonal, the resulting transform will be as precise as can possibly be presented by integer coordinates.\n"
"  Paramegers: (oaDouble,oaDouble)\n"
"    Calls: void transform(oaDouble scale,oaDouble angle)\n"
"    Signature: transform|void-void|simple-oaDouble,simple-oaDouble,\n"
"    This function transforms this box by the specified scale factor and rotation angle . The angle can be an arbitrary angle, and the result of the transform will be exact if the angle specified is orthogonal. If the angle is non-orthogonal, the resulting transform will be as precise as can possibly be presented by integer coordinates. The original box is modified to reflect this transform.\n"
;

static PyObject*
oaBox_transform(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    // Case: (oaTransform,oaBox)
    {
        PyParamoaTransform p1;
        PyParamoaBox p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaTransform_Convert,&p1,
              &PyoaBox_Convert,&p2)) {
            data.DataCall()->transform(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaTransform)
    {
        PyParamoaTransform p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaTransform_Convert,&p1)) {
            data.DataCall()->transform(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaPoint,oaBox)
    {
        PyParamoaPoint p1;
        PyParamoaBox p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaPoint_Convert,&p1,
              &PyoaBox_Convert,&p2)) {
            data.DataCall()->transform(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaPoint)
    {
        PyParamoaPoint p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaPoint_Convert,&p1)) {
            data.DataCall()->transform(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDouble,oaDouble,oaBox)
    {
        PyParamoaDouble p1;
        PyParamoaDouble p2;
        PyParamoaBox p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaDouble_Convert,&p1,
              &PyoaDouble_Convert,&p2,
              &PyoaBox_Convert,&p3)) {
            data.DataCall()->transform(p1.Data(),p2.Data(),p3.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDouble,oaDouble)
    {
        PyParamoaDouble p1;
        PyParamoaDouble p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaDouble_Convert,&p1,
              &PyoaDouble_Convert,&p2)) {
            data.DataCall()->transform(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBox, function: transform, Choices are:\n"
        "    (oaTransform,oaBox)\n"
        "    (oaTransform)\n"
        "    (oaPoint,oaBox)\n"
        "    (oaPoint)\n"
        "    (oaDouble,oaDouble,oaBox)\n"
        "    (oaDouble,oaDouble)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBox_upperRight_doc[] = 
"Class: oaBox, Function: upperRight\n"
"  Paramegers: ()\n"
"    Calls: oaPoint& upperRight()\n"
"    Signature: upperRight|ref-oaPoint|\n"
"    BrowseData: 1\n"
"    This function returns a reference to the upper-right point of this box. You can change the value of the attributes right and top .\n"
;

static PyObject*
oaBox_upperRight(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox data;
    int convert_status=PyoaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxObject* self=(PyoaBoxObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaPoint* result=&(data.DataCall()->upperRight());
        return PyoaPoint_FromoaPoint(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaBox_assign_doc[] = 
"Class: oaBox, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBox_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBox data;
  int convert_status=PyoaBox_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBox p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBox_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBox_methodlist[] = {
    {"bottom",(PyCFunction)oaBox_bottom,METH_VARARGS,oaBox_bottom_doc},
    {"contains",(PyCFunction)oaBox_contains,METH_VARARGS,oaBox_contains_doc},
    {"distanceFrom2",(PyCFunction)oaBox_distanceFrom2,METH_VARARGS,oaBox_distanceFrom2_doc},
    {"fix",(PyCFunction)oaBox_fix,METH_VARARGS,oaBox_fix_doc},
    {"getCenter",(PyCFunction)oaBox_getCenter,METH_VARARGS,oaBox_getCenter_doc},
    {"getHeight",(PyCFunction)oaBox_getHeight,METH_VARARGS,oaBox_getHeight_doc},
    {"getLowerRight",(PyCFunction)oaBox_getLowerRight,METH_VARARGS,oaBox_getLowerRight_doc},
    {"getUpperLeft",(PyCFunction)oaBox_getUpperLeft,METH_VARARGS,oaBox_getUpperLeft_doc},
    {"getWidth",(PyCFunction)oaBox_getWidth,METH_VARARGS,oaBox_getWidth_doc},
    {"hasNoArea",(PyCFunction)oaBox_hasNoArea,METH_VARARGS,oaBox_hasNoArea_doc},
    {"init",(PyCFunction)oaBox_init,METH_VARARGS,oaBox_init_doc},
    {"intersection",(PyCFunction)oaBox_intersection,METH_VARARGS,oaBox_intersection_doc},
    {"isInverted",(PyCFunction)oaBox_isInverted,METH_VARARGS,oaBox_isInverted_doc},
    {"left",(PyCFunction)oaBox_left,METH_VARARGS,oaBox_left_doc},
    {"lowerLeft",(PyCFunction)oaBox_lowerLeft,METH_VARARGS,oaBox_lowerLeft_doc},
    {"makeInvertedZero",(PyCFunction)oaBox_makeInvertedZero,METH_VARARGS,oaBox_makeInvertedZero_doc},
    {"makeZero",(PyCFunction)oaBox_makeZero,METH_VARARGS,oaBox_makeZero_doc},
    {"merge",(PyCFunction)oaBox_merge,METH_VARARGS,oaBox_merge_doc},
    {"overlaps",(PyCFunction)oaBox_overlaps,METH_VARARGS,oaBox_overlaps_doc},
    {"right",(PyCFunction)oaBox_right,METH_VARARGS,oaBox_right_doc},
    {"scale",(PyCFunction)oaBox_scale,METH_VARARGS,oaBox_scale_doc},
    {"set",(PyCFunction)oaBox_set,METH_VARARGS,oaBox_set_doc},
    {"toPoints",(PyCFunction)oaBox_toPoints,METH_VARARGS,oaBox_toPoints_doc},
    {"top",(PyCFunction)oaBox_top,METH_VARARGS,oaBox_top_doc},
    {"transform",(PyCFunction)oaBox_transform,METH_VARARGS,oaBox_transform_doc},
    {"upperRight",(PyCFunction)oaBox_upperRight,METH_VARARGS,oaBox_upperRight_doc},
    {"assign",(PyCFunction)oaBox_tp_assign,METH_VARARGS,oaBox_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBox_doc[] = 
"Class: oaBox\n"
"  The oaBox utility class implements a two-dimensional rectangular region with integer coordinates. This class is used throughout the database to represent the bounding boxes of objects.\n"
"  If coordinates are stored in a bounding box such that the left value is greater than the right value, or the bottom value is greater than the top value, then the bounding box is referred to as inverted . Inverted bounding boxes are used to indicate that no valid bounding coordinates are present.\n"
"  The coordinates are in integer data base units (DBUs) which get mapped to defined distances by settings in the technology data base. See oaTech::getDBUPerUU for more. When the data base units are set to 1000 per micron, the coordinate range for OpenAccess is +/-2.147 meters.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaBox()\n"
"    Signature: oaBox||\n"
"    This function constructs an uninitialized oaBox object. Accessing the coordinates in a box at this point has indeterminate results.\n"
"  Paramegers: (oaCoord,oaCoord,oaCoord,oaCoord)\n"
"    Calls: oaBox(oaCoord leftIn,oaCoord bottomIn,oaCoord rightIn,oaCoord topIn)\n"
"    Signature: oaBox||simple-oaCoord,simple-oaCoord,simple-oaCoord,simple-oaCoord,\n"
"    This function constructs a box from individual left, bottom, right, and top side coordinates of the box.\n"
"    leftIn\n"
"    The left side location of the box\n"
"    bottomIn\n"
"    The bottom side location of the box\n"
"    rightIn\n"
"    The right side location of the box\n"
"    topIn\n"
"    The top right side location of the box\n"
"  Paramegers: (oaPoint,oaPoint)\n"
"    Calls: oaBox(const oaPoint& lowerLeftIn,const oaPoint& upperRightIn)\n"
"    Signature: oaBox||cref-oaPoint,cref-oaPoint,\n"
"    This function constructs a box from two oaPoint values. The two oaPoint values define the lower-left and upper right corners of the box.\n"
"    lowerLeftIn\n"
"    The lower-left oaPoint for the box\n"
"    upperRightIn\n"
"    The upper right oaPoint for the box\n"
"  Paramegers: (oaPoint,oaUInt4)\n"
"    Calls: oaBox(const oaPoint& center,oaUInt4 size)\n"
"    Signature: oaBox||cref-oaPoint,simple-oaUInt4,\n"
"    This function constructs a square box centered about the specified oaPoint with each side set to the specified size from the center.\n"
"    center\n"
"    The oaPoint at which the box is centered\n"
"    size\n"
"    The spacing from each side to the center of the box\n"
"  Paramegers: (oaBox,oaTransform)\n"
"    Calls: oaBox(const oaBox& box,const oaTransform& xform)\n"
"    Signature: oaBox||cref-oaBox,cref-oaTransform,\n"
"    This function creates a transformed copy of the specified box.\n"
"    box\n"
"    The box to copy\n"
"    xform\n"
"    The transform to apply to the copy\n"
"  Paramegers: (oaBox)\n"
"    Calls: (const oaBox&)\n"
"    Signature: oaBox||cref-oaBox,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBox_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBox",
    sizeof(PyoaBoxObject),
    0,
    (destructor)oaBox_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBox_tp_compare,	/* tp_compare */
    (reprfunc)oaBox_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBox_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBox_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBox_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBox_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBox_Type)<0) {
      printf("** PyType_Ready failed for: oaBox\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBox",
           (PyObject*)(&PyoaBox_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBox\n");
       return -1;
    }
    return 0;
}


// ==================================================================
// Array for class: oaBox
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBox_Array_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBox_Array_Type);
    PyObject* gself = type->tp_alloc(type,0);
    if (gself == NULL) return gself;
    PyoaBox_ArrayObject* self = (PyoaBox_ArrayObject*)gself;
    self->borrow = 0;
    self->locks=NULL;
    static char *kwlist [] = { NULL } ;
    /* Case: () */ 
    {
        if (PyArg_ParseTuple(args,"")) {
            return gself;
        }
    }
    PyErr_Clear();
    /* Case: (int) */
    {
        int p1;
        if (PyArg_ParseTuple(args,(char*)"i",&p1)) {
            self->data.SetLen(p1);
            return gself;
        }
    }
    PyErr_Clear();
    /* Case: (oaBox_Array) */
    {
        PyParamoaBox_Array p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBox_Array_Convert,&p1)) {
            self->data.TakeAway(p1);
            return gself;
        }
    }
    /* Error */
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBox_Array, Choices are:\n"
        "    ()\n"
        "    (int)\n"
        "    (oaBox_Array)\n"
    );
    Py_DECREF(gself);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBox_Array_dealloc(PyObject* gself)
{
    PyoaBox_ArrayObject* self = (PyoaBox_ArrayObject*)gself;
    Py_XDECREF(self->locks);
    self->ob_type->tp_free(gself);
}

// ------------------------------------------------------------------
static PyObject*
oaBox_Array_str(PyObject *ob)
{
    PyParamoaBox_Array value;
    int convert_status=PyoaBox_Array_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* lst=PyoaBox_Array_CreateList(value);
    PyObject* result=PyObject_Str(lst);
    Py_DECREF(lst);
    return result;
}

// ------------------------------------------------------------------
static PyObject*
oaBox_Array_repr(PyObject *ob)
{
    PyParamoaBox_Array value;
    int convert_status=PyoaBox_Array_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* lst=PyoaBox_Array_CreateList(value);
    PyObject* result=PyObject_Repr(lst);
    Py_DECREF(lst);
    return result;
}

// ------------------------------------------------------------------
static int
oaBox_Array_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBox_Array p1;
    PyParamoaBox_Array p2;
    int s1=PyoaBox_Array_Convert(ob1,&p1);
    int s2=PyoaBox_Array_Convert(ob2,&p2);
    assert(s1!=0);
    assert(s2!=0);
    PyObject* l1=PyoaBox_Array_CreateList(p1);
    PyObject* l2=PyoaBox_Array_CreateList(p2);
    int result=PyObject_Compare(l1,l2);
    Py_DECREF(l1);
    Py_DECREF(l2);
    return result;
}

// ------------------------------------------------------------------
int
PyoaBox_Array_Convert(PyObject* ob,PyParamoaBox_Array* result)
{
  Pyoa_ssize_t len,i;
  if (PyoaBox_Array_Check(ob)) {
    PyoaBox_ArrayObject* self = (PyoaBox_ArrayObject*)ob;
    result->Borrow(self->data);
  }
  else if (PyList_Check(ob)) {
    len=PyList_Size(ob);
    result->SetLen(len);
    PyParamoaBox data;
    for(i=0;i<len;i++) {
      PyObject* a=PyList_GetItem(ob,i);
      if (!PyoaBox_Convert(a,&data)) return 0;
      result->SetItem(i,data.Data());
    }
  }
  else if (PyTuple_Check(ob)) {
    len=PyTuple_Size(ob);
    result->SetLen(len);
    PyParamoaBox data;
    for(i=0;i<len;i++) {
      PyObject* a=PyTuple_GetItem(ob,i);
      if (!PyoaBox_Convert(a,&data)) return 0;
      result->SetItem(i,data.Data());
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError,
      "Convertion of parameter to class: oaBox_Array Failed");
    return 0;
  }
  return 1;
}

// ------------------------------------------------------------------
PyObject* PyoaBox_Array_FromoaBox_Array(const oaBox_Array& value)
{
  PyObject* gself = PyoaBox_Array_Type.tp_alloc(&PyoaBox_Array_Type,0);
  if (gself == NULL) return gself;
  PyoaBox_ArrayObject* self = (PyoaBox_ArrayObject*)gself;
  self->data = value;
  self->borrow = 0;
  self->locks=NULL;
  return gself;
}

// ------------------------------------------------------------------
PyObject* PyoaBox_Array_FromoaBox_Array(PyTypeoaBox* data,Pyoa_ssize_t len,PyObject* lock)
{
  PyObject* gself = PyoaBox_Array_Type.tp_alloc(&PyoaBox_Array_Type,0);
  if (gself == NULL) return gself;
  PyoaBox_ArrayObject* self = (PyoaBox_ArrayObject*)gself;
  self->data.Borrow(data,len);
  self->borrow = 1;
  self->locks=NULL;
  if (lock) PyoaLockObject(self->locks,lock);
  return gself;
}

// ------------------------------------------------------------------
PyObject* PyoaBox_Array_CreateList(PyParamoaBox_Array& value)
{
  Pyoa_ssize_t i;
  PyObject* lst=PyList_New(value.Len());
  for(i=0;i<value.Len();i++) {
    PyObject* ob=PyoaBox_FromoaBox(value.Data()[i]);
    PyList_SetItem(lst,i,ob);
  }
  return lst;
}

// ------------------------------------------------------------------
// Methods
// ------------------------------------------------------------------
static char oaBox_Array_assign_doc[] = 
"Class: oaBox_Array, Function: assign\n"
"  Paramegers: (oaBox_Array)\n"
"    This function assigns the current value.\n"
;

static PyObject*
oaBox_Array_assign(PyObject* ob, PyObject *args)
{
  PyoaBox_ArrayObject* self=(PyoaBox_ArrayObject*)ob;
  try {
    PyParamoaBox_Array p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBox_Array_Convert,&p1)) {
        self->data=p1;
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}
// ------------------------------------------------------------------
static char oaBox_Array_list_doc[] = 
"Class: oaBox_Array, Function: list\n"
"  Paramegers: ()\n"
"    This function returns the current value as a list.\n"
;

static PyObject*
oaBox_Array_list(PyObject* ob, PyObject *args)
{
  PyoaBox_ArrayObject* self=(PyoaBox_ArrayObject*)ob;
  try {
    if (PyArg_ParseTuple(args,(char*)"")) {
      return PyoaBox_Array_CreateList(self->data);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}
// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------
static PyMethodDef oaBox_Array_methodlist[] = {
    {"assign",(PyCFunction)oaBox_Array_assign,METH_VARARGS,oaBox_Array_assign_doc},
    {"list",(PyCFunction)oaBox_Array_list,METH_VARARGS,oaBox_Array_list_doc},
   {NULL,NULL,0,NULL}
};

// ------------------------------------------------------------------
static PyObject*
oaBox_Array_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaBox_ArrayObject* self=(PyoaBox_ArrayObject*)ob;
  try {
    PyParamoaBox_Array data;
    int convert_status=PyoaBox_Array_Convert(ob,&data);
    assert(convert_status!=0);
    if (index<0 || index>=data.Len()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    return PyoaBox_FromoaBox(data.GetItemPtr(index),1,self->locks);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static Pyoa_ssize_t
oaBox_Array_index_get_length(PyObject* ob)
{
    PyParamoaBox_Array data;
    int convert_status=PyoaBox_Array_Convert(ob,&data);
    assert(convert_status!=0);
    return data.Len();
}

// ------------------------------------------------------------------
static int
oaBox_Array_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaBox_Array data;
    PyParamoaBox dataitem;
    int convert_status=PyoaBox_Array_Convert(ob,&data);
    assert(convert_status!=0);
    if (index<0 || index>=data.Len()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    if (PyoaBox_Convert(value,&dataitem)==0) return -1;
    data.SetItem(index,dataitem.Data());
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return 0;
  }
}

// ------------------------------------------------------------------
static char oaBox_Array_doc[] =
"Class: oaBox_Array\n"
"  The oaBox_Array utility class provides an array of oaBox.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaBox_Array()\n"
"    Signature: oaBox_Array||\n"
"    This is the default constructor for the oaBox_Array class. This constructor creates an empty oaBox_Array.\n"
"  Paramegers: (oaBox_Array)\n"
"    Calls: (const oaBox_Array&)\n"
"    Signature: oaBox_Array||cref-oaBox_Array,\n"
;

// ------------------------------------------------------------------
static PySequenceMethods oaBox_Array_as_sequence = {
    (Pyoa_inquiry)oaBox_Array_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,              /* sq_concat */
    (Pyoa_intargfunc)0,              /* sq_repeat */
    (Pyoa_intargfunc)oaBox_Array_index_get, /* sq_item */
    (Pyoa_intintargfunc)0,           /* sq_slice */
    (Pyoa_intobjargproc)oaBox_Array_index_set,      /* sq_ass_item */
};

// ------------------------------------------------------------------
PyTypeObject PyoaBox_Array_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBox_Array",
    sizeof(PyoaBox_ArrayObject),
    0,
    oaBox_Array_dealloc, /* tp_dealloc */
    0,  /* tp_print */
    0,                                  /* tp_getattr */
    0,                                  /* tp_setattr */
    oaBox_Array_compare,    /* tp_compare */
    oaBox_Array_repr,      /* tp_repr */
    0,                                  /* tp_as_number */
    &oaBox_Array_as_sequence,  /* tp_as_sequence */
    0,                                  /* tp_as_mapping */
    0,                                  /* tp_as_hash */
    0,                                  /* tp_as_call */
    oaBox_Array_str,               /* tp_str */
    0,                                  /* tp_getattro */
    0,                                  /* tp_setattro */
    0,                                  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBox_Array_doc, /* tp_doc */
    0,                                  /* tp_traverse */
    0,                                  /* tp_clear */
    0,                                  /* tp_richcompre */
    0,                                  /* tp_weaklistoffset */
    0,                                  /* tp_iter */
    0,                                  /* tp_iternext */
    oaBox_Array_methodlist, /* tp_methods */
    0,                                  /* tp_members */
    0,                                  /* tp_getset */
    0,                                  /* tp_base */
    0,                                  /* tp_dict */
    0,                                  /* tp_descr_get */
    0,                                  /* tp_descr_set */
    0,                                  /* tp_dictoffset */
    0,                                  /* tp_init */
    PyType_GenericAlloc,        /* tp_alloc */
    oaBox_Array_new, /* tp_new */
    _PyObject_Del,      /* tp_free */
};


// ------------------------------------------------------------------
int
PyoaBox_Array_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBox_Array_Type)<0) {
      printf("** PyType_Ready failed for: oaBox_Array\n");
      return -1;
    }
    if (PyDict_SetItemString(mod_dict,"oaBox_Array",
           (PyObject*)(&PyoaBox_Array_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBox_Array\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBoxArray
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBoxArray_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBoxArray_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBoxArrayObject* self = (PyoaBoxArrayObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaArrayBase_oaBox*)  new oaBoxArray();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value = (oaArrayBase_oaBox*)  new oaBoxArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaBoxArray)
    {
        PyParamoaBoxArray p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBoxArray_Convert,&p1)) {
            self->value=(oaArrayBase_oaBox*)  new oaBoxArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBoxArray, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaBoxArray)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBoxArray_tp_dealloc(PyoaBoxArrayObject* self)
{
    if (!self->borrow) {
        delete (oaBoxArray*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBoxArray_tp_repr(PyObject *ob)
{
    PyParamoaBoxArray value;
    int convert_status=PyoaBoxArray_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[32];
    sprintf(buffer,"<oaBoxArray::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBoxArray_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBoxArray v1;
    PyParamoaBoxArray v2;
    int convert_status1=PyoaBoxArray_Convert(ob1,&v1);
    int convert_status2=PyoaBoxArray_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBoxArray_Convert(PyObject* ob,PyParamoaBoxArray* result)
{
    if (ob == NULL) return 1;
    if (PyoaBoxArray_Check(ob)) {
        result->SetData( (oaBoxArray*) ((PyoaBoxArrayObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBoxArray Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBoxArray_FromoaBoxArray(oaBoxArray* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaBoxArray_Type.tp_alloc(&PyoaBoxArray_Type,0);
        if (bself == NULL) return bself;
        PyoaBoxArrayObject* self = (PyoaBoxArrayObject*)bself;
        self->value = (oaArrayBase_oaBox*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBoxArray_doc[] = 
"Class: oaBoxArray\n"
"  The oaBoxArray class implements an array of oaBoxes.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaBoxArray()\n"
"    Signature: oaBoxArray||simple-oaUInt4,\n"
"    This is the constructor for the oaBoxArray class. It allocates storage for this array with the specified size.\n"
"    sizeIn\n"
"    The array size\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaBoxArray(oaUInt4 sizeIn)\n"
"    Signature: oaBoxArray||simple-oaUInt4,\n"
"    This is the constructor for the oaBoxArray class. It allocates storage for this array with the specified size.\n"
"    sizeIn\n"
"    The array size\n"
"  Paramegers: (oaBoxArray)\n"
"    Calls: (const oaBoxArray&)\n"
"    Signature: oaBoxArray||cref-oaBoxArray,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBoxArray_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBoxArray",
    sizeof(PyoaBoxArrayObject),
    0,
    (destructor)oaBoxArray_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBoxArray_tp_compare,	/* tp_compare */
    (reprfunc)oaBoxArray_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBoxArray_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaArray_oaBox_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBoxArray_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBoxArray_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBoxArray_Type)<0) {
      printf("** PyType_Ready failed for: oaBoxArray\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBoxArray",
           (PyObject*)(&PyoaBoxArray_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBoxArray\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBoxArrayValue
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBoxArrayValue_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBoxArrayValue_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBoxArrayValueObject* self = (PyoaBoxArrayValueObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBoxArrayValue)
    {
        PyParamoaBoxArrayValue p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBoxArrayValue_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBoxArrayValue, Choices are:\n"
        "    (oaBoxArrayValue)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBoxArrayValue_tp_dealloc(PyoaBoxArrayValueObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBoxArrayValue_tp_repr(PyObject *ob)
{
    PyParamoaBoxArrayValue value;
    int convert_status=PyoaBoxArrayValue_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[37];
    sprintf(buffer,"<oaBoxArrayValue::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBoxArrayValue_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBoxArrayValue v1;
    PyParamoaBoxArrayValue v2;
    int convert_status1=PyoaBoxArrayValue_Convert(ob1,&v1);
    int convert_status2=PyoaBoxArrayValue_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBoxArrayValue_Convert(PyObject* ob,PyParamoaBoxArrayValue* result)
{
    if (ob == NULL) return 1;
    if (PyoaBoxArrayValue_Check(ob)) {
        result->SetData( (oaBoxArrayValue**) ((PyoaBoxArrayValueObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBoxArrayValue Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBoxArrayValue_FromoaBoxArrayValue(oaBoxArrayValue** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBoxArrayValue* data=*value;
        PyObject* bself = PyoaBoxArrayValue_Type.tp_alloc(&PyoaBoxArrayValue_Type,0);
        if (bself == NULL) return bself;
        PyoaBoxArrayValueObject* self = (PyoaBoxArrayValueObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBoxArrayValue_FromoaBoxArrayValue(oaBoxArrayValue* data)
{
    if (data) {
       PyObject* bself = PyoaBoxArrayValue_Type.tp_alloc(&PyoaBoxArrayValue_Type,0);
       if (bself == NULL) return bself;
       PyoaBoxArrayValueObject* self = (PyoaBoxArrayValueObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBoxArrayValue_get_doc[] = 
"Class: oaBoxArrayValue, Function: get\n"
"  Paramegers: (oaBoxArray)\n"
"    Calls: void get(oaBoxArray& value) const\n"
"    Signature: get|void-void|ref-oaBoxArray,\n"
"    BrowseData: 0,oaBoxArray\n"
"    This function returns the boxArray for this value.\n"
"    value\n"
"    The returned value\n"
;

static PyObject*
oaBoxArrayValue_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBoxArrayValue data;
    int convert_status=PyoaBoxArrayValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxArrayValueObject* self=(PyoaBoxArrayValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBoxArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBoxArray_Convert,&p1)) {
        data.DataCall()->get(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBoxArrayValue_set_doc[] = 
"Class: oaBoxArrayValue, Function: set\n"
"  Paramegers: (oaBoxArray)\n"
"    Calls: void set(const oaBoxArray& value)\n"
"    Signature: set|void-void|cref-oaBoxArray,\n"
"    This function sets this value to the specified boxArray value.\n"
"    value\n"
"    The boxArray value to set\n"
;

static PyObject*
oaBoxArrayValue_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBoxArrayValue data;
    int convert_status=PyoaBoxArrayValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBoxArrayValueObject* self=(PyoaBoxArrayValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBoxArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBoxArray_Convert,&p1)) {
        data.DataCall()->set(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBoxArrayValue_isNull_doc[] =
"Class: oaBoxArrayValue, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBoxArrayValue_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBoxArrayValue data;
    int convert_status=PyoaBoxArrayValue_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBoxArrayValue_assign_doc[] = 
"Class: oaBoxArrayValue, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBoxArrayValue_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBoxArrayValue data;
  int convert_status=PyoaBoxArrayValue_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBoxArrayValue p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBoxArrayValue_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBoxArrayValue_methodlist[] = {
    {"get",(PyCFunction)oaBoxArrayValue_get,METH_VARARGS,oaBoxArrayValue_get_doc},
    {"set",(PyCFunction)oaBoxArrayValue_set,METH_VARARGS,oaBoxArrayValue_set_doc},
    {"isNull",(PyCFunction)oaBoxArrayValue_tp_isNull,METH_VARARGS,oaBoxArrayValue_isNull_doc},
    {"assign",(PyCFunction)oaBoxArrayValue_tp_assign,METH_VARARGS,oaBoxArrayValue_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBoxArrayValue_doc[] = 
"Class: oaBoxArrayValue\n"
"  The oaBoxArrayValue class represents an array of boxes.\n"
"  See oaValue for a discussion of the usage of all of the oaValue subclasses.\n"
"Constructors:\n"
"  Paramegers: (oaBoxArrayValue)\n"
"    Calls: (const oaBoxArrayValue&)\n"
"    Signature: oaBoxArrayValue||cref-oaBoxArrayValue,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBoxArrayValue_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBoxArrayValue",
    sizeof(PyoaBoxArrayValueObject),
    0,
    (destructor)oaBoxArrayValue_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBoxArrayValue_tp_compare,	/* tp_compare */
    (reprfunc)oaBoxArrayValue_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBoxArrayValue_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBoxArrayValue_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaValue_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBoxArrayValue_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBoxArrayValue_static_create_doc[] = 
"Class: oaBoxArrayValue, Function: create\n"
"  Paramegers: (oaObject,oaBoxArray)\n"
"    Calls: oaBoxArrayValue* create(oaObject* database,const oaBoxArray& value)\n"
"    Signature: create|ptr-oaBoxArrayValue|ptr-oaObject,cref-oaBoxArray,\n"
"    This function creates a boxArray value in the database specified.\n"
"    database\n"
"    The database in which to create the value.\n"
"    value\n"
"    The boxArray value\n"
"    oacEmptyArrayValue\n"
"    oacInvalidDatabase\n"
;

static PyObject*
oaBoxArrayValue_static_create(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObject p1;
    PyParamoaBoxArray p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaObject_Convert,&p1,
          &PyoaBoxArray_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoxArrayValuep result= (oaBoxArrayValue::create(p1.Data(),p2.Data()));
        return PyoaBoxArrayValue_FromoaBoxArrayValue(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBoxArrayValue_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaBoxArrayValue_static_create,METH_VARARGS,oaBoxArrayValue_static_create_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBoxArrayValue_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBoxArrayValue_Type)<0) {
      printf("** PyType_Ready failed for: oaBoxArrayValue\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBoxArrayValue",
           (PyObject*)(&PyoaBoxArrayValue_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBoxArrayValue\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBoxArrayValue_Type.tp_dict;
    for(method=oaBoxArrayValue_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBuildInfo
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBuildInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBuildInfo_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBuildInfoObject* self = (PyoaBuildInfoObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBuildInfo)
    {
        PyParamoaBuildInfo p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBuildInfo_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBuildInfo, Choices are:\n"
        "    (oaBuildInfo)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBuildInfo_tp_dealloc(PyoaBuildInfoObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBuildInfo_tp_repr(PyObject *ob)
{
    PyParamoaBuildInfo value;
    int convert_status=PyoaBuildInfo_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[33];
    sprintf(buffer,"<oaBuildInfo::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBuildInfo_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBuildInfo v1;
    PyParamoaBuildInfo v2;
    int convert_status1=PyoaBuildInfo_Convert(ob1,&v1);
    int convert_status2=PyoaBuildInfo_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBuildInfo_Convert(PyObject* ob,PyParamoaBuildInfo* result)
{
    if (ob == NULL) return 1;
    if (PyoaBuildInfo_Check(ob)) {
        result->SetData(  ((PyoaBuildInfoObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBuildInfo Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBuildInfo_FromoaBuildInfo(oaBuildInfo** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBuildInfo* data=*value;
        PyObject* bself = PyoaBuildInfo_Type.tp_alloc(&PyoaBuildInfo_Type,0);
        if (bself == NULL) return bself;
        PyoaBuildInfoObject* self = (PyoaBuildInfoObject*)bself;
        self->value = value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBuildInfo_FromoaBuildInfo(oaBuildInfo* data)
{
    if (data) {
       PyObject* bself = PyoaBuildInfo_Type.tp_alloc(&PyoaBuildInfo_Type,0);
       if (bself == NULL) return bself;
       PyoaBuildInfoObject* self = (PyoaBuildInfoObject*)bself;
       self->data = data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBuildInfo_getBuildName_doc[] = 
"Class: oaBuildInfo, Function: getBuildName\n"
"  Paramegers: ()\n"
"    Calls: const oaString& getBuildName() const\n"
"    Signature: getBuildName|cref-oaString|\n"
"    BrowseData: 1\n"
"    This function returns the build name associated with this oaBuildInfo object.\n"
;

static PyObject*
oaBuildInfo_getBuildName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBuildInfo data;
    int convert_status=PyoaBuildInfo_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBuildInfoObject* self=(PyoaBuildInfoObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaString result= (data.DataCall()->getBuildName());
        return PyoaString_FromoaString(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBuildInfo_getBuildNumber_doc[] = 
"Class: oaBuildInfo, Function: getBuildNumber\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getBuildNumber() const\n"
"    Signature: getBuildNumber|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the build number associated with this oaBuildInfo object.\n"
;

static PyObject*
oaBuildInfo_getBuildNumber(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBuildInfo data;
    int convert_status=PyoaBuildInfo_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBuildInfoObject* self=(PyoaBuildInfoObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getBuildNumber());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBuildInfo_getBuildTime_doc[] = 
"Class: oaBuildInfo, Function: getBuildTime\n"
"  Paramegers: ()\n"
"    Calls: const oaString& getBuildTime() const\n"
"    Signature: getBuildTime|cref-oaString|\n"
"    BrowseData: 1\n"
"    This function returns the build time string associated with this oaBuildInfo object.\n"
;

static PyObject*
oaBuildInfo_getBuildTime(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBuildInfo data;
    int convert_status=PyoaBuildInfo_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBuildInfoObject* self=(PyoaBuildInfoObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaString result= (data.DataCall()->getBuildTime());
        return PyoaString_FromoaString(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBuildInfo_getMajorReleaseNum_doc[] = 
"Class: oaBuildInfo, Function: getMajorReleaseNum\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getMajorReleaseNum() const\n"
"    Signature: getMajorReleaseNum|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the major release number associated with this oaBuildInfo object.\n"
;

static PyObject*
oaBuildInfo_getMajorReleaseNum(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBuildInfo data;
    int convert_status=PyoaBuildInfo_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBuildInfoObject* self=(PyoaBuildInfoObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getMajorReleaseNum());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBuildInfo_getMinorReleaseNum_doc[] = 
"Class: oaBuildInfo, Function: getMinorReleaseNum\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getMinorReleaseNum() const\n"
"    Signature: getMinorReleaseNum|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the minor release number associated with this oaBuildInfo object.\n"
;

static PyObject*
oaBuildInfo_getMinorReleaseNum(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBuildInfo data;
    int convert_status=PyoaBuildInfo_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBuildInfoObject* self=(PyoaBuildInfoObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getMinorReleaseNum());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBuildInfo_getPackageName_doc[] = 
"Class: oaBuildInfo, Function: getPackageName\n"
"  Paramegers: ()\n"
"    Calls: const oaString& getPackageName() const\n"
"    Signature: getPackageName|cref-oaString|\n"
"    BrowseData: 1\n"
"    This function returns the package name associated with this oaBuildInfo object.\n"
;

static PyObject*
oaBuildInfo_getPackageName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBuildInfo data;
    int convert_status=PyoaBuildInfo_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBuildInfoObject* self=(PyoaBuildInfoObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaString result= (data.DataCall()->getPackageName());
        return PyoaString_FromoaString(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBuildInfo_isNull_doc[] =
"Class: oaBuildInfo, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBuildInfo_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBuildInfo data;
    int convert_status=PyoaBuildInfo_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBuildInfo_assign_doc[] = 
"Class: oaBuildInfo, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBuildInfo_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBuildInfo data;
  int convert_status=PyoaBuildInfo_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBuildInfo p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBuildInfo_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBuildInfo_methodlist[] = {
    {"getBuildName",(PyCFunction)oaBuildInfo_getBuildName,METH_VARARGS,oaBuildInfo_getBuildName_doc},
    {"getBuildNumber",(PyCFunction)oaBuildInfo_getBuildNumber,METH_VARARGS,oaBuildInfo_getBuildNumber_doc},
    {"getBuildTime",(PyCFunction)oaBuildInfo_getBuildTime,METH_VARARGS,oaBuildInfo_getBuildTime_doc},
    {"getMajorReleaseNum",(PyCFunction)oaBuildInfo_getMajorReleaseNum,METH_VARARGS,oaBuildInfo_getMajorReleaseNum_doc},
    {"getMinorReleaseNum",(PyCFunction)oaBuildInfo_getMinorReleaseNum,METH_VARARGS,oaBuildInfo_getMinorReleaseNum_doc},
    {"getPackageName",(PyCFunction)oaBuildInfo_getPackageName,METH_VARARGS,oaBuildInfo_getPackageName_doc},
    {"isNull",(PyCFunction)oaBuildInfo_tp_isNull,METH_VARARGS,oaBuildInfo_isNull_doc},
    {"assign",(PyCFunction)oaBuildInfo_tp_assign,METH_VARARGS,oaBuildInfo_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBuildInfo_doc[] = 
"Class: oaBuildInfo\n"
"  The oaBuildInfo class implements a utility class for registering and querying build information for libraries and executables. When OpenAccess is built, each library and executable registers its own oaBuildInfo object. Applications can query by name for a specific oaBuildInfo object or can get the list of all registered packages.\n"
"  The build process defines the build name, time, and number, which helps identify the OpenAccess code in use. This information can be important when considering data compatibility. See Compatibility for OpenAccess Applications and Data in the Programmers Guide for more information.\n"
"Constructors:\n"
"  Paramegers: (oaBuildInfo)\n"
"    Calls: (const oaBuildInfo&)\n"
"    Signature: oaBuildInfo||cref-oaBuildInfo,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBuildInfo_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBuildInfo",
    sizeof(PyoaBuildInfoObject),
    0,
    (destructor)oaBuildInfo_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBuildInfo_tp_compare,	/* tp_compare */
    (reprfunc)oaBuildInfo_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBuildInfo_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBuildInfo_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBuildInfo_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBuildInfo_static_find_doc[] = 
"Class: oaBuildInfo, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaBuildInfo* find(const oaString& packageName)\n"
"    Signature: find|ptr-oaBuildInfo|cref-oaString,\n"
"    This function searches the list of build packages for a package with the specified name. NULL is returned if no such package is registered.\n"
"    packageName\n"
"    The name of the build package to find.\n"
;

static PyObject*
oaBuildInfo_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        oaBuildInfop result= (oaBuildInfo::find(p1.Data()));
        return PyoaBuildInfo_FromoaBuildInfo(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBuildInfo_static_getAppBuildName_doc[] = 
"Class: oaBuildInfo, Function: getAppBuildName\n"
"  Paramegers: ()\n"
"    Calls: const oaString& getAppBuildName()\n"
"    Signature: getAppBuildName|cref-oaString|\n"
"    BrowseData: 1\n"
"    This function returns the OpenAccess build name that the application is compiled against.\n"
;

static PyObject*
oaBuildInfo_static_getAppBuildName(PyObject* ob, PyObject *args)
{
  try {
    if (PyArg_ParseTuple(args,"")) {
        oaString result= (oaBuildInfo::getAppBuildName());
        return PyoaString_FromoaString(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBuildInfo_static_getNumPackages_doc[] = 
"Class: oaBuildInfo, Function: getNumPackages\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumPackages()\n"
"    Signature: getNumPackages|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of registered build packages.\n"
;

static PyObject*
oaBuildInfo_static_getNumPackages(PyObject* ob, PyObject *args)
{
  try {
    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (oaBuildInfo::getNumPackages());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBuildInfo_static_getPackages_doc[] = 
"Class: oaBuildInfo, Function: getPackages\n"
"  Paramegers: (oaBuildInfoArray)\n"
"    Calls: void getPackages(oaBuildInfoArray& packagesIn)\n"
"    Signature: getPackages|void-void|ref-oaBuildInfoArray,\n"
"    BrowseData: 0,oaBuildInfoArray\n"
"    This function returns the array of oaBuildInfo pointers stored by this class.\n"
"    packagesIn\n"
"    The array of oaBuildInfo pointers in which to return the list of packages.\n"
"  Paramegers: ()\n"
"    Calls:  getPackages()\n"
"    Signature: getPackages|pptr-oaBuildInfo|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the list of registered packages that have registered build information. This list can be traversed as follows:\n"
"    oaBuildInfo **packages = oaBuildInfo::getPackages (); for (oaUInt4 i = 0; i < oaBuildInfo::getNumPackages (); i++) { oaBuildInfo *pkg = packages[i]; ... }\n"
;

extern PyObject* oaBuildInfo_static_getPackages(PyObject *self, PyObject *args);

// ------------------------------------------------------------------
static char oaBuildInfo_static_getPlatformName_doc[] = 
"Class: oaBuildInfo, Function: getPlatformName\n"
"  Paramegers: ()\n"
"    Calls: oaString getPlatformName()\n"
"    Signature: getPlatformName|simple-oaString|\n"
"    BrowseData: 1\n"
"    oaBuildInfo::getPlatformName\n"
"    This static function returns the platform name string associated with this oaBuildInfo object.\n"
"    For a complete list of the OpenAccess supported platforms, refer to the OpenAccess 2.2 Installation and Configuration Notes .\n"
;

static PyObject*
oaBuildInfo_static_getPlatformName(PyObject* ob, PyObject *args)
{
  try {
    if (PyArg_ParseTuple(args,"")) {
        oaString result= (oaBuildInfo::getPlatformName());
        return PyoaString_FromoaString(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBuildInfo_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaBuildInfo_static_find,METH_VARARGS,oaBuildInfo_static_find_doc},
    {"static_getAppBuildName",(PyCFunction)oaBuildInfo_static_getAppBuildName,METH_VARARGS,oaBuildInfo_static_getAppBuildName_doc},
    {"static_getNumPackages",(PyCFunction)oaBuildInfo_static_getNumPackages,METH_VARARGS,oaBuildInfo_static_getNumPackages_doc},
    {"static_getPackages",(PyCFunction)oaBuildInfo_static_getPackages,METH_VARARGS,oaBuildInfo_static_getPackages_doc},
    {"static_getPlatformName",(PyCFunction)oaBuildInfo_static_getPlatformName,METH_VARARGS,oaBuildInfo_static_getPlatformName_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBuildInfo_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBuildInfo_Type)<0) {
      printf("** PyType_Ready failed for: oaBuildInfo\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBuildInfo",
           (PyObject*)(&PyoaBuildInfo_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBuildInfo\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBuildInfo_Type.tp_dict;
    for(method=oaBuildInfo_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


// ==================================================================
// Array for class: oaBuildInfo
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBuildInfo_Array_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBuildInfo_Array_Type);
    PyObject* gself = type->tp_alloc(type,0);
    if (gself == NULL) return gself;
    PyoaBuildInfo_ArrayObject* self = (PyoaBuildInfo_ArrayObject*)gself;
    self->borrow = 0;
    self->locks=NULL;
    static char *kwlist [] = { NULL } ;
    /* Case: () */ 
    {
        if (PyArg_ParseTuple(args,"")) {
            return gself;
        }
    }
    PyErr_Clear();
    /* Case: (int) */
    {
        int p1;
        if (PyArg_ParseTuple(args,(char*)"i",&p1)) {
            self->data.SetLen(p1);
            return gself;
        }
    }
    PyErr_Clear();
    /* Case: (oaBuildInfo_Array) */
    {
        PyParamoaBuildInfo_Array p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBuildInfo_Array_Convert,&p1)) {
            self->data.TakeAway(p1);
            return gself;
        }
    }
    /* Error */
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBuildInfo_Array, Choices are:\n"
        "    ()\n"
        "    (int)\n"
        "    (oaBuildInfo_Array)\n"
    );
    Py_DECREF(gself);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBuildInfo_Array_dealloc(PyObject* gself)
{
    PyoaBuildInfo_ArrayObject* self = (PyoaBuildInfo_ArrayObject*)gself;
    Py_XDECREF(self->locks);
    self->ob_type->tp_free(gself);
}

// ------------------------------------------------------------------
static PyObject*
oaBuildInfo_Array_str(PyObject *ob)
{
    PyParamoaBuildInfo_Array value;
    int convert_status=PyoaBuildInfo_Array_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* lst=PyoaBuildInfo_Array_CreateList(value);
    PyObject* result=PyObject_Str(lst);
    Py_DECREF(lst);
    return result;
}

// ------------------------------------------------------------------
static PyObject*
oaBuildInfo_Array_repr(PyObject *ob)
{
    PyParamoaBuildInfo_Array value;
    int convert_status=PyoaBuildInfo_Array_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* lst=PyoaBuildInfo_Array_CreateList(value);
    PyObject* result=PyObject_Repr(lst);
    Py_DECREF(lst);
    return result;
}

// ------------------------------------------------------------------
static int
oaBuildInfo_Array_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBuildInfo_Array p1;
    PyParamoaBuildInfo_Array p2;
    int s1=PyoaBuildInfo_Array_Convert(ob1,&p1);
    int s2=PyoaBuildInfo_Array_Convert(ob2,&p2);
    assert(s1!=0);
    assert(s2!=0);
    PyObject* l1=PyoaBuildInfo_Array_CreateList(p1);
    PyObject* l2=PyoaBuildInfo_Array_CreateList(p2);
    int result=PyObject_Compare(l1,l2);
    Py_DECREF(l1);
    Py_DECREF(l2);
    return result;
}

// ------------------------------------------------------------------
int
PyoaBuildInfo_Array_Convert(PyObject* ob,PyParamoaBuildInfo_Array* result)
{
  Pyoa_ssize_t len,i;
  if (PyoaBuildInfo_Array_Check(ob)) {
    PyoaBuildInfo_ArrayObject* self = (PyoaBuildInfo_ArrayObject*)ob;
    result->Borrow(self->data);
  }
  else if (PyList_Check(ob)) {
    len=PyList_Size(ob);
    result->SetLen(len);
    PyParamoaBuildInfo data;
    for(i=0;i<len;i++) {
      PyObject* a=PyList_GetItem(ob,i);
      if (!PyoaBuildInfo_Convert(a,&data)) return 0;
      result->SetItem(i,data.Data());
    }
  }
  else if (PyTuple_Check(ob)) {
    len=PyTuple_Size(ob);
    result->SetLen(len);
    PyParamoaBuildInfo data;
    for(i=0;i<len;i++) {
      PyObject* a=PyTuple_GetItem(ob,i);
      if (!PyoaBuildInfo_Convert(a,&data)) return 0;
      result->SetItem(i,data.Data());
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError,
      "Convertion of parameter to class: oaBuildInfo_Array Failed");
    return 0;
  }
  return 1;
}

// ------------------------------------------------------------------
PyObject* PyoaBuildInfo_Array_FromoaBuildInfo_Array(const oaBuildInfo_Array& value)
{
  PyObject* gself = PyoaBuildInfo_Array_Type.tp_alloc(&PyoaBuildInfo_Array_Type,0);
  if (gself == NULL) return gself;
  PyoaBuildInfo_ArrayObject* self = (PyoaBuildInfo_ArrayObject*)gself;
  self->data = value;
  self->borrow = 0;
  self->locks=NULL;
  return gself;
}

// ------------------------------------------------------------------
PyObject* PyoaBuildInfo_Array_FromoaBuildInfo_Array(PyTypeoaBuildInfo* data,Pyoa_ssize_t len,PyObject* lock)
{
  PyObject* gself = PyoaBuildInfo_Array_Type.tp_alloc(&PyoaBuildInfo_Array_Type,0);
  if (gself == NULL) return gself;
  PyoaBuildInfo_ArrayObject* self = (PyoaBuildInfo_ArrayObject*)gself;
  self->data.Borrow(data,len);
  self->borrow = 1;
  self->locks=NULL;
  if (lock) PyoaLockObject(self->locks,lock);
  return gself;
}

// ------------------------------------------------------------------
PyObject* PyoaBuildInfo_Array_CreateList(PyParamoaBuildInfo_Array& value)
{
  Pyoa_ssize_t i;
  PyObject* lst=PyList_New(value.Len());
  for(i=0;i<value.Len();i++) {
    PyObject* ob=PyoaBuildInfo_FromoaBuildInfo(value.Data()[i]);
    PyList_SetItem(lst,i,ob);
  }
  return lst;
}

// ------------------------------------------------------------------
// Methods
// ------------------------------------------------------------------
static char oaBuildInfo_Array_assign_doc[] = 
"Class: oaBuildInfo_Array, Function: assign\n"
"  Paramegers: (oaBuildInfo_Array)\n"
"    This function assigns the current value.\n"
;

static PyObject*
oaBuildInfo_Array_assign(PyObject* ob, PyObject *args)
{
  PyoaBuildInfo_ArrayObject* self=(PyoaBuildInfo_ArrayObject*)ob;
  try {
    PyParamoaBuildInfo_Array p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBuildInfo_Array_Convert,&p1)) {
        self->data=p1;
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}
// ------------------------------------------------------------------
static char oaBuildInfo_Array_list_doc[] = 
"Class: oaBuildInfo_Array, Function: list\n"
"  Paramegers: ()\n"
"    This function returns the current value as a list.\n"
;

static PyObject*
oaBuildInfo_Array_list(PyObject* ob, PyObject *args)
{
  PyoaBuildInfo_ArrayObject* self=(PyoaBuildInfo_ArrayObject*)ob;
  try {
    if (PyArg_ParseTuple(args,(char*)"")) {
      return PyoaBuildInfo_Array_CreateList(self->data);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}
// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------
static PyMethodDef oaBuildInfo_Array_methodlist[] = {
    {"assign",(PyCFunction)oaBuildInfo_Array_assign,METH_VARARGS,oaBuildInfo_Array_assign_doc},
    {"list",(PyCFunction)oaBuildInfo_Array_list,METH_VARARGS,oaBuildInfo_Array_list_doc},
   {NULL,NULL,0,NULL}
};

// ------------------------------------------------------------------
static PyObject*
oaBuildInfo_Array_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaBuildInfo_ArrayObject* self=(PyoaBuildInfo_ArrayObject*)ob;
  try {
    PyParamoaBuildInfo_Array data;
    int convert_status=PyoaBuildInfo_Array_Convert(ob,&data);
    assert(convert_status!=0);
    if (index<0 || index>=data.Len()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    return PyoaBuildInfo_FromoaBuildInfo(data.GetItemPtr(index),1,self->locks);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static Pyoa_ssize_t
oaBuildInfo_Array_index_get_length(PyObject* ob)
{
    PyParamoaBuildInfo_Array data;
    int convert_status=PyoaBuildInfo_Array_Convert(ob,&data);
    assert(convert_status!=0);
    return data.Len();
}

// ------------------------------------------------------------------
static int
oaBuildInfo_Array_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaBuildInfo_Array data;
    PyParamoaBuildInfo dataitem;
    int convert_status=PyoaBuildInfo_Array_Convert(ob,&data);
    assert(convert_status!=0);
    if (index<0 || index>=data.Len()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    if (PyoaBuildInfo_Convert(value,&dataitem)==0) return -1;
    data.SetItem(index,dataitem.Data());
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return 0;
  }
}

// ------------------------------------------------------------------
static char oaBuildInfo_Array_doc[] =
"Class: oaBuildInfo_Array\n"
"  The oaBuildInfo_Array utility class provides an array of oaBuildInfo.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaBuildInfo_Array()\n"
"    Signature: oaBuildInfo_Array||\n"
"    This is the default constructor for the oaBuildInfo_Array class. This constructor creates an empty oaBuildInfo_Array.\n"
"  Paramegers: (oaBuildInfo_Array)\n"
"    Calls: (const oaBuildInfo_Array&)\n"
"    Signature: oaBuildInfo_Array||cref-oaBuildInfo_Array,\n"
;

// ------------------------------------------------------------------
static PySequenceMethods oaBuildInfo_Array_as_sequence = {
    (Pyoa_inquiry)oaBuildInfo_Array_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,              /* sq_concat */
    (Pyoa_intargfunc)0,              /* sq_repeat */
    (Pyoa_intargfunc)oaBuildInfo_Array_index_get, /* sq_item */
    (Pyoa_intintargfunc)0,           /* sq_slice */
    (Pyoa_intobjargproc)oaBuildInfo_Array_index_set,      /* sq_ass_item */
};

// ------------------------------------------------------------------
PyTypeObject PyoaBuildInfo_Array_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBuildInfo_Array",
    sizeof(PyoaBuildInfo_ArrayObject),
    0,
    oaBuildInfo_Array_dealloc, /* tp_dealloc */
    0,  /* tp_print */
    0,                                  /* tp_getattr */
    0,                                  /* tp_setattr */
    oaBuildInfo_Array_compare,    /* tp_compare */
    oaBuildInfo_Array_repr,      /* tp_repr */
    0,                                  /* tp_as_number */
    &oaBuildInfo_Array_as_sequence,  /* tp_as_sequence */
    0,                                  /* tp_as_mapping */
    0,                                  /* tp_as_hash */
    0,                                  /* tp_as_call */
    oaBuildInfo_Array_str,               /* tp_str */
    0,                                  /* tp_getattro */
    0,                                  /* tp_setattro */
    0,                                  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBuildInfo_Array_doc, /* tp_doc */
    0,                                  /* tp_traverse */
    0,                                  /* tp_clear */
    0,                                  /* tp_richcompre */
    0,                                  /* tp_weaklistoffset */
    0,                                  /* tp_iter */
    0,                                  /* tp_iternext */
    oaBuildInfo_Array_methodlist, /* tp_methods */
    0,                                  /* tp_members */
    0,                                  /* tp_getset */
    0,                                  /* tp_base */
    0,                                  /* tp_dict */
    0,                                  /* tp_descr_get */
    0,                                  /* tp_descr_set */
    0,                                  /* tp_dictoffset */
    0,                                  /* tp_init */
    PyType_GenericAlloc,        /* tp_alloc */
    oaBuildInfo_Array_new, /* tp_new */
    _PyObject_Del,      /* tp_free */
};


// ------------------------------------------------------------------
int
PyoaBuildInfo_Array_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBuildInfo_Array_Type)<0) {
      printf("** PyType_Ready failed for: oaBuildInfo_Array\n");
      return -1;
    }
    if (PyDict_SetItemString(mod_dict,"oaBuildInfo_Array",
           (PyObject*)(&PyoaBuildInfo_Array_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBuildInfo_Array\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBuildInfoArray
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBuildInfoArray_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBuildInfoArray_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBuildInfoArrayObject* self = (PyoaBuildInfoArrayObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaArrayBase_oaBuildInfo*)  new oaBuildInfoArray();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value = (oaArrayBase_oaBuildInfo*)  new oaBuildInfoArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaBuildInfoArray)
    {
        PyParamoaBuildInfoArray p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBuildInfoArray_Convert,&p1)) {
            self->value=(oaArrayBase_oaBuildInfo*)  new oaBuildInfoArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBuildInfoArray, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaBuildInfoArray)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBuildInfoArray_tp_dealloc(PyoaBuildInfoArrayObject* self)
{
    if (!self->borrow) {
        delete (oaBuildInfoArray*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBuildInfoArray_tp_repr(PyObject *ob)
{
    PyParamoaBuildInfoArray value;
    int convert_status=PyoaBuildInfoArray_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[38];
    sprintf(buffer,"<oaBuildInfoArray::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBuildInfoArray_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBuildInfoArray v1;
    PyParamoaBuildInfoArray v2;
    int convert_status1=PyoaBuildInfoArray_Convert(ob1,&v1);
    int convert_status2=PyoaBuildInfoArray_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBuildInfoArray_Convert(PyObject* ob,PyParamoaBuildInfoArray* result)
{
    if (ob == NULL) return 1;
    if (PyoaBuildInfoArray_Check(ob)) {
        result->SetData( (oaBuildInfoArray*) ((PyoaBuildInfoArrayObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBuildInfoArray Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBuildInfoArray_FromoaBuildInfoArray(oaBuildInfoArray* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaBuildInfoArray_Type.tp_alloc(&PyoaBuildInfoArray_Type,0);
        if (bself == NULL) return bself;
        PyoaBuildInfoArrayObject* self = (PyoaBuildInfoArrayObject*)bself;
        self->value = (oaArrayBase_oaBuildInfo*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBuildInfoArray_sort_doc[] = 
"Class: oaBuildInfoArray, Function: sort\n"
"  Paramegers: ()\n"
"    Calls: void sort()\n"
"    Signature: sort|void-void|\n"
"    BrowseData: 0\n"
"    This function sorts the oaBuildInfo pointers by their package names in this oaBuildInfoArray.\n"
;

static PyObject*
oaBuildInfoArray_sort(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBuildInfoArray data;
    int convert_status=PyoaBuildInfoArray_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBuildInfoArrayObject* self=(PyoaBuildInfoArrayObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->sort();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaBuildInfoArray_assign_doc[] = 
"Class: oaBuildInfoArray, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBuildInfoArray_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBuildInfoArray data;
  int convert_status=PyoaBuildInfoArray_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBuildInfoArray p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBuildInfoArray_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBuildInfoArray_methodlist[] = {
    {"sort",(PyCFunction)oaBuildInfoArray_sort,METH_VARARGS,oaBuildInfoArray_sort_doc},
    {"assign",(PyCFunction)oaBuildInfoArray_tp_assign,METH_VARARGS,oaBuildInfoArray_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBuildInfoArray_doc[] = 
"Class: oaBuildInfoArray\n"
"  The oaBuildInfoArray class implements a utility array class used to pass an array of oaBuildInfo pointers back to the user via oaBuildInfo::getPackages() .\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaBuildInfoArray()\n"
"    Signature: oaBuildInfoArray||simple-oaUInt4,\n"
"    This function constructs an oaBuildInfoArray object, allocating storage for sizeIn oaBuildInfo pointer elements.\n"
"    sizeIn\n"
"    number of values for which to allocate storage; the default number is 0.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaBuildInfoArray(oaUInt4 sizeIn)\n"
"    Signature: oaBuildInfoArray||simple-oaUInt4,\n"
"    This function constructs an oaBuildInfoArray object, allocating storage for sizeIn oaBuildInfo pointer elements.\n"
"    sizeIn\n"
"    number of values for which to allocate storage; the default number is 0.\n"
"  Paramegers: (oaBuildInfoArray)\n"
"    Calls: (const oaBuildInfoArray&)\n"
"    Signature: oaBuildInfoArray||cref-oaBuildInfoArray,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBuildInfoArray_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBuildInfoArray",
    sizeof(PyoaBuildInfoArrayObject),
    0,
    (destructor)oaBuildInfoArray_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBuildInfoArray_tp_compare,	/* tp_compare */
    (reprfunc)oaBuildInfoArray_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBuildInfoArray_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBuildInfoArray_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaArray_oaBuildInfo_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBuildInfoArray_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBuildInfoArray_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBuildInfoArray_Type)<0) {
      printf("** PyType_Ready failed for: oaBuildInfoArray\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBuildInfoArray",
           (PyObject*)(&PyoaBuildInfoArray_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBuildInfoArray\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBundleName
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBundleName_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBundleName_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBundleNameObject* self = (PyoaBundleNameObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaBundleName();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,[oaChar])
    {
        PyParamoaNameSpace p1;
        PyParamoaChar_Array p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaChar_Array_Convert,&p2)) {
            self->value =  new oaBundleName(p1.Data(),p2.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            self->value =  new oaBundleName(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaScalarName,oaUInt4)
    {
        PyParamoaScalarName p1;
        PyParamoaUInt4 p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaScalarName_Convert,&p1,
              &PyoaUInt4_Convert,&p2)) {
            self->value =  new oaBundleName(p1.Data(),p2.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaVectorName)
    {
        PyParamoaVectorName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorName_Convert,&p1)) {
            self->value =  new oaBundleName(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaVectorName,oaUInt4)
    {
        PyParamoaVectorName p1;
        PyParamoaUInt4 p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaVectorName_Convert,&p1,
              &PyoaUInt4_Convert,&p2)) {
            self->value =  new oaBundleName(p1.Data(),p2.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaVectorBitName)
    {
        PyParamoaVectorBitName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorBitName_Convert,&p1)) {
            self->value =  new oaBundleName(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaVectorBitName,oaUInt4)
    {
        PyParamoaVectorBitName p1;
        PyParamoaUInt4 p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaVectorBitName_Convert,&p1,
              &PyoaUInt4_Convert,&p2)) {
            self->value =  new oaBundleName(p1.Data(),p2.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName)
    {
        PyParamoaSimpleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSimpleName_Convert,&p1)) {
            self->value =  new oaBundleName(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName,oaUInt4)
    {
        PyParamoaSimpleName p1;
        PyParamoaUInt4 p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaSimpleName_Convert,&p1,
              &PyoaUInt4_Convert,&p2)) {
            self->value =  new oaBundleName(p1.Data(),p2.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaBundleName)
    {
        PyParamoaBundleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBundleName_Convert,&p1)) {
            self->value =  new oaBundleName(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBundleName, Choices are:\n"
        "    ()\n"
        "    (oaNameSpace,[oaChar])\n"
        "    (oaScalarName)\n"
        "    (oaScalarName,oaUInt4)\n"
        "    (oaVectorName)\n"
        "    (oaVectorName,oaUInt4)\n"
        "    (oaVectorBitName)\n"
        "    (oaVectorBitName,oaUInt4)\n"
        "    (oaSimpleName)\n"
        "    (oaSimpleName,oaUInt4)\n"
        "    (oaBundleName)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBundleName_tp_dealloc(PyoaBundleNameObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBundleName_tp_repr(PyObject *ob)
{
    PyParamoaBundleName value;
    int convert_status=PyoaBundleName_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    oaString sresult;
    value.DataCall()->get(sresult);

    char addr[34];
    sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
    oaString buffer;
    buffer+=oaString("<oaBundleName::");
    buffer+=oaString(addr);
    buffer+=oaString("::");
    buffer+=oaString(sresult);
    buffer+=oaString(">");
    result=PyString_FromString((char*)(const char*)buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBundleName_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBundleName v1;
    PyParamoaBundleName v2;
    int convert_status1=PyoaBundleName_Convert(ob1,&v1);
    int convert_status2=PyoaBundleName_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    if (v1.Data()==v2.Data()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBundleName_Convert(PyObject* ob,PyParamoaBundleName* result)
{
    if (ob == NULL) return 1;
    if (PyoaBundleName_Check(ob)) {
        result->SetData(  ((PyoaBundleNameObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBundleName Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBundleName_FromoaBundleName(oaBundleName* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaBundleName_Type.tp_alloc(&PyoaBundleName_Type,0);
        if (bself == NULL) return bself;
        PyoaBundleNameObject* self = (PyoaBundleNameObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBundleName_index_get_doc[] = 
"Class: oaBundleName, Function: index_get\n"
;

static PyObject*
oaBundleName_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaBundleNameObject* self=(PyoaBundleNameObject*)ob;
  try {
    PyParamoaBundleName data;
    int convert_status=PyoaBundleName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBundleNameObject* self=(PyoaBundleNameObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumMembers()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaSimpleName* result= new oaSimpleName(data.Data()[index]);
    return PyoaSimpleName_FromoaSimpleName(result,0,NULL);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaBundleName_index_get_length(PyObject* ob)
{
    PyParamoaBundleName data;
    int convert_status=PyoaBundleName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBundleNameObject* self=(PyoaBundleNameObject*)ob;

    return data.Data().getNumMembers();
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBundleName_addHierMem_doc[] = 
"Class: oaBundleName, Function: addHierMem\n"
"  Paramegers: (oaNameSpace,[oaChar],oaUInt4)\n"
"    Calls: void addHierMem(const oaNameSpace& nSpace,const oaChar* in,oaUInt4 len)\n"
"    Signature: addHierMem|void-void|cref-oaNameSpace,cptr-oaChar,simple-oaUInt4,\n"
"    This function adds the given string as a nameMem to the hierarchical portion of the name for each of the members of this bundle name. For each bundle member, the nameMem is inserted after the existing hierarchical nameMems and before the last nameMem, which represents the local name of the bundle member.\n"
"    The in string must not contain any hierarchy delimiters. Only len characters of in are considered. An exception is thrown if this name is empty.\n"
"    nSpace\n"
"    The nameSpace in which to evaluate the given string\n"
"    in\n"
"    The input string to add to the hierarchy of this name\n"
"    len\n"
"    The length of the specified input string\n"
"    oacInvalidName\n"
"  Paramegers: (oaNameMem)\n"
"    Calls: void addHierMem(const oaNameMem& in)\n"
"    Signature: addHierMem|void-void|cref-oaNameMem,\n"
"    This function adds a hierarchical nameMem to each of the bundle members of this name. For each bundle member, this function inserts a copy of in after the existing nameMems that represent the hierarchical path for the bundle member, and before the last nameMem, which represents the local name. An exception is thrown if this name is empty.\n"
"    in\n"
"    The member to be added\n"
"    oacInvalidName\n"
;

static PyObject*
oaBundleName_addHierMem(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBundleName data;
    int convert_status=PyoaBundleName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBundleNameObject* self=(PyoaBundleNameObject*)ob;

    // Case: (oaNameSpace,[oaChar],oaUInt4)
    {
        PyParamoaNameSpace p1;
        PyParamoaChar_Array p2;
        PyParamoaUInt4 p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaChar_Array_Convert,&p2,
              &PyoaUInt4_Convert,&p3)) {
            data.DataCall()->addHierMem(p1.Data(),p2.Data(),p3.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameMem)
    {
        PyParamoaNameMem p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaNameMem_Convert,&p1)) {
            data.DataCall()->addHierMem(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBundleName, function: addHierMem, Choices are:\n"
        "    (oaNameSpace,[oaChar],oaUInt4)\n"
        "    (oaNameMem)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleName_addHierPath_doc[] = 
"Class: oaBundleName, Function: addHierPath\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void addHierPath(const oaScalarName& path)\n"
"    Signature: addHierPath|void-void|cref-oaScalarName,\n"
"    This function prepends a hierarchical path to each of the bundle members of this name. An exception is thrown if this name is empty.\n"
"    path\n"
"    The path to add\n"
"    oacInvalidName\n"
"  Paramegers: (oaVectorBitName)\n"
"    Calls: void addHierPath(const oaVectorBitName& path)\n"
"    Signature: addHierPath|void-void|cref-oaVectorBitName,\n"
"    This function prepends a hierarchical path to each of the bundle members of this name. An exception is thrown if this name is empty.\n"
"    path\n"
"    The path to add\n"
"    oacInvalidName\n"
;

static PyObject*
oaBundleName_addHierPath(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBundleName data;
    int convert_status=PyoaBundleName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBundleNameObject* self=(PyoaBundleNameObject*)ob;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->addHierPath(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaVectorBitName)
    {
        PyParamoaVectorBitName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorBitName_Convert,&p1)) {
            data.DataCall()->addHierPath(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBundleName, function: addHierPath, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaVectorBitName)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleName_append_doc[] = 
"Class: oaBundleName, Function: append\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void append(const oaScalarName& name)\n"
"    Signature: append|void-void|cref-oaScalarName,simple-oaUInt4,\n"
"    This function appends the specified oaScalarName object to this oaBundleName object. The optional repeat argument indicates the initial repeat value for the input member. The default value for the repeat argument is one.\n"
"    If you plan to append to a bundle name object using a member of the same bundle name object, you must first check the size of the bundle name and resize the bundle name if necessary, before calling append() . For example, you may want to call append with bundle.append(bundle[0], 2); This is very dangerous if the bundle name object is not big enough to fit the additional member. In that case, the bundle name is resized and the memory of the bundle name members will likely be changed, and the input bundle[0] will not refer to the correct data.\n"
"    name\n"
"    The oaScalarName to append\n"
"    repeat\n"
"    The repeat value for the member specified\n"
"  Paramegers: (oaScalarName,oaUInt4)\n"
"    Calls: void append(const oaScalarName& name,oaUInt4 repeat)\n"
"    Signature: append|void-void|cref-oaScalarName,simple-oaUInt4,\n"
"    This function appends the specified oaScalarName object to this oaBundleName object. The optional repeat argument indicates the initial repeat value for the input member. The default value for the repeat argument is one.\n"
"    If you plan to append to a bundle name object using a member of the same bundle name object, you must first check the size of the bundle name and resize the bundle name if necessary, before calling append() . For example, you may want to call append with bundle.append(bundle[0], 2); This is very dangerous if the bundle name object is not big enough to fit the additional member. In that case, the bundle name is resized and the memory of the bundle name members will likely be changed, and the input bundle[0] will not refer to the correct data.\n"
"    name\n"
"    The oaScalarName to append\n"
"    repeat\n"
"    The repeat value for the member specified\n"
"  Paramegers: (oaVectorName)\n"
"    Calls: void append(const oaVectorName& name)\n"
"    Signature: append|void-void|cref-oaVectorName,simple-oaUInt4,\n"
"    This function appends the specified oaVectorName object to this oaBundleName object. The optional repeat argument indicates the initial repeat value for the input member. The default value for the repeat argument is one.\n"
"    If the current size of the bundle name object is not large enough to fit the additional member, this function will resize the bundle name object as needed.\n"
"    If you plan to append to a bundle name object using a member of the same bundle name object, you must first check to make sure that the size of the bundle name is large enough to fit the additional member. If not, you must resize the bundle name before calling append() . Otherwise, the result of append() may be incorrect. For example, you may want to call append with bundle.append(bundle[0], 2); This is very dangerous if the bundle name object is not big enough to fit the additional member. In that case, the bundle name is resized and the memory of the bundle name members will likely be changed, and the input bundle[0] will not refer to the correct data.\n"
"    name\n"
"    The oaVectorName to append\n"
"    repeat\n"
"    The repeat value for the member specified\n"
"  Paramegers: (oaVectorName,oaUInt4)\n"
"    Calls: void append(const oaVectorName& name,oaUInt4 repeat)\n"
"    Signature: append|void-void|cref-oaVectorName,simple-oaUInt4,\n"
"    This function appends the specified oaVectorName object to this oaBundleName object. The optional repeat argument indicates the initial repeat value for the input member. The default value for the repeat argument is one.\n"
"    If the current size of the bundle name object is not large enough to fit the additional member, this function will resize the bundle name object as needed.\n"
"    If you plan to append to a bundle name object using a member of the same bundle name object, you must first check to make sure that the size of the bundle name is large enough to fit the additional member. If not, you must resize the bundle name before calling append() . Otherwise, the result of append() may be incorrect. For example, you may want to call append with bundle.append(bundle[0], 2); This is very dangerous if the bundle name object is not big enough to fit the additional member. In that case, the bundle name is resized and the memory of the bundle name members will likely be changed, and the input bundle[0] will not refer to the correct data.\n"
"    name\n"
"    The oaVectorName to append\n"
"    repeat\n"
"    The repeat value for the member specified\n"
"  Paramegers: (oaVectorBitName)\n"
"    Calls: void append(const oaVectorBitName& name)\n"
"    Signature: append|void-void|cref-oaVectorBitName,simple-oaUInt4,\n"
"    This function appends the specified oaVectorBitName object to this oaBundleName object. The optional repeat argument indicates the initial repeat value for the input member. The default value for the repeat argument is one.\n"
"    If the current size of the bundle name object is not large enough to fit the additional member, this function will resize the bundle name object as needed.\n"
"    If you plan to append to a bundle name object using a member of the same bundle name object, you must first check to make sure that the size of the bundle name is large enough to fit the additional member. If not, you must resize the bundle name before calling append() . Otherwise, the result of append() may be incorrect. For example, you may want to call append with bundle.append(bundle[0], 2); This is very dangerous if the bundle name object is not big enough to fit the additional member. In that case, the bundle name is resized and the memory of the bundle name members will likely be changed, and the input bundle[0] will not refer to the correct data.\n"
"    name\n"
"    The oaVectorBitName to append\n"
"    repeat\n"
"    The repeat value for the member specified\n"
"  Paramegers: (oaVectorBitName,oaUInt4)\n"
"    Calls: void append(const oaVectorBitName& name,oaUInt4 repeat)\n"
"    Signature: append|void-void|cref-oaVectorBitName,simple-oaUInt4,\n"
"    This function appends the specified oaVectorBitName object to this oaBundleName object. The optional repeat argument indicates the initial repeat value for the input member. The default value for the repeat argument is one.\n"
"    If the current size of the bundle name object is not large enough to fit the additional member, this function will resize the bundle name object as needed.\n"
"    If you plan to append to a bundle name object using a member of the same bundle name object, you must first check to make sure that the size of the bundle name is large enough to fit the additional member. If not, you must resize the bundle name before calling append() . Otherwise, the result of append() may be incorrect. For example, you may want to call append with bundle.append(bundle[0], 2); This is very dangerous if the bundle name object is not big enough to fit the additional member. In that case, the bundle name is resized and the memory of the bundle name members will likely be changed, and the input bundle[0] will not refer to the correct data.\n"
"    name\n"
"    The oaVectorBitName to append\n"
"    repeat\n"
"    The repeat value for the member specified\n"
"  Paramegers: (oaSimpleName)\n"
"    Calls: void append(const oaSimpleName& name)\n"
"    Signature: append|void-void|cref-oaSimpleName,simple-oaUInt4,\n"
"    This function appends the specified oaSimpleName object to this oaBundleName object. The optional repeat argument indicates the initial repeat value for the input member. The default value for the repeat argument is one.\n"
"    If the current size of the bundle name object is not large enough to fit the additional member, this function will resize the bundle name object as needed.\n"
"    If you plan to append to a bundle name object using a member of the same bundle name object, you must first check to make sure that the size of the bundle name is large enough to fit the additional member. If not, you must resize the bundle name before calling append() . Otherwise, the result of append() may be incorrect. For example, you may want to call append with bundle.append(bundle[0], 2); This is very dangerous if the bundle name object is not big enough to fit the additional member. In that case, the bundle name is resized and the memory of the bundle name members will likely be changed, and the input bundle[0] will not refer to the correct data.\n"
"    name\n"
"    The oaSimpleName to append\n"
"    repeat\n"
"    The repeat value for the member specified\n"
"  Paramegers: (oaSimpleName,oaUInt4)\n"
"    Calls: void append(const oaSimpleName& name,oaUInt4 repeat)\n"
"    Signature: append|void-void|cref-oaSimpleName,simple-oaUInt4,\n"
"    This function appends the specified oaSimpleName object to this oaBundleName object. The optional repeat argument indicates the initial repeat value for the input member. The default value for the repeat argument is one.\n"
"    If the current size of the bundle name object is not large enough to fit the additional member, this function will resize the bundle name object as needed.\n"
"    If you plan to append to a bundle name object using a member of the same bundle name object, you must first check to make sure that the size of the bundle name is large enough to fit the additional member. If not, you must resize the bundle name before calling append() . Otherwise, the result of append() may be incorrect. For example, you may want to call append with bundle.append(bundle[0], 2); This is very dangerous if the bundle name object is not big enough to fit the additional member. In that case, the bundle name is resized and the memory of the bundle name members will likely be changed, and the input bundle[0] will not refer to the correct data.\n"
"    name\n"
"    The oaSimpleName to append\n"
"    repeat\n"
"    The repeat value for the member specified\n"
;

static PyObject*
oaBundleName_append(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBundleName data;
    int convert_status=PyoaBundleName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBundleNameObject* self=(PyoaBundleNameObject*)ob;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->append(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaScalarName,oaUInt4)
    {
        PyParamoaScalarName p1;
        PyParamoaUInt4 p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaScalarName_Convert,&p1,
              &PyoaUInt4_Convert,&p2)) {
            data.DataCall()->append(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaVectorName)
    {
        PyParamoaVectorName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorName_Convert,&p1)) {
            data.DataCall()->append(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaVectorName,oaUInt4)
    {
        PyParamoaVectorName p1;
        PyParamoaUInt4 p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaVectorName_Convert,&p1,
              &PyoaUInt4_Convert,&p2)) {
            data.DataCall()->append(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaVectorBitName)
    {
        PyParamoaVectorBitName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorBitName_Convert,&p1)) {
            data.DataCall()->append(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaVectorBitName,oaUInt4)
    {
        PyParamoaVectorBitName p1;
        PyParamoaUInt4 p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaVectorBitName_Convert,&p1,
              &PyoaUInt4_Convert,&p2)) {
            data.DataCall()->append(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName)
    {
        PyParamoaSimpleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSimpleName_Convert,&p1)) {
            data.DataCall()->append(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName,oaUInt4)
    {
        PyParamoaSimpleName p1;
        PyParamoaUInt4 p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaSimpleName_Convert,&p1,
              &PyoaUInt4_Convert,&p2)) {
            data.DataCall()->append(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBundleName, function: append, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaScalarName,oaUInt4)\n"
        "    (oaVectorName)\n"
        "    (oaVectorName,oaUInt4)\n"
        "    (oaVectorBitName)\n"
        "    (oaVectorBitName,oaUInt4)\n"
        "    (oaSimpleName)\n"
        "    (oaSimpleName,oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleName_get_doc[] = 
"Class: oaBundleName, Function: get\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void get(const oaNameSpace& nSpace,oaString& out) const\n"
"    Signature: get|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns this name mapped into the specified name space.\n"
"    An oacBundleNameInvalid exception is thrown if the specified nameSpace does not support bundleNames. For information on the names supported in each nameSpace, see Details of OpenAccess Name Spaces .\n"
"    nSpace\n"
"    The name space to which to map this name\n"
"    out\n"
"    The string in which to output the mapped name\n"
"    oacBundleNameInvalid\n"
"  Paramegers: (oaString)\n"
"    Calls: void get(oaString& out) const\n"
"    Signature: get|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function returns this name mapped into the oaNative name space.\n"
"    out\n"
"    The string in which to output the mapped name\n"
;

static PyObject*
oaBundleName_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBundleName data;
    int convert_status=PyoaBundleName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBundleNameObject* self=(PyoaBundleNameObject*)ob;

    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->get(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            data.DataCall()->get(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBundleName, function: get, Choices are:\n"
        "    (oaNameSpace,oaString)\n"
        "    (oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleName_getBitName_doc[] = 
"Class: oaBundleName, Function: getBitName\n"
"  Paramegers: (oaNameSpace,oaUInt4,oaString)\n"
"    Calls: void getBitName(const oaNameSpace& nSpace,oaUInt4 bit,oaString& out) const\n"
"    Signature: getBitName|void-void|cref-oaNameSpace,simple-oaUInt4,ref-oaString,\n"
"    This function returns the bit name of this oaBundleName, mapped into the specified oaNameSpace .\n"
"    nSpace\n"
"    The name space to which to map this name\n"
"    bit\n"
"    The bit name to map to the string out\n"
"    out\n"
"    The string in which to output the mapped name\n"
"    oacBitNotInRangeForName\n"
;

static PyObject*
oaBundleName_getBitName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBundleName data;
    int convert_status=PyoaBundleName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBundleNameObject* self=(PyoaBundleNameObject*)ob;

    PyParamoaNameSpace p1;
    PyParamoaUInt4 p2;
    PyParamoaString p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaNameSpace_Convert,&p1,
          &PyoaUInt4_Convert,&p2,
          &PyoaString_Convert,&p3)) {
        data.DataCall()->getBitName(p1.Data(),p2.Data(),p3.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleName_getNumBits_doc[] = 
"Class: oaBundleName, Function: getNumBits\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumBits() const\n"
"    Signature: getNumBits|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of bits this name represents.\n"
"    Example: Assume an oaBundlename constructed with the oaNativeNS string \"2*U,V[2],V[4:5]\". oaBundleName::getNumBits will return 5.\n"
;

static PyObject*
oaBundleName_getNumBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBundleName data;
    int convert_status=PyoaBundleName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBundleNameObject* self=(PyoaBundleNameObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumBits());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleName_getNumMembers_doc[] = 
"Class: oaBundleName, Function: getNumMembers\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumMembers() const\n"
"    Signature: getNumMembers|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of bundle members in this oaBundleName object.\n"
"    Example: Assume an oaBundlename constructed with the oaCdbaNS string \"a,2*b,c<5:0>\". oaBundleName::getNumMembers will return 3.\n"
;

static PyObject*
oaBundleName_getNumMembers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBundleName data;
    int convert_status=PyoaBundleName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBundleNameObject* self=(PyoaBundleNameObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumMembers());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleName_getSize_doc[] = 
"Class: oaBundleName, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size of this oaBundleName object, which indicates the number of oaSimpleName objects.\n"
;

static PyObject*
oaBundleName_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBundleName data;
    int convert_status=PyoaBundleName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBundleNameObject* self=(PyoaBundleNameObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleName_init_doc[] = 
"Class: oaBundleName, Function: init\n"
"  Paramegers: (oaNameSpace,[oaChar])\n"
"    Calls: void init(const oaNameSpace& nSpace,const oaChar* in)\n"
"    Signature: init|void-void|cref-oaNameSpace,cptr-oaChar,\n"
"    This function clears old name data, then initializes its value to the string in , evaluated in the specified name space.\n"
"    nSpace\n"
"    The name space in which to evaluate the string\n"
"    in\n"
"    The input string to evaluate\n"
"    oacInvalidNameLength\n"
;

static PyObject*
oaBundleName_init(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBundleName data;
    int convert_status=PyoaBundleName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBundleNameObject* self=(PyoaBundleNameObject*)ob;

    PyParamoaNameSpace p1;
    PyParamoaChar_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaNameSpace_Convert,&p1,
          &PyoaChar_Array_Convert,&p2)) {
        data.DataCall()->init(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleName_isEmpty_doc[] = 
"Class: oaBundleName, Function: isEmpty\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isEmpty() const\n"
"    Signature: isEmpty|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns an boolean value that indicates if this oaBundleName object contains any bundle members.\n"
;

static PyObject*
oaBundleName_isEmpty(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBundleName data;
    int convert_status=PyoaBundleName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBundleNameObject* self=(PyoaBundleNameObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isEmpty());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleName_resize_doc[] = 
"Class: oaBundleName, Function: resize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void resize(oaUInt4 newSize)\n"
"    Signature: resize|void-void|simple-oaUInt4,\n"
"    This function resizes the size of the storage in this bundle to newSize , which is the number of oaSimpleName objects.\n"
;

static PyObject*
oaBundleName_resize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBundleName data;
    int convert_status=PyoaBundleName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBundleNameObject* self=(PyoaBundleNameObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->resize(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaBundleName_assign_doc[] = 
"Class: oaBundleName, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBundleName_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBundleName data;
  int convert_status=PyoaBundleName_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBundleName p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBundleName_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBundleName_methodlist[] = {
    {"addHierMem",(PyCFunction)oaBundleName_addHierMem,METH_VARARGS,oaBundleName_addHierMem_doc},
    {"addHierPath",(PyCFunction)oaBundleName_addHierPath,METH_VARARGS,oaBundleName_addHierPath_doc},
    {"append",(PyCFunction)oaBundleName_append,METH_VARARGS,oaBundleName_append_doc},
    {"get",(PyCFunction)oaBundleName_get,METH_VARARGS,oaBundleName_get_doc},
    {"getBitName",(PyCFunction)oaBundleName_getBitName,METH_VARARGS,oaBundleName_getBitName_doc},
    {"getNumBits",(PyCFunction)oaBundleName_getNumBits,METH_VARARGS,oaBundleName_getNumBits_doc},
    {"getNumMembers",(PyCFunction)oaBundleName_getNumMembers,METH_VARARGS,oaBundleName_getNumMembers_doc},
    {"getSize",(PyCFunction)oaBundleName_getSize,METH_VARARGS,oaBundleName_getSize_doc},
    {"init",(PyCFunction)oaBundleName_init,METH_VARARGS,oaBundleName_init_doc},
    {"isEmpty",(PyCFunction)oaBundleName_isEmpty,METH_VARARGS,oaBundleName_isEmpty_doc},
    {"resize",(PyCFunction)oaBundleName_resize,METH_VARARGS,oaBundleName_resize_doc},
    {"assign",(PyCFunction)oaBundleName_tp_assign,METH_VARARGS,oaBundleName_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaBundleName_as_sequence = {
    (Pyoa_inquiry)oaBundleName_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaBundleName_index_get,	/* sq_item */
};
// ------------------------------------------------------------------
static char oaBundleName_doc[] = 
"Class: oaBundleName\n"
"  The oaBundleName utility class represents a name that consists of a list of potentially repeated oaSimpleName objects. In conjunction with the oaNameSpace objects, this class facilitates mapping names from one name space to another. See the Name Mapping section in the Programmers Guide for more information about mapping names between different namespaces.\n"
"  Only oaNets and oaTerminals can have bundle names. Only the CDBA and Native namespaces have a syntax for representing bundle names.\n"
"  A repeat operator used in a bundle name indicates the number of times to repeat the following name. An example of a bundled name in the CDBA name space is: <*2>A,B<1:0>,C which expands to A,A,B<1>,B<0>,C\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaBundleName()\n"
"    Signature: oaBundleName||\n"
"    This function constructs an empty oaBundleName object.\n"
"  Paramegers: (oaNameSpace,[oaChar])\n"
"    Calls: oaBundleName(const oaNameSpace& nSpace,const oaChar* in)\n"
"    Signature: oaBundleName||cref-oaNameSpace,cptr-oaChar,\n"
"    This function constructs an oaBundleName object, evaluating the specified input string in the specified name space.\n"
"    oacInvalidNameLength\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: oaBundleName(const oaScalarName& in)\n"
"    Signature: oaBundleName||cref-oaScalarName,simple-oaUInt4,\n"
"    This function constructs an oaBundleName object that contains the specified oaScalarName as the first bundle member. The optional repeat argument indicates the initial repeat value for the input member. The default value for the repeat argument is one.\n"
"    in\n"
"    The oaScalarName to initialize as the first bundle member\n"
"    repeat\n"
"    The repeat value for the member specified\n"
"  Paramegers: (oaScalarName,oaUInt4)\n"
"    Calls: oaBundleName(const oaScalarName& in,oaUInt4 repeat)\n"
"    Signature: oaBundleName||cref-oaScalarName,simple-oaUInt4,\n"
"    This function constructs an oaBundleName object that contains the specified oaScalarName as the first bundle member. The optional repeat argument indicates the initial repeat value for the input member. The default value for the repeat argument is one.\n"
"    in\n"
"    The oaScalarName to initialize as the first bundle member\n"
"    repeat\n"
"    The repeat value for the member specified\n"
"  Paramegers: (oaVectorName)\n"
"    Calls: oaBundleName(const oaVectorName& in)\n"
"    Signature: oaBundleName||cref-oaVectorName,simple-oaUInt4,\n"
"    This function constructs an oaBundleName object that contains the specified oaVectorName as the first bundle member. The optional repeat argument indicates the initial repeat value for the input member. The default value for the repeat argument is one.\n"
"    in\n"
"    The oaVectorName to initialize as the first bundle member\n"
"    repeat\n"
"    The repeat value for the member specified\n"
"  Paramegers: (oaVectorName,oaUInt4)\n"
"    Calls: oaBundleName(const oaVectorName& in,oaUInt4 repeat)\n"
"    Signature: oaBundleName||cref-oaVectorName,simple-oaUInt4,\n"
"    This function constructs an oaBundleName object that contains the specified oaVectorName as the first bundle member. The optional repeat argument indicates the initial repeat value for the input member. The default value for the repeat argument is one.\n"
"    in\n"
"    The oaVectorName to initialize as the first bundle member\n"
"    repeat\n"
"    The repeat value for the member specified\n"
"  Paramegers: (oaVectorBitName)\n"
"    Calls: oaBundleName(const oaVectorBitName& in)\n"
"    Signature: oaBundleName||cref-oaVectorBitName,simple-oaUInt4,\n"
"    This function constructs an oaBundleName object that contains the specified oaVectorBitName as the first bundle member. The optional repeat argument indicates the initial repeat value for the input member. The default value for the repeat argument is one.\n"
"    in\n"
"    The oaVectorBitName to initialize as the first bundle member\n"
"    repeat\n"
"    The repeat value for the member specified\n"
"  Paramegers: (oaVectorBitName,oaUInt4)\n"
"    Calls: oaBundleName(const oaVectorBitName& in,oaUInt4 repeat)\n"
"    Signature: oaBundleName||cref-oaVectorBitName,simple-oaUInt4,\n"
"    This function constructs an oaBundleName object that contains the specified oaVectorBitName as the first bundle member. The optional repeat argument indicates the initial repeat value for the input member. The default value for the repeat argument is one.\n"
"    in\n"
"    The oaVectorBitName to initialize as the first bundle member\n"
"    repeat\n"
"    The repeat value for the member specified\n"
"  Paramegers: (oaSimpleName)\n"
"    Calls: oaBundleName(const oaSimpleName& in)\n"
"    Signature: oaBundleName||cref-oaSimpleName,simple-oaUInt4,\n"
"    This function constructs an oaBundleName object that contains the specified oaSimpleName as the first bundle member. The optional repeat argument indicates the initial repeat value for the input member. The default value for the repeat argument is one.\n"
"    in\n"
"    The oaSimpleName to initialize as the first bundle member\n"
"    repeat\n"
"    The repeat value for the member specified\n"
"  Paramegers: (oaSimpleName,oaUInt4)\n"
"    Calls: oaBundleName(const oaSimpleName& in,oaUInt4 repeat)\n"
"    Signature: oaBundleName||cref-oaSimpleName,simple-oaUInt4,\n"
"    This function constructs an oaBundleName object that contains the specified oaSimpleName as the first bundle member. The optional repeat argument indicates the initial repeat value for the input member. The default value for the repeat argument is one.\n"
"    in\n"
"    The oaSimpleName to initialize as the first bundle member\n"
"    repeat\n"
"    The repeat value for the member specified\n"
"  Paramegers: (oaBundleName)\n"
"    Calls: oaBundleName(const oaBundleName& in)\n"
"    Signature: oaBundleName||cref-oaBundleName,\n"
"    This function creates a copy of the specified oaBundleName object.\n"
"  Paramegers: (oaBundleName)\n"
"    Calls: (const oaBundleName&)\n"
"    Signature: oaBundleName||cref-oaBundleName,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBundleName_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBundleName",
    sizeof(PyoaBundleNameObject),
    0,
    (destructor)oaBundleName_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBundleName_tp_compare,	/* tp_compare */
    (reprfunc)oaBundleName_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaBundleName_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBundleName_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBundleName_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBundleName_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBundleName_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBundleName_Type)<0) {
      printf("** PyType_Ready failed for: oaBundleName\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBundleName",
           (PyObject*)(&PyoaBundleName_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBundleName\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBundleNet
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBundleNet_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBundleNet_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBundleNetObject* self = (PyoaBundleNetObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBundleNet)
    {
        PyParamoaBundleNet p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBundleNet_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBundleNet, Choices are:\n"
        "    (oaBundleNet)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBundleNet_tp_dealloc(PyoaBundleNetObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBundleNet_tp_repr(PyObject *ob)
{
    PyParamoaBundleNet value;
    int convert_status=PyoaBundleNet_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaBundleNet::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[33];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaBundleNet::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBundleNet_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBundleNet v1;
    PyParamoaBundleNet v2;
    int convert_status1=PyoaBundleNet_Convert(ob1,&v1);
    int convert_status2=PyoaBundleNet_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBundleNet_Convert(PyObject* ob,PyParamoaBundleNet* result)
{
    if (ob == NULL) return 1;
    if (PyoaBundleNet_Check(ob)) {
        result->SetData( (oaBundleNet**) ((PyoaBundleNetObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBundleNet Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBundleNet_FromoaBundleNet(oaBundleNet** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBundleNet* data=*value;
        PyObject* bself = PyoaBundleNet_Type.tp_alloc(&PyoaBundleNet_Type,0);
        if (bself == NULL) return bself;
        PyoaBundleNetObject* self = (PyoaBundleNetObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBundleNet_FromoaBundleNet(oaBundleNet* data)
{
    if (data) {
       PyObject* bself = PyoaBundleNet_Type.tp_alloc(&PyoaBundleNet_Type,0);
       if (bself == NULL) return bself;
       PyoaBundleNetObject* self = (PyoaBundleNetObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBundleNet_getMember_doc[] = 
"Class: oaBundleNet, Function: getMember\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaNet* getMember(oaUInt4 index) const\n"
"    Signature: getMember|ptr-oaNet|simple-oaUInt4,\n"
"    This function returns the specified member of this net at the specified bundle member index.\n"
"    memIndex\n"
"    The bundle member index of the net to be returned.\n"
"    A pointer to an oaNet\n"
"    oacInvalidBundleNetMemberIndex\n"
;

static PyObject*
oaBundleNet_getMember(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBundleNet data;
    int convert_status=PyoaBundleNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBundleNetObject* self=(PyoaBundleNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaNetp result= (data.DataCall()->getMember(p1.Data()));
        return PyoaNet_FromoaNet(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleNet_getMembers_doc[] = 
"Class: oaBundleNet, Function: getMembers\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaNet_oaBundleNet getMembers() const\n"
"    Signature: getMembers|simple-oaCollection_oaNet_oaBundleNet|\n"
"    BrowseData: 1\n"
"    This function returns a collection of the member nets in this oaBundleNet.\n"
;

static PyObject*
oaBundleNet_getMembers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBundleNet data;
    int convert_status=PyoaBundleNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBundleNetObject* self=(PyoaBundleNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaNet_oaBundleNet* result= new oaCollection_oaNet_oaBundleNet(data.DataCall()->getMembers());
        return PyoaCollection_oaNet_oaBundleNet_FromoaCollection_oaNet_oaBundleNet(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleNet_getMembersIter_doc[] = 
"Class: oaBundleNet, Function: getMembersIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaNet getMembersIter() const\n"
"    Signature: getMembersIter|simple-oaIter_oaNet|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of the member nets in this oaBundleNet.\n"
;

static PyObject*
oaBundleNet_getMembersIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBundleNet data;
    int convert_status=PyoaBundleNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBundleNetObject* self=(PyoaBundleNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaNet* result= new oaIter_oaNet(data.DataCall()->getMembers());
        return PyoaIter_oaNet_FromoaIter_oaNet(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleNet_getName_doc[] = 
"Class: oaBundleNet, Function: getName\n"
"  Paramegers: (oaBundleName)\n"
"    Calls: void getName(oaBundleName& name) const\n"
"    Signature: getName|void-void|ref-oaBundleName,\n"
"    BrowseData: 0,oaBundleName\n"
"    This function returns the name of this oaBundleNet\n"
"    name\n"
"    The name of the oaBundleNet to returned\n"
"  Paramegers: (oaName)\n"
"    Calls: void getName(oaName& name) const\n"
"    Signature: getName|void-void|ref-oaName,\n"
"    BrowseData: 0,oaName\n"
"    This function returns the name of this net in the name argument.\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the name of this net in the specified nameSpace in the specified name string.\n"
;

static PyObject*
oaBundleNet_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBundleNet data;
    int convert_status=PyoaBundleNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBundleNetObject* self=(PyoaBundleNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaBundleName)
    {
        PyParamoaBundleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBundleName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaName)
    {
        PyParamoaName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBundleNet, function: getName, Choices are:\n"
        "    (oaBundleName)\n"
        "    (oaName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleNet_getNumMembers_doc[] = 
"Class: oaBundleNet, Function: getNumMembers\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumMembers() const\n"
"    Signature: getNumMembers|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of members in this oaBundleNet. Each member net in an oaBundleNet can repeat.\n"
"    Example: Assume an oaBundleNet with a oaCdbaNS bundleName of \"a,2*b,c<5:0>\". oaBundleNet::getNumMembers will return 3.\n"
;

static PyObject*
oaBundleNet_getNumMembers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBundleNet data;
    int convert_status=PyoaBundleNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBundleNetObject* self=(PyoaBundleNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumMembers());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleNet_getRepeat_doc[] = 
"Class: oaBundleNet, Function: getRepeat\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaUInt4 getRepeat(oaUInt4 index) const\n"
"    Signature: getRepeat|simple-oaUInt4|simple-oaUInt4,\n"
"    This function returns the repeat count for the specified member of this oaBundleNet.\n"
"    For example, for oaBundleNet a,b,c , the repeat count for each member is one. An oaBundleNet x,100*y[0:1] contains two members, and the repeat count for the second member is 100. The number of bits for the net is 201.\n"
"    memIndex\n"
"    The member number for which to return the repeat count\n"
"    An unsigned value indicating the repeat count for the specified member of the oaBundleNet\n"
"    oacInvalidBundleNetMemberIndex\n"
;

static PyObject*
oaBundleNet_getRepeat(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBundleNet data;
    int convert_status=PyoaBundleNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBundleNetObject* self=(PyoaBundleNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaUInt4 result= (data.DataCall()->getRepeat(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleNet_isNull_doc[] =
"Class: oaBundleNet, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBundleNet_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBundleNet data;
    int convert_status=PyoaBundleNet_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBundleNet_assign_doc[] = 
"Class: oaBundleNet, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBundleNet_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBundleNet data;
  int convert_status=PyoaBundleNet_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBundleNet p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBundleNet_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBundleNet_methodlist[] = {
    {"getMember",(PyCFunction)oaBundleNet_getMember,METH_VARARGS,oaBundleNet_getMember_doc},
    {"getMembers",(PyCFunction)oaBundleNet_getMembers,METH_VARARGS,oaBundleNet_getMembers_doc},
    {"getMembersIter",(PyCFunction)oaBundleNet_getMembersIter,METH_VARARGS,oaBundleNet_getMembersIter_doc},
    {"getName",(PyCFunction)oaBundleNet_getName,METH_VARARGS,oaBundleNet_getName_doc},
    {"getNumMembers",(PyCFunction)oaBundleNet_getNumMembers,METH_VARARGS,oaBundleNet_getNumMembers_doc},
    {"getRepeat",(PyCFunction)oaBundleNet_getRepeat,METH_VARARGS,oaBundleNet_getRepeat_doc},
    {"isNull",(PyCFunction)oaBundleNet_tp_isNull,METH_VARARGS,oaBundleNet_isNull_doc},
    {"assign",(PyCFunction)oaBundleNet_tp_assign,METH_VARARGS,oaBundleNet_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBundleNet_doc[] = 
"Class: oaBundleNet\n"
"  This class implements a multi-bit net composed of one or more scalar nets, bus nets, or a combination of both. When an oaBundleNet is created, all member nets specified as part of the bundle name expression are added to it. The constituent scalar nets and bus nets are automatically created as implicit nets if they do not already exist. Refer to oaNet documentation for a general description of implicit nets.\n"
"  An oaBundleNet object can be viewed as a collection of single bit net members and represents a collection of logical connections. The index and ordering of each member of a bundle net is indicated by the bundle name representation (refer to oaBundleName documentation for general description).\n"
"  For example, a bundle net with the name of '2*A,2*B[5],2*C[1:0]' in the oaNative namespace consists of 8 single bit members: A A B[5] B[5] C[1] C[0] C[1] and C[0]. The single bit net 'C[1]' is the 5th member of that bundle net, it is also the 7th member because the busName representation 'C[1:0]' is set to have a repeat value of 2.\n"
"Constructors:\n"
"  Paramegers: (oaBundleNet)\n"
"    Calls: (const oaBundleNet&)\n"
"    Signature: oaBundleNet||cref-oaBundleNet,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBundleNet_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBundleNet",
    sizeof(PyoaBundleNetObject),
    0,
    (destructor)oaBundleNet_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBundleNet_tp_compare,	/* tp_compare */
    (reprfunc)oaBundleNet_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBundleNet_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBundleNet_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaNet_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBundleNet_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBundleNet_static_create_doc[] = 
"Class: oaBundleNet, Function: create\n"
"  Paramegers: (oaBlock,oaBundleName)\n"
"    Calls: oaBundleNet* create(oaBlock* block,const oaBundleName& name)\n"
"    Signature: create|ptr-oaBundleNet|ptr-oaBlock,cref-oaBundleName,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates an oaBundleNet object in the specified block with the specified attributes. The name specifies the members of the oaBundleNet object and these member nets are automatically created if they do not already exist in the specified block. An exception is thrown if an oaBundleNet object with the given name already exists.\n"
"    block\n"
"    The block in which to create the oaBundleNet\n"
"    name\n"
"    The name of this oaBundleNet. The members of the BundleNet are derived from the name.\n"
"    sigType\n"
"    The signal type to associate with this net\n"
"    isGlobal\n"
"    Specifies if this is a global net\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaBundleNet\n"
"    oacNetExists\n"
"  Paramegers: (oaBlock,oaBundleName,oaSigType)\n"
"    Calls: oaBundleNet* create(oaBlock* block,const oaBundleName& name,oaSigType sigType)\n"
"    Signature: create|ptr-oaBundleNet|ptr-oaBlock,cref-oaBundleName,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates an oaBundleNet object in the specified block with the specified attributes. The name specifies the members of the oaBundleNet object and these member nets are automatically created if they do not already exist in the specified block. An exception is thrown if an oaBundleNet object with the given name already exists.\n"
"    block\n"
"    The block in which to create the oaBundleNet\n"
"    name\n"
"    The name of this oaBundleNet. The members of the BundleNet are derived from the name.\n"
"    sigType\n"
"    The signal type to associate with this net\n"
"    isGlobal\n"
"    Specifies if this is a global net\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaBundleNet\n"
"    oacNetExists\n"
"  Paramegers: (oaBlock,oaBundleName,oaSigType,oaBoolean)\n"
"    Calls: oaBundleNet* create(oaBlock* block,const oaBundleName& name,oaSigType sigType,oaBoolean isGlobal)\n"
"    Signature: create|ptr-oaBundleNet|ptr-oaBlock,cref-oaBundleName,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates an oaBundleNet object in the specified block with the specified attributes. The name specifies the members of the oaBundleNet object and these member nets are automatically created if they do not already exist in the specified block. An exception is thrown if an oaBundleNet object with the given name already exists.\n"
"    block\n"
"    The block in which to create the oaBundleNet\n"
"    name\n"
"    The name of this oaBundleNet. The members of the BundleNet are derived from the name.\n"
"    sigType\n"
"    The signal type to associate with this net\n"
"    isGlobal\n"
"    Specifies if this is a global net\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaBundleNet\n"
"    oacNetExists\n"
"  Paramegers: (oaBlock,oaBundleName,oaSigType,oaBoolean,oaBlockDomainVisibility)\n"
"    Calls: oaBundleNet* create(oaBlock* block,const oaBundleName& name,oaSigType sigType,oaBoolean isGlobal,oaBlockDomainVisibility view)\n"
"    Signature: create|ptr-oaBundleNet|ptr-oaBlock,cref-oaBundleName,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates an oaBundleNet object in the specified block with the specified attributes. The name specifies the members of the oaBundleNet object and these member nets are automatically created if they do not already exist in the specified block. An exception is thrown if an oaBundleNet object with the given name already exists.\n"
"    block\n"
"    The block in which to create the oaBundleNet\n"
"    name\n"
"    The name of this oaBundleNet. The members of the BundleNet are derived from the name.\n"
"    sigType\n"
"    The signal type to associate with this net\n"
"    isGlobal\n"
"    Specifies if this is a global net\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaBundleNet\n"
"    oacNetExists\n"
;

static PyObject*
oaBundleNet_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaBlock,oaBundleName)
    {
        PyParamoaBlock p1;
        PyParamoaBundleName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaBundleName_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBundleNetp result= (oaBundleNet::create(p1.Data(),p2.Data()));
            return PyoaBundleNet_FromoaBundleNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaBundleName,oaSigType)
    {
        PyParamoaBlock p1;
        PyParamoaBundleName p2;
        PyParamoaSigType p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaBundleName_Convert,&p2,
              &PyoaSigType_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBundleNetp result= (oaBundleNet::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBundleNet_FromoaBundleNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaBundleName,oaSigType,oaBoolean)
    {
        PyParamoaBlock p1;
        PyParamoaBundleName p2;
        PyParamoaSigType p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaBundleName_Convert,&p2,
              &PyoaSigType_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBundleNetp result= (oaBundleNet::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBundleNet_FromoaBundleNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaBundleName,oaSigType,oaBoolean,oaBlockDomainVisibility)
    {
        PyParamoaBlock p1;
        PyParamoaBundleName p2;
        PyParamoaSigType p3;
        PyParamoaBoolean p4;
        PyParamoaBlockDomainVisibility p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaBundleName_Convert,&p2,
              &PyoaSigType_Convert,&p3,
              &PyoaBoolean_Convert,&p4,
              &PyoaBlockDomainVisibility_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBundleNetp result= (oaBundleNet::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
            return PyoaBundleNet_FromoaBundleNet(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBundleNet, function: create, Choices are:\n"
        "    (oaBlock,oaBundleName)\n"
        "    (oaBlock,oaBundleName,oaSigType)\n"
        "    (oaBlock,oaBundleName,oaSigType,oaBoolean)\n"
        "    (oaBlock,oaBundleName,oaSigType,oaBoolean,oaBlockDomainVisibility)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleNet_static_find_doc[] = 
"Class: oaBundleNet, Function: find\n"
"  Paramegers: (oaBlock,oaBundleName)\n"
"    Calls: oaBundleNet* find(const oaBlock* block,const oaBundleName& name)\n"
"    Signature: find|ptr-oaBundleNet|cptr-oaBlock,cref-oaBundleName,\n"
"    This function searches the specified block for an oaBundleNet with the specified name .\n"
"    block\n"
"    The block to search\n"
"    name\n"
"    The name of the oaBundleNet to find\n"
"    A pointer to an oaBundleNet; NULL is returned if found\n"
;

static PyObject*
oaBundleNet_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaBundleName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaBundleName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBundleNetp result= (oaBundleNet::find(p1.Data(),p2.Data()));
        return PyoaBundleNet_FromoaBundleNet(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleNet_static_isValidName_doc[] = 
"Class: oaBundleNet, Function: isValidName\n"
"  Paramegers: (oaBlock,oaBundleName)\n"
"    Calls: oaBoolean isValidName(oaBlock* block,const oaBundleName& name)\n"
"    Signature: isValidName|simple-oaBoolean|ptr-oaBlock,cref-oaBundleName,\n"
"    This function returns a boolean value that indicates if the specified name is valid for a new oaBundleNet in the specified block.\n"
"    block\n"
"    The block in which to check the oaBundleNet name\n"
"    name\n"
"    The name of the new oaBundleNet that might be created\n"
;

static PyObject*
oaBundleNet_static_isValidName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaBundleName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaBundleName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (oaBundleNet::isValidName(p1.Data(),p2.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBundleNet_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaBundleNet_static_create,METH_VARARGS,oaBundleNet_static_create_doc},
    {"static_find",(PyCFunction)oaBundleNet_static_find,METH_VARARGS,oaBundleNet_static_find_doc},
    {"static_isValidName",(PyCFunction)oaBundleNet_static_isValidName,METH_VARARGS,oaBundleNet_static_isValidName_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBundleNet_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBundleNet_Type)<0) {
      printf("** PyType_Ready failed for: oaBundleNet\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBundleNet",
           (PyObject*)(&PyoaBundleNet_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBundleNet\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBundleNet_Type.tp_dict;
    for(method=oaBundleNet_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBundleTerm
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBundleTerm_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBundleTerm_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBundleTermObject* self = (PyoaBundleTermObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBundleTerm)
    {
        PyParamoaBundleTerm p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBundleTerm_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBundleTerm, Choices are:\n"
        "    (oaBundleTerm)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBundleTerm_tp_dealloc(PyoaBundleTermObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBundleTerm_tp_repr(PyObject *ob)
{
    PyParamoaBundleTerm value;
    int convert_status=PyoaBundleTerm_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaBundleTerm::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[34];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaBundleTerm::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBundleTerm_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBundleTerm v1;
    PyParamoaBundleTerm v2;
    int convert_status1=PyoaBundleTerm_Convert(ob1,&v1);
    int convert_status2=PyoaBundleTerm_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBundleTerm_Convert(PyObject* ob,PyParamoaBundleTerm* result)
{
    if (ob == NULL) return 1;
    if (PyoaBundleTerm_Check(ob)) {
        result->SetData( (oaBundleTerm**) ((PyoaBundleTermObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBundleTerm Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBundleTerm_FromoaBundleTerm(oaBundleTerm** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBundleTerm* data=*value;
        PyObject* bself = PyoaBundleTerm_Type.tp_alloc(&PyoaBundleTerm_Type,0);
        if (bself == NULL) return bself;
        PyoaBundleTermObject* self = (PyoaBundleTermObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBundleTerm_FromoaBundleTerm(oaBundleTerm* data)
{
    if (data) {
       PyObject* bself = PyoaBundleTerm_Type.tp_alloc(&PyoaBundleTerm_Type,0);
       if (bself == NULL) return bself;
       PyoaBundleTermObject* self = (PyoaBundleTermObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBundleTerm_getMember_doc[] = 
"Class: oaBundleTerm, Function: getMember\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaTerm* getMember(oaUInt4 index) const\n"
"    Signature: getMember|ptr-oaTerm|simple-oaUInt4,\n"
"    This function returns the memIndex member of this bundleTerm.\n"
"    memIndex\n"
"    The bundle member index of the member term to get\n"
"    A pointer to an oaTerm\n"
"    oacInvalidBundleTermMemberIndex\n"
;

static PyObject*
oaBundleTerm_getMember(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBundleTerm data;
    int convert_status=PyoaBundleTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBundleTermObject* self=(PyoaBundleTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaTermp result= (data.DataCall()->getMember(p1.Data()));
        return PyoaTerm_FromoaTerm(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleTerm_getMembers_doc[] = 
"Class: oaBundleTerm, Function: getMembers\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaTerm_oaBundleTerm getMembers() const\n"
"    Signature: getMembers|simple-oaCollection_oaTerm_oaBundleTerm|\n"
"    BrowseData: 1\n"
"    This function returns a collection of member terms in this bundleTerm.\n"
;

static PyObject*
oaBundleTerm_getMembers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBundleTerm data;
    int convert_status=PyoaBundleTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBundleTermObject* self=(PyoaBundleTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaTerm_oaBundleTerm* result= new oaCollection_oaTerm_oaBundleTerm(data.DataCall()->getMembers());
        return PyoaCollection_oaTerm_oaBundleTerm_FromoaCollection_oaTerm_oaBundleTerm(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleTerm_getMembersIter_doc[] = 
"Class: oaBundleTerm, Function: getMembersIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaTerm getMembersIter() const\n"
"    Signature: getMembersIter|simple-oaIter_oaTerm|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of member terms in this bundleTerm.\n"
;

static PyObject*
oaBundleTerm_getMembersIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBundleTerm data;
    int convert_status=PyoaBundleTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBundleTermObject* self=(PyoaBundleTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaTerm* result= new oaIter_oaTerm(data.DataCall()->getMembers());
        return PyoaIter_oaTerm_FromoaIter_oaTerm(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleTerm_getName_doc[] = 
"Class: oaBundleTerm, Function: getName\n"
"  Paramegers: (oaBundleName)\n"
"    Calls: void getName(oaBundleName& name) const\n"
"    Signature: getName|void-void|ref-oaBundleName,\n"
"    BrowseData: 0,oaBundleName\n"
"    This function returns the name of this oaBundleTerm.\n"
"    name\n"
"    The name of the oaBundleTerm to return\n"
"  Paramegers: (oaName)\n"
"    Calls: void getName(oaName& name) const\n"
"    Signature: getName|void-void|ref-oaName,\n"
"    BrowseData: 0,oaName\n"
"    This function fills out name with the name of this terminal.\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function fills in name with the name of this terminal mapped to the specified nameSpace.\n"
;

static PyObject*
oaBundleTerm_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBundleTerm data;
    int convert_status=PyoaBundleTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBundleTermObject* self=(PyoaBundleTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaBundleName)
    {
        PyParamoaBundleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBundleName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaName)
    {
        PyParamoaName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBundleTerm, function: getName, Choices are:\n"
        "    (oaBundleName)\n"
        "    (oaName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleTerm_getNumMembers_doc[] = 
"Class: oaBundleTerm, Function: getNumMembers\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumMembers() const\n"
"    Signature: getNumMembers|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of members in this bundleTerm.\n"
"    The number of member terminals in this bundleTerm\n"
;

static PyObject*
oaBundleTerm_getNumMembers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBundleTerm data;
    int convert_status=PyoaBundleTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBundleTermObject* self=(PyoaBundleTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumMembers());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleTerm_isNull_doc[] =
"Class: oaBundleTerm, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBundleTerm_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBundleTerm data;
    int convert_status=PyoaBundleTerm_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBundleTerm_assign_doc[] = 
"Class: oaBundleTerm, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBundleTerm_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBundleTerm data;
  int convert_status=PyoaBundleTerm_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBundleTerm p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBundleTerm_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBundleTerm_methodlist[] = {
    {"getMember",(PyCFunction)oaBundleTerm_getMember,METH_VARARGS,oaBundleTerm_getMember_doc},
    {"getMembers",(PyCFunction)oaBundleTerm_getMembers,METH_VARARGS,oaBundleTerm_getMembers_doc},
    {"getMembersIter",(PyCFunction)oaBundleTerm_getMembersIter,METH_VARARGS,oaBundleTerm_getMembersIter_doc},
    {"getName",(PyCFunction)oaBundleTerm_getName,METH_VARARGS,oaBundleTerm_getName_doc},
    {"getNumMembers",(PyCFunction)oaBundleTerm_getNumMembers,METH_VARARGS,oaBundleTerm_getNumMembers_doc},
    {"isNull",(PyCFunction)oaBundleTerm_tp_isNull,METH_VARARGS,oaBundleTerm_isNull_doc},
    {"assign",(PyCFunction)oaBundleTerm_tp_assign,METH_VARARGS,oaBundleTerm_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBundleTerm_doc[] = 
"Class: oaBundleTerm\n"
"  The oaBundleTerm class implements a multi-bit terminal for a block composed of one or more scalarTerms, one or more busTerms, or a combination of scalarTerms and busTerms. When a bundleTerm is created, the constituent scalarTerms and busNetBits are automatically created if they do not already exist. Bundle terms are associated with bundle nets ( oaBundleNet ) to represent connectivity. The number of bits implied by the name of the bundle term and bundle net must match to be meaningful.\n"
"Constructors:\n"
"  Paramegers: (oaBundleTerm)\n"
"    Calls: (const oaBundleTerm&)\n"
"    Signature: oaBundleTerm||cref-oaBundleTerm,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBundleTerm_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBundleTerm",
    sizeof(PyoaBundleTermObject),
    0,
    (destructor)oaBundleTerm_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBundleTerm_tp_compare,	/* tp_compare */
    (reprfunc)oaBundleTerm_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBundleTerm_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBundleTerm_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaTerm_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBundleTerm_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBundleTerm_static_create_doc[] = 
"Class: oaBundleTerm, Function: create\n"
"  Paramegers: (oaNet,oaBundleName)\n"
"    Calls: oaBundleTerm* create(oaNet* net,const oaBundleName& name)\n"
"    Signature: create|ptr-oaBundleTerm|ptr-oaNet,cref-oaBundleName,simple-oaTermType,simple-oaBlockDomainVisibility,\n"
"    This function creates an oaBundleTerm object on the specified net with the specified attributes. The given name specifies the members of the bundleTerm. These member terminals are automatically created if they do not already exist. The number of bits implied by the name must match the number of bits in the given net .\n"
"    net\n"
"    A pointer to the net to associate with the terminal; the bits of the net are associated with the constituent bits of the automatically created member terminals\n"
"    name\n"
"    The name of the terminal\n"
"    termType\n"
"    The type of terminal to create\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaBundleTerm\n"
"    oacNetTermWidthMismatch\n"
"    oacTermExists\n"
"    oacCannotCreateTermWithImplicitNet\n"
"    oacTermNetMustBeInUniqueOccHier\n"
"  Paramegers: (oaNet,oaBundleName,oaTermType)\n"
"    Calls: oaBundleTerm* create(oaNet* net,const oaBundleName& name,oaTermType termType)\n"
"    Signature: create|ptr-oaBundleTerm|ptr-oaNet,cref-oaBundleName,simple-oaTermType,simple-oaBlockDomainVisibility,\n"
"    This function creates an oaBundleTerm object on the specified net with the specified attributes. The given name specifies the members of the bundleTerm. These member terminals are automatically created if they do not already exist. The number of bits implied by the name must match the number of bits in the given net .\n"
"    net\n"
"    A pointer to the net to associate with the terminal; the bits of the net are associated with the constituent bits of the automatically created member terminals\n"
"    name\n"
"    The name of the terminal\n"
"    termType\n"
"    The type of terminal to create\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaBundleTerm\n"
"    oacNetTermWidthMismatch\n"
"    oacTermExists\n"
"    oacCannotCreateTermWithImplicitNet\n"
"    oacTermNetMustBeInUniqueOccHier\n"
"  Paramegers: (oaNet,oaBundleName,oaTermType,oaBlockDomainVisibility)\n"
"    Calls: oaBundleTerm* create(oaNet* net,const oaBundleName& name,oaTermType termType,oaBlockDomainVisibility view)\n"
"    Signature: create|ptr-oaBundleTerm|ptr-oaNet,cref-oaBundleName,simple-oaTermType,simple-oaBlockDomainVisibility,\n"
"    This function creates an oaBundleTerm object on the specified net with the specified attributes. The given name specifies the members of the bundleTerm. These member terminals are automatically created if they do not already exist. The number of bits implied by the name must match the number of bits in the given net .\n"
"    net\n"
"    A pointer to the net to associate with the terminal; the bits of the net are associated with the constituent bits of the automatically created member terminals\n"
"    name\n"
"    The name of the terminal\n"
"    termType\n"
"    The type of terminal to create\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaBundleTerm\n"
"    oacNetTermWidthMismatch\n"
"    oacTermExists\n"
"    oacCannotCreateTermWithImplicitNet\n"
"    oacTermNetMustBeInUniqueOccHier\n"
;

static PyObject*
oaBundleTerm_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaNet,oaBundleName)
    {
        PyParamoaNet p1;
        PyParamoaBundleName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNet_Convert,&p1,
              &PyoaBundleName_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBundleTermp result= (oaBundleTerm::create(p1.Data(),p2.Data()));
            return PyoaBundleTerm_FromoaBundleTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaNet,oaBundleName,oaTermType)
    {
        PyParamoaNet p1;
        PyParamoaBundleName p2;
        PyParamoaTermType p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaNet_Convert,&p1,
              &PyoaBundleName_Convert,&p2,
              &PyoaTermType_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBundleTermp result= (oaBundleTerm::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBundleTerm_FromoaBundleTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaNet,oaBundleName,oaTermType,oaBlockDomainVisibility)
    {
        PyParamoaNet p1;
        PyParamoaBundleName p2;
        PyParamoaTermType p3;
        PyParamoaBlockDomainVisibility p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaNet_Convert,&p1,
              &PyoaBundleName_Convert,&p2,
              &PyoaTermType_Convert,&p3,
              &PyoaBlockDomainVisibility_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBundleTermp result= (oaBundleTerm::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBundleTerm_FromoaBundleTerm(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBundleTerm, function: create, Choices are:\n"
        "    (oaNet,oaBundleName)\n"
        "    (oaNet,oaBundleName,oaTermType)\n"
        "    (oaNet,oaBundleName,oaTermType,oaBlockDomainVisibility)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleTerm_static_find_doc[] = 
"Class: oaBundleTerm, Function: find\n"
"  Paramegers: (oaBlock,oaBundleName)\n"
"    Calls: oaBundleTerm* find(const oaBlock* block,const oaBundleName& name)\n"
"    Signature: find|ptr-oaBundleTerm|cptr-oaBlock,cref-oaBundleName,\n"
"    This function searches the specified block for a bundleTerm with the given name . The bundleTerm is returned if it exists. Otherwise, NULL is returned.\n"
"    block\n"
"    The block to search\n"
"    name\n"
"    The name of the terminal\n"
"    A pointer to an oaBundleTerm if found; otherwise, NULL is returned\n"
;

static PyObject*
oaBundleTerm_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaBundleName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaBundleName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBundleTermp result= (oaBundleTerm::find(p1.Data(),p2.Data()));
        return PyoaBundleTerm_FromoaBundleTerm(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBundleTerm_static_isValidName_doc[] = 
"Class: oaBundleTerm, Function: isValidName\n"
"  Paramegers: (oaBlock,oaNet,oaBundleName)\n"
"    Calls: oaBoolean isValidName(oaBlock* block,oaNet* net,const oaBundleName& name)\n"
"    Signature: isValidName|simple-oaBoolean|ptr-oaBlock,ptr-oaNet,cref-oaBundleName,\n"
"    This function returns a boolean value indicating whether the specified name is valid for a new oaBundleTerm object associated with the specified net.\n"
"    block\n"
"    The block in which to create the new bundle terminal\n"
"    net\n"
"    The net with which to associate the new bundle terminal\n"
"    name\n"
"    The name of the new bundle terminal\n"
;

static PyObject*
oaBundleTerm_static_isValidName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaNet p2;
    PyParamoaBundleName p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaNet_Convert,&p2,
          &PyoaBundleName_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!PyValidateDbObject(p2.Data(),2)) return NULL;
        oaBoolean result= (oaBundleTerm::isValidName(p1.Data(),p2.Data(),p3.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBundleTerm_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaBundleTerm_static_create,METH_VARARGS,oaBundleTerm_static_create_doc},
    {"static_find",(PyCFunction)oaBundleTerm_static_find,METH_VARARGS,oaBundleTerm_static_find_doc},
    {"static_isValidName",(PyCFunction)oaBundleTerm_static_isValidName,METH_VARARGS,oaBundleTerm_static_isValidName_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBundleTerm_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBundleTerm_Type)<0) {
      printf("** PyType_Ready failed for: oaBundleTerm\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBundleTerm",
           (PyObject*)(&PyoaBundleTerm_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBundleTerm\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBundleTerm_Type.tp_dict;
    for(method=oaBundleTerm_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBusNet
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBusNet_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBusNet_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBusNetObject* self = (PyoaBusNetObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBusNet)
    {
        PyParamoaBusNet p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBusNet_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBusNet, Choices are:\n"
        "    (oaBusNet)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBusNet_tp_dealloc(PyoaBusNetObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBusNet_tp_repr(PyObject *ob)
{
    PyParamoaBusNet value;
    int convert_status=PyoaBusNet_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaBusNet::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[30];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaBusNet::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBusNet_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBusNet v1;
    PyParamoaBusNet v2;
    int convert_status1=PyoaBusNet_Convert(ob1,&v1);
    int convert_status2=PyoaBusNet_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBusNet_Convert(PyObject* ob,PyParamoaBusNet* result)
{
    if (ob == NULL) return 1;
    if (PyoaBusNet_Check(ob)) {
        result->SetData( (oaBusNet**) ((PyoaBusNetObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBusNet Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBusNet_FromoaBusNet(oaBusNet** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBusNet* data=*value;
        PyObject* bself = PyoaBusNet_Type.tp_alloc(&PyoaBusNet_Type,0);
        if (bself == NULL) return bself;
        PyoaBusNetObject* self = (PyoaBusNetObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBusNet_FromoaBusNet(oaBusNet* data)
{
    if (data) {
       PyObject* bself = PyoaBusNet_Type.tp_alloc(&PyoaBusNet_Type,0);
       if (bself == NULL) return bself;
       PyoaBusNetObject* self = (PyoaBusNetObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBusNet_getDef_doc[] = 
"Class: oaBusNet, Function: getDef\n"
"  Paramegers: ()\n"
"    Calls: oaBusNetDef* getDef() const\n"
"    Signature: getDef|ptr-oaBusNetDef|\n"
"    BrowseData: 1\n"
"    This function returns the busNetDef for this busNet.\n"
"    A pointer to an oaBusNetDef\n"
;

static PyObject*
oaBusNet_getDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusNet data;
    int convert_status=PyoaBusNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusNetObject* self=(PyoaBusNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBusNetDefp result= (data.DataCall()->getDef());
        return PyoaBusNetDef_FromoaBusNetDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNet_getName_doc[] = 
"Class: oaBusNet, Function: getName\n"
"  Paramegers: (oaVectorName)\n"
"    Calls: void getName(oaVectorName& name) const\n"
"    Signature: getName|void-void|ref-oaVectorName,\n"
"    BrowseData: 0,oaVectorName\n"
"    This function returns the name of this oaBusNet.\n"
"    name\n"
"    The name of the oaBusNet to return\n"
"  Paramegers: (oaName)\n"
"    Calls: void getName(oaName& name) const\n"
"    Signature: getName|void-void|ref-oaName,\n"
"    BrowseData: 0,oaName\n"
"    This function returns the name of this net in the name argument.\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the name of this net in the specified nameSpace in the specified name string.\n"
;

static PyObject*
oaBusNet_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusNet data;
    int convert_status=PyoaBusNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusNetObject* self=(PyoaBusNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaVectorName)
    {
        PyParamoaVectorName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaName)
    {
        PyParamoaName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBusNet, function: getName, Choices are:\n"
        "    (oaVectorName)\n"
        "    (oaName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNet_getStart_doc[] = 
"Class: oaBusNet, Function: getStart\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getStart() const\n"
"    Signature: getStart|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the starting index for this oaBusNet. The bit order of an oaBusNet is implied by the values returned by getStart and getStop.\n"
"    The starting index of this busNet\n"
;

static PyObject*
oaBusNet_getStart(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusNet data;
    int convert_status=PyoaBusNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusNetObject* self=(PyoaBusNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getStart());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNet_getStep_doc[] = 
"Class: oaBusNet, Function: getStep\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getStep() const\n"
"    Signature: getStep|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the step value for this busNet.\n"
"    The step value for this busNet\n"
;

static PyObject*
oaBusNet_getStep(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusNet data;
    int convert_status=PyoaBusNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusNetObject* self=(PyoaBusNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getStep());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNet_getStop_doc[] = 
"Class: oaBusNet, Function: getStop\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getStop() const\n"
"    Signature: getStop|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the ending index for this oaBusNet. The bit order of an oaBusNet is implied by the values returned by getStart and getStop.\n"
"    The ending index for this busNet\n"
;

static PyObject*
oaBusNet_getStop(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusNet data;
    int convert_status=PyoaBusNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusNetObject* self=(PyoaBusNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getStop());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNet_setBaseName_doc[] = 
"Class: oaBusNet, Function: setBaseName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void setBaseName(const oaScalarName& name)\n"
"    Signature: setBaseName|void-void|cref-oaScalarName,\n"
"    This function changes the base name of this busNet.\n"
"    name\n"
"    The base name for the net\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacCannotRenameToImplicitBusNet\n"
"    oacCannotSetNameOfImplicitNet\n"
"    oacCannotSetNameOfNetInBundleNet\n"
"    oacNetExists\n"
"    oacNetSetBaseNameConflictsInTerms\n"
"    oacNetSetBaseNameConflictsInInstTerms\n"
;

static PyObject*
oaBusNet_setBaseName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusNet data;
    int convert_status=PyoaBusNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusNetObject* self=(PyoaBusNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScalarName p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaScalarName_Convert,&p1)) {
        data.DataCall()->setBaseName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNet_setRange_doc[] = 
"Class: oaBusNet, Function: setRange\n"
"  Paramegers: (oaUInt4,oaUInt4)\n"
"    Calls: void setRange(oaUInt4 start,oaUInt4 stop)\n"
"    Signature: setRange|void-void|simple-oaUInt4,simple-oaUInt4,\n"
"    This function changes the vector range for this busNet. The new number of bits implied by the specified start and stop bits must match the current number of bits. This restriction is necessary so that any terminals or instance terminals that are associated with this busNet are not affected.\n"
"    start\n"
"    The starting index of the net\n"
"    stop\n"
"    The stopping index of the net\n"
"    oacCannotRenameToImplicitBusNet\n"
"    oacCannotSetRangeOfImplicitBus\n"
"    oacCannotSetRangeOfBusInBundleNet\n"
"    oacInvalidBusStartStopRange\n"
"    oacNetExists\n"
"    oacNetSetRangeConflictsWithOtherNets\n"
;

static PyObject*
oaBusNet_setRange(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusNet data;
    int convert_status=PyoaBusNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusNetObject* self=(PyoaBusNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2)) {
        data.DataCall()->setRange(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNet_isNull_doc[] =
"Class: oaBusNet, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBusNet_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBusNet data;
    int convert_status=PyoaBusNet_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBusNet_assign_doc[] = 
"Class: oaBusNet, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBusNet_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBusNet data;
  int convert_status=PyoaBusNet_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBusNet p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBusNet_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBusNet_methodlist[] = {
    {"getDef",(PyCFunction)oaBusNet_getDef,METH_VARARGS,oaBusNet_getDef_doc},
    {"getName",(PyCFunction)oaBusNet_getName,METH_VARARGS,oaBusNet_getName_doc},
    {"getStart",(PyCFunction)oaBusNet_getStart,METH_VARARGS,oaBusNet_getStart_doc},
    {"getStep",(PyCFunction)oaBusNet_getStep,METH_VARARGS,oaBusNet_getStep_doc},
    {"getStop",(PyCFunction)oaBusNet_getStop,METH_VARARGS,oaBusNet_getStop_doc},
    {"setBaseName",(PyCFunction)oaBusNet_setBaseName,METH_VARARGS,oaBusNet_setBaseName_doc},
    {"setRange",(PyCFunction)oaBusNet_setRange,METH_VARARGS,oaBusNet_setRange_doc},
    {"isNull",(PyCFunction)oaBusNet_tp_isNull,METH_VARARGS,oaBusNet_isNull_doc},
    {"assign",(PyCFunction)oaBusNet_tp_assign,METH_VARARGS,oaBusNet_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBusNet_doc[] = 
"Class: oaBusNet\n"
"  The oaBusNet class implements a net that can represent one or more bits that are associated with a common base name and vector range specification. A busNet has a corresponding busNetDef (refer to oaBusNetDef class) that manages all busNets that share the same base name. Once a busNet is created, the associated bus net bits are also created as implicit single bit nets if they do not exist already. Refer to oaNet for a general description of implicit nets.\n"
"  Bus nets are named by the oaBusName convention, that is, it has a baseName and the start, stop, step value. A bus net object can be viewed as a collection of single bit logical connections.\n"
"  An example of oaBusNet--\"A[0:6:2]\"--It is a bus net consisting of 4 oaBusNetBit objects: A[0] A[2] A[4] A[6].\n"
"  The related oaBusNetDef object is what the database use to manage bus nets with the same base name.\n"
"Constructors:\n"
"  Paramegers: (oaBusNet)\n"
"    Calls: (const oaBusNet&)\n"
"    Signature: oaBusNet||cref-oaBusNet,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBusNet_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBusNet",
    sizeof(PyoaBusNetObject),
    0,
    (destructor)oaBusNet_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBusNet_tp_compare,	/* tp_compare */
    (reprfunc)oaBusNet_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBusNet_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBusNet_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaNet_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBusNet_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBusNet_static_create_doc[] = 
"Class: oaBusNet, Function: create\n"
"  Paramegers: (oaBlock,oaScalarName,oaUInt4,oaUInt4,oaUInt4)\n"
"    Calls: oaBusNet* create(oaBlock* block,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop,oaUInt4 step)\n"
"    Signature: create|ptr-oaBusNet|ptr-oaBlock,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,simple-oaUInt4,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates a single-bit or multi-bit busNet with the specified attributes. The specified baseName and start , stop , and step indices are first checked to verify they are legal and do not specify an existing busNet.\n"
"    block\n"
"    The block in which to create the busNet\n"
"    baseName\n"
"    The base name for the busNet\n"
"    start\n"
"    The starting index of the busNet\n"
"    stop\n"
"    The stopping index of the busNet\n"
"    step\n"
"    The index increment value from start to step; step should be greater than zero\n"
"    sigType\n"
"    The signal type of the busNet\n"
"    isGlobal\n"
"    Specifies if this is a global busNet\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to the oaBusNet created\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacNetExists\n"
"  Paramegers: (oaBlock,oaScalarName,oaUInt4,oaUInt4,oaUInt4,oaSigType)\n"
"    Calls: oaBusNet* create(oaBlock* block,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop,oaUInt4 step,oaSigType sigType)\n"
"    Signature: create|ptr-oaBusNet|ptr-oaBlock,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,simple-oaUInt4,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates a single-bit or multi-bit busNet with the specified attributes. The specified baseName and start , stop , and step indices are first checked to verify they are legal and do not specify an existing busNet.\n"
"    block\n"
"    The block in which to create the busNet\n"
"    baseName\n"
"    The base name for the busNet\n"
"    start\n"
"    The starting index of the busNet\n"
"    stop\n"
"    The stopping index of the busNet\n"
"    step\n"
"    The index increment value from start to step; step should be greater than zero\n"
"    sigType\n"
"    The signal type of the busNet\n"
"    isGlobal\n"
"    Specifies if this is a global busNet\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to the oaBusNet created\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacNetExists\n"
"  Paramegers: (oaBlock,oaScalarName,oaUInt4,oaUInt4,oaUInt4,oaSigType,oaBoolean)\n"
"    Calls: oaBusNet* create(oaBlock* block,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop,oaUInt4 step,oaSigType sigType,oaBoolean isGlobal)\n"
"    Signature: create|ptr-oaBusNet|ptr-oaBlock,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,simple-oaUInt4,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates a single-bit or multi-bit busNet with the specified attributes. The specified baseName and start , stop , and step indices are first checked to verify they are legal and do not specify an existing busNet.\n"
"    block\n"
"    The block in which to create the busNet\n"
"    baseName\n"
"    The base name for the busNet\n"
"    start\n"
"    The starting index of the busNet\n"
"    stop\n"
"    The stopping index of the busNet\n"
"    step\n"
"    The index increment value from start to step; step should be greater than zero\n"
"    sigType\n"
"    The signal type of the busNet\n"
"    isGlobal\n"
"    Specifies if this is a global busNet\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to the oaBusNet created\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacNetExists\n"
"  Paramegers: (oaBlock,oaScalarName,oaUInt4,oaUInt4,oaUInt4,oaSigType,oaBoolean,oaBlockDomainVisibility)\n"
"    Calls: oaBusNet* create(oaBlock* block,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop,oaUInt4 step,oaSigType sigType,oaBoolean isGlobal,oaBlockDomainVisibility view)\n"
"    Signature: create|ptr-oaBusNet|ptr-oaBlock,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,simple-oaUInt4,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates a single-bit or multi-bit busNet with the specified attributes. The specified baseName and start , stop , and step indices are first checked to verify they are legal and do not specify an existing busNet.\n"
"    block\n"
"    The block in which to create the busNet\n"
"    baseName\n"
"    The base name for the busNet\n"
"    start\n"
"    The starting index of the busNet\n"
"    stop\n"
"    The stopping index of the busNet\n"
"    step\n"
"    The index increment value from start to step; step should be greater than zero\n"
"    sigType\n"
"    The signal type of the busNet\n"
"    isGlobal\n"
"    Specifies if this is a global busNet\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to the oaBusNet created\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacNetExists\n"
"  Paramegers: (oaBlock,oaVectorName)\n"
"    Calls: oaBusNet* create(oaBlock* block,const oaVectorName& name)\n"
"    Signature: create|ptr-oaBusNet|ptr-oaBlock,cref-oaVectorName,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates a busNet with the specified attributes using an oaVectorName as input and creating a multi-bit busNet. (Use one of the other create() API functions to create single-bit nets.)\n"
"    block\n"
"    The block in which to create the busNet\n"
"    name\n"
"    The base name, start, stop, and step values to use to create the busNet\n"
"    sigType\n"
"    The signal type of the busNet\n"
"    isGlobal\n"
"    Specifies if this is a global busNet\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaBusNet\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacNetExists\n"
"  Paramegers: (oaBlock,oaVectorName,oaSigType)\n"
"    Calls: oaBusNet* create(oaBlock* block,const oaVectorName& name,oaSigType sigType)\n"
"    Signature: create|ptr-oaBusNet|ptr-oaBlock,cref-oaVectorName,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates a busNet with the specified attributes using an oaVectorName as input and creating a multi-bit busNet. (Use one of the other create() API functions to create single-bit nets.)\n"
"    block\n"
"    The block in which to create the busNet\n"
"    name\n"
"    The base name, start, stop, and step values to use to create the busNet\n"
"    sigType\n"
"    The signal type of the busNet\n"
"    isGlobal\n"
"    Specifies if this is a global busNet\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaBusNet\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacNetExists\n"
"  Paramegers: (oaBlock,oaVectorName,oaSigType,oaBoolean)\n"
"    Calls: oaBusNet* create(oaBlock* block,const oaVectorName& name,oaSigType sigType,oaBoolean isGlobal)\n"
"    Signature: create|ptr-oaBusNet|ptr-oaBlock,cref-oaVectorName,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates a busNet with the specified attributes using an oaVectorName as input and creating a multi-bit busNet. (Use one of the other create() API functions to create single-bit nets.)\n"
"    block\n"
"    The block in which to create the busNet\n"
"    name\n"
"    The base name, start, stop, and step values to use to create the busNet\n"
"    sigType\n"
"    The signal type of the busNet\n"
"    isGlobal\n"
"    Specifies if this is a global busNet\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaBusNet\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacNetExists\n"
"  Paramegers: (oaBlock,oaVectorName,oaSigType,oaBoolean,oaBlockDomainVisibility)\n"
"    Calls: oaBusNet* create(oaBlock* block,const oaVectorName& name,oaSigType sigType,oaBoolean isGlobal,oaBlockDomainVisibility view)\n"
"    Signature: create|ptr-oaBusNet|ptr-oaBlock,cref-oaVectorName,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates a busNet with the specified attributes using an oaVectorName as input and creating a multi-bit busNet. (Use one of the other create() API functions to create single-bit nets.)\n"
"    block\n"
"    The block in which to create the busNet\n"
"    name\n"
"    The base name, start, stop, and step values to use to create the busNet\n"
"    sigType\n"
"    The signal type of the busNet\n"
"    isGlobal\n"
"    Specifies if this is a global busNet\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaBusNet\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacNetExists\n"
"  Paramegers: (oaBlock,oaVectorBitName)\n"
"    Calls: oaBusNet* create(oaBlock* block,const oaVectorBitName& name)\n"
"    Signature: create|ptr-oaBusNet|ptr-oaBlock,cref-oaVectorBitName,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates a busNet with the specified attributes, using an oaVectorBitName as input and creating a single-bit busNet.\n"
"    block\n"
"    The block in which to create the busNet\n"
"    name\n"
"    The base name and bit index to use to create the busNet\n"
"    sigType\n"
"    The signal type of the busNet\n"
"    isGlobal\n"
"    Specifies if this is a global net\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaBusNet\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacNetExists\n"
"  Paramegers: (oaBlock,oaVectorBitName,oaSigType)\n"
"    Calls: oaBusNet* create(oaBlock* block,const oaVectorBitName& name,oaSigType sigType)\n"
"    Signature: create|ptr-oaBusNet|ptr-oaBlock,cref-oaVectorBitName,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates a busNet with the specified attributes, using an oaVectorBitName as input and creating a single-bit busNet.\n"
"    block\n"
"    The block in which to create the busNet\n"
"    name\n"
"    The base name and bit index to use to create the busNet\n"
"    sigType\n"
"    The signal type of the busNet\n"
"    isGlobal\n"
"    Specifies if this is a global net\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaBusNet\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacNetExists\n"
"  Paramegers: (oaBlock,oaVectorBitName,oaSigType,oaBoolean)\n"
"    Calls: oaBusNet* create(oaBlock* block,const oaVectorBitName& name,oaSigType sigType,oaBoolean isGlobal)\n"
"    Signature: create|ptr-oaBusNet|ptr-oaBlock,cref-oaVectorBitName,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates a busNet with the specified attributes, using an oaVectorBitName as input and creating a single-bit busNet.\n"
"    block\n"
"    The block in which to create the busNet\n"
"    name\n"
"    The base name and bit index to use to create the busNet\n"
"    sigType\n"
"    The signal type of the busNet\n"
"    isGlobal\n"
"    Specifies if this is a global net\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaBusNet\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacNetExists\n"
"  Paramegers: (oaBlock,oaVectorBitName,oaSigType,oaBoolean,oaBlockDomainVisibility)\n"
"    Calls: oaBusNet* create(oaBlock* block,const oaVectorBitName& name,oaSigType sigType,oaBoolean isGlobal,oaBlockDomainVisibility view)\n"
"    Signature: create|ptr-oaBusNet|ptr-oaBlock,cref-oaVectorBitName,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates a busNet with the specified attributes, using an oaVectorBitName as input and creating a single-bit busNet.\n"
"    block\n"
"    The block in which to create the busNet\n"
"    name\n"
"    The base name and bit index to use to create the busNet\n"
"    sigType\n"
"    The signal type of the busNet\n"
"    isGlobal\n"
"    Specifies if this is a global net\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaBusNet\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacNetExists\n"
;

static PyObject*
oaBusNet_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaBlock,oaScalarName,oaUInt4,oaUInt4,oaUInt4)
    {
        PyParamoaBlock p1;
        PyParamoaScalarName p2;
        PyParamoaUInt4 p3;
        PyParamoaUInt4 p4;
        PyParamoaUInt4 p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaUInt4_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaUInt4_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusNetp result= (oaBusNet::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
            return PyoaBusNet_FromoaBusNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaScalarName,oaUInt4,oaUInt4,oaUInt4,oaSigType)
    {
        PyParamoaBlock p1;
        PyParamoaScalarName p2;
        PyParamoaUInt4 p3;
        PyParamoaUInt4 p4;
        PyParamoaUInt4 p5;
        PyParamoaSigType p6;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaUInt4_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaUInt4_Convert,&p5,
              &PyoaSigType_Convert,&p6)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusNetp result= (oaBusNet::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data()));
            return PyoaBusNet_FromoaBusNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaScalarName,oaUInt4,oaUInt4,oaUInt4,oaSigType,oaBoolean)
    {
        PyParamoaBlock p1;
        PyParamoaScalarName p2;
        PyParamoaUInt4 p3;
        PyParamoaUInt4 p4;
        PyParamoaUInt4 p5;
        PyParamoaSigType p6;
        PyParamoaBoolean p7;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaUInt4_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaUInt4_Convert,&p5,
              &PyoaSigType_Convert,&p6,
              &PyoaBoolean_Convert,&p7)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusNetp result= (oaBusNet::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data()));
            return PyoaBusNet_FromoaBusNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaScalarName,oaUInt4,oaUInt4,oaUInt4,oaSigType,oaBoolean,oaBlockDomainVisibility)
    {
        PyParamoaBlock p1;
        PyParamoaScalarName p2;
        PyParamoaUInt4 p3;
        PyParamoaUInt4 p4;
        PyParamoaUInt4 p5;
        PyParamoaSigType p6;
        PyParamoaBoolean p7;
        PyParamoaBlockDomainVisibility p8;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaUInt4_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaUInt4_Convert,&p5,
              &PyoaSigType_Convert,&p6,
              &PyoaBoolean_Convert,&p7,
              &PyoaBlockDomainVisibility_Convert,&p8)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusNetp result= (oaBusNet::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.Data()));
            return PyoaBusNet_FromoaBusNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaVectorName)
    {
        PyParamoaBlock p1;
        PyParamoaVectorName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaVectorName_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusNetp result= (oaBusNet::create(p1.Data(),p2.Data()));
            return PyoaBusNet_FromoaBusNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaVectorName,oaSigType)
    {
        PyParamoaBlock p1;
        PyParamoaVectorName p2;
        PyParamoaSigType p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaVectorName_Convert,&p2,
              &PyoaSigType_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusNetp result= (oaBusNet::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBusNet_FromoaBusNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaVectorName,oaSigType,oaBoolean)
    {
        PyParamoaBlock p1;
        PyParamoaVectorName p2;
        PyParamoaSigType p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaVectorName_Convert,&p2,
              &PyoaSigType_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusNetp result= (oaBusNet::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBusNet_FromoaBusNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaVectorName,oaSigType,oaBoolean,oaBlockDomainVisibility)
    {
        PyParamoaBlock p1;
        PyParamoaVectorName p2;
        PyParamoaSigType p3;
        PyParamoaBoolean p4;
        PyParamoaBlockDomainVisibility p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaVectorName_Convert,&p2,
              &PyoaSigType_Convert,&p3,
              &PyoaBoolean_Convert,&p4,
              &PyoaBlockDomainVisibility_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusNetp result= (oaBusNet::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
            return PyoaBusNet_FromoaBusNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaVectorBitName)
    {
        PyParamoaBlock p1;
        PyParamoaVectorBitName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaVectorBitName_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusNetp result= (oaBusNet::create(p1.Data(),p2.Data()));
            return PyoaBusNet_FromoaBusNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaVectorBitName,oaSigType)
    {
        PyParamoaBlock p1;
        PyParamoaVectorBitName p2;
        PyParamoaSigType p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaVectorBitName_Convert,&p2,
              &PyoaSigType_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusNetp result= (oaBusNet::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBusNet_FromoaBusNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaVectorBitName,oaSigType,oaBoolean)
    {
        PyParamoaBlock p1;
        PyParamoaVectorBitName p2;
        PyParamoaSigType p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaVectorBitName_Convert,&p2,
              &PyoaSigType_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusNetp result= (oaBusNet::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBusNet_FromoaBusNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaVectorBitName,oaSigType,oaBoolean,oaBlockDomainVisibility)
    {
        PyParamoaBlock p1;
        PyParamoaVectorBitName p2;
        PyParamoaSigType p3;
        PyParamoaBoolean p4;
        PyParamoaBlockDomainVisibility p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaVectorBitName_Convert,&p2,
              &PyoaSigType_Convert,&p3,
              &PyoaBoolean_Convert,&p4,
              &PyoaBlockDomainVisibility_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusNetp result= (oaBusNet::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
            return PyoaBusNet_FromoaBusNet(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBusNet, function: create, Choices are:\n"
        "    (oaBlock,oaScalarName,oaUInt4,oaUInt4,oaUInt4)\n"
        "    (oaBlock,oaScalarName,oaUInt4,oaUInt4,oaUInt4,oaSigType)\n"
        "    (oaBlock,oaScalarName,oaUInt4,oaUInt4,oaUInt4,oaSigType,oaBoolean)\n"
        "    (oaBlock,oaScalarName,oaUInt4,oaUInt4,oaUInt4,oaSigType,oaBoolean,oaBlockDomainVisibility)\n"
        "    (oaBlock,oaVectorName)\n"
        "    (oaBlock,oaVectorName,oaSigType)\n"
        "    (oaBlock,oaVectorName,oaSigType,oaBoolean)\n"
        "    (oaBlock,oaVectorName,oaSigType,oaBoolean,oaBlockDomainVisibility)\n"
        "    (oaBlock,oaVectorBitName)\n"
        "    (oaBlock,oaVectorBitName,oaSigType)\n"
        "    (oaBlock,oaVectorBitName,oaSigType,oaBoolean)\n"
        "    (oaBlock,oaVectorBitName,oaSigType,oaBoolean,oaBlockDomainVisibility)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNet_static_find_doc[] = 
"Class: oaBusNet, Function: find\n"
"  Paramegers: (oaBlock,oaScalarName,oaUInt4,oaUInt4,oaUInt4)\n"
"    Calls: oaBusNet* find(const oaBlock* block,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop,oaUInt4 step)\n"
"    Signature: find|ptr-oaBusNet|cptr-oaBlock,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,simple-oaUInt4,\n"
"    This function searches the specified block for a busNet with the specified baseName and start, stop, step indices. The busNet is returned if found. Otherwise, NULL is returned.\n"
"    block\n"
"    The block in which to find the busNet\n"
"    baseName\n"
"    The base name for the net\n"
"    start\n"
"    The starting index of the net\n"
"    stop\n"
"    The stopping index of the net\n"
"    step\n"
"    The index increment value from start to step; step should be greater than zero\n"
"    A pointer to the oaBusNet\n"
;

static PyObject*
oaBusNet_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaScalarName p2;
    PyParamoaUInt4 p3;
    PyParamoaUInt4 p4;
    PyParamoaUInt4 p5;
    if (PyArg_ParseTuple(args,"O&O&O&O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaUInt4_Convert,&p3,
          &PyoaUInt4_Convert,&p4,
          &PyoaUInt4_Convert,&p5)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBusNetp result= (oaBusNet::find(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
        return PyoaBusNet_FromoaBusNet(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNet_static_isValidName_doc[] = 
"Class: oaBusNet, Function: isValidName\n"
"  Paramegers: (oaBlock,oaScalarName,oaUInt4,oaUInt4,oaUInt4)\n"
"    Calls: oaBoolean isValidName(const oaBlock* block,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop,oaUInt4 step)\n"
"    Signature: isValidName|simple-oaBoolean|cptr-oaBlock,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,simple-oaUInt4,\n"
"    This function returns a boolean value indicating whether the specified name is valid for a new oaBusNet in the specified block.\n"
"    block\n"
"    The block to search\n"
"    baseName\n"
"    The base bus net name\n"
"    start\n"
"    The starting index of the net\n"
"    stop\n"
"    The stopping index of the net\n"
"    step\n"
"    The index increment value from start to step; step should be greater than zero\n"
;

static PyObject*
oaBusNet_static_isValidName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaScalarName p2;
    PyParamoaUInt4 p3;
    PyParamoaUInt4 p4;
    PyParamoaUInt4 p5;
    if (PyArg_ParseTuple(args,"O&O&O&O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaUInt4_Convert,&p3,
          &PyoaUInt4_Convert,&p4,
          &PyoaUInt4_Convert,&p5)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (oaBusNet::isValidName(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBusNet_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaBusNet_static_create,METH_VARARGS,oaBusNet_static_create_doc},
    {"static_find",(PyCFunction)oaBusNet_static_find,METH_VARARGS,oaBusNet_static_find_doc},
    {"static_isValidName",(PyCFunction)oaBusNet_static_isValidName,METH_VARARGS,oaBusNet_static_isValidName_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBusNet_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBusNet_Type)<0) {
      printf("** PyType_Ready failed for: oaBusNet\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBusNet",
           (PyObject*)(&PyoaBusNet_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBusNet\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBusNet_Type.tp_dict;
    for(method=oaBusNet_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBusNetBit
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBusNetBit_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBusNetBit_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBusNetBitObject* self = (PyoaBusNetBitObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBusNetBit)
    {
        PyParamoaBusNetBit p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBusNetBit_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBusNetBit, Choices are:\n"
        "    (oaBusNetBit)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBusNetBit_tp_dealloc(PyoaBusNetBitObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBusNetBit_tp_repr(PyObject *ob)
{
    PyParamoaBusNetBit value;
    int convert_status=PyoaBusNetBit_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaBusNetBit::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[33];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaBusNetBit::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBusNetBit_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBusNetBit v1;
    PyParamoaBusNetBit v2;
    int convert_status1=PyoaBusNetBit_Convert(ob1,&v1);
    int convert_status2=PyoaBusNetBit_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBusNetBit_Convert(PyObject* ob,PyParamoaBusNetBit* result)
{
    if (ob == NULL) return 1;
    if (PyoaBusNetBit_Check(ob)) {
        result->SetData( (oaBusNetBit**) ((PyoaBusNetBitObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBusNetBit Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBusNetBit_FromoaBusNetBit(oaBusNetBit** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBusNetBit* data=*value;
        PyObject* bself = PyoaBusNetBit_Type.tp_alloc(&PyoaBusNetBit_Type,0);
        if (bself == NULL) return bself;
        PyoaBusNetBitObject* self = (PyoaBusNetBitObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBusNetBit_FromoaBusNetBit(oaBusNetBit* data)
{
    if (data) {
       PyObject* bself = PyoaBusNetBit_Type.tp_alloc(&PyoaBusNetBit_Type,0);
       if (bself == NULL) return bself;
       PyoaBusNetBitObject* self = (PyoaBusNetBitObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBusNetBit_getBitIndex_doc[] = 
"Class: oaBusNetBit, Function: getBitIndex\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getBitIndex() const\n"
"    Signature: getBitIndex|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the index for this busNetBit (with the respect of the corresponding bus net def). Returns can include non-consecutive numbers.\n"
;

static PyObject*
oaBusNetBit_getBitIndex(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusNetBit data;
    int convert_status=PyoaBusNetBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusNetBitObject* self=(PyoaBusNetBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getBitIndex());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNetBit_getDef_doc[] = 
"Class: oaBusNetBit, Function: getDef\n"
"  Paramegers: ()\n"
"    Calls: oaBusNetDef* getDef() const\n"
"    Signature: getDef|ptr-oaBusNetDef|\n"
"    BrowseData: 1\n"
"    This function returns the busNetDef associated with this busNetBit.\n"
;

static PyObject*
oaBusNetBit_getDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusNetBit data;
    int convert_status=PyoaBusNetBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusNetBitObject* self=(PyoaBusNetBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBusNetDefp result= (data.DataCall()->getDef());
        return PyoaBusNetDef_FromoaBusNetDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNetBit_getName_doc[] = 
"Class: oaBusNetBit, Function: getName\n"
"  Paramegers: (oaVectorBitName)\n"
"    Calls: void getName(oaVectorBitName& name) const\n"
"    Signature: getName|void-void|ref-oaVectorBitName,\n"
"    BrowseData: 0,oaVectorBitName\n"
"    This function returns the name of this oaBusNetBit.\n"
"    name\n"
"    The name of the oaBusNetBit to return\n"
"  Paramegers: (oaName)\n"
"    Calls: void getName(oaName& name) const\n"
"    Signature: getName|void-void|ref-oaName,\n"
"    BrowseData: 0,oaName\n"
"    This function returns the name of this net in the name argument.\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the name of this net in the specified nameSpace in the specified name string.\n"
;

static PyObject*
oaBusNetBit_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusNetBit data;
    int convert_status=PyoaBusNetBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusNetBitObject* self=(PyoaBusNetBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaVectorBitName)
    {
        PyParamoaVectorBitName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorBitName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaName)
    {
        PyParamoaName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBusNetBit, function: getName, Choices are:\n"
        "    (oaVectorBitName)\n"
        "    (oaName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNetBit_setName_doc[] = 
"Class: oaBusNetBit, Function: setName\n"
"  Paramegers: (oaScalarName,oaUInt4)\n"
"    Calls: void setName(const oaScalarName& baseName,oaUInt4 bitIndex)\n"
"    Signature: setName|void-void|cref-oaScalarName,simple-oaUInt4,\n"
"    This function changes the name of this busNetBit to that implied by the given baseName and bitIndex .\n"
"    baseName\n"
"    The new base name for this net\n"
"    bitIndex\n"
"    The new bit index for this net\n"
"    oacCannotSetNameOfImplicitNet\n"
"    oacCannotSetNameOfNetInBundleNet\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacNetExists\n"
;

static PyObject*
oaBusNetBit_setName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusNetBit data;
    int convert_status=PyoaBusNetBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusNetBitObject* self=(PyoaBusNetBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScalarName p1;
    PyParamoaUInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaScalarName_Convert,&p1,
          &PyoaUInt4_Convert,&p2)) {
        data.DataCall()->setName(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNetBit_isNull_doc[] =
"Class: oaBusNetBit, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBusNetBit_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBusNetBit data;
    int convert_status=PyoaBusNetBit_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBusNetBit_assign_doc[] = 
"Class: oaBusNetBit, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBusNetBit_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBusNetBit data;
  int convert_status=PyoaBusNetBit_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBusNetBit p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBusNetBit_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBusNetBit_methodlist[] = {
    {"getBitIndex",(PyCFunction)oaBusNetBit_getBitIndex,METH_VARARGS,oaBusNetBit_getBitIndex_doc},
    {"getDef",(PyCFunction)oaBusNetBit_getDef,METH_VARARGS,oaBusNetBit_getDef_doc},
    {"getName",(PyCFunction)oaBusNetBit_getName,METH_VARARGS,oaBusNetBit_getName_doc},
    {"setName",(PyCFunction)oaBusNetBit_setName,METH_VARARGS,oaBusNetBit_setName_doc},
    {"isNull",(PyCFunction)oaBusNetBit_tp_isNull,METH_VARARGS,oaBusNetBit_isNull_doc},
    {"assign",(PyCFunction)oaBusNetBit_tp_assign,METH_VARARGS,oaBusNetBit_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBusNetBit_doc[] = 
"Class: oaBusNetBit\n"
"  The oaBusNetBit class implements an oaBitNet that represents a single bit of an oaBusNet which is a busNet in the block domain. When a busNet is created, a corresponding set of busNetBits is automatically created. When the busNet is destroyed, the automatically created busNetBits are also destroyed. An implicitly created busNetBit cannot be used to connect to terminals or instTerms, nor can it be associated with shapes or routes.\n"
"  An oaBusNetBit can be explicitly created and used in other operations like creating terminals or instTerms. An explicitly created busNetBit must be explicitly destroyed.\n"
"Constructors:\n"
"  Paramegers: (oaBusNetBit)\n"
"    Calls: (const oaBusNetBit&)\n"
"    Signature: oaBusNetBit||cref-oaBusNetBit,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBusNetBit_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBusNetBit",
    sizeof(PyoaBusNetBitObject),
    0,
    (destructor)oaBusNetBit_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBusNetBit_tp_compare,	/* tp_compare */
    (reprfunc)oaBusNetBit_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBusNetBit_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBusNetBit_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaBitNet_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBusNetBit_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBusNetBit_static_create_doc[] = 
"Class: oaBusNetBit, Function: create\n"
"  Paramegers: (oaBlock,oaScalarName,oaUInt4)\n"
"    Calls: oaBusNetBit* create(oaBlock* block,const oaScalarName& baseName,oaUInt4 bitIndex)\n"
"    Signature: create|ptr-oaBusNetBit|ptr-oaBlock,cref-oaScalarName,simple-oaUInt4,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates a busNetBit with the specified baseName and bitIndex in the given block .\n"
"    block\n"
"    The block to create the net in\n"
"    baseName\n"
"    The base name to give the net\n"
"    bitIndex\n"
"    The bit index to give the net\n"
"    sigType\n"
"    The signal type of the busNetBit\n"
"    isGlobal\n"
"    Specifies if this is a global net\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacNetExists\n"
"  Paramegers: (oaBlock,oaScalarName,oaUInt4,oaSigType)\n"
"    Calls: oaBusNetBit* create(oaBlock* block,const oaScalarName& baseName,oaUInt4 bitIndex,oaSigType sigType)\n"
"    Signature: create|ptr-oaBusNetBit|ptr-oaBlock,cref-oaScalarName,simple-oaUInt4,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates a busNetBit with the specified baseName and bitIndex in the given block .\n"
"    block\n"
"    The block to create the net in\n"
"    baseName\n"
"    The base name to give the net\n"
"    bitIndex\n"
"    The bit index to give the net\n"
"    sigType\n"
"    The signal type of the busNetBit\n"
"    isGlobal\n"
"    Specifies if this is a global net\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacNetExists\n"
"  Paramegers: (oaBlock,oaScalarName,oaUInt4,oaSigType,oaBoolean)\n"
"    Calls: oaBusNetBit* create(oaBlock* block,const oaScalarName& baseName,oaUInt4 bitIndex,oaSigType sigType,oaBoolean isGlobale)\n"
"    Signature: create|ptr-oaBusNetBit|ptr-oaBlock,cref-oaScalarName,simple-oaUInt4,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates a busNetBit with the specified baseName and bitIndex in the given block .\n"
"    block\n"
"    The block to create the net in\n"
"    baseName\n"
"    The base name to give the net\n"
"    bitIndex\n"
"    The bit index to give the net\n"
"    sigType\n"
"    The signal type of the busNetBit\n"
"    isGlobal\n"
"    Specifies if this is a global net\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacNetExists\n"
"  Paramegers: (oaBlock,oaScalarName,oaUInt4,oaSigType,oaBoolean,oaBlockDomainVisibility)\n"
"    Calls: oaBusNetBit* create(oaBlock* block,const oaScalarName& baseName,oaUInt4 bitIndex,oaSigType sigType,oaBoolean isGlobale,oaBlockDomainVisibility view)\n"
"    Signature: create|ptr-oaBusNetBit|ptr-oaBlock,cref-oaScalarName,simple-oaUInt4,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates a busNetBit with the specified baseName and bitIndex in the given block .\n"
"    block\n"
"    The block to create the net in\n"
"    baseName\n"
"    The base name to give the net\n"
"    bitIndex\n"
"    The bit index to give the net\n"
"    sigType\n"
"    The signal type of the busNetBit\n"
"    isGlobal\n"
"    Specifies if this is a global net\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacNetExists\n"
"  Paramegers: (oaBlock,oaVectorBitName)\n"
"    Calls: oaBusNetBit* create(oaBlock* block,const oaVectorBitName& bitName)\n"
"    Signature: create|ptr-oaBusNetBit|ptr-oaBlock,cref-oaVectorBitName,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates a busNetBit with the baseName and bitIndex as specified in the given bitName .\n"
"    block\n"
"    The block to create the net in\n"
"    bitName\n"
"    The vector bit name to use for the net\n"
"    sigType\n"
"    The signal type of the busNetBit\n"
"    isGlobal\n"
"    Specifies if this is a global net\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacNetExists\n"
"  Paramegers: (oaBlock,oaVectorBitName,oaSigType)\n"
"    Calls: oaBusNetBit* create(oaBlock* block,const oaVectorBitName& bitName,oaSigType sigType)\n"
"    Signature: create|ptr-oaBusNetBit|ptr-oaBlock,cref-oaVectorBitName,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates a busNetBit with the baseName and bitIndex as specified in the given bitName .\n"
"    block\n"
"    The block to create the net in\n"
"    bitName\n"
"    The vector bit name to use for the net\n"
"    sigType\n"
"    The signal type of the busNetBit\n"
"    isGlobal\n"
"    Specifies if this is a global net\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacNetExists\n"
"  Paramegers: (oaBlock,oaVectorBitName,oaSigType,oaBoolean)\n"
"    Calls: oaBusNetBit* create(oaBlock* block,const oaVectorBitName& bitName,oaSigType sigType,oaBoolean isGlobale)\n"
"    Signature: create|ptr-oaBusNetBit|ptr-oaBlock,cref-oaVectorBitName,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates a busNetBit with the baseName and bitIndex as specified in the given bitName .\n"
"    block\n"
"    The block to create the net in\n"
"    bitName\n"
"    The vector bit name to use for the net\n"
"    sigType\n"
"    The signal type of the busNetBit\n"
"    isGlobal\n"
"    Specifies if this is a global net\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacNetExists\n"
"  Paramegers: (oaBlock,oaVectorBitName,oaSigType,oaBoolean,oaBlockDomainVisibility)\n"
"    Calls: oaBusNetBit* create(oaBlock* block,const oaVectorBitName& bitName,oaSigType sigType,oaBoolean isGlobale,oaBlockDomainVisibility view)\n"
"    Signature: create|ptr-oaBusNetBit|ptr-oaBlock,cref-oaVectorBitName,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates a busNetBit with the baseName and bitIndex as specified in the given bitName .\n"
"    block\n"
"    The block to create the net in\n"
"    bitName\n"
"    The vector bit name to use for the net\n"
"    sigType\n"
"    The signal type of the busNetBit\n"
"    isGlobal\n"
"    Specifies if this is a global net\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacNetExists\n"
;

static PyObject*
oaBusNetBit_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaBlock,oaScalarName,oaUInt4)
    {
        PyParamoaBlock p1;
        PyParamoaScalarName p2;
        PyParamoaUInt4 p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaUInt4_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusNetBitp result= (oaBusNetBit::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBusNetBit_FromoaBusNetBit(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaScalarName,oaUInt4,oaSigType)
    {
        PyParamoaBlock p1;
        PyParamoaScalarName p2;
        PyParamoaUInt4 p3;
        PyParamoaSigType p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaUInt4_Convert,&p3,
              &PyoaSigType_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusNetBitp result= (oaBusNetBit::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBusNetBit_FromoaBusNetBit(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaScalarName,oaUInt4,oaSigType,oaBoolean)
    {
        PyParamoaBlock p1;
        PyParamoaScalarName p2;
        PyParamoaUInt4 p3;
        PyParamoaSigType p4;
        PyParamoaBoolean p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaUInt4_Convert,&p3,
              &PyoaSigType_Convert,&p4,
              &PyoaBoolean_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusNetBitp result= (oaBusNetBit::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
            return PyoaBusNetBit_FromoaBusNetBit(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaScalarName,oaUInt4,oaSigType,oaBoolean,oaBlockDomainVisibility)
    {
        PyParamoaBlock p1;
        PyParamoaScalarName p2;
        PyParamoaUInt4 p3;
        PyParamoaSigType p4;
        PyParamoaBoolean p5;
        PyParamoaBlockDomainVisibility p6;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaUInt4_Convert,&p3,
              &PyoaSigType_Convert,&p4,
              &PyoaBoolean_Convert,&p5,
              &PyoaBlockDomainVisibility_Convert,&p6)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusNetBitp result= (oaBusNetBit::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data()));
            return PyoaBusNetBit_FromoaBusNetBit(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaVectorBitName)
    {
        PyParamoaBlock p1;
        PyParamoaVectorBitName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaVectorBitName_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusNetBitp result= (oaBusNetBit::create(p1.Data(),p2.Data()));
            return PyoaBusNetBit_FromoaBusNetBit(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaVectorBitName,oaSigType)
    {
        PyParamoaBlock p1;
        PyParamoaVectorBitName p2;
        PyParamoaSigType p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaVectorBitName_Convert,&p2,
              &PyoaSigType_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusNetBitp result= (oaBusNetBit::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBusNetBit_FromoaBusNetBit(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaVectorBitName,oaSigType,oaBoolean)
    {
        PyParamoaBlock p1;
        PyParamoaVectorBitName p2;
        PyParamoaSigType p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaVectorBitName_Convert,&p2,
              &PyoaSigType_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusNetBitp result= (oaBusNetBit::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBusNetBit_FromoaBusNetBit(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaVectorBitName,oaSigType,oaBoolean,oaBlockDomainVisibility)
    {
        PyParamoaBlock p1;
        PyParamoaVectorBitName p2;
        PyParamoaSigType p3;
        PyParamoaBoolean p4;
        PyParamoaBlockDomainVisibility p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaVectorBitName_Convert,&p2,
              &PyoaSigType_Convert,&p3,
              &PyoaBoolean_Convert,&p4,
              &PyoaBlockDomainVisibility_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusNetBitp result= (oaBusNetBit::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
            return PyoaBusNetBit_FromoaBusNetBit(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBusNetBit, function: create, Choices are:\n"
        "    (oaBlock,oaScalarName,oaUInt4)\n"
        "    (oaBlock,oaScalarName,oaUInt4,oaSigType)\n"
        "    (oaBlock,oaScalarName,oaUInt4,oaSigType,oaBoolean)\n"
        "    (oaBlock,oaScalarName,oaUInt4,oaSigType,oaBoolean,oaBlockDomainVisibility)\n"
        "    (oaBlock,oaVectorBitName)\n"
        "    (oaBlock,oaVectorBitName,oaSigType)\n"
        "    (oaBlock,oaVectorBitName,oaSigType,oaBoolean)\n"
        "    (oaBlock,oaVectorBitName,oaSigType,oaBoolean,oaBlockDomainVisibility)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNetBit_static_find_doc[] = 
"Class: oaBusNetBit, Function: find\n"
"  Paramegers: (oaBlock,oaScalarName,oaUInt4)\n"
"    Calls: oaBusNetBit* find(const oaBlock* block,const oaScalarName& baseName,oaUInt4 bitIndex)\n"
"    Signature: find|ptr-oaBusNetBit|cptr-oaBlock,cref-oaScalarName,simple-oaUInt4,\n"
"    This function searches the specified block looking for a busNetBit with the specified baseName and bit index. The net is returned if found, otherwise NULL is returned.\n"
"    block\n"
"    The block to search\n"
"    baseName\n"
"    The baseName of the busNetBit to locate\n"
"    bitIndex\n"
"    The bit index of the busNetBit to locate\n"
;

static PyObject*
oaBusNetBit_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaScalarName p2;
    PyParamoaUInt4 p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaUInt4_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBusNetBitp result= (oaBusNetBit::find(p1.Data(),p2.Data(),p3.Data()));
        return PyoaBusNetBit_FromoaBusNetBit(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNetBit_static_isValidName_doc[] = 
"Class: oaBusNetBit, Function: isValidName\n"
"  Paramegers: (oaBlock,oaScalarName,oaUInt4)\n"
"    Calls: oaBoolean isValidName(const oaBlock* block,const oaScalarName& baseName,oaUInt4 bitIndex)\n"
"    Signature: isValidName|simple-oaBoolean|cptr-oaBlock,cref-oaScalarName,simple-oaUInt4,\n"
"    This function returns a boolean value indicating whether the specified name is valid for a new oaBusNetBit in the specified block.\n"
"    block\n"
"    The block to search\n"
"    baseName\n"
"    The base name of the bus bit\n"
"    bitIndex\n"
"    The bit index of the bus bit\n"
;

static PyObject*
oaBusNetBit_static_isValidName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaScalarName p2;
    PyParamoaUInt4 p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaUInt4_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (oaBusNetBit::isValidName(p1.Data(),p2.Data(),p3.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBusNetBit_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaBusNetBit_static_create,METH_VARARGS,oaBusNetBit_static_create_doc},
    {"static_find",(PyCFunction)oaBusNetBit_static_find,METH_VARARGS,oaBusNetBit_static_find_doc},
    {"static_isValidName",(PyCFunction)oaBusNetBit_static_isValidName,METH_VARARGS,oaBusNetBit_static_isValidName_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBusNetBit_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBusNetBit_Type)<0) {
      printf("** PyType_Ready failed for: oaBusNetBit\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBusNetBit",
           (PyObject*)(&PyoaBusNetBit_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBusNetBit\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBusNetBit_Type.tp_dict;
    for(method=oaBusNetBit_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBusNetDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBusNetDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBusNetDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBusNetDefObject* self = (PyoaBusNetDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBusNetDef)
    {
        PyParamoaBusNetDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBusNetDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBusNetDef, Choices are:\n"
        "    (oaBusNetDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBusNetDef_tp_dealloc(PyoaBusNetDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBusNetDef_tp_repr(PyObject *ob)
{
    PyParamoaBusNetDef value;
    int convert_status=PyoaBusNetDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaBusNetDef::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaScalarName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[33];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaBusNetDef::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBusNetDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBusNetDef v1;
    PyParamoaBusNetDef v2;
    int convert_status1=PyoaBusNetDef_Convert(ob1,&v1);
    int convert_status2=PyoaBusNetDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBusNetDef_Convert(PyObject* ob,PyParamoaBusNetDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaBusNetDef_Check(ob)) {
        result->SetData( (oaBusNetDef**) ((PyoaBusNetDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBusNetDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBusNetDef_FromoaBusNetDef(oaBusNetDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBusNetDef* data=*value;
        PyObject* bself = PyoaBusNetDef_Type.tp_alloc(&PyoaBusNetDef_Type,0);
        if (bself == NULL) return bself;
        PyoaBusNetDefObject* self = (PyoaBusNetDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBusNetDef_FromoaBusNetDef(oaBusNetDef* data)
{
    if (data) {
       PyObject* bself = PyoaBusNetDef_Type.tp_alloc(&PyoaBusNetDef_Type,0);
       if (bself == NULL) return bself;
       PyoaBusNetDefObject* self = (PyoaBusNetDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBusNetDef_destroy_doc[] = 
"Class: oaBusNetDef, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function destroys this oaBusNetDef, removing it from the database. An exception is thrown if the oaBusNetDef is implicit or if there are still oaBusNets associated with it.\n"
"    oacCannotDestroyImplicitBusNetDef\n"
"    oacCannotDestroyBusNetDefWithNets\n"
;

static PyObject*
oaBusNetDef_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusNetDef data;
    int convert_status=PyoaBusNetDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusNetDefObject* self=(PyoaBusNetDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNetDef_getBitOrder_doc[] = 
"Class: oaBusNetDef, Function: getBitOrder\n"
"  Paramegers: ()\n"
"    Calls: oaBitOrder getBitOrder() const\n"
"    Signature: getBitOrder|simple-oaBitOrder|\n"
"    BrowseData: 1\n"
"    This function returns the bitOrder associated with this oaBusNetDef object.\n"
;

static PyObject*
oaBusNetDef_getBitOrder(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusNetDef data;
    int convert_status=PyoaBusNetDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusNetDefObject* self=(PyoaBusNetDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBitOrder* result= new oaBitOrder(data.DataCall()->getBitOrder());
        return PyoaBitOrder_FromoaBitOrder(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNetDef_getBusNetBits_doc[] = 
"Class: oaBusNetDef, Function: getBusNetBits\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaBusNetBit_oaBusNetDef getBusNetBits() const\n"
"    Signature: getBusNetBits|simple-oaCollection_oaBusNetBit_oaBusNetDef|\n"
"    BrowseData: 1\n"
"    This function returns a collection of oaBusNetBit objects in this oaBusNetDef object.\n"
;

static PyObject*
oaBusNetDef_getBusNetBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusNetDef data;
    int convert_status=PyoaBusNetDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusNetDefObject* self=(PyoaBusNetDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaBusNetBit_oaBusNetDef* result= new oaCollection_oaBusNetBit_oaBusNetDef(data.DataCall()->getBusNetBits());
        return PyoaCollection_oaBusNetBit_oaBusNetDef_FromoaCollection_oaBusNetBit_oaBusNetDef(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNetDef_getBusNetBitsIter_doc[] = 
"Class: oaBusNetDef, Function: getBusNetBitsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaBusNetBit getBusNetBitsIter() const\n"
"    Signature: getBusNetBitsIter|simple-oaIter_oaBusNetBit|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of oaBusNetBit objects in this oaBusNetDef object.\n"
;

static PyObject*
oaBusNetDef_getBusNetBitsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusNetDef data;
    int convert_status=PyoaBusNetDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusNetDefObject* self=(PyoaBusNetDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaBusNetBit* result= new oaIter_oaBusNetBit(data.DataCall()->getBusNetBits());
        return PyoaIter_oaBusNetBit_FromoaIter_oaBusNetBit(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNetDef_getBusNets_doc[] = 
"Class: oaBusNetDef, Function: getBusNets\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaBusNet_oaBusNetDef getBusNets() const\n"
"    Signature: getBusNets|simple-oaCollection_oaBusNet_oaBusNetDef|\n"
"    BrowseData: 1\n"
"    This function returns a collection of oaBusNet objects in this oaBusNetDef object.\n"
;

static PyObject*
oaBusNetDef_getBusNets(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusNetDef data;
    int convert_status=PyoaBusNetDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusNetDefObject* self=(PyoaBusNetDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaBusNet_oaBusNetDef* result= new oaCollection_oaBusNet_oaBusNetDef(data.DataCall()->getBusNets());
        return PyoaCollection_oaBusNet_oaBusNetDef_FromoaCollection_oaBusNet_oaBusNetDef(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNetDef_getBusNetsIter_doc[] = 
"Class: oaBusNetDef, Function: getBusNetsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaBusNet getBusNetsIter() const\n"
"    Signature: getBusNetsIter|simple-oaIter_oaBusNet|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of oaBusNet objects in this oaBusNetDef object.\n"
;

static PyObject*
oaBusNetDef_getBusNetsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusNetDef data;
    int convert_status=PyoaBusNetDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusNetDefObject* self=(PyoaBusNetDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaBusNet* result= new oaIter_oaBusNet(data.DataCall()->getBusNets());
        return PyoaIter_oaBusNet_FromoaIter_oaBusNet(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNetDef_getMaxIndex_doc[] = 
"Class: oaBusNetDef, Function: getMaxIndex\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getMaxIndex() const\n"
"    Signature: getMaxIndex|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the largest bit number in use for this oaBusNetDef object. This is the largest index used across all busNets associated with this oaBusNetDef object.\n"
;

static PyObject*
oaBusNetDef_getMaxIndex(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusNetDef data;
    int convert_status=PyoaBusNetDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusNetDefObject* self=(PyoaBusNetDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getMaxIndex());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNetDef_getMinIndex_doc[] = 
"Class: oaBusNetDef, Function: getMinIndex\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getMinIndex() const\n"
"    Signature: getMinIndex|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the smallest bit number in use for this oaBusNetDef object. This is the smallest index used across all busNets associated with this oaBusNetDef object.\n"
;

static PyObject*
oaBusNetDef_getMinIndex(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusNetDef data;
    int convert_status=PyoaBusNetDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusNetDefObject* self=(PyoaBusNetDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getMinIndex());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNetDef_getName_doc[] = 
"Class: oaBusNetDef, Function: getName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getName(oaScalarName& name) const\n"
"    Signature: getName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the name of this oaBusNetDef object.\n"
"    name\n"
"    The scalar name in which to return the oaBusNetDef object name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the name string of this oaBusNetDef object in the specified nameSpace.\n"
"    ns\n"
"    The nameSpace to use when getting the name string\n"
"    name\n"
"    Returns the string name of this oaBusNetDef\n"
;

static PyObject*
oaBusNetDef_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusNetDef data;
    int convert_status=PyoaBusNetDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusNetDefObject* self=(PyoaBusNetDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBusNetDef, function: getName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNetDef_getNumBits_doc[] = 
"Class: oaBusNetDef, Function: getNumBits\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumBits() const\n"
"    Signature: getNumBits|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of bits covered by the busses in this oaBusNetDef. The number of bits is equal to abs(maxIndex - minIndex) + 1; it is not necessarily the number of busNetBits present in this busNetDef. To get the number of busNetBits in this busnetDef, use oaBusNetDef::getBusNetBits() .getCount() .\n"
;

static PyObject*
oaBusNetDef_getNumBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusNetDef data;
    int convert_status=PyoaBusNetDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusNetDefObject* self=(PyoaBusNetDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumBits());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNetDef_isImplicit_doc[] = 
"Class: oaBusNetDef, Function: isImplicit\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isImplicit() const\n"
"    Signature: isImplicit|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether this oaBusNetDef was implicitly created or not.\n"
;

static PyObject*
oaBusNetDef_isImplicit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusNetDef data;
    int convert_status=PyoaBusNetDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusNetDefObject* self=(PyoaBusNetDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isImplicit());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNetDef_setBitOrder_doc[] = 
"Class: oaBusNetDef, Function: setBitOrder\n"
"  Paramegers: (oaBitOrder)\n"
"    Calls: void setBitOrder(oaBitOrder order)\n"
"    Signature: setBitOrder|void-void|simple-oaBitOrder,\n"
"    This function changes the bitOrder value associated with the oaBusNetDef. An exception is thrown if this busNetDef was implicitly created.\n"
"    order\n"
"    The new bitOrder value for this busNetDef\n"
"    oacBitOrderBusNetDefImplicit\n"
;

static PyObject*
oaBusNetDef_setBitOrder(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusNetDef data;
    int convert_status=PyoaBusNetDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusNetDefObject* self=(PyoaBusNetDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBitOrder p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBitOrder_Convert,&p1)) {
        data.DataCall()->setBitOrder(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNetDef_isNull_doc[] =
"Class: oaBusNetDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBusNetDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBusNetDef data;
    int convert_status=PyoaBusNetDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBusNetDef_assign_doc[] = 
"Class: oaBusNetDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBusNetDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBusNetDef data;
  int convert_status=PyoaBusNetDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBusNetDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBusNetDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBusNetDef_methodlist[] = {
    {"destroy",(PyCFunction)oaBusNetDef_destroy,METH_VARARGS,oaBusNetDef_destroy_doc},
    {"getBitOrder",(PyCFunction)oaBusNetDef_getBitOrder,METH_VARARGS,oaBusNetDef_getBitOrder_doc},
    {"getBusNetBits",(PyCFunction)oaBusNetDef_getBusNetBits,METH_VARARGS,oaBusNetDef_getBusNetBits_doc},
    {"getBusNetBitsIter",(PyCFunction)oaBusNetDef_getBusNetBitsIter,METH_VARARGS,oaBusNetDef_getBusNetBitsIter_doc},
    {"getBusNets",(PyCFunction)oaBusNetDef_getBusNets,METH_VARARGS,oaBusNetDef_getBusNets_doc},
    {"getBusNetsIter",(PyCFunction)oaBusNetDef_getBusNetsIter,METH_VARARGS,oaBusNetDef_getBusNetsIter_doc},
    {"getMaxIndex",(PyCFunction)oaBusNetDef_getMaxIndex,METH_VARARGS,oaBusNetDef_getMaxIndex_doc},
    {"getMinIndex",(PyCFunction)oaBusNetDef_getMinIndex,METH_VARARGS,oaBusNetDef_getMinIndex_doc},
    {"getName",(PyCFunction)oaBusNetDef_getName,METH_VARARGS,oaBusNetDef_getName_doc},
    {"getNumBits",(PyCFunction)oaBusNetDef_getNumBits,METH_VARARGS,oaBusNetDef_getNumBits_doc},
    {"isImplicit",(PyCFunction)oaBusNetDef_isImplicit,METH_VARARGS,oaBusNetDef_isImplicit_doc},
    {"setBitOrder",(PyCFunction)oaBusNetDef_setBitOrder,METH_VARARGS,oaBusNetDef_setBitOrder_doc},
    {"isNull",(PyCFunction)oaBusNetDef_tp_isNull,METH_VARARGS,oaBusNetDef_isNull_doc},
    {"assign",(PyCFunction)oaBusNetDef_tp_assign,METH_VARARGS,oaBusNetDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBusNetDef_doc[] = 
"Class: oaBusNetDef\n"
"  The oaBusNetDef class implements the definition of a busNet, including its base name and bit-range. All busNets and busNetBits in a block with the same base name are managed by the same busNet definition. The oaBusNetDef class tracks the minimum and maximum indices referred to by all of its corresponding oaBusNetBit objects.\n"
"  A busNetDef can be 'sparse' (have missing bits). Busses do not have to start or end at zero. For example, a[22:25] is a legal bus name. Bus indexes must be non-negative.\n"
"  An oaBusNetDef is automatically created if necessary whenever applications create busNets. Implicitly created busNet definitions have no bitOrder. Applications may explicitly create a busNet definition in order to specify that it has a specific bitOrder.\n"
"  Implicitly created busNet definitions are automatically destroyed when the last busNet with the same base name is destroyed. Explicitly created busNet definitions must be explicitly destroyed.\n"
"  The oaBusNetDef class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaBusNetDef)\n"
"    Calls: (const oaBusNetDef&)\n"
"    Signature: oaBusNetDef||cref-oaBusNetDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBusNetDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBusNetDef",
    sizeof(PyoaBusNetDefObject),
    0,
    (destructor)oaBusNetDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBusNetDef_tp_compare,	/* tp_compare */
    (reprfunc)oaBusNetDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBusNetDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBusNetDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaBlockObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBusNetDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBusNetDef_static_create_doc[] = 
"Class: oaBusNetDef, Function: create\n"
"  Paramegers: (oaBlock,oaScalarName,oaBitOrder)\n"
"    Calls: oaBusNetDef* create(const oaBlock* block,const oaScalarName& name,oaBitOrder order)\n"
"    Signature: create|ptr-oaBusNetDef|cptr-oaBlock,cref-oaScalarName,simple-oaBitOrder,\n"
"    This function creates an oaBusNetDef in the specified block with the given base name and bit order. An exception is thrown if an oaBusNetDef already exists with the specified name . Explicitly creating an oaBusNetDef also means that the busNet definition must be explicitly destroyed.\n"
"    The bit order of an explicit oaBusNetDef is independent of the order within individual oaBusNets with the same base name. Verilog requires a single wire declaration for a given base name, and the range of that declaration covers all of the bit indices used by the sub-ranges that correspond to oaBusNets.\n"
"    block\n"
"    The block to create the oaBusNetDef object in\n"
"    name\n"
"    The base name for the oaBusNetDef\n"
"    order\n"
"    The bit order for the oaBusNetDef\n"
"    oacBusNetDefAlreadyExists\n"
;

static PyObject*
oaBusNetDef_static_create(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaScalarName p2;
    PyParamoaBitOrder p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaBitOrder_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBusNetDefp result= (oaBusNetDef::create(p1.Data(),p2.Data(),p3.Data()));
        return PyoaBusNetDef_FromoaBusNetDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusNetDef_static_find_doc[] = 
"Class: oaBusNetDef, Function: find\n"
"  Paramegers: (oaBlock,oaScalarName)\n"
"    Calls: oaBusNetDef* find(const oaBlock* block,const oaScalarName& name)\n"
"    Signature: find|ptr-oaBusNetDef|cptr-oaBlock,cref-oaScalarName,\n"
"    This function searches the specified block for an oaBusNetDef with the specified name. The oaBusNetDef is returned if found. Otherwise, NULL is returned.\n"
"    block\n"
"    The block to search for the oaBusNetDef object\n"
"    name\n"
"    The name of the oaBusNetDef to find\n"
;

static PyObject*
oaBusNetDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBusNetDefp result= (oaBusNetDef::find(p1.Data(),p2.Data()));
        return PyoaBusNetDef_FromoaBusNetDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBusNetDef_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaBusNetDef_static_create,METH_VARARGS,oaBusNetDef_static_create_doc},
    {"static_find",(PyCFunction)oaBusNetDef_static_find,METH_VARARGS,oaBusNetDef_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBusNetDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBusNetDef_Type)<0) {
      printf("** PyType_Ready failed for: oaBusNetDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBusNetDef",
           (PyObject*)(&PyoaBusNetDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBusNetDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBusNetDef_Type.tp_dict;
    for(method=oaBusNetDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBusNetDefModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaBusNetDefModTypeEnum_Convert(PyObject* ob,PyParamoaBusNetDefModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacSetImplicitBusNetDefModType")==0) { result->SetData(oacSetImplicitBusNetDefModType); return 1;}
        if (strcasecmp(str,"oacSetBitOrderBusNetDefModType")==0) { result->SetData(oacSetBitOrderBusNetDefModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaBusNetDefModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBusNetDefModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaBusNetDefModTypeEnum_FromoaBusNetDefModTypeEnum(oaBusNetDefModTypeEnum ob)
{
    if (ob==oacSetImplicitBusNetDefModType) return PyString_FromString("oacSetImplicitBusNetDefModType");
    if (ob==oacSetBitOrderBusNetDefModType) return PyString_FromString("oacSetBitOrderBusNetDefModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaBusNetDefModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaBusNetDefModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaBusNetDefModTypeEnum_FromoaBusNetDefModTypeEnum(oaBusNetDefModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaBusNetDefModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaBusNetDefModTypeEnum_doc[] =
"Type convert function for enum: oaBusNetDefModTypeEnum";
                               
static PyMethodDef PyoaBusNetDefModTypeEnum_method =
  {"oaBusNetDefModTypeEnum",(PyCFunction)PyoaBusNetDefModTypeEnum_TypeFunction,METH_VARARGS,oaBusNetDefModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaBusNetDefModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacSetImplicitBusNetDefModType");
    PyDict_SetItemString(mod_dict,"oacSetImplicitBusNetDefModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetBitOrderBusNetDefModType");
    PyDict_SetItemString(mod_dict,"oacSetBitOrderBusNetDefModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaBusNetDefModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaBusNetDefModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaBusNetDefModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBusTerm
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBusTerm_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBusTerm_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBusTermObject* self = (PyoaBusTermObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBusTerm)
    {
        PyParamoaBusTerm p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBusTerm_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBusTerm, Choices are:\n"
        "    (oaBusTerm)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBusTerm_tp_dealloc(PyoaBusTermObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBusTerm_tp_repr(PyObject *ob)
{
    PyParamoaBusTerm value;
    int convert_status=PyoaBusTerm_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaBusTerm::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[31];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaBusTerm::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBusTerm_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBusTerm v1;
    PyParamoaBusTerm v2;
    int convert_status1=PyoaBusTerm_Convert(ob1,&v1);
    int convert_status2=PyoaBusTerm_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBusTerm_Convert(PyObject* ob,PyParamoaBusTerm* result)
{
    if (ob == NULL) return 1;
    if (PyoaBusTerm_Check(ob)) {
        result->SetData( (oaBusTerm**) ((PyoaBusTermObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBusTerm Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBusTerm_FromoaBusTerm(oaBusTerm** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBusTerm* data=*value;
        PyObject* bself = PyoaBusTerm_Type.tp_alloc(&PyoaBusTerm_Type,0);
        if (bself == NULL) return bself;
        PyoaBusTermObject* self = (PyoaBusTermObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBusTerm_FromoaBusTerm(oaBusTerm* data)
{
    if (data) {
       PyObject* bself = PyoaBusTerm_Type.tp_alloc(&PyoaBusTerm_Type,0);
       if (bself == NULL) return bself;
       PyoaBusTermObject* self = (PyoaBusTermObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBusTerm_getDef_doc[] = 
"Class: oaBusTerm, Function: getDef\n"
"  Paramegers: ()\n"
"    Calls: oaBusTermDef* getDef() const\n"
"    Signature: getDef|ptr-oaBusTermDef|\n"
"    BrowseData: 1\n"
"    This function returns the oaBusTermDef for this oaBusTerm object.\n"
"    A pointer to an oaBusTermDef\n"
;

static PyObject*
oaBusTerm_getDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusTerm data;
    int convert_status=PyoaBusTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusTermObject* self=(PyoaBusTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBusTermDefp result= (data.DataCall()->getDef());
        return PyoaBusTermDef_FromoaBusTermDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTerm_getName_doc[] = 
"Class: oaBusTerm, Function: getName\n"
"  Paramegers: (oaVectorName)\n"
"    Calls: void getName(oaVectorName& name) const\n"
"    Signature: getName|void-void|ref-oaVectorName,\n"
"    BrowseData: 0,oaVectorName\n"
"    This function returns the name of this oaBusTerm\n"
"    name\n"
"    The name of the oaBusTerm to return\n"
"  Paramegers: (oaName)\n"
"    Calls: void getName(oaName& name) const\n"
"    Signature: getName|void-void|ref-oaName,\n"
"    BrowseData: 0,oaName\n"
"    This function fills out name with the name of this terminal.\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function fills in name with the name of this terminal mapped to the specified nameSpace.\n"
;

static PyObject*
oaBusTerm_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusTerm data;
    int convert_status=PyoaBusTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusTermObject* self=(PyoaBusTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaVectorName)
    {
        PyParamoaVectorName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaName)
    {
        PyParamoaName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBusTerm, function: getName, Choices are:\n"
        "    (oaVectorName)\n"
        "    (oaName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTerm_getStart_doc[] = 
"Class: oaBusTerm, Function: getStart\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getStart() const\n"
"    Signature: getStart|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the starting index for this oaBusTerm object.\n"
"    The starting index for this oaBusTerm\n"
;

static PyObject*
oaBusTerm_getStart(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusTerm data;
    int convert_status=PyoaBusTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusTermObject* self=(PyoaBusTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getStart());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTerm_getStep_doc[] = 
"Class: oaBusTerm, Function: getStep\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getStep() const\n"
"    Signature: getStep|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the stepping index for this oaBusTerm object.\n"
"    The step value for this oaBusTerm\n"
;

static PyObject*
oaBusTerm_getStep(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusTerm data;
    int convert_status=PyoaBusTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusTermObject* self=(PyoaBusTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getStep());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTerm_getStop_doc[] = 
"Class: oaBusTerm, Function: getStop\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getStop() const\n"
"    Signature: getStop|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the ending index for this oaBusTerm object.\n"
"    The ending index for this oaBusTerm\n"
;

static PyObject*
oaBusTerm_getStop(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusTerm data;
    int convert_status=PyoaBusTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusTermObject* self=(PyoaBusTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getStop());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTerm_setBaseName_doc[] = 
"Class: oaBusTerm, Function: setBaseName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void setBaseName(const oaScalarName& name)\n"
"    Signature: setBaseName|void-void|cref-oaScalarName,\n"
"    This function changes the baseName of this oaBusTerm.\n"
"    name\n"
"    The baseName for the terminal\n"
"    oacBusTermBaseNameMatchesScalarName\n"
"    oacCannotSetNameOfImplicitTerm\n"
"    oacCannotSetNameOfTermInBundleTerm\n"
"    oacNetTermWidthMismatch\n"
"    oacTermExists\n"
"    oacTermMemberExists\n"
;

static PyObject*
oaBusTerm_setBaseName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusTerm data;
    int convert_status=PyoaBusTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusTermObject* self=(PyoaBusTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScalarName p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaScalarName_Convert,&p1)) {
        data.DataCall()->setBaseName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTerm_setRange_doc[] = 
"Class: oaBusTerm, Function: setRange\n"
"  Paramegers: (oaUInt4,oaUInt4)\n"
"    Calls: void setRange(oaUInt4 start,oaUInt4 stop)\n"
"    Signature: setRange|void-void|simple-oaUInt4,simple-oaUInt4,\n"
"    This function changes the vector range for this oaBusTerm. The new number of bits implied by the specified start and stop bits must match the current numBits . This restriction is necessary because the number of bits must match the number of bits of the net that is associated with this oaBusTerm object.\n"
"    start\n"
"    The starting index of the terminal\n"
"    stop\n"
"    The stopping index of the terminal\n"
"    oacCannotSetNameOfImplicitTerm\n"
"    oacCannotSetNameOfTermInBundleTerm\n"
"    oacTermExists\n"
"    oacInvalidBusStartStopRange\n"
;

static PyObject*
oaBusTerm_setRange(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusTerm data;
    int convert_status=PyoaBusTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusTermObject* self=(PyoaBusTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2)) {
        data.DataCall()->setRange(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTerm_isNull_doc[] =
"Class: oaBusTerm, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBusTerm_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBusTerm data;
    int convert_status=PyoaBusTerm_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBusTerm_assign_doc[] = 
"Class: oaBusTerm, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBusTerm_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBusTerm data;
  int convert_status=PyoaBusTerm_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBusTerm p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBusTerm_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBusTerm_methodlist[] = {
    {"getDef",(PyCFunction)oaBusTerm_getDef,METH_VARARGS,oaBusTerm_getDef_doc},
    {"getName",(PyCFunction)oaBusTerm_getName,METH_VARARGS,oaBusTerm_getName_doc},
    {"getStart",(PyCFunction)oaBusTerm_getStart,METH_VARARGS,oaBusTerm_getStart_doc},
    {"getStep",(PyCFunction)oaBusTerm_getStep,METH_VARARGS,oaBusTerm_getStep_doc},
    {"getStop",(PyCFunction)oaBusTerm_getStop,METH_VARARGS,oaBusTerm_getStop_doc},
    {"setBaseName",(PyCFunction)oaBusTerm_setBaseName,METH_VARARGS,oaBusTerm_setBaseName_doc},
    {"setRange",(PyCFunction)oaBusTerm_setRange,METH_VARARGS,oaBusTerm_setRange_doc},
    {"isNull",(PyCFunction)oaBusTerm_tp_isNull,METH_VARARGS,oaBusTerm_isNull_doc},
    {"assign",(PyCFunction)oaBusTerm_tp_assign,METH_VARARGS,oaBusTerm_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBusTerm_doc[] = 
"Class: oaBusTerm\n"
"  The oaBusTerm class implements a terminal that represents one or more bits that are associated by a common baseName and vector-range specification. An oaBusTerm object has a corresponding oaBusTermDef object that manages all oaBusTerm objects that share the same baseName.\n"
"Constructors:\n"
"  Paramegers: (oaBusTerm)\n"
"    Calls: (const oaBusTerm&)\n"
"    Signature: oaBusTerm||cref-oaBusTerm,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBusTerm_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBusTerm",
    sizeof(PyoaBusTermObject),
    0,
    (destructor)oaBusTerm_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBusTerm_tp_compare,	/* tp_compare */
    (reprfunc)oaBusTerm_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBusTerm_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBusTerm_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaTerm_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBusTerm_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBusTerm_static_create_doc[] = 
"Class: oaBusTerm, Function: create\n"
"  Paramegers: (oaNet,oaScalarName,oaUInt4,oaUInt4,oaUInt4)\n"
"    Calls: oaBusTerm* create(oaNet* net,const oaScalarName& name,oaUInt4 start,oaUInt4 stop,oaUInt4 step)\n"
"    Signature: create|ptr-oaBusTerm|ptr-oaNet,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,simple-oaUInt4,simple-oaTermType,simple-oaBlockDomainVisibility,\n"
"    This function creates an oaBusTerm object with the specified attributes. The specified baseName and start , stop , and step indices are first checked to verify they are legal and do not specify an oaBusTerm object that already exists.\n"
"    net\n"
"    The net to use to create the oaBusTerm\n"
"    name\n"
"    The baseName for the oaBusTerm\n"
"    start\n"
"    The starting index of the oaBusTerm\n"
"    stop\n"
"    The stopping index of the oaBusTerm\n"
"    step\n"
"    The step value of the oaBusTerm\n"
"    termType\n"
"    The terminal type of the oaBusTerm\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaBusTerm\n"
"    oacBusTermBaseNameMatchesScalarName\n"
"    oacCannotCreateTermWithImplicitNet\n"
"    oacNetTermWidthMismatch\n"
"    oacTermExists\n"
"    oacTermMemberExists\n"
"    oacTermNetMustBeInUniqueOccHier\n"
"  Paramegers: (oaNet,oaScalarName,oaUInt4,oaUInt4,oaUInt4,oaTermType)\n"
"    Calls: oaBusTerm* create(oaNet* net,const oaScalarName& name,oaUInt4 start,oaUInt4 stop,oaUInt4 step,oaTermType termType)\n"
"    Signature: create|ptr-oaBusTerm|ptr-oaNet,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,simple-oaUInt4,simple-oaTermType,simple-oaBlockDomainVisibility,\n"
"    This function creates an oaBusTerm object with the specified attributes. The specified baseName and start , stop , and step indices are first checked to verify they are legal and do not specify an oaBusTerm object that already exists.\n"
"    net\n"
"    The net to use to create the oaBusTerm\n"
"    name\n"
"    The baseName for the oaBusTerm\n"
"    start\n"
"    The starting index of the oaBusTerm\n"
"    stop\n"
"    The stopping index of the oaBusTerm\n"
"    step\n"
"    The step value of the oaBusTerm\n"
"    termType\n"
"    The terminal type of the oaBusTerm\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaBusTerm\n"
"    oacBusTermBaseNameMatchesScalarName\n"
"    oacCannotCreateTermWithImplicitNet\n"
"    oacNetTermWidthMismatch\n"
"    oacTermExists\n"
"    oacTermMemberExists\n"
"    oacTermNetMustBeInUniqueOccHier\n"
"  Paramegers: (oaNet,oaScalarName,oaUInt4,oaUInt4,oaUInt4,oaTermType,oaBlockDomainVisibility)\n"
"    Calls: oaBusTerm* create(oaNet* net,const oaScalarName& name,oaUInt4 start,oaUInt4 stop,oaUInt4 step,oaTermType termType,oaBlockDomainVisibility view)\n"
"    Signature: create|ptr-oaBusTerm|ptr-oaNet,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,simple-oaUInt4,simple-oaTermType,simple-oaBlockDomainVisibility,\n"
"    This function creates an oaBusTerm object with the specified attributes. The specified baseName and start , stop , and step indices are first checked to verify they are legal and do not specify an oaBusTerm object that already exists.\n"
"    net\n"
"    The net to use to create the oaBusTerm\n"
"    name\n"
"    The baseName for the oaBusTerm\n"
"    start\n"
"    The starting index of the oaBusTerm\n"
"    stop\n"
"    The stopping index of the oaBusTerm\n"
"    step\n"
"    The step value of the oaBusTerm\n"
"    termType\n"
"    The terminal type of the oaBusTerm\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaBusTerm\n"
"    oacBusTermBaseNameMatchesScalarName\n"
"    oacCannotCreateTermWithImplicitNet\n"
"    oacNetTermWidthMismatch\n"
"    oacTermExists\n"
"    oacTermMemberExists\n"
"    oacTermNetMustBeInUniqueOccHier\n"
"  Paramegers: (oaNet,oaVectorName)\n"
"    Calls: oaBusTerm* create(oaNet* net,const oaVectorName& name)\n"
"    Signature: create|ptr-oaBusTerm|ptr-oaNet,cref-oaVectorName,simple-oaTermType,simple-oaBlockDomainVisibility,\n"
"    This function creates an oaBusTerm object with the specified attributes. This function takes an oaVectorName and creates a multi-bit oaBusTerm object on the specified net .\n"
"    net\n"
"    The net to use to create the oaBusTerm\n"
"    name\n"
"    The baseName, start, stop, and step values to use to create the oaBusTerm\n"
"    termType\n"
"    The type of terminal to create\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaBusTerm\n"
"    oacBusTermBaseNameMatchesScalarName\n"
"    oacNetTermWidthMismatch\n"
"    oacTermExists\n"
"    oacTermMemberExists\n"
"    oacCannotCreateTermWithImplicitNet\n"
"    oacTermNetMustBeInUniqueOccHier\n"
"  Paramegers: (oaNet,oaVectorName,oaTermType)\n"
"    Calls: oaBusTerm* create(oaNet* net,const oaVectorName& name,oaTermType termType)\n"
"    Signature: create|ptr-oaBusTerm|ptr-oaNet,cref-oaVectorName,simple-oaTermType,simple-oaBlockDomainVisibility,\n"
"    This function creates an oaBusTerm object with the specified attributes. This function takes an oaVectorName and creates a multi-bit oaBusTerm object on the specified net .\n"
"    net\n"
"    The net to use to create the oaBusTerm\n"
"    name\n"
"    The baseName, start, stop, and step values to use to create the oaBusTerm\n"
"    termType\n"
"    The type of terminal to create\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaBusTerm\n"
"    oacBusTermBaseNameMatchesScalarName\n"
"    oacNetTermWidthMismatch\n"
"    oacTermExists\n"
"    oacTermMemberExists\n"
"    oacCannotCreateTermWithImplicitNet\n"
"    oacTermNetMustBeInUniqueOccHier\n"
"  Paramegers: (oaNet,oaVectorName,oaTermType,oaBlockDomainVisibility)\n"
"    Calls: oaBusTerm* create(oaNet* net,const oaVectorName& name,oaTermType termType,oaBlockDomainVisibility view)\n"
"    Signature: create|ptr-oaBusTerm|ptr-oaNet,cref-oaVectorName,simple-oaTermType,simple-oaBlockDomainVisibility,\n"
"    This function creates an oaBusTerm object with the specified attributes. This function takes an oaVectorName and creates a multi-bit oaBusTerm object on the specified net .\n"
"    net\n"
"    The net to use to create the oaBusTerm\n"
"    name\n"
"    The baseName, start, stop, and step values to use to create the oaBusTerm\n"
"    termType\n"
"    The type of terminal to create\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaBusTerm\n"
"    oacBusTermBaseNameMatchesScalarName\n"
"    oacNetTermWidthMismatch\n"
"    oacTermExists\n"
"    oacTermMemberExists\n"
"    oacCannotCreateTermWithImplicitNet\n"
"    oacTermNetMustBeInUniqueOccHier\n"
"  Paramegers: (oaNet,oaVectorBitName)\n"
"    Calls: oaBusTerm* create(oaNet* net,const oaVectorBitName& name)\n"
"    Signature: create|ptr-oaBusTerm|ptr-oaNet,cref-oaVectorBitName,simple-oaTermType,simple-oaBlockDomainVisibility,\n"
"    This function creates an oaBusTerm object with the specified attributes. This function takes an oaVectorBitName and creates a single-bit oaBusTerm object on the specified net .\n"
"    net\n"
"    The net to use to create the oaBusTerm\n"
"    name\n"
"    The baseName and bit index to use to create the oaBusTerm\n"
"    termType\n"
"    The type of terminal to create\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaBusTerm\n"
"    oacBusTermBaseNameMatchesScalarName\n"
"    oacNetTermWidthMismatch\n"
"    oacTermExists\n"
"    oacTermMemberExists\n"
"    oacCannotCreateTermWithImplicitNet\n"
"    oacTermNetMustBeInUniqueOccHier\n"
"  Paramegers: (oaNet,oaVectorBitName,oaTermType)\n"
"    Calls: oaBusTerm* create(oaNet* net,const oaVectorBitName& name,oaTermType termType)\n"
"    Signature: create|ptr-oaBusTerm|ptr-oaNet,cref-oaVectorBitName,simple-oaTermType,simple-oaBlockDomainVisibility,\n"
"    This function creates an oaBusTerm object with the specified attributes. This function takes an oaVectorBitName and creates a single-bit oaBusTerm object on the specified net .\n"
"    net\n"
"    The net to use to create the oaBusTerm\n"
"    name\n"
"    The baseName and bit index to use to create the oaBusTerm\n"
"    termType\n"
"    The type of terminal to create\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaBusTerm\n"
"    oacBusTermBaseNameMatchesScalarName\n"
"    oacNetTermWidthMismatch\n"
"    oacTermExists\n"
"    oacTermMemberExists\n"
"    oacCannotCreateTermWithImplicitNet\n"
"    oacTermNetMustBeInUniqueOccHier\n"
"  Paramegers: (oaNet,oaVectorBitName,oaTermType,oaBlockDomainVisibility)\n"
"    Calls: oaBusTerm* create(oaNet* net,const oaVectorBitName& name,oaTermType termType,oaBlockDomainVisibility view)\n"
"    Signature: create|ptr-oaBusTerm|ptr-oaNet,cref-oaVectorBitName,simple-oaTermType,simple-oaBlockDomainVisibility,\n"
"    This function creates an oaBusTerm object with the specified attributes. This function takes an oaVectorBitName and creates a single-bit oaBusTerm object on the specified net .\n"
"    net\n"
"    The net to use to create the oaBusTerm\n"
"    name\n"
"    The baseName and bit index to use to create the oaBusTerm\n"
"    termType\n"
"    The type of terminal to create\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaBusTerm\n"
"    oacBusTermBaseNameMatchesScalarName\n"
"    oacNetTermWidthMismatch\n"
"    oacTermExists\n"
"    oacTermMemberExists\n"
"    oacCannotCreateTermWithImplicitNet\n"
"    oacTermNetMustBeInUniqueOccHier\n"
;

static PyObject*
oaBusTerm_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaNet,oaScalarName,oaUInt4,oaUInt4,oaUInt4)
    {
        PyParamoaNet p1;
        PyParamoaScalarName p2;
        PyParamoaUInt4 p3;
        PyParamoaUInt4 p4;
        PyParamoaUInt4 p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaNet_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaUInt4_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaUInt4_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusTermp result= (oaBusTerm::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
            return PyoaBusTerm_FromoaBusTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaNet,oaScalarName,oaUInt4,oaUInt4,oaUInt4,oaTermType)
    {
        PyParamoaNet p1;
        PyParamoaScalarName p2;
        PyParamoaUInt4 p3;
        PyParamoaUInt4 p4;
        PyParamoaUInt4 p5;
        PyParamoaTermType p6;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&",
              &PyoaNet_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaUInt4_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaUInt4_Convert,&p5,
              &PyoaTermType_Convert,&p6)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusTermp result= (oaBusTerm::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data()));
            return PyoaBusTerm_FromoaBusTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaNet,oaScalarName,oaUInt4,oaUInt4,oaUInt4,oaTermType,oaBlockDomainVisibility)
    {
        PyParamoaNet p1;
        PyParamoaScalarName p2;
        PyParamoaUInt4 p3;
        PyParamoaUInt4 p4;
        PyParamoaUInt4 p5;
        PyParamoaTermType p6;
        PyParamoaBlockDomainVisibility p7;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&",
              &PyoaNet_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaUInt4_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaUInt4_Convert,&p5,
              &PyoaTermType_Convert,&p6,
              &PyoaBlockDomainVisibility_Convert,&p7)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusTermp result= (oaBusTerm::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data()));
            return PyoaBusTerm_FromoaBusTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaNet,oaVectorName)
    {
        PyParamoaNet p1;
        PyParamoaVectorName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNet_Convert,&p1,
              &PyoaVectorName_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusTermp result= (oaBusTerm::create(p1.Data(),p2.Data()));
            return PyoaBusTerm_FromoaBusTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaNet,oaVectorName,oaTermType)
    {
        PyParamoaNet p1;
        PyParamoaVectorName p2;
        PyParamoaTermType p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaNet_Convert,&p1,
              &PyoaVectorName_Convert,&p2,
              &PyoaTermType_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusTermp result= (oaBusTerm::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBusTerm_FromoaBusTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaNet,oaVectorName,oaTermType,oaBlockDomainVisibility)
    {
        PyParamoaNet p1;
        PyParamoaVectorName p2;
        PyParamoaTermType p3;
        PyParamoaBlockDomainVisibility p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaNet_Convert,&p1,
              &PyoaVectorName_Convert,&p2,
              &PyoaTermType_Convert,&p3,
              &PyoaBlockDomainVisibility_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusTermp result= (oaBusTerm::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBusTerm_FromoaBusTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaNet,oaVectorBitName)
    {
        PyParamoaNet p1;
        PyParamoaVectorBitName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNet_Convert,&p1,
              &PyoaVectorBitName_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusTermp result= (oaBusTerm::create(p1.Data(),p2.Data()));
            return PyoaBusTerm_FromoaBusTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaNet,oaVectorBitName,oaTermType)
    {
        PyParamoaNet p1;
        PyParamoaVectorBitName p2;
        PyParamoaTermType p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaNet_Convert,&p1,
              &PyoaVectorBitName_Convert,&p2,
              &PyoaTermType_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusTermp result= (oaBusTerm::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBusTerm_FromoaBusTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaNet,oaVectorBitName,oaTermType,oaBlockDomainVisibility)
    {
        PyParamoaNet p1;
        PyParamoaVectorBitName p2;
        PyParamoaTermType p3;
        PyParamoaBlockDomainVisibility p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaNet_Convert,&p1,
              &PyoaVectorBitName_Convert,&p2,
              &PyoaTermType_Convert,&p3,
              &PyoaBlockDomainVisibility_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusTermp result= (oaBusTerm::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBusTerm_FromoaBusTerm(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBusTerm, function: create, Choices are:\n"
        "    (oaNet,oaScalarName,oaUInt4,oaUInt4,oaUInt4)\n"
        "    (oaNet,oaScalarName,oaUInt4,oaUInt4,oaUInt4,oaTermType)\n"
        "    (oaNet,oaScalarName,oaUInt4,oaUInt4,oaUInt4,oaTermType,oaBlockDomainVisibility)\n"
        "    (oaNet,oaVectorName)\n"
        "    (oaNet,oaVectorName,oaTermType)\n"
        "    (oaNet,oaVectorName,oaTermType,oaBlockDomainVisibility)\n"
        "    (oaNet,oaVectorBitName)\n"
        "    (oaNet,oaVectorBitName,oaTermType)\n"
        "    (oaNet,oaVectorBitName,oaTermType,oaBlockDomainVisibility)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTerm_static_find_doc[] = 
"Class: oaBusTerm, Function: find\n"
"  Paramegers: (oaBlock,oaScalarName,oaUInt4,oaUInt4,oaUInt4)\n"
"    Calls: oaBusTerm* find(const oaBlock* block,const oaScalarName& name,oaUInt4 start,oaUInt4 stop,oaUInt4 step)\n"
"    Signature: find|ptr-oaBusTerm|cptr-oaBlock,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,simple-oaUInt4,\n"
"    This function searches the specified block for an oaBusTerm object with the specified baseName and start , stop , and step indices. The oaBusTerm object is returned if found. Otherwise, NULL is returned.\n"
"    block\n"
"    The block to search for the oaBusTerm\n"
"    baseName\n"
"    The baseName for the oaBusTerm\n"
"    start\n"
"    The starting index of the oaBusTerm\n"
"    stop\n"
"    The stopping index of the oaBusTerm\n"
"    step\n"
"    The step value of the oaBusTerm\n"
"    A pointer to an oaBusTerm\n"
;

static PyObject*
oaBusTerm_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaScalarName p2;
    PyParamoaUInt4 p3;
    PyParamoaUInt4 p4;
    PyParamoaUInt4 p5;
    if (PyArg_ParseTuple(args,"O&O&O&O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaUInt4_Convert,&p3,
          &PyoaUInt4_Convert,&p4,
          &PyoaUInt4_Convert,&p5)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBusTermp result= (oaBusTerm::find(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
        return PyoaBusTerm_FromoaBusTerm(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTerm_static_isValidName_doc[] = 
"Class: oaBusTerm, Function: isValidName\n"
"  Paramegers: (oaBlock,oaNet,oaScalarName,oaUInt4,oaUInt4,oaUInt4)\n"
"    Calls: oaBoolean isValidName(const oaBlock* block,const oaNet* net,const oaScalarName& name,oaUInt4 start,oaUInt4 stop,oaUInt4 step)\n"
"    Signature: isValidName|simple-oaBoolean|cptr-oaBlock,cptr-oaNet,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,simple-oaUInt4,\n"
"    This function returns a boolean value indicating whether the specified name is valid for a new oaBusTerm object that is associated with the specified net .\n"
"    block\n"
"    The block to search for the oaBusTerm\n"
"    net\n"
"    The net to use to create the oaBusTerm\n"
"    name\n"
"    The name for the new oaBusTerm\n"
"    start\n"
"    The starting index of the oaBusTerm\n"
"    stop\n"
"    The stopping index of the oaBusTerm\n"
"    step\n"
"    The step value of the oaBusTerm\n"
;

static PyObject*
oaBusTerm_static_isValidName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaNet p2;
    PyParamoaScalarName p3;
    PyParamoaUInt4 p4;
    PyParamoaUInt4 p5;
    PyParamoaUInt4 p6;
    if (PyArg_ParseTuple(args,"O&O&O&O&O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaNet_Convert,&p2,
          &PyoaScalarName_Convert,&p3,
          &PyoaUInt4_Convert,&p4,
          &PyoaUInt4_Convert,&p5,
          &PyoaUInt4_Convert,&p6)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!PyValidateDbObject(p2.Data(),2)) return NULL;
        oaBoolean result= (oaBusTerm::isValidName(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBusTerm_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaBusTerm_static_create,METH_VARARGS,oaBusTerm_static_create_doc},
    {"static_find",(PyCFunction)oaBusTerm_static_find,METH_VARARGS,oaBusTerm_static_find_doc},
    {"static_isValidName",(PyCFunction)oaBusTerm_static_isValidName,METH_VARARGS,oaBusTerm_static_isValidName_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBusTerm_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBusTerm_Type)<0) {
      printf("** PyType_Ready failed for: oaBusTerm\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBusTerm",
           (PyObject*)(&PyoaBusTerm_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBusTerm\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBusTerm_Type.tp_dict;
    for(method=oaBusTerm_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBusTermBit
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBusTermBit_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBusTermBit_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBusTermBitObject* self = (PyoaBusTermBitObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBusTermBit)
    {
        PyParamoaBusTermBit p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBusTermBit_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBusTermBit, Choices are:\n"
        "    (oaBusTermBit)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBusTermBit_tp_dealloc(PyoaBusTermBitObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBusTermBit_tp_repr(PyObject *ob)
{
    PyParamoaBusTermBit value;
    int convert_status=PyoaBusTermBit_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaBusTermBit::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[34];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaBusTermBit::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBusTermBit_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBusTermBit v1;
    PyParamoaBusTermBit v2;
    int convert_status1=PyoaBusTermBit_Convert(ob1,&v1);
    int convert_status2=PyoaBusTermBit_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBusTermBit_Convert(PyObject* ob,PyParamoaBusTermBit* result)
{
    if (ob == NULL) return 1;
    if (PyoaBusTermBit_Check(ob)) {
        result->SetData( (oaBusTermBit**) ((PyoaBusTermBitObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBusTermBit Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBusTermBit_FromoaBusTermBit(oaBusTermBit** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBusTermBit* data=*value;
        PyObject* bself = PyoaBusTermBit_Type.tp_alloc(&PyoaBusTermBit_Type,0);
        if (bself == NULL) return bself;
        PyoaBusTermBitObject* self = (PyoaBusTermBitObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBusTermBit_FromoaBusTermBit(oaBusTermBit* data)
{
    if (data) {
       PyObject* bself = PyoaBusTermBit_Type.tp_alloc(&PyoaBusTermBit_Type,0);
       if (bself == NULL) return bself;
       PyoaBusTermBitObject* self = (PyoaBusTermBitObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBusTermBit_getBitIndex_doc[] = 
"Class: oaBusTermBit, Function: getBitIndex\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getBitIndex() const\n"
"    Signature: getBitIndex|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the index for this busTermBit, with the respect of the corresponding busTermDef.\n"
;

static PyObject*
oaBusTermBit_getBitIndex(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusTermBit data;
    int convert_status=PyoaBusTermBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusTermBitObject* self=(PyoaBusTermBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getBitIndex());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTermBit_getDef_doc[] = 
"Class: oaBusTermBit, Function: getDef\n"
"  Paramegers: ()\n"
"    Calls: oaBusTermDef* getDef() const\n"
"    Signature: getDef|ptr-oaBusTermDef|\n"
"    BrowseData: 1\n"
"    This function returns the busTermDef associated with this terminal.\n"
;

static PyObject*
oaBusTermBit_getDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusTermBit data;
    int convert_status=PyoaBusTermBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusTermBitObject* self=(PyoaBusTermBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBusTermDefp result= (data.DataCall()->getDef());
        return PyoaBusTermDef_FromoaBusTermDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTermBit_getName_doc[] = 
"Class: oaBusTermBit, Function: getName\n"
"  Paramegers: (oaVectorBitName)\n"
"    Calls: void getName(oaVectorBitName& name) const\n"
"    Signature: getName|void-void|ref-oaVectorBitName,\n"
"    BrowseData: 0,oaVectorBitName\n"
"    This function returns the name of this oaBusTermBit.\n"
"    name\n"
"    The name of the oaBusTermBit to return\n"
"  Paramegers: (oaName)\n"
"    Calls: void getName(oaName& name) const\n"
"    Signature: getName|void-void|ref-oaName,\n"
"    BrowseData: 0,oaName\n"
"    This function fills out name with the name of this terminal.\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function fills in name with the name of this terminal mapped to the specified nameSpace.\n"
;

static PyObject*
oaBusTermBit_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusTermBit data;
    int convert_status=PyoaBusTermBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusTermBitObject* self=(PyoaBusTermBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaVectorBitName)
    {
        PyParamoaVectorBitName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorBitName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaName)
    {
        PyParamoaName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBusTermBit, function: getName, Choices are:\n"
        "    (oaVectorBitName)\n"
        "    (oaName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTermBit_setName_doc[] = 
"Class: oaBusTermBit, Function: setName\n"
"  Paramegers: (oaScalarName,oaUInt4)\n"
"    Calls: void setName(const oaScalarName& baseName,oaUInt4 bitIndex)\n"
"    Signature: setName|void-void|cref-oaScalarName,simple-oaUInt4,\n"
"    This function changes the name of this busTermBit to that implied by the given baseName and bitIndex .\n"
"    baseName\n"
"    The new base name for this net\n"
"    bitIndex\n"
"    The new bit index for this net\n"
"    oacCannotSetNameOfImplicitTerm\n"
"    oacCannotSetNameOfTermInBundleTerm\n"
"    oacBusTermBaseNameMatchesScalarName\n"
"    oacTermMemberExists\n"
"    oacTermExists\n"
;

static PyObject*
oaBusTermBit_setName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusTermBit data;
    int convert_status=PyoaBusTermBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusTermBitObject* self=(PyoaBusTermBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScalarName p1;
    PyParamoaUInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaScalarName_Convert,&p1,
          &PyoaUInt4_Convert,&p2)) {
        data.DataCall()->setName(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTermBit_isNull_doc[] =
"Class: oaBusTermBit, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBusTermBit_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBusTermBit data;
    int convert_status=PyoaBusTermBit_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBusTermBit_assign_doc[] = 
"Class: oaBusTermBit, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBusTermBit_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBusTermBit data;
  int convert_status=PyoaBusTermBit_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBusTermBit p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBusTermBit_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBusTermBit_methodlist[] = {
    {"getBitIndex",(PyCFunction)oaBusTermBit_getBitIndex,METH_VARARGS,oaBusTermBit_getBitIndex_doc},
    {"getDef",(PyCFunction)oaBusTermBit_getDef,METH_VARARGS,oaBusTermBit_getDef_doc},
    {"getName",(PyCFunction)oaBusTermBit_getName,METH_VARARGS,oaBusTermBit_getName_doc},
    {"setName",(PyCFunction)oaBusTermBit_setName,METH_VARARGS,oaBusTermBit_setName_doc},
    {"isNull",(PyCFunction)oaBusTermBit_tp_isNull,METH_VARARGS,oaBusTermBit_isNull_doc},
    {"assign",(PyCFunction)oaBusTermBit_tp_assign,METH_VARARGS,oaBusTermBit_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBusTermBit_doc[] = 
"Class: oaBusTermBit\n"
"  The oaBusTermBit class implements an oaBitTerm that represents a single bit of an oaBusTerm . When a busTerm is created, a corresponding set of busTermBits is automatically created. When the busTerm is destroyed, the automatically created busTermBits are also destroyed. An implicitly created busTermBit cannot be used to connect to terminals or instTerms, nor can it be associated with shapes or routes.\n"
"  An oaBusTermBit can be explicitly created and used in other operations like creating pins. An explicitly created busTermBit must be explicitly destroyed.\n"
"Constructors:\n"
"  Paramegers: (oaBusTermBit)\n"
"    Calls: (const oaBusTermBit&)\n"
"    Signature: oaBusTermBit||cref-oaBusTermBit,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBusTermBit_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBusTermBit",
    sizeof(PyoaBusTermBitObject),
    0,
    (destructor)oaBusTermBit_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBusTermBit_tp_compare,	/* tp_compare */
    (reprfunc)oaBusTermBit_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBusTermBit_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBusTermBit_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaBitTerm_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBusTermBit_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBusTermBit_static_create_doc[] = 
"Class: oaBusTermBit, Function: create\n"
"  Paramegers: (oaBitNet,oaScalarName,oaUInt4)\n"
"    Calls: oaBusTermBit* create(oaBitNet* net,const oaScalarName& baseName,oaUInt4 bitIndex)\n"
"    Signature: create|ptr-oaBusTermBit|ptr-oaBitNet,cref-oaScalarName,simple-oaUInt4,simple-oaTermType,simple-oaBlockDomainVisibility,\n"
"    This function creates a busTermBit with the specified baseName and bitIndex on the given net .\n"
"    net\n"
"    The net to create the terminal on\n"
"    baseName\n"
"    The base name to give the terminal\n"
"    bitIndex\n"
"    The bit index to give the terminal\n"
"    termType\n"
"    The type of terminal to create\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    oacBusTermBaseNameMatchesScalarName\n"
"    oacTermExists\n"
"    oacTermMemberExists\n"
"    oacCannotCreateTermWithImplicitNet\n"
"  Paramegers: (oaBitNet,oaScalarName,oaUInt4,oaTermType)\n"
"    Calls: oaBusTermBit* create(oaBitNet* net,const oaScalarName& baseName,oaUInt4 bitIndex,oaTermType termType)\n"
"    Signature: create|ptr-oaBusTermBit|ptr-oaBitNet,cref-oaScalarName,simple-oaUInt4,simple-oaTermType,simple-oaBlockDomainVisibility,\n"
"    This function creates a busTermBit with the specified baseName and bitIndex on the given net .\n"
"    net\n"
"    The net to create the terminal on\n"
"    baseName\n"
"    The base name to give the terminal\n"
"    bitIndex\n"
"    The bit index to give the terminal\n"
"    termType\n"
"    The type of terminal to create\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    oacBusTermBaseNameMatchesScalarName\n"
"    oacTermExists\n"
"    oacTermMemberExists\n"
"    oacCannotCreateTermWithImplicitNet\n"
"  Paramegers: (oaBitNet,oaScalarName,oaUInt4,oaTermType,oaBlockDomainVisibility)\n"
"    Calls: oaBusTermBit* create(oaBitNet* net,const oaScalarName& baseName,oaUInt4 bitIndex,oaTermType termType,oaBlockDomainVisibility view)\n"
"    Signature: create|ptr-oaBusTermBit|ptr-oaBitNet,cref-oaScalarName,simple-oaUInt4,simple-oaTermType,simple-oaBlockDomainVisibility,\n"
"    This function creates a busTermBit with the specified baseName and bitIndex on the given net .\n"
"    net\n"
"    The net to create the terminal on\n"
"    baseName\n"
"    The base name to give the terminal\n"
"    bitIndex\n"
"    The bit index to give the terminal\n"
"    termType\n"
"    The type of terminal to create\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    oacBusTermBaseNameMatchesScalarName\n"
"    oacTermExists\n"
"    oacTermMemberExists\n"
"    oacCannotCreateTermWithImplicitNet\n"
"  Paramegers: (oaBitNet,oaVectorBitName)\n"
"    Calls: oaBusTermBit* create(oaBitNet* net,const oaVectorBitName& bitName)\n"
"    Signature: create|ptr-oaBusTermBit|ptr-oaBitNet,cref-oaVectorBitName,simple-oaTermType,simple-oaBlockDomainVisibility,\n"
"    This function creates a busTermBit with the baseName and em bitIndex as specified in the given bitName on the given net .\n"
"    net\n"
"    The net to create the terminal on\n"
"    bitName\n"
"    The name supplying the baseName and bit index to give the terminal\n"
"    termType\n"
"    The type of terminal to create\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    oacBusTermBaseNameMatchesScalarName\n"
"    oacNetTermWidthMismatch\n"
"    oacTermExists\n"
"    oacTermMemberExists\n"
"    oacCannotCreateTermWithImplicitNet\n"
"  Paramegers: (oaBitNet,oaVectorBitName,oaTermType)\n"
"    Calls: oaBusTermBit* create(oaBitNet* net,const oaVectorBitName& bitName,oaTermType termType)\n"
"    Signature: create|ptr-oaBusTermBit|ptr-oaBitNet,cref-oaVectorBitName,simple-oaTermType,simple-oaBlockDomainVisibility,\n"
"    This function creates a busTermBit with the baseName and em bitIndex as specified in the given bitName on the given net .\n"
"    net\n"
"    The net to create the terminal on\n"
"    bitName\n"
"    The name supplying the baseName and bit index to give the terminal\n"
"    termType\n"
"    The type of terminal to create\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    oacBusTermBaseNameMatchesScalarName\n"
"    oacNetTermWidthMismatch\n"
"    oacTermExists\n"
"    oacTermMemberExists\n"
"    oacCannotCreateTermWithImplicitNet\n"
"  Paramegers: (oaBitNet,oaVectorBitName,oaTermType,oaBlockDomainVisibility)\n"
"    Calls: oaBusTermBit* create(oaBitNet* net,const oaVectorBitName& bitName,oaTermType termType,oaBlockDomainVisibility view)\n"
"    Signature: create|ptr-oaBusTermBit|ptr-oaBitNet,cref-oaVectorBitName,simple-oaTermType,simple-oaBlockDomainVisibility,\n"
"    This function creates a busTermBit with the baseName and em bitIndex as specified in the given bitName on the given net .\n"
"    net\n"
"    The net to create the terminal on\n"
"    bitName\n"
"    The name supplying the baseName and bit index to give the terminal\n"
"    termType\n"
"    The type of terminal to create\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    oacBusTermBaseNameMatchesScalarName\n"
"    oacNetTermWidthMismatch\n"
"    oacTermExists\n"
"    oacTermMemberExists\n"
"    oacCannotCreateTermWithImplicitNet\n"
;

static PyObject*
oaBusTermBit_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaBitNet,oaScalarName,oaUInt4)
    {
        PyParamoaBitNet p1;
        PyParamoaScalarName p2;
        PyParamoaUInt4 p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaBitNet_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaUInt4_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusTermBitp result= (oaBusTermBit::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBusTermBit_FromoaBusTermBit(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBitNet,oaScalarName,oaUInt4,oaTermType)
    {
        PyParamoaBitNet p1;
        PyParamoaScalarName p2;
        PyParamoaUInt4 p3;
        PyParamoaTermType p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaBitNet_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaUInt4_Convert,&p3,
              &PyoaTermType_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusTermBitp result= (oaBusTermBit::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBusTermBit_FromoaBusTermBit(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBitNet,oaScalarName,oaUInt4,oaTermType,oaBlockDomainVisibility)
    {
        PyParamoaBitNet p1;
        PyParamoaScalarName p2;
        PyParamoaUInt4 p3;
        PyParamoaTermType p4;
        PyParamoaBlockDomainVisibility p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaBitNet_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaUInt4_Convert,&p3,
              &PyoaTermType_Convert,&p4,
              &PyoaBlockDomainVisibility_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusTermBitp result= (oaBusTermBit::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
            return PyoaBusTermBit_FromoaBusTermBit(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBitNet,oaVectorBitName)
    {
        PyParamoaBitNet p1;
        PyParamoaVectorBitName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBitNet_Convert,&p1,
              &PyoaVectorBitName_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusTermBitp result= (oaBusTermBit::create(p1.Data(),p2.Data()));
            return PyoaBusTermBit_FromoaBusTermBit(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBitNet,oaVectorBitName,oaTermType)
    {
        PyParamoaBitNet p1;
        PyParamoaVectorBitName p2;
        PyParamoaTermType p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaBitNet_Convert,&p1,
              &PyoaVectorBitName_Convert,&p2,
              &PyoaTermType_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusTermBitp result= (oaBusTermBit::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaBusTermBit_FromoaBusTermBit(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBitNet,oaVectorBitName,oaTermType,oaBlockDomainVisibility)
    {
        PyParamoaBitNet p1;
        PyParamoaVectorBitName p2;
        PyParamoaTermType p3;
        PyParamoaBlockDomainVisibility p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaBitNet_Convert,&p1,
              &PyoaVectorBitName_Convert,&p2,
              &PyoaTermType_Convert,&p3,
              &PyoaBlockDomainVisibility_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBusTermBitp result= (oaBusTermBit::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaBusTermBit_FromoaBusTermBit(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBusTermBit, function: create, Choices are:\n"
        "    (oaBitNet,oaScalarName,oaUInt4)\n"
        "    (oaBitNet,oaScalarName,oaUInt4,oaTermType)\n"
        "    (oaBitNet,oaScalarName,oaUInt4,oaTermType,oaBlockDomainVisibility)\n"
        "    (oaBitNet,oaVectorBitName)\n"
        "    (oaBitNet,oaVectorBitName,oaTermType)\n"
        "    (oaBitNet,oaVectorBitName,oaTermType,oaBlockDomainVisibility)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTermBit_static_find_doc[] = 
"Class: oaBusTermBit, Function: find\n"
"  Paramegers: (oaBlock,oaScalarName,oaUInt4)\n"
"    Calls: oaBusTermBit* find(const oaBlock* block,const oaScalarName& baseName,oaUInt4 bitIndex)\n"
"    Signature: find|ptr-oaBusTermBit|cptr-oaBlock,cref-oaScalarName,simple-oaUInt4,\n"
"    This function searches the specified block for a busTermBit with the specified baseName and bitIndex . The busTermBit is returned if found. Otherwise, NULL is returned.\n"
"    block\n"
"    The block to search for the busTermBit\n"
"    baseName\n"
"    The base name for the busTermBit\n"
"    bitIndex\n"
"    The bit index for the busTermBit\n"
"    A pointer to an oaBusTermBit\n"
;

static PyObject*
oaBusTermBit_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaScalarName p2;
    PyParamoaUInt4 p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaUInt4_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBusTermBitp result= (oaBusTermBit::find(p1.Data(),p2.Data(),p3.Data()));
        return PyoaBusTermBit_FromoaBusTermBit(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTermBit_static_isValidName_doc[] = 
"Class: oaBusTermBit, Function: isValidName\n"
"  Paramegers: (oaBitNet,oaScalarName,oaUInt4)\n"
"    Calls: oaBoolean isValidName(const oaBitNet* net,const oaScalarName& baseName,oaUInt4 bitIndex)\n"
"    Signature: isValidName|simple-oaBoolean|cptr-oaBitNet,cref-oaScalarName,simple-oaUInt4,\n"
"    This function returns a boolean value indicating whether the specified name is valid for a new oaBusTermBit on the specified net.\n"
"    net\n"
"    The net to search\n"
"    baseName\n"
"    The base name of the bus bit\n"
"    bitIndex\n"
"    The bit index of the bus bit\n"
;

static PyObject*
oaBusTermBit_static_isValidName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBitNet p1;
    PyParamoaScalarName p2;
    PyParamoaUInt4 p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaBitNet_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaUInt4_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (oaBusTermBit::isValidName(p1.Data(),p2.Data(),p3.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBusTermBit_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaBusTermBit_static_create,METH_VARARGS,oaBusTermBit_static_create_doc},
    {"static_find",(PyCFunction)oaBusTermBit_static_find,METH_VARARGS,oaBusTermBit_static_find_doc},
    {"static_isValidName",(PyCFunction)oaBusTermBit_static_isValidName,METH_VARARGS,oaBusTermBit_static_isValidName_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBusTermBit_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBusTermBit_Type)<0) {
      printf("** PyType_Ready failed for: oaBusTermBit\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBusTermBit",
           (PyObject*)(&PyoaBusTermBit_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBusTermBit\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBusTermBit_Type.tp_dict;
    for(method=oaBusTermBit_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBusTermDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaBusTermDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaBusTermDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaBusTermDefObject* self = (PyoaBusTermDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaBusTermDef)
    {
        PyParamoaBusTermDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaBusTermDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaBusTermDef, Choices are:\n"
        "    (oaBusTermDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaBusTermDef_tp_dealloc(PyoaBusTermDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaBusTermDef_tp_repr(PyObject *ob)
{
    PyParamoaBusTermDef value;
    int convert_status=PyoaBusTermDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaBusTermDef::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaScalarName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[34];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaBusTermDef::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaBusTermDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaBusTermDef v1;
    PyParamoaBusTermDef v2;
    int convert_status1=PyoaBusTermDef_Convert(ob1,&v1);
    int convert_status2=PyoaBusTermDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaBusTermDef_Convert(PyObject* ob,PyParamoaBusTermDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaBusTermDef_Check(ob)) {
        result->SetData( (oaBusTermDef**) ((PyoaBusTermDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBusTermDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaBusTermDef_FromoaBusTermDef(oaBusTermDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaBusTermDef* data=*value;
        PyObject* bself = PyoaBusTermDef_Type.tp_alloc(&PyoaBusTermDef_Type,0);
        if (bself == NULL) return bself;
        PyoaBusTermDefObject* self = (PyoaBusTermDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaBusTermDef_FromoaBusTermDef(oaBusTermDef* data)
{
    if (data) {
       PyObject* bself = PyoaBusTermDef_Type.tp_alloc(&PyoaBusTermDef_Type,0);
       if (bself == NULL) return bself;
       PyoaBusTermDefObject* self = (PyoaBusTermDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBusTermDef_destroy_doc[] = 
"Class: oaBusTermDef, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function destroys this oaBusTermDef, removing it from the database. An exception is thrown if the oaBusTermDef is implicit or if there are still oaBusTerms associated with it.\n"
"    oacCannotDestroyImplicitBusTermDef\n"
"    oacCannotDestroyBusTermDefWithTerms\n"
;

static PyObject*
oaBusTermDef_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusTermDef data;
    int convert_status=PyoaBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusTermDefObject* self=(PyoaBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTermDef_getBitOrder_doc[] = 
"Class: oaBusTermDef, Function: getBitOrder\n"
"  Paramegers: ()\n"
"    Calls: oaBitOrder getBitOrder() const\n"
"    Signature: getBitOrder|simple-oaBitOrder|\n"
"    BrowseData: 1\n"
"    This function returns the bitOrder associated with this oaBusTermDef object.\n"
;

static PyObject*
oaBusTermDef_getBitOrder(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusTermDef data;
    int convert_status=PyoaBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusTermDefObject* self=(PyoaBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBitOrder* result= new oaBitOrder(data.DataCall()->getBitOrder());
        return PyoaBitOrder_FromoaBitOrder(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTermDef_getBusTermBits_doc[] = 
"Class: oaBusTermDef, Function: getBusTermBits\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaBusTermBit_oaBusTermDef getBusTermBits() const\n"
"    Signature: getBusTermBits|simple-oaCollection_oaBusTermBit_oaBusTermDef|\n"
"    BrowseData: 1\n"
"    This function returns a collection of oaBusTermBits in this oaBusTermDef object.\n"
;

static PyObject*
oaBusTermDef_getBusTermBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusTermDef data;
    int convert_status=PyoaBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusTermDefObject* self=(PyoaBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaBusTermBit_oaBusTermDef* result= new oaCollection_oaBusTermBit_oaBusTermDef(data.DataCall()->getBusTermBits());
        return PyoaCollection_oaBusTermBit_oaBusTermDef_FromoaCollection_oaBusTermBit_oaBusTermDef(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTermDef_getBusTermBitsIter_doc[] = 
"Class: oaBusTermDef, Function: getBusTermBitsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaBusTermBit getBusTermBitsIter() const\n"
"    Signature: getBusTermBitsIter|simple-oaIter_oaBusTermBit|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of oaBusTermBits in this oaBusTermDef object.\n"
;

static PyObject*
oaBusTermDef_getBusTermBitsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusTermDef data;
    int convert_status=PyoaBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusTermDefObject* self=(PyoaBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaBusTermBit* result= new oaIter_oaBusTermBit(data.DataCall()->getBusTermBits());
        return PyoaIter_oaBusTermBit_FromoaIter_oaBusTermBit(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTermDef_getBusTerms_doc[] = 
"Class: oaBusTermDef, Function: getBusTerms\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaBusTerm_oaBusTermDef getBusTerms() const\n"
"    Signature: getBusTerms|simple-oaCollection_oaBusTerm_oaBusTermDef|\n"
"    BrowseData: 1\n"
"    This function returns a collection of oaBusTerm objects in this oaBusTermDef object.\n"
;

static PyObject*
oaBusTermDef_getBusTerms(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusTermDef data;
    int convert_status=PyoaBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusTermDefObject* self=(PyoaBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaBusTerm_oaBusTermDef* result= new oaCollection_oaBusTerm_oaBusTermDef(data.DataCall()->getBusTerms());
        return PyoaCollection_oaBusTerm_oaBusTermDef_FromoaCollection_oaBusTerm_oaBusTermDef(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTermDef_getBusTermsIter_doc[] = 
"Class: oaBusTermDef, Function: getBusTermsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaBusTerm getBusTermsIter() const\n"
"    Signature: getBusTermsIter|simple-oaIter_oaBusTerm|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of oaBusTerm objects in this oaBusTermDef object.\n"
;

static PyObject*
oaBusTermDef_getBusTermsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusTermDef data;
    int convert_status=PyoaBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusTermDefObject* self=(PyoaBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaBusTerm* result= new oaIter_oaBusTerm(data.DataCall()->getBusTerms());
        return PyoaIter_oaBusTerm_FromoaIter_oaBusTerm(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTermDef_getMaxIndex_doc[] = 
"Class: oaBusTermDef, Function: getMaxIndex\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getMaxIndex() const\n"
"    Signature: getMaxIndex|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the largest bit number in use for this oaBusTermDef object. This is the largest index used across all oaBusTerms associated with this oaBusTermDef object.\n"
;

static PyObject*
oaBusTermDef_getMaxIndex(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusTermDef data;
    int convert_status=PyoaBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusTermDefObject* self=(PyoaBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getMaxIndex());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTermDef_getMinIndex_doc[] = 
"Class: oaBusTermDef, Function: getMinIndex\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getMinIndex() const\n"
"    Signature: getMinIndex|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the smallest bit number in use for this oaBusTermDef object. This is the smallest index used across all oaBusTerms associated with this oaBusTermDef object.\n"
;

static PyObject*
oaBusTermDef_getMinIndex(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusTermDef data;
    int convert_status=PyoaBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusTermDefObject* self=(PyoaBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getMinIndex());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTermDef_getName_doc[] = 
"Class: oaBusTermDef, Function: getName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getName(oaScalarName& name) const\n"
"    Signature: getName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the name of this oaBusTermDef object.\n"
"    name\n"
"    The scalar name in which to return the name of this oaBusTermDef\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the name string of this oaBusTermDef in the specified nameSpace.\n"
"    ns\n"
"    The nameSpace to use when getting the name string\n"
"    name\n"
"    Returns the string name of this oaBusTermDef\n"
;

static PyObject*
oaBusTermDef_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusTermDef data;
    int convert_status=PyoaBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusTermDefObject* self=(PyoaBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaBusTermDef, function: getName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTermDef_getNumBits_doc[] = 
"Class: oaBusTermDef, Function: getNumBits\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumBits() const\n"
"    Signature: getNumBits|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of bits covered by the busses in this oaBusTermDef. The number of bits is equal to abs(maxIndex - minIndex) + 1; it is not necessarily the number of busTermBits present in this busTermDef. To get the number of busTermBits in this busTermDef, use oaBusTermDef::getBusNetBits().getCount() .\n"
;

static PyObject*
oaBusTermDef_getNumBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusTermDef data;
    int convert_status=PyoaBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusTermDefObject* self=(PyoaBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumBits());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTermDef_isImplicit_doc[] = 
"Class: oaBusTermDef, Function: isImplicit\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isImplicit() const\n"
"    Signature: isImplicit|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether this oaBusTermDef was implicitly created or not.\n"
;

static PyObject*
oaBusTermDef_isImplicit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusTermDef data;
    int convert_status=PyoaBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusTermDefObject* self=(PyoaBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isImplicit());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTermDef_setBitOrder_doc[] = 
"Class: oaBusTermDef, Function: setBitOrder\n"
"  Paramegers: (oaBitOrder)\n"
"    Calls: void setBitOrder(oaBitOrder order)\n"
"    Signature: setBitOrder|void-void|simple-oaBitOrder,\n"
"    This function changes the bitOrder value associated with the oaBusTermDef. An exception is thrown if this busTermDef was implicitly created.\n"
"    order\n"
"    The new bitOrder value for this busTermDef\n"
"    oacBitOrderBusTermDefImplicit\n"
;

static PyObject*
oaBusTermDef_setBitOrder(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBusTermDef data;
    int convert_status=PyoaBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaBusTermDefObject* self=(PyoaBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBitOrder p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBitOrder_Convert,&p1)) {
        data.DataCall()->setBitOrder(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTermDef_isNull_doc[] =
"Class: oaBusTermDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaBusTermDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaBusTermDef data;
    int convert_status=PyoaBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaBusTermDef_assign_doc[] = 
"Class: oaBusTermDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaBusTermDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaBusTermDef data;
  int convert_status=PyoaBusTermDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaBusTermDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaBusTermDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaBusTermDef_methodlist[] = {
    {"destroy",(PyCFunction)oaBusTermDef_destroy,METH_VARARGS,oaBusTermDef_destroy_doc},
    {"getBitOrder",(PyCFunction)oaBusTermDef_getBitOrder,METH_VARARGS,oaBusTermDef_getBitOrder_doc},
    {"getBusTermBits",(PyCFunction)oaBusTermDef_getBusTermBits,METH_VARARGS,oaBusTermDef_getBusTermBits_doc},
    {"getBusTermBitsIter",(PyCFunction)oaBusTermDef_getBusTermBitsIter,METH_VARARGS,oaBusTermDef_getBusTermBitsIter_doc},
    {"getBusTerms",(PyCFunction)oaBusTermDef_getBusTerms,METH_VARARGS,oaBusTermDef_getBusTerms_doc},
    {"getBusTermsIter",(PyCFunction)oaBusTermDef_getBusTermsIter,METH_VARARGS,oaBusTermDef_getBusTermsIter_doc},
    {"getMaxIndex",(PyCFunction)oaBusTermDef_getMaxIndex,METH_VARARGS,oaBusTermDef_getMaxIndex_doc},
    {"getMinIndex",(PyCFunction)oaBusTermDef_getMinIndex,METH_VARARGS,oaBusTermDef_getMinIndex_doc},
    {"getName",(PyCFunction)oaBusTermDef_getName,METH_VARARGS,oaBusTermDef_getName_doc},
    {"getNumBits",(PyCFunction)oaBusTermDef_getNumBits,METH_VARARGS,oaBusTermDef_getNumBits_doc},
    {"isImplicit",(PyCFunction)oaBusTermDef_isImplicit,METH_VARARGS,oaBusTermDef_isImplicit_doc},
    {"setBitOrder",(PyCFunction)oaBusTermDef_setBitOrder,METH_VARARGS,oaBusTermDef_setBitOrder_doc},
    {"isNull",(PyCFunction)oaBusTermDef_tp_isNull,METH_VARARGS,oaBusTermDef_isNull_doc},
    {"assign",(PyCFunction)oaBusTermDef_tp_assign,METH_VARARGS,oaBusTermDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBusTermDef_doc[] = 
"Class: oaBusTermDef\n"
"  The oaBusTermDef class implements the definition of an oaBusTerm , including its base name and bit-range. All oaBusTerms and oaBusTermBits in a block with the same base name are managed by the same oaBusTermDef. The oaBusTermDef class tracks the minimum and maximum indices refered to by all of its corresponding busTermBit objects.\n"
"  A bus definition can be 'sparse' (have missing bits). Busses do not have to start or end at zero. For example, a<22:25> is a legal bus name. Bus indexes must be non-negative.\n"
"  An oaBusTermDef is automatically created if necessary whenever applications create oaBusTerms. Implicitly created oaBusTermDef have no bitOrder. Applications may explicitly create a oaBusTermDef in order to specify that it has a specific bitOrder.\n"
"  Implicitly created oaBusTermDefs are automatically destroyed when the last oaBusTerm with the same base name is destroyed. Explicitly created oaBusTermDefs must be explicitly destroyed.\n"
"  oaModBusTermDef , oaOccBusTermDef , and oaBusTermDef each manage the bus terminals on a different kind of master, where in each case the master represents a level of hierarchy in the design.\n"
"  For oaModBusTermDef , the master is an oaModule , and each module in a design will have a set of zero or more modBusTermDefs. For oaOccBusTerm , the master is an oaOccurrence .\n"
"  For oaBusTermDef, the master is an oaBlock , and the top block for the design will have a set of zero or more modBusTermDefs. Typically, many of the oaBusTermDefs on the top oaBlock have a corresponding oaModBusTermDef on the top oaModule . All of the oaBusTerms on the top oaBlock have a corresponding oaOccBusTerm on the top oaOccurrence .\n"
"  OpenAccess requires a consistent definition of bus terminals shared between the top module and the top block in a design. When an oaBusTerm has been created that is not visible in the module domain, it is not possible to create an oaModBusTerm that uses the same base name.\n"
"  The oaBusTermDef class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaBusTermDef)\n"
"    Calls: (const oaBusTermDef&)\n"
"    Signature: oaBusTermDef||cref-oaBusTermDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaBusTermDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaBusTermDef",
    sizeof(PyoaBusTermDefObject),
    0,
    (destructor)oaBusTermDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaBusTermDef_tp_compare,	/* tp_compare */
    (reprfunc)oaBusTermDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaBusTermDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaBusTermDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaBlockObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaBusTermDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaBusTermDef_static_create_doc[] = 
"Class: oaBusTermDef, Function: create\n"
"  Paramegers: (oaBlock,oaScalarName,oaBitOrder)\n"
"    Calls: oaBusTermDef* create(const oaBlock* block,const oaScalarName& name,oaBitOrder order)\n"
"    Signature: create|ptr-oaBusTermDef|cptr-oaBlock,cref-oaScalarName,simple-oaBitOrder,\n"
"    This function creates an oaBusTermDef in the specified block with the given base name and bit order. An exception is thrown if an oaBusTermDef already exists with the specified name . Explicitly creating an oaBusTermDef also means that the oaBusTermDef must be explicitly destroyed.\n"
"    block\n"
"    The block to create the oaBusTermDef object in\n"
"    name\n"
"    The base name for the oaBusTermDef\n"
"    order\n"
"    The bit order for the oaBusTermDef\n"
"    oacBusTermDefAlreadyExists\n"
;

static PyObject*
oaBusTermDef_static_create(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaScalarName p2;
    PyParamoaBitOrder p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaBitOrder_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBusTermDefp result= (oaBusTermDef::create(p1.Data(),p2.Data(),p3.Data()));
        return PyoaBusTermDef_FromoaBusTermDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaBusTermDef_static_find_doc[] = 
"Class: oaBusTermDef, Function: find\n"
"  Paramegers: (oaBlock,oaScalarName)\n"
"    Calls: oaBusTermDef* find(const oaBlock* block,const oaScalarName& name)\n"
"    Signature: find|ptr-oaBusTermDef|cptr-oaBlock,cref-oaScalarName,\n"
"    This function searches the specified design for a busTermDef with the specified name. The busTermDef is returned if found. Otherwise, NULL is returned.\n"
"    block\n"
"    The block to search for the oaBusTermDef object\n"
"    name\n"
"    The name of the oaBusTermDef to find\n"
;

static PyObject*
oaBusTermDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBusTermDefp result= (oaBusTermDef::find(p1.Data(),p2.Data()));
        return PyoaBusTermDef_FromoaBusTermDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaBusTermDef_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaBusTermDef_static_create,METH_VARARGS,oaBusTermDef_static_create_doc},
    {"static_find",(PyCFunction)oaBusTermDef_static_find,METH_VARARGS,oaBusTermDef_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaBusTermDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaBusTermDef_Type)<0) {
      printf("** PyType_Ready failed for: oaBusTermDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaBusTermDef",
           (PyObject*)(&PyoaBusTermDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaBusTermDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaBusTermDef_Type.tp_dict;
    for(method=oaBusTermDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaBusTermDefModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaBusTermDefModTypeEnum_Convert(PyObject* ob,PyParamoaBusTermDefModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacSetImplicitBusTermDefModType")==0) { result->SetData(oacSetImplicitBusTermDefModType); return 1;}
        if (strcasecmp(str,"oacSetBitOrderBusTermDefModType")==0) { result->SetData(oacSetBitOrderBusTermDefModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaBusTermDefModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaBusTermDefModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaBusTermDefModTypeEnum_FromoaBusTermDefModTypeEnum(oaBusTermDefModTypeEnum ob)
{
    if (ob==oacSetImplicitBusTermDefModType) return PyString_FromString("oacSetImplicitBusTermDefModType");
    if (ob==oacSetBitOrderBusTermDefModType) return PyString_FromString("oacSetBitOrderBusTermDefModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaBusTermDefModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaBusTermDefModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaBusTermDefModTypeEnum_FromoaBusTermDefModTypeEnum(oaBusTermDefModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaBusTermDefModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaBusTermDefModTypeEnum_doc[] =
"Type convert function for enum: oaBusTermDefModTypeEnum";
                               
static PyMethodDef PyoaBusTermDefModTypeEnum_method =
  {"oaBusTermDefModTypeEnum",(PyCFunction)PyoaBusTermDefModTypeEnum_TypeFunction,METH_VARARGS,oaBusTermDefModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaBusTermDefModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacSetImplicitBusTermDefModType");
    PyDict_SetItemString(mod_dict,"oacSetImplicitBusTermDefModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetBitOrderBusTermDefModType");
    PyDict_SetItemString(mod_dict,"oacSetBitOrderBusTermDefModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaBusTermDefModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaBusTermDefModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaBusTermDefModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaCMap
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaCMap_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaCMap_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaCMapObject* self = (PyoaCMapObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaCMap)
    {
        PyParamoaCMap p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaCMap_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaCMap, Choices are:\n"
        "    (oaCMap)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaCMap_tp_dealloc(PyoaCMapObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaCMap_tp_repr(PyObject *ob)
{
    PyParamoaCMap value;
    int convert_status=PyoaCMap_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[28];
    sprintf(buffer,"<oaCMap::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaCMap_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaCMap v1;
    PyParamoaCMap v2;
    int convert_status1=PyoaCMap_Convert(ob1,&v1);
    int convert_status2=PyoaCMap_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaCMap_Convert(PyObject* ob,PyParamoaCMap* result)
{
    if (ob == NULL) return 1;
    if (PyoaCMap_Check(ob)) {
        result->SetData( (oaCMap**) ((PyoaCMapObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaCMap Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaCMap_FromoaCMap(oaCMap** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaCMap* data=*value;
        PyObject* bself = PyoaCMap_Type.tp_alloc(&PyoaCMap_Type,0);
        if (bself == NULL) return bself;
        PyoaCMapObject* self = (PyoaCMapObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaCMap_FromoaCMap(oaCMap* data)
{
    if (data) {
       PyObject* bself = PyoaCMap_Type.tp_alloc(&PyoaCMap_Type,0);
       if (bself == NULL) return bself;
       PyoaCMapObject* self = (PyoaCMapObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaCMap_deleteSupplyDemand_doc[] = 
"Class: oaCMap, Function: deleteSupplyDemand\n"
"  Paramegers: ()\n"
"    Calls: void deleteSupplyDemand()\n"
"    Signature: deleteSupplyDemand|void-void|\n"
"    BrowseData: 0\n"
"    This function sets the invalid flag of the congestion map. All the existing supply and demand values are deleted. The congestion map remains invalid until the next set of values for some GCell.\n"
;

static PyObject*
oaCMap_deleteSupplyDemand(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCMap data;
    int convert_status=PyoaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCMapObject* self=(PyoaCMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->deleteSupplyDemand();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCMap_getGCell_doc[] = 
"Class: oaCMap, Function: getGCell\n"
"  Paramegers: (oaUInt4,oaUInt4,oaLayerNum,oaUInt4,oaUInt4,oaUInt4,oaUInt4,oaUInt4,oaUInt4)\n"
"    Calls: void getGCell(oaUInt4 xIndex,oaUInt4 yIndex,oaLayerNum layerNum,oaUInt4& horizontalSupply,oaUInt4& verticalSupply,oaUInt4& upSupply,oaUInt4& horizontalDemand,oaUInt4& verticalDemand,oaUInt4& upDemand) const\n"
"    Signature: getGCell|void-void|simple-oaUInt4,simple-oaUInt4,simple-oaLayerNum,ref-oaUInt4,ref-oaUInt4,ref-oaUInt4,ref-oaUInt4,ref-oaUInt4,ref-oaUInt4,\n"
"    This function gets all of the GCell attributes for the specified GCell in a single call.\n"
"    oacCMapLayerNotExists\n"
;

static PyObject*
oaCMap_getGCell(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCMap data;
    int convert_status=PyoaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCMapObject* self=(PyoaCMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    PyParamoaLayerNum p3;
    PyParamoaUInt4 p4;
    PyParamoaUInt4 p5;
    PyParamoaUInt4 p6;
    PyParamoaUInt4 p7;
    PyParamoaUInt4 p8;
    PyParamoaUInt4 p9;
    if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2,
          &PyoaLayerNum_Convert,&p3,
          &PyoaUInt4_Convert,&p4,
          &PyoaUInt4_Convert,&p5,
          &PyoaUInt4_Convert,&p6,
          &PyoaUInt4_Convert,&p7,
          &PyoaUInt4_Convert,&p8,
          &PyoaUInt4_Convert,&p9)) {
        data.DataCall()->getGCell(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.Data(),p9.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCMap_getHorizontalDemand_doc[] = 
"Class: oaCMap, Function: getHorizontalDemand\n"
"  Paramegers: (oaUInt4,oaUInt4,oaLayerNum)\n"
"    Calls: oaUInt4 getHorizontalDemand(oaUInt4 xIndex,oaUInt4 yIndex,oaLayerNum layerNum) const\n"
"    Signature: getHorizontalDemand|simple-oaUInt4|simple-oaUInt4,simple-oaUInt4,simple-oaLayerNum,\n"
"    This function gets the horizontal demand value from the gCell at the specified X,Y index.\n"
"    oacCMapLayerNotExists\n"
;

static PyObject*
oaCMap_getHorizontalDemand(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCMap data;
    int convert_status=PyoaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCMapObject* self=(PyoaCMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    PyParamoaLayerNum p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2,
          &PyoaLayerNum_Convert,&p3)) {
        oaUInt4 result= (data.DataCall()->getHorizontalDemand(p1.Data(),p2.Data(),p3.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCMap_getHorizontalSupply_doc[] = 
"Class: oaCMap, Function: getHorizontalSupply\n"
"  Paramegers: (oaUInt4,oaUInt4,oaLayerNum)\n"
"    Calls: oaUInt4 getHorizontalSupply(oaUInt4 xIndex,oaUInt4 yIndex,oaLayerNum layerNum) const\n"
"    Signature: getHorizontalSupply|simple-oaUInt4|simple-oaUInt4,simple-oaUInt4,simple-oaLayerNum,\n"
"    This function gets the horizontal supply value from the specified gCell.\n"
"    oacCMapLayerNotExists\n"
;

static PyObject*
oaCMap_getHorizontalSupply(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCMap data;
    int convert_status=PyoaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCMapObject* self=(PyoaCMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    PyParamoaLayerNum p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2,
          &PyoaLayerNum_Convert,&p3)) {
        oaUInt4 result= (data.DataCall()->getHorizontalSupply(p1.Data(),p2.Data(),p3.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCMap_getNumXGCell_doc[] = 
"Class: oaCMap, Function: getNumXGCell\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumXGCell() const\n"
"    Signature: getNumXGCell|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function gets the total number of gCells in the X direction. This number is determined by the oaGCellPattern objects with isHorizontal set. If there are no such oaGCellPatterns, oacNullIndex is returned.\n"
;

static PyObject*
oaCMap_getNumXGCell(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCMap data;
    int convert_status=PyoaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCMapObject* self=(PyoaCMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumXGCell());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCMap_getNumYGCell_doc[] = 
"Class: oaCMap, Function: getNumYGCell\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumYGCell() const\n"
"    Signature: getNumYGCell|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function gets the total number of gCells in the Y direction. This number is determined by the oaGCellPattern objects with isHorizontal unset. If there are no such oaGCellPatterns, oacNullIndex is returned.\n"
;

static PyObject*
oaCMap_getNumYGCell(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCMap data;
    int convert_status=PyoaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCMapObject* self=(PyoaCMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumYGCell());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCMap_getTimeStamp_doc[] = 
"Class: oaCMap, Function: getTimeStamp\n"
"  Paramegers: ()\n"
"    Calls: oaTimeStamp getTimeStamp() const\n"
"    Signature: getTimeStamp|simple-oaTimeStamp|\n"
"    BrowseData: 1\n"
"    This function gets the timeStamp of the congestion map.\n"
;

static PyObject*
oaCMap_getTimeStamp(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCMap data;
    int convert_status=PyoaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCMapObject* self=(PyoaCMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaTimeStamp* result= new oaTimeStamp(data.DataCall()->getTimeStamp());
        return PyoaTimeStamp_FromoaTimeStamp(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCMap_getUpDemand_doc[] = 
"Class: oaCMap, Function: getUpDemand\n"
"  Paramegers: (oaUInt4,oaUInt4,oaLayerNum)\n"
"    Calls: oaUInt4 getUpDemand(oaUInt4 xIndex,oaUInt4 yIndex,oaLayerNum layerNum) const\n"
"    Signature: getUpDemand|simple-oaUInt4|simple-oaUInt4,simple-oaUInt4,simple-oaLayerNum,\n"
"    This function gets the upDemand value from the gCell at the specified X,Y index.\n"
"    oacCMapLayerNotExists\n"
;

static PyObject*
oaCMap_getUpDemand(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCMap data;
    int convert_status=PyoaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCMapObject* self=(PyoaCMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    PyParamoaLayerNum p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2,
          &PyoaLayerNum_Convert,&p3)) {
        oaUInt4 result= (data.DataCall()->getUpDemand(p1.Data(),p2.Data(),p3.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCMap_getUpSupply_doc[] = 
"Class: oaCMap, Function: getUpSupply\n"
"  Paramegers: (oaUInt4,oaUInt4,oaLayerNum)\n"
"    Calls: oaUInt4 getUpSupply(oaUInt4 xIndex,oaUInt4 yIndex,oaLayerNum layerNum) const\n"
"    Signature: getUpSupply|simple-oaUInt4|simple-oaUInt4,simple-oaUInt4,simple-oaLayerNum,\n"
"    This function gets the upSupply value from the gCell at the specified X,Y index.\n"
"    oacCMapLayerNotExists\n"
;

static PyObject*
oaCMap_getUpSupply(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCMap data;
    int convert_status=PyoaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCMapObject* self=(PyoaCMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    PyParamoaLayerNum p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2,
          &PyoaLayerNum_Convert,&p3)) {
        oaUInt4 result= (data.DataCall()->getUpSupply(p1.Data(),p2.Data(),p3.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCMap_getVerticalDemand_doc[] = 
"Class: oaCMap, Function: getVerticalDemand\n"
"  Paramegers: (oaUInt4,oaUInt4,oaLayerNum)\n"
"    Calls: oaUInt4 getVerticalDemand(oaUInt4 xIndex,oaUInt4 yIndex,oaLayerNum layerNum) const\n"
"    Signature: getVerticalDemand|simple-oaUInt4|simple-oaUInt4,simple-oaUInt4,simple-oaLayerNum,\n"
"    This function gets the verticalDemand value from the gCell at the specified X,Y index.\n"
"    oacCMapLayerNotExists\n"
;

static PyObject*
oaCMap_getVerticalDemand(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCMap data;
    int convert_status=PyoaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCMapObject* self=(PyoaCMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    PyParamoaLayerNum p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2,
          &PyoaLayerNum_Convert,&p3)) {
        oaUInt4 result= (data.DataCall()->getVerticalDemand(p1.Data(),p2.Data(),p3.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCMap_getVerticalSupply_doc[] = 
"Class: oaCMap, Function: getVerticalSupply\n"
"  Paramegers: (oaUInt4,oaUInt4,oaLayerNum)\n"
"    Calls: oaUInt4 getVerticalSupply(oaUInt4 xIndex,oaUInt4 yIndex,oaLayerNum layerNum) const\n"
"    Signature: getVerticalSupply|simple-oaUInt4|simple-oaUInt4,simple-oaUInt4,simple-oaLayerNum,\n"
"    This function gets the verticalSupply value from the gCell at the specified X,Y index.\n"
"    oacCMapLayerNotExists\n"
;

static PyObject*
oaCMap_getVerticalSupply(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCMap data;
    int convert_status=PyoaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCMapObject* self=(PyoaCMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    PyParamoaLayerNum p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2,
          &PyoaLayerNum_Convert,&p3)) {
        oaUInt4 result= (data.DataCall()->getVerticalSupply(p1.Data(),p2.Data(),p3.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCMap_getXYIndex_doc[] = 
"Class: oaCMap, Function: getXYIndex\n"
"  Paramegers: (oaPoint,oaUInt4,oaUInt4)\n"
"    Calls: void getXYIndex(const oaPoint& point,oaUInt4& xIndex,oaUInt4& yIndex)\n"
"    Signature: getXYIndex|void-void|cref-oaPoint,ref-oaUInt4,ref-oaUInt4,\n"
"    This function returns the GCell indexes for the GCell containg the specified point. If the point lies outside the coordinates of the GCell grid, the the values returned are oacNullIndex .\n"
;

static PyObject*
oaCMap_getXYIndex(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCMap data;
    int convert_status=PyoaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCMapObject* self=(PyoaCMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaPoint p1;
    PyParamoaUInt4 p2;
    PyParamoaUInt4 p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaPoint_Convert,&p1,
          &PyoaUInt4_Convert,&p2,
          &PyoaUInt4_Convert,&p3)) {
        data.DataCall()->getXYIndex(p1.Data(),p2.Data(),p3.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCMap_isSupplyDemandValid_doc[] = 
"Class: oaCMap, Function: isSupplyDemandValid\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isSupplyDemandValid() const\n"
"    Signature: isSupplyDemandValid|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function gets the flag indicating whether this congestion map is valid. It is valid if any GCell statistics were set since the last change to a GCellPattern or since a call to oaCMap::deleteSupplyDemand .\n"
;

static PyObject*
oaCMap_isSupplyDemandValid(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCMap data;
    int convert_status=PyoaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCMapObject* self=(PyoaCMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isSupplyDemandValid());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCMap_setGCell_doc[] = 
"Class: oaCMap, Function: setGCell\n"
"  Paramegers: (oaUInt4,oaUInt4,oaLayerNum,oaUInt4,oaUInt4,oaUInt4,oaUInt4,oaUInt4,oaUInt4)\n"
"    Calls: void setGCell(oaUInt4 xIndex,oaUInt4 yIndex,oaLayerNum layerNum,oaUInt4 horizontalSupply,oaUInt4 verticalSupply,oaUInt4 upSupply,oaUInt4 horizontalDemand,oaUInt4 verticalDemand,oaUInt4 upDemand)\n"
"    Signature: setGCell|void-void|simple-oaUInt4,simple-oaUInt4,simple-oaLayerNum,simple-oaUInt4,simple-oaUInt4,simple-oaUInt4,simple-oaUInt4,simple-oaUInt4,simple-oaUInt4,\n"
"    This function sets all of the GCell attributes for the specified GCell in a single call.\n"
;

static PyObject*
oaCMap_setGCell(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCMap data;
    int convert_status=PyoaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCMapObject* self=(PyoaCMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    PyParamoaLayerNum p3;
    PyParamoaUInt4 p4;
    PyParamoaUInt4 p5;
    PyParamoaUInt4 p6;
    PyParamoaUInt4 p7;
    PyParamoaUInt4 p8;
    PyParamoaUInt4 p9;
    if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2,
          &PyoaLayerNum_Convert,&p3,
          &PyoaUInt4_Convert,&p4,
          &PyoaUInt4_Convert,&p5,
          &PyoaUInt4_Convert,&p6,
          &PyoaUInt4_Convert,&p7,
          &PyoaUInt4_Convert,&p8,
          &PyoaUInt4_Convert,&p9)) {
        data.DataCall()->setGCell(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.Data(),p9.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCMap_setHorizontalDemand_doc[] = 
"Class: oaCMap, Function: setHorizontalDemand\n"
"  Paramegers: (oaUInt4,oaUInt4,oaLayerNum,oaUInt4)\n"
"    Calls: void setHorizontalDemand(oaUInt4 xIndex,oaUInt4 yIndex,oaLayerNum layerNum,oaUInt4 horizontalDemand)\n"
"    Signature: setHorizontalDemand|void-void|simple-oaUInt4,simple-oaUInt4,simple-oaLayerNum,simple-oaUInt4,\n"
"    This function sets the horizontalDemand value to the gCell at the specified X,Y index.\n"
;

static PyObject*
oaCMap_setHorizontalDemand(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCMap data;
    int convert_status=PyoaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCMapObject* self=(PyoaCMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    PyParamoaLayerNum p3;
    PyParamoaUInt4 p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2,
          &PyoaLayerNum_Convert,&p3,
          &PyoaUInt4_Convert,&p4)) {
        data.DataCall()->setHorizontalDemand(p1.Data(),p2.Data(),p3.Data(),p4.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCMap_setHorizontalSupply_doc[] = 
"Class: oaCMap, Function: setHorizontalSupply\n"
"  Paramegers: (oaUInt4,oaUInt4,oaLayerNum,oaUInt4)\n"
"    Calls: void setHorizontalSupply(oaUInt4 xIndex,oaUInt4 yIndex,oaLayerNum layerNum,oaUInt4 horizontalSupply)\n"
"    Signature: setHorizontalSupply|void-void|simple-oaUInt4,simple-oaUInt4,simple-oaLayerNum,simple-oaUInt4,\n"
"    This function sets the horizontalSupply value to the gCell at the specified X,Y index.\n"
;

static PyObject*
oaCMap_setHorizontalSupply(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCMap data;
    int convert_status=PyoaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCMapObject* self=(PyoaCMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    PyParamoaLayerNum p3;
    PyParamoaUInt4 p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2,
          &PyoaLayerNum_Convert,&p3,
          &PyoaUInt4_Convert,&p4)) {
        data.DataCall()->setHorizontalSupply(p1.Data(),p2.Data(),p3.Data(),p4.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCMap_setUpDemand_doc[] = 
"Class: oaCMap, Function: setUpDemand\n"
"  Paramegers: (oaUInt4,oaUInt4,oaLayerNum,oaUInt4)\n"
"    Calls: void setUpDemand(oaUInt4 xIndex,oaUInt4 yIndex,oaLayerNum layerNum,oaUInt4 upDemand)\n"
"    Signature: setUpDemand|void-void|simple-oaUInt4,simple-oaUInt4,simple-oaLayerNum,simple-oaUInt4,\n"
"    This function sets the upDemand value to the gCell at the specified X,Y index.\n"
;

static PyObject*
oaCMap_setUpDemand(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCMap data;
    int convert_status=PyoaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCMapObject* self=(PyoaCMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    PyParamoaLayerNum p3;
    PyParamoaUInt4 p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2,
          &PyoaLayerNum_Convert,&p3,
          &PyoaUInt4_Convert,&p4)) {
        data.DataCall()->setUpDemand(p1.Data(),p2.Data(),p3.Data(),p4.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCMap_setUpSupply_doc[] = 
"Class: oaCMap, Function: setUpSupply\n"
"  Paramegers: (oaUInt4,oaUInt4,oaLayerNum,oaUInt4)\n"
"    Calls: void setUpSupply(oaUInt4 xIndex,oaUInt4 yIndex,oaLayerNum layerNum,oaUInt4 upSupply)\n"
"    Signature: setUpSupply|void-void|simple-oaUInt4,simple-oaUInt4,simple-oaLayerNum,simple-oaUInt4,\n"
"    This function sets the upSupply value to the gCell at the specified X,Y index.\n"
;

static PyObject*
oaCMap_setUpSupply(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCMap data;
    int convert_status=PyoaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCMapObject* self=(PyoaCMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    PyParamoaLayerNum p3;
    PyParamoaUInt4 p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2,
          &PyoaLayerNum_Convert,&p3,
          &PyoaUInt4_Convert,&p4)) {
        data.DataCall()->setUpSupply(p1.Data(),p2.Data(),p3.Data(),p4.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCMap_setVerticalDemand_doc[] = 
"Class: oaCMap, Function: setVerticalDemand\n"
"  Paramegers: (oaUInt4,oaUInt4,oaLayerNum,oaUInt4)\n"
"    Calls: void setVerticalDemand(oaUInt4 xIndex,oaUInt4 yIndex,oaLayerNum layerNum,oaUInt4 verticalDemand)\n"
"    Signature: setVerticalDemand|void-void|simple-oaUInt4,simple-oaUInt4,simple-oaLayerNum,simple-oaUInt4,\n"
"    This function sets the verticalDemand value to the gCell at the specified X,Y index.\n"
;

static PyObject*
oaCMap_setVerticalDemand(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCMap data;
    int convert_status=PyoaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCMapObject* self=(PyoaCMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    PyParamoaLayerNum p3;
    PyParamoaUInt4 p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2,
          &PyoaLayerNum_Convert,&p3,
          &PyoaUInt4_Convert,&p4)) {
        data.DataCall()->setVerticalDemand(p1.Data(),p2.Data(),p3.Data(),p4.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCMap_setVerticalSupply_doc[] = 
"Class: oaCMap, Function: setVerticalSupply\n"
"  Paramegers: (oaUInt4,oaUInt4,oaLayerNum,oaUInt4)\n"
"    Calls: void setVerticalSupply(oaUInt4 xIndex,oaUInt4 yIndex,oaLayerNum layerNum,oaUInt4 verticalSupply)\n"
"    Signature: setVerticalSupply|void-void|simple-oaUInt4,simple-oaUInt4,simple-oaLayerNum,simple-oaUInt4,\n"
"    This function sets the verticalSupply value to the gCell at the specified X,Y index.\n"
;

static PyObject*
oaCMap_setVerticalSupply(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCMap data;
    int convert_status=PyoaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCMapObject* self=(PyoaCMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    PyParamoaLayerNum p3;
    PyParamoaUInt4 p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2,
          &PyoaLayerNum_Convert,&p3,
          &PyoaUInt4_Convert,&p4)) {
        data.DataCall()->setVerticalSupply(p1.Data(),p2.Data(),p3.Data(),p4.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCMap_isNull_doc[] =
"Class: oaCMap, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaCMap_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaCMap data;
    int convert_status=PyoaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaCMap_assign_doc[] = 
"Class: oaCMap, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaCMap_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaCMap data;
  int convert_status=PyoaCMap_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaCMap p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaCMap_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaCMap_methodlist[] = {
    {"deleteSupplyDemand",(PyCFunction)oaCMap_deleteSupplyDemand,METH_VARARGS,oaCMap_deleteSupplyDemand_doc},
    {"getGCell",(PyCFunction)oaCMap_getGCell,METH_VARARGS,oaCMap_getGCell_doc},
    {"getHorizontalDemand",(PyCFunction)oaCMap_getHorizontalDemand,METH_VARARGS,oaCMap_getHorizontalDemand_doc},
    {"getHorizontalSupply",(PyCFunction)oaCMap_getHorizontalSupply,METH_VARARGS,oaCMap_getHorizontalSupply_doc},
    {"getNumXGCell",(PyCFunction)oaCMap_getNumXGCell,METH_VARARGS,oaCMap_getNumXGCell_doc},
    {"getNumYGCell",(PyCFunction)oaCMap_getNumYGCell,METH_VARARGS,oaCMap_getNumYGCell_doc},
    {"getTimeStamp",(PyCFunction)oaCMap_getTimeStamp,METH_VARARGS,oaCMap_getTimeStamp_doc},
    {"getUpDemand",(PyCFunction)oaCMap_getUpDemand,METH_VARARGS,oaCMap_getUpDemand_doc},
    {"getUpSupply",(PyCFunction)oaCMap_getUpSupply,METH_VARARGS,oaCMap_getUpSupply_doc},
    {"getVerticalDemand",(PyCFunction)oaCMap_getVerticalDemand,METH_VARARGS,oaCMap_getVerticalDemand_doc},
    {"getVerticalSupply",(PyCFunction)oaCMap_getVerticalSupply,METH_VARARGS,oaCMap_getVerticalSupply_doc},
    {"getXYIndex",(PyCFunction)oaCMap_getXYIndex,METH_VARARGS,oaCMap_getXYIndex_doc},
    {"isSupplyDemandValid",(PyCFunction)oaCMap_isSupplyDemandValid,METH_VARARGS,oaCMap_isSupplyDemandValid_doc},
    {"setGCell",(PyCFunction)oaCMap_setGCell,METH_VARARGS,oaCMap_setGCell_doc},
    {"setHorizontalDemand",(PyCFunction)oaCMap_setHorizontalDemand,METH_VARARGS,oaCMap_setHorizontalDemand_doc},
    {"setHorizontalSupply",(PyCFunction)oaCMap_setHorizontalSupply,METH_VARARGS,oaCMap_setHorizontalSupply_doc},
    {"setUpDemand",(PyCFunction)oaCMap_setUpDemand,METH_VARARGS,oaCMap_setUpDemand_doc},
    {"setUpSupply",(PyCFunction)oaCMap_setUpSupply,METH_VARARGS,oaCMap_setUpSupply_doc},
    {"setVerticalDemand",(PyCFunction)oaCMap_setVerticalDemand,METH_VARARGS,oaCMap_setVerticalDemand_doc},
    {"setVerticalSupply",(PyCFunction)oaCMap_setVerticalSupply,METH_VARARGS,oaCMap_setVerticalSupply_doc},
    {"isNull",(PyCFunction)oaCMap_tp_isNull,METH_VARARGS,oaCMap_isNull_doc},
    {"assign",(PyCFunction)oaCMap_tp_assign,METH_VARARGS,oaCMap_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaCMap_doc[] = 
"Class: oaCMap\n"
"  The oaCMap class implements a congestion map for use by global routers. The congestion map is a two-dimensional grid that exists for each layer in the design. Each grid cell on each layer is called a GCell. See the class oaGCellPattern for a discussion of how the grid size and coordinates are determined.\n"
"  Each GCell can hold supply and demand counts for routes that traverse the GCell horizontally, vertically, and up/down through vias. All of these GCell statistics are set and managed by applications. The database does not calculate them automatically.\n"
"  For all of the functions below that get statistics for a specified GCell, the function will return values of oacNullIndex for any value that is not set. If the specified layer has not had any values set, it throws the exception oacCMapLayerNotExists.\n"
"  The oaCMap class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaCMap)\n"
"    Calls: (const oaCMap&)\n"
"    Signature: oaCMap||cref-oaCMap,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaCMap_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaCMap",
    sizeof(PyoaCMapObject),
    0,
    (destructor)oaCMap_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaCMap_tp_compare,	/* tp_compare */
    (reprfunc)oaCMap_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaCMap_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaCMap_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaBlockObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaCMap_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaCMap_static_getCMap_doc[] = 
"Class: oaCMap, Function: getCMap\n"
"  Paramegers: (oaBlock)\n"
"    Calls: oaCMap* getCMap(oaBlock* block)\n"
"    Signature: getCMap|ptr-oaCMap|ptr-oaBlock,\n"
"    This function gets the congestion map in the specified design . If the congestion map exists, it is returned. If the congestion map does not exist, it is created. There is only one congestion map per design.\n"
;

static PyObject*
oaCMap_static_getCMap(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBlock_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaCMapp result= (oaCMap::getCMap(p1.Data()));
        return PyoaCMap_FromoaCMap(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaCMap_staticmethodlist[] = {
    {"static_getCMap",(PyCFunction)oaCMap_static_getCMap,METH_VARARGS,oaCMap_static_getCMap_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaCMap_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaCMap_Type)<0) {
      printf("** PyType_Ready failed for: oaCMap\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaCMap",
           (PyObject*)(&PyoaCMap_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaCMap\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaCMap_Type.tp_dict;
    for(method=oaCMap_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaCMapModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaCMapModTypeEnum_Convert(PyObject* ob,PyParamoaCMapModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacSetHorizontalSupplyCMapModType")==0) { result->SetData(oacSetHorizontalSupplyCMapModType); return 1;}
        if (strcasecmp(str,"oacSetVerticalSupplyCMapModType")==0) { result->SetData(oacSetVerticalSupplyCMapModType); return 1;}
        if (strcasecmp(str,"oacSetUpSupplyCMapModType")==0) { result->SetData(oacSetUpSupplyCMapModType); return 1;}
        if (strcasecmp(str,"oacSetHorizontalDemandCMapModType")==0) { result->SetData(oacSetHorizontalDemandCMapModType); return 1;}
        if (strcasecmp(str,"oacSetVerticalDemandCMapModType")==0) { result->SetData(oacSetVerticalDemandCMapModType); return 1;}
        if (strcasecmp(str,"oacSetUpDemandCMapModType")==0) { result->SetData(oacSetUpDemandCMapModType); return 1;}
        if (strcasecmp(str,"oacSetInvalidCMapModType")==0) { result->SetData(oacSetInvalidCMapModType); return 1;}
        if (strcasecmp(str,"oacSetGCellCMapModType")==0) { result->SetData(oacSetGCellCMapModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaCMapModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaCMapModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaCMapModTypeEnum_FromoaCMapModTypeEnum(oaCMapModTypeEnum ob)
{
    if (ob==oacSetHorizontalSupplyCMapModType) return PyString_FromString("oacSetHorizontalSupplyCMapModType");
    if (ob==oacSetVerticalSupplyCMapModType) return PyString_FromString("oacSetVerticalSupplyCMapModType");
    if (ob==oacSetUpSupplyCMapModType) return PyString_FromString("oacSetUpSupplyCMapModType");
    if (ob==oacSetHorizontalDemandCMapModType) return PyString_FromString("oacSetHorizontalDemandCMapModType");
    if (ob==oacSetVerticalDemandCMapModType) return PyString_FromString("oacSetVerticalDemandCMapModType");
    if (ob==oacSetUpDemandCMapModType) return PyString_FromString("oacSetUpDemandCMapModType");
    if (ob==oacSetInvalidCMapModType) return PyString_FromString("oacSetInvalidCMapModType");
    if (ob==oacSetGCellCMapModType) return PyString_FromString("oacSetGCellCMapModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaCMapModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaCMapModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaCMapModTypeEnum_FromoaCMapModTypeEnum(oaCMapModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaCMapModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaCMapModTypeEnum_doc[] =
"Type convert function for enum: oaCMapModTypeEnum";
                               
static PyMethodDef PyoaCMapModTypeEnum_method =
  {"oaCMapModTypeEnum",(PyCFunction)PyoaCMapModTypeEnum_TypeFunction,METH_VARARGS,oaCMapModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaCMapModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacSetHorizontalSupplyCMapModType");
    PyDict_SetItemString(mod_dict,"oacSetHorizontalSupplyCMapModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetVerticalSupplyCMapModType");
    PyDict_SetItemString(mod_dict,"oacSetVerticalSupplyCMapModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetUpSupplyCMapModType");
    PyDict_SetItemString(mod_dict,"oacSetUpSupplyCMapModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetHorizontalDemandCMapModType");
    PyDict_SetItemString(mod_dict,"oacSetHorizontalDemandCMapModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetVerticalDemandCMapModType");
    PyDict_SetItemString(mod_dict,"oacSetVerticalDemandCMapModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetUpDemandCMapModType");
    PyDict_SetItemString(mod_dict,"oacSetUpDemandCMapModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetInvalidCMapModType");
    PyDict_SetItemString(mod_dict,"oacSetInvalidCMapModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetGCellCMapModType");
    PyDict_SetItemString(mod_dict,"oacSetGCellCMapModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaCMapModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaCMapModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaCMapModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaCategory
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaCategory_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaCategory_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaCategoryObject* self = (PyoaCategoryObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaCategory();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaCategoryEnum)
    {
        PyParamoaCategoryEnum p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaCategoryEnum_Convert,&p1)) {
            self->value =  new oaCategory(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            self->value =  new oaCategory(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaCategory)
    {
        PyParamoaCategory p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaCategory_Convert,&p1)) {
            self->value= new oaCategory(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaCategory, Choices are:\n"
        "    ()\n"
        "    (oaCategoryEnum)\n"
        "    (oaString)\n"
        "    (oaCategory)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaCategory_tp_dealloc(PyoaCategoryObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaCategory_tp_repr(PyObject *ob)
{
    PyParamoaCategory value;
    int convert_status=PyoaCategory_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    oaString sresult(value.DataCall()->getName());

    char addr[32];
    sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
    oaString buffer;
    buffer+=oaString("<oaCategory::");
    buffer+=oaString(addr);
    buffer+=oaString("::");
    buffer+=oaString(sresult);
    buffer+=oaString(">");
    result=PyString_FromString((char*)(const char*)buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaCategory_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaCategory v1;
    PyParamoaCategory v2;
    int convert_status1=PyoaCategory_Convert(ob1,&v1);
    int convert_status2=PyoaCategory_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaCategory_Convert(PyObject* ob,PyParamoaCategory* result)
{
    if (ob == NULL) return 1;
    if (PyoaCategory_Check(ob)) {
        result->SetData(  ((PyoaCategoryObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaCategory Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaCategory_FromoaCategory(oaCategory* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaCategory_Type.tp_alloc(&PyoaCategory_Type,0);
        if (bself == NULL) return bself;
        PyoaCategoryObject* self = (PyoaCategoryObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaCategory_getName_doc[] = 
"Class: oaCategory, Function: getName\n"
"  Paramegers: ()\n"
"    Calls: const oaString& getName() const\n"
"    Signature: getName|cref-oaString|\n"
"    BrowseData: 1\n"
"    This function returns the string name that corresponds to the enum value of this oaCategory class object.\n"
;

static PyObject*
oaCategory_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCategory data;
    int convert_status=PyoaCategory_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCategoryObject* self=(PyoaCategoryObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaString result= (data.DataCall()->getName());
        return PyoaString_FromoaString(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCategory_oaCategoryEnum_doc[] = 
"Class: oaCategory, Function: oaCategoryEnum\n"
"  Paramegers: ()\n"
"    Calls: oaCategoryEnum oaCategoryEnum() const\n"
"    Signature: operator oaCategoryEnum|simple-oaCategoryEnum|\n"
"    BrowseData: 1\n"
"    This operator returns the enumerated value that corresponds to the category type that this object represents.\n"
;

static PyObject*
oaCategory_oaCategoryEnum(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCategory data;
    int convert_status=PyoaCategory_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCategoryObject* self=(PyoaCategoryObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaCategoryEnum result= (data.DataCall()->operator oaCategoryEnum());
        return PyoaCategoryEnum_FromoaCategoryEnum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaCategory_assign_doc[] = 
"Class: oaCategory, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaCategory_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaCategory data;
  int convert_status=PyoaCategory_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaCategory p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaCategory_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaCategory_methodlist[] = {
    {"getName",(PyCFunction)oaCategory_getName,METH_VARARGS,oaCategory_getName_doc},
    {"oaCategoryEnum",(PyCFunction)oaCategory_oaCategoryEnum,METH_VARARGS,oaCategory_oaCategoryEnum_doc},
    {"assign",(PyCFunction)oaCategory_tp_assign,METH_VARARGS,oaCategory_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaCategory_doc[] = 
"Class: oaCategory\n"
"  The oaCategory class is an enum wrapper class for oaCategoryEnum values. It represents a portion of the OpenAccess data model.\n"
"  See Enum Wrappers in the Programmers Guide for a discussion of enum wrappers.\n"
"  oaCategoryEnum\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaCategory()\n"
"    Signature: oaCategory||\n"
"    This is the default constructor for the oaCategory class enum wrapper.\n"
"  Paramegers: (oaCategoryEnum)\n"
"    Calls: oaCategory(oaCategoryEnum typeIn)\n"
"    Signature: oaCategory||simple-oaCategoryEnum,\n"
"    This constructor for the oaCategory class enum wrapper takes an oaCategoryEnum as input.\n"
"    typeIn\n"
"    an oaCategoryEnum\n"
"  Paramegers: (oaString)\n"
"    Calls: oaCategory(const oaString& name)\n"
"    Signature: oaCategory||cref-oaString,\n"
"    This constructor creates an oaCategory object based on the constant string value that represents the category type.\n"
"    name\n"
"    A reference to a constant oaString object that holds the category type name\n"
"    oacInvalidCategoryName\n"
"  Paramegers: (oaCategory)\n"
"    Calls: (const oaCategory&)\n"
"    Signature: oaCategory||cref-oaCategory,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaCategory_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaCategory",
    sizeof(PyoaCategoryObject),
    0,
    (destructor)oaCategory_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaCategory_tp_compare,	/* tp_compare */
    (reprfunc)oaCategory_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaCategory_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaCategory_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaCategory_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaCategory_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaCategory_Type)<0) {
      printf("** PyType_Ready failed for: oaCategory\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaCategory",
           (PyObject*)(&PyoaCategory_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaCategory\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaCategoryEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaCategoryEnum_Convert(PyObject* ob,PyParamoaCategoryEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacFutureCategory")==0) { result->SetData(oacFutureCategory); return 1;}
        if (strcasecmp(str,"oacConstraintCategory")==0) { result->SetData(oacConstraintCategory); return 1;}
        if (strcasecmp(str,"oacValueCategory")==0) { result->SetData(oacValueCategory); return 1;}
        if (strcasecmp(str,"oacAnnotationCategory")==0) { result->SetData(oacAnnotationCategory); return 1;}
        if (strcasecmp(str,"oacApplicationDefinedCategory")==0) { result->SetData(oacApplicationDefinedCategory); return 1;}
        if (strcasecmp(str,"oacNameCategory")==0) { result->SetData(oacNameCategory); return 1;}
        if (strcasecmp(str,"oacObserverCategory")==0) { result->SetData(oacObserverCategory); return 1;}
        if (strcasecmp(str,"oacDesignManagementCategory")==0) { result->SetData(oacDesignManagementCategory); return 1;}
        if (strcasecmp(str,"oacTechCategory")==0) { result->SetData(oacTechCategory); return 1;}
        if (strcasecmp(str,"oacWaferCategory")==0) { result->SetData(oacWaferCategory); return 1;}
        if (strcasecmp(str,"oacDesignHierarchyCategory")==0) { result->SetData(oacDesignHierarchyCategory); return 1;}
        if (strcasecmp(str,"oacGeometryCategory")==0) { result->SetData(oacGeometryCategory); return 1;}
        if (strcasecmp(str,"oacPlaceAndRouteCategory")==0) { result->SetData(oacPlaceAndRouteCategory); return 1;}
        if (strcasecmp(str,"oacConnectivityCategory")==0) { result->SetData(oacConnectivityCategory); return 1;}
        if (strcasecmp(str,"oacParasiticsCategory")==0) { result->SetData(oacParasiticsCategory); return 1;}
        if (strcasecmp(str,"oacPlugInCategory")==0) { result->SetData(oacPlugInCategory); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaCategoryEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaCategoryEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaCategoryEnum_FromoaCategoryEnum(oaCategoryEnum ob)
{
    if (ob==oacFutureCategory) return PyString_FromString("oacFutureCategory");
    if (ob==oacConstraintCategory) return PyString_FromString("oacConstraintCategory");
    if (ob==oacValueCategory) return PyString_FromString("oacValueCategory");
    if (ob==oacAnnotationCategory) return PyString_FromString("oacAnnotationCategory");
    if (ob==oacApplicationDefinedCategory) return PyString_FromString("oacApplicationDefinedCategory");
    if (ob==oacNameCategory) return PyString_FromString("oacNameCategory");
    if (ob==oacObserverCategory) return PyString_FromString("oacObserverCategory");
    if (ob==oacDesignManagementCategory) return PyString_FromString("oacDesignManagementCategory");
    if (ob==oacTechCategory) return PyString_FromString("oacTechCategory");
    if (ob==oacWaferCategory) return PyString_FromString("oacWaferCategory");
    if (ob==oacDesignHierarchyCategory) return PyString_FromString("oacDesignHierarchyCategory");
    if (ob==oacGeometryCategory) return PyString_FromString("oacGeometryCategory");
    if (ob==oacPlaceAndRouteCategory) return PyString_FromString("oacPlaceAndRouteCategory");
    if (ob==oacConnectivityCategory) return PyString_FromString("oacConnectivityCategory");
    if (ob==oacParasiticsCategory) return PyString_FromString("oacParasiticsCategory");
    if (ob==oacPlugInCategory) return PyString_FromString("oacPlugInCategory");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaCategoryEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaCategoryEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaCategoryEnum_FromoaCategoryEnum(oaCategoryEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaCategoryEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaCategoryEnum_doc[] =
"Type convert function for enum: oaCategoryEnum";
                               
static PyMethodDef PyoaCategoryEnum_method =
  {"oaCategoryEnum",(PyCFunction)PyoaCategoryEnum_TypeFunction,METH_VARARGS,oaCategoryEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaCategoryEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacFutureCategory");
    PyDict_SetItemString(mod_dict,"oacFutureCategory",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConstraintCategory");
    PyDict_SetItemString(mod_dict,"oacConstraintCategory",value);
    Py_DECREF(value);
    value=PyString_FromString("oacValueCategory");
    PyDict_SetItemString(mod_dict,"oacValueCategory",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAnnotationCategory");
    PyDict_SetItemString(mod_dict,"oacAnnotationCategory",value);
    Py_DECREF(value);
    value=PyString_FromString("oacApplicationDefinedCategory");
    PyDict_SetItemString(mod_dict,"oacApplicationDefinedCategory",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNameCategory");
    PyDict_SetItemString(mod_dict,"oacNameCategory",value);
    Py_DECREF(value);
    value=PyString_FromString("oacObserverCategory");
    PyDict_SetItemString(mod_dict,"oacObserverCategory",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDesignManagementCategory");
    PyDict_SetItemString(mod_dict,"oacDesignManagementCategory",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechCategory");
    PyDict_SetItemString(mod_dict,"oacTechCategory",value);
    Py_DECREF(value);
    value=PyString_FromString("oacWaferCategory");
    PyDict_SetItemString(mod_dict,"oacWaferCategory",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDesignHierarchyCategory");
    PyDict_SetItemString(mod_dict,"oacDesignHierarchyCategory",value);
    Py_DECREF(value);
    value=PyString_FromString("oacGeometryCategory");
    PyDict_SetItemString(mod_dict,"oacGeometryCategory",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPlaceAndRouteCategory");
    PyDict_SetItemString(mod_dict,"oacPlaceAndRouteCategory",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConnectivityCategory");
    PyDict_SetItemString(mod_dict,"oacConnectivityCategory",value);
    Py_DECREF(value);
    value=PyString_FromString("oacParasiticsCategory");
    PyDict_SetItemString(mod_dict,"oacParasiticsCategory",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPlugInCategory");
    PyDict_SetItemString(mod_dict,"oacPlugInCategory",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaCategoryEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaCategoryEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaCategoryEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaCdbaNS
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaCdbaNS_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaCdbaNS_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaCdbaNSObject* self = (PyoaCdbaNSObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaNameSpace*)  new oaCdbaNS();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaCdbaNS)
    {
        PyParamoaCdbaNS p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaCdbaNS_Convert,&p1)) {
            self->value=(oaNameSpace*)  new oaCdbaNS(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaCdbaNS, Choices are:\n"
        "    ()\n"
        "    (oaCdbaNS)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaCdbaNS_tp_dealloc(PyoaCdbaNSObject* self)
{
    if (!self->borrow) {
        delete (oaCdbaNS*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaCdbaNS_tp_repr(PyObject *ob)
{
    PyParamoaCdbaNS value;
    int convert_status=PyoaCdbaNS_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[30];
    sprintf(buffer,"<oaCdbaNS::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaCdbaNS_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaCdbaNS v1;
    PyParamoaCdbaNS v2;
    int convert_status1=PyoaCdbaNS_Convert(ob1,&v1);
    int convert_status2=PyoaCdbaNS_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaCdbaNS_Convert(PyObject* ob,PyParamoaCdbaNS* result)
{
    if (ob == NULL) return 1;
    if (PyoaCdbaNS_Check(ob)) {
        result->SetData( (oaCdbaNS*) ((PyoaCdbaNSObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaCdbaNS Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaCdbaNS_FromoaCdbaNS(oaCdbaNS* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaCdbaNS_Type.tp_alloc(&PyoaCdbaNS_Type,0);
        if (bself == NULL) return bself;
        PyoaCdbaNSObject* self = (PyoaCdbaNSObject*)bself;
        self->value = (oaNameSpace*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaCdbaNS_getType_doc[] = 
"Class: oaCdbaNS, Function: getType\n"
"  Paramegers: ([oaChar])\n"
"    Calls: oaNameType getType(const oaChar* in) const\n"
"    Signature: getType|simple-oaNameType|cptr-oaChar,\n"
"    Function getType\n"
;

static PyObject*
oaCdbaNS_getType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCdbaNS data;
    int convert_status=PyoaCdbaNS_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCdbaNSObject* self=(PyoaCdbaNSObject*)ob;

    PyParamoaChar_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaChar_Array_Convert,&p1)) {
        oaNameType* result= new oaNameType(data.DataCall()->getType(p1.Data()));
        return PyoaNameType_FromoaNameType(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCdbaNS_isEqual_doc[] = 
"Class: oaCdbaNS, Function: isEqual\n"
"  Paramegers: (oaScalarName,oaScalarName)\n"
"    Calls: oaBoolean isEqual(const oaScalarName& n1,const oaScalarName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaScalarName,cref-oaScalarName,\n"
"    Function isEqual\n"
"  Paramegers: (oaVectorName,oaVectorName)\n"
"    Calls: oaBoolean isEqual(const oaVectorName& n1,const oaVectorName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaVectorName,cref-oaVectorName,\n"
"    Function isEqual\n"
"  Paramegers: (oaVectorBitName,oaVectorBitName)\n"
"    Calls: oaBoolean isEqual(const oaVectorBitName& n1,const oaVectorBitName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaVectorBitName,cref-oaVectorBitName,\n"
"    Function isEqual\n"
"  Paramegers: (oaBundleName,oaBundleName)\n"
"    Calls: oaBoolean isEqual(const oaBundleName& n1,const oaBundleName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaBundleName,cref-oaBundleName,\n"
"    Function isEqual\n"
"  Paramegers: (oaSimpleName,oaSimpleName)\n"
"    Calls: oaBoolean isEqual(const oaSimpleName& n1,const oaSimpleName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaSimpleName,cref-oaSimpleName,\n"
"    Function isEqual\n"
"  Paramegers: (oaName,oaName)\n"
"    Calls: oaBoolean isEqual(const oaName& n1,const oaName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaName,cref-oaName,\n"
"    Function isEqual\n"
;

static PyObject*
oaCdbaNS_isEqual(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCdbaNS data;
    int convert_status=PyoaCdbaNS_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCdbaNSObject* self=(PyoaCdbaNSObject*)ob;

    // Case: (oaScalarName,oaScalarName)
    {
        PyParamoaScalarName p1;
        PyParamoaScalarName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaScalarName_Convert,&p1,
              &PyoaScalarName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaVectorName,oaVectorName)
    {
        PyParamoaVectorName p1;
        PyParamoaVectorName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaVectorName_Convert,&p1,
              &PyoaVectorName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaVectorBitName,oaVectorBitName)
    {
        PyParamoaVectorBitName p1;
        PyParamoaVectorBitName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaVectorBitName_Convert,&p1,
              &PyoaVectorBitName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBundleName,oaBundleName)
    {
        PyParamoaBundleName p1;
        PyParamoaBundleName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBundleName_Convert,&p1,
              &PyoaBundleName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName,oaSimpleName)
    {
        PyParamoaSimpleName p1;
        PyParamoaSimpleName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaSimpleName_Convert,&p1,
              &PyoaSimpleName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaName,oaName)
    {
        PyParamoaName p1;
        PyParamoaName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaName_Convert,&p1,
              &PyoaName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaCdbaNS, function: isEqual, Choices are:\n"
        "    (oaScalarName,oaScalarName)\n"
        "    (oaVectorName,oaVectorName)\n"
        "    (oaVectorBitName,oaVectorBitName)\n"
        "    (oaBundleName,oaBundleName)\n"
        "    (oaSimpleName,oaSimpleName)\n"
        "    (oaName,oaName)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaCdbaNS_assign_doc[] = 
"Class: oaCdbaNS, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaCdbaNS_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaCdbaNS data;
  int convert_status=PyoaCdbaNS_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaCdbaNS p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaCdbaNS_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaCdbaNS_methodlist[] = {
    {"getType",(PyCFunction)oaCdbaNS_getType,METH_VARARGS,oaCdbaNS_getType_doc},
    {"isEqual",(PyCFunction)oaCdbaNS_isEqual,METH_VARARGS,oaCdbaNS_isEqual_doc},
    {"assign",(PyCFunction)oaCdbaNS_tp_assign,METH_VARARGS,oaCdbaNS_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaCdbaNS_doc[] = 
"Class: oaCdbaNS\n"
"  The oaCdbaNS class implements the CDBA nameSpace used in name mapping. The CDBA name space reflects the rules for specifying legal names in the CDBA database. This namespace is used by many Cadence applications. In conjunction with the oaName object, the oaCdbaNS class facilitates mapping names to and from CDBA. See the Name Mapping Section of the Programmers Guide for more information.\n"
"  The CDBA nameSpace is case sensitive and supports vectored, stepped, hierarchical, and bundled names. See the CDBA Name Space Section of the Programmers Guide for a more detailed description of the characteristics of the CDBA name space.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaCdbaNS()\n"
"    Signature: oaCdbaNS||\n"
"    This function constructs the oaCdbaNS instance.\n"
"  Paramegers: (oaCdbaNS)\n"
"    Calls: (const oaCdbaNS&)\n"
"    Signature: oaCdbaNS||cref-oaCdbaNS,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaCdbaNS_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaCdbaNS",
    sizeof(PyoaCdbaNSObject),
    0,
    (destructor)oaCdbaNS_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaCdbaNS_tp_compare,	/* tp_compare */
    (reprfunc)oaCdbaNS_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaCdbaNS_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaCdbaNS_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaNameSpace_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaCdbaNS_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaCdbaNS_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaCdbaNS_Type)<0) {
      printf("** PyType_Ready failed for: oaCdbaNS\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaCdbaNS",
           (PyObject*)(&PyoaCdbaNS_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaCdbaNS\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaCell
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaCell_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaCell_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaCellObject* self = (PyoaCellObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaCell)
    {
        PyParamoaCell p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaCell_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaCell, Choices are:\n"
        "    (oaCell)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaCell_tp_dealloc(PyoaCellObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaCell_tp_repr(PyObject *ob)
{
    PyParamoaCell value;
    int convert_status=PyoaCell_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaCell::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaScalarName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[28];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaCell::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaCell_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaCell v1;
    PyParamoaCell v2;
    int convert_status1=PyoaCell_Convert(ob1,&v1);
    int convert_status2=PyoaCell_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaCell_Convert(PyObject* ob,PyParamoaCell* result)
{
    if (ob == NULL) return 1;
    if (PyoaCell_Check(ob)) {
        result->SetData( (oaCell**) ((PyoaCellObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaCell Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaCell_FromoaCell(oaCell** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaCell* data=*value;
        PyObject* bself = PyoaCell_Type.tp_alloc(&PyoaCell_Type,0);
        if (bself == NULL) return bself;
        PyoaCellObject* self = (PyoaCellObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaCell_FromoaCell(oaCell* data)
{
    if (data) {
       PyObject* bself = PyoaCell_Type.tp_alloc(&PyoaCell_Type,0);
       if (bself == NULL) return bself;
       PyoaCellObject* self = (PyoaCellObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaCell_destroy_doc[] = 
"Class: oaCell, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function destroys this oaCell.\n"
"    This function requires write access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if write access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaCell_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCell data;
    int convert_status=PyoaCell_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCellObject* self=(PyoaCellObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCell_getCellViews_doc[] = 
"Class: oaCell, Function: getCellViews\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaCellView_oaCell getCellViews() const\n"
"    Signature: getCellViews|simple-oaCollection_oaCellView_oaCell|\n"
"    BrowseData: 1\n"
"    This function returns a collection of the cellViews which are defined using this cell.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaCell_getCellViews(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCell data;
    int convert_status=PyoaCell_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCellObject* self=(PyoaCellObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaCellView_oaCell* result= new oaCollection_oaCellView_oaCell(data.DataCall()->getCellViews());
        return PyoaCollection_oaCellView_oaCell_FromoaCollection_oaCellView_oaCell(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCell_getCellViewsIter_doc[] = 
"Class: oaCell, Function: getCellViewsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaCellView getCellViewsIter() const\n"
"    Signature: getCellViewsIter|simple-oaIter_oaCellView|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of the cellViews which are defined using this cell.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaCell_getCellViewsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCell data;
    int convert_status=PyoaCell_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCellObject* self=(PyoaCellObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaCellView* result= new oaIter_oaCellView(data.DataCall()->getCellViews());
        return PyoaIter_oaCellView_FromoaIter_oaCellView(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCell_getName_doc[] = 
"Class: oaCell, Function: getName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getName(oaScalarName& name) const\n"
"    Signature: getName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the name of this cell.\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& out) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the name of this cell in the specified namespace.\n"
;

static PyObject*
oaCell_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCell data;
    int convert_status=PyoaCell_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCellObject* self=(PyoaCellObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaCell, function: getName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCell_isNull_doc[] =
"Class: oaCell, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaCell_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaCell data;
    int convert_status=PyoaCell_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaCell_assign_doc[] = 
"Class: oaCell, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaCell_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaCell data;
  int convert_status=PyoaCell_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaCell p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaCell_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaCell_methodlist[] = {
    {"destroy",(PyCFunction)oaCell_destroy,METH_VARARGS,oaCell_destroy_doc},
    {"getCellViews",(PyCFunction)oaCell_getCellViews,METH_VARARGS,oaCell_getCellViews_doc},
    {"getCellViewsIter",(PyCFunction)oaCell_getCellViewsIter,METH_VARARGS,oaCell_getCellViewsIter_doc},
    {"getName",(PyCFunction)oaCell_getName,METH_VARARGS,oaCell_getName_doc},
    {"isNull",(PyCFunction)oaCell_tp_isNull,METH_VARARGS,oaCell_isNull_doc},
    {"assign",(PyCFunction)oaCell_tp_assign,METH_VARARGS,oaCell_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaCell_doc[] = 
"Class: oaCell\n"
"  The oaCell class implements an OpenAccess library cell object.\n"
"  The oaCell class can be observed by deriving from\n"
"  Note: The oaCell function descriptions indicate if library access is required for the called function. If the access type must be write access, this requirement also is noted.\n"
"  For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"Constructors:\n"
"  Paramegers: (oaCell)\n"
"    Calls: (const oaCell&)\n"
"    Signature: oaCell||cref-oaCell,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaCell_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaCell",
    sizeof(PyoaCellObject),
    0,
    (destructor)oaCell_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaCell_tp_compare,	/* tp_compare */
    (reprfunc)oaCell_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaCell_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaCell_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaDMContainer_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaCell_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaCell_static_find_doc[] = 
"Class: oaCell, Function: find\n"
"  Paramegers: (oaLib,oaScalarName)\n"
"    Calls: oaCell* find(const oaLib* lib,const oaScalarName& name)\n"
"    Signature: find|ptr-oaCell|cptr-oaLib,cref-oaScalarName,\n"
"    This function finds and returns the cell with the specified name if it exists. If not found, NULL is returned.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaCell_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaLib p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaLib_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaCellp result= (oaCell::find(p1.Data(),p2.Data()));
        return PyoaCell_FromoaCell(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCell_static_get_doc[] = 
"Class: oaCell, Function: get\n"
"  Paramegers: (oaLib,oaScalarName)\n"
"    Calls: oaCell* get(const oaLib* lib,const oaScalarName& name)\n"
"    Signature: get|ptr-oaCell|cptr-oaLib,cref-oaScalarName,\n"
"    This function finds and returns the cell with the specified name if it exists. If not found, it is created, and the new cell is returned.\n"
"    This function requires write access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if write access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaCell_static_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaLib p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaLib_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaCellp result= (oaCell::get(p1.Data(),p2.Data()));
        return PyoaCell_FromoaCell(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaCell_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaCell_static_find,METH_VARARGS,oaCell_static_find_doc},
    {"static_get",(PyCFunction)oaCell_static_get,METH_VARARGS,oaCell_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaCell_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaCell_Type)<0) {
      printf("** PyType_Ready failed for: oaCell\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaCell",
           (PyObject*)(&PyoaCell_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaCell\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaCell_Type.tp_dict;
    for(method=oaCell_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaCellDMData
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaCellDMData_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaCellDMData_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaCellDMDataObject* self = (PyoaCellDMDataObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaCellDMData)
    {
        PyParamoaCellDMData p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaCellDMData_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaCellDMData, Choices are:\n"
        "    (oaCellDMData)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaCellDMData_tp_dealloc(PyoaCellDMDataObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaCellDMData_tp_repr(PyObject *ob)
{
    PyParamoaCellDMData value;
    int convert_status=PyoaCellDMData_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[34];
    sprintf(buffer,"<oaCellDMData::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaCellDMData_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaCellDMData v1;
    PyParamoaCellDMData v2;
    int convert_status1=PyoaCellDMData_Convert(ob1,&v1);
    int convert_status2=PyoaCellDMData_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaCellDMData_Convert(PyObject* ob,PyParamoaCellDMData* result)
{
    if (ob == NULL) return 1;
    if (PyoaCellDMData_Check(ob)) {
        result->SetData( (oaCellDMData**) ((PyoaCellDMDataObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaCellDMData Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaCellDMData_FromoaCellDMData(oaCellDMData** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaCellDMData* data=*value;
        PyObject* bself = PyoaCellDMData_Type.tp_alloc(&PyoaCellDMData_Type,0);
        if (bself == NULL) return bself;
        PyoaCellDMDataObject* self = (PyoaCellDMDataObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaCellDMData_FromoaCellDMData(oaCellDMData* data)
{
    if (data) {
       PyObject* bself = PyoaCellDMData_Type.tp_alloc(&PyoaCellDMData_Type,0);
       if (bself == NULL) return bself;
       PyoaCellDMDataObject* self = (PyoaCellDMDataObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaCellDMData_getCellName_doc[] = 
"Class: oaCellDMData, Function: getCellName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getCellName(oaScalarName& cellName) const\n"
"    Signature: getCellName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the cell name for this oaCellDMData object.\n"
"    cellName\n"
"    the returned oaScalarName cell name\n"
"    oacInvalidCell\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getCellName(const oaNameSpace& ns,oaString& cellName) const\n"
"    Signature: getCellName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the cell name for this oaCellDMData object in the specified nameSpace.\n"
"    ns\n"
"    input parameter - the name space in which to return the cell name\n"
"    cellName\n"
"    the returned oaString cell name\n"
"    oacInvalidCell\n"
"    oacDMDataCannotGetReadAccess\n"
;

static PyObject*
oaCellDMData_getCellName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCellDMData data;
    int convert_status=PyoaCellDMData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCellDMDataObject* self=(PyoaCellDMDataObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getCellName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getCellName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaCellDMData, function: getCellName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCellDMData_isNull_doc[] =
"Class: oaCellDMData, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaCellDMData_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaCellDMData data;
    int convert_status=PyoaCellDMData_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaCellDMData_assign_doc[] = 
"Class: oaCellDMData, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaCellDMData_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaCellDMData data;
  int convert_status=PyoaCellDMData_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaCellDMData p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaCellDMData_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaCellDMData_methodlist[] = {
    {"getCellName",(PyCFunction)oaCellDMData_getCellName,METH_VARARGS,oaCellDMData_getCellName_doc},
    {"isNull",(PyCFunction)oaCellDMData_tp_isNull,METH_VARARGS,oaCellDMData_isNull_doc},
    {"assign",(PyCFunction)oaCellDMData_tp_assign,METH_VARARGS,oaCellDMData_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaCellDMData_doc[] = 
"Class: oaCellDMData\n"
"  oaCellDMData objects represent database objects that can be associated with a DM cell and can be used to persistently store properties ( oaProp objects), groups ( oaGroup objects), group members ( oaGroupMember objects) and application objects (see oaAppObject .)\n"
"Constructors:\n"
"  Paramegers: (oaCellDMData)\n"
"    Calls: (const oaCellDMData&)\n"
"    Signature: oaCellDMData||cref-oaCellDMData,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaCellDMData_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaCellDMData",
    sizeof(PyoaCellDMDataObject),
    0,
    (destructor)oaCellDMData_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaCellDMData_tp_compare,	/* tp_compare */
    (reprfunc)oaCellDMData_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaCellDMData_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaCellDMData_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaDMData_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaCellDMData_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaCellDMData_static_destroy_doc[] = 
"Class: oaCellDMData, Function: destroy\n"
"  Paramegers: (oaScalarName,oaScalarName)\n"
"    Calls: void destroy(const oaScalarName& libName,const oaScalarName& cellName)\n"
"    Signature: destroy|void-void|cref-oaScalarName,cref-oaScalarName,\n"
"    This function attempts to remove the dmData from disk. It throws an exception if the dmData is currently open or if the dmData cannot be found on disk.\n"
"    libName\n"
"    The name of the library\n"
"    cellName\n"
"    The name of the cell whose CellDMData is to be destroyed\n"
"    oacLibNotFound\n"
"    oacDestroyDMDataDoesNotExist\n"
"    oacDMDataHasReadNeedWriteAccess\n"
"    oacDMDataCannotGetWriteAccess\n"
"    oacDestroyDMDataOpen\n"
"    oacDestroyDMDataDoesNotExist\n"
;

static PyObject*
oaCellDMData_static_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaScalarName p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaScalarName_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        oaCellDMData::destroy(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCellDMData_static_exists_doc[] = 
"Class: oaCellDMData, Function: exists\n"
"  Paramegers: (oaScalarName,oaScalarName)\n"
"    Calls: oaBoolean exists(const oaScalarName& libName,const oaScalarName& cellName)\n"
"    Signature: exists|simple-oaBoolean|cref-oaScalarName,cref-oaScalarName,\n"
"    This function checks if there is a DMData open for the given library, or if a DMData file exists on disk with a non-zero size.\n"
"    libName\n"
"    The name of the library in which the lookup will happen\n"
"    cellName\n"
"    The name of the cell whose CellDMData existence is to be checked\n"
"    oacDMDataCannotGetReadAccess\n"
;

static PyObject*
oaCellDMData_static_exists(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaScalarName p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaScalarName_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        oaBoolean result= (oaCellDMData::exists(p1.Data(),p2.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCellDMData_static_find_doc[] = 
"Class: oaCellDMData, Function: find\n"
"  Paramegers: (oaScalarName,oaScalarName)\n"
"    Calls: oaCellDMData* find(const oaScalarName& libName,const oaScalarName& cellName)\n"
"    Signature: find|ptr-oaCellDMData|cref-oaScalarName,cref-oaScalarName,\n"
"    This function attempts to find an open DM data for the given library. If successful, a pointer to the DMData object is returned; otherwise, NULL is returned.\n"
"    libName\n"
"    The name of the library in which the lookup will happen\n"
"    cellName\n"
"    The name of the cell whose CellDMData is to be found\n"
"    oacDMDataCannotGetReadAccess\n"
;

static PyObject*
oaCellDMData_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaScalarName p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaScalarName_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        oaCellDMDatap result= (oaCellDMData::find(p1.Data(),p2.Data()));
        return PyoaCellDMData_FromoaCellDMData(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCellDMData_static_open_doc[] = 
"Class: oaCellDMData, Function: open\n"
"  Paramegers: (oaScalarName,oaScalarName,oaChar)\n"
"    Calls: oaCellDMData* open(const oaScalarName& libName,const oaScalarName& cellName,oaChar mode)\n"
"    Signature: open|ptr-oaCellDMData|cref-oaScalarName,cref-oaScalarName,simple-oaChar,\n"
"    This function attempts to open the oaCellDMData object for the cell with the specified name in the specified library with the specified mode. If the specified mode is a write-access mode ('a'ppend or 'w'rite mode) and the oaCellDMData does not exist, it will be created. If the specified mode is a read-access mode ('r'ead-only mode) and the oaCellDMData does not exist, an oacDMDataDoesNotExist exception will be thrown.\n"
"    If successful, a pointer to the CellDMData object is returned.\n"
"    libName\n"
"    The name of the library to use\n"
"    cellName\n"
"    The name of the cell whose DMData is to be opened\n"
"    mode\n"
"    The mode to use to open the DMData\n"
"    oacOpenUndefinedModeDMData\n"
"    oacLibNotFound\n"
"    oacCellNotFound\n"
"    oacDMDataCannotGetReadAccess\n"
"    oacDMDataHasReadNeedWriteAccess\n"
"    oacDMDataCannotGetWriteAccess\n"
;

static PyObject*
oaCellDMData_static_open(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaScalarName p1;
    PyParamoaScalarName p2;
    PyParamoaChar p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaScalarName_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaChar_Convert,&p3)) {
        oaCellDMDatap result= (oaCellDMData::open(p1.Data(),p2.Data(),p3.Data()));
        return PyoaCellDMData_FromoaCellDMData(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaCellDMData_staticmethodlist[] = {
    {"static_destroy",(PyCFunction)oaCellDMData_static_destroy,METH_VARARGS,oaCellDMData_static_destroy_doc},
    {"static_exists",(PyCFunction)oaCellDMData_static_exists,METH_VARARGS,oaCellDMData_static_exists_doc},
    {"static_find",(PyCFunction)oaCellDMData_static_find,METH_VARARGS,oaCellDMData_static_find_doc},
    {"static_open",(PyCFunction)oaCellDMData_static_open,METH_VARARGS,oaCellDMData_static_open_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaCellDMData_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaCellDMData_Type)<0) {
      printf("** PyType_Ready failed for: oaCellDMData\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaCellDMData",
           (PyObject*)(&PyoaCellDMData_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaCellDMData\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaCellDMData_Type.tp_dict;
    for(method=oaCellDMData_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaCellModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaCellModTypeEnum_Convert(PyObject* ob,PyParamoaCellModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaCellModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaCellModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaCellModTypeEnum_FromoaCellModTypeEnum(oaCellModTypeEnum ob)
{

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaCellModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaCellModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaCellModTypeEnum_FromoaCellModTypeEnum(oaCellModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaCellModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaCellModTypeEnum_doc[] =
"Type convert function for enum: oaCellModTypeEnum";
                               
static PyMethodDef PyoaCellModTypeEnum_method =
  {"oaCellModTypeEnum",(PyCFunction)PyoaCellModTypeEnum_TypeFunction,METH_VARARGS,oaCellModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaCellModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaCellModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaCellModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaCellModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaCellType
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaCellType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaCellType_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaCellTypeObject* self = (PyoaCellTypeObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaCellTypeEnum)
    {
        PyParamoaCellTypeEnum p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaCellTypeEnum_Convert,&p1)) {
            self->value =  new oaCellType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            self->value =  new oaCellType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaCellType)
    {
        PyParamoaCellType p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaCellType_Convert,&p1)) {
            self->value= new oaCellType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaCellType, Choices are:\n"
        "    (oaCellTypeEnum)\n"
        "    (oaString)\n"
        "    (oaCellType)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaCellType_tp_dealloc(PyoaCellTypeObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaCellType_tp_repr(PyObject *ob)
{
    PyParamoaCellType value;
    int convert_status=PyoaCellType_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    oaString sresult(value.DataCall()->getName());

    char addr[32];
    sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
    oaString buffer;
    buffer+=oaString("<oaCellType::");
    buffer+=oaString(addr);
    buffer+=oaString("::");
    buffer+=oaString(sresult);
    buffer+=oaString(">");
    result=PyString_FromString((char*)(const char*)buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaCellType_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaCellType v1;
    PyParamoaCellType v2;
    int convert_status1=PyoaCellType_Convert(ob1,&v1);
    int convert_status2=PyoaCellType_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaCellType_Convert(PyObject* ob,PyParamoaCellType* result)
{
    if (ob == NULL) return 1;
    if (PyoaCellType_Check(ob)) {
        result->SetData(  ((PyoaCellTypeObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaCellType Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaCellType_FromoaCellType(oaCellType* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaCellType_Type.tp_alloc(&PyoaCellType_Type,0);
        if (bself == NULL) return bself;
        PyoaCellTypeObject* self = (PyoaCellTypeObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaCellType_getName_doc[] = 
"Class: oaCellType, Function: getName\n"
"  Paramegers: ()\n"
"    Calls: const oaString& getName() const\n"
"    Signature: getName|cref-oaString|\n"
"    BrowseData: 1\n"
"    This function returns the name string associated with the encapsulated #oaCellTypeEnum object.\n"
;

static PyObject*
oaCellType_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCellType data;
    int convert_status=PyoaCellType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCellTypeObject* self=(PyoaCellTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaString result= (data.DataCall()->getName());
        return PyoaString_FromoaString(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCellType_oaCellTypeEnum_doc[] = 
"Class: oaCellType, Function: oaCellTypeEnum\n"
"  Paramegers: ()\n"
"    Calls: oaCellTypeEnum oaCellTypeEnum() const\n"
"    Signature: operator oaCellTypeEnum|simple-oaCellTypeEnum|\n"
"    BrowseData: 1\n"
"    This function casts this oaCellType object into the corresponding #oaCellTypeEnum value.\n"
;

static PyObject*
oaCellType_oaCellTypeEnum(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCellType data;
    int convert_status=PyoaCellType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCellTypeObject* self=(PyoaCellTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaCellTypeEnum result= (data.DataCall()->operator oaCellTypeEnum());
        return PyoaCellTypeEnum_FromoaCellTypeEnum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaCellType_assign_doc[] = 
"Class: oaCellType, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaCellType_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaCellType data;
  int convert_status=PyoaCellType_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaCellType p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaCellType_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaCellType_methodlist[] = {
    {"getName",(PyCFunction)oaCellType_getName,METH_VARARGS,oaCellType_getName_doc},
    {"oaCellTypeEnum",(PyCFunction)oaCellType_oaCellTypeEnum,METH_VARARGS,oaCellType_oaCellTypeEnum_doc},
    {"assign",(PyCFunction)oaCellType_tp_assign,METH_VARARGS,oaCellType_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaCellType_doc[] = 
"Class: oaCellType\n"
"  The oaCellType class is an enum wrapper for the values that describe the specialized uses of an oaDesign with an oaDesignType of oacMaskLayout.\n"
"  See Enum Wrappers in the Programmers Guide for a discussion of enum wrappers.\n"
"  oaCellTypeEnum\n"
"Constructors:\n"
"  Paramegers: (oaCellTypeEnum)\n"
"    Calls: oaCellType(oaCellTypeEnum valueIn)\n"
"    Signature: oaCellType||simple-oaCellTypeEnum,\n"
"    This function constructs an instance of an oaCellType class using the specified #oaCellTypeEnum value.\n"
"  Paramegers: (oaString)\n"
"    Calls: oaCellType(const oaString& name)\n"
"    Signature: oaCellType||cref-oaString,\n"
"    This function constructs an instance of an oaCellType class using the #oaCellTypeEnum associated with the specified string name . This name must be defined in the legal set of names associated with #oaCellTypeEnum.\n"
"    oacInvalidCellTypeName\n"
"  Paramegers: (oaCellType)\n"
"    Calls: (const oaCellType&)\n"
"    Signature: oaCellType||cref-oaCellType,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaCellType_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaCellType",
    sizeof(PyoaCellTypeObject),
    0,
    (destructor)oaCellType_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaCellType_tp_compare,	/* tp_compare */
    (reprfunc)oaCellType_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaCellType_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaCellType_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaCellType_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaCellType_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaCellType_Type)<0) {
      printf("** PyType_Ready failed for: oaCellType\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaCellType",
           (PyObject*)(&PyoaCellType_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaCellType\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaCellTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaCellTypeEnum_Convert(PyObject* ob,PyParamoaCellTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacNoCellType")==0) { result->SetData(oacNoCellType); return 1;}
        if (strcasecmp(str,"oacBlockCellType")==0) { result->SetData(oacBlockCellType); return 1;}
        if (strcasecmp(str,"oacBlockRingCellType")==0) { result->SetData(oacBlockRingCellType); return 1;}
        if (strcasecmp(str,"oacCoverCellType")==0) { result->SetData(oacCoverCellType); return 1;}
        if (strcasecmp(str,"oacCoverBumpCellType")==0) { result->SetData(oacCoverBumpCellType); return 1;}
        if (strcasecmp(str,"oacPadCellType")==0) { result->SetData(oacPadCellType); return 1;}
        if (strcasecmp(str,"oacPadSpacerCellType")==0) { result->SetData(oacPadSpacerCellType); return 1;}
        if (strcasecmp(str,"oacCoreCellType")==0) { result->SetData(oacCoreCellType); return 1;}
        if (strcasecmp(str,"oacCoreSpacerCellType")==0) { result->SetData(oacCoreSpacerCellType); return 1;}
        if (strcasecmp(str,"oacCoreAntennaCellType")==0) { result->SetData(oacCoreAntennaCellType); return 1;}
        if (strcasecmp(str,"oacCornerCellType")==0) { result->SetData(oacCornerCellType); return 1;}
        if (strcasecmp(str,"oacSoftMacroCellType")==0) { result->SetData(oacSoftMacroCellType); return 1;}
        if (strcasecmp(str,"oacViaCellType")==0) { result->SetData(oacViaCellType); return 1;}
        if (strcasecmp(str,"oacBlockBlackBoxCellType")==0) { result->SetData(oacBlockBlackBoxCellType); return 1;}
        if (strcasecmp(str,"oacPadAreaIOCellType")==0) { result->SetData(oacPadAreaIOCellType); return 1;}
        if (strcasecmp(str,"oacCoreWellTapCellType")==0) { result->SetData(oacCoreWellTapCellType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaCellTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaCellTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaCellTypeEnum_FromoaCellTypeEnum(oaCellTypeEnum ob)
{
    if (ob==oacNoCellType) return PyString_FromString("oacNoCellType");
    if (ob==oacBlockCellType) return PyString_FromString("oacBlockCellType");
    if (ob==oacBlockRingCellType) return PyString_FromString("oacBlockRingCellType");
    if (ob==oacCoverCellType) return PyString_FromString("oacCoverCellType");
    if (ob==oacCoverBumpCellType) return PyString_FromString("oacCoverBumpCellType");
    if (ob==oacPadCellType) return PyString_FromString("oacPadCellType");
    if (ob==oacPadSpacerCellType) return PyString_FromString("oacPadSpacerCellType");
    if (ob==oacCoreCellType) return PyString_FromString("oacCoreCellType");
    if (ob==oacCoreSpacerCellType) return PyString_FromString("oacCoreSpacerCellType");
    if (ob==oacCoreAntennaCellType) return PyString_FromString("oacCoreAntennaCellType");
    if (ob==oacCornerCellType) return PyString_FromString("oacCornerCellType");
    if (ob==oacSoftMacroCellType) return PyString_FromString("oacSoftMacroCellType");
    if (ob==oacViaCellType) return PyString_FromString("oacViaCellType");
    if (ob==oacBlockBlackBoxCellType) return PyString_FromString("oacBlockBlackBoxCellType");
    if (ob==oacPadAreaIOCellType) return PyString_FromString("oacPadAreaIOCellType");
    if (ob==oacCoreWellTapCellType) return PyString_FromString("oacCoreWellTapCellType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaCellTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaCellTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaCellTypeEnum_FromoaCellTypeEnum(oaCellTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaCellTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaCellTypeEnum_doc[] =
"Type convert function for enum: oaCellTypeEnum";
                               
static PyMethodDef PyoaCellTypeEnum_method =
  {"oaCellTypeEnum",(PyCFunction)PyoaCellTypeEnum_TypeFunction,METH_VARARGS,oaCellTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaCellTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacNoCellType");
    PyDict_SetItemString(mod_dict,"oacNoCellType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBlockCellType");
    PyDict_SetItemString(mod_dict,"oacBlockCellType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBlockRingCellType");
    PyDict_SetItemString(mod_dict,"oacBlockRingCellType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCoverCellType");
    PyDict_SetItemString(mod_dict,"oacCoverCellType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCoverBumpCellType");
    PyDict_SetItemString(mod_dict,"oacCoverBumpCellType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPadCellType");
    PyDict_SetItemString(mod_dict,"oacPadCellType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPadSpacerCellType");
    PyDict_SetItemString(mod_dict,"oacPadSpacerCellType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCoreCellType");
    PyDict_SetItemString(mod_dict,"oacCoreCellType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCoreSpacerCellType");
    PyDict_SetItemString(mod_dict,"oacCoreSpacerCellType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCoreAntennaCellType");
    PyDict_SetItemString(mod_dict,"oacCoreAntennaCellType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCornerCellType");
    PyDict_SetItemString(mod_dict,"oacCornerCellType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSoftMacroCellType");
    PyDict_SetItemString(mod_dict,"oacSoftMacroCellType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacViaCellType");
    PyDict_SetItemString(mod_dict,"oacViaCellType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBlockBlackBoxCellType");
    PyDict_SetItemString(mod_dict,"oacBlockBlackBoxCellType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPadAreaIOCellType");
    PyDict_SetItemString(mod_dict,"oacPadAreaIOCellType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCoreWellTapCellType");
    PyDict_SetItemString(mod_dict,"oacCoreWellTapCellType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaCellTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaCellTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaCellTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaCellView
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaCellView_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaCellView_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaCellViewObject* self = (PyoaCellViewObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaCellView)
    {
        PyParamoaCellView p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaCellView_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaCellView, Choices are:\n"
        "    (oaCellView)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaCellView_tp_dealloc(PyoaCellViewObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaCellView_tp_repr(PyObject *ob)
{
    PyParamoaCellView value;
    int convert_status=PyoaCellView_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaCellView::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaString sresult;
        oaString sep=" ";
        sep[(oaUInt4)0]=oacInternalHierDelimiter;
        oaScalarName name;
        oaString str;
        value.DataCall()->getCell()->getName(name);
        name.get(str);
        sresult+=oaString(str);
        sresult+=sep;
        value.DataCall()->getView()->getName(name);
        name.get(str);
        sresult+=oaString(str);
    
        char addr[32];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaCellView::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaCellView_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaCellView v1;
    PyParamoaCellView v2;
    int convert_status1=PyoaCellView_Convert(ob1,&v1);
    int convert_status2=PyoaCellView_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaCellView_Convert(PyObject* ob,PyParamoaCellView* result)
{
    if (ob == NULL) return 1;
    if (PyoaCellView_Check(ob)) {
        result->SetData( (oaCellView**) ((PyoaCellViewObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaCellView Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaCellView_FromoaCellView(oaCellView** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaCellView* data=*value;
        PyObject* bself = PyoaCellView_Type.tp_alloc(&PyoaCellView_Type,0);
        if (bself == NULL) return bself;
        PyoaCellViewObject* self = (PyoaCellViewObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaCellView_FromoaCellView(oaCellView* data)
{
    if (data) {
       PyObject* bself = PyoaCellView_Type.tp_alloc(&PyoaCellView_Type,0);
       if (bself == NULL) return bself;
       PyoaCellViewObject* self = (PyoaCellViewObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaCellView_destroy_doc[] = 
"Class: oaCellView, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function destroys the this oaCellView.\n"
"    This function requires write access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if write access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaCellView_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCellView data;
    int convert_status=PyoaCellView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCellViewObject* self=(PyoaCellViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCellView_getCell_doc[] = 
"Class: oaCellView, Function: getCell\n"
"  Paramegers: ()\n"
"    Calls: oaCell* getCell() const\n"
"    Signature: getCell|ptr-oaCell|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the cell for this cellView.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaCellView_getCell(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCellView data;
    int convert_status=PyoaCellView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCellViewObject* self=(PyoaCellViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCellp result= (data.DataCall()->getCell());
        return PyoaCell_FromoaCell(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCellView_getPrimary_doc[] = 
"Class: oaCellView, Function: getPrimary\n"
"  Paramegers: ()\n"
"    Calls: oaDMFile* getPrimary() const\n"
"    Signature: getPrimary|ptr-oaDMFile|\n"
"    BrowseData: 1\n"
"    This function returns the primary file for this cellView.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaCellView_getPrimary(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCellView data;
    int convert_status=PyoaCellView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCellViewObject* self=(PyoaCellViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaDMFilep result= (data.DataCall()->getPrimary());
        return PyoaDMFile_FromoaDMFile(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCellView_getView_doc[] = 
"Class: oaCellView, Function: getView\n"
"  Paramegers: ()\n"
"    Calls: oaView* getView() const\n"
"    Signature: getView|ptr-oaView|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the view for this cellView.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaCellView_getView(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCellView data;
    int convert_status=PyoaCellView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCellViewObject* self=(PyoaCellViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaViewp result= (data.DataCall()->getView());
        return PyoaView_FromoaView(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCellView_setView_doc[] = 
"Class: oaCellView, Function: setView\n"
"  Paramegers: (oaView)\n"
"    Calls: void setView(const oaView* view)\n"
"    Signature: setView|void-void|cptr-oaView,\n"
"    oaCellView::setView1\n"
"    This function modifies this cellView by associating it with the specified view.\n"
"    When using this version of the function, the existing primary data will be renamed to be of the appropriate type. An oacCVSetViewPrimaryFileExists exception will be thrown if the non-primary data of the specified type already exists in the cellView.\n"
"    Note: Two setView functions (with and without the mustExist argument) have been implemented in the current release to maintain drop-in compatibility. These two functions will be merged together at a later date.\n"
"    An oacCVExists exception is thrown if another cellView (a cellView other than this cellView) already exists with the cellName and viewName that this function is to set on this cellView.\n"
"    An oacCVSetViewPrimaryFileExists exception is thrown if a file already exists in the cellView with the same name to which the primary file is to be renamed.\n"
"    An oacCVSetViewPrimaryFileLocked exception is thrown if the primary file cannot be write-locked by the current process -- for example, because it is locked by another process.\n"
"    This function requires write access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if write access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    view\n"
"    input parameter - pointer to the view to set for this cellView\n"
"    oacCVExists\n"
"    oacCVSetViewPrimaryFileExists\n"
"    oacCVSetViewPrimaryFileLocked\n"
"    oacLibAccessDenied\n"
"  Paramegers: (oaView,oaBoolean)\n"
"    Calls: void setView(const oaView* view,oaBoolean mustExist)\n"
"    Signature: setView|void-void|cptr-oaView,simple-oaBoolean,\n"
"    This function modifies this cellView by associating it with the specified view.\n"
"    If mustExist is false, this version of the function operates the same as the version of this function that does not include the mustExist argument - the view is changed, and the primary data is renamed (see oaCellView::setView ).\n"
"    If the mustExist is true, this version of the function assumes that the cellView already contains the appropriate type of data but that it is not currently marked as the primary data for the cellView. This function makes this data the primary data. The original data is left in the cellView as non-primary data.\n"
"    Note: Two setView functions (with and without the mustExist argument) have been implemented in the current release to maintain drop-in compatibility. These two functions will be merged together at a later date.\n"
"    An oacCVSetViewPrimaryFileLocked exception is thrown if the primary file cannot be write-locked by the current process -- for example, because it is locked by another process.\n"
"    New: An oacCVSetViewPrimaryFileDoesNotExist exception is thrown if the file that corresponds to the new viewType does not exist in the cellView.\n"
"    This function requires write access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if write access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    view\n"
"    input parameter - pointer to the view to set for this cellView\n"
"    mustExist-\n"
"    boolean which should set to true in this version of the function\n"
"    oacCVSetViewPrimaryFileLocked\n"
"    oacCVSetViewPrimaryFileDoesNotExist\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaCellView_setView(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaCellView data;
    int convert_status=PyoaCellView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaCellViewObject* self=(PyoaCellViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaView)
    {
        PyParamoaView p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaView_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->setView(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaView,oaBoolean)
    {
        PyParamoaView p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaView_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->setView(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaCellView, function: setView, Choices are:\n"
        "    (oaView)\n"
        "    (oaView,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCellView_isNull_doc[] =
"Class: oaCellView, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaCellView_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaCellView data;
    int convert_status=PyoaCellView_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaCellView_assign_doc[] = 
"Class: oaCellView, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaCellView_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaCellView data;
  int convert_status=PyoaCellView_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaCellView p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaCellView_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaCellView_methodlist[] = {
    {"destroy",(PyCFunction)oaCellView_destroy,METH_VARARGS,oaCellView_destroy_doc},
    {"getCell",(PyCFunction)oaCellView_getCell,METH_VARARGS,oaCellView_getCell_doc},
    {"getPrimary",(PyCFunction)oaCellView_getPrimary,METH_VARARGS,oaCellView_getPrimary_doc},
    {"getView",(PyCFunction)oaCellView_getView,METH_VARARGS,oaCellView_getView_doc},
    {"setView",(PyCFunction)oaCellView_setView,METH_VARARGS,oaCellView_setView_doc},
    {"isNull",(PyCFunction)oaCellView_tp_isNull,METH_VARARGS,oaCellView_isNull_doc},
    {"assign",(PyCFunction)oaCellView_tp_assign,METH_VARARGS,oaCellView_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaCellView_doc[] = 
"Class: oaCellView\n"
"  The oaCellView class implements an OpenAccess library cellView file object.\n"
"  The oaCellView class can be observed by deriving from\n"
"  Note: The oaCellView function descriptions indicate if library access is required for the called function. If the access type must be write access, this requirement also is noted.\n"
"  For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"Constructors:\n"
"  Paramegers: (oaCellView)\n"
"    Calls: (const oaCellView&)\n"
"    Signature: oaCellView||cref-oaCellView,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaCellView_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaCellView",
    sizeof(PyoaCellViewObject),
    0,
    (destructor)oaCellView_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaCellView_tp_compare,	/* tp_compare */
    (reprfunc)oaCellView_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaCellView_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaCellView_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaDMContainer_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaCellView_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaCellView_static_find_doc[] = 
"Class: oaCellView, Function: find\n"
"  Paramegers: (oaCell,oaView)\n"
"    Calls: oaCellView* find(const oaCell* cell,const oaView* view)\n"
"    Signature: find|ptr-oaCellView|cptr-oaCell,cptr-oaView,\n"
"    This function finds and returns a pointer to the specified cellView. An exception is thrown if the specified cell and view are not in the same library. If not found, NULL is returned.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    oacCellViewNotInSameLib\n"
"    oacLibAccessDenied\n"
"  Paramegers: (oaLib,oaScalarName,oaScalarName)\n"
"    Calls: oaCellView* find(const oaLib* lib,const oaScalarName& cellName,const oaScalarName& viewName)\n"
"    Signature: find|ptr-oaCellView|cptr-oaLib,cref-oaScalarName,cref-oaScalarName,\n"
"    This functions finds and returns a pointer to the cellView specified by the cell and view names. If not found, NULL is returned.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaCellView_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaCell,oaView)
    {
        PyParamoaCell p1;
        PyParamoaView p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaCell_Convert,&p1,
              &PyoaView_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaCellViewp result= (oaCellView::find(p1.Data(),p2.Data()));
            return PyoaCellView_FromoaCellView(result);
        }
    }
    PyErr_Clear();
    // Case: (oaLib,oaScalarName,oaScalarName)
    {
        PyParamoaLib p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaLib_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaCellViewp result= (oaCellView::find(p1.Data(),p2.Data(),p3.Data()));
            return PyoaCellView_FromoaCellView(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaCellView, function: find, Choices are:\n"
        "    (oaCell,oaView)\n"
        "    (oaLib,oaScalarName,oaScalarName)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaCellView_static_get_doc[] = 
"Class: oaCellView, Function: get\n"
"  Paramegers: (oaCell,oaView)\n"
"    Calls: oaCellView* get(const oaCell* cell,const oaView* view)\n"
"    Signature: get|ptr-oaCellView|cptr-oaCell,cptr-oaView,\n"
"    This function finds and returns the cellView with the specified cell and view if it exists. If not found, it is created, and a pointer to the new cellView is returned. An exception is thrown if the specified cell and view are not in the same library. When a new cellview is created, a new dmFile as the primary of that cellview will be automatically created after that cellview itself is created. The users will get the postCreate callback on the cellview, followed by the postCreate callback on the primary file.\n"
"    This function requires write access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if the write access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    oacCellViewNotInSameLib\n"
"    oacLibAccessDenied\n"
"  Paramegers: (oaLib,oaScalarName,oaScalarName,oaViewType)\n"
"    Calls: oaCellView* get(const oaLib* lib,const oaScalarName& cellName,const oaScalarName& viewName,const oaViewType* viewType)\n"
"    Signature: get|ptr-oaCellView|cptr-oaLib,cref-oaScalarName,cref-oaScalarName,cptr-oaViewType,\n"
"    This function attempts to find and return the cellView specified by lib, cellName, viewName and viewType. If it cannot be found, an attempt is made to create the cellView while creating any missing cell and view owners. Proper library write access is required for the creation to be successful and an exception is thrown if this is not the case. If successful, a pointer to an oaCellView object is returned.\n"
"    lib\n"
"    A pointer to the oaLib object representing the library\n"
"    cellName\n"
"    A constant reference to an oaScalarName object holding the name of the cell\n"
"    viewName\n"
"    A constant reference to an oaScalarName object holding the name of the view\n"
"    viewType\n"
"    A pointer to a constant viewType object specifying the type of view to obtain\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaCellView_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaCell,oaView)
    {
        PyParamoaCell p1;
        PyParamoaView p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaCell_Convert,&p1,
              &PyoaView_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaCellViewp result= (oaCellView::get(p1.Data(),p2.Data()));
            return PyoaCellView_FromoaCellView(result);
        }
    }
    PyErr_Clear();
    // Case: (oaLib,oaScalarName,oaScalarName,oaViewType)
    {
        PyParamoaLib p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaViewType p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaLib_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaViewType_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p4.Data(),4)) return NULL;
            oaCellViewp result= (oaCellView::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaCellView_FromoaCellView(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaCellView, function: get, Choices are:\n"
        "    (oaCell,oaView)\n"
        "    (oaLib,oaScalarName,oaScalarName,oaViewType)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaCellView_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaCellView_static_find,METH_VARARGS,oaCellView_static_find_doc},
    {"static_get",(PyCFunction)oaCellView_static_get,METH_VARARGS,oaCellView_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaCellView_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaCellView_Type)<0) {
      printf("** PyType_Ready failed for: oaCellView\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaCellView",
           (PyObject*)(&PyoaCellView_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaCellView\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaCellView_Type.tp_dict;
    for(method=oaCellView_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}

