
/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVarDataAppDef_oaSiteDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaSiteDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVarDataAppDef_oaSiteDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVarDataAppDef_oaSiteDefObject* self = (PyoaVarDataAppDef_oaSiteDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaVarDataAppDef_oaSiteDef)
    {
        PyParamoaVarDataAppDef_oaSiteDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVarDataAppDef_oaSiteDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVarDataAppDef_oaSiteDef, Choices are:\n"
        "    (oaVarDataAppDef_oaSiteDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVarDataAppDef_oaSiteDef_tp_dealloc(PyoaVarDataAppDef_oaSiteDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaSiteDef_tp_repr(PyObject *ob)
{
    PyParamoaVarDataAppDef_oaSiteDef value;
    int convert_status=PyoaVarDataAppDef_oaSiteDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[47];
    sprintf(buffer,"<oaVarDataAppDef_oaSiteDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVarDataAppDef_oaSiteDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVarDataAppDef_oaSiteDef v1;
    PyParamoaVarDataAppDef_oaSiteDef v2;
    int convert_status1=PyoaVarDataAppDef_oaSiteDef_Convert(ob1,&v1);
    int convert_status2=PyoaVarDataAppDef_oaSiteDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVarDataAppDef_oaSiteDef_Convert(PyObject* ob,PyParamoaVarDataAppDef_oaSiteDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaVarDataAppDef_oaSiteDef_Check(ob)) {
        result->SetData( (oaVarDataAppDef_oaSiteDef**) ((PyoaVarDataAppDef_oaSiteDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVarDataAppDef_oaSiteDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaSiteDef_FromoaVarDataAppDef_oaSiteDef(oaVarDataAppDef_oaSiteDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaVarDataAppDef_oaSiteDef* data=*value;
        PyObject* bself = PyoaVarDataAppDef_oaSiteDef_Type.tp_alloc(&PyoaVarDataAppDef_oaSiteDef_Type,0);
        if (bself == NULL) return bself;
        PyoaVarDataAppDef_oaSiteDefObject* self = (PyoaVarDataAppDef_oaSiteDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaSiteDef_FromoaVarDataAppDef_oaSiteDef(oaVarDataAppDef_oaSiteDef* data)
{
    if (data) {
       PyObject* bself = PyoaVarDataAppDef_oaSiteDef_Type.tp_alloc(&PyoaVarDataAppDef_oaSiteDef_Type,0);
       if (bself == NULL) return bself;
       PyoaVarDataAppDef_oaSiteDefObject* self = (PyoaVarDataAppDef_oaSiteDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaSiteDef_get_doc[] = 
"Class: oaVarDataAppDef_oaSiteDef, Function: get\n"
"  Paramegers: (oaSiteDef,[oaByte])\n"
"    Calls: void get(const oaSiteDef* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaSiteDef,ptr-oaByte,\n"
"    This function returns the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaSiteDef_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaSiteDef data;
    int convert_status=PyoaVarDataAppDef_oaSiteDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaSiteDefObject* self=(PyoaVarDataAppDef_oaSiteDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaSiteDef p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaSiteDef_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize(p1.Data())==p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match object data");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaSiteDef_getDefault_doc[] = 
"Class: oaVarDataAppDef_oaSiteDef, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value for this extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to be filled out with the default value\n"
;

static PyObject*
oaVarDataAppDef_oaSiteDef_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaSiteDef data;
    int convert_status=PyoaVarDataAppDef_oaSiteDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaSiteDefObject* self=(PyoaVarDataAppDef_oaSiteDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getDefaultSize()==p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match default size");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaSiteDef_getDefaultSize_doc[] = 
"Class: oaVarDataAppDef_oaSiteDef, Function: getDefaultSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getDefaultSize() const\n"
"    Signature: getDefaultSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the default size for this extension in bytes.\n"
;

static PyObject*
oaVarDataAppDef_oaSiteDef_getDefaultSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaSiteDef data;
    int convert_status=PyoaVarDataAppDef_oaSiteDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaSiteDefObject* self=(PyoaVarDataAppDef_oaSiteDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getDefaultSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaSiteDef_getSize_doc[] = 
"Class: oaVarDataAppDef_oaSiteDef, Function: getSize\n"
"  Paramegers: (oaSiteDef)\n"
"    Calls: oaUInt4 getSize(const oaSiteDef* object)\n"
"    Signature: getSize|simple-oaUInt4|cptr-oaSiteDef,\n"
"    This function returns the size of the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaSiteDef_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaSiteDef data;
    int convert_status=PyoaVarDataAppDef_oaSiteDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaSiteDefObject* self=(PyoaVarDataAppDef_oaSiteDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaSiteDef p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaSiteDef_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (data.DataCall()->getSize(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaSiteDef_set_doc[] = 
"Class: oaVarDataAppDef_oaSiteDef, Function: set\n"
"  Paramegers: (oaSiteDef,[oaByte])\n"
"    Calls: void set(oaSiteDef* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaSiteDef,simple-oaUInt4,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaSiteDef_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaSiteDef data;
    int convert_status=PyoaVarDataAppDef_oaSiteDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaSiteDefObject* self=(PyoaVarDataAppDef_oaSiteDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaSiteDef p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaSiteDef_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaSiteDef_isNull_doc[] =
"Class: oaVarDataAppDef_oaSiteDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaVarDataAppDef_oaSiteDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaVarDataAppDef_oaSiteDef data;
    int convert_status=PyoaVarDataAppDef_oaSiteDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaVarDataAppDef_oaSiteDef_assign_doc[] = 
"Class: oaVarDataAppDef_oaSiteDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVarDataAppDef_oaSiteDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVarDataAppDef_oaSiteDef data;
  int convert_status=PyoaVarDataAppDef_oaSiteDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVarDataAppDef_oaSiteDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVarDataAppDef_oaSiteDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVarDataAppDef_oaSiteDef_methodlist[] = {
    {"get",(PyCFunction)oaVarDataAppDef_oaSiteDef_get,METH_VARARGS,oaVarDataAppDef_oaSiteDef_get_doc},
    {"getDefault",(PyCFunction)oaVarDataAppDef_oaSiteDef_getDefault,METH_VARARGS,oaVarDataAppDef_oaSiteDef_getDefault_doc},
    {"getDefaultSize",(PyCFunction)oaVarDataAppDef_oaSiteDef_getDefaultSize,METH_VARARGS,oaVarDataAppDef_oaSiteDef_getDefaultSize_doc},
    {"getSize",(PyCFunction)oaVarDataAppDef_oaSiteDef_getSize,METH_VARARGS,oaVarDataAppDef_oaSiteDef_getSize_doc},
    {"set",(PyCFunction)oaVarDataAppDef_oaSiteDef_set,METH_VARARGS,oaVarDataAppDef_oaSiteDef_set_doc},
    {"isNull",(PyCFunction)oaVarDataAppDef_oaSiteDef_tp_isNull,METH_VARARGS,oaVarDataAppDef_oaSiteDef_isNull_doc},
    {"assign",(PyCFunction)oaVarDataAppDef_oaSiteDef_tp_assign,METH_VARARGS,oaVarDataAppDef_oaSiteDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaSiteDef_doc[] = 
"Class: oaVarDataAppDef_oaSiteDef\n"
"  The oaVarDataAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When the objects are created, a data field is added to each object of the specified dataType. Applications can use the new data field for whatever purpose is necessary.\n"
"  This type of extension is useful because it allows variable-sized data for each object being extended. This is similar to the oaDataAppDef class, but more general because the data size can differ for each object. (There is a minor speed and size penalty for this additional flexibility.) The default value for this extension is zero bytes.\n"
"  Note: Because the type of data is unknown to OpenAccess, it is unmanaged. This means the contents are not byte-swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaVarDataAppDef_oaSiteDef)\n"
"    Calls: (const oaVarDataAppDef_oaSiteDef&)\n"
"    Signature: oaVarDataAppDef_oaSiteDef||cref-oaVarDataAppDef_oaSiteDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVarDataAppDef_oaSiteDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVarDataAppDef_oaSiteDef",
    sizeof(PyoaVarDataAppDef_oaSiteDefObject),
    0,
    (destructor)oaVarDataAppDef_oaSiteDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVarDataAppDef_oaSiteDef_tp_compare,	/* tp_compare */
    (reprfunc)oaVarDataAppDef_oaSiteDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVarDataAppDef_oaSiteDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVarDataAppDef_oaSiteDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVarDataAppDef_oaSiteDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaSiteDef_static_find_doc[] = 
"Class: oaVarDataAppDef_oaSiteDef, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaSiteDef* find(const oaString& name)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaSiteDef|cref-oaString,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaSiteDef* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaSiteDef|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaVarDataAppDef_oaSiteDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaSiteDefp result= (oaVarDataAppDef_oaSiteDef::find(p1.Data()));
            return PyoaVarDataAppDef_oaSiteDef_FromoaVarDataAppDef_oaSiteDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaSiteDefp result= (oaVarDataAppDef_oaSiteDef::find(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaSiteDef_FromoaVarDataAppDef_oaSiteDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaSiteDef, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaSiteDef_static_get_doc[] = 
"Class: oaVarDataAppDef_oaSiteDef, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaSiteDef* get(const oaString& name)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaSiteDef|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaSiteDef* get(const oaString& name,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaSiteDef|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaSiteDef* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaSiteDef|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaSiteDef* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaSiteDef|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaSiteDef* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaSiteDef|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaSiteDef* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaSiteDef|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
;

static PyObject*
oaVarDataAppDef_oaSiteDef_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaSiteDefp result= (oaVarDataAppDef_oaSiteDef::get(p1.Data()));
            return PyoaVarDataAppDef_oaSiteDef_FromoaVarDataAppDef_oaSiteDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaVarDataAppDef_oaSiteDefp result= (oaVarDataAppDef_oaSiteDef::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaSiteDef_FromoaVarDataAppDef_oaSiteDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaVarDataAppDef_oaSiteDefp result= (oaVarDataAppDef_oaSiteDef::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaSiteDef_FromoaVarDataAppDef_oaSiteDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaSiteDefp result= (oaVarDataAppDef_oaSiteDef::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaSiteDef_FromoaVarDataAppDef_oaSiteDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaSiteDefp result= (oaVarDataAppDef_oaSiteDef::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaSiteDef_FromoaVarDataAppDef_oaSiteDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaSiteDefp result= (oaVarDataAppDef_oaSiteDef::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaVarDataAppDef_oaSiteDef_FromoaVarDataAppDef_oaSiteDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaSiteDef, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaVarDataAppDef_oaSiteDef_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaVarDataAppDef_oaSiteDef_static_find,METH_VARARGS,oaVarDataAppDef_oaSiteDef_static_find_doc},
    {"static_get",(PyCFunction)oaVarDataAppDef_oaSiteDef_static_get,METH_VARARGS,oaVarDataAppDef_oaSiteDef_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVarDataAppDef_oaSiteDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVarDataAppDef_oaSiteDef_Type)<0) {
      printf("** PyType_Ready failed for: oaVarDataAppDef_oaSiteDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVarDataAppDef_oaSiteDef",
           (PyObject*)(&PyoaVarDataAppDef_oaSiteDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVarDataAppDef_oaSiteDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaVarDataAppDef_oaSiteDef_Type.tp_dict;
    for(method=oaVarDataAppDef_oaSiteDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVarDataAppDef_oaSteiner
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaSteiner_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVarDataAppDef_oaSteiner_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVarDataAppDef_oaSteinerObject* self = (PyoaVarDataAppDef_oaSteinerObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaVarDataAppDef_oaSteiner)
    {
        PyParamoaVarDataAppDef_oaSteiner p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVarDataAppDef_oaSteiner_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVarDataAppDef_oaSteiner, Choices are:\n"
        "    (oaVarDataAppDef_oaSteiner)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVarDataAppDef_oaSteiner_tp_dealloc(PyoaVarDataAppDef_oaSteinerObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaSteiner_tp_repr(PyObject *ob)
{
    PyParamoaVarDataAppDef_oaSteiner value;
    int convert_status=PyoaVarDataAppDef_oaSteiner_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[47];
    sprintf(buffer,"<oaVarDataAppDef_oaSteiner::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVarDataAppDef_oaSteiner_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVarDataAppDef_oaSteiner v1;
    PyParamoaVarDataAppDef_oaSteiner v2;
    int convert_status1=PyoaVarDataAppDef_oaSteiner_Convert(ob1,&v1);
    int convert_status2=PyoaVarDataAppDef_oaSteiner_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVarDataAppDef_oaSteiner_Convert(PyObject* ob,PyParamoaVarDataAppDef_oaSteiner* result)
{
    if (ob == NULL) return 1;
    if (PyoaVarDataAppDef_oaSteiner_Check(ob)) {
        result->SetData( (oaVarDataAppDef_oaSteiner**) ((PyoaVarDataAppDef_oaSteinerObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVarDataAppDef_oaSteiner Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaSteiner_FromoaVarDataAppDef_oaSteiner(oaVarDataAppDef_oaSteiner** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaVarDataAppDef_oaSteiner* data=*value;
        PyObject* bself = PyoaVarDataAppDef_oaSteiner_Type.tp_alloc(&PyoaVarDataAppDef_oaSteiner_Type,0);
        if (bself == NULL) return bself;
        PyoaVarDataAppDef_oaSteinerObject* self = (PyoaVarDataAppDef_oaSteinerObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaSteiner_FromoaVarDataAppDef_oaSteiner(oaVarDataAppDef_oaSteiner* data)
{
    if (data) {
       PyObject* bself = PyoaVarDataAppDef_oaSteiner_Type.tp_alloc(&PyoaVarDataAppDef_oaSteiner_Type,0);
       if (bself == NULL) return bself;
       PyoaVarDataAppDef_oaSteinerObject* self = (PyoaVarDataAppDef_oaSteinerObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaSteiner_get_doc[] = 
"Class: oaVarDataAppDef_oaSteiner, Function: get\n"
"  Paramegers: (oaSteiner,[oaByte])\n"
"    Calls: void get(const oaSteiner* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaSteiner,ptr-oaByte,\n"
"    This function returns the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaSteiner_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaSteiner data;
    int convert_status=PyoaVarDataAppDef_oaSteiner_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaSteinerObject* self=(PyoaVarDataAppDef_oaSteinerObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaSteiner p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaSteiner_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize(p1.Data())==p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match object data");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaSteiner_getDefault_doc[] = 
"Class: oaVarDataAppDef_oaSteiner, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value for this extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to be filled out with the default value\n"
;

static PyObject*
oaVarDataAppDef_oaSteiner_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaSteiner data;
    int convert_status=PyoaVarDataAppDef_oaSteiner_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaSteinerObject* self=(PyoaVarDataAppDef_oaSteinerObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getDefaultSize()==p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match default size");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaSteiner_getDefaultSize_doc[] = 
"Class: oaVarDataAppDef_oaSteiner, Function: getDefaultSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getDefaultSize() const\n"
"    Signature: getDefaultSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the default size for this extension in bytes.\n"
;

static PyObject*
oaVarDataAppDef_oaSteiner_getDefaultSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaSteiner data;
    int convert_status=PyoaVarDataAppDef_oaSteiner_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaSteinerObject* self=(PyoaVarDataAppDef_oaSteinerObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getDefaultSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaSteiner_getSize_doc[] = 
"Class: oaVarDataAppDef_oaSteiner, Function: getSize\n"
"  Paramegers: (oaSteiner)\n"
"    Calls: oaUInt4 getSize(const oaSteiner* object)\n"
"    Signature: getSize|simple-oaUInt4|cptr-oaSteiner,\n"
"    This function returns the size of the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaSteiner_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaSteiner data;
    int convert_status=PyoaVarDataAppDef_oaSteiner_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaSteinerObject* self=(PyoaVarDataAppDef_oaSteinerObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaSteiner p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaSteiner_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (data.DataCall()->getSize(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaSteiner_set_doc[] = 
"Class: oaVarDataAppDef_oaSteiner, Function: set\n"
"  Paramegers: (oaSteiner,[oaByte])\n"
"    Calls: void set(oaSteiner* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaSteiner,simple-oaUInt4,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaSteiner_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaSteiner data;
    int convert_status=PyoaVarDataAppDef_oaSteiner_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaSteinerObject* self=(PyoaVarDataAppDef_oaSteinerObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaSteiner p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaSteiner_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaSteiner_isNull_doc[] =
"Class: oaVarDataAppDef_oaSteiner, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaVarDataAppDef_oaSteiner_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaVarDataAppDef_oaSteiner data;
    int convert_status=PyoaVarDataAppDef_oaSteiner_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaVarDataAppDef_oaSteiner_assign_doc[] = 
"Class: oaVarDataAppDef_oaSteiner, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVarDataAppDef_oaSteiner_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVarDataAppDef_oaSteiner data;
  int convert_status=PyoaVarDataAppDef_oaSteiner_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVarDataAppDef_oaSteiner p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVarDataAppDef_oaSteiner_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVarDataAppDef_oaSteiner_methodlist[] = {
    {"get",(PyCFunction)oaVarDataAppDef_oaSteiner_get,METH_VARARGS,oaVarDataAppDef_oaSteiner_get_doc},
    {"getDefault",(PyCFunction)oaVarDataAppDef_oaSteiner_getDefault,METH_VARARGS,oaVarDataAppDef_oaSteiner_getDefault_doc},
    {"getDefaultSize",(PyCFunction)oaVarDataAppDef_oaSteiner_getDefaultSize,METH_VARARGS,oaVarDataAppDef_oaSteiner_getDefaultSize_doc},
    {"getSize",(PyCFunction)oaVarDataAppDef_oaSteiner_getSize,METH_VARARGS,oaVarDataAppDef_oaSteiner_getSize_doc},
    {"set",(PyCFunction)oaVarDataAppDef_oaSteiner_set,METH_VARARGS,oaVarDataAppDef_oaSteiner_set_doc},
    {"isNull",(PyCFunction)oaVarDataAppDef_oaSteiner_tp_isNull,METH_VARARGS,oaVarDataAppDef_oaSteiner_isNull_doc},
    {"assign",(PyCFunction)oaVarDataAppDef_oaSteiner_tp_assign,METH_VARARGS,oaVarDataAppDef_oaSteiner_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaSteiner_doc[] = 
"Class: oaVarDataAppDef_oaSteiner\n"
"  The oaVarDataAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When the objects are created, a data field is added to each object of the specified dataType. Applications can use the new data field for whatever purpose is necessary.\n"
"  This type of extension is useful because it allows variable-sized data for each object being extended. This is similar to the oaDataAppDef class, but more general because the data size can differ for each object. (There is a minor speed and size penalty for this additional flexibility.) The default value for this extension is zero bytes.\n"
"  Note: Because the type of data is unknown to OpenAccess, it is unmanaged. This means the contents are not byte-swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaVarDataAppDef_oaSteiner)\n"
"    Calls: (const oaVarDataAppDef_oaSteiner&)\n"
"    Signature: oaVarDataAppDef_oaSteiner||cref-oaVarDataAppDef_oaSteiner,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVarDataAppDef_oaSteiner_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVarDataAppDef_oaSteiner",
    sizeof(PyoaVarDataAppDef_oaSteinerObject),
    0,
    (destructor)oaVarDataAppDef_oaSteiner_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVarDataAppDef_oaSteiner_tp_compare,	/* tp_compare */
    (reprfunc)oaVarDataAppDef_oaSteiner_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVarDataAppDef_oaSteiner_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVarDataAppDef_oaSteiner_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVarDataAppDef_oaSteiner_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaSteiner_static_find_doc[] = 
"Class: oaVarDataAppDef_oaSteiner, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaSteiner* find(const oaString& name)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaSteiner|cref-oaString,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaSteiner* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaSteiner|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaVarDataAppDef_oaSteiner_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaSteinerp result= (oaVarDataAppDef_oaSteiner::find(p1.Data()));
            return PyoaVarDataAppDef_oaSteiner_FromoaVarDataAppDef_oaSteiner(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaSteinerp result= (oaVarDataAppDef_oaSteiner::find(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaSteiner_FromoaVarDataAppDef_oaSteiner(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaSteiner, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaSteiner_static_get_doc[] = 
"Class: oaVarDataAppDef_oaSteiner, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaSteiner* get(const oaString& name)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaSteiner|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaSteiner* get(const oaString& name,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaSteiner|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaSteiner* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaSteiner|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaSteiner* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaSteiner|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaSteiner* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaSteiner|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaSteiner* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaSteiner|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
;

static PyObject*
oaVarDataAppDef_oaSteiner_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaSteinerp result= (oaVarDataAppDef_oaSteiner::get(p1.Data()));
            return PyoaVarDataAppDef_oaSteiner_FromoaVarDataAppDef_oaSteiner(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaVarDataAppDef_oaSteinerp result= (oaVarDataAppDef_oaSteiner::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaSteiner_FromoaVarDataAppDef_oaSteiner(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaVarDataAppDef_oaSteinerp result= (oaVarDataAppDef_oaSteiner::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaSteiner_FromoaVarDataAppDef_oaSteiner(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaSteinerp result= (oaVarDataAppDef_oaSteiner::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaSteiner_FromoaVarDataAppDef_oaSteiner(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaSteinerp result= (oaVarDataAppDef_oaSteiner::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaSteiner_FromoaVarDataAppDef_oaSteiner(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaSteinerp result= (oaVarDataAppDef_oaSteiner::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaVarDataAppDef_oaSteiner_FromoaVarDataAppDef_oaSteiner(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaSteiner, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaVarDataAppDef_oaSteiner_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaVarDataAppDef_oaSteiner_static_find,METH_VARARGS,oaVarDataAppDef_oaSteiner_static_find_doc},
    {"static_get",(PyCFunction)oaVarDataAppDef_oaSteiner_static_get,METH_VARARGS,oaVarDataAppDef_oaSteiner_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVarDataAppDef_oaSteiner_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVarDataAppDef_oaSteiner_Type)<0) {
      printf("** PyType_Ready failed for: oaVarDataAppDef_oaSteiner\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVarDataAppDef_oaSteiner",
           (PyObject*)(&PyoaVarDataAppDef_oaSteiner_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVarDataAppDef_oaSteiner\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaVarDataAppDef_oaSteiner_Type.tp_dict;
    for(method=oaVarDataAppDef_oaSteiner_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVarDataAppDef_oaStepperMap
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaStepperMap_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVarDataAppDef_oaStepperMap_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVarDataAppDef_oaStepperMapObject* self = (PyoaVarDataAppDef_oaStepperMapObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaVarDataAppDef_oaStepperMap)
    {
        PyParamoaVarDataAppDef_oaStepperMap p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVarDataAppDef_oaStepperMap_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVarDataAppDef_oaStepperMap, Choices are:\n"
        "    (oaVarDataAppDef_oaStepperMap)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVarDataAppDef_oaStepperMap_tp_dealloc(PyoaVarDataAppDef_oaStepperMapObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaStepperMap_tp_repr(PyObject *ob)
{
    PyParamoaVarDataAppDef_oaStepperMap value;
    int convert_status=PyoaVarDataAppDef_oaStepperMap_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[50];
    sprintf(buffer,"<oaVarDataAppDef_oaStepperMap::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVarDataAppDef_oaStepperMap_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVarDataAppDef_oaStepperMap v1;
    PyParamoaVarDataAppDef_oaStepperMap v2;
    int convert_status1=PyoaVarDataAppDef_oaStepperMap_Convert(ob1,&v1);
    int convert_status2=PyoaVarDataAppDef_oaStepperMap_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVarDataAppDef_oaStepperMap_Convert(PyObject* ob,PyParamoaVarDataAppDef_oaStepperMap* result)
{
    if (ob == NULL) return 1;
    if (PyoaVarDataAppDef_oaStepperMap_Check(ob)) {
        result->SetData( (oaVarDataAppDef_oaStepperMap**) ((PyoaVarDataAppDef_oaStepperMapObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVarDataAppDef_oaStepperMap Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaStepperMap_FromoaVarDataAppDef_oaStepperMap(oaVarDataAppDef_oaStepperMap** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaVarDataAppDef_oaStepperMap* data=*value;
        PyObject* bself = PyoaVarDataAppDef_oaStepperMap_Type.tp_alloc(&PyoaVarDataAppDef_oaStepperMap_Type,0);
        if (bself == NULL) return bself;
        PyoaVarDataAppDef_oaStepperMapObject* self = (PyoaVarDataAppDef_oaStepperMapObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaStepperMap_FromoaVarDataAppDef_oaStepperMap(oaVarDataAppDef_oaStepperMap* data)
{
    if (data) {
       PyObject* bself = PyoaVarDataAppDef_oaStepperMap_Type.tp_alloc(&PyoaVarDataAppDef_oaStepperMap_Type,0);
       if (bself == NULL) return bself;
       PyoaVarDataAppDef_oaStepperMapObject* self = (PyoaVarDataAppDef_oaStepperMapObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaStepperMap_get_doc[] = 
"Class: oaVarDataAppDef_oaStepperMap, Function: get\n"
"  Paramegers: (oaStepperMap,[oaByte])\n"
"    Calls: void get(const oaStepperMap* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaStepperMap,ptr-oaByte,\n"
"    This function returns the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaStepperMap_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaStepperMap data;
    int convert_status=PyoaVarDataAppDef_oaStepperMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaStepperMapObject* self=(PyoaVarDataAppDef_oaStepperMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaStepperMap p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaStepperMap_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize(p1.Data())==p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match object data");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaStepperMap_getDefault_doc[] = 
"Class: oaVarDataAppDef_oaStepperMap, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value for this extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to be filled out with the default value\n"
;

static PyObject*
oaVarDataAppDef_oaStepperMap_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaStepperMap data;
    int convert_status=PyoaVarDataAppDef_oaStepperMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaStepperMapObject* self=(PyoaVarDataAppDef_oaStepperMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getDefaultSize()==p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match default size");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaStepperMap_getDefaultSize_doc[] = 
"Class: oaVarDataAppDef_oaStepperMap, Function: getDefaultSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getDefaultSize() const\n"
"    Signature: getDefaultSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the default size for this extension in bytes.\n"
;

static PyObject*
oaVarDataAppDef_oaStepperMap_getDefaultSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaStepperMap data;
    int convert_status=PyoaVarDataAppDef_oaStepperMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaStepperMapObject* self=(PyoaVarDataAppDef_oaStepperMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getDefaultSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaStepperMap_getSize_doc[] = 
"Class: oaVarDataAppDef_oaStepperMap, Function: getSize\n"
"  Paramegers: (oaStepperMap)\n"
"    Calls: oaUInt4 getSize(const oaStepperMap* object)\n"
"    Signature: getSize|simple-oaUInt4|cptr-oaStepperMap,\n"
"    This function returns the size of the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaStepperMap_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaStepperMap data;
    int convert_status=PyoaVarDataAppDef_oaStepperMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaStepperMapObject* self=(PyoaVarDataAppDef_oaStepperMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaStepperMap p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaStepperMap_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (data.DataCall()->getSize(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaStepperMap_set_doc[] = 
"Class: oaVarDataAppDef_oaStepperMap, Function: set\n"
"  Paramegers: (oaStepperMap,[oaByte])\n"
"    Calls: void set(oaStepperMap* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaStepperMap,simple-oaUInt4,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaStepperMap_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaStepperMap data;
    int convert_status=PyoaVarDataAppDef_oaStepperMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaStepperMapObject* self=(PyoaVarDataAppDef_oaStepperMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaStepperMap p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaStepperMap_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaStepperMap_isNull_doc[] =
"Class: oaVarDataAppDef_oaStepperMap, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaVarDataAppDef_oaStepperMap_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaVarDataAppDef_oaStepperMap data;
    int convert_status=PyoaVarDataAppDef_oaStepperMap_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaVarDataAppDef_oaStepperMap_assign_doc[] = 
"Class: oaVarDataAppDef_oaStepperMap, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVarDataAppDef_oaStepperMap_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVarDataAppDef_oaStepperMap data;
  int convert_status=PyoaVarDataAppDef_oaStepperMap_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVarDataAppDef_oaStepperMap p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVarDataAppDef_oaStepperMap_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVarDataAppDef_oaStepperMap_methodlist[] = {
    {"get",(PyCFunction)oaVarDataAppDef_oaStepperMap_get,METH_VARARGS,oaVarDataAppDef_oaStepperMap_get_doc},
    {"getDefault",(PyCFunction)oaVarDataAppDef_oaStepperMap_getDefault,METH_VARARGS,oaVarDataAppDef_oaStepperMap_getDefault_doc},
    {"getDefaultSize",(PyCFunction)oaVarDataAppDef_oaStepperMap_getDefaultSize,METH_VARARGS,oaVarDataAppDef_oaStepperMap_getDefaultSize_doc},
    {"getSize",(PyCFunction)oaVarDataAppDef_oaStepperMap_getSize,METH_VARARGS,oaVarDataAppDef_oaStepperMap_getSize_doc},
    {"set",(PyCFunction)oaVarDataAppDef_oaStepperMap_set,METH_VARARGS,oaVarDataAppDef_oaStepperMap_set_doc},
    {"isNull",(PyCFunction)oaVarDataAppDef_oaStepperMap_tp_isNull,METH_VARARGS,oaVarDataAppDef_oaStepperMap_isNull_doc},
    {"assign",(PyCFunction)oaVarDataAppDef_oaStepperMap_tp_assign,METH_VARARGS,oaVarDataAppDef_oaStepperMap_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaStepperMap_doc[] = 
"Class: oaVarDataAppDef_oaStepperMap\n"
"  The oaVarDataAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When the objects are created, a data field is added to each object of the specified dataType. Applications can use the new data field for whatever purpose is necessary.\n"
"  This type of extension is useful because it allows variable-sized data for each object being extended. This is similar to the oaDataAppDef class, but more general because the data size can differ for each object. (There is a minor speed and size penalty for this additional flexibility.) The default value for this extension is zero bytes.\n"
"  Note: Because the type of data is unknown to OpenAccess, it is unmanaged. This means the contents are not byte-swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaVarDataAppDef_oaStepperMap)\n"
"    Calls: (const oaVarDataAppDef_oaStepperMap&)\n"
"    Signature: oaVarDataAppDef_oaStepperMap||cref-oaVarDataAppDef_oaStepperMap,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVarDataAppDef_oaStepperMap_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVarDataAppDef_oaStepperMap",
    sizeof(PyoaVarDataAppDef_oaStepperMapObject),
    0,
    (destructor)oaVarDataAppDef_oaStepperMap_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVarDataAppDef_oaStepperMap_tp_compare,	/* tp_compare */
    (reprfunc)oaVarDataAppDef_oaStepperMap_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVarDataAppDef_oaStepperMap_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVarDataAppDef_oaStepperMap_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVarDataAppDef_oaStepperMap_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaStepperMap_static_find_doc[] = 
"Class: oaVarDataAppDef_oaStepperMap, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaStepperMap* find(const oaString& name)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaStepperMap|cref-oaString,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaStepperMap* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaStepperMap|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaVarDataAppDef_oaStepperMap_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaStepperMapp result= (oaVarDataAppDef_oaStepperMap::find(p1.Data()));
            return PyoaVarDataAppDef_oaStepperMap_FromoaVarDataAppDef_oaStepperMap(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaStepperMapp result= (oaVarDataAppDef_oaStepperMap::find(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaStepperMap_FromoaVarDataAppDef_oaStepperMap(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaStepperMap, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaStepperMap_static_get_doc[] = 
"Class: oaVarDataAppDef_oaStepperMap, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaStepperMap* get(const oaString& name)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaStepperMap|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaStepperMap* get(const oaString& name,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaStepperMap|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaStepperMap* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaStepperMap|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaStepperMap* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaStepperMap|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaStepperMap* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaStepperMap|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaStepperMap* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaStepperMap|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
;

static PyObject*
oaVarDataAppDef_oaStepperMap_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaStepperMapp result= (oaVarDataAppDef_oaStepperMap::get(p1.Data()));
            return PyoaVarDataAppDef_oaStepperMap_FromoaVarDataAppDef_oaStepperMap(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaVarDataAppDef_oaStepperMapp result= (oaVarDataAppDef_oaStepperMap::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaStepperMap_FromoaVarDataAppDef_oaStepperMap(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaVarDataAppDef_oaStepperMapp result= (oaVarDataAppDef_oaStepperMap::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaStepperMap_FromoaVarDataAppDef_oaStepperMap(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaStepperMapp result= (oaVarDataAppDef_oaStepperMap::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaStepperMap_FromoaVarDataAppDef_oaStepperMap(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaStepperMapp result= (oaVarDataAppDef_oaStepperMap::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaStepperMap_FromoaVarDataAppDef_oaStepperMap(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaStepperMapp result= (oaVarDataAppDef_oaStepperMap::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaVarDataAppDef_oaStepperMap_FromoaVarDataAppDef_oaStepperMap(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaStepperMap, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaVarDataAppDef_oaStepperMap_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaVarDataAppDef_oaStepperMap_static_find,METH_VARARGS,oaVarDataAppDef_oaStepperMap_static_find_doc},
    {"static_get",(PyCFunction)oaVarDataAppDef_oaStepperMap_static_get,METH_VARARGS,oaVarDataAppDef_oaStepperMap_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVarDataAppDef_oaStepperMap_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVarDataAppDef_oaStepperMap_Type)<0) {
      printf("** PyType_Ready failed for: oaVarDataAppDef_oaStepperMap\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVarDataAppDef_oaStepperMap",
           (PyObject*)(&PyoaVarDataAppDef_oaStepperMap_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVarDataAppDef_oaStepperMap\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaVarDataAppDef_oaStepperMap_Type.tp_dict;
    for(method=oaVarDataAppDef_oaStepperMap_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVarDataAppDef_oaTech
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaTech_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVarDataAppDef_oaTech_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVarDataAppDef_oaTechObject* self = (PyoaVarDataAppDef_oaTechObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaVarDataAppDef_oaTech)
    {
        PyParamoaVarDataAppDef_oaTech p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVarDataAppDef_oaTech_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVarDataAppDef_oaTech, Choices are:\n"
        "    (oaVarDataAppDef_oaTech)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVarDataAppDef_oaTech_tp_dealloc(PyoaVarDataAppDef_oaTechObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaTech_tp_repr(PyObject *ob)
{
    PyParamoaVarDataAppDef_oaTech value;
    int convert_status=PyoaVarDataAppDef_oaTech_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[44];
    sprintf(buffer,"<oaVarDataAppDef_oaTech::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVarDataAppDef_oaTech_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVarDataAppDef_oaTech v1;
    PyParamoaVarDataAppDef_oaTech v2;
    int convert_status1=PyoaVarDataAppDef_oaTech_Convert(ob1,&v1);
    int convert_status2=PyoaVarDataAppDef_oaTech_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVarDataAppDef_oaTech_Convert(PyObject* ob,PyParamoaVarDataAppDef_oaTech* result)
{
    if (ob == NULL) return 1;
    if (PyoaVarDataAppDef_oaTech_Check(ob)) {
        result->SetData( (oaVarDataAppDef_oaTech**) ((PyoaVarDataAppDef_oaTechObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVarDataAppDef_oaTech Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaTech_FromoaVarDataAppDef_oaTech(oaVarDataAppDef_oaTech** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaVarDataAppDef_oaTech* data=*value;
        PyObject* bself = PyoaVarDataAppDef_oaTech_Type.tp_alloc(&PyoaVarDataAppDef_oaTech_Type,0);
        if (bself == NULL) return bself;
        PyoaVarDataAppDef_oaTechObject* self = (PyoaVarDataAppDef_oaTechObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaTech_FromoaVarDataAppDef_oaTech(oaVarDataAppDef_oaTech* data)
{
    if (data) {
       PyObject* bself = PyoaVarDataAppDef_oaTech_Type.tp_alloc(&PyoaVarDataAppDef_oaTech_Type,0);
       if (bself == NULL) return bself;
       PyoaVarDataAppDef_oaTechObject* self = (PyoaVarDataAppDef_oaTechObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTech_get_doc[] = 
"Class: oaVarDataAppDef_oaTech, Function: get\n"
"  Paramegers: (oaTech,[oaByte])\n"
"    Calls: void get(const oaTech* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaTech,ptr-oaByte,\n"
"    This function returns the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaTech_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTech data;
    int convert_status=PyoaVarDataAppDef_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTechObject* self=(PyoaVarDataAppDef_oaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTech p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTech_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize(p1.Data())==p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match object data");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTech_getDefault_doc[] = 
"Class: oaVarDataAppDef_oaTech, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value for this extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to be filled out with the default value\n"
;

static PyObject*
oaVarDataAppDef_oaTech_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTech data;
    int convert_status=PyoaVarDataAppDef_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTechObject* self=(PyoaVarDataAppDef_oaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getDefaultSize()==p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match default size");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTech_getDefaultSize_doc[] = 
"Class: oaVarDataAppDef_oaTech, Function: getDefaultSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getDefaultSize() const\n"
"    Signature: getDefaultSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the default size for this extension in bytes.\n"
;

static PyObject*
oaVarDataAppDef_oaTech_getDefaultSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTech data;
    int convert_status=PyoaVarDataAppDef_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTechObject* self=(PyoaVarDataAppDef_oaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getDefaultSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTech_getSize_doc[] = 
"Class: oaVarDataAppDef_oaTech, Function: getSize\n"
"  Paramegers: (oaTech)\n"
"    Calls: oaUInt4 getSize(const oaTech* object)\n"
"    Signature: getSize|simple-oaUInt4|cptr-oaTech,\n"
"    This function returns the size of the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaTech_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTech data;
    int convert_status=PyoaVarDataAppDef_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTechObject* self=(PyoaVarDataAppDef_oaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTech p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTech_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (data.DataCall()->getSize(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTech_set_doc[] = 
"Class: oaVarDataAppDef_oaTech, Function: set\n"
"  Paramegers: (oaTech,[oaByte])\n"
"    Calls: void set(oaTech* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaTech,simple-oaUInt4,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaTech_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTech data;
    int convert_status=PyoaVarDataAppDef_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTechObject* self=(PyoaVarDataAppDef_oaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTech p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTech_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTech_isNull_doc[] =
"Class: oaVarDataAppDef_oaTech, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaVarDataAppDef_oaTech_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaVarDataAppDef_oaTech data;
    int convert_status=PyoaVarDataAppDef_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaVarDataAppDef_oaTech_assign_doc[] = 
"Class: oaVarDataAppDef_oaTech, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVarDataAppDef_oaTech_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVarDataAppDef_oaTech data;
  int convert_status=PyoaVarDataAppDef_oaTech_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVarDataAppDef_oaTech p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVarDataAppDef_oaTech_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVarDataAppDef_oaTech_methodlist[] = {
    {"get",(PyCFunction)oaVarDataAppDef_oaTech_get,METH_VARARGS,oaVarDataAppDef_oaTech_get_doc},
    {"getDefault",(PyCFunction)oaVarDataAppDef_oaTech_getDefault,METH_VARARGS,oaVarDataAppDef_oaTech_getDefault_doc},
    {"getDefaultSize",(PyCFunction)oaVarDataAppDef_oaTech_getDefaultSize,METH_VARARGS,oaVarDataAppDef_oaTech_getDefaultSize_doc},
    {"getSize",(PyCFunction)oaVarDataAppDef_oaTech_getSize,METH_VARARGS,oaVarDataAppDef_oaTech_getSize_doc},
    {"set",(PyCFunction)oaVarDataAppDef_oaTech_set,METH_VARARGS,oaVarDataAppDef_oaTech_set_doc},
    {"isNull",(PyCFunction)oaVarDataAppDef_oaTech_tp_isNull,METH_VARARGS,oaVarDataAppDef_oaTech_isNull_doc},
    {"assign",(PyCFunction)oaVarDataAppDef_oaTech_tp_assign,METH_VARARGS,oaVarDataAppDef_oaTech_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTech_doc[] = 
"Class: oaVarDataAppDef_oaTech\n"
"  The oaVarDataAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When the objects are created, a data field is added to each object of the specified dataType. Applications can use the new data field for whatever purpose is necessary.\n"
"  This type of extension is useful because it allows variable-sized data for each object being extended. This is similar to the oaDataAppDef class, but more general because the data size can differ for each object. (There is a minor speed and size penalty for this additional flexibility.) The default value for this extension is zero bytes.\n"
"  Note: Because the type of data is unknown to OpenAccess, it is unmanaged. This means the contents are not byte-swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaVarDataAppDef_oaTech)\n"
"    Calls: (const oaVarDataAppDef_oaTech&)\n"
"    Signature: oaVarDataAppDef_oaTech||cref-oaVarDataAppDef_oaTech,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVarDataAppDef_oaTech_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVarDataAppDef_oaTech",
    sizeof(PyoaVarDataAppDef_oaTechObject),
    0,
    (destructor)oaVarDataAppDef_oaTech_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVarDataAppDef_oaTech_tp_compare,	/* tp_compare */
    (reprfunc)oaVarDataAppDef_oaTech_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVarDataAppDef_oaTech_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVarDataAppDef_oaTech_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVarDataAppDef_oaTech_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTech_static_find_doc[] = 
"Class: oaVarDataAppDef_oaTech, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaTech* find(const oaString& name)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaTech|cref-oaString,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaTech* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaTech|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaVarDataAppDef_oaTech_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaTechp result= (oaVarDataAppDef_oaTech::find(p1.Data()));
            return PyoaVarDataAppDef_oaTech_FromoaVarDataAppDef_oaTech(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaTechp result= (oaVarDataAppDef_oaTech::find(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaTech_FromoaVarDataAppDef_oaTech(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaTech, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTech_static_get_doc[] = 
"Class: oaVarDataAppDef_oaTech, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaTech* get(const oaString& name)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTech|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaTech* get(const oaString& name,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTech|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaTech* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTech|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaTech* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTech|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaTech* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTech|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaTech* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTech|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
;

static PyObject*
oaVarDataAppDef_oaTech_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaTechp result= (oaVarDataAppDef_oaTech::get(p1.Data()));
            return PyoaVarDataAppDef_oaTech_FromoaVarDataAppDef_oaTech(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaVarDataAppDef_oaTechp result= (oaVarDataAppDef_oaTech::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaTech_FromoaVarDataAppDef_oaTech(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaVarDataAppDef_oaTechp result= (oaVarDataAppDef_oaTech::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaTech_FromoaVarDataAppDef_oaTech(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaTechp result= (oaVarDataAppDef_oaTech::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaTech_FromoaVarDataAppDef_oaTech(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaTechp result= (oaVarDataAppDef_oaTech::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaTech_FromoaVarDataAppDef_oaTech(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaTechp result= (oaVarDataAppDef_oaTech::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaVarDataAppDef_oaTech_FromoaVarDataAppDef_oaTech(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaTech, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaVarDataAppDef_oaTech_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaVarDataAppDef_oaTech_static_find,METH_VARARGS,oaVarDataAppDef_oaTech_static_find_doc},
    {"static_get",(PyCFunction)oaVarDataAppDef_oaTech_static_get,METH_VARARGS,oaVarDataAppDef_oaTech_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVarDataAppDef_oaTech_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVarDataAppDef_oaTech_Type)<0) {
      printf("** PyType_Ready failed for: oaVarDataAppDef_oaTech\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVarDataAppDef_oaTech",
           (PyObject*)(&PyoaVarDataAppDef_oaTech_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVarDataAppDef_oaTech\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaVarDataAppDef_oaTech_Type.tp_dict;
    for(method=oaVarDataAppDef_oaTech_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVarDataAppDef_oaTechHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaTechHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVarDataAppDef_oaTechHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVarDataAppDef_oaTechHeaderObject* self = (PyoaVarDataAppDef_oaTechHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaVarDataAppDef_oaTechHeader)
    {
        PyParamoaVarDataAppDef_oaTechHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVarDataAppDef_oaTechHeader_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVarDataAppDef_oaTechHeader, Choices are:\n"
        "    (oaVarDataAppDef_oaTechHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVarDataAppDef_oaTechHeader_tp_dealloc(PyoaVarDataAppDef_oaTechHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaTechHeader_tp_repr(PyObject *ob)
{
    PyParamoaVarDataAppDef_oaTechHeader value;
    int convert_status=PyoaVarDataAppDef_oaTechHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[50];
    sprintf(buffer,"<oaVarDataAppDef_oaTechHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVarDataAppDef_oaTechHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVarDataAppDef_oaTechHeader v1;
    PyParamoaVarDataAppDef_oaTechHeader v2;
    int convert_status1=PyoaVarDataAppDef_oaTechHeader_Convert(ob1,&v1);
    int convert_status2=PyoaVarDataAppDef_oaTechHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVarDataAppDef_oaTechHeader_Convert(PyObject* ob,PyParamoaVarDataAppDef_oaTechHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaVarDataAppDef_oaTechHeader_Check(ob)) {
        result->SetData( (oaVarDataAppDef_oaTechHeader**) ((PyoaVarDataAppDef_oaTechHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVarDataAppDef_oaTechHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaTechHeader_FromoaVarDataAppDef_oaTechHeader(oaVarDataAppDef_oaTechHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaVarDataAppDef_oaTechHeader* data=*value;
        PyObject* bself = PyoaVarDataAppDef_oaTechHeader_Type.tp_alloc(&PyoaVarDataAppDef_oaTechHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaVarDataAppDef_oaTechHeaderObject* self = (PyoaVarDataAppDef_oaTechHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaTechHeader_FromoaVarDataAppDef_oaTechHeader(oaVarDataAppDef_oaTechHeader* data)
{
    if (data) {
       PyObject* bself = PyoaVarDataAppDef_oaTechHeader_Type.tp_alloc(&PyoaVarDataAppDef_oaTechHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaVarDataAppDef_oaTechHeaderObject* self = (PyoaVarDataAppDef_oaTechHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechHeader_get_doc[] = 
"Class: oaVarDataAppDef_oaTechHeader, Function: get\n"
"  Paramegers: (oaTechHeader,[oaByte])\n"
"    Calls: void get(const oaTechHeader* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaTechHeader,ptr-oaByte,\n"
"    This function returns the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaTechHeader_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTechHeader data;
    int convert_status=PyoaVarDataAppDef_oaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTechHeaderObject* self=(PyoaVarDataAppDef_oaTechHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechHeader p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTechHeader_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize(p1.Data())==p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match object data");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechHeader_getDefault_doc[] = 
"Class: oaVarDataAppDef_oaTechHeader, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value for this extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to be filled out with the default value\n"
;

static PyObject*
oaVarDataAppDef_oaTechHeader_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTechHeader data;
    int convert_status=PyoaVarDataAppDef_oaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTechHeaderObject* self=(PyoaVarDataAppDef_oaTechHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getDefaultSize()==p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match default size");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechHeader_getDefaultSize_doc[] = 
"Class: oaVarDataAppDef_oaTechHeader, Function: getDefaultSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getDefaultSize() const\n"
"    Signature: getDefaultSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the default size for this extension in bytes.\n"
;

static PyObject*
oaVarDataAppDef_oaTechHeader_getDefaultSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTechHeader data;
    int convert_status=PyoaVarDataAppDef_oaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTechHeaderObject* self=(PyoaVarDataAppDef_oaTechHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getDefaultSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechHeader_getSize_doc[] = 
"Class: oaVarDataAppDef_oaTechHeader, Function: getSize\n"
"  Paramegers: (oaTechHeader)\n"
"    Calls: oaUInt4 getSize(const oaTechHeader* object)\n"
"    Signature: getSize|simple-oaUInt4|cptr-oaTechHeader,\n"
"    This function returns the size of the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaTechHeader_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTechHeader data;
    int convert_status=PyoaVarDataAppDef_oaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTechHeaderObject* self=(PyoaVarDataAppDef_oaTechHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechHeader p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTechHeader_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (data.DataCall()->getSize(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechHeader_set_doc[] = 
"Class: oaVarDataAppDef_oaTechHeader, Function: set\n"
"  Paramegers: (oaTechHeader,[oaByte])\n"
"    Calls: void set(oaTechHeader* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaTechHeader,simple-oaUInt4,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaTechHeader_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTechHeader data;
    int convert_status=PyoaVarDataAppDef_oaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTechHeaderObject* self=(PyoaVarDataAppDef_oaTechHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechHeader p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTechHeader_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechHeader_isNull_doc[] =
"Class: oaVarDataAppDef_oaTechHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaVarDataAppDef_oaTechHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaVarDataAppDef_oaTechHeader data;
    int convert_status=PyoaVarDataAppDef_oaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaVarDataAppDef_oaTechHeader_assign_doc[] = 
"Class: oaVarDataAppDef_oaTechHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVarDataAppDef_oaTechHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVarDataAppDef_oaTechHeader data;
  int convert_status=PyoaVarDataAppDef_oaTechHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVarDataAppDef_oaTechHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVarDataAppDef_oaTechHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVarDataAppDef_oaTechHeader_methodlist[] = {
    {"get",(PyCFunction)oaVarDataAppDef_oaTechHeader_get,METH_VARARGS,oaVarDataAppDef_oaTechHeader_get_doc},
    {"getDefault",(PyCFunction)oaVarDataAppDef_oaTechHeader_getDefault,METH_VARARGS,oaVarDataAppDef_oaTechHeader_getDefault_doc},
    {"getDefaultSize",(PyCFunction)oaVarDataAppDef_oaTechHeader_getDefaultSize,METH_VARARGS,oaVarDataAppDef_oaTechHeader_getDefaultSize_doc},
    {"getSize",(PyCFunction)oaVarDataAppDef_oaTechHeader_getSize,METH_VARARGS,oaVarDataAppDef_oaTechHeader_getSize_doc},
    {"set",(PyCFunction)oaVarDataAppDef_oaTechHeader_set,METH_VARARGS,oaVarDataAppDef_oaTechHeader_set_doc},
    {"isNull",(PyCFunction)oaVarDataAppDef_oaTechHeader_tp_isNull,METH_VARARGS,oaVarDataAppDef_oaTechHeader_isNull_doc},
    {"assign",(PyCFunction)oaVarDataAppDef_oaTechHeader_tp_assign,METH_VARARGS,oaVarDataAppDef_oaTechHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechHeader_doc[] = 
"Class: oaVarDataAppDef_oaTechHeader\n"
"  The oaVarDataAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When the objects are created, a data field is added to each object of the specified dataType. Applications can use the new data field for whatever purpose is necessary.\n"
"  This type of extension is useful because it allows variable-sized data for each object being extended. This is similar to the oaDataAppDef class, but more general because the data size can differ for each object. (There is a minor speed and size penalty for this additional flexibility.) The default value for this extension is zero bytes.\n"
"  Note: Because the type of data is unknown to OpenAccess, it is unmanaged. This means the contents are not byte-swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaVarDataAppDef_oaTechHeader)\n"
"    Calls: (const oaVarDataAppDef_oaTechHeader&)\n"
"    Signature: oaVarDataAppDef_oaTechHeader||cref-oaVarDataAppDef_oaTechHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVarDataAppDef_oaTechHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVarDataAppDef_oaTechHeader",
    sizeof(PyoaVarDataAppDef_oaTechHeaderObject),
    0,
    (destructor)oaVarDataAppDef_oaTechHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVarDataAppDef_oaTechHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaVarDataAppDef_oaTechHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVarDataAppDef_oaTechHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVarDataAppDef_oaTechHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVarDataAppDef_oaTechHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechHeader_static_find_doc[] = 
"Class: oaVarDataAppDef_oaTechHeader, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaTechHeader* find(const oaString& name)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaTechHeader|cref-oaString,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaTechHeader* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaTechHeader|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaVarDataAppDef_oaTechHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaTechHeaderp result= (oaVarDataAppDef_oaTechHeader::find(p1.Data()));
            return PyoaVarDataAppDef_oaTechHeader_FromoaVarDataAppDef_oaTechHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaTechHeaderp result= (oaVarDataAppDef_oaTechHeader::find(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaTechHeader_FromoaVarDataAppDef_oaTechHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaTechHeader, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechHeader_static_get_doc[] = 
"Class: oaVarDataAppDef_oaTechHeader, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaTechHeader* get(const oaString& name)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTechHeader|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaTechHeader* get(const oaString& name,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTechHeader|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaTechHeader* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTechHeader|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaTechHeader* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTechHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaTechHeader* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTechHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaTechHeader* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTechHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
;

static PyObject*
oaVarDataAppDef_oaTechHeader_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaTechHeaderp result= (oaVarDataAppDef_oaTechHeader::get(p1.Data()));
            return PyoaVarDataAppDef_oaTechHeader_FromoaVarDataAppDef_oaTechHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaVarDataAppDef_oaTechHeaderp result= (oaVarDataAppDef_oaTechHeader::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaTechHeader_FromoaVarDataAppDef_oaTechHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaVarDataAppDef_oaTechHeaderp result= (oaVarDataAppDef_oaTechHeader::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaTechHeader_FromoaVarDataAppDef_oaTechHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaTechHeaderp result= (oaVarDataAppDef_oaTechHeader::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaTechHeader_FromoaVarDataAppDef_oaTechHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaTechHeaderp result= (oaVarDataAppDef_oaTechHeader::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaTechHeader_FromoaVarDataAppDef_oaTechHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaTechHeaderp result= (oaVarDataAppDef_oaTechHeader::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaVarDataAppDef_oaTechHeader_FromoaVarDataAppDef_oaTechHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaTechHeader, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaVarDataAppDef_oaTechHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaVarDataAppDef_oaTechHeader_static_find,METH_VARARGS,oaVarDataAppDef_oaTechHeader_static_find_doc},
    {"static_get",(PyCFunction)oaVarDataAppDef_oaTechHeader_static_get,METH_VARARGS,oaVarDataAppDef_oaTechHeader_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVarDataAppDef_oaTechHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVarDataAppDef_oaTechHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaVarDataAppDef_oaTechHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVarDataAppDef_oaTechHeader",
           (PyObject*)(&PyoaVarDataAppDef_oaTechHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVarDataAppDef_oaTechHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaVarDataAppDef_oaTechHeader_Type.tp_dict;
    for(method=oaVarDataAppDef_oaTechHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVarDataAppDef_oaTechLayerHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaTechLayerHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVarDataAppDef_oaTechLayerHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVarDataAppDef_oaTechLayerHeaderObject* self = (PyoaVarDataAppDef_oaTechLayerHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaVarDataAppDef_oaTechLayerHeader)
    {
        PyParamoaVarDataAppDef_oaTechLayerHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVarDataAppDef_oaTechLayerHeader_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVarDataAppDef_oaTechLayerHeader, Choices are:\n"
        "    (oaVarDataAppDef_oaTechLayerHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVarDataAppDef_oaTechLayerHeader_tp_dealloc(PyoaVarDataAppDef_oaTechLayerHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaTechLayerHeader_tp_repr(PyObject *ob)
{
    PyParamoaVarDataAppDef_oaTechLayerHeader value;
    int convert_status=PyoaVarDataAppDef_oaTechLayerHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[55];
    sprintf(buffer,"<oaVarDataAppDef_oaTechLayerHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVarDataAppDef_oaTechLayerHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVarDataAppDef_oaTechLayerHeader v1;
    PyParamoaVarDataAppDef_oaTechLayerHeader v2;
    int convert_status1=PyoaVarDataAppDef_oaTechLayerHeader_Convert(ob1,&v1);
    int convert_status2=PyoaVarDataAppDef_oaTechLayerHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVarDataAppDef_oaTechLayerHeader_Convert(PyObject* ob,PyParamoaVarDataAppDef_oaTechLayerHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaVarDataAppDef_oaTechLayerHeader_Check(ob)) {
        result->SetData( (oaVarDataAppDef_oaTechLayerHeader**) ((PyoaVarDataAppDef_oaTechLayerHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVarDataAppDef_oaTechLayerHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaTechLayerHeader_FromoaVarDataAppDef_oaTechLayerHeader(oaVarDataAppDef_oaTechLayerHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaVarDataAppDef_oaTechLayerHeader* data=*value;
        PyObject* bself = PyoaVarDataAppDef_oaTechLayerHeader_Type.tp_alloc(&PyoaVarDataAppDef_oaTechLayerHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaVarDataAppDef_oaTechLayerHeaderObject* self = (PyoaVarDataAppDef_oaTechLayerHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaTechLayerHeader_FromoaVarDataAppDef_oaTechLayerHeader(oaVarDataAppDef_oaTechLayerHeader* data)
{
    if (data) {
       PyObject* bself = PyoaVarDataAppDef_oaTechLayerHeader_Type.tp_alloc(&PyoaVarDataAppDef_oaTechLayerHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaVarDataAppDef_oaTechLayerHeaderObject* self = (PyoaVarDataAppDef_oaTechLayerHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechLayerHeader_get_doc[] = 
"Class: oaVarDataAppDef_oaTechLayerHeader, Function: get\n"
"  Paramegers: (oaTechLayerHeader,[oaByte])\n"
"    Calls: void get(const oaTechLayerHeader* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaTechLayerHeader,ptr-oaByte,\n"
"    This function returns the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaTechLayerHeader_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTechLayerHeader data;
    int convert_status=PyoaVarDataAppDef_oaTechLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTechLayerHeaderObject* self=(PyoaVarDataAppDef_oaTechLayerHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechLayerHeader p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTechLayerHeader_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize(p1.Data())==p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match object data");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechLayerHeader_getDefault_doc[] = 
"Class: oaVarDataAppDef_oaTechLayerHeader, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value for this extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to be filled out with the default value\n"
;

static PyObject*
oaVarDataAppDef_oaTechLayerHeader_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTechLayerHeader data;
    int convert_status=PyoaVarDataAppDef_oaTechLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTechLayerHeaderObject* self=(PyoaVarDataAppDef_oaTechLayerHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getDefaultSize()==p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match default size");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechLayerHeader_getDefaultSize_doc[] = 
"Class: oaVarDataAppDef_oaTechLayerHeader, Function: getDefaultSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getDefaultSize() const\n"
"    Signature: getDefaultSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the default size for this extension in bytes.\n"
;

static PyObject*
oaVarDataAppDef_oaTechLayerHeader_getDefaultSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTechLayerHeader data;
    int convert_status=PyoaVarDataAppDef_oaTechLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTechLayerHeaderObject* self=(PyoaVarDataAppDef_oaTechLayerHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getDefaultSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechLayerHeader_getSize_doc[] = 
"Class: oaVarDataAppDef_oaTechLayerHeader, Function: getSize\n"
"  Paramegers: (oaTechLayerHeader)\n"
"    Calls: oaUInt4 getSize(const oaTechLayerHeader* object)\n"
"    Signature: getSize|simple-oaUInt4|cptr-oaTechLayerHeader,\n"
"    This function returns the size of the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaTechLayerHeader_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTechLayerHeader data;
    int convert_status=PyoaVarDataAppDef_oaTechLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTechLayerHeaderObject* self=(PyoaVarDataAppDef_oaTechLayerHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechLayerHeader p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTechLayerHeader_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (data.DataCall()->getSize(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechLayerHeader_set_doc[] = 
"Class: oaVarDataAppDef_oaTechLayerHeader, Function: set\n"
"  Paramegers: (oaTechLayerHeader,[oaByte])\n"
"    Calls: void set(oaTechLayerHeader* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaTechLayerHeader,simple-oaUInt4,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaTechLayerHeader_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTechLayerHeader data;
    int convert_status=PyoaVarDataAppDef_oaTechLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTechLayerHeaderObject* self=(PyoaVarDataAppDef_oaTechLayerHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechLayerHeader p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTechLayerHeader_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechLayerHeader_isNull_doc[] =
"Class: oaVarDataAppDef_oaTechLayerHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaVarDataAppDef_oaTechLayerHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaVarDataAppDef_oaTechLayerHeader data;
    int convert_status=PyoaVarDataAppDef_oaTechLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaVarDataAppDef_oaTechLayerHeader_assign_doc[] = 
"Class: oaVarDataAppDef_oaTechLayerHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVarDataAppDef_oaTechLayerHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVarDataAppDef_oaTechLayerHeader data;
  int convert_status=PyoaVarDataAppDef_oaTechLayerHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVarDataAppDef_oaTechLayerHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVarDataAppDef_oaTechLayerHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVarDataAppDef_oaTechLayerHeader_methodlist[] = {
    {"get",(PyCFunction)oaVarDataAppDef_oaTechLayerHeader_get,METH_VARARGS,oaVarDataAppDef_oaTechLayerHeader_get_doc},
    {"getDefault",(PyCFunction)oaVarDataAppDef_oaTechLayerHeader_getDefault,METH_VARARGS,oaVarDataAppDef_oaTechLayerHeader_getDefault_doc},
    {"getDefaultSize",(PyCFunction)oaVarDataAppDef_oaTechLayerHeader_getDefaultSize,METH_VARARGS,oaVarDataAppDef_oaTechLayerHeader_getDefaultSize_doc},
    {"getSize",(PyCFunction)oaVarDataAppDef_oaTechLayerHeader_getSize,METH_VARARGS,oaVarDataAppDef_oaTechLayerHeader_getSize_doc},
    {"set",(PyCFunction)oaVarDataAppDef_oaTechLayerHeader_set,METH_VARARGS,oaVarDataAppDef_oaTechLayerHeader_set_doc},
    {"isNull",(PyCFunction)oaVarDataAppDef_oaTechLayerHeader_tp_isNull,METH_VARARGS,oaVarDataAppDef_oaTechLayerHeader_isNull_doc},
    {"assign",(PyCFunction)oaVarDataAppDef_oaTechLayerHeader_tp_assign,METH_VARARGS,oaVarDataAppDef_oaTechLayerHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechLayerHeader_doc[] = 
"Class: oaVarDataAppDef_oaTechLayerHeader\n"
"  The oaVarDataAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When the objects are created, a data field is added to each object of the specified dataType. Applications can use the new data field for whatever purpose is necessary.\n"
"  This type of extension is useful because it allows variable-sized data for each object being extended. This is similar to the oaDataAppDef class, but more general because the data size can differ for each object. (There is a minor speed and size penalty for this additional flexibility.) The default value for this extension is zero bytes.\n"
"  Note: Because the type of data is unknown to OpenAccess, it is unmanaged. This means the contents are not byte-swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaVarDataAppDef_oaTechLayerHeader)\n"
"    Calls: (const oaVarDataAppDef_oaTechLayerHeader&)\n"
"    Signature: oaVarDataAppDef_oaTechLayerHeader||cref-oaVarDataAppDef_oaTechLayerHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVarDataAppDef_oaTechLayerHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVarDataAppDef_oaTechLayerHeader",
    sizeof(PyoaVarDataAppDef_oaTechLayerHeaderObject),
    0,
    (destructor)oaVarDataAppDef_oaTechLayerHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVarDataAppDef_oaTechLayerHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaVarDataAppDef_oaTechLayerHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVarDataAppDef_oaTechLayerHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVarDataAppDef_oaTechLayerHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVarDataAppDef_oaTechLayerHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechLayerHeader_static_find_doc[] = 
"Class: oaVarDataAppDef_oaTechLayerHeader, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaTechLayerHeader* find(const oaString& name)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaTechLayerHeader|cref-oaString,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaTechLayerHeader* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaTechLayerHeader|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaVarDataAppDef_oaTechLayerHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaTechLayerHeaderp result= (oaVarDataAppDef_oaTechLayerHeader::find(p1.Data()));
            return PyoaVarDataAppDef_oaTechLayerHeader_FromoaVarDataAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaTechLayerHeaderp result= (oaVarDataAppDef_oaTechLayerHeader::find(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaTechLayerHeader_FromoaVarDataAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaTechLayerHeader, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechLayerHeader_static_get_doc[] = 
"Class: oaVarDataAppDef_oaTechLayerHeader, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaTechLayerHeader* get(const oaString& name)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTechLayerHeader|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaTechLayerHeader* get(const oaString& name,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTechLayerHeader|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaTechLayerHeader* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTechLayerHeader|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaTechLayerHeader* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTechLayerHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaTechLayerHeader* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTechLayerHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaTechLayerHeader* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTechLayerHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
;

static PyObject*
oaVarDataAppDef_oaTechLayerHeader_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaTechLayerHeaderp result= (oaVarDataAppDef_oaTechLayerHeader::get(p1.Data()));
            return PyoaVarDataAppDef_oaTechLayerHeader_FromoaVarDataAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaVarDataAppDef_oaTechLayerHeaderp result= (oaVarDataAppDef_oaTechLayerHeader::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaTechLayerHeader_FromoaVarDataAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaVarDataAppDef_oaTechLayerHeaderp result= (oaVarDataAppDef_oaTechLayerHeader::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaTechLayerHeader_FromoaVarDataAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaTechLayerHeaderp result= (oaVarDataAppDef_oaTechLayerHeader::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaTechLayerHeader_FromoaVarDataAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaTechLayerHeaderp result= (oaVarDataAppDef_oaTechLayerHeader::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaTechLayerHeader_FromoaVarDataAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaTechLayerHeaderp result= (oaVarDataAppDef_oaTechLayerHeader::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaVarDataAppDef_oaTechLayerHeader_FromoaVarDataAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaTechLayerHeader, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaVarDataAppDef_oaTechLayerHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaVarDataAppDef_oaTechLayerHeader_static_find,METH_VARARGS,oaVarDataAppDef_oaTechLayerHeader_static_find_doc},
    {"static_get",(PyCFunction)oaVarDataAppDef_oaTechLayerHeader_static_get,METH_VARARGS,oaVarDataAppDef_oaTechLayerHeader_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVarDataAppDef_oaTechLayerHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVarDataAppDef_oaTechLayerHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaVarDataAppDef_oaTechLayerHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVarDataAppDef_oaTechLayerHeader",
           (PyObject*)(&PyoaVarDataAppDef_oaTechLayerHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVarDataAppDef_oaTechLayerHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaVarDataAppDef_oaTechLayerHeader_Type.tp_dict;
    for(method=oaVarDataAppDef_oaTechLayerHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVarDataAppDef_oaTechViaDefHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaTechViaDefHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVarDataAppDef_oaTechViaDefHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVarDataAppDef_oaTechViaDefHeaderObject* self = (PyoaVarDataAppDef_oaTechViaDefHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaVarDataAppDef_oaTechViaDefHeader)
    {
        PyParamoaVarDataAppDef_oaTechViaDefHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVarDataAppDef_oaTechViaDefHeader_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVarDataAppDef_oaTechViaDefHeader, Choices are:\n"
        "    (oaVarDataAppDef_oaTechViaDefHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVarDataAppDef_oaTechViaDefHeader_tp_dealloc(PyoaVarDataAppDef_oaTechViaDefHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaTechViaDefHeader_tp_repr(PyObject *ob)
{
    PyParamoaVarDataAppDef_oaTechViaDefHeader value;
    int convert_status=PyoaVarDataAppDef_oaTechViaDefHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[56];
    sprintf(buffer,"<oaVarDataAppDef_oaTechViaDefHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVarDataAppDef_oaTechViaDefHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVarDataAppDef_oaTechViaDefHeader v1;
    PyParamoaVarDataAppDef_oaTechViaDefHeader v2;
    int convert_status1=PyoaVarDataAppDef_oaTechViaDefHeader_Convert(ob1,&v1);
    int convert_status2=PyoaVarDataAppDef_oaTechViaDefHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVarDataAppDef_oaTechViaDefHeader_Convert(PyObject* ob,PyParamoaVarDataAppDef_oaTechViaDefHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaVarDataAppDef_oaTechViaDefHeader_Check(ob)) {
        result->SetData( (oaVarDataAppDef_oaTechViaDefHeader**) ((PyoaVarDataAppDef_oaTechViaDefHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVarDataAppDef_oaTechViaDefHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaTechViaDefHeader_FromoaVarDataAppDef_oaTechViaDefHeader(oaVarDataAppDef_oaTechViaDefHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaVarDataAppDef_oaTechViaDefHeader* data=*value;
        PyObject* bself = PyoaVarDataAppDef_oaTechViaDefHeader_Type.tp_alloc(&PyoaVarDataAppDef_oaTechViaDefHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaVarDataAppDef_oaTechViaDefHeaderObject* self = (PyoaVarDataAppDef_oaTechViaDefHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaTechViaDefHeader_FromoaVarDataAppDef_oaTechViaDefHeader(oaVarDataAppDef_oaTechViaDefHeader* data)
{
    if (data) {
       PyObject* bself = PyoaVarDataAppDef_oaTechViaDefHeader_Type.tp_alloc(&PyoaVarDataAppDef_oaTechViaDefHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaVarDataAppDef_oaTechViaDefHeaderObject* self = (PyoaVarDataAppDef_oaTechViaDefHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechViaDefHeader_get_doc[] = 
"Class: oaVarDataAppDef_oaTechViaDefHeader, Function: get\n"
"  Paramegers: (oaTechViaDefHeader,[oaByte])\n"
"    Calls: void get(const oaTechViaDefHeader* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaTechViaDefHeader,ptr-oaByte,\n"
"    This function returns the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaTechViaDefHeader_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTechViaDefHeader data;
    int convert_status=PyoaVarDataAppDef_oaTechViaDefHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTechViaDefHeaderObject* self=(PyoaVarDataAppDef_oaTechViaDefHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechViaDefHeader p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTechViaDefHeader_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize(p1.Data())==p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match object data");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechViaDefHeader_getDefault_doc[] = 
"Class: oaVarDataAppDef_oaTechViaDefHeader, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value for this extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to be filled out with the default value\n"
;

static PyObject*
oaVarDataAppDef_oaTechViaDefHeader_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTechViaDefHeader data;
    int convert_status=PyoaVarDataAppDef_oaTechViaDefHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTechViaDefHeaderObject* self=(PyoaVarDataAppDef_oaTechViaDefHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getDefaultSize()==p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match default size");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechViaDefHeader_getDefaultSize_doc[] = 
"Class: oaVarDataAppDef_oaTechViaDefHeader, Function: getDefaultSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getDefaultSize() const\n"
"    Signature: getDefaultSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the default size for this extension in bytes.\n"
;

static PyObject*
oaVarDataAppDef_oaTechViaDefHeader_getDefaultSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTechViaDefHeader data;
    int convert_status=PyoaVarDataAppDef_oaTechViaDefHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTechViaDefHeaderObject* self=(PyoaVarDataAppDef_oaTechViaDefHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getDefaultSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechViaDefHeader_getSize_doc[] = 
"Class: oaVarDataAppDef_oaTechViaDefHeader, Function: getSize\n"
"  Paramegers: (oaTechViaDefHeader)\n"
"    Calls: oaUInt4 getSize(const oaTechViaDefHeader* object)\n"
"    Signature: getSize|simple-oaUInt4|cptr-oaTechViaDefHeader,\n"
"    This function returns the size of the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaTechViaDefHeader_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTechViaDefHeader data;
    int convert_status=PyoaVarDataAppDef_oaTechViaDefHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTechViaDefHeaderObject* self=(PyoaVarDataAppDef_oaTechViaDefHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechViaDefHeader p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTechViaDefHeader_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (data.DataCall()->getSize(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechViaDefHeader_set_doc[] = 
"Class: oaVarDataAppDef_oaTechViaDefHeader, Function: set\n"
"  Paramegers: (oaTechViaDefHeader,[oaByte])\n"
"    Calls: void set(oaTechViaDefHeader* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaTechViaDefHeader,simple-oaUInt4,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaTechViaDefHeader_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTechViaDefHeader data;
    int convert_status=PyoaVarDataAppDef_oaTechViaDefHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTechViaDefHeaderObject* self=(PyoaVarDataAppDef_oaTechViaDefHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechViaDefHeader p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTechViaDefHeader_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechViaDefHeader_isNull_doc[] =
"Class: oaVarDataAppDef_oaTechViaDefHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaVarDataAppDef_oaTechViaDefHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaVarDataAppDef_oaTechViaDefHeader data;
    int convert_status=PyoaVarDataAppDef_oaTechViaDefHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaVarDataAppDef_oaTechViaDefHeader_assign_doc[] = 
"Class: oaVarDataAppDef_oaTechViaDefHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVarDataAppDef_oaTechViaDefHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVarDataAppDef_oaTechViaDefHeader data;
  int convert_status=PyoaVarDataAppDef_oaTechViaDefHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVarDataAppDef_oaTechViaDefHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVarDataAppDef_oaTechViaDefHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVarDataAppDef_oaTechViaDefHeader_methodlist[] = {
    {"get",(PyCFunction)oaVarDataAppDef_oaTechViaDefHeader_get,METH_VARARGS,oaVarDataAppDef_oaTechViaDefHeader_get_doc},
    {"getDefault",(PyCFunction)oaVarDataAppDef_oaTechViaDefHeader_getDefault,METH_VARARGS,oaVarDataAppDef_oaTechViaDefHeader_getDefault_doc},
    {"getDefaultSize",(PyCFunction)oaVarDataAppDef_oaTechViaDefHeader_getDefaultSize,METH_VARARGS,oaVarDataAppDef_oaTechViaDefHeader_getDefaultSize_doc},
    {"getSize",(PyCFunction)oaVarDataAppDef_oaTechViaDefHeader_getSize,METH_VARARGS,oaVarDataAppDef_oaTechViaDefHeader_getSize_doc},
    {"set",(PyCFunction)oaVarDataAppDef_oaTechViaDefHeader_set,METH_VARARGS,oaVarDataAppDef_oaTechViaDefHeader_set_doc},
    {"isNull",(PyCFunction)oaVarDataAppDef_oaTechViaDefHeader_tp_isNull,METH_VARARGS,oaVarDataAppDef_oaTechViaDefHeader_isNull_doc},
    {"assign",(PyCFunction)oaVarDataAppDef_oaTechViaDefHeader_tp_assign,METH_VARARGS,oaVarDataAppDef_oaTechViaDefHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechViaDefHeader_doc[] = 
"Class: oaVarDataAppDef_oaTechViaDefHeader\n"
"  The oaVarDataAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When the objects are created, a data field is added to each object of the specified dataType. Applications can use the new data field for whatever purpose is necessary.\n"
"  This type of extension is useful because it allows variable-sized data for each object being extended. This is similar to the oaDataAppDef class, but more general because the data size can differ for each object. (There is a minor speed and size penalty for this additional flexibility.) The default value for this extension is zero bytes.\n"
"  Note: Because the type of data is unknown to OpenAccess, it is unmanaged. This means the contents are not byte-swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaVarDataAppDef_oaTechViaDefHeader)\n"
"    Calls: (const oaVarDataAppDef_oaTechViaDefHeader&)\n"
"    Signature: oaVarDataAppDef_oaTechViaDefHeader||cref-oaVarDataAppDef_oaTechViaDefHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVarDataAppDef_oaTechViaDefHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVarDataAppDef_oaTechViaDefHeader",
    sizeof(PyoaVarDataAppDef_oaTechViaDefHeaderObject),
    0,
    (destructor)oaVarDataAppDef_oaTechViaDefHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVarDataAppDef_oaTechViaDefHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaVarDataAppDef_oaTechViaDefHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVarDataAppDef_oaTechViaDefHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVarDataAppDef_oaTechViaDefHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVarDataAppDef_oaTechViaDefHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechViaDefHeader_static_find_doc[] = 
"Class: oaVarDataAppDef_oaTechViaDefHeader, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaTechViaDefHeader* find(const oaString& name)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaTechViaDefHeader|cref-oaString,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaTechViaDefHeader* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaTechViaDefHeader|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaVarDataAppDef_oaTechViaDefHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaTechViaDefHeaderp result= (oaVarDataAppDef_oaTechViaDefHeader::find(p1.Data()));
            return PyoaVarDataAppDef_oaTechViaDefHeader_FromoaVarDataAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaTechViaDefHeaderp result= (oaVarDataAppDef_oaTechViaDefHeader::find(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaTechViaDefHeader_FromoaVarDataAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaTechViaDefHeader, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTechViaDefHeader_static_get_doc[] = 
"Class: oaVarDataAppDef_oaTechViaDefHeader, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaTechViaDefHeader* get(const oaString& name)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTechViaDefHeader|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaTechViaDefHeader* get(const oaString& name,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTechViaDefHeader|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaTechViaDefHeader* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTechViaDefHeader|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaTechViaDefHeader* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTechViaDefHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaTechViaDefHeader* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTechViaDefHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaTechViaDefHeader* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTechViaDefHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
;

static PyObject*
oaVarDataAppDef_oaTechViaDefHeader_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaTechViaDefHeaderp result= (oaVarDataAppDef_oaTechViaDefHeader::get(p1.Data()));
            return PyoaVarDataAppDef_oaTechViaDefHeader_FromoaVarDataAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaVarDataAppDef_oaTechViaDefHeaderp result= (oaVarDataAppDef_oaTechViaDefHeader::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaTechViaDefHeader_FromoaVarDataAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaVarDataAppDef_oaTechViaDefHeaderp result= (oaVarDataAppDef_oaTechViaDefHeader::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaTechViaDefHeader_FromoaVarDataAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaTechViaDefHeaderp result= (oaVarDataAppDef_oaTechViaDefHeader::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaTechViaDefHeader_FromoaVarDataAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaTechViaDefHeaderp result= (oaVarDataAppDef_oaTechViaDefHeader::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaTechViaDefHeader_FromoaVarDataAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaTechViaDefHeaderp result= (oaVarDataAppDef_oaTechViaDefHeader::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaVarDataAppDef_oaTechViaDefHeader_FromoaVarDataAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaTechViaDefHeader, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaVarDataAppDef_oaTechViaDefHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaVarDataAppDef_oaTechViaDefHeader_static_find,METH_VARARGS,oaVarDataAppDef_oaTechViaDefHeader_static_find_doc},
    {"static_get",(PyCFunction)oaVarDataAppDef_oaTechViaDefHeader_static_get,METH_VARARGS,oaVarDataAppDef_oaTechViaDefHeader_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVarDataAppDef_oaTechViaDefHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVarDataAppDef_oaTechViaDefHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaVarDataAppDef_oaTechViaDefHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVarDataAppDef_oaTechViaDefHeader",
           (PyObject*)(&PyoaVarDataAppDef_oaTechViaDefHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVarDataAppDef_oaTechViaDefHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaVarDataAppDef_oaTechViaDefHeader_Type.tp_dict;
    for(method=oaVarDataAppDef_oaTechViaDefHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVarDataAppDef_oaTerm
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaTerm_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVarDataAppDef_oaTerm_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVarDataAppDef_oaTermObject* self = (PyoaVarDataAppDef_oaTermObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaVarDataAppDef_oaTerm)
    {
        PyParamoaVarDataAppDef_oaTerm p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVarDataAppDef_oaTerm_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVarDataAppDef_oaTerm, Choices are:\n"
        "    (oaVarDataAppDef_oaTerm)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVarDataAppDef_oaTerm_tp_dealloc(PyoaVarDataAppDef_oaTermObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaTerm_tp_repr(PyObject *ob)
{
    PyParamoaVarDataAppDef_oaTerm value;
    int convert_status=PyoaVarDataAppDef_oaTerm_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[44];
    sprintf(buffer,"<oaVarDataAppDef_oaTerm::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVarDataAppDef_oaTerm_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVarDataAppDef_oaTerm v1;
    PyParamoaVarDataAppDef_oaTerm v2;
    int convert_status1=PyoaVarDataAppDef_oaTerm_Convert(ob1,&v1);
    int convert_status2=PyoaVarDataAppDef_oaTerm_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVarDataAppDef_oaTerm_Convert(PyObject* ob,PyParamoaVarDataAppDef_oaTerm* result)
{
    if (ob == NULL) return 1;
    if (PyoaVarDataAppDef_oaTerm_Check(ob)) {
        result->SetData( (oaVarDataAppDef_oaTerm**) ((PyoaVarDataAppDef_oaTermObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVarDataAppDef_oaTerm Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaTerm_FromoaVarDataAppDef_oaTerm(oaVarDataAppDef_oaTerm** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaVarDataAppDef_oaTerm* data=*value;
        PyObject* bself = PyoaVarDataAppDef_oaTerm_Type.tp_alloc(&PyoaVarDataAppDef_oaTerm_Type,0);
        if (bself == NULL) return bself;
        PyoaVarDataAppDef_oaTermObject* self = (PyoaVarDataAppDef_oaTermObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaTerm_FromoaVarDataAppDef_oaTerm(oaVarDataAppDef_oaTerm* data)
{
    if (data) {
       PyObject* bself = PyoaVarDataAppDef_oaTerm_Type.tp_alloc(&PyoaVarDataAppDef_oaTerm_Type,0);
       if (bself == NULL) return bself;
       PyoaVarDataAppDef_oaTermObject* self = (PyoaVarDataAppDef_oaTermObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTerm_get_doc[] = 
"Class: oaVarDataAppDef_oaTerm, Function: get\n"
"  Paramegers: (oaTerm,[oaByte])\n"
"    Calls: void get(const oaTerm* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaTerm,ptr-oaByte,\n"
"    This function returns the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaTerm_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTerm data;
    int convert_status=PyoaVarDataAppDef_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTermObject* self=(PyoaVarDataAppDef_oaTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTerm p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTerm_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize(p1.Data())==p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match object data");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTerm_getDefault_doc[] = 
"Class: oaVarDataAppDef_oaTerm, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value for this extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to be filled out with the default value\n"
;

static PyObject*
oaVarDataAppDef_oaTerm_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTerm data;
    int convert_status=PyoaVarDataAppDef_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTermObject* self=(PyoaVarDataAppDef_oaTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getDefaultSize()==p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match default size");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTerm_getDefaultSize_doc[] = 
"Class: oaVarDataAppDef_oaTerm, Function: getDefaultSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getDefaultSize() const\n"
"    Signature: getDefaultSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the default size for this extension in bytes.\n"
;

static PyObject*
oaVarDataAppDef_oaTerm_getDefaultSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTerm data;
    int convert_status=PyoaVarDataAppDef_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTermObject* self=(PyoaVarDataAppDef_oaTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getDefaultSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTerm_getSize_doc[] = 
"Class: oaVarDataAppDef_oaTerm, Function: getSize\n"
"  Paramegers: (oaTerm)\n"
"    Calls: oaUInt4 getSize(const oaTerm* object)\n"
"    Signature: getSize|simple-oaUInt4|cptr-oaTerm,\n"
"    This function returns the size of the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaTerm_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTerm data;
    int convert_status=PyoaVarDataAppDef_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTermObject* self=(PyoaVarDataAppDef_oaTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTerm p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTerm_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (data.DataCall()->getSize(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTerm_set_doc[] = 
"Class: oaVarDataAppDef_oaTerm, Function: set\n"
"  Paramegers: (oaTerm,[oaByte])\n"
"    Calls: void set(oaTerm* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaTerm,simple-oaUInt4,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaTerm_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTerm data;
    int convert_status=PyoaVarDataAppDef_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTermObject* self=(PyoaVarDataAppDef_oaTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTerm p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTerm_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTerm_isNull_doc[] =
"Class: oaVarDataAppDef_oaTerm, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaVarDataAppDef_oaTerm_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaVarDataAppDef_oaTerm data;
    int convert_status=PyoaVarDataAppDef_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaVarDataAppDef_oaTerm_assign_doc[] = 
"Class: oaVarDataAppDef_oaTerm, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVarDataAppDef_oaTerm_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVarDataAppDef_oaTerm data;
  int convert_status=PyoaVarDataAppDef_oaTerm_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVarDataAppDef_oaTerm p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVarDataAppDef_oaTerm_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVarDataAppDef_oaTerm_methodlist[] = {
    {"get",(PyCFunction)oaVarDataAppDef_oaTerm_get,METH_VARARGS,oaVarDataAppDef_oaTerm_get_doc},
    {"getDefault",(PyCFunction)oaVarDataAppDef_oaTerm_getDefault,METH_VARARGS,oaVarDataAppDef_oaTerm_getDefault_doc},
    {"getDefaultSize",(PyCFunction)oaVarDataAppDef_oaTerm_getDefaultSize,METH_VARARGS,oaVarDataAppDef_oaTerm_getDefaultSize_doc},
    {"getSize",(PyCFunction)oaVarDataAppDef_oaTerm_getSize,METH_VARARGS,oaVarDataAppDef_oaTerm_getSize_doc},
    {"set",(PyCFunction)oaVarDataAppDef_oaTerm_set,METH_VARARGS,oaVarDataAppDef_oaTerm_set_doc},
    {"isNull",(PyCFunction)oaVarDataAppDef_oaTerm_tp_isNull,METH_VARARGS,oaVarDataAppDef_oaTerm_isNull_doc},
    {"assign",(PyCFunction)oaVarDataAppDef_oaTerm_tp_assign,METH_VARARGS,oaVarDataAppDef_oaTerm_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTerm_doc[] = 
"Class: oaVarDataAppDef_oaTerm\n"
"  The oaVarDataAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When the objects are created, a data field is added to each object of the specified dataType. Applications can use the new data field for whatever purpose is necessary.\n"
"  This type of extension is useful because it allows variable-sized data for each object being extended. This is similar to the oaDataAppDef class, but more general because the data size can differ for each object. (There is a minor speed and size penalty for this additional flexibility.) The default value for this extension is zero bytes.\n"
"  Note: Because the type of data is unknown to OpenAccess, it is unmanaged. This means the contents are not byte-swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaVarDataAppDef_oaTerm)\n"
"    Calls: (const oaVarDataAppDef_oaTerm&)\n"
"    Signature: oaVarDataAppDef_oaTerm||cref-oaVarDataAppDef_oaTerm,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVarDataAppDef_oaTerm_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVarDataAppDef_oaTerm",
    sizeof(PyoaVarDataAppDef_oaTermObject),
    0,
    (destructor)oaVarDataAppDef_oaTerm_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVarDataAppDef_oaTerm_tp_compare,	/* tp_compare */
    (reprfunc)oaVarDataAppDef_oaTerm_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVarDataAppDef_oaTerm_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVarDataAppDef_oaTerm_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVarDataAppDef_oaTerm_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTerm_static_find_doc[] = 
"Class: oaVarDataAppDef_oaTerm, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaTerm* find(const oaString& name)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaTerm|cref-oaString,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaTerm* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaTerm|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaVarDataAppDef_oaTerm_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaTermp result= (oaVarDataAppDef_oaTerm::find(p1.Data()));
            return PyoaVarDataAppDef_oaTerm_FromoaVarDataAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaTermp result= (oaVarDataAppDef_oaTerm::find(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaTerm_FromoaVarDataAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaTerm, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTerm_static_get_doc[] = 
"Class: oaVarDataAppDef_oaTerm, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaTerm* get(const oaString& name)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTerm|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaTerm* get(const oaString& name,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTerm|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaTerm* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTerm|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaTerm* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTerm|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaTerm* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTerm|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaTerm* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTerm|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
;

static PyObject*
oaVarDataAppDef_oaTerm_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaTermp result= (oaVarDataAppDef_oaTerm::get(p1.Data()));
            return PyoaVarDataAppDef_oaTerm_FromoaVarDataAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaVarDataAppDef_oaTermp result= (oaVarDataAppDef_oaTerm::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaTerm_FromoaVarDataAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaVarDataAppDef_oaTermp result= (oaVarDataAppDef_oaTerm::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaTerm_FromoaVarDataAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaTermp result= (oaVarDataAppDef_oaTerm::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaTerm_FromoaVarDataAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaTermp result= (oaVarDataAppDef_oaTerm::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaTerm_FromoaVarDataAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaTermp result= (oaVarDataAppDef_oaTerm::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaVarDataAppDef_oaTerm_FromoaVarDataAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaTerm, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaVarDataAppDef_oaTerm_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaVarDataAppDef_oaTerm_static_find,METH_VARARGS,oaVarDataAppDef_oaTerm_static_find_doc},
    {"static_get",(PyCFunction)oaVarDataAppDef_oaTerm_static_get,METH_VARARGS,oaVarDataAppDef_oaTerm_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVarDataAppDef_oaTerm_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVarDataAppDef_oaTerm_Type)<0) {
      printf("** PyType_Ready failed for: oaVarDataAppDef_oaTerm\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVarDataAppDef_oaTerm",
           (PyObject*)(&PyoaVarDataAppDef_oaTerm_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVarDataAppDef_oaTerm\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaVarDataAppDef_oaTerm_Type.tp_dict;
    for(method=oaVarDataAppDef_oaTerm_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVarDataAppDef_oaTrackPattern
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaTrackPattern_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVarDataAppDef_oaTrackPattern_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVarDataAppDef_oaTrackPatternObject* self = (PyoaVarDataAppDef_oaTrackPatternObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaVarDataAppDef_oaTrackPattern)
    {
        PyParamoaVarDataAppDef_oaTrackPattern p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVarDataAppDef_oaTrackPattern_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVarDataAppDef_oaTrackPattern, Choices are:\n"
        "    (oaVarDataAppDef_oaTrackPattern)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVarDataAppDef_oaTrackPattern_tp_dealloc(PyoaVarDataAppDef_oaTrackPatternObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaTrackPattern_tp_repr(PyObject *ob)
{
    PyParamoaVarDataAppDef_oaTrackPattern value;
    int convert_status=PyoaVarDataAppDef_oaTrackPattern_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[52];
    sprintf(buffer,"<oaVarDataAppDef_oaTrackPattern::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVarDataAppDef_oaTrackPattern_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVarDataAppDef_oaTrackPattern v1;
    PyParamoaVarDataAppDef_oaTrackPattern v2;
    int convert_status1=PyoaVarDataAppDef_oaTrackPattern_Convert(ob1,&v1);
    int convert_status2=PyoaVarDataAppDef_oaTrackPattern_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVarDataAppDef_oaTrackPattern_Convert(PyObject* ob,PyParamoaVarDataAppDef_oaTrackPattern* result)
{
    if (ob == NULL) return 1;
    if (PyoaVarDataAppDef_oaTrackPattern_Check(ob)) {
        result->SetData( (oaVarDataAppDef_oaTrackPattern**) ((PyoaVarDataAppDef_oaTrackPatternObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVarDataAppDef_oaTrackPattern Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaTrackPattern_FromoaVarDataAppDef_oaTrackPattern(oaVarDataAppDef_oaTrackPattern** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaVarDataAppDef_oaTrackPattern* data=*value;
        PyObject* bself = PyoaVarDataAppDef_oaTrackPattern_Type.tp_alloc(&PyoaVarDataAppDef_oaTrackPattern_Type,0);
        if (bself == NULL) return bself;
        PyoaVarDataAppDef_oaTrackPatternObject* self = (PyoaVarDataAppDef_oaTrackPatternObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaTrackPattern_FromoaVarDataAppDef_oaTrackPattern(oaVarDataAppDef_oaTrackPattern* data)
{
    if (data) {
       PyObject* bself = PyoaVarDataAppDef_oaTrackPattern_Type.tp_alloc(&PyoaVarDataAppDef_oaTrackPattern_Type,0);
       if (bself == NULL) return bself;
       PyoaVarDataAppDef_oaTrackPatternObject* self = (PyoaVarDataAppDef_oaTrackPatternObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTrackPattern_get_doc[] = 
"Class: oaVarDataAppDef_oaTrackPattern, Function: get\n"
"  Paramegers: (oaTrackPattern,[oaByte])\n"
"    Calls: void get(const oaTrackPattern* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaTrackPattern,ptr-oaByte,\n"
"    This function returns the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaTrackPattern_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTrackPattern data;
    int convert_status=PyoaVarDataAppDef_oaTrackPattern_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTrackPatternObject* self=(PyoaVarDataAppDef_oaTrackPatternObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTrackPattern p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTrackPattern_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize(p1.Data())==p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match object data");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTrackPattern_getDefault_doc[] = 
"Class: oaVarDataAppDef_oaTrackPattern, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value for this extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to be filled out with the default value\n"
;

static PyObject*
oaVarDataAppDef_oaTrackPattern_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTrackPattern data;
    int convert_status=PyoaVarDataAppDef_oaTrackPattern_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTrackPatternObject* self=(PyoaVarDataAppDef_oaTrackPatternObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getDefaultSize()==p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match default size");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTrackPattern_getDefaultSize_doc[] = 
"Class: oaVarDataAppDef_oaTrackPattern, Function: getDefaultSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getDefaultSize() const\n"
"    Signature: getDefaultSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the default size for this extension in bytes.\n"
;

static PyObject*
oaVarDataAppDef_oaTrackPattern_getDefaultSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTrackPattern data;
    int convert_status=PyoaVarDataAppDef_oaTrackPattern_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTrackPatternObject* self=(PyoaVarDataAppDef_oaTrackPatternObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getDefaultSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTrackPattern_getSize_doc[] = 
"Class: oaVarDataAppDef_oaTrackPattern, Function: getSize\n"
"  Paramegers: (oaTrackPattern)\n"
"    Calls: oaUInt4 getSize(const oaTrackPattern* object)\n"
"    Signature: getSize|simple-oaUInt4|cptr-oaTrackPattern,\n"
"    This function returns the size of the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaTrackPattern_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTrackPattern data;
    int convert_status=PyoaVarDataAppDef_oaTrackPattern_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTrackPatternObject* self=(PyoaVarDataAppDef_oaTrackPatternObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTrackPattern p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTrackPattern_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (data.DataCall()->getSize(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTrackPattern_set_doc[] = 
"Class: oaVarDataAppDef_oaTrackPattern, Function: set\n"
"  Paramegers: (oaTrackPattern,[oaByte])\n"
"    Calls: void set(oaTrackPattern* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaTrackPattern,simple-oaUInt4,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaTrackPattern_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaTrackPattern data;
    int convert_status=PyoaVarDataAppDef_oaTrackPattern_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaTrackPatternObject* self=(PyoaVarDataAppDef_oaTrackPatternObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTrackPattern p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTrackPattern_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTrackPattern_isNull_doc[] =
"Class: oaVarDataAppDef_oaTrackPattern, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaVarDataAppDef_oaTrackPattern_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaVarDataAppDef_oaTrackPattern data;
    int convert_status=PyoaVarDataAppDef_oaTrackPattern_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaVarDataAppDef_oaTrackPattern_assign_doc[] = 
"Class: oaVarDataAppDef_oaTrackPattern, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVarDataAppDef_oaTrackPattern_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVarDataAppDef_oaTrackPattern data;
  int convert_status=PyoaVarDataAppDef_oaTrackPattern_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVarDataAppDef_oaTrackPattern p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVarDataAppDef_oaTrackPattern_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVarDataAppDef_oaTrackPattern_methodlist[] = {
    {"get",(PyCFunction)oaVarDataAppDef_oaTrackPattern_get,METH_VARARGS,oaVarDataAppDef_oaTrackPattern_get_doc},
    {"getDefault",(PyCFunction)oaVarDataAppDef_oaTrackPattern_getDefault,METH_VARARGS,oaVarDataAppDef_oaTrackPattern_getDefault_doc},
    {"getDefaultSize",(PyCFunction)oaVarDataAppDef_oaTrackPattern_getDefaultSize,METH_VARARGS,oaVarDataAppDef_oaTrackPattern_getDefaultSize_doc},
    {"getSize",(PyCFunction)oaVarDataAppDef_oaTrackPattern_getSize,METH_VARARGS,oaVarDataAppDef_oaTrackPattern_getSize_doc},
    {"set",(PyCFunction)oaVarDataAppDef_oaTrackPattern_set,METH_VARARGS,oaVarDataAppDef_oaTrackPattern_set_doc},
    {"isNull",(PyCFunction)oaVarDataAppDef_oaTrackPattern_tp_isNull,METH_VARARGS,oaVarDataAppDef_oaTrackPattern_isNull_doc},
    {"assign",(PyCFunction)oaVarDataAppDef_oaTrackPattern_tp_assign,METH_VARARGS,oaVarDataAppDef_oaTrackPattern_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTrackPattern_doc[] = 
"Class: oaVarDataAppDef_oaTrackPattern\n"
"  The oaVarDataAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When the objects are created, a data field is added to each object of the specified dataType. Applications can use the new data field for whatever purpose is necessary.\n"
"  This type of extension is useful because it allows variable-sized data for each object being extended. This is similar to the oaDataAppDef class, but more general because the data size can differ for each object. (There is a minor speed and size penalty for this additional flexibility.) The default value for this extension is zero bytes.\n"
"  Note: Because the type of data is unknown to OpenAccess, it is unmanaged. This means the contents are not byte-swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaVarDataAppDef_oaTrackPattern)\n"
"    Calls: (const oaVarDataAppDef_oaTrackPattern&)\n"
"    Signature: oaVarDataAppDef_oaTrackPattern||cref-oaVarDataAppDef_oaTrackPattern,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVarDataAppDef_oaTrackPattern_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVarDataAppDef_oaTrackPattern",
    sizeof(PyoaVarDataAppDef_oaTrackPatternObject),
    0,
    (destructor)oaVarDataAppDef_oaTrackPattern_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVarDataAppDef_oaTrackPattern_tp_compare,	/* tp_compare */
    (reprfunc)oaVarDataAppDef_oaTrackPattern_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVarDataAppDef_oaTrackPattern_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVarDataAppDef_oaTrackPattern_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVarDataAppDef_oaTrackPattern_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTrackPattern_static_find_doc[] = 
"Class: oaVarDataAppDef_oaTrackPattern, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaTrackPattern* find(const oaString& name)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaTrackPattern|cref-oaString,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaTrackPattern* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaTrackPattern|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaVarDataAppDef_oaTrackPattern_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaTrackPatternp result= (oaVarDataAppDef_oaTrackPattern::find(p1.Data()));
            return PyoaVarDataAppDef_oaTrackPattern_FromoaVarDataAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaTrackPatternp result= (oaVarDataAppDef_oaTrackPattern::find(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaTrackPattern_FromoaVarDataAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaTrackPattern, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaTrackPattern_static_get_doc[] = 
"Class: oaVarDataAppDef_oaTrackPattern, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaTrackPattern* get(const oaString& name)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTrackPattern|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaTrackPattern* get(const oaString& name,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTrackPattern|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaTrackPattern* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTrackPattern|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaTrackPattern* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTrackPattern|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaTrackPattern* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTrackPattern|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaTrackPattern* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaTrackPattern|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
;

static PyObject*
oaVarDataAppDef_oaTrackPattern_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaTrackPatternp result= (oaVarDataAppDef_oaTrackPattern::get(p1.Data()));
            return PyoaVarDataAppDef_oaTrackPattern_FromoaVarDataAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaVarDataAppDef_oaTrackPatternp result= (oaVarDataAppDef_oaTrackPattern::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaTrackPattern_FromoaVarDataAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaVarDataAppDef_oaTrackPatternp result= (oaVarDataAppDef_oaTrackPattern::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaTrackPattern_FromoaVarDataAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaTrackPatternp result= (oaVarDataAppDef_oaTrackPattern::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaTrackPattern_FromoaVarDataAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaTrackPatternp result= (oaVarDataAppDef_oaTrackPattern::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaTrackPattern_FromoaVarDataAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaTrackPatternp result= (oaVarDataAppDef_oaTrackPattern::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaVarDataAppDef_oaTrackPattern_FromoaVarDataAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaTrackPattern, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaVarDataAppDef_oaTrackPattern_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaVarDataAppDef_oaTrackPattern_static_find,METH_VARARGS,oaVarDataAppDef_oaTrackPattern_static_find_doc},
    {"static_get",(PyCFunction)oaVarDataAppDef_oaTrackPattern_static_get,METH_VARARGS,oaVarDataAppDef_oaTrackPattern_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVarDataAppDef_oaTrackPattern_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVarDataAppDef_oaTrackPattern_Type)<0) {
      printf("** PyType_Ready failed for: oaVarDataAppDef_oaTrackPattern\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVarDataAppDef_oaTrackPattern",
           (PyObject*)(&PyoaVarDataAppDef_oaTrackPattern_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVarDataAppDef_oaTrackPattern\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaVarDataAppDef_oaTrackPattern_Type.tp_dict;
    for(method=oaVarDataAppDef_oaTrackPattern_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVarDataAppDef_oaValue
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaValue_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVarDataAppDef_oaValue_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVarDataAppDef_oaValueObject* self = (PyoaVarDataAppDef_oaValueObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaVarDataAppDef_oaValue)
    {
        PyParamoaVarDataAppDef_oaValue p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVarDataAppDef_oaValue_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVarDataAppDef_oaValue, Choices are:\n"
        "    (oaVarDataAppDef_oaValue)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVarDataAppDef_oaValue_tp_dealloc(PyoaVarDataAppDef_oaValueObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaValue_tp_repr(PyObject *ob)
{
    PyParamoaVarDataAppDef_oaValue value;
    int convert_status=PyoaVarDataAppDef_oaValue_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[45];
    sprintf(buffer,"<oaVarDataAppDef_oaValue::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVarDataAppDef_oaValue_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVarDataAppDef_oaValue v1;
    PyParamoaVarDataAppDef_oaValue v2;
    int convert_status1=PyoaVarDataAppDef_oaValue_Convert(ob1,&v1);
    int convert_status2=PyoaVarDataAppDef_oaValue_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVarDataAppDef_oaValue_Convert(PyObject* ob,PyParamoaVarDataAppDef_oaValue* result)
{
    if (ob == NULL) return 1;
    if (PyoaVarDataAppDef_oaValue_Check(ob)) {
        result->SetData( (oaVarDataAppDef_oaValue**) ((PyoaVarDataAppDef_oaValueObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVarDataAppDef_oaValue Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaValue_FromoaVarDataAppDef_oaValue(oaVarDataAppDef_oaValue** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaVarDataAppDef_oaValue* data=*value;
        PyObject* bself = PyoaVarDataAppDef_oaValue_Type.tp_alloc(&PyoaVarDataAppDef_oaValue_Type,0);
        if (bself == NULL) return bself;
        PyoaVarDataAppDef_oaValueObject* self = (PyoaVarDataAppDef_oaValueObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaValue_FromoaVarDataAppDef_oaValue(oaVarDataAppDef_oaValue* data)
{
    if (data) {
       PyObject* bself = PyoaVarDataAppDef_oaValue_Type.tp_alloc(&PyoaVarDataAppDef_oaValue_Type,0);
       if (bself == NULL) return bself;
       PyoaVarDataAppDef_oaValueObject* self = (PyoaVarDataAppDef_oaValueObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaValue_get_doc[] = 
"Class: oaVarDataAppDef_oaValue, Function: get\n"
"  Paramegers: (oaValue,[oaByte])\n"
"    Calls: void get(const oaValue* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaValue,ptr-oaByte,\n"
"    This function returns the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaValue_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaValue data;
    int convert_status=PyoaVarDataAppDef_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaValueObject* self=(PyoaVarDataAppDef_oaValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaValue p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaValue_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize(p1.Data())==p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match object data");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaValue_getDefault_doc[] = 
"Class: oaVarDataAppDef_oaValue, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value for this extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to be filled out with the default value\n"
;

static PyObject*
oaVarDataAppDef_oaValue_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaValue data;
    int convert_status=PyoaVarDataAppDef_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaValueObject* self=(PyoaVarDataAppDef_oaValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getDefaultSize()==p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match default size");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaValue_getDefaultSize_doc[] = 
"Class: oaVarDataAppDef_oaValue, Function: getDefaultSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getDefaultSize() const\n"
"    Signature: getDefaultSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the default size for this extension in bytes.\n"
;

static PyObject*
oaVarDataAppDef_oaValue_getDefaultSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaValue data;
    int convert_status=PyoaVarDataAppDef_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaValueObject* self=(PyoaVarDataAppDef_oaValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getDefaultSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaValue_getSize_doc[] = 
"Class: oaVarDataAppDef_oaValue, Function: getSize\n"
"  Paramegers: (oaValue)\n"
"    Calls: oaUInt4 getSize(const oaValue* object)\n"
"    Signature: getSize|simple-oaUInt4|cptr-oaValue,\n"
"    This function returns the size of the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaValue_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaValue data;
    int convert_status=PyoaVarDataAppDef_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaValueObject* self=(PyoaVarDataAppDef_oaValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaValue p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaValue_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (data.DataCall()->getSize(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaValue_set_doc[] = 
"Class: oaVarDataAppDef_oaValue, Function: set\n"
"  Paramegers: (oaValue,[oaByte])\n"
"    Calls: void set(oaValue* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaValue,simple-oaUInt4,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaValue_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaValue data;
    int convert_status=PyoaVarDataAppDef_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaValueObject* self=(PyoaVarDataAppDef_oaValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaValue p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaValue_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaValue_isNull_doc[] =
"Class: oaVarDataAppDef_oaValue, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaVarDataAppDef_oaValue_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaVarDataAppDef_oaValue data;
    int convert_status=PyoaVarDataAppDef_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaVarDataAppDef_oaValue_assign_doc[] = 
"Class: oaVarDataAppDef_oaValue, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVarDataAppDef_oaValue_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVarDataAppDef_oaValue data;
  int convert_status=PyoaVarDataAppDef_oaValue_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVarDataAppDef_oaValue p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVarDataAppDef_oaValue_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVarDataAppDef_oaValue_methodlist[] = {
    {"get",(PyCFunction)oaVarDataAppDef_oaValue_get,METH_VARARGS,oaVarDataAppDef_oaValue_get_doc},
    {"getDefault",(PyCFunction)oaVarDataAppDef_oaValue_getDefault,METH_VARARGS,oaVarDataAppDef_oaValue_getDefault_doc},
    {"getDefaultSize",(PyCFunction)oaVarDataAppDef_oaValue_getDefaultSize,METH_VARARGS,oaVarDataAppDef_oaValue_getDefaultSize_doc},
    {"getSize",(PyCFunction)oaVarDataAppDef_oaValue_getSize,METH_VARARGS,oaVarDataAppDef_oaValue_getSize_doc},
    {"set",(PyCFunction)oaVarDataAppDef_oaValue_set,METH_VARARGS,oaVarDataAppDef_oaValue_set_doc},
    {"isNull",(PyCFunction)oaVarDataAppDef_oaValue_tp_isNull,METH_VARARGS,oaVarDataAppDef_oaValue_isNull_doc},
    {"assign",(PyCFunction)oaVarDataAppDef_oaValue_tp_assign,METH_VARARGS,oaVarDataAppDef_oaValue_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaValue_doc[] = 
"Class: oaVarDataAppDef_oaValue\n"
"  The oaVarDataAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When the objects are created, a data field is added to each object of the specified dataType. Applications can use the new data field for whatever purpose is necessary.\n"
"  This type of extension is useful because it allows variable-sized data for each object being extended. This is similar to the oaDataAppDef class, but more general because the data size can differ for each object. (There is a minor speed and size penalty for this additional flexibility.) The default value for this extension is zero bytes.\n"
"  Note: Because the type of data is unknown to OpenAccess, it is unmanaged. This means the contents are not byte-swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaVarDataAppDef_oaValue)\n"
"    Calls: (const oaVarDataAppDef_oaValue&)\n"
"    Signature: oaVarDataAppDef_oaValue||cref-oaVarDataAppDef_oaValue,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVarDataAppDef_oaValue_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVarDataAppDef_oaValue",
    sizeof(PyoaVarDataAppDef_oaValueObject),
    0,
    (destructor)oaVarDataAppDef_oaValue_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVarDataAppDef_oaValue_tp_compare,	/* tp_compare */
    (reprfunc)oaVarDataAppDef_oaValue_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVarDataAppDef_oaValue_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVarDataAppDef_oaValue_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVarDataAppDef_oaValue_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaValue_static_find_doc[] = 
"Class: oaVarDataAppDef_oaValue, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaValue* find(const oaString& name)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaValue|cref-oaString,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaValue* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaValue|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaVarDataAppDef_oaValue_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaValuep result= (oaVarDataAppDef_oaValue::find(p1.Data()));
            return PyoaVarDataAppDef_oaValue_FromoaVarDataAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaValuep result= (oaVarDataAppDef_oaValue::find(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaValue_FromoaVarDataAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaValue, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaValue_static_get_doc[] = 
"Class: oaVarDataAppDef_oaValue, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaValue* get(const oaString& name)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaValue|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaValue* get(const oaString& name,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaValue|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaValue* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaValue|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaValue* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaValue|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaValue* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaValue|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaValue* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaValue|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
;

static PyObject*
oaVarDataAppDef_oaValue_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaValuep result= (oaVarDataAppDef_oaValue::get(p1.Data()));
            return PyoaVarDataAppDef_oaValue_FromoaVarDataAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaVarDataAppDef_oaValuep result= (oaVarDataAppDef_oaValue::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaValue_FromoaVarDataAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaVarDataAppDef_oaValuep result= (oaVarDataAppDef_oaValue::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaValue_FromoaVarDataAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaValuep result= (oaVarDataAppDef_oaValue::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaValue_FromoaVarDataAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaValuep result= (oaVarDataAppDef_oaValue::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaValue_FromoaVarDataAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaValuep result= (oaVarDataAppDef_oaValue::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaVarDataAppDef_oaValue_FromoaVarDataAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaValue, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaVarDataAppDef_oaValue_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaVarDataAppDef_oaValue_static_find,METH_VARARGS,oaVarDataAppDef_oaValue_static_find_doc},
    {"static_get",(PyCFunction)oaVarDataAppDef_oaValue_static_get,METH_VARARGS,oaVarDataAppDef_oaValue_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVarDataAppDef_oaValue_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVarDataAppDef_oaValue_Type)<0) {
      printf("** PyType_Ready failed for: oaVarDataAppDef_oaValue\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVarDataAppDef_oaValue",
           (PyObject*)(&PyoaVarDataAppDef_oaValue_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVarDataAppDef_oaValue\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaVarDataAppDef_oaValue_Type.tp_dict;
    for(method=oaVarDataAppDef_oaValue_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVarDataAppDef_oaVectorInstDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaVectorInstDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVarDataAppDef_oaVectorInstDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVarDataAppDef_oaVectorInstDefObject* self = (PyoaVarDataAppDef_oaVectorInstDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaVarDataAppDef_oaVectorInstDef)
    {
        PyParamoaVarDataAppDef_oaVectorInstDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVarDataAppDef_oaVectorInstDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVarDataAppDef_oaVectorInstDef, Choices are:\n"
        "    (oaVarDataAppDef_oaVectorInstDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVarDataAppDef_oaVectorInstDef_tp_dealloc(PyoaVarDataAppDef_oaVectorInstDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaVectorInstDef_tp_repr(PyObject *ob)
{
    PyParamoaVarDataAppDef_oaVectorInstDef value;
    int convert_status=PyoaVarDataAppDef_oaVectorInstDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[53];
    sprintf(buffer,"<oaVarDataAppDef_oaVectorInstDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVarDataAppDef_oaVectorInstDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVarDataAppDef_oaVectorInstDef v1;
    PyParamoaVarDataAppDef_oaVectorInstDef v2;
    int convert_status1=PyoaVarDataAppDef_oaVectorInstDef_Convert(ob1,&v1);
    int convert_status2=PyoaVarDataAppDef_oaVectorInstDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVarDataAppDef_oaVectorInstDef_Convert(PyObject* ob,PyParamoaVarDataAppDef_oaVectorInstDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaVarDataAppDef_oaVectorInstDef_Check(ob)) {
        result->SetData( (oaVarDataAppDef_oaVectorInstDef**) ((PyoaVarDataAppDef_oaVectorInstDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVarDataAppDef_oaVectorInstDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaVectorInstDef_FromoaVarDataAppDef_oaVectorInstDef(oaVarDataAppDef_oaVectorInstDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaVarDataAppDef_oaVectorInstDef* data=*value;
        PyObject* bself = PyoaVarDataAppDef_oaVectorInstDef_Type.tp_alloc(&PyoaVarDataAppDef_oaVectorInstDef_Type,0);
        if (bself == NULL) return bself;
        PyoaVarDataAppDef_oaVectorInstDefObject* self = (PyoaVarDataAppDef_oaVectorInstDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaVectorInstDef_FromoaVarDataAppDef_oaVectorInstDef(oaVarDataAppDef_oaVectorInstDef* data)
{
    if (data) {
       PyObject* bself = PyoaVarDataAppDef_oaVectorInstDef_Type.tp_alloc(&PyoaVarDataAppDef_oaVectorInstDef_Type,0);
       if (bself == NULL) return bself;
       PyoaVarDataAppDef_oaVectorInstDefObject* self = (PyoaVarDataAppDef_oaVectorInstDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaVectorInstDef_get_doc[] = 
"Class: oaVarDataAppDef_oaVectorInstDef, Function: get\n"
"  Paramegers: (oaVectorInstDef,[oaByte])\n"
"    Calls: void get(const oaVectorInstDef* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaVectorInstDef,ptr-oaByte,\n"
"    This function returns the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaVectorInstDef_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaVectorInstDef data;
    int convert_status=PyoaVarDataAppDef_oaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaVectorInstDefObject* self=(PyoaVarDataAppDef_oaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaVectorInstDef p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaVectorInstDef_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize(p1.Data())==p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match object data");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaVectorInstDef_getDefault_doc[] = 
"Class: oaVarDataAppDef_oaVectorInstDef, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value for this extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to be filled out with the default value\n"
;

static PyObject*
oaVarDataAppDef_oaVectorInstDef_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaVectorInstDef data;
    int convert_status=PyoaVarDataAppDef_oaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaVectorInstDefObject* self=(PyoaVarDataAppDef_oaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getDefaultSize()==p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match default size");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaVectorInstDef_getDefaultSize_doc[] = 
"Class: oaVarDataAppDef_oaVectorInstDef, Function: getDefaultSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getDefaultSize() const\n"
"    Signature: getDefaultSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the default size for this extension in bytes.\n"
;

static PyObject*
oaVarDataAppDef_oaVectorInstDef_getDefaultSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaVectorInstDef data;
    int convert_status=PyoaVarDataAppDef_oaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaVectorInstDefObject* self=(PyoaVarDataAppDef_oaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getDefaultSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaVectorInstDef_getSize_doc[] = 
"Class: oaVarDataAppDef_oaVectorInstDef, Function: getSize\n"
"  Paramegers: (oaVectorInstDef)\n"
"    Calls: oaUInt4 getSize(const oaVectorInstDef* object)\n"
"    Signature: getSize|simple-oaUInt4|cptr-oaVectorInstDef,\n"
"    This function returns the size of the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaVectorInstDef_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaVectorInstDef data;
    int convert_status=PyoaVarDataAppDef_oaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaVectorInstDefObject* self=(PyoaVarDataAppDef_oaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaVectorInstDef p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaVectorInstDef_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (data.DataCall()->getSize(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaVectorInstDef_set_doc[] = 
"Class: oaVarDataAppDef_oaVectorInstDef, Function: set\n"
"  Paramegers: (oaVectorInstDef,[oaByte])\n"
"    Calls: void set(oaVectorInstDef* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaVectorInstDef,simple-oaUInt4,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaVectorInstDef_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaVectorInstDef data;
    int convert_status=PyoaVarDataAppDef_oaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaVectorInstDefObject* self=(PyoaVarDataAppDef_oaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaVectorInstDef p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaVectorInstDef_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaVectorInstDef_isNull_doc[] =
"Class: oaVarDataAppDef_oaVectorInstDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaVarDataAppDef_oaVectorInstDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaVarDataAppDef_oaVectorInstDef data;
    int convert_status=PyoaVarDataAppDef_oaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaVarDataAppDef_oaVectorInstDef_assign_doc[] = 
"Class: oaVarDataAppDef_oaVectorInstDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVarDataAppDef_oaVectorInstDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVarDataAppDef_oaVectorInstDef data;
  int convert_status=PyoaVarDataAppDef_oaVectorInstDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVarDataAppDef_oaVectorInstDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVarDataAppDef_oaVectorInstDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVarDataAppDef_oaVectorInstDef_methodlist[] = {
    {"get",(PyCFunction)oaVarDataAppDef_oaVectorInstDef_get,METH_VARARGS,oaVarDataAppDef_oaVectorInstDef_get_doc},
    {"getDefault",(PyCFunction)oaVarDataAppDef_oaVectorInstDef_getDefault,METH_VARARGS,oaVarDataAppDef_oaVectorInstDef_getDefault_doc},
    {"getDefaultSize",(PyCFunction)oaVarDataAppDef_oaVectorInstDef_getDefaultSize,METH_VARARGS,oaVarDataAppDef_oaVectorInstDef_getDefaultSize_doc},
    {"getSize",(PyCFunction)oaVarDataAppDef_oaVectorInstDef_getSize,METH_VARARGS,oaVarDataAppDef_oaVectorInstDef_getSize_doc},
    {"set",(PyCFunction)oaVarDataAppDef_oaVectorInstDef_set,METH_VARARGS,oaVarDataAppDef_oaVectorInstDef_set_doc},
    {"isNull",(PyCFunction)oaVarDataAppDef_oaVectorInstDef_tp_isNull,METH_VARARGS,oaVarDataAppDef_oaVectorInstDef_isNull_doc},
    {"assign",(PyCFunction)oaVarDataAppDef_oaVectorInstDef_tp_assign,METH_VARARGS,oaVarDataAppDef_oaVectorInstDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaVectorInstDef_doc[] = 
"Class: oaVarDataAppDef_oaVectorInstDef\n"
"  The oaVarDataAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When the objects are created, a data field is added to each object of the specified dataType. Applications can use the new data field for whatever purpose is necessary.\n"
"  This type of extension is useful because it allows variable-sized data for each object being extended. This is similar to the oaDataAppDef class, but more general because the data size can differ for each object. (There is a minor speed and size penalty for this additional flexibility.) The default value for this extension is zero bytes.\n"
"  Note: Because the type of data is unknown to OpenAccess, it is unmanaged. This means the contents are not byte-swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaVarDataAppDef_oaVectorInstDef)\n"
"    Calls: (const oaVarDataAppDef_oaVectorInstDef&)\n"
"    Signature: oaVarDataAppDef_oaVectorInstDef||cref-oaVarDataAppDef_oaVectorInstDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVarDataAppDef_oaVectorInstDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVarDataAppDef_oaVectorInstDef",
    sizeof(PyoaVarDataAppDef_oaVectorInstDefObject),
    0,
    (destructor)oaVarDataAppDef_oaVectorInstDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVarDataAppDef_oaVectorInstDef_tp_compare,	/* tp_compare */
    (reprfunc)oaVarDataAppDef_oaVectorInstDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVarDataAppDef_oaVectorInstDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVarDataAppDef_oaVectorInstDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVarDataAppDef_oaVectorInstDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaVectorInstDef_static_find_doc[] = 
"Class: oaVarDataAppDef_oaVectorInstDef, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaVectorInstDef* find(const oaString& name)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaVectorInstDef|cref-oaString,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaVectorInstDef* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaVectorInstDef|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaVarDataAppDef_oaVectorInstDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaVectorInstDefp result= (oaVarDataAppDef_oaVectorInstDef::find(p1.Data()));
            return PyoaVarDataAppDef_oaVectorInstDef_FromoaVarDataAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaVectorInstDefp result= (oaVarDataAppDef_oaVectorInstDef::find(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaVectorInstDef_FromoaVarDataAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaVectorInstDef, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaVectorInstDef_static_get_doc[] = 
"Class: oaVarDataAppDef_oaVectorInstDef, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaVectorInstDef* get(const oaString& name)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaVectorInstDef|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaVectorInstDef* get(const oaString& name,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaVectorInstDef|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaVectorInstDef* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaVectorInstDef|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaVectorInstDef* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaVectorInstDef|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaVectorInstDef* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaVectorInstDef|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaVectorInstDef* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaVectorInstDef|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
;

static PyObject*
oaVarDataAppDef_oaVectorInstDef_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaVectorInstDefp result= (oaVarDataAppDef_oaVectorInstDef::get(p1.Data()));
            return PyoaVarDataAppDef_oaVectorInstDef_FromoaVarDataAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaVarDataAppDef_oaVectorInstDefp result= (oaVarDataAppDef_oaVectorInstDef::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaVectorInstDef_FromoaVarDataAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaVarDataAppDef_oaVectorInstDefp result= (oaVarDataAppDef_oaVectorInstDef::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaVectorInstDef_FromoaVarDataAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaVectorInstDefp result= (oaVarDataAppDef_oaVectorInstDef::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaVectorInstDef_FromoaVarDataAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaVectorInstDefp result= (oaVarDataAppDef_oaVectorInstDef::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaVectorInstDef_FromoaVarDataAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaVectorInstDefp result= (oaVarDataAppDef_oaVectorInstDef::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaVarDataAppDef_oaVectorInstDef_FromoaVarDataAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaVectorInstDef, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaVarDataAppDef_oaVectorInstDef_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaVarDataAppDef_oaVectorInstDef_static_find,METH_VARARGS,oaVarDataAppDef_oaVectorInstDef_static_find_doc},
    {"static_get",(PyCFunction)oaVarDataAppDef_oaVectorInstDef_static_get,METH_VARARGS,oaVarDataAppDef_oaVectorInstDef_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVarDataAppDef_oaVectorInstDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVarDataAppDef_oaVectorInstDef_Type)<0) {
      printf("** PyType_Ready failed for: oaVarDataAppDef_oaVectorInstDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVarDataAppDef_oaVectorInstDef",
           (PyObject*)(&PyoaVarDataAppDef_oaVectorInstDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVarDataAppDef_oaVectorInstDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaVarDataAppDef_oaVectorInstDef_Type.tp_dict;
    for(method=oaVarDataAppDef_oaVectorInstDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVarDataAppDef_oaVia
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaVia_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVarDataAppDef_oaVia_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVarDataAppDef_oaViaObject* self = (PyoaVarDataAppDef_oaViaObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaVarDataAppDef_oaVia)
    {
        PyParamoaVarDataAppDef_oaVia p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVarDataAppDef_oaVia_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVarDataAppDef_oaVia, Choices are:\n"
        "    (oaVarDataAppDef_oaVia)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVarDataAppDef_oaVia_tp_dealloc(PyoaVarDataAppDef_oaViaObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaVia_tp_repr(PyObject *ob)
{
    PyParamoaVarDataAppDef_oaVia value;
    int convert_status=PyoaVarDataAppDef_oaVia_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaVarDataAppDef_oaVia::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVarDataAppDef_oaVia_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVarDataAppDef_oaVia v1;
    PyParamoaVarDataAppDef_oaVia v2;
    int convert_status1=PyoaVarDataAppDef_oaVia_Convert(ob1,&v1);
    int convert_status2=PyoaVarDataAppDef_oaVia_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVarDataAppDef_oaVia_Convert(PyObject* ob,PyParamoaVarDataAppDef_oaVia* result)
{
    if (ob == NULL) return 1;
    if (PyoaVarDataAppDef_oaVia_Check(ob)) {
        result->SetData( (oaVarDataAppDef_oaVia**) ((PyoaVarDataAppDef_oaViaObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVarDataAppDef_oaVia Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaVia_FromoaVarDataAppDef_oaVia(oaVarDataAppDef_oaVia** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaVarDataAppDef_oaVia* data=*value;
        PyObject* bself = PyoaVarDataAppDef_oaVia_Type.tp_alloc(&PyoaVarDataAppDef_oaVia_Type,0);
        if (bself == NULL) return bself;
        PyoaVarDataAppDef_oaViaObject* self = (PyoaVarDataAppDef_oaViaObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaVia_FromoaVarDataAppDef_oaVia(oaVarDataAppDef_oaVia* data)
{
    if (data) {
       PyObject* bself = PyoaVarDataAppDef_oaVia_Type.tp_alloc(&PyoaVarDataAppDef_oaVia_Type,0);
       if (bself == NULL) return bself;
       PyoaVarDataAppDef_oaViaObject* self = (PyoaVarDataAppDef_oaViaObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaVia_get_doc[] = 
"Class: oaVarDataAppDef_oaVia, Function: get\n"
"  Paramegers: (oaVia,[oaByte])\n"
"    Calls: void get(const oaVia* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaVia,ptr-oaByte,\n"
"    This function returns the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaVia_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaVia data;
    int convert_status=PyoaVarDataAppDef_oaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViaObject* self=(PyoaVarDataAppDef_oaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaVia p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaVia_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize(p1.Data())==p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match object data");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaVia_getDefault_doc[] = 
"Class: oaVarDataAppDef_oaVia, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value for this extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to be filled out with the default value\n"
;

static PyObject*
oaVarDataAppDef_oaVia_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaVia data;
    int convert_status=PyoaVarDataAppDef_oaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViaObject* self=(PyoaVarDataAppDef_oaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getDefaultSize()==p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match default size");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaVia_getDefaultSize_doc[] = 
"Class: oaVarDataAppDef_oaVia, Function: getDefaultSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getDefaultSize() const\n"
"    Signature: getDefaultSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the default size for this extension in bytes.\n"
;

static PyObject*
oaVarDataAppDef_oaVia_getDefaultSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaVia data;
    int convert_status=PyoaVarDataAppDef_oaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViaObject* self=(PyoaVarDataAppDef_oaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getDefaultSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaVia_getSize_doc[] = 
"Class: oaVarDataAppDef_oaVia, Function: getSize\n"
"  Paramegers: (oaVia)\n"
"    Calls: oaUInt4 getSize(const oaVia* object)\n"
"    Signature: getSize|simple-oaUInt4|cptr-oaVia,\n"
"    This function returns the size of the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaVia_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaVia data;
    int convert_status=PyoaVarDataAppDef_oaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViaObject* self=(PyoaVarDataAppDef_oaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaVia p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaVia_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (data.DataCall()->getSize(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaVia_set_doc[] = 
"Class: oaVarDataAppDef_oaVia, Function: set\n"
"  Paramegers: (oaVia,[oaByte])\n"
"    Calls: void set(oaVia* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaVia,simple-oaUInt4,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaVia_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaVia data;
    int convert_status=PyoaVarDataAppDef_oaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViaObject* self=(PyoaVarDataAppDef_oaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaVia p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaVia_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaVia_isNull_doc[] =
"Class: oaVarDataAppDef_oaVia, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaVarDataAppDef_oaVia_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaVarDataAppDef_oaVia data;
    int convert_status=PyoaVarDataAppDef_oaVia_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaVarDataAppDef_oaVia_assign_doc[] = 
"Class: oaVarDataAppDef_oaVia, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVarDataAppDef_oaVia_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVarDataAppDef_oaVia data;
  int convert_status=PyoaVarDataAppDef_oaVia_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVarDataAppDef_oaVia p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVarDataAppDef_oaVia_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVarDataAppDef_oaVia_methodlist[] = {
    {"get",(PyCFunction)oaVarDataAppDef_oaVia_get,METH_VARARGS,oaVarDataAppDef_oaVia_get_doc},
    {"getDefault",(PyCFunction)oaVarDataAppDef_oaVia_getDefault,METH_VARARGS,oaVarDataAppDef_oaVia_getDefault_doc},
    {"getDefaultSize",(PyCFunction)oaVarDataAppDef_oaVia_getDefaultSize,METH_VARARGS,oaVarDataAppDef_oaVia_getDefaultSize_doc},
    {"getSize",(PyCFunction)oaVarDataAppDef_oaVia_getSize,METH_VARARGS,oaVarDataAppDef_oaVia_getSize_doc},
    {"set",(PyCFunction)oaVarDataAppDef_oaVia_set,METH_VARARGS,oaVarDataAppDef_oaVia_set_doc},
    {"isNull",(PyCFunction)oaVarDataAppDef_oaVia_tp_isNull,METH_VARARGS,oaVarDataAppDef_oaVia_isNull_doc},
    {"assign",(PyCFunction)oaVarDataAppDef_oaVia_tp_assign,METH_VARARGS,oaVarDataAppDef_oaVia_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaVia_doc[] = 
"Class: oaVarDataAppDef_oaVia\n"
"  The oaVarDataAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When the objects are created, a data field is added to each object of the specified dataType. Applications can use the new data field for whatever purpose is necessary.\n"
"  This type of extension is useful because it allows variable-sized data for each object being extended. This is similar to the oaDataAppDef class, but more general because the data size can differ for each object. (There is a minor speed and size penalty for this additional flexibility.) The default value for this extension is zero bytes.\n"
"  Note: Because the type of data is unknown to OpenAccess, it is unmanaged. This means the contents are not byte-swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaVarDataAppDef_oaVia)\n"
"    Calls: (const oaVarDataAppDef_oaVia&)\n"
"    Signature: oaVarDataAppDef_oaVia||cref-oaVarDataAppDef_oaVia,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVarDataAppDef_oaVia_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVarDataAppDef_oaVia",
    sizeof(PyoaVarDataAppDef_oaViaObject),
    0,
    (destructor)oaVarDataAppDef_oaVia_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVarDataAppDef_oaVia_tp_compare,	/* tp_compare */
    (reprfunc)oaVarDataAppDef_oaVia_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVarDataAppDef_oaVia_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVarDataAppDef_oaVia_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVarDataAppDef_oaVia_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaVia_static_find_doc[] = 
"Class: oaVarDataAppDef_oaVia, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaVia* find(const oaString& name)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaVia|cref-oaString,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaVia* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaVia|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaVarDataAppDef_oaVia_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaViap result= (oaVarDataAppDef_oaVia::find(p1.Data()));
            return PyoaVarDataAppDef_oaVia_FromoaVarDataAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaViap result= (oaVarDataAppDef_oaVia::find(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaVia_FromoaVarDataAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaVia, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaVia_static_get_doc[] = 
"Class: oaVarDataAppDef_oaVia, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaVia* get(const oaString& name)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaVia|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaVia* get(const oaString& name,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaVia|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaVia* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaVia|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaVia* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaVia|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaVia* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaVia|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaVia* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaVia|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
;

static PyObject*
oaVarDataAppDef_oaVia_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaViap result= (oaVarDataAppDef_oaVia::get(p1.Data()));
            return PyoaVarDataAppDef_oaVia_FromoaVarDataAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaVarDataAppDef_oaViap result= (oaVarDataAppDef_oaVia::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaVia_FromoaVarDataAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaVarDataAppDef_oaViap result= (oaVarDataAppDef_oaVia::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaVia_FromoaVarDataAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaViap result= (oaVarDataAppDef_oaVia::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaVia_FromoaVarDataAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaViap result= (oaVarDataAppDef_oaVia::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaVia_FromoaVarDataAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaViap result= (oaVarDataAppDef_oaVia::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaVarDataAppDef_oaVia_FromoaVarDataAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaVia, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaVarDataAppDef_oaVia_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaVarDataAppDef_oaVia_static_find,METH_VARARGS,oaVarDataAppDef_oaVia_static_find_doc},
    {"static_get",(PyCFunction)oaVarDataAppDef_oaVia_static_get,METH_VARARGS,oaVarDataAppDef_oaVia_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVarDataAppDef_oaVia_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVarDataAppDef_oaVia_Type)<0) {
      printf("** PyType_Ready failed for: oaVarDataAppDef_oaVia\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVarDataAppDef_oaVia",
           (PyObject*)(&PyoaVarDataAppDef_oaVia_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVarDataAppDef_oaVia\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaVarDataAppDef_oaVia_Type.tp_dict;
    for(method=oaVarDataAppDef_oaVia_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVarDataAppDef_oaViaDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaViaDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVarDataAppDef_oaViaDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVarDataAppDef_oaViaDefObject* self = (PyoaVarDataAppDef_oaViaDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaVarDataAppDef_oaViaDef)
    {
        PyParamoaVarDataAppDef_oaViaDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVarDataAppDef_oaViaDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVarDataAppDef_oaViaDef, Choices are:\n"
        "    (oaVarDataAppDef_oaViaDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVarDataAppDef_oaViaDef_tp_dealloc(PyoaVarDataAppDef_oaViaDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaViaDef_tp_repr(PyObject *ob)
{
    PyParamoaVarDataAppDef_oaViaDef value;
    int convert_status=PyoaVarDataAppDef_oaViaDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[46];
    sprintf(buffer,"<oaVarDataAppDef_oaViaDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVarDataAppDef_oaViaDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVarDataAppDef_oaViaDef v1;
    PyParamoaVarDataAppDef_oaViaDef v2;
    int convert_status1=PyoaVarDataAppDef_oaViaDef_Convert(ob1,&v1);
    int convert_status2=PyoaVarDataAppDef_oaViaDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVarDataAppDef_oaViaDef_Convert(PyObject* ob,PyParamoaVarDataAppDef_oaViaDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaVarDataAppDef_oaViaDef_Check(ob)) {
        result->SetData( (oaVarDataAppDef_oaViaDef**) ((PyoaVarDataAppDef_oaViaDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVarDataAppDef_oaViaDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaViaDef_FromoaVarDataAppDef_oaViaDef(oaVarDataAppDef_oaViaDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaVarDataAppDef_oaViaDef* data=*value;
        PyObject* bself = PyoaVarDataAppDef_oaViaDef_Type.tp_alloc(&PyoaVarDataAppDef_oaViaDef_Type,0);
        if (bself == NULL) return bself;
        PyoaVarDataAppDef_oaViaDefObject* self = (PyoaVarDataAppDef_oaViaDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaViaDef_FromoaVarDataAppDef_oaViaDef(oaVarDataAppDef_oaViaDef* data)
{
    if (data) {
       PyObject* bself = PyoaVarDataAppDef_oaViaDef_Type.tp_alloc(&PyoaVarDataAppDef_oaViaDef_Type,0);
       if (bself == NULL) return bself;
       PyoaVarDataAppDef_oaViaDefObject* self = (PyoaVarDataAppDef_oaViaDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaDef_get_doc[] = 
"Class: oaVarDataAppDef_oaViaDef, Function: get\n"
"  Paramegers: (oaViaDef,[oaByte])\n"
"    Calls: void get(const oaViaDef* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaViaDef,ptr-oaByte,\n"
"    This function returns the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaViaDef_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaViaDef data;
    int convert_status=PyoaVarDataAppDef_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViaDefObject* self=(PyoaVarDataAppDef_oaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaDef p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViaDef_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize(p1.Data())==p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match object data");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaDef_getDefault_doc[] = 
"Class: oaVarDataAppDef_oaViaDef, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value for this extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to be filled out with the default value\n"
;

static PyObject*
oaVarDataAppDef_oaViaDef_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaViaDef data;
    int convert_status=PyoaVarDataAppDef_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViaDefObject* self=(PyoaVarDataAppDef_oaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getDefaultSize()==p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match default size");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaDef_getDefaultSize_doc[] = 
"Class: oaVarDataAppDef_oaViaDef, Function: getDefaultSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getDefaultSize() const\n"
"    Signature: getDefaultSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the default size for this extension in bytes.\n"
;

static PyObject*
oaVarDataAppDef_oaViaDef_getDefaultSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaViaDef data;
    int convert_status=PyoaVarDataAppDef_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViaDefObject* self=(PyoaVarDataAppDef_oaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getDefaultSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaDef_getSize_doc[] = 
"Class: oaVarDataAppDef_oaViaDef, Function: getSize\n"
"  Paramegers: (oaViaDef)\n"
"    Calls: oaUInt4 getSize(const oaViaDef* object)\n"
"    Signature: getSize|simple-oaUInt4|cptr-oaViaDef,\n"
"    This function returns the size of the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaViaDef_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaViaDef data;
    int convert_status=PyoaVarDataAppDef_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViaDefObject* self=(PyoaVarDataAppDef_oaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaDef p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaViaDef_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (data.DataCall()->getSize(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaDef_set_doc[] = 
"Class: oaVarDataAppDef_oaViaDef, Function: set\n"
"  Paramegers: (oaViaDef,[oaByte])\n"
"    Calls: void set(oaViaDef* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaViaDef,simple-oaUInt4,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaViaDef_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaViaDef data;
    int convert_status=PyoaVarDataAppDef_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViaDefObject* self=(PyoaVarDataAppDef_oaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaDef p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViaDef_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaDef_isNull_doc[] =
"Class: oaVarDataAppDef_oaViaDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaVarDataAppDef_oaViaDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaVarDataAppDef_oaViaDef data;
    int convert_status=PyoaVarDataAppDef_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaVarDataAppDef_oaViaDef_assign_doc[] = 
"Class: oaVarDataAppDef_oaViaDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVarDataAppDef_oaViaDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVarDataAppDef_oaViaDef data;
  int convert_status=PyoaVarDataAppDef_oaViaDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVarDataAppDef_oaViaDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVarDataAppDef_oaViaDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVarDataAppDef_oaViaDef_methodlist[] = {
    {"get",(PyCFunction)oaVarDataAppDef_oaViaDef_get,METH_VARARGS,oaVarDataAppDef_oaViaDef_get_doc},
    {"getDefault",(PyCFunction)oaVarDataAppDef_oaViaDef_getDefault,METH_VARARGS,oaVarDataAppDef_oaViaDef_getDefault_doc},
    {"getDefaultSize",(PyCFunction)oaVarDataAppDef_oaViaDef_getDefaultSize,METH_VARARGS,oaVarDataAppDef_oaViaDef_getDefaultSize_doc},
    {"getSize",(PyCFunction)oaVarDataAppDef_oaViaDef_getSize,METH_VARARGS,oaVarDataAppDef_oaViaDef_getSize_doc},
    {"set",(PyCFunction)oaVarDataAppDef_oaViaDef_set,METH_VARARGS,oaVarDataAppDef_oaViaDef_set_doc},
    {"isNull",(PyCFunction)oaVarDataAppDef_oaViaDef_tp_isNull,METH_VARARGS,oaVarDataAppDef_oaViaDef_isNull_doc},
    {"assign",(PyCFunction)oaVarDataAppDef_oaViaDef_tp_assign,METH_VARARGS,oaVarDataAppDef_oaViaDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaDef_doc[] = 
"Class: oaVarDataAppDef_oaViaDef\n"
"  The oaVarDataAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When the objects are created, a data field is added to each object of the specified dataType. Applications can use the new data field for whatever purpose is necessary.\n"
"  This type of extension is useful because it allows variable-sized data for each object being extended. This is similar to the oaDataAppDef class, but more general because the data size can differ for each object. (There is a minor speed and size penalty for this additional flexibility.) The default value for this extension is zero bytes.\n"
"  Note: Because the type of data is unknown to OpenAccess, it is unmanaged. This means the contents are not byte-swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaVarDataAppDef_oaViaDef)\n"
"    Calls: (const oaVarDataAppDef_oaViaDef&)\n"
"    Signature: oaVarDataAppDef_oaViaDef||cref-oaVarDataAppDef_oaViaDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVarDataAppDef_oaViaDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVarDataAppDef_oaViaDef",
    sizeof(PyoaVarDataAppDef_oaViaDefObject),
    0,
    (destructor)oaVarDataAppDef_oaViaDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVarDataAppDef_oaViaDef_tp_compare,	/* tp_compare */
    (reprfunc)oaVarDataAppDef_oaViaDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVarDataAppDef_oaViaDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVarDataAppDef_oaViaDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVarDataAppDef_oaViaDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaDef_static_find_doc[] = 
"Class: oaVarDataAppDef_oaViaDef, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaViaDef* find(const oaString& name)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaViaDef|cref-oaString,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaViaDef* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaViaDef|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaVarDataAppDef_oaViaDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaViaDefp result= (oaVarDataAppDef_oaViaDef::find(p1.Data()));
            return PyoaVarDataAppDef_oaViaDef_FromoaVarDataAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaViaDefp result= (oaVarDataAppDef_oaViaDef::find(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaViaDef_FromoaVarDataAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaViaDef, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaDef_static_get_doc[] = 
"Class: oaVarDataAppDef_oaViaDef, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaViaDef* get(const oaString& name)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaViaDef|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaViaDef* get(const oaString& name,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaViaDef|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaViaDef* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaViaDef|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaViaDef* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaViaDef|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaViaDef* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaViaDef|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaViaDef* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaViaDef|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
;

static PyObject*
oaVarDataAppDef_oaViaDef_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaViaDefp result= (oaVarDataAppDef_oaViaDef::get(p1.Data()));
            return PyoaVarDataAppDef_oaViaDef_FromoaVarDataAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaVarDataAppDef_oaViaDefp result= (oaVarDataAppDef_oaViaDef::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaViaDef_FromoaVarDataAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaVarDataAppDef_oaViaDefp result= (oaVarDataAppDef_oaViaDef::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaViaDef_FromoaVarDataAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaViaDefp result= (oaVarDataAppDef_oaViaDef::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaViaDef_FromoaVarDataAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaViaDefp result= (oaVarDataAppDef_oaViaDef::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaViaDef_FromoaVarDataAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaViaDefp result= (oaVarDataAppDef_oaViaDef::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaVarDataAppDef_oaViaDef_FromoaVarDataAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaViaDef, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaVarDataAppDef_oaViaDef_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaVarDataAppDef_oaViaDef_static_find,METH_VARARGS,oaVarDataAppDef_oaViaDef_static_find_doc},
    {"static_get",(PyCFunction)oaVarDataAppDef_oaViaDef_static_get,METH_VARARGS,oaVarDataAppDef_oaViaDef_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVarDataAppDef_oaViaDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVarDataAppDef_oaViaDef_Type)<0) {
      printf("** PyType_Ready failed for: oaVarDataAppDef_oaViaDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVarDataAppDef_oaViaDef",
           (PyObject*)(&PyoaVarDataAppDef_oaViaDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVarDataAppDef_oaViaDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaVarDataAppDef_oaViaDef_Type.tp_dict;
    for(method=oaVarDataAppDef_oaViaDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVarDataAppDef_oaViaHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaViaHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVarDataAppDef_oaViaHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVarDataAppDef_oaViaHeaderObject* self = (PyoaVarDataAppDef_oaViaHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaVarDataAppDef_oaViaHeader)
    {
        PyParamoaVarDataAppDef_oaViaHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVarDataAppDef_oaViaHeader_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVarDataAppDef_oaViaHeader, Choices are:\n"
        "    (oaVarDataAppDef_oaViaHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVarDataAppDef_oaViaHeader_tp_dealloc(PyoaVarDataAppDef_oaViaHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaViaHeader_tp_repr(PyObject *ob)
{
    PyParamoaVarDataAppDef_oaViaHeader value;
    int convert_status=PyoaVarDataAppDef_oaViaHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[49];
    sprintf(buffer,"<oaVarDataAppDef_oaViaHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVarDataAppDef_oaViaHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVarDataAppDef_oaViaHeader v1;
    PyParamoaVarDataAppDef_oaViaHeader v2;
    int convert_status1=PyoaVarDataAppDef_oaViaHeader_Convert(ob1,&v1);
    int convert_status2=PyoaVarDataAppDef_oaViaHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVarDataAppDef_oaViaHeader_Convert(PyObject* ob,PyParamoaVarDataAppDef_oaViaHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaVarDataAppDef_oaViaHeader_Check(ob)) {
        result->SetData( (oaVarDataAppDef_oaViaHeader**) ((PyoaVarDataAppDef_oaViaHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVarDataAppDef_oaViaHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaViaHeader_FromoaVarDataAppDef_oaViaHeader(oaVarDataAppDef_oaViaHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaVarDataAppDef_oaViaHeader* data=*value;
        PyObject* bself = PyoaVarDataAppDef_oaViaHeader_Type.tp_alloc(&PyoaVarDataAppDef_oaViaHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaVarDataAppDef_oaViaHeaderObject* self = (PyoaVarDataAppDef_oaViaHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaViaHeader_FromoaVarDataAppDef_oaViaHeader(oaVarDataAppDef_oaViaHeader* data)
{
    if (data) {
       PyObject* bself = PyoaVarDataAppDef_oaViaHeader_Type.tp_alloc(&PyoaVarDataAppDef_oaViaHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaVarDataAppDef_oaViaHeaderObject* self = (PyoaVarDataAppDef_oaViaHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaHeader_get_doc[] = 
"Class: oaVarDataAppDef_oaViaHeader, Function: get\n"
"  Paramegers: (oaViaHeader,[oaByte])\n"
"    Calls: void get(const oaViaHeader* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaViaHeader,ptr-oaByte,\n"
"    This function returns the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaViaHeader_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaViaHeader data;
    int convert_status=PyoaVarDataAppDef_oaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViaHeaderObject* self=(PyoaVarDataAppDef_oaViaHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaHeader p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViaHeader_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize(p1.Data())==p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match object data");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaHeader_getDefault_doc[] = 
"Class: oaVarDataAppDef_oaViaHeader, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value for this extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to be filled out with the default value\n"
;

static PyObject*
oaVarDataAppDef_oaViaHeader_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaViaHeader data;
    int convert_status=PyoaVarDataAppDef_oaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViaHeaderObject* self=(PyoaVarDataAppDef_oaViaHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getDefaultSize()==p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match default size");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaHeader_getDefaultSize_doc[] = 
"Class: oaVarDataAppDef_oaViaHeader, Function: getDefaultSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getDefaultSize() const\n"
"    Signature: getDefaultSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the default size for this extension in bytes.\n"
;

static PyObject*
oaVarDataAppDef_oaViaHeader_getDefaultSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaViaHeader data;
    int convert_status=PyoaVarDataAppDef_oaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViaHeaderObject* self=(PyoaVarDataAppDef_oaViaHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getDefaultSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaHeader_getSize_doc[] = 
"Class: oaVarDataAppDef_oaViaHeader, Function: getSize\n"
"  Paramegers: (oaViaHeader)\n"
"    Calls: oaUInt4 getSize(const oaViaHeader* object)\n"
"    Signature: getSize|simple-oaUInt4|cptr-oaViaHeader,\n"
"    This function returns the size of the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaViaHeader_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaViaHeader data;
    int convert_status=PyoaVarDataAppDef_oaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViaHeaderObject* self=(PyoaVarDataAppDef_oaViaHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaHeader p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaViaHeader_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (data.DataCall()->getSize(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaHeader_set_doc[] = 
"Class: oaVarDataAppDef_oaViaHeader, Function: set\n"
"  Paramegers: (oaViaHeader,[oaByte])\n"
"    Calls: void set(oaViaHeader* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaViaHeader,simple-oaUInt4,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaViaHeader_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaViaHeader data;
    int convert_status=PyoaVarDataAppDef_oaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViaHeaderObject* self=(PyoaVarDataAppDef_oaViaHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaHeader p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViaHeader_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaHeader_isNull_doc[] =
"Class: oaVarDataAppDef_oaViaHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaVarDataAppDef_oaViaHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaVarDataAppDef_oaViaHeader data;
    int convert_status=PyoaVarDataAppDef_oaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaVarDataAppDef_oaViaHeader_assign_doc[] = 
"Class: oaVarDataAppDef_oaViaHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVarDataAppDef_oaViaHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVarDataAppDef_oaViaHeader data;
  int convert_status=PyoaVarDataAppDef_oaViaHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVarDataAppDef_oaViaHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVarDataAppDef_oaViaHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVarDataAppDef_oaViaHeader_methodlist[] = {
    {"get",(PyCFunction)oaVarDataAppDef_oaViaHeader_get,METH_VARARGS,oaVarDataAppDef_oaViaHeader_get_doc},
    {"getDefault",(PyCFunction)oaVarDataAppDef_oaViaHeader_getDefault,METH_VARARGS,oaVarDataAppDef_oaViaHeader_getDefault_doc},
    {"getDefaultSize",(PyCFunction)oaVarDataAppDef_oaViaHeader_getDefaultSize,METH_VARARGS,oaVarDataAppDef_oaViaHeader_getDefaultSize_doc},
    {"getSize",(PyCFunction)oaVarDataAppDef_oaViaHeader_getSize,METH_VARARGS,oaVarDataAppDef_oaViaHeader_getSize_doc},
    {"set",(PyCFunction)oaVarDataAppDef_oaViaHeader_set,METH_VARARGS,oaVarDataAppDef_oaViaHeader_set_doc},
    {"isNull",(PyCFunction)oaVarDataAppDef_oaViaHeader_tp_isNull,METH_VARARGS,oaVarDataAppDef_oaViaHeader_isNull_doc},
    {"assign",(PyCFunction)oaVarDataAppDef_oaViaHeader_tp_assign,METH_VARARGS,oaVarDataAppDef_oaViaHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaHeader_doc[] = 
"Class: oaVarDataAppDef_oaViaHeader\n"
"  The oaVarDataAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When the objects are created, a data field is added to each object of the specified dataType. Applications can use the new data field for whatever purpose is necessary.\n"
"  This type of extension is useful because it allows variable-sized data for each object being extended. This is similar to the oaDataAppDef class, but more general because the data size can differ for each object. (There is a minor speed and size penalty for this additional flexibility.) The default value for this extension is zero bytes.\n"
"  Note: Because the type of data is unknown to OpenAccess, it is unmanaged. This means the contents are not byte-swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaVarDataAppDef_oaViaHeader)\n"
"    Calls: (const oaVarDataAppDef_oaViaHeader&)\n"
"    Signature: oaVarDataAppDef_oaViaHeader||cref-oaVarDataAppDef_oaViaHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVarDataAppDef_oaViaHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVarDataAppDef_oaViaHeader",
    sizeof(PyoaVarDataAppDef_oaViaHeaderObject),
    0,
    (destructor)oaVarDataAppDef_oaViaHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVarDataAppDef_oaViaHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaVarDataAppDef_oaViaHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVarDataAppDef_oaViaHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVarDataAppDef_oaViaHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVarDataAppDef_oaViaHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaHeader_static_find_doc[] = 
"Class: oaVarDataAppDef_oaViaHeader, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaViaHeader* find(const oaString& name)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaViaHeader|cref-oaString,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaViaHeader* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaViaHeader|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaVarDataAppDef_oaViaHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaViaHeaderp result= (oaVarDataAppDef_oaViaHeader::find(p1.Data()));
            return PyoaVarDataAppDef_oaViaHeader_FromoaVarDataAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaViaHeaderp result= (oaVarDataAppDef_oaViaHeader::find(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaViaHeader_FromoaVarDataAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaViaHeader, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaHeader_static_get_doc[] = 
"Class: oaVarDataAppDef_oaViaHeader, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaViaHeader* get(const oaString& name)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaViaHeader|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaViaHeader* get(const oaString& name,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaViaHeader|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaViaHeader* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaViaHeader|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaViaHeader* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaViaHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaViaHeader* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaViaHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaViaHeader* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaViaHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
;

static PyObject*
oaVarDataAppDef_oaViaHeader_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaViaHeaderp result= (oaVarDataAppDef_oaViaHeader::get(p1.Data()));
            return PyoaVarDataAppDef_oaViaHeader_FromoaVarDataAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaVarDataAppDef_oaViaHeaderp result= (oaVarDataAppDef_oaViaHeader::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaViaHeader_FromoaVarDataAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaVarDataAppDef_oaViaHeaderp result= (oaVarDataAppDef_oaViaHeader::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaViaHeader_FromoaVarDataAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaViaHeaderp result= (oaVarDataAppDef_oaViaHeader::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaViaHeader_FromoaVarDataAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaViaHeaderp result= (oaVarDataAppDef_oaViaHeader::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaViaHeader_FromoaVarDataAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaViaHeaderp result= (oaVarDataAppDef_oaViaHeader::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaVarDataAppDef_oaViaHeader_FromoaVarDataAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaViaHeader, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaVarDataAppDef_oaViaHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaVarDataAppDef_oaViaHeader_static_find,METH_VARARGS,oaVarDataAppDef_oaViaHeader_static_find_doc},
    {"static_get",(PyCFunction)oaVarDataAppDef_oaViaHeader_static_get,METH_VARARGS,oaVarDataAppDef_oaViaHeader_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVarDataAppDef_oaViaHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVarDataAppDef_oaViaHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaVarDataAppDef_oaViaHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVarDataAppDef_oaViaHeader",
           (PyObject*)(&PyoaVarDataAppDef_oaViaHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVarDataAppDef_oaViaHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaVarDataAppDef_oaViaHeader_Type.tp_dict;
    for(method=oaVarDataAppDef_oaViaHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVarDataAppDef_oaViaSpec
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaViaSpec_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVarDataAppDef_oaViaSpec_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVarDataAppDef_oaViaSpecObject* self = (PyoaVarDataAppDef_oaViaSpecObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaVarDataAppDef_oaViaSpec)
    {
        PyParamoaVarDataAppDef_oaViaSpec p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVarDataAppDef_oaViaSpec_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVarDataAppDef_oaViaSpec, Choices are:\n"
        "    (oaVarDataAppDef_oaViaSpec)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVarDataAppDef_oaViaSpec_tp_dealloc(PyoaVarDataAppDef_oaViaSpecObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaViaSpec_tp_repr(PyObject *ob)
{
    PyParamoaVarDataAppDef_oaViaSpec value;
    int convert_status=PyoaVarDataAppDef_oaViaSpec_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[47];
    sprintf(buffer,"<oaVarDataAppDef_oaViaSpec::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVarDataAppDef_oaViaSpec_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVarDataAppDef_oaViaSpec v1;
    PyParamoaVarDataAppDef_oaViaSpec v2;
    int convert_status1=PyoaVarDataAppDef_oaViaSpec_Convert(ob1,&v1);
    int convert_status2=PyoaVarDataAppDef_oaViaSpec_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVarDataAppDef_oaViaSpec_Convert(PyObject* ob,PyParamoaVarDataAppDef_oaViaSpec* result)
{
    if (ob == NULL) return 1;
    if (PyoaVarDataAppDef_oaViaSpec_Check(ob)) {
        result->SetData( (oaVarDataAppDef_oaViaSpec**) ((PyoaVarDataAppDef_oaViaSpecObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVarDataAppDef_oaViaSpec Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaViaSpec_FromoaVarDataAppDef_oaViaSpec(oaVarDataAppDef_oaViaSpec** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaVarDataAppDef_oaViaSpec* data=*value;
        PyObject* bself = PyoaVarDataAppDef_oaViaSpec_Type.tp_alloc(&PyoaVarDataAppDef_oaViaSpec_Type,0);
        if (bself == NULL) return bself;
        PyoaVarDataAppDef_oaViaSpecObject* self = (PyoaVarDataAppDef_oaViaSpecObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaViaSpec_FromoaVarDataAppDef_oaViaSpec(oaVarDataAppDef_oaViaSpec* data)
{
    if (data) {
       PyObject* bself = PyoaVarDataAppDef_oaViaSpec_Type.tp_alloc(&PyoaVarDataAppDef_oaViaSpec_Type,0);
       if (bself == NULL) return bself;
       PyoaVarDataAppDef_oaViaSpecObject* self = (PyoaVarDataAppDef_oaViaSpecObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaSpec_get_doc[] = 
"Class: oaVarDataAppDef_oaViaSpec, Function: get\n"
"  Paramegers: (oaViaSpec,[oaByte])\n"
"    Calls: void get(const oaViaSpec* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaViaSpec,ptr-oaByte,\n"
"    This function returns the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaViaSpec_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaViaSpec data;
    int convert_status=PyoaVarDataAppDef_oaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViaSpecObject* self=(PyoaVarDataAppDef_oaViaSpecObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaSpec p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViaSpec_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize(p1.Data())==p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match object data");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaSpec_getDefault_doc[] = 
"Class: oaVarDataAppDef_oaViaSpec, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value for this extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to be filled out with the default value\n"
;

static PyObject*
oaVarDataAppDef_oaViaSpec_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaViaSpec data;
    int convert_status=PyoaVarDataAppDef_oaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViaSpecObject* self=(PyoaVarDataAppDef_oaViaSpecObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getDefaultSize()==p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match default size");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaSpec_getDefaultSize_doc[] = 
"Class: oaVarDataAppDef_oaViaSpec, Function: getDefaultSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getDefaultSize() const\n"
"    Signature: getDefaultSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the default size for this extension in bytes.\n"
;

static PyObject*
oaVarDataAppDef_oaViaSpec_getDefaultSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaViaSpec data;
    int convert_status=PyoaVarDataAppDef_oaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViaSpecObject* self=(PyoaVarDataAppDef_oaViaSpecObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getDefaultSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaSpec_getSize_doc[] = 
"Class: oaVarDataAppDef_oaViaSpec, Function: getSize\n"
"  Paramegers: (oaViaSpec)\n"
"    Calls: oaUInt4 getSize(const oaViaSpec* object)\n"
"    Signature: getSize|simple-oaUInt4|cptr-oaViaSpec,\n"
"    This function returns the size of the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaViaSpec_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaViaSpec data;
    int convert_status=PyoaVarDataAppDef_oaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViaSpecObject* self=(PyoaVarDataAppDef_oaViaSpecObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaSpec p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaViaSpec_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (data.DataCall()->getSize(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaSpec_set_doc[] = 
"Class: oaVarDataAppDef_oaViaSpec, Function: set\n"
"  Paramegers: (oaViaSpec,[oaByte])\n"
"    Calls: void set(oaViaSpec* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaViaSpec,simple-oaUInt4,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaViaSpec_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaViaSpec data;
    int convert_status=PyoaVarDataAppDef_oaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViaSpecObject* self=(PyoaVarDataAppDef_oaViaSpecObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaSpec p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViaSpec_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaSpec_isNull_doc[] =
"Class: oaVarDataAppDef_oaViaSpec, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaVarDataAppDef_oaViaSpec_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaVarDataAppDef_oaViaSpec data;
    int convert_status=PyoaVarDataAppDef_oaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaVarDataAppDef_oaViaSpec_assign_doc[] = 
"Class: oaVarDataAppDef_oaViaSpec, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVarDataAppDef_oaViaSpec_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVarDataAppDef_oaViaSpec data;
  int convert_status=PyoaVarDataAppDef_oaViaSpec_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVarDataAppDef_oaViaSpec p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVarDataAppDef_oaViaSpec_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVarDataAppDef_oaViaSpec_methodlist[] = {
    {"get",(PyCFunction)oaVarDataAppDef_oaViaSpec_get,METH_VARARGS,oaVarDataAppDef_oaViaSpec_get_doc},
    {"getDefault",(PyCFunction)oaVarDataAppDef_oaViaSpec_getDefault,METH_VARARGS,oaVarDataAppDef_oaViaSpec_getDefault_doc},
    {"getDefaultSize",(PyCFunction)oaVarDataAppDef_oaViaSpec_getDefaultSize,METH_VARARGS,oaVarDataAppDef_oaViaSpec_getDefaultSize_doc},
    {"getSize",(PyCFunction)oaVarDataAppDef_oaViaSpec_getSize,METH_VARARGS,oaVarDataAppDef_oaViaSpec_getSize_doc},
    {"set",(PyCFunction)oaVarDataAppDef_oaViaSpec_set,METH_VARARGS,oaVarDataAppDef_oaViaSpec_set_doc},
    {"isNull",(PyCFunction)oaVarDataAppDef_oaViaSpec_tp_isNull,METH_VARARGS,oaVarDataAppDef_oaViaSpec_isNull_doc},
    {"assign",(PyCFunction)oaVarDataAppDef_oaViaSpec_tp_assign,METH_VARARGS,oaVarDataAppDef_oaViaSpec_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaSpec_doc[] = 
"Class: oaVarDataAppDef_oaViaSpec\n"
"  The oaVarDataAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When the objects are created, a data field is added to each object of the specified dataType. Applications can use the new data field for whatever purpose is necessary.\n"
"  This type of extension is useful because it allows variable-sized data for each object being extended. This is similar to the oaDataAppDef class, but more general because the data size can differ for each object. (There is a minor speed and size penalty for this additional flexibility.) The default value for this extension is zero bytes.\n"
"  Note: Because the type of data is unknown to OpenAccess, it is unmanaged. This means the contents are not byte-swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaVarDataAppDef_oaViaSpec)\n"
"    Calls: (const oaVarDataAppDef_oaViaSpec&)\n"
"    Signature: oaVarDataAppDef_oaViaSpec||cref-oaVarDataAppDef_oaViaSpec,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVarDataAppDef_oaViaSpec_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVarDataAppDef_oaViaSpec",
    sizeof(PyoaVarDataAppDef_oaViaSpecObject),
    0,
    (destructor)oaVarDataAppDef_oaViaSpec_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVarDataAppDef_oaViaSpec_tp_compare,	/* tp_compare */
    (reprfunc)oaVarDataAppDef_oaViaSpec_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVarDataAppDef_oaViaSpec_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVarDataAppDef_oaViaSpec_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVarDataAppDef_oaViaSpec_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaSpec_static_find_doc[] = 
"Class: oaVarDataAppDef_oaViaSpec, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaViaSpec* find(const oaString& name)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaViaSpec|cref-oaString,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaViaSpec* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaViaSpec|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaVarDataAppDef_oaViaSpec_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaViaSpecp result= (oaVarDataAppDef_oaViaSpec::find(p1.Data()));
            return PyoaVarDataAppDef_oaViaSpec_FromoaVarDataAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaViaSpecp result= (oaVarDataAppDef_oaViaSpec::find(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaViaSpec_FromoaVarDataAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaViaSpec, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaViaSpec_static_get_doc[] = 
"Class: oaVarDataAppDef_oaViaSpec, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaViaSpec* get(const oaString& name)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaViaSpec|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaViaSpec* get(const oaString& name,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaViaSpec|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaViaSpec* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaViaSpec|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaViaSpec* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaViaSpec|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaViaSpec* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaViaSpec|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaViaSpec* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaViaSpec|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
;

static PyObject*
oaVarDataAppDef_oaViaSpec_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaViaSpecp result= (oaVarDataAppDef_oaViaSpec::get(p1.Data()));
            return PyoaVarDataAppDef_oaViaSpec_FromoaVarDataAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaVarDataAppDef_oaViaSpecp result= (oaVarDataAppDef_oaViaSpec::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaViaSpec_FromoaVarDataAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaVarDataAppDef_oaViaSpecp result= (oaVarDataAppDef_oaViaSpec::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaViaSpec_FromoaVarDataAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaViaSpecp result= (oaVarDataAppDef_oaViaSpec::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaViaSpec_FromoaVarDataAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaViaSpecp result= (oaVarDataAppDef_oaViaSpec::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaViaSpec_FromoaVarDataAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaViaSpecp result= (oaVarDataAppDef_oaViaSpec::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaVarDataAppDef_oaViaSpec_FromoaVarDataAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaViaSpec, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaVarDataAppDef_oaViaSpec_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaVarDataAppDef_oaViaSpec_static_find,METH_VARARGS,oaVarDataAppDef_oaViaSpec_static_find_doc},
    {"static_get",(PyCFunction)oaVarDataAppDef_oaViaSpec_static_get,METH_VARARGS,oaVarDataAppDef_oaViaSpec_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVarDataAppDef_oaViaSpec_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVarDataAppDef_oaViaSpec_Type)<0) {
      printf("** PyType_Ready failed for: oaVarDataAppDef_oaViaSpec\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVarDataAppDef_oaViaSpec",
           (PyObject*)(&PyoaVarDataAppDef_oaViaSpec_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVarDataAppDef_oaViaSpec\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaVarDataAppDef_oaViaSpec_Type.tp_dict;
    for(method=oaVarDataAppDef_oaViaSpec_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVarDataAppDef_oaView
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaView_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVarDataAppDef_oaView_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVarDataAppDef_oaViewObject* self = (PyoaVarDataAppDef_oaViewObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaVarDataAppDef_oaView)
    {
        PyParamoaVarDataAppDef_oaView p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVarDataAppDef_oaView_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVarDataAppDef_oaView, Choices are:\n"
        "    (oaVarDataAppDef_oaView)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVarDataAppDef_oaView_tp_dealloc(PyoaVarDataAppDef_oaViewObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaView_tp_repr(PyObject *ob)
{
    PyParamoaVarDataAppDef_oaView value;
    int convert_status=PyoaVarDataAppDef_oaView_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[44];
    sprintf(buffer,"<oaVarDataAppDef_oaView::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVarDataAppDef_oaView_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVarDataAppDef_oaView v1;
    PyParamoaVarDataAppDef_oaView v2;
    int convert_status1=PyoaVarDataAppDef_oaView_Convert(ob1,&v1);
    int convert_status2=PyoaVarDataAppDef_oaView_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVarDataAppDef_oaView_Convert(PyObject* ob,PyParamoaVarDataAppDef_oaView* result)
{
    if (ob == NULL) return 1;
    if (PyoaVarDataAppDef_oaView_Check(ob)) {
        result->SetData( (oaVarDataAppDef_oaView**) ((PyoaVarDataAppDef_oaViewObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVarDataAppDef_oaView Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaView_FromoaVarDataAppDef_oaView(oaVarDataAppDef_oaView** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaVarDataAppDef_oaView* data=*value;
        PyObject* bself = PyoaVarDataAppDef_oaView_Type.tp_alloc(&PyoaVarDataAppDef_oaView_Type,0);
        if (bself == NULL) return bself;
        PyoaVarDataAppDef_oaViewObject* self = (PyoaVarDataAppDef_oaViewObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaView_FromoaVarDataAppDef_oaView(oaVarDataAppDef_oaView* data)
{
    if (data) {
       PyObject* bself = PyoaVarDataAppDef_oaView_Type.tp_alloc(&PyoaVarDataAppDef_oaView_Type,0);
       if (bself == NULL) return bself;
       PyoaVarDataAppDef_oaViewObject* self = (PyoaVarDataAppDef_oaViewObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaView_get_doc[] = 
"Class: oaVarDataAppDef_oaView, Function: get\n"
"  Paramegers: (oaView,[oaByte])\n"
"    Calls: void get(const oaView* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaView,ptr-oaByte,\n"
"    This function returns the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaView_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaView data;
    int convert_status=PyoaVarDataAppDef_oaView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViewObject* self=(PyoaVarDataAppDef_oaViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaView p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaView_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize(p1.Data())==p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match object data");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaView_getDefault_doc[] = 
"Class: oaVarDataAppDef_oaView, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value for this extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to be filled out with the default value\n"
;

static PyObject*
oaVarDataAppDef_oaView_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaView data;
    int convert_status=PyoaVarDataAppDef_oaView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViewObject* self=(PyoaVarDataAppDef_oaViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getDefaultSize()==p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match default size");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaView_getDefaultSize_doc[] = 
"Class: oaVarDataAppDef_oaView, Function: getDefaultSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getDefaultSize() const\n"
"    Signature: getDefaultSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the default size for this extension in bytes.\n"
;

static PyObject*
oaVarDataAppDef_oaView_getDefaultSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaView data;
    int convert_status=PyoaVarDataAppDef_oaView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViewObject* self=(PyoaVarDataAppDef_oaViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getDefaultSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaView_getSize_doc[] = 
"Class: oaVarDataAppDef_oaView, Function: getSize\n"
"  Paramegers: (oaView)\n"
"    Calls: oaUInt4 getSize(const oaView* object)\n"
"    Signature: getSize|simple-oaUInt4|cptr-oaView,\n"
"    This function returns the size of the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaView_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaView data;
    int convert_status=PyoaVarDataAppDef_oaView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViewObject* self=(PyoaVarDataAppDef_oaViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaView p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaView_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (data.DataCall()->getSize(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaView_set_doc[] = 
"Class: oaVarDataAppDef_oaView, Function: set\n"
"  Paramegers: (oaView,[oaByte])\n"
"    Calls: void set(oaView* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaView,simple-oaUInt4,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaView_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaView data;
    int convert_status=PyoaVarDataAppDef_oaView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaViewObject* self=(PyoaVarDataAppDef_oaViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaView p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaView_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaView_isNull_doc[] =
"Class: oaVarDataAppDef_oaView, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaVarDataAppDef_oaView_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaVarDataAppDef_oaView data;
    int convert_status=PyoaVarDataAppDef_oaView_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaVarDataAppDef_oaView_assign_doc[] = 
"Class: oaVarDataAppDef_oaView, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVarDataAppDef_oaView_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVarDataAppDef_oaView data;
  int convert_status=PyoaVarDataAppDef_oaView_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVarDataAppDef_oaView p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVarDataAppDef_oaView_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVarDataAppDef_oaView_methodlist[] = {
    {"get",(PyCFunction)oaVarDataAppDef_oaView_get,METH_VARARGS,oaVarDataAppDef_oaView_get_doc},
    {"getDefault",(PyCFunction)oaVarDataAppDef_oaView_getDefault,METH_VARARGS,oaVarDataAppDef_oaView_getDefault_doc},
    {"getDefaultSize",(PyCFunction)oaVarDataAppDef_oaView_getDefaultSize,METH_VARARGS,oaVarDataAppDef_oaView_getDefaultSize_doc},
    {"getSize",(PyCFunction)oaVarDataAppDef_oaView_getSize,METH_VARARGS,oaVarDataAppDef_oaView_getSize_doc},
    {"set",(PyCFunction)oaVarDataAppDef_oaView_set,METH_VARARGS,oaVarDataAppDef_oaView_set_doc},
    {"isNull",(PyCFunction)oaVarDataAppDef_oaView_tp_isNull,METH_VARARGS,oaVarDataAppDef_oaView_isNull_doc},
    {"assign",(PyCFunction)oaVarDataAppDef_oaView_tp_assign,METH_VARARGS,oaVarDataAppDef_oaView_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaView_doc[] = 
"Class: oaVarDataAppDef_oaView\n"
"  The oaVarDataAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When the objects are created, a data field is added to each object of the specified dataType. Applications can use the new data field for whatever purpose is necessary.\n"
"  This type of extension is useful because it allows variable-sized data for each object being extended. This is similar to the oaDataAppDef class, but more general because the data size can differ for each object. (There is a minor speed and size penalty for this additional flexibility.) The default value for this extension is zero bytes.\n"
"  Note: Because the type of data is unknown to OpenAccess, it is unmanaged. This means the contents are not byte-swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaVarDataAppDef_oaView)\n"
"    Calls: (const oaVarDataAppDef_oaView&)\n"
"    Signature: oaVarDataAppDef_oaView||cref-oaVarDataAppDef_oaView,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVarDataAppDef_oaView_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVarDataAppDef_oaView",
    sizeof(PyoaVarDataAppDef_oaViewObject),
    0,
    (destructor)oaVarDataAppDef_oaView_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVarDataAppDef_oaView_tp_compare,	/* tp_compare */
    (reprfunc)oaVarDataAppDef_oaView_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVarDataAppDef_oaView_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVarDataAppDef_oaView_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVarDataAppDef_oaView_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaView_static_find_doc[] = 
"Class: oaVarDataAppDef_oaView, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaView* find(const oaString& name)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaView|cref-oaString,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaView* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaView|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaVarDataAppDef_oaView_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaViewp result= (oaVarDataAppDef_oaView::find(p1.Data()));
            return PyoaVarDataAppDef_oaView_FromoaVarDataAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaViewp result= (oaVarDataAppDef_oaView::find(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaView_FromoaVarDataAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaView, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaView_static_get_doc[] = 
"Class: oaVarDataAppDef_oaView, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaView* get(const oaString& name)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaView|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaView* get(const oaString& name,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaView|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaView* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaView|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaView* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaView|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaView* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaView|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaView* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaView|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
;

static PyObject*
oaVarDataAppDef_oaView_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaViewp result= (oaVarDataAppDef_oaView::get(p1.Data()));
            return PyoaVarDataAppDef_oaView_FromoaVarDataAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaVarDataAppDef_oaViewp result= (oaVarDataAppDef_oaView::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaView_FromoaVarDataAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaVarDataAppDef_oaViewp result= (oaVarDataAppDef_oaView::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaView_FromoaVarDataAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaViewp result= (oaVarDataAppDef_oaView::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaView_FromoaVarDataAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaViewp result= (oaVarDataAppDef_oaView::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaView_FromoaVarDataAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaViewp result= (oaVarDataAppDef_oaView::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaVarDataAppDef_oaView_FromoaVarDataAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaView, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaVarDataAppDef_oaView_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaVarDataAppDef_oaView_static_find,METH_VARARGS,oaVarDataAppDef_oaView_static_find_doc},
    {"static_get",(PyCFunction)oaVarDataAppDef_oaView_static_get,METH_VARARGS,oaVarDataAppDef_oaView_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVarDataAppDef_oaView_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVarDataAppDef_oaView_Type)<0) {
      printf("** PyType_Ready failed for: oaVarDataAppDef_oaView\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVarDataAppDef_oaView",
           (PyObject*)(&PyoaVarDataAppDef_oaView_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVarDataAppDef_oaView\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaVarDataAppDef_oaView_Type.tp_dict;
    for(method=oaVarDataAppDef_oaView_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVarDataAppDef_oaWafer
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaWafer_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVarDataAppDef_oaWafer_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVarDataAppDef_oaWaferObject* self = (PyoaVarDataAppDef_oaWaferObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaVarDataAppDef_oaWafer)
    {
        PyParamoaVarDataAppDef_oaWafer p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVarDataAppDef_oaWafer_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVarDataAppDef_oaWafer, Choices are:\n"
        "    (oaVarDataAppDef_oaWafer)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVarDataAppDef_oaWafer_tp_dealloc(PyoaVarDataAppDef_oaWaferObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaWafer_tp_repr(PyObject *ob)
{
    PyParamoaVarDataAppDef_oaWafer value;
    int convert_status=PyoaVarDataAppDef_oaWafer_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[45];
    sprintf(buffer,"<oaVarDataAppDef_oaWafer::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVarDataAppDef_oaWafer_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVarDataAppDef_oaWafer v1;
    PyParamoaVarDataAppDef_oaWafer v2;
    int convert_status1=PyoaVarDataAppDef_oaWafer_Convert(ob1,&v1);
    int convert_status2=PyoaVarDataAppDef_oaWafer_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVarDataAppDef_oaWafer_Convert(PyObject* ob,PyParamoaVarDataAppDef_oaWafer* result)
{
    if (ob == NULL) return 1;
    if (PyoaVarDataAppDef_oaWafer_Check(ob)) {
        result->SetData( (oaVarDataAppDef_oaWafer**) ((PyoaVarDataAppDef_oaWaferObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVarDataAppDef_oaWafer Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaWafer_FromoaVarDataAppDef_oaWafer(oaVarDataAppDef_oaWafer** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaVarDataAppDef_oaWafer* data=*value;
        PyObject* bself = PyoaVarDataAppDef_oaWafer_Type.tp_alloc(&PyoaVarDataAppDef_oaWafer_Type,0);
        if (bself == NULL) return bself;
        PyoaVarDataAppDef_oaWaferObject* self = (PyoaVarDataAppDef_oaWaferObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaWafer_FromoaVarDataAppDef_oaWafer(oaVarDataAppDef_oaWafer* data)
{
    if (data) {
       PyObject* bself = PyoaVarDataAppDef_oaWafer_Type.tp_alloc(&PyoaVarDataAppDef_oaWafer_Type,0);
       if (bself == NULL) return bself;
       PyoaVarDataAppDef_oaWaferObject* self = (PyoaVarDataAppDef_oaWaferObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWafer_get_doc[] = 
"Class: oaVarDataAppDef_oaWafer, Function: get\n"
"  Paramegers: (oaWafer,[oaByte])\n"
"    Calls: void get(const oaWafer* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaWafer,ptr-oaByte,\n"
"    This function returns the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaWafer_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaWafer data;
    int convert_status=PyoaVarDataAppDef_oaWafer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaWaferObject* self=(PyoaVarDataAppDef_oaWaferObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWafer p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaWafer_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize(p1.Data())==p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match object data");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWafer_getDefault_doc[] = 
"Class: oaVarDataAppDef_oaWafer, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value for this extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to be filled out with the default value\n"
;

static PyObject*
oaVarDataAppDef_oaWafer_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaWafer data;
    int convert_status=PyoaVarDataAppDef_oaWafer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaWaferObject* self=(PyoaVarDataAppDef_oaWaferObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getDefaultSize()==p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match default size");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWafer_getDefaultSize_doc[] = 
"Class: oaVarDataAppDef_oaWafer, Function: getDefaultSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getDefaultSize() const\n"
"    Signature: getDefaultSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the default size for this extension in bytes.\n"
;

static PyObject*
oaVarDataAppDef_oaWafer_getDefaultSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaWafer data;
    int convert_status=PyoaVarDataAppDef_oaWafer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaWaferObject* self=(PyoaVarDataAppDef_oaWaferObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getDefaultSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWafer_getSize_doc[] = 
"Class: oaVarDataAppDef_oaWafer, Function: getSize\n"
"  Paramegers: (oaWafer)\n"
"    Calls: oaUInt4 getSize(const oaWafer* object)\n"
"    Signature: getSize|simple-oaUInt4|cptr-oaWafer,\n"
"    This function returns the size of the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaWafer_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaWafer data;
    int convert_status=PyoaVarDataAppDef_oaWafer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaWaferObject* self=(PyoaVarDataAppDef_oaWaferObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWafer p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaWafer_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (data.DataCall()->getSize(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWafer_set_doc[] = 
"Class: oaVarDataAppDef_oaWafer, Function: set\n"
"  Paramegers: (oaWafer,[oaByte])\n"
"    Calls: void set(oaWafer* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaWafer,simple-oaUInt4,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaWafer_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaWafer data;
    int convert_status=PyoaVarDataAppDef_oaWafer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaWaferObject* self=(PyoaVarDataAppDef_oaWaferObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWafer p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaWafer_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWafer_isNull_doc[] =
"Class: oaVarDataAppDef_oaWafer, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaVarDataAppDef_oaWafer_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaVarDataAppDef_oaWafer data;
    int convert_status=PyoaVarDataAppDef_oaWafer_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaVarDataAppDef_oaWafer_assign_doc[] = 
"Class: oaVarDataAppDef_oaWafer, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVarDataAppDef_oaWafer_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVarDataAppDef_oaWafer data;
  int convert_status=PyoaVarDataAppDef_oaWafer_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVarDataAppDef_oaWafer p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVarDataAppDef_oaWafer_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVarDataAppDef_oaWafer_methodlist[] = {
    {"get",(PyCFunction)oaVarDataAppDef_oaWafer_get,METH_VARARGS,oaVarDataAppDef_oaWafer_get_doc},
    {"getDefault",(PyCFunction)oaVarDataAppDef_oaWafer_getDefault,METH_VARARGS,oaVarDataAppDef_oaWafer_getDefault_doc},
    {"getDefaultSize",(PyCFunction)oaVarDataAppDef_oaWafer_getDefaultSize,METH_VARARGS,oaVarDataAppDef_oaWafer_getDefaultSize_doc},
    {"getSize",(PyCFunction)oaVarDataAppDef_oaWafer_getSize,METH_VARARGS,oaVarDataAppDef_oaWafer_getSize_doc},
    {"set",(PyCFunction)oaVarDataAppDef_oaWafer_set,METH_VARARGS,oaVarDataAppDef_oaWafer_set_doc},
    {"isNull",(PyCFunction)oaVarDataAppDef_oaWafer_tp_isNull,METH_VARARGS,oaVarDataAppDef_oaWafer_isNull_doc},
    {"assign",(PyCFunction)oaVarDataAppDef_oaWafer_tp_assign,METH_VARARGS,oaVarDataAppDef_oaWafer_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWafer_doc[] = 
"Class: oaVarDataAppDef_oaWafer\n"
"  The oaVarDataAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When the objects are created, a data field is added to each object of the specified dataType. Applications can use the new data field for whatever purpose is necessary.\n"
"  This type of extension is useful because it allows variable-sized data for each object being extended. This is similar to the oaDataAppDef class, but more general because the data size can differ for each object. (There is a minor speed and size penalty for this additional flexibility.) The default value for this extension is zero bytes.\n"
"  Note: Because the type of data is unknown to OpenAccess, it is unmanaged. This means the contents are not byte-swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaVarDataAppDef_oaWafer)\n"
"    Calls: (const oaVarDataAppDef_oaWafer&)\n"
"    Signature: oaVarDataAppDef_oaWafer||cref-oaVarDataAppDef_oaWafer,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVarDataAppDef_oaWafer_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVarDataAppDef_oaWafer",
    sizeof(PyoaVarDataAppDef_oaWaferObject),
    0,
    (destructor)oaVarDataAppDef_oaWafer_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVarDataAppDef_oaWafer_tp_compare,	/* tp_compare */
    (reprfunc)oaVarDataAppDef_oaWafer_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVarDataAppDef_oaWafer_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVarDataAppDef_oaWafer_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVarDataAppDef_oaWafer_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWafer_static_find_doc[] = 
"Class: oaVarDataAppDef_oaWafer, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaWafer* find(const oaString& name)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaWafer|cref-oaString,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaWafer* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaWafer|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaVarDataAppDef_oaWafer_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaWaferp result= (oaVarDataAppDef_oaWafer::find(p1.Data()));
            return PyoaVarDataAppDef_oaWafer_FromoaVarDataAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaWaferp result= (oaVarDataAppDef_oaWafer::find(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaWafer_FromoaVarDataAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaWafer, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWafer_static_get_doc[] = 
"Class: oaVarDataAppDef_oaWafer, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaWafer* get(const oaString& name)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaWafer|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaWafer* get(const oaString& name,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaWafer|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaWafer* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaWafer|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaWafer* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaWafer|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaWafer* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaWafer|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaWafer* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaWafer|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
;

static PyObject*
oaVarDataAppDef_oaWafer_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaWaferp result= (oaVarDataAppDef_oaWafer::get(p1.Data()));
            return PyoaVarDataAppDef_oaWafer_FromoaVarDataAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaVarDataAppDef_oaWaferp result= (oaVarDataAppDef_oaWafer::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaWafer_FromoaVarDataAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaVarDataAppDef_oaWaferp result= (oaVarDataAppDef_oaWafer::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaWafer_FromoaVarDataAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaWaferp result= (oaVarDataAppDef_oaWafer::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaWafer_FromoaVarDataAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaWaferp result= (oaVarDataAppDef_oaWafer::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaWafer_FromoaVarDataAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaWaferp result= (oaVarDataAppDef_oaWafer::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaVarDataAppDef_oaWafer_FromoaVarDataAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaWafer, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaVarDataAppDef_oaWafer_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaVarDataAppDef_oaWafer_static_find,METH_VARARGS,oaVarDataAppDef_oaWafer_static_find_doc},
    {"static_get",(PyCFunction)oaVarDataAppDef_oaWafer_static_get,METH_VARARGS,oaVarDataAppDef_oaWafer_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVarDataAppDef_oaWafer_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVarDataAppDef_oaWafer_Type)<0) {
      printf("** PyType_Ready failed for: oaVarDataAppDef_oaWafer\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVarDataAppDef_oaWafer",
           (PyObject*)(&PyoaVarDataAppDef_oaWafer_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVarDataAppDef_oaWafer\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaVarDataAppDef_oaWafer_Type.tp_dict;
    for(method=oaVarDataAppDef_oaWafer_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVarDataAppDef_oaWaferDesc
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaWaferDesc_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVarDataAppDef_oaWaferDesc_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVarDataAppDef_oaWaferDescObject* self = (PyoaVarDataAppDef_oaWaferDescObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaVarDataAppDef_oaWaferDesc)
    {
        PyParamoaVarDataAppDef_oaWaferDesc p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVarDataAppDef_oaWaferDesc_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVarDataAppDef_oaWaferDesc, Choices are:\n"
        "    (oaVarDataAppDef_oaWaferDesc)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVarDataAppDef_oaWaferDesc_tp_dealloc(PyoaVarDataAppDef_oaWaferDescObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaWaferDesc_tp_repr(PyObject *ob)
{
    PyParamoaVarDataAppDef_oaWaferDesc value;
    int convert_status=PyoaVarDataAppDef_oaWaferDesc_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[49];
    sprintf(buffer,"<oaVarDataAppDef_oaWaferDesc::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVarDataAppDef_oaWaferDesc_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVarDataAppDef_oaWaferDesc v1;
    PyParamoaVarDataAppDef_oaWaferDesc v2;
    int convert_status1=PyoaVarDataAppDef_oaWaferDesc_Convert(ob1,&v1);
    int convert_status2=PyoaVarDataAppDef_oaWaferDesc_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVarDataAppDef_oaWaferDesc_Convert(PyObject* ob,PyParamoaVarDataAppDef_oaWaferDesc* result)
{
    if (ob == NULL) return 1;
    if (PyoaVarDataAppDef_oaWaferDesc_Check(ob)) {
        result->SetData( (oaVarDataAppDef_oaWaferDesc**) ((PyoaVarDataAppDef_oaWaferDescObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVarDataAppDef_oaWaferDesc Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaWaferDesc_FromoaVarDataAppDef_oaWaferDesc(oaVarDataAppDef_oaWaferDesc** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaVarDataAppDef_oaWaferDesc* data=*value;
        PyObject* bself = PyoaVarDataAppDef_oaWaferDesc_Type.tp_alloc(&PyoaVarDataAppDef_oaWaferDesc_Type,0);
        if (bself == NULL) return bself;
        PyoaVarDataAppDef_oaWaferDescObject* self = (PyoaVarDataAppDef_oaWaferDescObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaWaferDesc_FromoaVarDataAppDef_oaWaferDesc(oaVarDataAppDef_oaWaferDesc* data)
{
    if (data) {
       PyObject* bself = PyoaVarDataAppDef_oaWaferDesc_Type.tp_alloc(&PyoaVarDataAppDef_oaWaferDesc_Type,0);
       if (bself == NULL) return bself;
       PyoaVarDataAppDef_oaWaferDescObject* self = (PyoaVarDataAppDef_oaWaferDescObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWaferDesc_get_doc[] = 
"Class: oaVarDataAppDef_oaWaferDesc, Function: get\n"
"  Paramegers: (oaWaferDesc,[oaByte])\n"
"    Calls: void get(const oaWaferDesc* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaWaferDesc,ptr-oaByte,\n"
"    This function returns the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaWaferDesc_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaWaferDesc data;
    int convert_status=PyoaVarDataAppDef_oaWaferDesc_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaWaferDescObject* self=(PyoaVarDataAppDef_oaWaferDescObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWaferDesc p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaWaferDesc_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize(p1.Data())==p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match object data");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWaferDesc_getDefault_doc[] = 
"Class: oaVarDataAppDef_oaWaferDesc, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value for this extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to be filled out with the default value\n"
;

static PyObject*
oaVarDataAppDef_oaWaferDesc_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaWaferDesc data;
    int convert_status=PyoaVarDataAppDef_oaWaferDesc_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaWaferDescObject* self=(PyoaVarDataAppDef_oaWaferDescObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getDefaultSize()==p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match default size");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWaferDesc_getDefaultSize_doc[] = 
"Class: oaVarDataAppDef_oaWaferDesc, Function: getDefaultSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getDefaultSize() const\n"
"    Signature: getDefaultSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the default size for this extension in bytes.\n"
;

static PyObject*
oaVarDataAppDef_oaWaferDesc_getDefaultSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaWaferDesc data;
    int convert_status=PyoaVarDataAppDef_oaWaferDesc_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaWaferDescObject* self=(PyoaVarDataAppDef_oaWaferDescObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getDefaultSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWaferDesc_getSize_doc[] = 
"Class: oaVarDataAppDef_oaWaferDesc, Function: getSize\n"
"  Paramegers: (oaWaferDesc)\n"
"    Calls: oaUInt4 getSize(const oaWaferDesc* object)\n"
"    Signature: getSize|simple-oaUInt4|cptr-oaWaferDesc,\n"
"    This function returns the size of the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaWaferDesc_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaWaferDesc data;
    int convert_status=PyoaVarDataAppDef_oaWaferDesc_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaWaferDescObject* self=(PyoaVarDataAppDef_oaWaferDescObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWaferDesc p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaWaferDesc_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (data.DataCall()->getSize(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWaferDesc_set_doc[] = 
"Class: oaVarDataAppDef_oaWaferDesc, Function: set\n"
"  Paramegers: (oaWaferDesc,[oaByte])\n"
"    Calls: void set(oaWaferDesc* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaWaferDesc,simple-oaUInt4,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaWaferDesc_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaWaferDesc data;
    int convert_status=PyoaVarDataAppDef_oaWaferDesc_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaWaferDescObject* self=(PyoaVarDataAppDef_oaWaferDescObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWaferDesc p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaWaferDesc_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWaferDesc_isNull_doc[] =
"Class: oaVarDataAppDef_oaWaferDesc, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaVarDataAppDef_oaWaferDesc_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaVarDataAppDef_oaWaferDesc data;
    int convert_status=PyoaVarDataAppDef_oaWaferDesc_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaVarDataAppDef_oaWaferDesc_assign_doc[] = 
"Class: oaVarDataAppDef_oaWaferDesc, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVarDataAppDef_oaWaferDesc_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVarDataAppDef_oaWaferDesc data;
  int convert_status=PyoaVarDataAppDef_oaWaferDesc_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVarDataAppDef_oaWaferDesc p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVarDataAppDef_oaWaferDesc_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVarDataAppDef_oaWaferDesc_methodlist[] = {
    {"get",(PyCFunction)oaVarDataAppDef_oaWaferDesc_get,METH_VARARGS,oaVarDataAppDef_oaWaferDesc_get_doc},
    {"getDefault",(PyCFunction)oaVarDataAppDef_oaWaferDesc_getDefault,METH_VARARGS,oaVarDataAppDef_oaWaferDesc_getDefault_doc},
    {"getDefaultSize",(PyCFunction)oaVarDataAppDef_oaWaferDesc_getDefaultSize,METH_VARARGS,oaVarDataAppDef_oaWaferDesc_getDefaultSize_doc},
    {"getSize",(PyCFunction)oaVarDataAppDef_oaWaferDesc_getSize,METH_VARARGS,oaVarDataAppDef_oaWaferDesc_getSize_doc},
    {"set",(PyCFunction)oaVarDataAppDef_oaWaferDesc_set,METH_VARARGS,oaVarDataAppDef_oaWaferDesc_set_doc},
    {"isNull",(PyCFunction)oaVarDataAppDef_oaWaferDesc_tp_isNull,METH_VARARGS,oaVarDataAppDef_oaWaferDesc_isNull_doc},
    {"assign",(PyCFunction)oaVarDataAppDef_oaWaferDesc_tp_assign,METH_VARARGS,oaVarDataAppDef_oaWaferDesc_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWaferDesc_doc[] = 
"Class: oaVarDataAppDef_oaWaferDesc\n"
"  The oaVarDataAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When the objects are created, a data field is added to each object of the specified dataType. Applications can use the new data field for whatever purpose is necessary.\n"
"  This type of extension is useful because it allows variable-sized data for each object being extended. This is similar to the oaDataAppDef class, but more general because the data size can differ for each object. (There is a minor speed and size penalty for this additional flexibility.) The default value for this extension is zero bytes.\n"
"  Note: Because the type of data is unknown to OpenAccess, it is unmanaged. This means the contents are not byte-swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaVarDataAppDef_oaWaferDesc)\n"
"    Calls: (const oaVarDataAppDef_oaWaferDesc&)\n"
"    Signature: oaVarDataAppDef_oaWaferDesc||cref-oaVarDataAppDef_oaWaferDesc,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVarDataAppDef_oaWaferDesc_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVarDataAppDef_oaWaferDesc",
    sizeof(PyoaVarDataAppDef_oaWaferDescObject),
    0,
    (destructor)oaVarDataAppDef_oaWaferDesc_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVarDataAppDef_oaWaferDesc_tp_compare,	/* tp_compare */
    (reprfunc)oaVarDataAppDef_oaWaferDesc_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVarDataAppDef_oaWaferDesc_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVarDataAppDef_oaWaferDesc_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVarDataAppDef_oaWaferDesc_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWaferDesc_static_find_doc[] = 
"Class: oaVarDataAppDef_oaWaferDesc, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaWaferDesc* find(const oaString& name)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaWaferDesc|cref-oaString,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaWaferDesc* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaWaferDesc|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaVarDataAppDef_oaWaferDesc_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaWaferDescp result= (oaVarDataAppDef_oaWaferDesc::find(p1.Data()));
            return PyoaVarDataAppDef_oaWaferDesc_FromoaVarDataAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaWaferDescp result= (oaVarDataAppDef_oaWaferDesc::find(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaWaferDesc_FromoaVarDataAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaWaferDesc, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWaferDesc_static_get_doc[] = 
"Class: oaVarDataAppDef_oaWaferDesc, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaWaferDesc* get(const oaString& name)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaWaferDesc|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaWaferDesc* get(const oaString& name,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaWaferDesc|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaWaferDesc* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaWaferDesc|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaWaferDesc* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaWaferDesc|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaWaferDesc* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaWaferDesc|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaWaferDesc* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaWaferDesc|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
;

static PyObject*
oaVarDataAppDef_oaWaferDesc_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaWaferDescp result= (oaVarDataAppDef_oaWaferDesc::get(p1.Data()));
            return PyoaVarDataAppDef_oaWaferDesc_FromoaVarDataAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaVarDataAppDef_oaWaferDescp result= (oaVarDataAppDef_oaWaferDesc::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaWaferDesc_FromoaVarDataAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaVarDataAppDef_oaWaferDescp result= (oaVarDataAppDef_oaWaferDesc::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaWaferDesc_FromoaVarDataAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaWaferDescp result= (oaVarDataAppDef_oaWaferDesc::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaWaferDesc_FromoaVarDataAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaWaferDescp result= (oaVarDataAppDef_oaWaferDesc::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaWaferDesc_FromoaVarDataAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaWaferDescp result= (oaVarDataAppDef_oaWaferDesc::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaVarDataAppDef_oaWaferDesc_FromoaVarDataAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaWaferDesc, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaVarDataAppDef_oaWaferDesc_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaVarDataAppDef_oaWaferDesc_static_find,METH_VARARGS,oaVarDataAppDef_oaWaferDesc_static_find_doc},
    {"static_get",(PyCFunction)oaVarDataAppDef_oaWaferDesc_static_get,METH_VARARGS,oaVarDataAppDef_oaWaferDesc_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVarDataAppDef_oaWaferDesc_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVarDataAppDef_oaWaferDesc_Type)<0) {
      printf("** PyType_Ready failed for: oaVarDataAppDef_oaWaferDesc\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVarDataAppDef_oaWaferDesc",
           (PyObject*)(&PyoaVarDataAppDef_oaWaferDesc_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVarDataAppDef_oaWaferDesc\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaVarDataAppDef_oaWaferDesc_Type.tp_dict;
    for(method=oaVarDataAppDef_oaWaferDesc_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVarDataAppDef_oaWaferFeature
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaWaferFeature_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVarDataAppDef_oaWaferFeature_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVarDataAppDef_oaWaferFeatureObject* self = (PyoaVarDataAppDef_oaWaferFeatureObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaVarDataAppDef_oaWaferFeature)
    {
        PyParamoaVarDataAppDef_oaWaferFeature p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVarDataAppDef_oaWaferFeature_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVarDataAppDef_oaWaferFeature, Choices are:\n"
        "    (oaVarDataAppDef_oaWaferFeature)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVarDataAppDef_oaWaferFeature_tp_dealloc(PyoaVarDataAppDef_oaWaferFeatureObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVarDataAppDef_oaWaferFeature_tp_repr(PyObject *ob)
{
    PyParamoaVarDataAppDef_oaWaferFeature value;
    int convert_status=PyoaVarDataAppDef_oaWaferFeature_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[52];
    sprintf(buffer,"<oaVarDataAppDef_oaWaferFeature::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVarDataAppDef_oaWaferFeature_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVarDataAppDef_oaWaferFeature v1;
    PyParamoaVarDataAppDef_oaWaferFeature v2;
    int convert_status1=PyoaVarDataAppDef_oaWaferFeature_Convert(ob1,&v1);
    int convert_status2=PyoaVarDataAppDef_oaWaferFeature_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVarDataAppDef_oaWaferFeature_Convert(PyObject* ob,PyParamoaVarDataAppDef_oaWaferFeature* result)
{
    if (ob == NULL) return 1;
    if (PyoaVarDataAppDef_oaWaferFeature_Check(ob)) {
        result->SetData( (oaVarDataAppDef_oaWaferFeature**) ((PyoaVarDataAppDef_oaWaferFeatureObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVarDataAppDef_oaWaferFeature Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaWaferFeature_FromoaVarDataAppDef_oaWaferFeature(oaVarDataAppDef_oaWaferFeature** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaVarDataAppDef_oaWaferFeature* data=*value;
        PyObject* bself = PyoaVarDataAppDef_oaWaferFeature_Type.tp_alloc(&PyoaVarDataAppDef_oaWaferFeature_Type,0);
        if (bself == NULL) return bself;
        PyoaVarDataAppDef_oaWaferFeatureObject* self = (PyoaVarDataAppDef_oaWaferFeatureObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaVarDataAppDef_oaWaferFeature_FromoaVarDataAppDef_oaWaferFeature(oaVarDataAppDef_oaWaferFeature* data)
{
    if (data) {
       PyObject* bself = PyoaVarDataAppDef_oaWaferFeature_Type.tp_alloc(&PyoaVarDataAppDef_oaWaferFeature_Type,0);
       if (bself == NULL) return bself;
       PyoaVarDataAppDef_oaWaferFeatureObject* self = (PyoaVarDataAppDef_oaWaferFeatureObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWaferFeature_get_doc[] = 
"Class: oaVarDataAppDef_oaWaferFeature, Function: get\n"
"  Paramegers: (oaWaferFeature,[oaByte])\n"
"    Calls: void get(const oaWaferFeature* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaWaferFeature,ptr-oaByte,\n"
"    This function returns the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaWaferFeature_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaWaferFeature data;
    int convert_status=PyoaVarDataAppDef_oaWaferFeature_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaWaferFeatureObject* self=(PyoaVarDataAppDef_oaWaferFeatureObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWaferFeature p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaWaferFeature_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize(p1.Data())==p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match object data");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWaferFeature_getDefault_doc[] = 
"Class: oaVarDataAppDef_oaWaferFeature, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value for this extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to be filled out with the default value\n"
;

static PyObject*
oaVarDataAppDef_oaWaferFeature_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaWaferFeature data;
    int convert_status=PyoaVarDataAppDef_oaWaferFeature_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaWaferFeatureObject* self=(PyoaVarDataAppDef_oaWaferFeatureObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getDefaultSize()==p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number bytes does not match default size");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWaferFeature_getDefaultSize_doc[] = 
"Class: oaVarDataAppDef_oaWaferFeature, Function: getDefaultSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getDefaultSize() const\n"
"    Signature: getDefaultSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the default size for this extension in bytes.\n"
;

static PyObject*
oaVarDataAppDef_oaWaferFeature_getDefaultSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaWaferFeature data;
    int convert_status=PyoaVarDataAppDef_oaWaferFeature_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaWaferFeatureObject* self=(PyoaVarDataAppDef_oaWaferFeatureObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getDefaultSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWaferFeature_getSize_doc[] = 
"Class: oaVarDataAppDef_oaWaferFeature, Function: getSize\n"
"  Paramegers: (oaWaferFeature)\n"
"    Calls: oaUInt4 getSize(const oaWaferFeature* object)\n"
"    Signature: getSize|simple-oaUInt4|cptr-oaWaferFeature,\n"
"    This function returns the size of the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaWaferFeature_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaWaferFeature data;
    int convert_status=PyoaVarDataAppDef_oaWaferFeature_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaWaferFeatureObject* self=(PyoaVarDataAppDef_oaWaferFeatureObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWaferFeature p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaWaferFeature_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (data.DataCall()->getSize(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWaferFeature_set_doc[] = 
"Class: oaVarDataAppDef_oaWaferFeature, Function: set\n"
"  Paramegers: (oaWaferFeature,[oaByte])\n"
"    Calls: void set(oaWaferFeature* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaWaferFeature,simple-oaUInt4,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaVarDataAppDef_oaWaferFeature_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVarDataAppDef_oaWaferFeature data;
    int convert_status=PyoaVarDataAppDef_oaWaferFeature_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVarDataAppDef_oaWaferFeatureObject* self=(PyoaVarDataAppDef_oaWaferFeatureObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWaferFeature p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaWaferFeature_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWaferFeature_isNull_doc[] =
"Class: oaVarDataAppDef_oaWaferFeature, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaVarDataAppDef_oaWaferFeature_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaVarDataAppDef_oaWaferFeature data;
    int convert_status=PyoaVarDataAppDef_oaWaferFeature_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaVarDataAppDef_oaWaferFeature_assign_doc[] = 
"Class: oaVarDataAppDef_oaWaferFeature, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVarDataAppDef_oaWaferFeature_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVarDataAppDef_oaWaferFeature data;
  int convert_status=PyoaVarDataAppDef_oaWaferFeature_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVarDataAppDef_oaWaferFeature p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVarDataAppDef_oaWaferFeature_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVarDataAppDef_oaWaferFeature_methodlist[] = {
    {"get",(PyCFunction)oaVarDataAppDef_oaWaferFeature_get,METH_VARARGS,oaVarDataAppDef_oaWaferFeature_get_doc},
    {"getDefault",(PyCFunction)oaVarDataAppDef_oaWaferFeature_getDefault,METH_VARARGS,oaVarDataAppDef_oaWaferFeature_getDefault_doc},
    {"getDefaultSize",(PyCFunction)oaVarDataAppDef_oaWaferFeature_getDefaultSize,METH_VARARGS,oaVarDataAppDef_oaWaferFeature_getDefaultSize_doc},
    {"getSize",(PyCFunction)oaVarDataAppDef_oaWaferFeature_getSize,METH_VARARGS,oaVarDataAppDef_oaWaferFeature_getSize_doc},
    {"set",(PyCFunction)oaVarDataAppDef_oaWaferFeature_set,METH_VARARGS,oaVarDataAppDef_oaWaferFeature_set_doc},
    {"isNull",(PyCFunction)oaVarDataAppDef_oaWaferFeature_tp_isNull,METH_VARARGS,oaVarDataAppDef_oaWaferFeature_isNull_doc},
    {"assign",(PyCFunction)oaVarDataAppDef_oaWaferFeature_tp_assign,METH_VARARGS,oaVarDataAppDef_oaWaferFeature_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWaferFeature_doc[] = 
"Class: oaVarDataAppDef_oaWaferFeature\n"
"  The oaVarDataAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When the objects are created, a data field is added to each object of the specified dataType. Applications can use the new data field for whatever purpose is necessary.\n"
"  This type of extension is useful because it allows variable-sized data for each object being extended. This is similar to the oaDataAppDef class, but more general because the data size can differ for each object. (There is a minor speed and size penalty for this additional flexibility.) The default value for this extension is zero bytes.\n"
"  Note: Because the type of data is unknown to OpenAccess, it is unmanaged. This means the contents are not byte-swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaVarDataAppDef_oaWaferFeature)\n"
"    Calls: (const oaVarDataAppDef_oaWaferFeature&)\n"
"    Signature: oaVarDataAppDef_oaWaferFeature||cref-oaVarDataAppDef_oaWaferFeature,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVarDataAppDef_oaWaferFeature_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVarDataAppDef_oaWaferFeature",
    sizeof(PyoaVarDataAppDef_oaWaferFeatureObject),
    0,
    (destructor)oaVarDataAppDef_oaWaferFeature_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVarDataAppDef_oaWaferFeature_tp_compare,	/* tp_compare */
    (reprfunc)oaVarDataAppDef_oaWaferFeature_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVarDataAppDef_oaWaferFeature_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVarDataAppDef_oaWaferFeature_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVarDataAppDef_oaWaferFeature_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWaferFeature_static_find_doc[] = 
"Class: oaVarDataAppDef_oaWaferFeature, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaWaferFeature* find(const oaString& name)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaWaferFeature|cref-oaString,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaWaferFeature* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaVarDataAppDef_oaWaferFeature|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaVarDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaVarDataAppDef_oaWaferFeature_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaWaferFeaturep result= (oaVarDataAppDef_oaWaferFeature::find(p1.Data()));
            return PyoaVarDataAppDef_oaWaferFeature_FromoaVarDataAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaWaferFeaturep result= (oaVarDataAppDef_oaWaferFeature::find(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaWaferFeature_FromoaVarDataAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaWaferFeature, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVarDataAppDef_oaWaferFeature_static_get_doc[] = 
"Class: oaVarDataAppDef_oaWaferFeature, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVarDataAppDef_oaWaferFeature* get(const oaString& name)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaWaferFeature|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaWaferFeature* get(const oaString& name,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaWaferFeature|cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaWaferFeature* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaWaferFeature|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name .\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaVarDataAppDef_oaWaferFeature* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaWaferFeature|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaWaferFeature* get(const oaString& name,const oaAppObjectDef* objDef,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaWaferFeature|cref-oaString,cptr-oaAppObjectDef,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaVarDataAppDef_oaWaferFeature* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaVarDataAppDef_oaWaferFeature|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaVarDataAppDef class variable data extension with the specified name for the specified type of object.\n"
"    name\n"
"    The name given to the oaVarDataAppDef object\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaVarDataAppDef data in the database\n"
"    defSize\n"
"    The default size of the data for this extension\n"
"    defValue\n"
"    The default value for the data for this extension\n"
"    oacAppDefExists\n"
;

static PyObject*
oaVarDataAppDef_oaWaferFeature_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaVarDataAppDef_oaWaferFeaturep result= (oaVarDataAppDef_oaWaferFeature::get(p1.Data()));
            return PyoaVarDataAppDef_oaWaferFeature_FromoaVarDataAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaVarDataAppDef_oaWaferFeaturep result= (oaVarDataAppDef_oaWaferFeature::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaWaferFeature_FromoaVarDataAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaVarDataAppDef_oaWaferFeaturep result= (oaVarDataAppDef_oaWaferFeature::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaWaferFeature_FromoaVarDataAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaWaferFeaturep result= (oaVarDataAppDef_oaWaferFeature::get(p1.Data(),p2.Data()));
            return PyoaVarDataAppDef_oaWaferFeature_FromoaVarDataAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaWaferFeaturep result= (oaVarDataAppDef_oaWaferFeature::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaVarDataAppDef_oaWaferFeature_FromoaVarDataAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVarDataAppDef_oaWaferFeaturep result= (oaVarDataAppDef_oaWaferFeature::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaVarDataAppDef_oaWaferFeature_FromoaVarDataAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVarDataAppDef_oaWaferFeature, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaVarDataAppDef_oaWaferFeature_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaVarDataAppDef_oaWaferFeature_static_find,METH_VARARGS,oaVarDataAppDef_oaWaferFeature_static_find_doc},
    {"static_get",(PyCFunction)oaVarDataAppDef_oaWaferFeature_static_get,METH_VARARGS,oaVarDataAppDef_oaWaferFeature_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVarDataAppDef_oaWaferFeature_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVarDataAppDef_oaWaferFeature_Type)<0) {
      printf("** PyType_Ready failed for: oaVarDataAppDef_oaWaferFeature\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVarDataAppDef_oaWaferFeature",
           (PyObject*)(&PyoaVarDataAppDef_oaWaferFeature_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVarDataAppDef_oaWaferFeature\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaVarDataAppDef_oaWaferFeature_Type.tp_dict;
    for(method=oaVarDataAppDef_oaWaferFeature_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVector
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVector_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVector_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVectorObject* self = (PyoaVectorObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaVector();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaOffset,oaOffset)
    {
        PyParamoaOffset p1;
        PyParamoaOffset p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaOffset_Convert,&p1,
              &PyoaOffset_Convert,&p2)) {
            self->value =  new oaVector(p1.Data(),p2.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaPoint)
    {
        PyParamoaPoint p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaPoint_Convert,&p1)) {
            self->value =  new oaVector(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaPoint,oaPoint)
    {
        PyParamoaPoint p1;
        PyParamoaPoint p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaPoint_Convert,&p1,
              &PyoaPoint_Convert,&p2)) {
            self->value =  new oaVector(p1.Data(),p2.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaVector)
    {
        PyParamoaVector p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVector_Convert,&p1)) {
            self->value= new oaVector(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVector, Choices are:\n"
        "    ()\n"
        "    (oaOffset,oaOffset)\n"
        "    (oaPoint)\n"
        "    (oaPoint,oaPoint)\n"
        "    (oaVector)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVector_tp_dealloc(PyoaVectorObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVector_tp_repr(PyObject *ob)
{
    PyParamoaVector value;
    int convert_status=PyoaVector_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[30];
    sprintf(buffer,"<oaVector::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVector_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVector v1;
    PyParamoaVector v2;
    int convert_status1=PyoaVector_Convert(ob1,&v1);
    int convert_status2=PyoaVector_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    if (v1.Data()==v2.Data()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVector_Convert(PyObject* ob,PyParamoaVector* result)
{
    if (ob == NULL) return 1;
    if (PyoaVector_Check(ob)) {
        result->SetData(  ((PyoaVectorObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVector Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVector_FromoaVector(oaVector* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaVector_Type.tp_alloc(&PyoaVector_Type,0);
        if (bself == NULL) return bself;
        PyoaVectorObject* self = (PyoaVectorObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVector__doc[] = 
"Class: oaVector, Function: \n"
"  Paramegers: (oaVector)\n"
"    Calls: oaDouble (const oaVector& v) const\n"
"    Signature: operator *|simple-oaDouble|cref-oaVector,\n"
"    This operator returns an oaDouble that equals the product of this oaVector and the specified oaVector v .\n"
;

static PyObject*
oaVector_(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVector data;
    int convert_status=PyoaVector_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorObject* self=(PyoaVectorObject*)ob;

    PyParamoaVector p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaVector_Convert,&p1)) {
        oaDouble result= (data.DataCall()->operator *(p1.Data()));
        return PyoaDouble_FromoaDouble(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVector_addToPoint_doc[] = 
"Class: oaVector, Function: addToPoint\n"
"  Paramegers: (oaPoint,oaPoint)\n"
"    Calls: void addToPoint(const oaPoint& start,oaPoint& result) const\n"
"    Signature: addToPoint|void-void|cref-oaPoint,ref-oaPoint,\n"
"    This function adds this vector to the point start , and places the result in result .\n"
"    start\n"
"    The starting point\n"
"    result\n"
"    The resulting point after this vector is added to start\n"
;

static PyObject*
oaVector_addToPoint(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVector data;
    int convert_status=PyoaVector_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorObject* self=(PyoaVectorObject*)ob;

    PyParamoaPoint p1;
    PyParamoaPoint p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaPoint_Convert,&p1,
          &PyoaPoint_Convert,&p2)) {
        data.DataCall()->addToPoint(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVector_getCosAngle_doc[] = 
"Class: oaVector, Function: getCosAngle\n"
"  Paramegers: (oaVector)\n"
"    Calls: oaDouble getCosAngle(const oaVector& v) const\n"
"    Signature: getCosAngle|simple-oaDouble|cref-oaVector,\n"
"    This function returns the cosine of the angle between this vector and the specified vector.\n"
"    v\n"
"    The other vector to be used for angle measurement\n"
;

static PyObject*
oaVector_getCosAngle(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVector data;
    int convert_status=PyoaVector_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorObject* self=(PyoaVectorObject*)ob;

    PyParamoaVector p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaVector_Convert,&p1)) {
        oaDouble result= (data.DataCall()->getCosAngle(p1.Data()));
        return PyoaDouble_FromoaDouble(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVector_getLength_doc[] = 
"Class: oaVector, Function: getLength\n"
"  Paramegers: ()\n"
"    Calls: oaInt4 getLength() const\n"
"    Signature: getLength|simple-oaInt4|\n"
"    BrowseData: 1\n"
"    This function returns the length of this vector.\n"
;

static PyObject*
oaVector_getLength(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVector data;
    int convert_status=PyoaVector_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorObject* self=(PyoaVectorObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaInt4 result= (data.DataCall()->getLength());
        return PyoaInt4_FromoaInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVector_intersects_doc[] = 
"Class: oaVector, Function: intersects\n"
"  Paramegers: (oaPoint,oaVector,oaPoint,oaPoint)\n"
"    Calls: oaBoolean intersects(const oaPoint& ref,const oaVector& other,const oaPoint& otherRef,oaPoint& iPt) const\n"
"    Signature: intersects|simple-oaBoolean|cref-oaPoint,cref-oaVector,cref-oaPoint,ref-oaPoint,\n"
"    This function finds the point of intersection between this vector and vector other . This function converts the vectors into segments. The segments do all the work.\n"
"    ref\n"
"    The head of this vector\n"
"    other\n"
"    The vector that intersects the reference vector\n"
"    otherRef\n"
"    The head of vector other\n"
"    iPt\n"
"    The point of intersection between the vectors\n"
;

static PyObject*
oaVector_intersects(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVector data;
    int convert_status=PyoaVector_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorObject* self=(PyoaVectorObject*)ob;

    PyParamoaPoint p1;
    PyParamoaVector p2;
    PyParamoaPoint p3;
    PyParamoaPoint p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaPoint_Convert,&p1,
          &PyoaVector_Convert,&p2,
          &PyoaPoint_Convert,&p3,
          &PyoaPoint_Convert,&p4)) {
        oaBoolean result= (data.DataCall()->intersects(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVector_leftOf_doc[] = 
"Class: oaVector, Function: leftOf\n"
"  Paramegers: (oaVector)\n"
"    Calls: oaBoolean leftOf(const oaVector& ref) const\n"
"    Signature: leftOf|simple-oaBoolean|cref-oaVector,\n"
"    This function returns true if this vector is to the left of the specified vector. \"Leftof\" means the angle of this vector minus the angle of ref is between 0 and 180 degrees.\n"
"    ref\n"
"    The specified vector\n"
;

static PyObject*
oaVector_leftOf(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVector data;
    int convert_status=PyoaVector_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorObject* self=(PyoaVectorObject*)ob;

    PyParamoaVector p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaVector_Convert,&p1)) {
        oaBoolean result= (data.DataCall()->leftOf(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVector_normalize_doc[] = 
"Class: oaVector, Function: normalize\n"
"  Paramegers: ()\n"
"    Calls: void normalize()\n"
"    Signature: normalize|void-void|\n"
"    BrowseData: 0\n"
"    This function normalizes this vector to a unit vector. The result is undefined for a zero length vector.\n"
;

static PyObject*
oaVector_normalize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVector data;
    int convert_status=PyoaVector_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorObject* self=(PyoaVectorObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->normalize();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVector_rightOf_doc[] = 
"Class: oaVector, Function: rightOf\n"
"  Paramegers: (oaVector)\n"
"    Calls: oaBoolean rightOf(const oaVector& ref) const\n"
"    Signature: rightOf|simple-oaBoolean|cref-oaVector,\n"
"    This function returns true if this vector is to the right of the specified vector. \"Rightof\" means the angle of this vector minus the angle of ref is between 180 and 360 degrees.\n"
"    ref\n"
"    The specified vector\n"
;

static PyObject*
oaVector_rightOf(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVector data;
    int convert_status=PyoaVector_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorObject* self=(PyoaVectorObject*)ob;

    PyParamoaVector p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaVector_Convert,&p1)) {
        oaBoolean result= (data.DataCall()->rightOf(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVector_rotate180_doc[] = 
"Class: oaVector, Function: rotate180\n"
"  Paramegers: ()\n"
"    Calls: void rotate180()\n"
"    Signature: rotate180|void-void|\n"
"    BrowseData: 0\n"
"    This function rotates this vector by 180 degrees in a clockwise direction.\n"
;

static PyObject*
oaVector_rotate180(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVector data;
    int convert_status=PyoaVector_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorObject* self=(PyoaVectorObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->rotate180();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVector_rotate270_doc[] = 
"Class: oaVector, Function: rotate270\n"
"  Paramegers: ()\n"
"    Calls: void rotate270()\n"
"    Signature: rotate270|void-void|\n"
"    BrowseData: 0\n"
"    This function rotates this vector by 270 degrees in a clockwise direction.\n"
;

static PyObject*
oaVector_rotate270(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVector data;
    int convert_status=PyoaVector_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorObject* self=(PyoaVectorObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->rotate270();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVector_rotate90_doc[] = 
"Class: oaVector, Function: rotate90\n"
"  Paramegers: ()\n"
"    Calls: void rotate90()\n"
"    Signature: rotate90|void-void|\n"
"    BrowseData: 0\n"
"    This function rotates this vector by 90 degrees in a clockwise direction.\n"
;

static PyObject*
oaVector_rotate90(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVector data;
    int convert_status=PyoaVector_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorObject* self=(PyoaVectorObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->rotate90();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVector_set_doc[] = 
"Class: oaVector, Function: set\n"
"  Paramegers: (oaPoint,oaPoint)\n"
"    Calls: void set(const oaPoint& tail,const oaPoint& head)\n"
"    Signature: set|void-void|cref-oaPoint,cref-oaPoint,\n"
"    This function recreates this vector based upon the segment generated from the head point to the tail point.\n"
"    head\n"
"    The head point of the new vector\n"
"    tail\n"
"    The tail point of the new vector\n"
;

static PyObject*
oaVector_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVector data;
    int convert_status=PyoaVector_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorObject* self=(PyoaVectorObject*)ob;

    PyParamoaPoint p1;
    PyParamoaPoint p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaPoint_Convert,&p1,
          &PyoaPoint_Convert,&p2)) {
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVector_setLength_doc[] = 
"Class: oaVector, Function: setLength\n"
"  Paramegers: (oaInt4)\n"
"    Calls: void setLength(oaInt4 length)\n"
"    Signature: setLength|void-void|simple-oaInt4,\n"
"    This function sets the length of this vector to the specified value. The result is undefined for a zero length vector.\n"
"    length\n"
"    The length of the new vector\n"
;

static PyObject*
oaVector_setLength(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVector data;
    int convert_status=PyoaVector_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorObject* self=(PyoaVectorObject*)ob;

    PyParamoaInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaInt4_Convert,&p1)) {
        data.DataCall()->setLength(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVector_subFromPoint_doc[] = 
"Class: oaVector, Function: subFromPoint\n"
"  Paramegers: (oaPoint,oaPoint)\n"
"    Calls: void subFromPoint(const oaPoint& start,oaPoint& result) const\n"
"    Signature: subFromPoint|void-void|cref-oaPoint,ref-oaPoint,\n"
"    This function subtracts this vector from the point start and places the result in result .\n"
;

static PyObject*
oaVector_subFromPoint(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVector data;
    int convert_status=PyoaVector_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorObject* self=(PyoaVectorObject*)ob;

    PyParamoaPoint p1;
    PyParamoaPoint p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaPoint_Convert,&p1,
          &PyoaPoint_Convert,&p2)) {
        data.DataCall()->subFromPoint(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVector_x_doc[] = 
"Class: oaVector, Function: x\n"
"  Paramegers: ()\n"
"    Calls: oaOffset& x()\n"
"    Signature: x|ref-oaOffset|\n"
"    BrowseData: 1\n"
"    This function returns the X value of this vector.\n"
;

static PyObject*
oaVector_x(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVector data;
    int convert_status=PyoaVector_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorObject* self=(PyoaVectorObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaOffset* result=&(data.DataCall()->x());
        return PyoaOffset_FromoaOffset(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVector_y_doc[] = 
"Class: oaVector, Function: y\n"
"  Paramegers: ()\n"
"    Calls: oaOffset& y()\n"
"    Signature: y|ref-oaOffset|\n"
"    BrowseData: 1\n"
"    This function returns the Y value of this vector.\n"
;

static PyObject*
oaVector_y(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVector data;
    int convert_status=PyoaVector_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorObject* self=(PyoaVectorObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaOffset* result=&(data.DataCall()->y());
        return PyoaOffset_FromoaOffset(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaVector_assign_doc[] = 
"Class: oaVector, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVector_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVector data;
  int convert_status=PyoaVector_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVector p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVector_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVector_methodlist[] = {
    {"",(PyCFunction)oaVector_,METH_VARARGS,oaVector__doc},
    {"addToPoint",(PyCFunction)oaVector_addToPoint,METH_VARARGS,oaVector_addToPoint_doc},
    {"getCosAngle",(PyCFunction)oaVector_getCosAngle,METH_VARARGS,oaVector_getCosAngle_doc},
    {"getLength",(PyCFunction)oaVector_getLength,METH_VARARGS,oaVector_getLength_doc},
    {"intersects",(PyCFunction)oaVector_intersects,METH_VARARGS,oaVector_intersects_doc},
    {"leftOf",(PyCFunction)oaVector_leftOf,METH_VARARGS,oaVector_leftOf_doc},
    {"normalize",(PyCFunction)oaVector_normalize,METH_VARARGS,oaVector_normalize_doc},
    {"rightOf",(PyCFunction)oaVector_rightOf,METH_VARARGS,oaVector_rightOf_doc},
    {"rotate180",(PyCFunction)oaVector_rotate180,METH_VARARGS,oaVector_rotate180_doc},
    {"rotate270",(PyCFunction)oaVector_rotate270,METH_VARARGS,oaVector_rotate270_doc},
    {"rotate90",(PyCFunction)oaVector_rotate90,METH_VARARGS,oaVector_rotate90_doc},
    {"set",(PyCFunction)oaVector_set,METH_VARARGS,oaVector_set_doc},
    {"setLength",(PyCFunction)oaVector_setLength,METH_VARARGS,oaVector_setLength_doc},
    {"subFromPoint",(PyCFunction)oaVector_subFromPoint,METH_VARARGS,oaVector_subFromPoint_doc},
    {"x",(PyCFunction)oaVector_x,METH_VARARGS,oaVector_x_doc},
    {"y",(PyCFunction)oaVector_y,METH_VARARGS,oaVector_y_doc},
    {"assign",(PyCFunction)oaVector_tp_assign,METH_VARARGS,oaVector_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVector_doc[] = 
"Class: oaVector\n"
"  The oaVector class implements a two-dimensional vector.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaVector()\n"
"    Signature: oaVector||\n"
"    This function constructs a default oaVector instance.\n"
"  Paramegers: (oaOffset,oaOffset)\n"
"    Calls: oaVector(oaOffset xValIn,oaOffset yValIn)\n"
"    Signature: oaVector||simple-oaOffset,simple-oaOffset,\n"
"    This function constructs an oaVector object, initializing the vector with the specified X and Y offset values.\n"
"    xValIn\n"
"    The X offset value to use\n"
"    yValIn\n"
"    The Y offset value to use\n"
"  Paramegers: (oaPoint)\n"
"    Calls: oaVector(const oaPoint& head)\n"
"    Signature: oaVector||cref-oaPoint,\n"
"    This function constructs an oaVector object, initializing the vector from a single head point with the origin at the implied tail.\n"
"    head\n"
"    The head point of this vector\n"
"  Paramegers: (oaPoint,oaPoint)\n"
"    Calls: oaVector(const oaPoint& tail,const oaPoint& head)\n"
"    Signature: oaVector||cref-oaPoint,cref-oaPoint,\n"
"    This function constructs an oaVector object, initializing the vector using the specified head and tail values.\n"
"    head\n"
"    The head point of this vector\n"
"    tail\n"
"    The tail point of this vector\n"
"  Paramegers: (oaVector)\n"
"    Calls: (const oaVector&)\n"
"    Signature: oaVector||cref-oaVector,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVector_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVector",
    sizeof(PyoaVectorObject),
    0,
    (destructor)oaVector_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVector_tp_compare,	/* tp_compare */
    (reprfunc)oaVector_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVector_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVector_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVector_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVector_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVector_Type)<0) {
      printf("** PyType_Ready failed for: oaVector\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVector",
           (PyObject*)(&PyoaVector_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVector\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVectorBitName
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVectorBitName_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVectorBitName_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVectorBitNameObject* self = (PyoaVectorBitNameObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaNameBase*)  new oaVectorBitName();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,[oaChar])
    {
        PyParamoaNameSpace p1;
        PyParamoaChar_Array p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaChar_Array_Convert,&p2)) {
            self->value = (oaNameBase*)  new oaVectorBitName(p1.Data(),p2.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,[oaChar],oaUInt4)
    {
        PyParamoaNameSpace p1;
        PyParamoaChar_Array p2;
        PyParamoaUInt4 p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaChar_Array_Convert,&p2,
              &PyoaUInt4_Convert,&p3)) {
            self->value = (oaNameBase*)  new oaVectorBitName(p1.Data(),p2.Data(),p3.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaScalarName,oaUInt4)
    {
        PyParamoaScalarName p1;
        PyParamoaUInt4 p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaScalarName_Convert,&p1,
              &PyoaUInt4_Convert,&p2)) {
            self->value = (oaNameBase*)  new oaVectorBitName(p1.Data(),p2.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaVectorBitName)
    {
        PyParamoaVectorBitName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorBitName_Convert,&p1)) {
            self->value = (oaNameBase*)  new oaVectorBitName(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVectorBitName, Choices are:\n"
        "    ()\n"
        "    (oaNameSpace,[oaChar])\n"
        "    (oaNameSpace,[oaChar],oaUInt4)\n"
        "    (oaScalarName,oaUInt4)\n"
        "    (oaVectorBitName)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVectorBitName_tp_dealloc(PyoaVectorBitNameObject* self)
{
    if (!self->borrow) {
        delete (oaVectorBitName*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVectorBitName_tp_repr(PyObject *ob)
{
    PyParamoaVectorBitName value;
    int convert_status=PyoaVectorBitName_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    oaString sresult;
    value.DataCall()->get(sresult);

    char addr[37];
    sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
    oaString buffer;
    buffer+=oaString("<oaVectorBitName::");
    buffer+=oaString(addr);
    buffer+=oaString("::");
    buffer+=oaString(sresult);
    buffer+=oaString(">");
    result=PyString_FromString((char*)(const char*)buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVectorBitName_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVectorBitName v1;
    PyParamoaVectorBitName v2;
    int convert_status1=PyoaVectorBitName_Convert(ob1,&v1);
    int convert_status2=PyoaVectorBitName_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    if (v1.Data()==v2.Data()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVectorBitName_Convert(PyObject* ob,PyParamoaVectorBitName* result)
{
    if (ob == NULL) return 1;
    if (PyoaVectorBitName_Check(ob)) {
        result->SetData( (oaVectorBitName*) ((PyoaVectorBitNameObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVectorBitName Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVectorBitName_FromoaVectorBitName(oaVectorBitName* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaVectorBitName_Type.tp_alloc(&PyoaVectorBitName_Type,0);
        if (bself == NULL) return bself;
        PyoaVectorBitNameObject* self = (PyoaVectorBitNameObject*)bself;
        self->value = (oaNameBase*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVectorBitName_append_doc[] = 
"Class: oaVectorBitName, Function: append\n"
"  Paramegers: (oaNameSpace,[oaChar],oaUInt4,oaUInt4)\n"
"    Calls: void append(const oaNameSpace& nSpace,const oaChar* in,oaUInt4 len,oaUInt4 flags)\n"
"    Signature: append|void-void|cref-oaNameSpace,cptr-oaChar,simple-oaUInt4,simple-oaUInt4,\n"
"    Function append\n"
;

static PyObject*
oaVectorBitName_append(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorBitName data;
    int convert_status=PyoaVectorBitName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorBitNameObject* self=(PyoaVectorBitNameObject*)ob;

    PyParamoaNameSpace p1;
    PyParamoaChar_Array p2;
    PyParamoaUInt4 p3;
    PyParamoaUInt4 p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaNameSpace_Convert,&p1,
          &PyoaChar_Array_Convert,&p2,
          &PyoaUInt4_Convert,&p3,
          &PyoaUInt4_Convert,&p4)) {
        data.DataCall()->append(p1.Data(),p2.Data(),p3.Data(),p4.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorBitName_get_doc[] = 
"Class: oaVectorBitName, Function: get\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void get(const oaNameSpace& nSpace,oaString& out) const\n"
"    Signature: get|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns this name mapped into the specified nameSpace.\n"
"    nSpace\n"
"    The nameSpace in which to map this name\n"
"    out\n"
"    The string in which to output the mapped name\n"
"  Paramegers: (oaString)\n"
"    Calls: void get(oaString& out) const\n"
"    Signature: get|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function returns this name mapped into the oaNative nameSpace.\n"
"    out\n"
"    The string in which to output the mapped name\n"
;

static PyObject*
oaVectorBitName_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorBitName data;
    int convert_status=PyoaVectorBitName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorBitNameObject* self=(PyoaVectorBitNameObject*)ob;

    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->get(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            data.DataCall()->get(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVectorBitName, function: get, Choices are:\n"
        "    (oaNameSpace,oaString)\n"
        "    (oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorBitName_getBaseName_doc[] = 
"Class: oaVectorBitName, Function: getBaseName\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getBaseName(const oaNameSpace& nSpace,oaString& out) const\n"
"    Signature: getBaseName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the base value of this name mapped into the specified nameSpace.\n"
"    nSpace\n"
"    The nameSpace in which to map the base value of this name\n"
"    out\n"
"    The string in which to output the mapped name\n"
"  Paramegers: (oaString)\n"
"    Calls: void getBaseName(oaString& out) const\n"
"    Signature: getBaseName|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function returns the base value of this name mapped into the oaNative nameSpace.\n"
"    out\n"
"    The string in which to output the base value of this name\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getBaseName(oaScalarName& out) const\n"
"    Signature: getBaseName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the base value of this name.\n"
"    out\n"
"    The oaScalarName in which to output the base value of this name\n"
;

static PyObject*
oaVectorBitName_getBaseName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorBitName data;
    int convert_status=PyoaVectorBitName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorBitNameObject* self=(PyoaVectorBitNameObject*)ob;

    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getBaseName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            data.DataCall()->getBaseName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getBaseName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVectorBitName, function: getBaseName, Choices are:\n"
        "    (oaNameSpace,oaString)\n"
        "    (oaString)\n"
        "    (oaScalarName)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorBitName_getIndex_doc[] = 
"Class: oaVectorBitName, Function: getIndex\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getIndex() const\n"
"    Signature: getIndex|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the bit index of this vectorbit name.\n"
;

static PyObject*
oaVectorBitName_getIndex(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorBitName data;
    int convert_status=PyoaVectorBitName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorBitNameObject* self=(PyoaVectorBitNameObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getIndex());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorBitName_getNumBits_doc[] = 
"Class: oaVectorBitName, Function: getNumBits\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumBits() const\n"
"    Signature: getNumBits|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of bits this name represents.\n"
;

static PyObject*
oaVectorBitName_getNumBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorBitName data;
    int convert_status=PyoaVectorBitName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorBitNameObject* self=(PyoaVectorBitNameObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumBits());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorBitName_init_doc[] = 
"Class: oaVectorBitName, Function: init\n"
"  Paramegers: (oaNameSpace,[oaChar])\n"
"    Calls: void init(const oaNameSpace& nSpace,const oaChar* in)\n"
"    Signature: init|void-void|cref-oaNameSpace,cptr-oaChar,simple-oaBoolean,\n"
"    This function allows reuse of the oaVectorBitName object in order to improve application performance and capacity. This function initializes the name by clearing any previously stored name data, then re-initializing its value to the string specified by in , evaluating the string in the specified namespace.\n"
"    The optional boolean argument baseOnly indicates if the input name is interpreted as the base portion of the vectorbit name or as the entire name -- for example, with nSpace set to the oaVerilog namespace, baseOnly equal to true, and in specified as \"abc[3]\".\n"
"    nSpace\n"
"    The oaNameSpace in which to evaluate the string\n"
"    in\n"
"    The input string, which may specify the base name only (if baseOnly is true) or the entire name (if baseOnly is false)\n"
"    baseOnly\n"
"    A boolean value that indicates if the input string is an entire vectorbit name or only the base portion\n"
"    oacInvalidNameLength\n"
"    oacInvalidNameSyntax\n"
"  Paramegers: (oaNameSpace,[oaChar],oaBoolean)\n"
"    Calls: void init(const oaNameSpace& nSpace,const oaChar* in,oaBoolean baseOnly)\n"
"    Signature: init|void-void|cref-oaNameSpace,cptr-oaChar,simple-oaBoolean,\n"
"    This function allows reuse of the oaVectorBitName object in order to improve application performance and capacity. This function initializes the name by clearing any previously stored name data, then re-initializing its value to the string specified by in , evaluating the string in the specified namespace.\n"
"    The optional boolean argument baseOnly indicates if the input name is interpreted as the base portion of the vectorbit name or as the entire name -- for example, with nSpace set to the oaVerilog namespace, baseOnly equal to true, and in specified as \"abc[3]\".\n"
"    nSpace\n"
"    The oaNameSpace in which to evaluate the string\n"
"    in\n"
"    The input string, which may specify the base name only (if baseOnly is true) or the entire name (if baseOnly is false)\n"
"    baseOnly\n"
"    A boolean value that indicates if the input string is an entire vectorbit name or only the base portion\n"
"    oacInvalidNameLength\n"
"    oacInvalidNameSyntax\n"
;

static PyObject*
oaVectorBitName_init(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorBitName data;
    int convert_status=PyoaVectorBitName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorBitNameObject* self=(PyoaVectorBitNameObject*)ob;

    // Case: (oaNameSpace,[oaChar])
    {
        PyParamoaNameSpace p1;
        PyParamoaChar_Array p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaChar_Array_Convert,&p2)) {
            data.DataCall()->init(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,[oaChar],oaBoolean)
    {
        PyParamoaNameSpace p1;
        PyParamoaChar_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaChar_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            data.DataCall()->init(p1.Data(),p2.Data(),p3.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVectorBitName, function: init, Choices are:\n"
        "    (oaNameSpace,[oaChar])\n"
        "    (oaNameSpace,[oaChar],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorBitName_setIndex_doc[] = 
"Class: oaVectorBitName, Function: setIndex\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setIndex(oaUInt4 val)\n"
"    Signature: setIndex|void-void|simple-oaUInt4,\n"
"    This function sets the bit value for this oaVectorBitName to the specified value.\n"
;

static PyObject*
oaVectorBitName_setIndex(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorBitName data;
    int convert_status=PyoaVectorBitName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorBitNameObject* self=(PyoaVectorBitNameObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setIndex(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaVectorBitName_assign_doc[] = 
"Class: oaVectorBitName, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVectorBitName_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVectorBitName data;
  int convert_status=PyoaVectorBitName_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVectorBitName p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVectorBitName_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVectorBitName_methodlist[] = {
    {"append",(PyCFunction)oaVectorBitName_append,METH_VARARGS,oaVectorBitName_append_doc},
    {"get",(PyCFunction)oaVectorBitName_get,METH_VARARGS,oaVectorBitName_get_doc},
    {"getBaseName",(PyCFunction)oaVectorBitName_getBaseName,METH_VARARGS,oaVectorBitName_getBaseName_doc},
    {"getIndex",(PyCFunction)oaVectorBitName_getIndex,METH_VARARGS,oaVectorBitName_getIndex_doc},
    {"getNumBits",(PyCFunction)oaVectorBitName_getNumBits,METH_VARARGS,oaVectorBitName_getNumBits_doc},
    {"init",(PyCFunction)oaVectorBitName_init,METH_VARARGS,oaVectorBitName_init_doc},
    {"setIndex",(PyCFunction)oaVectorBitName_setIndex,METH_VARARGS,oaVectorBitName_setIndex_doc},
    {"assign",(PyCFunction)oaVectorBitName_tp_assign,METH_VARARGS,oaVectorBitName_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVectorBitName_doc[] = 
"Class: oaVectorBitName\n"
"  The oaVectorBitName utility class represents the name for an object that has a base name and a single index number. This will be the name of an object that is a single bit of a vector. The name can be hierarchical. In conjunction with oaNameSpace objects, this class facilitates mapping names from one nameSpace to another. See the Name Mapping Section of the Programmers Guide for more information about mapping names between different namespaces.\n"
"  A vector bit name has a base name and an index. An example of an oaVectorBitName in the Verilog namespace is test[3] , where the base name is test and the index is 3 .\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaVectorBitName()\n"
"    Signature: oaVectorBitName||\n"
"    This function constructs an empty oaVectorBitName object.\n"
"  Paramegers: (oaNameSpace,[oaChar])\n"
"    Calls: oaVectorBitName(const oaNameSpace& nSpace,const oaChar* in)\n"
"    Signature: oaVectorBitName||cref-oaNameSpace,cptr-oaChar,\n"
"    This function constructs an oaVectorBitName object, evaluating the specified input string in the specified nameSpace.\n"
"    nSpace\n"
"    The nameSpace in which to evaluate the string\n"
"    in\n"
"    The input string to evaluate\n"
"    oacInvalidNameLength\n"
"    oacInvalidNameSyntax\n"
"  Paramegers: (oaNameSpace,[oaChar],oaUInt4)\n"
"    Calls: oaVectorBitName(const oaNameSpace& nSpace,const oaChar* in,oaUInt4 index)\n"
"    Signature: oaVectorBitName||cref-oaNameSpace,cptr-oaChar,simple-oaUInt4,\n"
"    This function constructs an oaVectorBitName object, evaluating the specified input string in the specified nameSpace. The input string is assumed to be the base portion of the name.\n"
"    nSpace\n"
"    The nameSpace in which to evaluate the string\n"
"    in\n"
"    The input string to evaluate as the base name\n"
"    index\n"
"    The bit value for the name\n"
"    oacInvalidNameLength\n"
"    oacInvalidNameSyntax\n"
"  Paramegers: (oaScalarName,oaUInt4)\n"
"    Calls: oaVectorBitName(const oaScalarName& in,oaUInt4 index)\n"
"    Signature: oaVectorBitName||cref-oaScalarName,simple-oaUInt4,\n"
"    This function constructs an oaVectorBitName object by accepting an oaScalarName that represents the base name of the vector bit, plus an index that represents the bit value of the name.\n"
"    in\n"
"    The base value of this name represented as an oaScalarName\n"
"    index\n"
"    The bit value for the name\n"
"  Paramegers: (oaVectorBitName)\n"
"    Calls: oaVectorBitName(const oaVectorBitName& name)\n"
"    Signature: oaVectorBitName||cref-oaVectorBitName,\n"
"    This function constructs a copy of the specified oaVectorBitName object.\n"
"  Paramegers: (oaVectorBitName)\n"
"    Calls: (const oaVectorBitName&)\n"
"    Signature: oaVectorBitName||cref-oaVectorBitName,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVectorBitName_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVectorBitName",
    sizeof(PyoaVectorBitNameObject),
    0,
    (destructor)oaVectorBitName_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVectorBitName_tp_compare,	/* tp_compare */
    (reprfunc)oaVectorBitName_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVectorBitName_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVectorBitName_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaNameBase_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVectorBitName_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVectorBitName_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVectorBitName_Type)<0) {
      printf("** PyType_Ready failed for: oaVectorBitName\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVectorBitName",
           (PyObject*)(&PyoaVectorBitName_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVectorBitName\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVectorInst
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVectorInst_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVectorInst_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVectorInstObject* self = (PyoaVectorInstObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaVectorInst)
    {
        PyParamoaVectorInst p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVectorInst_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVectorInst, Choices are:\n"
        "    (oaVectorInst)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVectorInst_tp_dealloc(PyoaVectorInstObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVectorInst_tp_repr(PyObject *ob)
{
    PyParamoaVectorInst value;
    int convert_status=PyoaVectorInst_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaVectorInst::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaSimpleName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[34];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaVectorInst::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVectorInst_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVectorInst v1;
    PyParamoaVectorInst v2;
    int convert_status1=PyoaVectorInst_Convert(ob1,&v1);
    int convert_status2=PyoaVectorInst_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVectorInst_Convert(PyObject* ob,PyParamoaVectorInst* result)
{
    if (ob == NULL) return 1;
    if (PyoaVectorInst_Check(ob)) {
        result->SetData( (oaVectorInst**) ((PyoaVectorInstObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVectorInst Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVectorInst_FromoaVectorInst(oaVectorInst** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaVectorInst* data=*value;
        PyObject* bself = PyoaVectorInst_Type.tp_alloc(&PyoaVectorInst_Type,0);
        if (bself == NULL) return bself;
        PyoaVectorInstObject* self = (PyoaVectorInstObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaVectorInst_FromoaVectorInst(oaVectorInst* data)
{
    if (data) {
       PyObject* bself = PyoaVectorInst_Type.tp_alloc(&PyoaVectorInst_Type,0);
       if (bself == NULL) return bself;
       PyoaVectorInstObject* self = (PyoaVectorInstObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVectorInst_getBit_doc[] = 
"Class: oaVectorInst, Function: getBit\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaVectorInstBit* getBit(oaUInt4 bitIndex) const\n"
"    Signature: getBit|ptr-oaVectorInstBit|simple-oaUInt4,\n"
"    This function returns a pointer to the vectorInstBit that corresponds to the specified bitIndex bit of this vectorInst. For example, if this is a vectorInst \"i[7:0]\" and bitIndex is zero, this function will return the vectorInstBit corresponding to \"i[7]\".\n"
"    bitIndex\n"
"    Specifies which bit of the instance to return\n"
"    A pointer to an oaVectorInstBit\n"
"    oacInvalidBitIndexIntoInst\n"
;

static PyObject*
oaVectorInst_getBit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorInst data;
    int convert_status=PyoaVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorInstObject* self=(PyoaVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaVectorInstBitp result= (data.DataCall()->getBit(p1.Data()));
        return PyoaVectorInstBit_FromoaVectorInstBit(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInst_getDef_doc[] = 
"Class: oaVectorInst, Function: getDef\n"
"  Paramegers: ()\n"
"    Calls: oaVectorInstDef* getDef() const\n"
"    Signature: getDef|ptr-oaVectorInstDef|\n"
"    BrowseData: 1\n"
"    This function returns the vectorInstDef for this vectorInst. The vectorInstDef is used to access all vectorInts with the same baseName.\n"
;

static PyObject*
oaVectorInst_getDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorInst data;
    int convert_status=PyoaVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorInstObject* self=(PyoaVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaVectorInstDefp result= (data.DataCall()->getDef());
        return PyoaVectorInstDef_FromoaVectorInstDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInst_getName_doc[] = 
"Class: oaVectorInst, Function: getName\n"
"  Paramegers: (oaVectorName)\n"
"    Calls: void getName(oaVectorName& name) const\n"
"    Signature: getName|void-void|ref-oaVectorName,\n"
"    BrowseData: 0,oaVectorName\n"
"    This function returns the vectorName of this vectorInst.\n"
"    name\n"
"    The vectorName of the vectorInst to return\n"
"  Paramegers: (oaSimpleName)\n"
"    Calls: void getName(oaSimpleName& name) const\n"
"    Signature: getName|void-void|ref-oaSimpleName,\n"
"    BrowseData: 0,oaSimpleName\n"
"    This function fills out name with the name of this instance.\n"
"    name\n"
"    The returned instance name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function fills out name with the name of this instance. The name is mapped according to the specified nameSpace.\n"
"    ns\n"
"    The nameSpace used to map the name\n"
"    name\n"
"    The returned instance name\n"
;

static PyObject*
oaVectorInst_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorInst data;
    int convert_status=PyoaVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorInstObject* self=(PyoaVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaVectorName)
    {
        PyParamoaVectorName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName)
    {
        PyParamoaSimpleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSimpleName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVectorInst, function: getName, Choices are:\n"
        "    (oaVectorName)\n"
        "    (oaSimpleName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInst_getStart_doc[] = 
"Class: oaVectorInst, Function: getStart\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getStart() const\n"
"    Signature: getStart|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the start index of this vectorInst.\n"
;

static PyObject*
oaVectorInst_getStart(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorInst data;
    int convert_status=PyoaVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorInstObject* self=(PyoaVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getStart());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInst_getStop_doc[] = 
"Class: oaVectorInst, Function: getStop\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getStop() const\n"
"    Signature: getStop|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the stop index of this vectorInst.\n"
;

static PyObject*
oaVectorInst_getStop(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorInst data;
    int convert_status=PyoaVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorInstObject* self=(PyoaVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getStop());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInst_setBaseName_doc[] = 
"Class: oaVectorInst, Function: setBaseName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void setBaseName(const oaScalarName& baseName)\n"
"    Signature: setBaseName|void-void|cref-oaScalarName,\n"
"    This function changes the base name of this vectorInst. Exceptions are thrown if the new name is the name of an existing scalar, an arrayInst, or if another vectorInst exists whose indices overlap with this vectorInst, or if the given baseName matches the form of the system-generated scalarInst name.\n"
"    baseName\n"
"    The new base name to give this instance\n"
"    oacCannotSetNameOfImplicitInst\n"
;

static PyObject*
oaVectorInst_setBaseName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorInst data;
    int convert_status=PyoaVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorInstObject* self=(PyoaVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScalarName p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaScalarName_Convert,&p1)) {
        data.DataCall()->setBaseName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInst_setRange_doc[] = 
"Class: oaVectorInst, Function: setRange\n"
"  Paramegers: (oaUInt4,oaUInt4)\n"
"    Calls: void setRange(oaUInt4 start,oaUInt4 stop)\n"
"    Signature: setRange|void-void|simple-oaUInt4,simple-oaUInt4,\n"
"    This function sets the start and stop bit indices of this vectorInst.\n"
"    start\n"
"    The new start value to give this instance\n"
"    stop\n"
"    The new stop value to give this instance\n"
"    oacInstNameOverlapsOtherInst\n"
"    oacCannotSetNameOfImplicitInst\n"
"    oacInvalidBusStartStopRange\n"
;

static PyObject*
oaVectorInst_setRange(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorInst data;
    int convert_status=PyoaVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorInstObject* self=(PyoaVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2)) {
        data.DataCall()->setRange(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInst_isNull_doc[] =
"Class: oaVectorInst, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaVectorInst_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaVectorInst data;
    int convert_status=PyoaVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaVectorInst_assign_doc[] = 
"Class: oaVectorInst, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVectorInst_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVectorInst data;
  int convert_status=PyoaVectorInst_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVectorInst p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVectorInst_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVectorInst_methodlist[] = {
    {"getBit",(PyCFunction)oaVectorInst_getBit,METH_VARARGS,oaVectorInst_getBit_doc},
    {"getDef",(PyCFunction)oaVectorInst_getDef,METH_VARARGS,oaVectorInst_getDef_doc},
    {"getName",(PyCFunction)oaVectorInst_getName,METH_VARARGS,oaVectorInst_getName_doc},
    {"getStart",(PyCFunction)oaVectorInst_getStart,METH_VARARGS,oaVectorInst_getStart_doc},
    {"getStop",(PyCFunction)oaVectorInst_getStop,METH_VARARGS,oaVectorInst_getStop_doc},
    {"setBaseName",(PyCFunction)oaVectorInst_setBaseName,METH_VARARGS,oaVectorInst_setBaseName_doc},
    {"setRange",(PyCFunction)oaVectorInst_setRange,METH_VARARGS,oaVectorInst_setRange_doc},
    {"isNull",(PyCFunction)oaVectorInst_tp_isNull,METH_VARARGS,oaVectorInst_isNull_doc},
    {"assign",(PyCFunction)oaVectorInst_tp_assign,METH_VARARGS,oaVectorInst_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVectorInst_doc[] = 
"Class: oaVectorInst\n"
"  The oaVectorInst class implements a vector instance in a block hierarchy. A vector instance represents several copies of the instance master with a range of index numbers to differentiate them.\n"
"  oaVectorInst objects are always in the block domain. They may be physical-only instances that are only in the block hierarchy, or they can be cross-domain instances that directly correspond to an oaModVectorInst in the module domain and an oaOccVectorInst in the occurrence domain.\n"
"  Note that there are many differences between the structure of VectorInsts and BusNets. A single VectorInst must have contiguous index numbers. While there can be multiple VectorInsts with the same base name, they must have no overlapping index numbers. A gap between the index numbers is allowed. For example, a block may have instances Ireg<3:0> and Ireg<7:6> (in a namespace that uses <> for bit indexes). However, it may not also have Ireg<5:3> since that would create 2 copies of Ireg<3>.\n"
"Constructors:\n"
"  Paramegers: (oaVectorInst)\n"
"    Calls: (const oaVectorInst&)\n"
"    Signature: oaVectorInst||cref-oaVectorInst,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVectorInst_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVectorInst",
    sizeof(PyoaVectorInstObject),
    0,
    (destructor)oaVectorInst_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVectorInst_tp_compare,	/* tp_compare */
    (reprfunc)oaVectorInst_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVectorInst_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVectorInst_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaInst_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVectorInst_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVectorInst_static_create_doc[] = 
"Class: oaVectorInst, Function: create\n"
"  Paramegers: (oaBlock,oaDesign,oaScalarName,oaUInt4,oaUInt4,oaTransform)\n"
"    Calls: oaVectorInst* create(oaBlock* block,oaDesign* master,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop,const oaTransform& xform)\n"
"    Signature: create|ptr-oaVectorInst|ptr-oaBlock,ptr-oaDesign,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,cref-oaTransform,cptr-oaParamArray,simple-oaBlockDomainVisibility,simple-oaPlacementStatus,\n"
"    This function creates an oaVectorInst object with the specified attributes. The specified baseName , start , and stop indices are first checked to verify they are legal and do not specify an instance that already exists. This form of the create specifies the master design so the master needs to be open to use it. You can also specify an optional paramArray if the master is a pCell. Exceptions are thrown if the new name is the name of an existing scalar, an arrayInst, or if another vectorInst exists whose indices overlap with this vectorInst, or if the given baseName matches the form of the system generated scalarInst name.\n"
"    oacInvalidSuperMaster\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"  Paramegers: (oaBlock,oaDesign,oaScalarName,oaUInt4,oaUInt4,oaTransform,oaParamArray)\n"
"    Calls: oaVectorInst* create(oaBlock* block,oaDesign* master,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop,const oaTransform& xform,const oaParamArray* params)\n"
"    Signature: create|ptr-oaVectorInst|ptr-oaBlock,ptr-oaDesign,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,cref-oaTransform,cptr-oaParamArray,simple-oaBlockDomainVisibility,simple-oaPlacementStatus,\n"
"    This function creates an oaVectorInst object with the specified attributes. The specified baseName , start , and stop indices are first checked to verify they are legal and do not specify an instance that already exists. This form of the create specifies the master design so the master needs to be open to use it. You can also specify an optional paramArray if the master is a pCell. Exceptions are thrown if the new name is the name of an existing scalar, an arrayInst, or if another vectorInst exists whose indices overlap with this vectorInst, or if the given baseName matches the form of the system generated scalarInst name.\n"
"    oacInvalidSuperMaster\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"  Paramegers: (oaBlock,oaDesign,oaScalarName,oaUInt4,oaUInt4,oaTransform,oaParamArray,oaBlockDomainVisibility)\n"
"    Calls: oaVectorInst* create(oaBlock* block,oaDesign* master,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop,const oaTransform& xform,const oaParamArray* params,oaBlockDomainVisibility view)\n"
"    Signature: create|ptr-oaVectorInst|ptr-oaBlock,ptr-oaDesign,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,cref-oaTransform,cptr-oaParamArray,simple-oaBlockDomainVisibility,simple-oaPlacementStatus,\n"
"    This function creates an oaVectorInst object with the specified attributes. The specified baseName , start , and stop indices are first checked to verify they are legal and do not specify an instance that already exists. This form of the create specifies the master design so the master needs to be open to use it. You can also specify an optional paramArray if the master is a pCell. Exceptions are thrown if the new name is the name of an existing scalar, an arrayInst, or if another vectorInst exists whose indices overlap with this vectorInst, or if the given baseName matches the form of the system generated scalarInst name.\n"
"    oacInvalidSuperMaster\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"  Paramegers: (oaBlock,oaDesign,oaScalarName,oaUInt4,oaUInt4,oaTransform,oaParamArray,oaBlockDomainVisibility,oaPlacementStatus)\n"
"    Calls: oaVectorInst* create(oaBlock* block,oaDesign* master,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop,const oaTransform& xform,const oaParamArray* params,oaBlockDomainVisibility view,oaPlacementStatus status)\n"
"    Signature: create|ptr-oaVectorInst|ptr-oaBlock,ptr-oaDesign,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,cref-oaTransform,cptr-oaParamArray,simple-oaBlockDomainVisibility,simple-oaPlacementStatus,\n"
"    This function creates an oaVectorInst object with the specified attributes. The specified baseName , start , and stop indices are first checked to verify they are legal and do not specify an instance that already exists. This form of the create specifies the master design so the master needs to be open to use it. You can also specify an optional paramArray if the master is a pCell. Exceptions are thrown if the new name is the name of an existing scalar, an arrayInst, or if another vectorInst exists whose indices overlap with this vectorInst, or if the given baseName matches the form of the system generated scalarInst name.\n"
"    oacInvalidSuperMaster\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"  Paramegers: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaUInt4,oaTransform)\n"
"    Calls: oaVectorInst* create(oaBlock* block,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop,const oaTransform& xform)\n"
"    Signature: create|ptr-oaVectorInst|ptr-oaBlock,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,cref-oaTransform,cptr-oaParamArray,simple-oaBlockDomainVisibility,simple-oaPlacementStatus,\n"
"    This function creates an oaVectorInst object with the specified attributes. The specified baseName , start , and stop indices are first checked to verify they are legal and do not specify an instance that already exists. This form of the create specifies its library, cell, and view names so the master does not need to be open to create instances. You can also specify an optional paramArray that will apply if the master is a pCell. Exceptions are thrown if the new name is the name of an existing scalarInst or an arrayInst, or if another vectorInst exists whose indices overlap with this vectorInst, or if the given baseName matches the form of the system-generated scalarInst name.\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"  Paramegers: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaUInt4,oaTransform,oaParamArray)\n"
"    Calls: oaVectorInst* create(oaBlock* block,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop,const oaTransform& xform,const oaParamArray* params)\n"
"    Signature: create|ptr-oaVectorInst|ptr-oaBlock,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,cref-oaTransform,cptr-oaParamArray,simple-oaBlockDomainVisibility,simple-oaPlacementStatus,\n"
"    This function creates an oaVectorInst object with the specified attributes. The specified baseName , start , and stop indices are first checked to verify they are legal and do not specify an instance that already exists. This form of the create specifies its library, cell, and view names so the master does not need to be open to create instances. You can also specify an optional paramArray that will apply if the master is a pCell. Exceptions are thrown if the new name is the name of an existing scalarInst or an arrayInst, or if another vectorInst exists whose indices overlap with this vectorInst, or if the given baseName matches the form of the system-generated scalarInst name.\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"  Paramegers: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaUInt4,oaTransform,oaParamArray,oaBlockDomainVisibility)\n"
"    Calls: oaVectorInst* create(oaBlock* block,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop,const oaTransform& xform,const oaParamArray* params,oaBlockDomainVisibility view)\n"
"    Signature: create|ptr-oaVectorInst|ptr-oaBlock,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,cref-oaTransform,cptr-oaParamArray,simple-oaBlockDomainVisibility,simple-oaPlacementStatus,\n"
"    This function creates an oaVectorInst object with the specified attributes. The specified baseName , start , and stop indices are first checked to verify they are legal and do not specify an instance that already exists. This form of the create specifies its library, cell, and view names so the master does not need to be open to create instances. You can also specify an optional paramArray that will apply if the master is a pCell. Exceptions are thrown if the new name is the name of an existing scalarInst or an arrayInst, or if another vectorInst exists whose indices overlap with this vectorInst, or if the given baseName matches the form of the system-generated scalarInst name.\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"  Paramegers: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaUInt4,oaTransform,oaParamArray,oaBlockDomainVisibility,oaPlacementStatus)\n"
"    Calls: oaVectorInst* create(oaBlock* block,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop,const oaTransform& xform,const oaParamArray* params,oaBlockDomainVisibility view,oaPlacementStatus status)\n"
"    Signature: create|ptr-oaVectorInst|ptr-oaBlock,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,cref-oaTransform,cptr-oaParamArray,simple-oaBlockDomainVisibility,simple-oaPlacementStatus,\n"
"    This function creates an oaVectorInst object with the specified attributes. The specified baseName , start , and stop indices are first checked to verify they are legal and do not specify an instance that already exists. This form of the create specifies its library, cell, and view names so the master does not need to be open to create instances. You can also specify an optional paramArray that will apply if the master is a pCell. Exceptions are thrown if the new name is the name of an existing scalarInst or an arrayInst, or if another vectorInst exists whose indices overlap with this vectorInst, or if the given baseName matches the form of the system-generated scalarInst name.\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
;

static PyObject*
oaVectorInst_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaBlock,oaDesign,oaScalarName,oaUInt4,oaUInt4,oaTransform)
    {
        PyParamoaBlock p1;
        PyParamoaDesign p2;
        PyParamoaScalarName p3;
        PyParamoaUInt4 p4;
        PyParamoaUInt4 p5;
        PyParamoaTransform p6;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaDesign_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaUInt4_Convert,&p5,
              &PyoaTransform_Convert,&p6)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVectorInstp result= (oaVectorInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data()));
            return PyoaVectorInst_FromoaVectorInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaDesign,oaScalarName,oaUInt4,oaUInt4,oaTransform,oaParamArray)
    {
        PyParamoaBlock p1;
        PyParamoaDesign p2;
        PyParamoaScalarName p3;
        PyParamoaUInt4 p4;
        PyParamoaUInt4 p5;
        PyParamoaTransform p6;
        PyParamoaParamArray p7;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaDesign_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaUInt4_Convert,&p5,
              &PyoaTransform_Convert,&p6,
              &PyoaParamArray_ConvertAof,&p7)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVectorInstp result= (oaVectorInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.DataAof()));
            return PyoaVectorInst_FromoaVectorInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaDesign,oaScalarName,oaUInt4,oaUInt4,oaTransform,oaParamArray,oaBlockDomainVisibility)
    {
        PyParamoaBlock p1;
        PyParamoaDesign p2;
        PyParamoaScalarName p3;
        PyParamoaUInt4 p4;
        PyParamoaUInt4 p5;
        PyParamoaTransform p6;
        PyParamoaParamArray p7;
        PyParamoaBlockDomainVisibility p8;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaDesign_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaUInt4_Convert,&p5,
              &PyoaTransform_Convert,&p6,
              &PyoaParamArray_ConvertAof,&p7,
              &PyoaBlockDomainVisibility_Convert,&p8)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVectorInstp result= (oaVectorInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.DataAof(),p8.Data()));
            return PyoaVectorInst_FromoaVectorInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaDesign,oaScalarName,oaUInt4,oaUInt4,oaTransform,oaParamArray,oaBlockDomainVisibility,oaPlacementStatus)
    {
        PyParamoaBlock p1;
        PyParamoaDesign p2;
        PyParamoaScalarName p3;
        PyParamoaUInt4 p4;
        PyParamoaUInt4 p5;
        PyParamoaTransform p6;
        PyParamoaParamArray p7;
        PyParamoaBlockDomainVisibility p8;
        PyParamoaPlacementStatus p9;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaDesign_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaUInt4_Convert,&p5,
              &PyoaTransform_Convert,&p6,
              &PyoaParamArray_ConvertAof,&p7,
              &PyoaBlockDomainVisibility_Convert,&p8,
              &PyoaPlacementStatus_Convert,&p9)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVectorInstp result= (oaVectorInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.DataAof(),p8.Data(),p9.Data()));
            return PyoaVectorInst_FromoaVectorInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaUInt4,oaTransform)
    {
        PyParamoaBlock p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        PyParamoaScalarName p5;
        PyParamoaUInt4 p6;
        PyParamoaUInt4 p7;
        PyParamoaTransform p8;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4,
              &PyoaScalarName_Convert,&p5,
              &PyoaUInt4_Convert,&p6,
              &PyoaUInt4_Convert,&p7,
              &PyoaTransform_Convert,&p8)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaVectorInstp result= (oaVectorInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.Data()));
            return PyoaVectorInst_FromoaVectorInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaUInt4,oaTransform,oaParamArray)
    {
        PyParamoaBlock p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        PyParamoaScalarName p5;
        PyParamoaUInt4 p6;
        PyParamoaUInt4 p7;
        PyParamoaTransform p8;
        PyParamoaParamArray p9;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4,
              &PyoaScalarName_Convert,&p5,
              &PyoaUInt4_Convert,&p6,
              &PyoaUInt4_Convert,&p7,
              &PyoaTransform_Convert,&p8,
              &PyoaParamArray_ConvertAof,&p9)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaVectorInstp result= (oaVectorInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.Data(),p9.DataAof()));
            return PyoaVectorInst_FromoaVectorInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaUInt4,oaTransform,oaParamArray,oaBlockDomainVisibility)
    {
        PyParamoaBlock p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        PyParamoaScalarName p5;
        PyParamoaUInt4 p6;
        PyParamoaUInt4 p7;
        PyParamoaTransform p8;
        PyParamoaParamArray p9;
        PyParamoaBlockDomainVisibility p10;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4,
              &PyoaScalarName_Convert,&p5,
              &PyoaUInt4_Convert,&p6,
              &PyoaUInt4_Convert,&p7,
              &PyoaTransform_Convert,&p8,
              &PyoaParamArray_ConvertAof,&p9,
              &PyoaBlockDomainVisibility_Convert,&p10)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaVectorInstp result= (oaVectorInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.Data(),p9.DataAof(),p10.Data()));
            return PyoaVectorInst_FromoaVectorInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaUInt4,oaTransform,oaParamArray,oaBlockDomainVisibility,oaPlacementStatus)
    {
        PyParamoaBlock p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        PyParamoaScalarName p5;
        PyParamoaUInt4 p6;
        PyParamoaUInt4 p7;
        PyParamoaTransform p8;
        PyParamoaParamArray p9;
        PyParamoaBlockDomainVisibility p10;
        PyParamoaPlacementStatus p11;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4,
              &PyoaScalarName_Convert,&p5,
              &PyoaUInt4_Convert,&p6,
              &PyoaUInt4_Convert,&p7,
              &PyoaTransform_Convert,&p8,
              &PyoaParamArray_ConvertAof,&p9,
              &PyoaBlockDomainVisibility_Convert,&p10,
              &PyoaPlacementStatus_Convert,&p11)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaVectorInstp result= (oaVectorInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.Data(),p9.DataAof(),p10.Data(),p11.Data()));
            return PyoaVectorInst_FromoaVectorInst(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVectorInst, function: create, Choices are:\n"
        "    (oaBlock,oaDesign,oaScalarName,oaUInt4,oaUInt4,oaTransform)\n"
        "    (oaBlock,oaDesign,oaScalarName,oaUInt4,oaUInt4,oaTransform,oaParamArray)\n"
        "    (oaBlock,oaDesign,oaScalarName,oaUInt4,oaUInt4,oaTransform,oaParamArray,oaBlockDomainVisibility)\n"
        "    (oaBlock,oaDesign,oaScalarName,oaUInt4,oaUInt4,oaTransform,oaParamArray,oaBlockDomainVisibility,oaPlacementStatus)\n"
        "    (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaUInt4,oaTransform)\n"
        "    (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaUInt4,oaTransform,oaParamArray)\n"
        "    (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaUInt4,oaTransform,oaParamArray,oaBlockDomainVisibility)\n"
        "    (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaUInt4,oaTransform,oaParamArray,oaBlockDomainVisibility,oaPlacementStatus)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInst_static_find_doc[] = 
"Class: oaVectorInst, Function: find\n"
"  Paramegers: (oaBlock,oaScalarName,oaUInt4,oaUInt4)\n"
"    Calls: oaVectorInst* find(const oaBlock* block,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop)\n"
"    Signature: find|ptr-oaVectorInst|cptr-oaBlock,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,\n"
"    This function searches the specified block for a vectorInst with the specified name and start or stop bits. The function returns the instance if it finds one. Otherwise, NULL is returned.\n"
;

static PyObject*
oaVectorInst_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaScalarName p2;
    PyParamoaUInt4 p3;
    PyParamoaUInt4 p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaUInt4_Convert,&p3,
          &PyoaUInt4_Convert,&p4)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaVectorInstp result= (oaVectorInst::find(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
        return PyoaVectorInst_FromoaVectorInst(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInst_static_isValidName_doc[] = 
"Class: oaVectorInst, Function: isValidName\n"
"  Paramegers: (oaBlock,oaScalarName,oaUInt4,oaUInt4)\n"
"    Calls: oaBoolean isValidName(const oaBlock* block,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop)\n"
"    Signature: isValidName|simple-oaBoolean|cptr-oaBlock,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,\n"
"    This function returns a boolean value that indicates if the specified baseName , combined with the start and stop values, is a valid new oaVectorInst in the specified design .\n"
;

static PyObject*
oaVectorInst_static_isValidName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaScalarName p2;
    PyParamoaUInt4 p3;
    PyParamoaUInt4 p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaUInt4_Convert,&p3,
          &PyoaUInt4_Convert,&p4)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (oaVectorInst::isValidName(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaVectorInst_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaVectorInst_static_create,METH_VARARGS,oaVectorInst_static_create_doc},
    {"static_find",(PyCFunction)oaVectorInst_static_find,METH_VARARGS,oaVectorInst_static_find_doc},
    {"static_isValidName",(PyCFunction)oaVectorInst_static_isValidName,METH_VARARGS,oaVectorInst_static_isValidName_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVectorInst_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVectorInst_Type)<0) {
      printf("** PyType_Ready failed for: oaVectorInst\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVectorInst",
           (PyObject*)(&PyoaVectorInst_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVectorInst\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaVectorInst_Type.tp_dict;
    for(method=oaVectorInst_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVectorInstBit
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVectorInstBit_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVectorInstBit_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVectorInstBitObject* self = (PyoaVectorInstBitObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaVectorInstBit)
    {
        PyParamoaVectorInstBit p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVectorInstBit_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVectorInstBit, Choices are:\n"
        "    (oaVectorInstBit)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVectorInstBit_tp_dealloc(PyoaVectorInstBitObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVectorInstBit_tp_repr(PyObject *ob)
{
    PyParamoaVectorInstBit value;
    int convert_status=PyoaVectorInstBit_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaVectorInstBit::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaSimpleName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[37];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaVectorInstBit::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVectorInstBit_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVectorInstBit v1;
    PyParamoaVectorInstBit v2;
    int convert_status1=PyoaVectorInstBit_Convert(ob1,&v1);
    int convert_status2=PyoaVectorInstBit_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVectorInstBit_Convert(PyObject* ob,PyParamoaVectorInstBit* result)
{
    if (ob == NULL) return 1;
    if (PyoaVectorInstBit_Check(ob)) {
        result->SetData( (oaVectorInstBit**) ((PyoaVectorInstBitObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVectorInstBit Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVectorInstBit_FromoaVectorInstBit(oaVectorInstBit** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaVectorInstBit* data=*value;
        PyObject* bself = PyoaVectorInstBit_Type.tp_alloc(&PyoaVectorInstBit_Type,0);
        if (bself == NULL) return bself;
        PyoaVectorInstBitObject* self = (PyoaVectorInstBitObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaVectorInstBit_FromoaVectorInstBit(oaVectorInstBit* data)
{
    if (data) {
       PyObject* bself = PyoaVectorInstBit_Type.tp_alloc(&PyoaVectorInstBit_Type,0);
       if (bself == NULL) return bself;
       PyoaVectorInstBitObject* self = (PyoaVectorInstBitObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVectorInstBit_getBitIndex_doc[] = 
"Class: oaVectorInstBit, Function: getBitIndex\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getBitIndex() const\n"
"    Signature: getBitIndex|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the bitIndex of this vectorInstBit.\n"
;

static PyObject*
oaVectorInstBit_getBitIndex(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorInstBit data;
    int convert_status=PyoaVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorInstBitObject* self=(PyoaVectorInstBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getBitIndex());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInstBit_getDef_doc[] = 
"Class: oaVectorInstBit, Function: getDef\n"
"  Paramegers: ()\n"
"    Calls: oaVectorInstDef* getDef() const\n"
"    Signature: getDef|ptr-oaVectorInstDef|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the vectorInstDef for this vectorInstBit.\n"
;

static PyObject*
oaVectorInstBit_getDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorInstBit data;
    int convert_status=PyoaVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorInstBitObject* self=(PyoaVectorInstBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaVectorInstDefp result= (data.DataCall()->getDef());
        return PyoaVectorInstDef_FromoaVectorInstDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInstBit_getName_doc[] = 
"Class: oaVectorInstBit, Function: getName\n"
"  Paramegers: (oaVectorBitName)\n"
"    Calls: void getName(oaVectorBitName& name) const\n"
"    Signature: getName|void-void|ref-oaVectorBitName,\n"
"    BrowseData: 0,oaVectorBitName\n"
"    This function returns the vectorName of this vectorInstBit.\n"
"    name\n"
"    The name of the vectorInstBit to return\n"
"  Paramegers: (oaSimpleName)\n"
"    Calls: void getName(oaSimpleName& name) const\n"
"    Signature: getName|void-void|ref-oaSimpleName,\n"
"    BrowseData: 0,oaSimpleName\n"
"    This function fills out name with the name of this instance.\n"
"    name\n"
"    The returned instance name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function fills out name with the name of this instance. The name is mapped according to the specified nameSpace.\n"
"    ns\n"
"    The nameSpace used to map the name\n"
"    name\n"
"    The returned instance name\n"
;

static PyObject*
oaVectorInstBit_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorInstBit data;
    int convert_status=PyoaVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorInstBitObject* self=(PyoaVectorInstBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaVectorBitName)
    {
        PyParamoaVectorBitName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorBitName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName)
    {
        PyParamoaSimpleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSimpleName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVectorInstBit, function: getName, Choices are:\n"
        "    (oaVectorBitName)\n"
        "    (oaSimpleName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInstBit_setName_doc[] = 
"Class: oaVectorInstBit, Function: setName\n"
"  Paramegers: (oaScalarName,oaUInt4)\n"
"    Calls: void setName(const oaScalarName& baseName,oaUInt4 bitIndex)\n"
"    Signature: setName|void-void|cref-oaScalarName,simple-oaUInt4,\n"
"    This function changes the name of this vectorInstBit. An exception is thrown if the new baseName is the name of an existing scalar or array instance or if a vectorInstBit already exists with the new name. An exception is also thrown if the new name would overlap with existing vectorInsts.\n"
"    baseName\n"
"    The new base name for this instance\n"
"    bitIndex\n"
"    The new bit index for this instance\n"
"    oacCannotSetNameOfImplicitInst\n"
;

static PyObject*
oaVectorInstBit_setName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorInstBit data;
    int convert_status=PyoaVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorInstBitObject* self=(PyoaVectorInstBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScalarName p1;
    PyParamoaUInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaScalarName_Convert,&p1,
          &PyoaUInt4_Convert,&p2)) {
        data.DataCall()->setName(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInstBit_isNull_doc[] =
"Class: oaVectorInstBit, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaVectorInstBit_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaVectorInstBit data;
    int convert_status=PyoaVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaVectorInstBit_assign_doc[] = 
"Class: oaVectorInstBit, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVectorInstBit_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVectorInstBit data;
  int convert_status=PyoaVectorInstBit_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVectorInstBit p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVectorInstBit_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVectorInstBit_methodlist[] = {
    {"getBitIndex",(PyCFunction)oaVectorInstBit_getBitIndex,METH_VARARGS,oaVectorInstBit_getBitIndex_doc},
    {"getDef",(PyCFunction)oaVectorInstBit_getDef,METH_VARARGS,oaVectorInstBit_getDef_doc},
    {"getName",(PyCFunction)oaVectorInstBit_getName,METH_VARARGS,oaVectorInstBit_getName_doc},
    {"setName",(PyCFunction)oaVectorInstBit_setName,METH_VARARGS,oaVectorInstBit_setName_doc},
    {"isNull",(PyCFunction)oaVectorInstBit_tp_isNull,METH_VARARGS,oaVectorInstBit_isNull_doc},
    {"assign",(PyCFunction)oaVectorInstBit_tp_assign,METH_VARARGS,oaVectorInstBit_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVectorInstBit_doc[] = 
"Class: oaVectorInstBit\n"
"  The oaVectorInstBit class implements a single bit of an oaVectorInst . VectorInstBits are automatically created and destroyed as vectorInsts are created or destroyed. Implicitly-created vectorInstBits cannot be modified to insure consistency with its defining vectorInst. Explicitly-created vectorInstBits define a unique bit of a vectorInst definition since the bits of a vectorInst are not allowed to overlap with other vectorInsts.\n"
"  oaVectorInstBit objects are always in the block domain. They can be physical-only instances that are only in the block hierarchy or they can be cross-domain instances that directly correspond to an oaModVectorInstBit in the module domain and an oaOccVectorInstBit in the occurrence domain.\n"
"Constructors:\n"
"  Paramegers: (oaVectorInstBit)\n"
"    Calls: (const oaVectorInstBit&)\n"
"    Signature: oaVectorInstBit||cref-oaVectorInstBit,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVectorInstBit_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVectorInstBit",
    sizeof(PyoaVectorInstBitObject),
    0,
    (destructor)oaVectorInstBit_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVectorInstBit_tp_compare,	/* tp_compare */
    (reprfunc)oaVectorInstBit_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVectorInstBit_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVectorInstBit_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaBitInst_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVectorInstBit_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVectorInstBit_static_create_doc[] = 
"Class: oaVectorInstBit, Function: create\n"
"  Paramegers: (oaBlock,oaDesign,oaScalarName,oaUInt4,oaTransform)\n"
"    Calls: oaVectorInstBit* create(oaBlock* block,oaDesign* master,const oaScalarName& baseName,oaUInt4 bitIndex,const oaTransform& xform)\n"
"    Signature: create|ptr-oaVectorInstBit|ptr-oaBlock,ptr-oaDesign,cref-oaScalarName,simple-oaUInt4,cref-oaTransform,cptr-oaParamArray,simple-oaBlockDomainVisibility,simple-oaPlacementStatus,\n"
"    This function creates an oaVectorInstBit object with the specified attributes. The given baseName and bitIndex are checked if they are legal and do not specify an instance that already exists. This version creates an instance of the specified master design. An optional array of parameters may be specified in the case where the master is a pCell.\n"
"    block\n"
"    The block in which to place the instance\n"
"    master\n"
"    The master of the design to instantiate\n"
"    baseName\n"
"    The base name for the instance\n"
"    bitIndex\n"
"    The bit index for the instance\n"
"    xform\n"
"    The transform used to place the instance\n"
"    params\n"
"    Optional parameter array for pCell instances\n"
"    view\n"
"    Specifies whether this instance is visible in the module domain\n"
"    status\n"
"    Specifies the placement status of this instance\n"
"    oacInvalidSuperMaster\n"
"    oacInvalidHierInstName\n"
"    oacVectorInstBitNameMatchesAutoName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"  Paramegers: (oaBlock,oaDesign,oaScalarName,oaUInt4,oaTransform,oaParamArray)\n"
"    Calls: oaVectorInstBit* create(oaBlock* block,oaDesign* master,const oaScalarName& baseName,oaUInt4 bitIndex,const oaTransform& xform,const oaParamArray* params)\n"
"    Signature: create|ptr-oaVectorInstBit|ptr-oaBlock,ptr-oaDesign,cref-oaScalarName,simple-oaUInt4,cref-oaTransform,cptr-oaParamArray,simple-oaBlockDomainVisibility,simple-oaPlacementStatus,\n"
"    This function creates an oaVectorInstBit object with the specified attributes. The given baseName and bitIndex are checked if they are legal and do not specify an instance that already exists. This version creates an instance of the specified master design. An optional array of parameters may be specified in the case where the master is a pCell.\n"
"    block\n"
"    The block in which to place the instance\n"
"    master\n"
"    The master of the design to instantiate\n"
"    baseName\n"
"    The base name for the instance\n"
"    bitIndex\n"
"    The bit index for the instance\n"
"    xform\n"
"    The transform used to place the instance\n"
"    params\n"
"    Optional parameter array for pCell instances\n"
"    view\n"
"    Specifies whether this instance is visible in the module domain\n"
"    status\n"
"    Specifies the placement status of this instance\n"
"    oacInvalidSuperMaster\n"
"    oacInvalidHierInstName\n"
"    oacVectorInstBitNameMatchesAutoName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"  Paramegers: (oaBlock,oaDesign,oaScalarName,oaUInt4,oaTransform,oaParamArray,oaBlockDomainVisibility)\n"
"    Calls: oaVectorInstBit* create(oaBlock* block,oaDesign* master,const oaScalarName& baseName,oaUInt4 bitIndex,const oaTransform& xform,const oaParamArray* params,oaBlockDomainVisibility view)\n"
"    Signature: create|ptr-oaVectorInstBit|ptr-oaBlock,ptr-oaDesign,cref-oaScalarName,simple-oaUInt4,cref-oaTransform,cptr-oaParamArray,simple-oaBlockDomainVisibility,simple-oaPlacementStatus,\n"
"    This function creates an oaVectorInstBit object with the specified attributes. The given baseName and bitIndex are checked if they are legal and do not specify an instance that already exists. This version creates an instance of the specified master design. An optional array of parameters may be specified in the case where the master is a pCell.\n"
"    block\n"
"    The block in which to place the instance\n"
"    master\n"
"    The master of the design to instantiate\n"
"    baseName\n"
"    The base name for the instance\n"
"    bitIndex\n"
"    The bit index for the instance\n"
"    xform\n"
"    The transform used to place the instance\n"
"    params\n"
"    Optional parameter array for pCell instances\n"
"    view\n"
"    Specifies whether this instance is visible in the module domain\n"
"    status\n"
"    Specifies the placement status of this instance\n"
"    oacInvalidSuperMaster\n"
"    oacInvalidHierInstName\n"
"    oacVectorInstBitNameMatchesAutoName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"  Paramegers: (oaBlock,oaDesign,oaScalarName,oaUInt4,oaTransform,oaParamArray,oaBlockDomainVisibility,oaPlacementStatus)\n"
"    Calls: oaVectorInstBit* create(oaBlock* block,oaDesign* master,const oaScalarName& baseName,oaUInt4 bitIndex,const oaTransform& xform,const oaParamArray* params,oaBlockDomainVisibility view,oaPlacementStatus status)\n"
"    Signature: create|ptr-oaVectorInstBit|ptr-oaBlock,ptr-oaDesign,cref-oaScalarName,simple-oaUInt4,cref-oaTransform,cptr-oaParamArray,simple-oaBlockDomainVisibility,simple-oaPlacementStatus,\n"
"    This function creates an oaVectorInstBit object with the specified attributes. The given baseName and bitIndex are checked if they are legal and do not specify an instance that already exists. This version creates an instance of the specified master design. An optional array of parameters may be specified in the case where the master is a pCell.\n"
"    block\n"
"    The block in which to place the instance\n"
"    master\n"
"    The master of the design to instantiate\n"
"    baseName\n"
"    The base name for the instance\n"
"    bitIndex\n"
"    The bit index for the instance\n"
"    xform\n"
"    The transform used to place the instance\n"
"    params\n"
"    Optional parameter array for pCell instances\n"
"    view\n"
"    Specifies whether this instance is visible in the module domain\n"
"    status\n"
"    Specifies the placement status of this instance\n"
"    oacInvalidSuperMaster\n"
"    oacInvalidHierInstName\n"
"    oacVectorInstBitNameMatchesAutoName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"  Paramegers: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaTransform)\n"
"    Calls: oaVectorInstBit* create(oaBlock* block,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName,const oaScalarName& baseName,oaUInt4 bitIndex,const oaTransform& xform)\n"
"    Signature: create|ptr-oaVectorInstBit|ptr-oaBlock,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,simple-oaUInt4,cref-oaTransform,cptr-oaParamArray,simple-oaBlockDomainVisibility,simple-oaPlacementStatus,\n"
"    This function creates an oaVectorInstBit object with the specified attributes. The given baseName and bitIndex are checked if they are legal and do not specify an instance that already exists. This version creates an instance of the master implied by the specified library, cell, and view names (the master need not be opened to create instances of it). An optional array of parameters may be specified in the case where the master is a pCell.\n"
"    block\n"
"    The block in which to place the instance\n"
"    libName\n"
"    The library name of the instance master\n"
"    cellName\n"
"    The cell name of the instance master\n"
"    viewName\n"
"    The view name of the instance master\n"
"    baseName\n"
"    The base name for the instance\n"
"    bitIndex\n"
"    The bit index for the instance\n"
"    xform\n"
"    The transform used to place the instance\n"
"    params\n"
"    Optional parameter array for pCell instances\n"
"    view\n"
"    Specifies whether this instance is visible in the module domain\n"
"    status\n"
"    Specifies the placement status of this instance\n"
"    oacInvalidHierInstName\n"
"    oacVectorInstBitNameMatchesAutoName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"  Paramegers: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaTransform,oaParamArray)\n"
"    Calls: oaVectorInstBit* create(oaBlock* block,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName,const oaScalarName& baseName,oaUInt4 bitIndex,const oaTransform& xform,const oaParamArray* params)\n"
"    Signature: create|ptr-oaVectorInstBit|ptr-oaBlock,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,simple-oaUInt4,cref-oaTransform,cptr-oaParamArray,simple-oaBlockDomainVisibility,simple-oaPlacementStatus,\n"
"    This function creates an oaVectorInstBit object with the specified attributes. The given baseName and bitIndex are checked if they are legal and do not specify an instance that already exists. This version creates an instance of the master implied by the specified library, cell, and view names (the master need not be opened to create instances of it). An optional array of parameters may be specified in the case where the master is a pCell.\n"
"    block\n"
"    The block in which to place the instance\n"
"    libName\n"
"    The library name of the instance master\n"
"    cellName\n"
"    The cell name of the instance master\n"
"    viewName\n"
"    The view name of the instance master\n"
"    baseName\n"
"    The base name for the instance\n"
"    bitIndex\n"
"    The bit index for the instance\n"
"    xform\n"
"    The transform used to place the instance\n"
"    params\n"
"    Optional parameter array for pCell instances\n"
"    view\n"
"    Specifies whether this instance is visible in the module domain\n"
"    status\n"
"    Specifies the placement status of this instance\n"
"    oacInvalidHierInstName\n"
"    oacVectorInstBitNameMatchesAutoName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"  Paramegers: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaTransform,oaParamArray,oaBlockDomainVisibility)\n"
"    Calls: oaVectorInstBit* create(oaBlock* block,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName,const oaScalarName& baseName,oaUInt4 bitIndex,const oaTransform& xform,const oaParamArray* params,oaBlockDomainVisibility view)\n"
"    Signature: create|ptr-oaVectorInstBit|ptr-oaBlock,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,simple-oaUInt4,cref-oaTransform,cptr-oaParamArray,simple-oaBlockDomainVisibility,simple-oaPlacementStatus,\n"
"    This function creates an oaVectorInstBit object with the specified attributes. The given baseName and bitIndex are checked if they are legal and do not specify an instance that already exists. This version creates an instance of the master implied by the specified library, cell, and view names (the master need not be opened to create instances of it). An optional array of parameters may be specified in the case where the master is a pCell.\n"
"    block\n"
"    The block in which to place the instance\n"
"    libName\n"
"    The library name of the instance master\n"
"    cellName\n"
"    The cell name of the instance master\n"
"    viewName\n"
"    The view name of the instance master\n"
"    baseName\n"
"    The base name for the instance\n"
"    bitIndex\n"
"    The bit index for the instance\n"
"    xform\n"
"    The transform used to place the instance\n"
"    params\n"
"    Optional parameter array for pCell instances\n"
"    view\n"
"    Specifies whether this instance is visible in the module domain\n"
"    status\n"
"    Specifies the placement status of this instance\n"
"    oacInvalidHierInstName\n"
"    oacVectorInstBitNameMatchesAutoName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"  Paramegers: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaTransform,oaParamArray,oaBlockDomainVisibility,oaPlacementStatus)\n"
"    Calls: oaVectorInstBit* create(oaBlock* block,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName,const oaScalarName& baseName,oaUInt4 bitIndex,const oaTransform& xform,const oaParamArray* params,oaBlockDomainVisibility view,oaPlacementStatus status)\n"
"    Signature: create|ptr-oaVectorInstBit|ptr-oaBlock,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,simple-oaUInt4,cref-oaTransform,cptr-oaParamArray,simple-oaBlockDomainVisibility,simple-oaPlacementStatus,\n"
"    This function creates an oaVectorInstBit object with the specified attributes. The given baseName and bitIndex are checked if they are legal and do not specify an instance that already exists. This version creates an instance of the master implied by the specified library, cell, and view names (the master need not be opened to create instances of it). An optional array of parameters may be specified in the case where the master is a pCell.\n"
"    block\n"
"    The block in which to place the instance\n"
"    libName\n"
"    The library name of the instance master\n"
"    cellName\n"
"    The cell name of the instance master\n"
"    viewName\n"
"    The view name of the instance master\n"
"    baseName\n"
"    The base name for the instance\n"
"    bitIndex\n"
"    The bit index for the instance\n"
"    xform\n"
"    The transform used to place the instance\n"
"    params\n"
"    Optional parameter array for pCell instances\n"
"    view\n"
"    Specifies whether this instance is visible in the module domain\n"
"    status\n"
"    Specifies the placement status of this instance\n"
"    oacInvalidHierInstName\n"
"    oacVectorInstBitNameMatchesAutoName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
;

static PyObject*
oaVectorInstBit_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaBlock,oaDesign,oaScalarName,oaUInt4,oaTransform)
    {
        PyParamoaBlock p1;
        PyParamoaDesign p2;
        PyParamoaScalarName p3;
        PyParamoaUInt4 p4;
        PyParamoaTransform p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaDesign_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaTransform_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVectorInstBitp result= (oaVectorInstBit::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
            return PyoaVectorInstBit_FromoaVectorInstBit(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaDesign,oaScalarName,oaUInt4,oaTransform,oaParamArray)
    {
        PyParamoaBlock p1;
        PyParamoaDesign p2;
        PyParamoaScalarName p3;
        PyParamoaUInt4 p4;
        PyParamoaTransform p5;
        PyParamoaParamArray p6;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaDesign_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaTransform_Convert,&p5,
              &PyoaParamArray_ConvertAof,&p6)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVectorInstBitp result= (oaVectorInstBit::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.DataAof()));
            return PyoaVectorInstBit_FromoaVectorInstBit(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaDesign,oaScalarName,oaUInt4,oaTransform,oaParamArray,oaBlockDomainVisibility)
    {
        PyParamoaBlock p1;
        PyParamoaDesign p2;
        PyParamoaScalarName p3;
        PyParamoaUInt4 p4;
        PyParamoaTransform p5;
        PyParamoaParamArray p6;
        PyParamoaBlockDomainVisibility p7;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaDesign_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaTransform_Convert,&p5,
              &PyoaParamArray_ConvertAof,&p6,
              &PyoaBlockDomainVisibility_Convert,&p7)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVectorInstBitp result= (oaVectorInstBit::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.DataAof(),p7.Data()));
            return PyoaVectorInstBit_FromoaVectorInstBit(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaDesign,oaScalarName,oaUInt4,oaTransform,oaParamArray,oaBlockDomainVisibility,oaPlacementStatus)
    {
        PyParamoaBlock p1;
        PyParamoaDesign p2;
        PyParamoaScalarName p3;
        PyParamoaUInt4 p4;
        PyParamoaTransform p5;
        PyParamoaParamArray p6;
        PyParamoaBlockDomainVisibility p7;
        PyParamoaPlacementStatus p8;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaDesign_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaTransform_Convert,&p5,
              &PyoaParamArray_ConvertAof,&p6,
              &PyoaBlockDomainVisibility_Convert,&p7,
              &PyoaPlacementStatus_Convert,&p8)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaVectorInstBitp result= (oaVectorInstBit::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.DataAof(),p7.Data(),p8.Data()));
            return PyoaVectorInstBit_FromoaVectorInstBit(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaTransform)
    {
        PyParamoaBlock p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        PyParamoaScalarName p5;
        PyParamoaUInt4 p6;
        PyParamoaTransform p7;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4,
              &PyoaScalarName_Convert,&p5,
              &PyoaUInt4_Convert,&p6,
              &PyoaTransform_Convert,&p7)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaVectorInstBitp result= (oaVectorInstBit::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data()));
            return PyoaVectorInstBit_FromoaVectorInstBit(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaTransform,oaParamArray)
    {
        PyParamoaBlock p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        PyParamoaScalarName p5;
        PyParamoaUInt4 p6;
        PyParamoaTransform p7;
        PyParamoaParamArray p8;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4,
              &PyoaScalarName_Convert,&p5,
              &PyoaUInt4_Convert,&p6,
              &PyoaTransform_Convert,&p7,
              &PyoaParamArray_ConvertAof,&p8)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaVectorInstBitp result= (oaVectorInstBit::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.DataAof()));
            return PyoaVectorInstBit_FromoaVectorInstBit(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaTransform,oaParamArray,oaBlockDomainVisibility)
    {
        PyParamoaBlock p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        PyParamoaScalarName p5;
        PyParamoaUInt4 p6;
        PyParamoaTransform p7;
        PyParamoaParamArray p8;
        PyParamoaBlockDomainVisibility p9;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4,
              &PyoaScalarName_Convert,&p5,
              &PyoaUInt4_Convert,&p6,
              &PyoaTransform_Convert,&p7,
              &PyoaParamArray_ConvertAof,&p8,
              &PyoaBlockDomainVisibility_Convert,&p9)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaVectorInstBitp result= (oaVectorInstBit::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.DataAof(),p9.Data()));
            return PyoaVectorInstBit_FromoaVectorInstBit(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaTransform,oaParamArray,oaBlockDomainVisibility,oaPlacementStatus)
    {
        PyParamoaBlock p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        PyParamoaScalarName p5;
        PyParamoaUInt4 p6;
        PyParamoaTransform p7;
        PyParamoaParamArray p8;
        PyParamoaBlockDomainVisibility p9;
        PyParamoaPlacementStatus p10;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4,
              &PyoaScalarName_Convert,&p5,
              &PyoaUInt4_Convert,&p6,
              &PyoaTransform_Convert,&p7,
              &PyoaParamArray_ConvertAof,&p8,
              &PyoaBlockDomainVisibility_Convert,&p9,
              &PyoaPlacementStatus_Convert,&p10)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaVectorInstBitp result= (oaVectorInstBit::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.DataAof(),p9.Data(),p10.Data()));
            return PyoaVectorInstBit_FromoaVectorInstBit(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVectorInstBit, function: create, Choices are:\n"
        "    (oaBlock,oaDesign,oaScalarName,oaUInt4,oaTransform)\n"
        "    (oaBlock,oaDesign,oaScalarName,oaUInt4,oaTransform,oaParamArray)\n"
        "    (oaBlock,oaDesign,oaScalarName,oaUInt4,oaTransform,oaParamArray,oaBlockDomainVisibility)\n"
        "    (oaBlock,oaDesign,oaScalarName,oaUInt4,oaTransform,oaParamArray,oaBlockDomainVisibility,oaPlacementStatus)\n"
        "    (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaTransform)\n"
        "    (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaTransform,oaParamArray)\n"
        "    (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaTransform,oaParamArray,oaBlockDomainVisibility)\n"
        "    (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaTransform,oaParamArray,oaBlockDomainVisibility,oaPlacementStatus)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInstBit_static_find_doc[] = 
"Class: oaVectorInstBit, Function: find\n"
"  Paramegers: (oaBlock,oaScalarName,oaUInt4)\n"
"    Calls: oaVectorInstBit* find(const oaBlock* block,const oaScalarName& baseName,oaUInt4 bitIndex)\n"
"    Signature: find|ptr-oaVectorInstBit|cptr-oaBlock,cref-oaScalarName,simple-oaUInt4,\n"
"    This function searches the specified block looking for a vectorInstBit with the specified baseName and bitIndex . If the instance is found, it is returned; otherwise, NULL is returned.\n"
"    block\n"
"    The block to search for the instance\n"
"    baseName\n"
"    The base name of the instance to find\n"
"    bitIndex\n"
"    The bit index of the instance to find\n"
;

static PyObject*
oaVectorInstBit_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaScalarName p2;
    PyParamoaUInt4 p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaUInt4_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaVectorInstBitp result= (oaVectorInstBit::find(p1.Data(),p2.Data(),p3.Data()));
        return PyoaVectorInstBit_FromoaVectorInstBit(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInstBit_static_isValidName_doc[] = 
"Class: oaVectorInstBit, Function: isValidName\n"
"  Paramegers: (oaBlock,oaScalarName,oaUInt4)\n"
"    Calls: oaBoolean isValidName(const oaBlock* block,const oaScalarName& baseName,oaUInt4 bitIndex)\n"
"    Signature: isValidName|simple-oaBoolean|cptr-oaBlock,cref-oaScalarName,simple-oaUInt4,\n"
"    This function returns a boolean indicating whether the specified baseName and bitIndex would be valid for an oaVectorInstBit in the specified block .\n"
"    block\n"
"    The block to check the name against\n"
"    baseName\n"
"    The base name to be checked\n"
"    bitIndex\n"
"    The bit index to be checked\n"
;

static PyObject*
oaVectorInstBit_static_isValidName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaScalarName p2;
    PyParamoaUInt4 p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaUInt4_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (oaVectorInstBit::isValidName(p1.Data(),p2.Data(),p3.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaVectorInstBit_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaVectorInstBit_static_create,METH_VARARGS,oaVectorInstBit_static_create_doc},
    {"static_find",(PyCFunction)oaVectorInstBit_static_find,METH_VARARGS,oaVectorInstBit_static_find_doc},
    {"static_isValidName",(PyCFunction)oaVectorInstBit_static_isValidName,METH_VARARGS,oaVectorInstBit_static_isValidName_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVectorInstBit_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVectorInstBit_Type)<0) {
      printf("** PyType_Ready failed for: oaVectorInstBit\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVectorInstBit",
           (PyObject*)(&PyoaVectorInstBit_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVectorInstBit\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaVectorInstBit_Type.tp_dict;
    for(method=oaVectorInstBit_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVectorInstDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVectorInstDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVectorInstDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVectorInstDefObject* self = (PyoaVectorInstDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaVectorInstDef)
    {
        PyParamoaVectorInstDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVectorInstDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVectorInstDef, Choices are:\n"
        "    (oaVectorInstDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVectorInstDef_tp_dealloc(PyoaVectorInstDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVectorInstDef_tp_repr(PyObject *ob)
{
    PyParamoaVectorInstDef value;
    int convert_status=PyoaVectorInstDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaVectorInstDef::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaScalarName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[37];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaVectorInstDef::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVectorInstDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVectorInstDef v1;
    PyParamoaVectorInstDef v2;
    int convert_status1=PyoaVectorInstDef_Convert(ob1,&v1);
    int convert_status2=PyoaVectorInstDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVectorInstDef_Convert(PyObject* ob,PyParamoaVectorInstDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaVectorInstDef_Check(ob)) {
        result->SetData( (oaVectorInstDef**) ((PyoaVectorInstDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVectorInstDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVectorInstDef_FromoaVectorInstDef(oaVectorInstDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaVectorInstDef* data=*value;
        PyObject* bself = PyoaVectorInstDef_Type.tp_alloc(&PyoaVectorInstDef_Type,0);
        if (bself == NULL) return bself;
        PyoaVectorInstDefObject* self = (PyoaVectorInstDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaVectorInstDef_FromoaVectorInstDef(oaVectorInstDef* data)
{
    if (data) {
       PyObject* bself = PyoaVectorInstDef_Type.tp_alloc(&PyoaVectorInstDef_Type,0);
       if (bself == NULL) return bself;
       PyoaVectorInstDefObject* self = (PyoaVectorInstDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVectorInstDef_destroy_doc[] = 
"Class: oaVectorInstDef, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function destroys this oaVectorInstDef, removing it from the database. An exception is thrown if the oaVectorInstDef is implicit or if there are still oaVectorInsts associated with it.\n"
"    oacCannotDestroyImplicitVectorInstDef\n"
"    oacCannotDestroyVectorInstDefWithInsts\n"
;

static PyObject*
oaVectorInstDef_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorInstDef data;
    int convert_status=PyoaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorInstDefObject* self=(PyoaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInstDef_getBitOrder_doc[] = 
"Class: oaVectorInstDef, Function: getBitOrder\n"
"  Paramegers: ()\n"
"    Calls: oaBitOrder getBitOrder() const\n"
"    Signature: getBitOrder|simple-oaBitOrder|\n"
"    BrowseData: 1\n"
"    This function returns the bitOrder associated with this oaVectorInstDef object.\n"
;

static PyObject*
oaVectorInstDef_getBitOrder(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorInstDef data;
    int convert_status=PyoaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorInstDefObject* self=(PyoaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBitOrder* result= new oaBitOrder(data.DataCall()->getBitOrder());
        return PyoaBitOrder_FromoaBitOrder(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInstDef_getMaxIndex_doc[] = 
"Class: oaVectorInstDef, Function: getMaxIndex\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getMaxIndex() const\n"
"    Signature: getMaxIndex|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the largest bit number in use for this oaVectorInstDef object. This is the largest index used across all vectorInsts associated with this oaVectorInstDef object.\n"
;

static PyObject*
oaVectorInstDef_getMaxIndex(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorInstDef data;
    int convert_status=PyoaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorInstDefObject* self=(PyoaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getMaxIndex());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInstDef_getMinIndex_doc[] = 
"Class: oaVectorInstDef, Function: getMinIndex\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getMinIndex() const\n"
"    Signature: getMinIndex|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the smallest bit number in use for this oaVectorInstDef object. This is the smallest index used across all vectorInsts associated with this oaVectorInstDef object.\n"
;

static PyObject*
oaVectorInstDef_getMinIndex(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorInstDef data;
    int convert_status=PyoaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorInstDefObject* self=(PyoaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getMinIndex());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInstDef_getName_doc[] = 
"Class: oaVectorInstDef, Function: getName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getName(oaScalarName& name) const\n"
"    Signature: getName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the name of this oaVectorInstDef object.\n"
"    name\n"
"    The scalar name in which to return the oaVectorInstDef object name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the name string of this oaVectorInstDef object in the specified nameSpace.\n"
"    ns\n"
"    The nameSpace to use when getting the name string\n"
"    name\n"
"    Returns the string name of this oaVectorInstDef\n"
;

static PyObject*
oaVectorInstDef_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorInstDef data;
    int convert_status=PyoaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorInstDefObject* self=(PyoaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVectorInstDef, function: getName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInstDef_getNumBits_doc[] = 
"Class: oaVectorInstDef, Function: getNumBits\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumBits() const\n"
"    Signature: getNumBits|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of bits covered by the vectorInsts in this oaVectorInstDef. The number of bits is equal to abs(maxIndex - minIndex) + 1.\n"
;

static PyObject*
oaVectorInstDef_getNumBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorInstDef data;
    int convert_status=PyoaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorInstDefObject* self=(PyoaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumBits());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInstDef_getVectorInstBits_doc[] = 
"Class: oaVectorInstDef, Function: getVectorInstBits\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaVectorInstBit_oaVectorInstDef getVectorInstBits() const\n"
"    Signature: getVectorInstBits|simple-oaCollection_oaVectorInstBit_oaVectorInstDef|\n"
"    BrowseData: 1\n"
"    This function returns a collection of oaVectorInstBit objects associated with this oaVectorInstDef object.\n"
;

static PyObject*
oaVectorInstDef_getVectorInstBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorInstDef data;
    int convert_status=PyoaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorInstDefObject* self=(PyoaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaVectorInstBit_oaVectorInstDef* result= new oaCollection_oaVectorInstBit_oaVectorInstDef(data.DataCall()->getVectorInstBits());
        return PyoaCollection_oaVectorInstBit_oaVectorInstDef_FromoaCollection_oaVectorInstBit_oaVectorInstDef(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInstDef_getVectorInstBitsIter_doc[] = 
"Class: oaVectorInstDef, Function: getVectorInstBitsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaVectorInstBit getVectorInstBitsIter() const\n"
"    Signature: getVectorInstBitsIter|simple-oaIter_oaVectorInstBit|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of oaVectorInstBit objects associated with this oaVectorInstDef object.\n"
;

static PyObject*
oaVectorInstDef_getVectorInstBitsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorInstDef data;
    int convert_status=PyoaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorInstDefObject* self=(PyoaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaVectorInstBit* result= new oaIter_oaVectorInstBit(data.DataCall()->getVectorInstBits());
        return PyoaIter_oaVectorInstBit_FromoaIter_oaVectorInstBit(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInstDef_getVectorInsts_doc[] = 
"Class: oaVectorInstDef, Function: getVectorInsts\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaVectorInst_oaVectorInstDef getVectorInsts() const\n"
"    Signature: getVectorInsts|simple-oaCollection_oaVectorInst_oaVectorInstDef|\n"
"    BrowseData: 1\n"
"    This function returns a collection of oaVectorInst objects associated with this oaVectorInstDef object.\n"
;

static PyObject*
oaVectorInstDef_getVectorInsts(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorInstDef data;
    int convert_status=PyoaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorInstDefObject* self=(PyoaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaVectorInst_oaVectorInstDef* result= new oaCollection_oaVectorInst_oaVectorInstDef(data.DataCall()->getVectorInsts());
        return PyoaCollection_oaVectorInst_oaVectorInstDef_FromoaCollection_oaVectorInst_oaVectorInstDef(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInstDef_getVectorInstsIter_doc[] = 
"Class: oaVectorInstDef, Function: getVectorInstsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaVectorInst getVectorInstsIter() const\n"
"    Signature: getVectorInstsIter|simple-oaIter_oaVectorInst|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of oaVectorInst objects associated with this oaVectorInstDef object.\n"
;

static PyObject*
oaVectorInstDef_getVectorInstsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorInstDef data;
    int convert_status=PyoaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorInstDefObject* self=(PyoaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaVectorInst* result= new oaIter_oaVectorInst(data.DataCall()->getVectorInsts());
        return PyoaIter_oaVectorInst_FromoaIter_oaVectorInst(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInstDef_isImplicit_doc[] = 
"Class: oaVectorInstDef, Function: isImplicit\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isImplicit() const\n"
"    Signature: isImplicit|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether this oaVectorInstDef was implicitly created or not.\n"
;

static PyObject*
oaVectorInstDef_isImplicit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorInstDef data;
    int convert_status=PyoaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorInstDefObject* self=(PyoaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isImplicit());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInstDef_setBitOrder_doc[] = 
"Class: oaVectorInstDef, Function: setBitOrder\n"
"  Paramegers: (oaBitOrder)\n"
"    Calls: void setBitOrder(oaBitOrder order)\n"
"    Signature: setBitOrder|void-void|simple-oaBitOrder,\n"
"    This function changes the bitOrder value associated with the oaVectorInstDef. An exception is thrown if this vectorInstDef was implicitly created.\n"
"    order\n"
"    The new bitOrder value for this vectorInstDef\n"
"    oacBitOrderVectorInstDefImplicit\n"
;

static PyObject*
oaVectorInstDef_setBitOrder(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorInstDef data;
    int convert_status=PyoaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorInstDefObject* self=(PyoaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBitOrder p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBitOrder_Convert,&p1)) {
        data.DataCall()->setBitOrder(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInstDef_isNull_doc[] =
"Class: oaVectorInstDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaVectorInstDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaVectorInstDef data;
    int convert_status=PyoaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaVectorInstDef_assign_doc[] = 
"Class: oaVectorInstDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVectorInstDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVectorInstDef data;
  int convert_status=PyoaVectorInstDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVectorInstDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVectorInstDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVectorInstDef_methodlist[] = {
    {"destroy",(PyCFunction)oaVectorInstDef_destroy,METH_VARARGS,oaVectorInstDef_destroy_doc},
    {"getBitOrder",(PyCFunction)oaVectorInstDef_getBitOrder,METH_VARARGS,oaVectorInstDef_getBitOrder_doc},
    {"getMaxIndex",(PyCFunction)oaVectorInstDef_getMaxIndex,METH_VARARGS,oaVectorInstDef_getMaxIndex_doc},
    {"getMinIndex",(PyCFunction)oaVectorInstDef_getMinIndex,METH_VARARGS,oaVectorInstDef_getMinIndex_doc},
    {"getName",(PyCFunction)oaVectorInstDef_getName,METH_VARARGS,oaVectorInstDef_getName_doc},
    {"getNumBits",(PyCFunction)oaVectorInstDef_getNumBits,METH_VARARGS,oaVectorInstDef_getNumBits_doc},
    {"getVectorInstBits",(PyCFunction)oaVectorInstDef_getVectorInstBits,METH_VARARGS,oaVectorInstDef_getVectorInstBits_doc},
    {"getVectorInstBitsIter",(PyCFunction)oaVectorInstDef_getVectorInstBitsIter,METH_VARARGS,oaVectorInstDef_getVectorInstBitsIter_doc},
    {"getVectorInsts",(PyCFunction)oaVectorInstDef_getVectorInsts,METH_VARARGS,oaVectorInstDef_getVectorInsts_doc},
    {"getVectorInstsIter",(PyCFunction)oaVectorInstDef_getVectorInstsIter,METH_VARARGS,oaVectorInstDef_getVectorInstsIter_doc},
    {"isImplicit",(PyCFunction)oaVectorInstDef_isImplicit,METH_VARARGS,oaVectorInstDef_isImplicit_doc},
    {"setBitOrder",(PyCFunction)oaVectorInstDef_setBitOrder,METH_VARARGS,oaVectorInstDef_setBitOrder_doc},
    {"isNull",(PyCFunction)oaVectorInstDef_tp_isNull,METH_VARARGS,oaVectorInstDef_isNull_doc},
    {"assign",(PyCFunction)oaVectorInstDef_tp_assign,METH_VARARGS,oaVectorInstDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVectorInstDef_doc[] = 
"Class: oaVectorInstDef\n"
"  The oaVectorInstDef class implements the definition of a vectorInst, including its name and bit-range. All vectorInsts in a block with the same base name are managed by the same vectorInst definition. The oaVectorInstDef class tracks the minimum and maximum indices referred to by all of its corresponding vectorInst objects.\n"
"  A vectorInstDef is automatically created if necessary whenever applications create vectorInsts. Implicitly created vectorInst definitions have no bitOrder. Applications may explicitly create a vectorInst definition in order to specify that it has a specific bitOrder.\n"
"  Implicitly created vectorInst definitions are automatically destroyed when the last vectorInst with the same base name is destroyed. Explicitly created vectorInst definitions must be explicitly destroyed.\n"
"  The oaVectorInstDef class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaVectorInstDef)\n"
"    Calls: (const oaVectorInstDef&)\n"
"    Signature: oaVectorInstDef||cref-oaVectorInstDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVectorInstDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVectorInstDef",
    sizeof(PyoaVectorInstDefObject),
    0,
    (destructor)oaVectorInstDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVectorInstDef_tp_compare,	/* tp_compare */
    (reprfunc)oaVectorInstDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVectorInstDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVectorInstDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaBlockObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVectorInstDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVectorInstDef_static_create_doc[] = 
"Class: oaVectorInstDef, Function: create\n"
"  Paramegers: (oaBlock,oaScalarName,oaBitOrder)\n"
"    Calls: oaVectorInstDef* create(const oaBlock* block,const oaScalarName& name,oaBitOrder order)\n"
"    Signature: create|ptr-oaVectorInstDef|cptr-oaBlock,cref-oaScalarName,simple-oaBitOrder,\n"
"    This function creates an oaVectorInstDef in the specified block with the given base name and bit order. An exception is thrown if an oaVectorInstDef already exists with the specified name . Explicitly creating an oaVectorInstDef also means that the vectorInst definition must be explicitly destroyed.\n"
"    block\n"
"    The block to create the oaVectorInstDef object in\n"
"    name\n"
"    The base name for the oaVectorInstDef\n"
"    order\n"
"    The bit order for the oaVectorInstDef\n"
"    oacVectorInstDefAlreadyExists\n"
;

static PyObject*
oaVectorInstDef_static_create(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaScalarName p2;
    PyParamoaBitOrder p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaBitOrder_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaVectorInstDefp result= (oaVectorInstDef::create(p1.Data(),p2.Data(),p3.Data()));
        return PyoaVectorInstDef_FromoaVectorInstDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorInstDef_static_find_doc[] = 
"Class: oaVectorInstDef, Function: find\n"
"  Paramegers: (oaBlock,oaScalarName)\n"
"    Calls: oaVectorInstDef* find(const oaBlock* block,const oaScalarName& name)\n"
"    Signature: find|ptr-oaVectorInstDef|cptr-oaBlock,cref-oaScalarName,\n"
"    This function searches the specified block for a vectorInstDef with the specified name. The function returns the vectorInstDef if it finds it. Otherwise, NULL is returned.\n"
;

static PyObject*
oaVectorInstDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaVectorInstDefp result= (oaVectorInstDef::find(p1.Data(),p2.Data()));
        return PyoaVectorInstDef_FromoaVectorInstDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaVectorInstDef_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaVectorInstDef_static_create,METH_VARARGS,oaVectorInstDef_static_create_doc},
    {"static_find",(PyCFunction)oaVectorInstDef_static_find,METH_VARARGS,oaVectorInstDef_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVectorInstDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVectorInstDef_Type)<0) {
      printf("** PyType_Ready failed for: oaVectorInstDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVectorInstDef",
           (PyObject*)(&PyoaVectorInstDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVectorInstDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaVectorInstDef_Type.tp_dict;
    for(method=oaVectorInstDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVectorInstDefModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaVectorInstDefModTypeEnum_Convert(PyObject* ob,PyParamoaVectorInstDefModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacSetImplicitVectorInstDefModType")==0) { result->SetData(oacSetImplicitVectorInstDefModType); return 1;}
        if (strcasecmp(str,"oacSetBitOrderVectorInstDefModType")==0) { result->SetData(oacSetBitOrderVectorInstDefModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaVectorInstDefModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVectorInstDefModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaVectorInstDefModTypeEnum_FromoaVectorInstDefModTypeEnum(oaVectorInstDefModTypeEnum ob)
{
    if (ob==oacSetImplicitVectorInstDefModType) return PyString_FromString("oacSetImplicitVectorInstDefModType");
    if (ob==oacSetBitOrderVectorInstDefModType) return PyString_FromString("oacSetBitOrderVectorInstDefModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaVectorInstDefModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaVectorInstDefModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaVectorInstDefModTypeEnum_FromoaVectorInstDefModTypeEnum(oaVectorInstDefModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaVectorInstDefModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaVectorInstDefModTypeEnum_doc[] =
"Type convert function for enum: oaVectorInstDefModTypeEnum";
                               
static PyMethodDef PyoaVectorInstDefModTypeEnum_method =
  {"oaVectorInstDefModTypeEnum",(PyCFunction)PyoaVectorInstDefModTypeEnum_TypeFunction,METH_VARARGS,oaVectorInstDefModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaVectorInstDefModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacSetImplicitVectorInstDefModType");
    PyDict_SetItemString(mod_dict,"oacSetImplicitVectorInstDefModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetBitOrderVectorInstDefModType");
    PyDict_SetItemString(mod_dict,"oacSetBitOrderVectorInstDefModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaVectorInstDefModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaVectorInstDefModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaVectorInstDefModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVectorName
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVectorName_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVectorName_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVectorNameObject* self = (PyoaVectorNameObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaNameBase*)  new oaVectorName();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,[oaChar],oaUInt4,oaUInt4)
    {
        PyParamoaNameSpace p1;
        PyParamoaChar_Array p2;
        PyParamoaUInt4 p3;
        PyParamoaUInt4 p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaChar_Array_Convert,&p2,
              &PyoaUInt4_Convert,&p3,
              &PyoaUInt4_Convert,&p4)) {
            self->value = (oaNameBase*)  new oaVectorName(p1.Data(),p2.Data(),p3.Data(),p4.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,[oaChar],oaUInt4,oaUInt4,oaUInt4)
    {
        PyParamoaNameSpace p1;
        PyParamoaChar_Array p2;
        PyParamoaUInt4 p3;
        PyParamoaUInt4 p4;
        PyParamoaUInt4 p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaChar_Array_Convert,&p2,
              &PyoaUInt4_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaUInt4_Convert,&p5)) {
            self->value = (oaNameBase*)  new oaVectorName(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,[oaChar])
    {
        PyParamoaNameSpace p1;
        PyParamoaChar_Array p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaChar_Array_Convert,&p2)) {
            self->value = (oaNameBase*)  new oaVectorName(p1.Data(),p2.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaScalarName,oaUInt4,oaUInt4)
    {
        PyParamoaScalarName p1;
        PyParamoaUInt4 p2;
        PyParamoaUInt4 p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaScalarName_Convert,&p1,
              &PyoaUInt4_Convert,&p2,
              &PyoaUInt4_Convert,&p3)) {
            self->value = (oaNameBase*)  new oaVectorName(p1.Data(),p2.Data(),p3.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaScalarName,oaUInt4,oaUInt4,oaUInt4)
    {
        PyParamoaScalarName p1;
        PyParamoaUInt4 p2;
        PyParamoaUInt4 p3;
        PyParamoaUInt4 p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaScalarName_Convert,&p1,
              &PyoaUInt4_Convert,&p2,
              &PyoaUInt4_Convert,&p3,
              &PyoaUInt4_Convert,&p4)) {
            self->value = (oaNameBase*)  new oaVectorName(p1.Data(),p2.Data(),p3.Data(),p4.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaVectorName)
    {
        PyParamoaVectorName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorName_Convert,&p1)) {
            self->value = (oaNameBase*)  new oaVectorName(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVectorName, Choices are:\n"
        "    ()\n"
        "    (oaNameSpace,[oaChar],oaUInt4,oaUInt4)\n"
        "    (oaNameSpace,[oaChar],oaUInt4,oaUInt4,oaUInt4)\n"
        "    (oaNameSpace,[oaChar])\n"
        "    (oaScalarName,oaUInt4,oaUInt4)\n"
        "    (oaScalarName,oaUInt4,oaUInt4,oaUInt4)\n"
        "    (oaVectorName)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVectorName_tp_dealloc(PyoaVectorNameObject* self)
{
    if (!self->borrow) {
        delete (oaVectorName*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVectorName_tp_repr(PyObject *ob)
{
    PyParamoaVectorName value;
    int convert_status=PyoaVectorName_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    oaString sresult;
    value.DataCall()->get(sresult);

    char addr[34];
    sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
    oaString buffer;
    buffer+=oaString("<oaVectorName::");
    buffer+=oaString(addr);
    buffer+=oaString("::");
    buffer+=oaString(sresult);
    buffer+=oaString(">");
    result=PyString_FromString((char*)(const char*)buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVectorName_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVectorName v1;
    PyParamoaVectorName v2;
    int convert_status1=PyoaVectorName_Convert(ob1,&v1);
    int convert_status2=PyoaVectorName_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    if (v1.Data()==v2.Data()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVectorName_Convert(PyObject* ob,PyParamoaVectorName* result)
{
    if (ob == NULL) return 1;
    if (PyoaVectorName_Check(ob)) {
        result->SetData( (oaVectorName*) ((PyoaVectorNameObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVectorName Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVectorName_FromoaVectorName(oaVectorName* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaVectorName_Type.tp_alloc(&PyoaVectorName_Type,0);
        if (bself == NULL) return bself;
        PyoaVectorNameObject* self = (PyoaVectorNameObject*)bself;
        self->value = (oaNameBase*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVectorName_append_doc[] = 
"Class: oaVectorName, Function: append\n"
"  Paramegers: (oaNameSpace,[oaChar],oaUInt4,oaUInt4)\n"
"    Calls: void append(const oaNameSpace& nSpace,const oaChar* in,oaUInt4 len,oaUInt4 flags)\n"
"    Signature: append|void-void|cref-oaNameSpace,cptr-oaChar,simple-oaUInt4,simple-oaUInt4,\n"
"    Function append\n"
;

static PyObject*
oaVectorName_append(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorName data;
    int convert_status=PyoaVectorName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorNameObject* self=(PyoaVectorNameObject*)ob;

    PyParamoaNameSpace p1;
    PyParamoaChar_Array p2;
    PyParamoaUInt4 p3;
    PyParamoaUInt4 p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaNameSpace_Convert,&p1,
          &PyoaChar_Array_Convert,&p2,
          &PyoaUInt4_Convert,&p3,
          &PyoaUInt4_Convert,&p4)) {
        data.DataCall()->append(p1.Data(),p2.Data(),p3.Data(),p4.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorName_get_doc[] = 
"Class: oaVectorName, Function: get\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void get(const oaNameSpace& nSpace,oaString& out) const\n"
"    Signature: get|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the vector name, mapped into the specified oaNameSpace .\n"
"    An oacVectorNameInvalid exception is thrown if the specified nameSpace does not support vectorNames. For information on the names supported in each nameSpace, see Details of OpenAccess Name Spaces .\n"
"    nSpace\n"
"    The oaNameSpace in which to map this name\n"
"    out\n"
"    The string in which to output the mapped name\n"
"    oacVectorNameInvalid\n"
"  Paramegers: (oaString)\n"
"    Calls: void get(oaString& out) const\n"
"    Signature: get|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function returns this vector name, mapped into the oaNative nameSpace.\n"
"    out\n"
"    The string in which to output the mapped name\n"
;

static PyObject*
oaVectorName_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorName data;
    int convert_status=PyoaVectorName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorNameObject* self=(PyoaVectorNameObject*)ob;

    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->get(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            data.DataCall()->get(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVectorName, function: get, Choices are:\n"
        "    (oaNameSpace,oaString)\n"
        "    (oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorName_getBaseName_doc[] = 
"Class: oaVectorName, Function: getBaseName\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getBaseName(const oaNameSpace& nSpace,oaString& out) const\n"
"    Signature: getBaseName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the base portion of this name, mapped into the specified oaNameSpace .\n"
"    nSpace\n"
"    The oaNameSpace in which to map the base portion of this name\n"
"    out\n"
"    The string in which to output the mapped name\n"
"  Paramegers: (oaString)\n"
"    Calls: void getBaseName(oaString& out) const\n"
"    Signature: getBaseName|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function returns the base portion of this name, mapped into the oaNative nameSpace.\n"
"    out\n"
"    The string in which to output the mapped name\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getBaseName(oaScalarName& out) const\n"
"    Signature: getBaseName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the base portion of this name.\n"
"    out\n"
"    The scalar name in which to output the mapped name\n"
;

static PyObject*
oaVectorName_getBaseName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorName data;
    int convert_status=PyoaVectorName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorNameObject* self=(PyoaVectorNameObject*)ob;

    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getBaseName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            data.DataCall()->getBaseName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getBaseName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVectorName, function: getBaseName, Choices are:\n"
        "    (oaNameSpace,oaString)\n"
        "    (oaString)\n"
        "    (oaScalarName)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorName_getBitName_doc[] = 
"Class: oaVectorName, Function: getBitName\n"
"  Paramegers: (oaNameSpace,oaUInt4,oaString)\n"
"    Calls: void getBitName(const oaNameSpace& nSpace,oaUInt4 bit,oaString& out) const\n"
"    Signature: getBitName|void-void|cref-oaNameSpace,simple-oaUInt4,ref-oaString,\n"
"    This function returns the bit value of this vector name, mapped into the specified oaNameSpace .\n"
"    nSpace\n"
"    The oaNameSpace in which to map the bit value of this name\n"
"    bit\n"
"    The bit value of this vector name\n"
"    out\n"
"    The string to which to output the mapped name\n"
"    oacBitNotInRangeForName\n"
;

static PyObject*
oaVectorName_getBitName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorName data;
    int convert_status=PyoaVectorName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorNameObject* self=(PyoaVectorNameObject*)ob;

    PyParamoaNameSpace p1;
    PyParamoaUInt4 p2;
    PyParamoaString p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaNameSpace_Convert,&p1,
          &PyoaUInt4_Convert,&p2,
          &PyoaString_Convert,&p3)) {
        data.DataCall()->getBitName(p1.Data(),p2.Data(),p3.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorName_getNumBits_doc[] = 
"Class: oaVectorName, Function: getNumBits\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumBits() const\n"
"    Signature: getNumBits|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of bits this vector name represents.\n"
;

static PyObject*
oaVectorName_getNumBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorName data;
    int convert_status=PyoaVectorName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorNameObject* self=(PyoaVectorNameObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumBits());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorName_getStart_doc[] = 
"Class: oaVectorName, Function: getStart\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getStart() const\n"
"    Signature: getStart|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the start index for this oaVectorName.\n"
;

static PyObject*
oaVectorName_getStart(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorName data;
    int convert_status=PyoaVectorName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorNameObject* self=(PyoaVectorNameObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getStart());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorName_getStep_doc[] = 
"Class: oaVectorName, Function: getStep\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getStep() const\n"
"    Signature: getStep|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the step value for this oaVectorName.\n"
;

static PyObject*
oaVectorName_getStep(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorName data;
    int convert_status=PyoaVectorName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorNameObject* self=(PyoaVectorNameObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getStep());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorName_getStop_doc[] = 
"Class: oaVectorName, Function: getStop\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getStop() const\n"
"    Signature: getStop|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the stop index of this oaVectorName.\n"
;

static PyObject*
oaVectorName_getStop(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorName data;
    int convert_status=PyoaVectorName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorNameObject* self=(PyoaVectorNameObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getStop());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorName_init_doc[] = 
"Class: oaVectorName, Function: init\n"
"  Paramegers: (oaNameSpace,[oaChar])\n"
"    Calls: void init(const oaNameSpace& nSpace,const oaChar* in)\n"
"    Signature: init|void-void|cref-oaNameSpace,cptr-oaChar,simple-oaBoolean,\n"
"    This function allows reuse of the oaVectorName object in order to improve application performance and capacity. This function initializes the name by clearing any previously stored name data, then re-initializing its value to the string specified by in , evaluating the string in the specified namespace.\n"
"    The optional boolean argument baseOnly indicates if the input name is interpreted as the base portion of the vector name or as the entire name -- for example, with nSpace set to the oaVerilog namespace, baseOnly equal to true, and in specified as \"abc[0:7:1]\".\n"
"    nSpace\n"
"    The oaNameSpace in which to evaluate the string\n"
"    in\n"
"    The input string, which may specify the base name only (if baseOnly is true) or the entire name (if baseOnly is false)\n"
"    baseOnly\n"
"    A boolean value that indicates if the input string is an entire vector name or only the base portion\n"
"    oacInvalidNameLength\n"
"    oacInvalidNameSyntax\n"
"    oacInvalidVectorValue\n"
"  Paramegers: (oaNameSpace,[oaChar],oaBoolean)\n"
"    Calls: void init(const oaNameSpace& nSpace,const oaChar* in,oaBoolean baseOnly)\n"
"    Signature: init|void-void|cref-oaNameSpace,cptr-oaChar,simple-oaBoolean,\n"
"    This function allows reuse of the oaVectorName object in order to improve application performance and capacity. This function initializes the name by clearing any previously stored name data, then re-initializing its value to the string specified by in , evaluating the string in the specified namespace.\n"
"    The optional boolean argument baseOnly indicates if the input name is interpreted as the base portion of the vector name or as the entire name -- for example, with nSpace set to the oaVerilog namespace, baseOnly equal to true, and in specified as \"abc[0:7:1]\".\n"
"    nSpace\n"
"    The oaNameSpace in which to evaluate the string\n"
"    in\n"
"    The input string, which may specify the base name only (if baseOnly is true) or the entire name (if baseOnly is false)\n"
"    baseOnly\n"
"    A boolean value that indicates if the input string is an entire vector name or only the base portion\n"
"    oacInvalidNameLength\n"
"    oacInvalidNameSyntax\n"
"    oacInvalidVectorValue\n"
;

static PyObject*
oaVectorName_init(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorName data;
    int convert_status=PyoaVectorName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorNameObject* self=(PyoaVectorNameObject*)ob;

    // Case: (oaNameSpace,[oaChar])
    {
        PyParamoaNameSpace p1;
        PyParamoaChar_Array p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaChar_Array_Convert,&p2)) {
            data.DataCall()->init(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,[oaChar],oaBoolean)
    {
        PyParamoaNameSpace p1;
        PyParamoaChar_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaChar_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            data.DataCall()->init(p1.Data(),p2.Data(),p3.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVectorName, function: init, Choices are:\n"
        "    (oaNameSpace,[oaChar])\n"
        "    (oaNameSpace,[oaChar],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorName_setStart_doc[] = 
"Class: oaVectorName, Function: setStart\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setStart(oaUInt4 val)\n"
"    Signature: setStart|void-void|simple-oaUInt4,\n"
"    This function sets the start index for this vector name to the specified value.\n"
"    val\n"
"    The start value\n"
;

static PyObject*
oaVectorName_setStart(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorName data;
    int convert_status=PyoaVectorName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorNameObject* self=(PyoaVectorNameObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setStart(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorName_setStep_doc[] = 
"Class: oaVectorName, Function: setStep\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setStep(oaUInt4 val)\n"
"    Signature: setStep|void-void|simple-oaUInt4,\n"
"    This function sets the step value for this vector name to the specified value.\n"
"    val\n"
"    The step value\n"
;

static PyObject*
oaVectorName_setStep(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorName data;
    int convert_status=PyoaVectorName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorNameObject* self=(PyoaVectorNameObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setStep(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVectorName_setStop_doc[] = 
"Class: oaVectorName, Function: setStop\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setStop(oaUInt4 val)\n"
"    Signature: setStop|void-void|simple-oaUInt4,\n"
"    This function sets the stop index for this vector name to the specified value.\n"
"    val\n"
"    The stop value\n"
;

static PyObject*
oaVectorName_setStop(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVectorName data;
    int convert_status=PyoaVectorName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVectorNameObject* self=(PyoaVectorNameObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setStop(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaVectorName_assign_doc[] = 
"Class: oaVectorName, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVectorName_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVectorName data;
  int convert_status=PyoaVectorName_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVectorName p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVectorName_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVectorName_methodlist[] = {
    {"append",(PyCFunction)oaVectorName_append,METH_VARARGS,oaVectorName_append_doc},
    {"get",(PyCFunction)oaVectorName_get,METH_VARARGS,oaVectorName_get_doc},
    {"getBaseName",(PyCFunction)oaVectorName_getBaseName,METH_VARARGS,oaVectorName_getBaseName_doc},
    {"getBitName",(PyCFunction)oaVectorName_getBitName,METH_VARARGS,oaVectorName_getBitName_doc},
    {"getNumBits",(PyCFunction)oaVectorName_getNumBits,METH_VARARGS,oaVectorName_getNumBits_doc},
    {"getStart",(PyCFunction)oaVectorName_getStart,METH_VARARGS,oaVectorName_getStart_doc},
    {"getStep",(PyCFunction)oaVectorName_getStep,METH_VARARGS,oaVectorName_getStep_doc},
    {"getStop",(PyCFunction)oaVectorName_getStop,METH_VARARGS,oaVectorName_getStop_doc},
    {"init",(PyCFunction)oaVectorName_init,METH_VARARGS,oaVectorName_init_doc},
    {"setStart",(PyCFunction)oaVectorName_setStart,METH_VARARGS,oaVectorName_setStart_doc},
    {"setStep",(PyCFunction)oaVectorName_setStep,METH_VARARGS,oaVectorName_setStep_doc},
    {"setStop",(PyCFunction)oaVectorName_setStop,METH_VARARGS,oaVectorName_setStop_doc},
    {"assign",(PyCFunction)oaVectorName_tp_assign,METH_VARARGS,oaVectorName_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVectorName_doc[] = 
"Class: oaVectorName\n"
"  The oaVectorName utility class holds a name for a database object that consists of a base name with an index range. These names can be hierarchical. The index range may be high to low or low to high, and may have an optional step value. If the step value is greater than 1, then a step value of n means that the vector only includes every nth bit after the starting bit.\n"
"  In conjunction with the oaNameSpace objects, this class facilitates mapping names from one namespace to another. See the Name Mapping Section in the Programmers Guide for more information about mapping names between different namespaces.\n"
"  An example of an oaVectorName in the oaVerilog namespace is test[3:0] , where the base portion of this name is test , and start index is 3, the stop index is 0, and the implied step value is 1.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaVectorName()\n"
"    Signature: oaVectorName||\n"
"    This function constructs an empty oaVectorName object.\n"
"  Paramegers: (oaNameSpace,[oaChar],oaUInt4,oaUInt4)\n"
"    Calls: oaVectorName(const oaNameSpace& nSpace,const oaChar* in,oaUInt4 start,oaUInt4 stop)\n"
"    Signature: oaVectorName||cref-oaNameSpace,cptr-oaChar,simple-oaUInt4,simple-oaUInt4,simple-oaUInt4,\n"
"    This function constructs an oaVectorName object, evaluating the specified input string in the specified oaNameSpace . The input string is assumed to be the base portion of the name.\n"
"    nSpace\n"
"    The oaNameSpace in which to evaluate the string\n"
"    in\n"
"    The input string to evaluate as the base name\n"
"    start\n"
"    The start index for the vector\n"
"    stop\n"
"    The stop index for the vector\n"
"    step\n"
"    The step value for the vector\n"
"    oacInvalidNameLength\n"
"    oacInvalidNameSyntax\n"
"    oacInvalidVectorValue\n"
"  Paramegers: (oaNameSpace,[oaChar],oaUInt4,oaUInt4,oaUInt4)\n"
"    Calls: oaVectorName(const oaNameSpace& nSpace,const oaChar* in,oaUInt4 start,oaUInt4 stop,oaUInt4 step)\n"
"    Signature: oaVectorName||cref-oaNameSpace,cptr-oaChar,simple-oaUInt4,simple-oaUInt4,simple-oaUInt4,\n"
"    This function constructs an oaVectorName object, evaluating the specified input string in the specified oaNameSpace . The input string is assumed to be the base portion of the name.\n"
"    nSpace\n"
"    The oaNameSpace in which to evaluate the string\n"
"    in\n"
"    The input string to evaluate as the base name\n"
"    start\n"
"    The start index for the vector\n"
"    stop\n"
"    The stop index for the vector\n"
"    step\n"
"    The step value for the vector\n"
"    oacInvalidNameLength\n"
"    oacInvalidNameSyntax\n"
"    oacInvalidVectorValue\n"
"  Paramegers: (oaNameSpace,[oaChar])\n"
"    Calls: oaVectorName(const oaNameSpace& nSpace,const oaChar* in)\n"
"    Signature: oaVectorName||cref-oaNameSpace,cptr-oaChar,\n"
"    This function constructs an oaVectorName object, evaluating the specified input string in the specified oaNameSpace .\n"
"    nSpace\n"
"    The oaNameSpace in which to evaluate the string\n"
"    in\n"
"    The input string to evaluate\n"
"    oacInvalidNameLength\n"
"    oacInvalidNameSyntax\n"
"    oacInvalidVectorValue\n"
"  Paramegers: (oaScalarName,oaUInt4,oaUInt4)\n"
"    Calls: oaVectorName(const oaScalarName& in,oaUInt4 start,oaUInt4 stop)\n"
"    Signature: oaVectorName||cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,simple-oaUInt4,\n"
"    This function constructs an oaVectorName object using an oaScalarName that represents the base name of the vector, plus start , stop , and step values that represent the vector value of the name.\n"
"    in\n"
"    The base portion of this name represented as an oaScalarName\n"
"    start\n"
"    The start index for the vector\n"
"    stop\n"
"    The stop index for the vector\n"
"    step\n"
"    The step value for the vector\n"
"    oacInvalidVectorValue\n"
"  Paramegers: (oaScalarName,oaUInt4,oaUInt4,oaUInt4)\n"
"    Calls: oaVectorName(const oaScalarName& in,oaUInt4 start,oaUInt4 stop,oaUInt4 step)\n"
"    Signature: oaVectorName||cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,simple-oaUInt4,\n"
"    This function constructs an oaVectorName object using an oaScalarName that represents the base name of the vector, plus start , stop , and step values that represent the vector value of the name.\n"
"    in\n"
"    The base portion of this name represented as an oaScalarName\n"
"    start\n"
"    The start index for the vector\n"
"    stop\n"
"    The stop index for the vector\n"
"    step\n"
"    The step value for the vector\n"
"    oacInvalidVectorValue\n"
"  Paramegers: (oaVectorName)\n"
"    Calls: oaVectorName(const oaVectorName& in)\n"
"    Signature: oaVectorName||cref-oaVectorName,\n"
"    This function constructs a copy of the specified oaVectorName object.\n"
"    name\n"
"    The vector to copy\n"
"  Paramegers: (oaVectorName)\n"
"    Calls: (const oaVectorName&)\n"
"    Signature: oaVectorName||cref-oaVectorName,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVectorName_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVectorName",
    sizeof(PyoaVectorNameObject),
    0,
    (destructor)oaVectorName_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVectorName_tp_compare,	/* tp_compare */
    (reprfunc)oaVectorName_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVectorName_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVectorName_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaNameBase_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVectorName_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVectorName_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVectorName_Type)<0) {
      printf("** PyType_Ready failed for: oaVectorName\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVectorName",
           (PyObject*)(&PyoaVectorName_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVectorName\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVerilogNS
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVerilogNS_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVerilogNS_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVerilogNSObject* self = (PyoaVerilogNSObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaNameSpace*)  new oaVerilogNS();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaVerilogNS)
    {
        PyParamoaVerilogNS p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVerilogNS_Convert,&p1)) {
            self->value = (oaNameSpace*)  new oaVerilogNS(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVerilogNS, Choices are:\n"
        "    ()\n"
        "    (oaVerilogNS)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVerilogNS_tp_dealloc(PyoaVerilogNSObject* self)
{
    if (!self->borrow) {
        delete (oaVerilogNS*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVerilogNS_tp_repr(PyObject *ob)
{
    PyParamoaVerilogNS value;
    int convert_status=PyoaVerilogNS_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[33];
    sprintf(buffer,"<oaVerilogNS::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVerilogNS_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVerilogNS v1;
    PyParamoaVerilogNS v2;
    int convert_status1=PyoaVerilogNS_Convert(ob1,&v1);
    int convert_status2=PyoaVerilogNS_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVerilogNS_Convert(PyObject* ob,PyParamoaVerilogNS* result)
{
    if (ob == NULL) return 1;
    if (PyoaVerilogNS_Check(ob)) {
        result->SetData( (oaVerilogNS*) ((PyoaVerilogNSObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVerilogNS Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVerilogNS_FromoaVerilogNS(oaVerilogNS* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaVerilogNS_Type.tp_alloc(&PyoaVerilogNS_Type,0);
        if (bself == NULL) return bself;
        PyoaVerilogNSObject* self = (PyoaVerilogNSObject*)bself;
        self->value = (oaNameSpace*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVerilogNS_getType_doc[] = 
"Class: oaVerilogNS, Function: getType\n"
"  Paramegers: ([oaChar])\n"
"    Calls: oaNameType getType(const oaChar* in) const\n"
"    Signature: getType|simple-oaNameType|cptr-oaChar,\n"
"    Function getType\n"
;

static PyObject*
oaVerilogNS_getType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVerilogNS data;
    int convert_status=PyoaVerilogNS_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVerilogNSObject* self=(PyoaVerilogNSObject*)ob;

    PyParamoaChar_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaChar_Array_Convert,&p1)) {
        oaNameType* result= new oaNameType(data.DataCall()->getType(p1.Data()));
        return PyoaNameType_FromoaNameType(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVerilogNS_isEqual_doc[] = 
"Class: oaVerilogNS, Function: isEqual\n"
"  Paramegers: (oaScalarName,oaScalarName)\n"
"    Calls: oaBoolean isEqual(const oaScalarName& n1,const oaScalarName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaScalarName,cref-oaScalarName,\n"
"    Function isEqual\n"
"  Paramegers: (oaVectorName,oaVectorName)\n"
"    Calls: oaBoolean isEqual(const oaVectorName& n1,const oaVectorName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaVectorName,cref-oaVectorName,\n"
"    Function isEqual\n"
"  Paramegers: (oaVectorBitName,oaVectorBitName)\n"
"    Calls: oaBoolean isEqual(const oaVectorBitName& n1,const oaVectorBitName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaVectorBitName,cref-oaVectorBitName,\n"
"    Function isEqual\n"
"  Paramegers: (oaBundleName,oaBundleName)\n"
"    Calls: oaBoolean isEqual(const oaBundleName& n1,const oaBundleName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaBundleName,cref-oaBundleName,\n"
"    Function isEqual\n"
"  Paramegers: (oaSimpleName,oaSimpleName)\n"
"    Calls: oaBoolean isEqual(const oaSimpleName& n1,const oaSimpleName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaSimpleName,cref-oaSimpleName,\n"
"    Function isEqual\n"
"  Paramegers: (oaName,oaName)\n"
"    Calls: oaBoolean isEqual(const oaName& n1,const oaName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaName,cref-oaName,\n"
"    Function isEqual\n"
;

static PyObject*
oaVerilogNS_isEqual(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVerilogNS data;
    int convert_status=PyoaVerilogNS_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVerilogNSObject* self=(PyoaVerilogNSObject*)ob;

    // Case: (oaScalarName,oaScalarName)
    {
        PyParamoaScalarName p1;
        PyParamoaScalarName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaScalarName_Convert,&p1,
              &PyoaScalarName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaVectorName,oaVectorName)
    {
        PyParamoaVectorName p1;
        PyParamoaVectorName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaVectorName_Convert,&p1,
              &PyoaVectorName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaVectorBitName,oaVectorBitName)
    {
        PyParamoaVectorBitName p1;
        PyParamoaVectorBitName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaVectorBitName_Convert,&p1,
              &PyoaVectorBitName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBundleName,oaBundleName)
    {
        PyParamoaBundleName p1;
        PyParamoaBundleName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBundleName_Convert,&p1,
              &PyoaBundleName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName,oaSimpleName)
    {
        PyParamoaSimpleName p1;
        PyParamoaSimpleName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaSimpleName_Convert,&p1,
              &PyoaSimpleName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaName,oaName)
    {
        PyParamoaName p1;
        PyParamoaName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaName_Convert,&p1,
              &PyoaName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVerilogNS, function: isEqual, Choices are:\n"
        "    (oaScalarName,oaScalarName)\n"
        "    (oaVectorName,oaVectorName)\n"
        "    (oaVectorBitName,oaVectorBitName)\n"
        "    (oaBundleName,oaBundleName)\n"
        "    (oaSimpleName,oaSimpleName)\n"
        "    (oaName,oaName)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaVerilogNS_assign_doc[] = 
"Class: oaVerilogNS, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVerilogNS_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVerilogNS data;
  int convert_status=PyoaVerilogNS_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVerilogNS p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVerilogNS_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVerilogNS_methodlist[] = {
    {"getType",(PyCFunction)oaVerilogNS_getType,METH_VARARGS,oaVerilogNS_getType_doc},
    {"isEqual",(PyCFunction)oaVerilogNS_isEqual,METH_VARARGS,oaVerilogNS_isEqual_doc},
    {"assign",(PyCFunction)oaVerilogNS_tp_assign,METH_VARARGS,oaVerilogNS_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVerilogNS_doc[] = 
"Class: oaVerilogNS\n"
"  The oaVerilogNS class implements the Verilog name space used in name mapping. The Verilog name space reflects the rules for specifying legal names of objects in the Verilog language. In conjunction with the oaName object, the oaVerilogNS class facilitates name mapping between the Unix name space and the native name space. See the Name Mapping Section of the Programmers Guide for more information.\n"
"  The Verilog name space is a case-sensitive name space and contains reserved keywords. This name space supports hierarchical constructs. This name space does not support stepped or bundled names. See the Verilog Name Space Section of the Programmers Guide for a more detailed description of the characteristics of the Verilog name space.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaVerilogNS()\n"
"    Signature: oaVerilogNS||\n"
"    This function constructs the oaVerilogNS instance.\n"
"  Paramegers: (oaVerilogNS)\n"
"    Calls: oaVerilogNS(const oaVerilogNS& ns)\n"
"    Signature: oaVerilogNS||cref-oaVerilogNS,\n"
"    This function creates a copy of the specified oaVerilogNS object.\n"
"  Paramegers: (oaVerilogNS)\n"
"    Calls: (const oaVerilogNS&)\n"
"    Signature: oaVerilogNS||cref-oaVerilogNS,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVerilogNS_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVerilogNS",
    sizeof(PyoaVerilogNSObject),
    0,
    (destructor)oaVerilogNS_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVerilogNS_tp_compare,	/* tp_compare */
    (reprfunc)oaVerilogNS_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVerilogNS_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVerilogNS_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaNameSpace_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVerilogNS_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVerilogNS_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVerilogNS_Type)<0) {
      printf("** PyType_Ready failed for: oaVerilogNS\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVerilogNS",
           (PyObject*)(&PyoaVerilogNS_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVerilogNS\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVersionComp
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVersionComp_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVersionComp_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVersionCompObject* self = (PyoaVersionCompObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaVersionCompEnum)
    {
        PyParamoaVersionCompEnum p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVersionCompEnum_Convert,&p1)) {
            self->value =  new oaVersionComp(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            self->value =  new oaVersionComp(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaVersionComp)
    {
        PyParamoaVersionComp p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVersionComp_Convert,&p1)) {
            self->value= new oaVersionComp(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVersionComp, Choices are:\n"
        "    (oaVersionCompEnum)\n"
        "    (oaString)\n"
        "    (oaVersionComp)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVersionComp_tp_dealloc(PyoaVersionCompObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVersionComp_tp_repr(PyObject *ob)
{
    PyParamoaVersionComp value;
    int convert_status=PyoaVersionComp_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    oaString sresult(value.DataCall()->getName());

    char addr[35];
    sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
    oaString buffer;
    buffer+=oaString("<oaVersionComp::");
    buffer+=oaString(addr);
    buffer+=oaString("::");
    buffer+=oaString(sresult);
    buffer+=oaString(">");
    result=PyString_FromString((char*)(const char*)buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVersionComp_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVersionComp v1;
    PyParamoaVersionComp v2;
    int convert_status1=PyoaVersionComp_Convert(ob1,&v1);
    int convert_status2=PyoaVersionComp_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVersionComp_Convert(PyObject* ob,PyParamoaVersionComp* result)
{
    if (ob == NULL) return 1;
    if (PyoaVersionComp_Check(ob)) {
        result->SetData(  ((PyoaVersionCompObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVersionComp Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVersionComp_FromoaVersionComp(oaVersionComp* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaVersionComp_Type.tp_alloc(&PyoaVersionComp_Type,0);
        if (bself == NULL) return bself;
        PyoaVersionCompObject* self = (PyoaVersionCompObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVersionComp_getName_doc[] = 
"Class: oaVersionComp, Function: getName\n"
"  Paramegers: ()\n"
"    Calls: const oaString& getName() const\n"
"    Signature: getName|cref-oaString|\n"
"    BrowseData: 1\n"
"    This function returns the name of the oaVersionCompEnum value set on this oaVersionComp wrapper object.\n"
;

static PyObject*
oaVersionComp_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVersionComp data;
    int convert_status=PyoaVersionComp_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVersionCompObject* self=(PyoaVersionCompObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaString result= (data.DataCall()->getName());
        return PyoaString_FromoaString(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVersionComp_oaVersionCompEnum_doc[] = 
"Class: oaVersionComp, Function: oaVersionCompEnum\n"
"  Paramegers: ()\n"
"    Calls: oaVersionCompEnum oaVersionCompEnum() const\n"
"    Signature: operator oaVersionCompEnum|simple-oaVersionCompEnum|\n"
"    BrowseData: 1\n"
"    This operator casts this oaVersionComp object into its corresponding oaVersionCompEnum value.\n"
;

static PyObject*
oaVersionComp_oaVersionCompEnum(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVersionComp data;
    int convert_status=PyoaVersionComp_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVersionCompObject* self=(PyoaVersionCompObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaVersionCompEnum result= (data.DataCall()->operator oaVersionCompEnum());
        return PyoaVersionCompEnum_FromoaVersionCompEnum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaVersionComp_assign_doc[] = 
"Class: oaVersionComp, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVersionComp_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVersionComp data;
  int convert_status=PyoaVersionComp_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVersionComp p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVersionComp_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVersionComp_methodlist[] = {
    {"getName",(PyCFunction)oaVersionComp_getName,METH_VARARGS,oaVersionComp_getName_doc},
    {"oaVersionCompEnum",(PyCFunction)oaVersionComp_oaVersionCompEnum,METH_VARARGS,oaVersionComp_oaVersionCompEnum_doc},
    {"assign",(PyCFunction)oaVersionComp_tp_assign,METH_VARARGS,oaVersionComp_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVersionComp_doc[] = 
"Class: oaVersionComp\n"
"  The oaVersionComp class is an enum wrapper class for oaVersionCompEnum values, which describe the results of version control system comparison operations.\n"
"  oaVersionCompEnum\n"
"Constructors:\n"
"  Paramegers: (oaVersionCompEnum)\n"
"    Calls: oaVersionComp(oaVersionCompEnum valueIn)\n"
"    Signature: oaVersionComp||simple-oaVersionCompEnum,\n"
"    This oaVersionComp constructor takes an oaVersionCompEnum value.\n"
"    valueIn\n"
"    an oaVersionCompEnum value\n"
"  Paramegers: (oaString)\n"
"    Calls: oaVersionComp(const oaString& name)\n"
"    Signature: oaVersionComp||cref-oaString,\n"
"    This oaVersionComp constructor takes an oaVersionCompEnum name.\n"
"    name\n"
"    the name associated with an oaVersionCompEnum value\n"
"    oacInvalidVersionCompName\n"
"  Paramegers: (oaVersionComp)\n"
"    Calls: (const oaVersionComp&)\n"
"    Signature: oaVersionComp||cref-oaVersionComp,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVersionComp_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVersionComp",
    sizeof(PyoaVersionCompObject),
    0,
    (destructor)oaVersionComp_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVersionComp_tp_compare,	/* tp_compare */
    (reprfunc)oaVersionComp_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVersionComp_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVersionComp_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVersionComp_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVersionComp_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVersionComp_Type)<0) {
      printf("** PyType_Ready failed for: oaVersionComp\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVersionComp",
           (PyObject*)(&PyoaVersionComp_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVersionComp\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVersionCompEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaVersionCompEnum_Convert(PyObject* ob,PyParamoaVersionCompEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacVersionCompEqual")==0) { result->SetData(oacVersionCompEqual); return 1;}
        if (strcasecmp(str,"oacVersionCompEarlier")==0) { result->SetData(oacVersionCompEarlier); return 1;}
        if (strcasecmp(str,"oacVersionCompLater")==0) { result->SetData(oacVersionCompLater); return 1;}
        if (strcasecmp(str,"oacVersionCompDifferentBranch")==0) { result->SetData(oacVersionCompDifferentBranch); return 1;}
        if (strcasecmp(str,"oacVersionCompIncompatable")==0) { result->SetData(oacVersionCompIncompatable); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaVersionCompEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVersionCompEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaVersionCompEnum_FromoaVersionCompEnum(oaVersionCompEnum ob)
{
    if (ob==oacVersionCompEqual) return PyString_FromString("oacVersionCompEqual");
    if (ob==oacVersionCompEarlier) return PyString_FromString("oacVersionCompEarlier");
    if (ob==oacVersionCompLater) return PyString_FromString("oacVersionCompLater");
    if (ob==oacVersionCompDifferentBranch) return PyString_FromString("oacVersionCompDifferentBranch");
    if (ob==oacVersionCompIncompatable) return PyString_FromString("oacVersionCompIncompatable");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaVersionCompEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaVersionCompEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaVersionCompEnum_FromoaVersionCompEnum(oaVersionCompEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaVersionCompEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaVersionCompEnum_doc[] =
"Type convert function for enum: oaVersionCompEnum";
                               
static PyMethodDef PyoaVersionCompEnum_method =
  {"oaVersionCompEnum",(PyCFunction)PyoaVersionCompEnum_TypeFunction,METH_VARARGS,oaVersionCompEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaVersionCompEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacVersionCompEqual");
    PyDict_SetItemString(mod_dict,"oacVersionCompEqual",value);
    Py_DECREF(value);
    value=PyString_FromString("oacVersionCompEarlier");
    PyDict_SetItemString(mod_dict,"oacVersionCompEarlier",value);
    Py_DECREF(value);
    value=PyString_FromString("oacVersionCompLater");
    PyDict_SetItemString(mod_dict,"oacVersionCompLater",value);
    Py_DECREF(value);
    value=PyString_FromString("oacVersionCompDifferentBranch");
    PyDict_SetItemString(mod_dict,"oacVersionCompDifferentBranch",value);
    Py_DECREF(value);
    value=PyString_FromString("oacVersionCompIncompatable");
    PyDict_SetItemString(mod_dict,"oacVersionCompIncompatable",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaVersionCompEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaVersionCompEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaVersionCompEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVhdlNS
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVhdlNS_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVhdlNS_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaVhdlNSObject* self = (PyoaVhdlNSObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaNameSpace*)  new oaVhdlNS();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaVhdlNS)
    {
        PyParamoaVhdlNS p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVhdlNS_Convert,&p1)) {
            self->value = (oaNameSpace*)  new oaVhdlNS(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVhdlNS, Choices are:\n"
        "    ()\n"
        "    (oaVhdlNS)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVhdlNS_tp_dealloc(PyoaVhdlNSObject* self)
{
    if (!self->borrow) {
        delete (oaVhdlNS*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVhdlNS_tp_repr(PyObject *ob)
{
    PyParamoaVhdlNS value;
    int convert_status=PyoaVhdlNS_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[30];
    sprintf(buffer,"<oaVhdlNS::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVhdlNS_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVhdlNS v1;
    PyParamoaVhdlNS v2;
    int convert_status1=PyoaVhdlNS_Convert(ob1,&v1);
    int convert_status2=PyoaVhdlNS_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVhdlNS_Convert(PyObject* ob,PyParamoaVhdlNS* result)
{
    if (ob == NULL) return 1;
    if (PyoaVhdlNS_Check(ob)) {
        result->SetData( (oaVhdlNS*) ((PyoaVhdlNSObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVhdlNS Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVhdlNS_FromoaVhdlNS(oaVhdlNS* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaVhdlNS_Type.tp_alloc(&PyoaVhdlNS_Type,0);
        if (bself == NULL) return bself;
        PyoaVhdlNSObject* self = (PyoaVhdlNSObject*)bself;
        self->value = (oaNameSpace*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVhdlNS_getType_doc[] = 
"Class: oaVhdlNS, Function: getType\n"
"  Paramegers: ([oaChar])\n"
"    Calls: oaNameType getType(const oaChar* in) const\n"
"    Signature: getType|simple-oaNameType|cptr-oaChar,\n"
"    Function getType\n"
;

static PyObject*
oaVhdlNS_getType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVhdlNS data;
    int convert_status=PyoaVhdlNS_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVhdlNSObject* self=(PyoaVhdlNSObject*)ob;

    PyParamoaChar_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaChar_Array_Convert,&p1)) {
        oaNameType* result= new oaNameType(data.DataCall()->getType(p1.Data()));
        return PyoaNameType_FromoaNameType(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVhdlNS_isEqual_doc[] = 
"Class: oaVhdlNS, Function: isEqual\n"
"  Paramegers: (oaScalarName,oaScalarName)\n"
"    Calls: oaBoolean isEqual(const oaScalarName& n1,const oaScalarName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaScalarName,cref-oaScalarName,\n"
"    Function isEqual\n"
"  Paramegers: (oaVectorName,oaVectorName)\n"
"    Calls: oaBoolean isEqual(const oaVectorName& n1,const oaVectorName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaVectorName,cref-oaVectorName,\n"
"    Function isEqual\n"
"  Paramegers: (oaVectorBitName,oaVectorBitName)\n"
"    Calls: oaBoolean isEqual(const oaVectorBitName& n1,const oaVectorBitName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaVectorBitName,cref-oaVectorBitName,\n"
"    Function isEqual\n"
"  Paramegers: (oaBundleName,oaBundleName)\n"
"    Calls: oaBoolean isEqual(const oaBundleName& n1,const oaBundleName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaBundleName,cref-oaBundleName,\n"
"    Function isEqual\n"
"  Paramegers: (oaSimpleName,oaSimpleName)\n"
"    Calls: oaBoolean isEqual(const oaSimpleName& n1,const oaSimpleName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaSimpleName,cref-oaSimpleName,\n"
"    Function isEqual\n"
"  Paramegers: (oaName,oaName)\n"
"    Calls: oaBoolean isEqual(const oaName& n1,const oaName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaName,cref-oaName,\n"
"    Function isEqual\n"
;

static PyObject*
oaVhdlNS_isEqual(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVhdlNS data;
    int convert_status=PyoaVhdlNS_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaVhdlNSObject* self=(PyoaVhdlNSObject*)ob;

    // Case: (oaScalarName,oaScalarName)
    {
        PyParamoaScalarName p1;
        PyParamoaScalarName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaScalarName_Convert,&p1,
              &PyoaScalarName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaVectorName,oaVectorName)
    {
        PyParamoaVectorName p1;
        PyParamoaVectorName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaVectorName_Convert,&p1,
              &PyoaVectorName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaVectorBitName,oaVectorBitName)
    {
        PyParamoaVectorBitName p1;
        PyParamoaVectorBitName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaVectorBitName_Convert,&p1,
              &PyoaVectorBitName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBundleName,oaBundleName)
    {
        PyParamoaBundleName p1;
        PyParamoaBundleName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBundleName_Convert,&p1,
              &PyoaBundleName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName,oaSimpleName)
    {
        PyParamoaSimpleName p1;
        PyParamoaSimpleName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaSimpleName_Convert,&p1,
              &PyoaSimpleName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaName,oaName)
    {
        PyParamoaName p1;
        PyParamoaName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaName_Convert,&p1,
              &PyoaName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaVhdlNS, function: isEqual, Choices are:\n"
        "    (oaScalarName,oaScalarName)\n"
        "    (oaVectorName,oaVectorName)\n"
        "    (oaVectorBitName,oaVectorBitName)\n"
        "    (oaBundleName,oaBundleName)\n"
        "    (oaSimpleName,oaSimpleName)\n"
        "    (oaName,oaName)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaVhdlNS_assign_doc[] = 
"Class: oaVhdlNS, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVhdlNS_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVhdlNS data;
  int convert_status=PyoaVhdlNS_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVhdlNS p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVhdlNS_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVhdlNS_methodlist[] = {
    {"getType",(PyCFunction)oaVhdlNS_getType,METH_VARARGS,oaVhdlNS_getType_doc},
    {"isEqual",(PyCFunction)oaVhdlNS_isEqual,METH_VARARGS,oaVhdlNS_isEqual_doc},
    {"assign",(PyCFunction)oaVhdlNS_tp_assign,METH_VARARGS,oaVhdlNS_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVhdlNS_doc[] = 
"Class: oaVhdlNS\n"
"  The oaVhdlNS class implements the VHDL name space used in name mapping. The VHDL name space reflects the rules for specifying legal names of objects using the VHDL93 standard. In conjunction with the oaName object, the oaVHDLNS class facilitates name mapping between the VHDL name space and the native name space. See the Name Mapping Section of the Programmers Guide for more information.\n"
"  The VHDL name space supports names in the normal or escaped form, and contains reserved keywords. VHDL normal names are case insensitive and VHDL escaped names are case sensitive. This name space does not support stepped or bundled names. See the VHDL Name Space Section of the Programmers Guide for a more detailed description of the characteristics of the VHDL name space.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaVhdlNS()\n"
"    Signature: oaVhdlNS||\n"
"    This function constructs the oaVhdlNS instance.\n"
"  Paramegers: (oaVhdlNS)\n"
"    Calls: oaVhdlNS(const oaVhdlNS& ns)\n"
"    Signature: oaVhdlNS||cref-oaVhdlNS,\n"
"    This function creates a copy of the specified oaVhdlNS object.\n"
"  Paramegers: (oaVhdlNS)\n"
"    Calls: (const oaVhdlNS&)\n"
"    Signature: oaVhdlNS||cref-oaVhdlNS,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVhdlNS_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVhdlNS",
    sizeof(PyoaVhdlNSObject),
    0,
    (destructor)oaVhdlNS_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVhdlNS_tp_compare,	/* tp_compare */
    (reprfunc)oaVhdlNS_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVhdlNS_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVhdlNS_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaNameSpace_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVhdlNS_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVhdlNS_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVhdlNS_Type)<0) {
      printf("** PyType_Ready failed for: oaVhdlNS\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVhdlNS",
           (PyObject*)(&PyoaVhdlNS_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVhdlNS\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaVia
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaVia_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaVia_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaViaObject* self = (PyoaViaObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaVia)
    {
        PyParamoaVia p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaVia_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaVia, Choices are:\n"
        "    (oaVia)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaVia_tp_dealloc(PyoaViaObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaVia_tp_repr(PyObject *ob)
{
    PyParamoaVia value;
    int convert_status=PyoaVia_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[27];
    sprintf(buffer,"<oaVia::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaVia_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaVia v1;
    PyParamoaVia v2;
    int convert_status1=PyoaVia_Convert(ob1,&v1);
    int convert_status2=PyoaVia_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaVia_Convert(PyObject* ob,PyParamoaVia* result)
{
    if (ob == NULL) return 1;
    if (PyoaVia_Check(ob)) {
        result->SetData( (oaVia**) ((PyoaViaObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaVia Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaVia_FromoaVia(oaVia** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaVia* data=*value;
        if (data->getType()==oacStdViaType) return PyoaStdVia_FromoaStdVia((oaStdVia**)value,borrow,lock);
        if (data->getType()==oacCustomViaType) return PyoaCustomVia_FromoaCustomVia((oaCustomVia**)value,borrow,lock);
        PyObject* bself = PyoaVia_Type.tp_alloc(&PyoaVia_Type,0);
        if (bself == NULL) return bself;
        PyoaViaObject* self = (PyoaViaObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaVia_FromoaVia(oaVia* data)
{
    if (data) {
        if (data->getType()==oacStdViaType) return PyoaStdVia_FromoaStdVia((oaStdVia*)data);
        if (data->getType()==oacCustomViaType) return PyoaCustomVia_FromoaCustomVia((oaCustomVia*)data);
       PyObject* bself = PyoaVia_Type.tp_alloc(&PyoaVia_Type,0);
       if (bself == NULL) return bself;
       PyoaViaObject* self = (PyoaViaObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVia_getConnRoutes_doc[] = 
"Class: oaVia, Function: getConnRoutes\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaRoute_oaVia getConnRoutes() const\n"
"    Signature: getConnRoutes|simple-oaCollection_oaRoute_oaVia|\n"
"    BrowseData: 1\n"
"    This function returns a collection of routes that are connected to this via. Each route in the collection has this via as either its startConn, endConn, or both.\n"
;

static PyObject*
oaVia_getConnRoutes(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVia data;
    int convert_status=PyoaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaObject* self=(PyoaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaRoute_oaVia* result= new oaCollection_oaRoute_oaVia(data.DataCall()->getConnRoutes());
        return PyoaCollection_oaRoute_oaVia_FromoaCollection_oaRoute_oaVia(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVia_getConnRoutesIter_doc[] = 
"Class: oaVia, Function: getConnRoutesIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaRoute getConnRoutesIter() const\n"
"    Signature: getConnRoutesIter|simple-oaIter_oaRoute|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of routes that are connected to this via. Each route in the collection has this via as either its startConn, endConn, or both.\n"
;

static PyObject*
oaVia_getConnRoutesIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVia data;
    int convert_status=PyoaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaObject* self=(PyoaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaRoute* result= new oaIter_oaRoute(data.DataCall()->getConnRoutes());
        return PyoaIter_oaRoute_FromoaIter_oaRoute(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVia_getDirection_doc[] = 
"Class: oaVia, Function: getDirection\n"
"  Paramegers: ()\n"
"    Calls: oaViaDirection getDirection() const\n"
"    Signature: getDirection|simple-oaViaDirection|\n"
"    BrowseData: 1\n"
"    This function returns the direction of this via.\n"
;

static PyObject*
oaVia_getDirection(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVia data;
    int convert_status=PyoaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaObject* self=(PyoaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaViaDirection* result= new oaViaDirection(data.DataCall()->getDirection());
        return PyoaViaDirection_FromoaViaDirection(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVia_getHeader_doc[] = 
"Class: oaVia, Function: getHeader\n"
"  Paramegers: ()\n"
"    Calls: oaViaHeader* getHeader() const\n"
"    Signature: getHeader|ptr-oaViaHeader|\n"
"    BrowseData: 1\n"
"    This function returns the viaHeader associated with this via. The viaHeader is a collection of the attributes that are common to all vias of a particular via definition. For vias of via definitions that have parameters, this function returns the via subheader.\n"
"    The pointer to the via header\n"
;

static PyObject*
oaVia_getHeader(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVia data;
    int convert_status=PyoaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaObject* self=(PyoaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaViaHeaderp result= (data.DataCall()->getHeader());
        return PyoaViaHeader_FromoaViaHeader(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVia_getPurposeNum_doc[] = 
"Class: oaVia, Function: getPurposeNum\n"
"  Paramegers: ()\n"
"    Calls: oaPurposeNum getPurposeNum() const\n"
"    Signature: getPurposeNum|simple-oaPurposeNum|\n"
"    BrowseData: 1\n"
"    This function returns the purpose number associated with this via.\n"
;

static PyObject*
oaVia_getPurposeNum(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVia data;
    int convert_status=PyoaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaObject* self=(PyoaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaPurposeNum result= (data.DataCall()->getPurposeNum());
        return PyoaPurposeNum_FromoaPurposeNum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVia_getRoute_doc[] = 
"Class: oaVia, Function: getRoute\n"
"  Paramegers: ()\n"
"    Calls: oaRoute* getRoute() const\n"
"    Signature: getRoute|ptr-oaRoute|\n"
"    BrowseData: 1\n"
"    This function returns the route to which this via may belong. If this via does not belong to a route, a NULL is returned.\n"
;

static PyObject*
oaVia_getRoute(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVia data;
    int convert_status=PyoaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaObject* self=(PyoaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaRoutep result= (data.DataCall()->getRoute());
        return PyoaRoute_FromoaRoute(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVia_getRouteStatus_doc[] = 
"Class: oaVia, Function: getRouteStatus\n"
"  Paramegers: ()\n"
"    Calls: oaRouteStatus getRouteStatus() const\n"
"    Signature: getRouteStatus|simple-oaRouteStatus|\n"
"    BrowseData: 1\n"
"    This function returns the current routing status of this via.\n"
;

static PyObject*
oaVia_getRouteStatus(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVia data;
    int convert_status=PyoaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaObject* self=(PyoaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaRouteStatus* result= new oaRouteStatus(data.DataCall()->getRouteStatus());
        return PyoaRouteStatus_FromoaRouteStatus(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVia_getRouteTopology_doc[] = 
"Class: oaVia, Function: getRouteTopology\n"
"  Paramegers: ()\n"
"    Calls: oaRouteTopology getRouteTopology() const\n"
"    Signature: getRouteTopology|simple-oaRouteTopology|\n"
"    BrowseData: 1\n"
"    This function returns the current routing topology of this via.\n"
;

static PyObject*
oaVia_getRouteTopology(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVia data;
    int convert_status=PyoaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaObject* self=(PyoaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaRouteTopology* result= new oaRouteTopology(data.DataCall()->getRouteTopology());
        return PyoaRouteTopology_FromoaRouteTopology(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVia_getShieldedNet1_doc[] = 
"Class: oaVia, Function: getShieldedNet1\n"
"  Paramegers: ()\n"
"    Calls: oaBitNet* getShieldedNet1() const\n"
"    Signature: getShieldedNet1|ptr-oaBitNet|\n"
"    BrowseData: 1\n"
"    This function returns the first net that this via is shielding. A via may shield up to two nets.\n"
;

static PyObject*
oaVia_getShieldedNet1(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVia data;
    int convert_status=PyoaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaObject* self=(PyoaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBitNetp result= (data.DataCall()->getShieldedNet1());
        return PyoaBitNet_FromoaBitNet(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVia_getShieldedNet2_doc[] = 
"Class: oaVia, Function: getShieldedNet2\n"
"  Paramegers: ()\n"
"    Calls: oaBitNet* getShieldedNet2() const\n"
"    Signature: getShieldedNet2|ptr-oaBitNet|\n"
"    BrowseData: 1\n"
"    This function returns the second net that this via is shielding. A via may shield up to two nets.\n"
;

static PyObject*
oaVia_getShieldedNet2(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVia data;
    int convert_status=PyoaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaObject* self=(PyoaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBitNetp result= (data.DataCall()->getShieldedNet2());
        return PyoaBitNet_FromoaBitNet(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVia_getViaDef_doc[] = 
"Class: oaVia, Function: getViaDef\n"
"  Paramegers: ()\n"
"    Calls: oaViaDef* getViaDef() const\n"
"    Signature: getViaDef|ptr-oaViaDef|\n"
"    BrowseData: 1\n"
"    This function returns the oaViaDef object associated with this via. If the oaViaDef is not bound, a NULL is returned.\n"
;

static PyObject*
oaVia_getViaDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVia data;
    int convert_status=PyoaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaObject* self=(PyoaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaViaDefp result= (data.DataCall()->getViaDef());
        return PyoaViaDef_FromoaViaDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVia_getViaDefName_doc[] = 
"Class: oaVia, Function: getViaDefName\n"
"  Paramegers: (oaString)\n"
"    Calls: void getViaDefName(oaString& name) const\n"
"    Signature: getViaDefName|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out name with the name of the via definition associated with this via.\n"
;

static PyObject*
oaVia_getViaDefName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVia data;
    int convert_status=PyoaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaObject* self=(PyoaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getViaDefName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVia_hasRoute_doc[] = 
"Class: oaVia, Function: hasRoute\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean hasRoute() const\n"
"    Signature: hasRoute|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns true if this via is part of a route, false otherwise.\n"
;

static PyObject*
oaVia_hasRoute(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVia data;
    int convert_status=PyoaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaObject* self=(PyoaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->hasRoute());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVia_isUnShielded_doc[] = 
"Class: oaVia, Function: isUnShielded\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isUnShielded() const\n"
"    Signature: isUnShielded|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns true if this via is not shielded.\n"
;

static PyObject*
oaVia_isUnShielded(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVia data;
    int convert_status=PyoaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaObject* self=(PyoaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isUnShielded());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVia_setDirection_doc[] = 
"Class: oaVia, Function: setDirection\n"
"  Paramegers: (oaViaDirection)\n"
"    Calls: void setDirection(const oaViaDirection& dir)\n"
"    Signature: setDirection|void-void|cref-oaViaDirection,\n"
"    This function sets the direction of this via to the specified 'dir'.\n"
"    dir\n"
"    The direction to be set for this via\n"
;

static PyObject*
oaVia_setDirection(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVia data;
    int convert_status=PyoaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaObject* self=(PyoaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaDirection p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaViaDirection_Convert,&p1)) {
        data.DataCall()->setDirection(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVia_setPurposeNum_doc[] = 
"Class: oaVia, Function: setPurposeNum\n"
"  Paramegers: (oaPurposeNum)\n"
"    Calls: void setPurposeNum(oaPurposeNum purposeNum)\n"
"    Signature: setPurposeNum|void-void|simple-oaPurposeNum,\n"
"    This function sets the purpose of this via to the specified 'purposeNum' value.\n"
"    purposeNum\n"
"    The new technology purpose number to associate with this via\n"
;

static PyObject*
oaVia_setPurposeNum(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVia data;
    int convert_status=PyoaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaObject* self=(PyoaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaPurposeNum p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaPurposeNum_Convert,&p1)) {
        data.DataCall()->setPurposeNum(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVia_setRouteStatus_doc[] = 
"Class: oaVia, Function: setRouteStatus\n"
"  Paramegers: (oaRouteStatus)\n"
"    Calls: void setRouteStatus(const oaRouteStatus& status)\n"
"    Signature: setRouteStatus|void-void|cref-oaRouteStatus,\n"
"    This function sets the routeStatus of this via to the specified 'status'.\n"
"    status\n"
"    The routing status to be set for this via\n"
;

static PyObject*
oaVia_setRouteStatus(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVia data;
    int convert_status=PyoaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaObject* self=(PyoaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaRouteStatus p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaRouteStatus_Convert,&p1)) {
        data.DataCall()->setRouteStatus(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVia_setRouteTopology_doc[] = 
"Class: oaVia, Function: setRouteTopology\n"
"  Paramegers: (oaRouteTopology)\n"
"    Calls: void setRouteTopology(const oaRouteTopology& topology)\n"
"    Signature: setRouteTopology|void-void|cref-oaRouteTopology,\n"
"    This function sets the routeTopology of this via to the specified 'topology'.\n"
"    topology\n"
"    The routing topology to be set for this via\n"
;

static PyObject*
oaVia_setRouteTopology(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVia data;
    int convert_status=PyoaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaObject* self=(PyoaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaRouteTopology p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaRouteTopology_Convert,&p1)) {
        data.DataCall()->setRouteTopology(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVia_setShieldedNet1_doc[] = 
"Class: oaVia, Function: setShieldedNet1\n"
"  Paramegers: (oaBitNet)\n"
"    Calls: void setShieldedNet1(oaBitNet* net)\n"
"    Signature: setShieldedNet1|void-void|ptr-oaBitNet,\n"
"    This function sets the first shielded net for this via to the specified bit net. A via may shield up to two nets. A NULL pointer resets the attribute. Exceptions are thrown if the bit net is not in the same database as this via.\n"
"    net\n"
"    Bit net that is shielded by this via\n"
"    oacNetFigNotInSameBlock\n"
"    oacObjectAlreadyShieldsNet\n"
;

static PyObject*
oaVia_setShieldedNet1(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVia data;
    int convert_status=PyoaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaObject* self=(PyoaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBitNet p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBitNet_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->setShieldedNet1(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVia_setShieldedNet2_doc[] = 
"Class: oaVia, Function: setShieldedNet2\n"
"  Paramegers: (oaBitNet)\n"
"    Calls: void setShieldedNet2(oaBitNet* net)\n"
"    Signature: setShieldedNet2|void-void|ptr-oaBitNet,\n"
"    This function sets the second shielded net for this via to the specified bit net. A via may shield up to two nets. A NULL pointer resets the attribute. Exceptions are thrown if the bit net is not in the same database as this via.\n"
"    net\n"
"    Bit net that is shielded by this via\n"
"    oacNetFigNotInSameBlock\n"
"    oacObjectAlreadyShieldsNet\n"
;

static PyObject*
oaVia_setShieldedNet2(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVia data;
    int convert_status=PyoaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaObject* self=(PyoaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBitNet p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBitNet_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->setShieldedNet2(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVia_setUnShielded_doc[] = 
"Class: oaVia, Function: setUnShielded\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: void setUnShielded(oaBoolean unShielded)\n"
"    Signature: setUnShielded|void-void|simple-oaBoolean,\n"
"    This function sets the unShielded attribute of this via to the specified value.\n"
"    unShielded\n"
"    value\n"
;

static PyObject*
oaVia_setUnShielded(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaVia data;
    int convert_status=PyoaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaObject* self=(PyoaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBoolean p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBoolean_Convert,&p1)) {
        data.DataCall()->setUnShielded(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaVia_isNull_doc[] =
"Class: oaVia, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaVia_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaVia data;
    int convert_status=PyoaVia_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaVia_assign_doc[] = 
"Class: oaVia, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaVia_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaVia data;
  int convert_status=PyoaVia_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaVia p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaVia_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaVia_methodlist[] = {
    {"getConnRoutes",(PyCFunction)oaVia_getConnRoutes,METH_VARARGS,oaVia_getConnRoutes_doc},
    {"getConnRoutesIter",(PyCFunction)oaVia_getConnRoutesIter,METH_VARARGS,oaVia_getConnRoutesIter_doc},
    {"getDirection",(PyCFunction)oaVia_getDirection,METH_VARARGS,oaVia_getDirection_doc},
    {"getHeader",(PyCFunction)oaVia_getHeader,METH_VARARGS,oaVia_getHeader_doc},
    {"getPurposeNum",(PyCFunction)oaVia_getPurposeNum,METH_VARARGS,oaVia_getPurposeNum_doc},
    {"getRoute",(PyCFunction)oaVia_getRoute,METH_VARARGS,oaVia_getRoute_doc},
    {"getRouteStatus",(PyCFunction)oaVia_getRouteStatus,METH_VARARGS,oaVia_getRouteStatus_doc},
    {"getRouteTopology",(PyCFunction)oaVia_getRouteTopology,METH_VARARGS,oaVia_getRouteTopology_doc},
    {"getShieldedNet1",(PyCFunction)oaVia_getShieldedNet1,METH_VARARGS,oaVia_getShieldedNet1_doc},
    {"getShieldedNet2",(PyCFunction)oaVia_getShieldedNet2,METH_VARARGS,oaVia_getShieldedNet2_doc},
    {"getViaDef",(PyCFunction)oaVia_getViaDef,METH_VARARGS,oaVia_getViaDef_doc},
    {"getViaDefName",(PyCFunction)oaVia_getViaDefName,METH_VARARGS,oaVia_getViaDefName_doc},
    {"hasRoute",(PyCFunction)oaVia_hasRoute,METH_VARARGS,oaVia_hasRoute_doc},
    {"isUnShielded",(PyCFunction)oaVia_isUnShielded,METH_VARARGS,oaVia_isUnShielded_doc},
    {"setDirection",(PyCFunction)oaVia_setDirection,METH_VARARGS,oaVia_setDirection_doc},
    {"setPurposeNum",(PyCFunction)oaVia_setPurposeNum,METH_VARARGS,oaVia_setPurposeNum_doc},
    {"setRouteStatus",(PyCFunction)oaVia_setRouteStatus,METH_VARARGS,oaVia_setRouteStatus_doc},
    {"setRouteTopology",(PyCFunction)oaVia_setRouteTopology,METH_VARARGS,oaVia_setRouteTopology_doc},
    {"setShieldedNet1",(PyCFunction)oaVia_setShieldedNet1,METH_VARARGS,oaVia_setShieldedNet1_doc},
    {"setShieldedNet2",(PyCFunction)oaVia_setShieldedNet2,METH_VARARGS,oaVia_setShieldedNet2_doc},
    {"setUnShielded",(PyCFunction)oaVia_setUnShielded,METH_VARARGS,oaVia_setUnShielded_doc},
    {"isNull",(PyCFunction)oaVia_tp_isNull,METH_VARARGS,oaVia_isNull_doc},
    {"assign",(PyCFunction)oaVia_tp_assign,METH_VARARGS,oaVia_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaVia_doc[] = 
"Class: oaVia\n"
"  The oaVia class is an abstract base class for vias. A via represents a physical connection between two adjacent route pathSegs that are on different layers. A via references a via definition ( oaViaDef ) from the technology database that corresponds to the design where the via exists.\n"
"  A via may be either a standard via or a custom via. A standard via has a pre-defined set of via parameters that can be tailored to create a variety vias to cover a variety of connections. The standard via references a standard via definition.\n"
"  A custom via is very much like an instance where, through its custom via definition, another design is referenced. Custom vias often include a set of parameter values that can be used to tailor the master for each specific via.\n"
"  A via can represent complex pin figures although vias are normally associated with routes.\n"
"  Vias always have an oaViaHeader which contains the attributes that are constant for all vias of a given via definition.\n"
"  The oaVia class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaVia)\n"
"    Calls: (const oaVia&)\n"
"    Signature: oaVia||cref-oaVia,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaVia_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaVia",
    sizeof(PyoaViaObject),
    0,
    (destructor)oaVia_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaVia_tp_compare,	/* tp_compare */
    (reprfunc)oaVia_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaVia_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaVia_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaRef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaVia_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaVia_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaVia_Type)<0) {
      printf("** PyType_Ready failed for: oaVia\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaVia",
           (PyObject*)(&PyoaVia_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaVia\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaViaDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaViaDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaViaDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaViaDefObject* self = (PyoaViaDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaViaDef)
    {
        PyParamoaViaDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaViaDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaViaDef, Choices are:\n"
        "    (oaViaDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaViaDef_tp_dealloc(PyoaViaDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaViaDef_tp_repr(PyObject *ob)
{
    PyParamoaViaDef value;
    int convert_status=PyoaViaDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaViaDef::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaString sresult;
        value.DataCall()->getName(sresult);
    
        char addr[30];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaViaDef::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaViaDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaViaDef v1;
    PyParamoaViaDef v2;
    int convert_status1=PyoaViaDef_Convert(ob1,&v1);
    int convert_status2=PyoaViaDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaViaDef_Convert(PyObject* ob,PyParamoaViaDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaViaDef_Check(ob)) {
        result->SetData( (oaViaDef**) ((PyoaViaDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaViaDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaViaDef_FromoaViaDef(oaViaDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaViaDef* data=*value;
        if (data->getType()==oacCustomViaDefType) return PyoaCustomViaDef_FromoaCustomViaDef((oaCustomViaDef**)value,borrow,lock);
        if (data->getType()==oacStdViaDefType) return PyoaStdViaDef_FromoaStdViaDef((oaStdViaDef**)value,borrow,lock);
        PyObject* bself = PyoaViaDef_Type.tp_alloc(&PyoaViaDef_Type,0);
        if (bself == NULL) return bself;
        PyoaViaDefObject* self = (PyoaViaDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaViaDef_FromoaViaDef(oaViaDef* data)
{
    if (data) {
        if (data->getType()==oacCustomViaDefType) return PyoaCustomViaDef_FromoaCustomViaDef((oaCustomViaDef*)data);
        if (data->getType()==oacStdViaDefType) return PyoaStdViaDef_FromoaStdViaDef((oaStdViaDef*)data);
       PyObject* bself = PyoaViaDef_Type.tp_alloc(&PyoaViaDef_Type,0);
       if (bself == NULL) return bself;
       PyoaViaDefObject* self = (PyoaViaDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaDef_destroy_doc[] = 
"Class: oaViaDef, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function destroys this viaDef, removing it from the technology database.\n"
;

static PyObject*
oaViaDef_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaDef data;
    int convert_status=PyoaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaDefObject* self=(PyoaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaDef_getLayer1_doc[] = 
"Class: oaViaDef, Function: getLayer1\n"
"  Paramegers: ()\n"
"    Calls: oaPhysicalLayer* getLayer1() const\n"
"    Signature: getLayer1|ptr-oaPhysicalLayer|\n"
"    BrowseData: 1\n"
"    This function returns the first layer associated with this viaDef.\n"
"    To get the layer1 number associated with this viaDef even if the tech database containing the layer is unbound, refer to getLayer1Num .\n"
;

static PyObject*
oaViaDef_getLayer1(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaDef data;
    int convert_status=PyoaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaDefObject* self=(PyoaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaPhysicalLayerp result= (data.DataCall()->getLayer1());
        return PyoaPhysicalLayer_FromoaPhysicalLayer(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaDef_getLayer1Num_doc[] = 
"Class: oaViaDef, Function: getLayer1Num\n"
"  Paramegers: ()\n"
"    Calls: oaLayerNum getLayer1Num() const\n"
"    Signature: getLayer1Num|simple-oaLayerNum|\n"
"    BrowseData: 1\n"
"    oaViaDef::getLayer1Num\n"
"    This function returns the layer1 number associated with this viaDef even if the tech database containing the layer is unbound.\n"
;

static PyObject*
oaViaDef_getLayer1Num(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaDef data;
    int convert_status=PyoaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaDefObject* self=(PyoaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaLayerNum result= (data.DataCall()->getLayer1Num());
        return PyoaLayerNum_FromoaLayerNum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaDef_getLayer2_doc[] = 
"Class: oaViaDef, Function: getLayer2\n"
"  Paramegers: ()\n"
"    Calls: oaPhysicalLayer* getLayer2() const\n"
"    Signature: getLayer2|ptr-oaPhysicalLayer|\n"
"    BrowseData: 1\n"
"    This function returns the second layer associated with this viaDef.\n"
"    To get the layer2 number associated with this viaDef even if the tech database containing the layer is unbound, refer to getLayer2Num .\n"
;

static PyObject*
oaViaDef_getLayer2(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaDef data;
    int convert_status=PyoaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaDefObject* self=(PyoaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaPhysicalLayerp result= (data.DataCall()->getLayer2());
        return PyoaPhysicalLayer_FromoaPhysicalLayer(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaDef_getLayer2Num_doc[] = 
"Class: oaViaDef, Function: getLayer2Num\n"
"  Paramegers: ()\n"
"    Calls: oaLayerNum getLayer2Num() const\n"
"    Signature: getLayer2Num|simple-oaLayerNum|\n"
"    BrowseData: 1\n"
"    oaViaDef::getLayer2Num\n"
"    This function returns the layer2 number associated with this viaDef even if the tech database containing the layer is unbound.\n"
;

static PyObject*
oaViaDef_getLayer2Num(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaDef data;
    int convert_status=PyoaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaDefObject* self=(PyoaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaLayerNum result= (data.DataCall()->getLayer2Num());
        return PyoaLayerNum_FromoaLayerNum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaDef_getLayers_doc[] = 
"Class: oaViaDef, Function: getLayers\n"
"  Paramegers: (oaPhysicalLayer,oaPhysicalLayer)\n"
"    Calls: void getLayers(oaPhysicalLayer*& layer1,oaPhysicalLayer*& layer2) const\n"
"    Signature: getLayers|void-void|ptrref-oaPhysicalLayer,ptrref-oaPhysicalLayer,\n"
"    BrowseData: 0,oaPhysicalLayer,oaPhysicalLayer\n"
"    This function fills out layer1 and layer2 with the physical layers associated with this viaDef object.\n"
;

static PyObject*
oaViaDef_getLayers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaDef data;
    int convert_status=PyoaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaDefObject* self=(PyoaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaPhysicalLayer p1;
    PyParamoaPhysicalLayer p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaPhysicalLayer_Convert,&p1,
          &PyoaPhysicalLayer_Convert,&p2)) {
        data.DataCall()->getLayers(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaDef_getName_doc[] = 
"Class: oaViaDef, Function: getName\n"
"  Paramegers: (oaString)\n"
"    Calls: void getName(oaString& name) const\n"
"    Signature: getName|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out name with the name of this viaDef.\n"
;

static PyObject*
oaViaDef_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaDef data;
    int convert_status=PyoaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaDefObject* self=(PyoaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaDef_getResistancePerCut_doc[] = 
"Class: oaViaDef, Function: getResistancePerCut\n"
"  Paramegers: ()\n"
"    Calls: oaFloat getResistancePerCut() const\n"
"    Signature: getResistancePerCut|simple-oaFloat|\n"
"    BrowseData: 1\n"
"    This function returns the resistancePerCut attribute on this viaDef. The oaFloat return value specifies resistance in Ohms.\n"
;

static PyObject*
oaViaDef_getResistancePerCut(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaDef data;
    int convert_status=PyoaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaDefObject* self=(PyoaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaFloat result= (data.DataCall()->getResistancePerCut());
        return PyoaFloat_FromoaFloat(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaDef_getUsedIn_doc[] = 
"Class: oaViaDef, Function: getUsedIn\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaViaHeader_oaViaDef getUsedIn() const\n"
"    Signature: getUsedIn|simple-oaCollection_oaViaHeader_oaViaDef|\n"
"    BrowseData: 1\n"
"    This function returns a collection of viaHeaders in all open designs that refer to this viaDef object.\n"
;

static PyObject*
oaViaDef_getUsedIn(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaDef data;
    int convert_status=PyoaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaDefObject* self=(PyoaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaViaHeader_oaViaDef* result= new oaCollection_oaViaHeader_oaViaDef(data.DataCall()->getUsedIn());
        return PyoaCollection_oaViaHeader_oaViaDef_FromoaCollection_oaViaHeader_oaViaDef(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaDef_getUsedInIter_doc[] = 
"Class: oaViaDef, Function: getUsedInIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaViaHeader getUsedInIter() const\n"
"    Signature: getUsedInIter|simple-oaIter_oaViaHeader|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of viaHeaders in all open designs that refer to this viaDef object.\n"
;

static PyObject*
oaViaDef_getUsedInIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaDef data;
    int convert_status=PyoaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaDefObject* self=(PyoaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaViaHeader* result= new oaIter_oaViaHeader(data.DataCall()->getUsedIn());
        return PyoaIter_oaViaHeader_FromoaIter_oaViaHeader(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaDef_hasLayer_doc[] = 
"Class: oaViaDef, Function: hasLayer\n"
"  Paramegers: (oaLayerNum)\n"
"    Calls: oaBoolean hasLayer(oaLayerNum layerNum) const\n"
"    Signature: hasLayer|simple-oaBoolean|simple-oaLayerNum,\n"
"    This function returns a boolean value that indicates if this viaDef is associated with the layer of the specified layer number.\n"
;

static PyObject*
oaViaDef_hasLayer(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaDef data;
    int convert_status=PyoaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaDefObject* self=(PyoaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaLayerNum p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaLayerNum_Convert,&p1)) {
        oaBoolean result= (data.DataCall()->hasLayer(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaDef_setResistancePerCut_doc[] = 
"Class: oaViaDef, Function: setResistancePerCut\n"
"  Paramegers: (oaFloat)\n"
"    Calls: void setResistancePerCut(oaFloat resPerCut)\n"
"    Signature: setResistancePerCut|void-void|simple-oaFloat,\n"
"    This function sets the resistancePerCut attribute on this viaDef. The resPerCut value should be specified in Ohms.\n"
;

static PyObject*
oaViaDef_setResistancePerCut(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaDef data;
    int convert_status=PyoaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaDefObject* self=(PyoaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaFloat p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaFloat_Convert,&p1)) {
        data.DataCall()->setResistancePerCut(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaDef_isNull_doc[] =
"Class: oaViaDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaViaDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaViaDef data;
    int convert_status=PyoaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaViaDef_assign_doc[] = 
"Class: oaViaDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaViaDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaViaDef data;
  int convert_status=PyoaViaDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaViaDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaViaDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaViaDef_methodlist[] = {
    {"destroy",(PyCFunction)oaViaDef_destroy,METH_VARARGS,oaViaDef_destroy_doc},
    {"getLayer1",(PyCFunction)oaViaDef_getLayer1,METH_VARARGS,oaViaDef_getLayer1_doc},
    {"getLayer1Num",(PyCFunction)oaViaDef_getLayer1Num,METH_VARARGS,oaViaDef_getLayer1Num_doc},
    {"getLayer2",(PyCFunction)oaViaDef_getLayer2,METH_VARARGS,oaViaDef_getLayer2_doc},
    {"getLayer2Num",(PyCFunction)oaViaDef_getLayer2Num,METH_VARARGS,oaViaDef_getLayer2Num_doc},
    {"getLayers",(PyCFunction)oaViaDef_getLayers,METH_VARARGS,oaViaDef_getLayers_doc},
    {"getName",(PyCFunction)oaViaDef_getName,METH_VARARGS,oaViaDef_getName_doc},
    {"getResistancePerCut",(PyCFunction)oaViaDef_getResistancePerCut,METH_VARARGS,oaViaDef_getResistancePerCut_doc},
    {"getUsedIn",(PyCFunction)oaViaDef_getUsedIn,METH_VARARGS,oaViaDef_getUsedIn_doc},
    {"getUsedInIter",(PyCFunction)oaViaDef_getUsedInIter,METH_VARARGS,oaViaDef_getUsedInIter_doc},
    {"hasLayer",(PyCFunction)oaViaDef_hasLayer,METH_VARARGS,oaViaDef_hasLayer_doc},
    {"setResistancePerCut",(PyCFunction)oaViaDef_setResistancePerCut,METH_VARARGS,oaViaDef_setResistancePerCut_doc},
    {"isNull",(PyCFunction)oaViaDef_tp_isNull,METH_VARARGS,oaViaDef_isNull_doc},
    {"assign",(PyCFunction)oaViaDef_tp_assign,METH_VARARGS,oaViaDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaDef_doc[] = 
"Class: oaViaDef\n"
"  The oaViaDef class implements an oaViaDef object. An oaViaDef object defines a via design in a technology database. A via in a route must point to an oaViaDef object in the technology database associated with the design where the route resides.\n"
"  The oaViaDef class can be observed by deriving from oaObserver<oaViaDef> .\n"
"Constructors:\n"
"  Paramegers: (oaViaDef)\n"
"    Calls: (const oaViaDef&)\n"
"    Signature: oaViaDef||cref-oaViaDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaViaDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaViaDef",
    sizeof(PyoaViaDefObject),
    0,
    (destructor)oaViaDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaViaDef_tp_compare,	/* tp_compare */
    (reprfunc)oaViaDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaViaDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaViaDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaTechObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaViaDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaDef_static_find_doc[] = 
"Class: oaViaDef, Function: find\n"
"  Paramegers: (oaTech,oaString)\n"
"    Calls: oaViaDef* find(const oaTech* tech,const oaString& name)\n"
"    Signature: find|ptr-oaViaDef|cptr-oaTech,cref-oaString,\n"
"    This function searches the technology database for a viaDef with the specified name . If the specified technology database references other technology databases, those are searched as well and the first matching viaDef is returned. To find a viaDef in the current technology database only, refer to the find overload that accepts the local argument.\n"
"    This function returns the viaDef, if found. Otherwise, NULL is returned.\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    tech\n"
"    Tech database to search\n"
"    name\n"
"    Name of the viaDef to find\n"
"  Paramegers: (oaTech,oaString,oaBoolean)\n"
"    Calls: oaViaDef* find(const oaTech* tech,const oaString& name,oaBoolean local)\n"
"    Signature: find|ptr-oaViaDef|cptr-oaTech,cref-oaString,simple-oaBoolean,\n"
"    oaViaDef::find2\n"
"    This function searches for a viaDef with the specified name. The local argument specifies whether (if true) to look only in the specified technology database or (if false) to look in the specified technology database and all of its referenced databases. If found, the viaDef is returned, otherwise NULL is returned.\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    tech\n"
"    The technology database to search\n"
"    name\n"
"    Name of the viaDef to find\n"
"    local\n"
"    Specifies whether (if true) to look only in the specified technology database or (if false) to look in the specified technology database and all of its referenced databases.\n"
;

static PyObject*
oaViaDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaTech,oaString)
    {
        PyParamoaTech p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaViaDefp result= (oaViaDef::find(p1.Data(),p2.Data()));
            return PyoaViaDef_FromoaViaDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTech,oaString,oaBoolean)
    {
        PyParamoaTech p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaViaDefp result= (oaViaDef::find(p1.Data(),p2.Data(),p3.Data()));
            return PyoaViaDef_FromoaViaDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaViaDef, function: find, Choices are:\n"
        "    (oaTech,oaString)\n"
        "    (oaTech,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaViaDef_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaViaDef_static_find,METH_VARARGS,oaViaDef_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaViaDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaViaDef_Type)<0) {
      printf("** PyType_Ready failed for: oaViaDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaViaDef",
           (PyObject*)(&PyoaViaDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaViaDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaViaDef_Type.tp_dict;
    for(method=oaViaDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


// ==================================================================
// Array for class: oaViaDef
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaViaDef_Array_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaViaDef_Array_Type);
    PyObject* gself = type->tp_alloc(type,0);
    if (gself == NULL) return gself;
    PyoaViaDef_ArrayObject* self = (PyoaViaDef_ArrayObject*)gself;
    self->borrow = 0;
    self->locks=NULL;
    static char *kwlist [] = { NULL } ;
    /* Case: () */ 
    {
        if (PyArg_ParseTuple(args,"")) {
            return gself;
        }
    }
    PyErr_Clear();
    /* Case: (int) */
    {
        int p1;
        if (PyArg_ParseTuple(args,(char*)"i",&p1)) {
            self->data.SetLen(p1);
            return gself;
        }
    }
    PyErr_Clear();
    /* Case: (oaViaDef_Array) */
    {
        PyParamoaViaDef_Array p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaViaDef_Array_Convert,&p1)) {
            self->data.TakeAway(p1);
            return gself;
        }
    }
    /* Error */
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaViaDef_Array, Choices are:\n"
        "    ()\n"
        "    (int)\n"
        "    (oaViaDef_Array)\n"
    );
    Py_DECREF(gself);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaViaDef_Array_dealloc(PyObject* gself)
{
    PyoaViaDef_ArrayObject* self = (PyoaViaDef_ArrayObject*)gself;
    Py_XDECREF(self->locks);
    self->ob_type->tp_free(gself);
}

// ------------------------------------------------------------------
static PyObject*
oaViaDef_Array_str(PyObject *ob)
{
    PyParamoaViaDef_Array value;
    int convert_status=PyoaViaDef_Array_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* lst=PyoaViaDef_Array_CreateList(value);
    PyObject* result=PyObject_Str(lst);
    Py_DECREF(lst);
    return result;
}

// ------------------------------------------------------------------
static PyObject*
oaViaDef_Array_repr(PyObject *ob)
{
    PyParamoaViaDef_Array value;
    int convert_status=PyoaViaDef_Array_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* lst=PyoaViaDef_Array_CreateList(value);
    PyObject* result=PyObject_Repr(lst);
    Py_DECREF(lst);
    return result;
}

// ------------------------------------------------------------------
static int
oaViaDef_Array_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaViaDef_Array p1;
    PyParamoaViaDef_Array p2;
    int s1=PyoaViaDef_Array_Convert(ob1,&p1);
    int s2=PyoaViaDef_Array_Convert(ob2,&p2);
    assert(s1!=0);
    assert(s2!=0);
    PyObject* l1=PyoaViaDef_Array_CreateList(p1);
    PyObject* l2=PyoaViaDef_Array_CreateList(p2);
    int result=PyObject_Compare(l1,l2);
    Py_DECREF(l1);
    Py_DECREF(l2);
    return result;
}

// ------------------------------------------------------------------
int
PyoaViaDef_Array_Convert(PyObject* ob,PyParamoaViaDef_Array* result)
{
  Pyoa_ssize_t len,i;
  if (PyoaViaDef_Array_Check(ob)) {
    PyoaViaDef_ArrayObject* self = (PyoaViaDef_ArrayObject*)ob;
    result->Borrow(self->data);
  }
  else if (PyList_Check(ob)) {
    len=PyList_Size(ob);
    result->SetLen(len);
    PyParamoaViaDef data;
    for(i=0;i<len;i++) {
      PyObject* a=PyList_GetItem(ob,i);
      if (!PyoaViaDef_Convert(a,&data)) return 0;
      result->SetItem(i,data.Data());
    }
  }
  else if (PyTuple_Check(ob)) {
    len=PyTuple_Size(ob);
    result->SetLen(len);
    PyParamoaViaDef data;
    for(i=0;i<len;i++) {
      PyObject* a=PyTuple_GetItem(ob,i);
      if (!PyoaViaDef_Convert(a,&data)) return 0;
      result->SetItem(i,data.Data());
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError,
      "Convertion of parameter to class: oaViaDef_Array Failed");
    return 0;
  }
  return 1;
}

// ------------------------------------------------------------------
PyObject* PyoaViaDef_Array_FromoaViaDef_Array(const oaViaDef_Array& value)
{
  PyObject* gself = PyoaViaDef_Array_Type.tp_alloc(&PyoaViaDef_Array_Type,0);
  if (gself == NULL) return gself;
  PyoaViaDef_ArrayObject* self = (PyoaViaDef_ArrayObject*)gself;
  self->data = value;
  self->borrow = 0;
  self->locks=NULL;
  return gself;
}

// ------------------------------------------------------------------
PyObject* PyoaViaDef_Array_FromoaViaDef_Array(PyTypeoaViaDef* data,Pyoa_ssize_t len,PyObject* lock)
{
  PyObject* gself = PyoaViaDef_Array_Type.tp_alloc(&PyoaViaDef_Array_Type,0);
  if (gself == NULL) return gself;
  PyoaViaDef_ArrayObject* self = (PyoaViaDef_ArrayObject*)gself;
  self->data.Borrow(data,len);
  self->borrow = 1;
  self->locks=NULL;
  if (lock) PyoaLockObject(self->locks,lock);
  return gself;
}

// ------------------------------------------------------------------
PyObject* PyoaViaDef_Array_CreateList(PyParamoaViaDef_Array& value)
{
  Pyoa_ssize_t i;
  PyObject* lst=PyList_New(value.Len());
  for(i=0;i<value.Len();i++) {
    PyObject* ob=PyoaViaDef_FromoaViaDef(value.Data()[i]);
    PyList_SetItem(lst,i,ob);
  }
  return lst;
}

// ------------------------------------------------------------------
// Methods
// ------------------------------------------------------------------
static char oaViaDef_Array_assign_doc[] = 
"Class: oaViaDef_Array, Function: assign\n"
"  Paramegers: (oaViaDef_Array)\n"
"    This function assigns the current value.\n"
;

static PyObject*
oaViaDef_Array_assign(PyObject* ob, PyObject *args)
{
  PyoaViaDef_ArrayObject* self=(PyoaViaDef_ArrayObject*)ob;
  try {
    PyParamoaViaDef_Array p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaViaDef_Array_Convert,&p1)) {
        self->data=p1;
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}
// ------------------------------------------------------------------
static char oaViaDef_Array_list_doc[] = 
"Class: oaViaDef_Array, Function: list\n"
"  Paramegers: ()\n"
"    This function returns the current value as a list.\n"
;

static PyObject*
oaViaDef_Array_list(PyObject* ob, PyObject *args)
{
  PyoaViaDef_ArrayObject* self=(PyoaViaDef_ArrayObject*)ob;
  try {
    if (PyArg_ParseTuple(args,(char*)"")) {
      return PyoaViaDef_Array_CreateList(self->data);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}
// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------
static PyMethodDef oaViaDef_Array_methodlist[] = {
    {"assign",(PyCFunction)oaViaDef_Array_assign,METH_VARARGS,oaViaDef_Array_assign_doc},
    {"list",(PyCFunction)oaViaDef_Array_list,METH_VARARGS,oaViaDef_Array_list_doc},
   {NULL,NULL,0,NULL}
};

// ------------------------------------------------------------------
static PyObject*
oaViaDef_Array_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaViaDef_ArrayObject* self=(PyoaViaDef_ArrayObject*)ob;
  try {
    PyParamoaViaDef_Array data;
    int convert_status=PyoaViaDef_Array_Convert(ob,&data);
    assert(convert_status!=0);
    if (index<0 || index>=data.Len()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    return PyoaViaDef_FromoaViaDef(data.GetItemPtr(index),1,self->locks);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static Pyoa_ssize_t
oaViaDef_Array_index_get_length(PyObject* ob)
{
    PyParamoaViaDef_Array data;
    int convert_status=PyoaViaDef_Array_Convert(ob,&data);
    assert(convert_status!=0);
    return data.Len();
}

// ------------------------------------------------------------------
static int
oaViaDef_Array_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaViaDef_Array data;
    PyParamoaViaDef dataitem;
    int convert_status=PyoaViaDef_Array_Convert(ob,&data);
    assert(convert_status!=0);
    if (index<0 || index>=data.Len()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    if (PyoaViaDef_Convert(value,&dataitem)==0) return -1;
    data.SetItem(index,dataitem.Data());
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return 0;
  }
}

// ------------------------------------------------------------------
static char oaViaDef_Array_doc[] =
"Class: oaViaDef_Array\n"
"  The oaViaDef_Array utility class provides an array of oaViaDef.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaViaDef_Array()\n"
"    Signature: oaViaDef_Array||\n"
"    This is the default constructor for the oaViaDef_Array class. This constructor creates an empty oaViaDef_Array.\n"
"  Paramegers: (oaViaDef_Array)\n"
"    Calls: (const oaViaDef_Array&)\n"
"    Signature: oaViaDef_Array||cref-oaViaDef_Array,\n"
;

// ------------------------------------------------------------------
static PySequenceMethods oaViaDef_Array_as_sequence = {
    (Pyoa_inquiry)oaViaDef_Array_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,              /* sq_concat */
    (Pyoa_intargfunc)0,              /* sq_repeat */
    (Pyoa_intargfunc)oaViaDef_Array_index_get, /* sq_item */
    (Pyoa_intintargfunc)0,           /* sq_slice */
    (Pyoa_intobjargproc)oaViaDef_Array_index_set,      /* sq_ass_item */
};

// ------------------------------------------------------------------
PyTypeObject PyoaViaDef_Array_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaViaDef_Array",
    sizeof(PyoaViaDef_ArrayObject),
    0,
    oaViaDef_Array_dealloc, /* tp_dealloc */
    0,  /* tp_print */
    0,                                  /* tp_getattr */
    0,                                  /* tp_setattr */
    oaViaDef_Array_compare,    /* tp_compare */
    oaViaDef_Array_repr,      /* tp_repr */
    0,                                  /* tp_as_number */
    &oaViaDef_Array_as_sequence,  /* tp_as_sequence */
    0,                                  /* tp_as_mapping */
    0,                                  /* tp_as_hash */
    0,                                  /* tp_as_call */
    oaViaDef_Array_str,               /* tp_str */
    0,                                  /* tp_getattro */
    0,                                  /* tp_setattro */
    0,                                  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaViaDef_Array_doc, /* tp_doc */
    0,                                  /* tp_traverse */
    0,                                  /* tp_clear */
    0,                                  /* tp_richcompre */
    0,                                  /* tp_weaklistoffset */
    0,                                  /* tp_iter */
    0,                                  /* tp_iternext */
    oaViaDef_Array_methodlist, /* tp_methods */
    0,                                  /* tp_members */
    0,                                  /* tp_getset */
    0,                                  /* tp_base */
    0,                                  /* tp_dict */
    0,                                  /* tp_descr_get */
    0,                                  /* tp_descr_set */
    0,                                  /* tp_dictoffset */
    0,                                  /* tp_init */
    PyType_GenericAlloc,        /* tp_alloc */
    oaViaDef_Array_new, /* tp_new */
    _PyObject_Del,      /* tp_free */
};


// ------------------------------------------------------------------
int
PyoaViaDef_Array_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaViaDef_Array_Type)<0) {
      printf("** PyType_Ready failed for: oaViaDef_Array\n");
      return -1;
    }
    if (PyDict_SetItemString(mod_dict,"oaViaDef_Array",
           (PyObject*)(&PyoaViaDef_Array_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaViaDef_Array\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaViaDef2DTblValue
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaViaDef2DTblValue_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaViaDef2DTblValue_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaViaDef2DTblValueObject* self = (PyoaViaDef2DTblValueObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaViaDef2DTblValue)
    {
        PyParamoaViaDef2DTblValue p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaViaDef2DTblValue_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaViaDef2DTblValue, Choices are:\n"
        "    (oaViaDef2DTblValue)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaViaDef2DTblValue_tp_dealloc(PyoaViaDef2DTblValueObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaViaDef2DTblValue_tp_repr(PyObject *ob)
{
    PyParamoaViaDef2DTblValue value;
    int convert_status=PyoaViaDef2DTblValue_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[40];
    sprintf(buffer,"<oaViaDef2DTblValue::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaViaDef2DTblValue_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaViaDef2DTblValue v1;
    PyParamoaViaDef2DTblValue v2;
    int convert_status1=PyoaViaDef2DTblValue_Convert(ob1,&v1);
    int convert_status2=PyoaViaDef2DTblValue_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaViaDef2DTblValue_Convert(PyObject* ob,PyParamoaViaDef2DTblValue* result)
{
    if (ob == NULL) return 1;
    if (PyoaViaDef2DTblValue_Check(ob)) {
        result->SetData( (oaViaDef2DTblValue**) ((PyoaViaDef2DTblValueObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaViaDef2DTblValue Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaViaDef2DTblValue_FromoaViaDef2DTblValue(oaViaDef2DTblValue** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaViaDef2DTblValue* data=*value;
        PyObject* bself = PyoaViaDef2DTblValue_Type.tp_alloc(&PyoaViaDef2DTblValue_Type,0);
        if (bself == NULL) return bself;
        PyoaViaDef2DTblValueObject* self = (PyoaViaDef2DTblValueObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaViaDef2DTblValue_FromoaViaDef2DTblValue(oaViaDef2DTblValue* data)
{
    if (data) {
       PyObject* bself = PyoaViaDef2DTblValue_Type.tp_alloc(&PyoaViaDef2DTblValue_Type,0);
       if (bself == NULL) return bself;
       PyoaViaDef2DTblValueObject* self = (PyoaViaDef2DTblValueObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaDef2DTblValue_get_doc[] = 
"Class: oaViaDef2DTblValue, Function: get\n"
"  Paramegers: (oa2DLookupTbl_oaInt4_oaInt4_oaViaDefArrayValue)\n"
"    Calls: void get(oa2DLookupTbl_oaInt4_oaInt4_oaViaDefArrayValue& value) const\n"
"    Signature: get|void-void|ref-oa2DLookupTbl_oaInt4_oaInt4_oaViaDefArrayValue,\n"
"    BrowseData: 0,oa2DLookupTbl_oaInt4_oaInt4_oaViaDefArrayValue\n"
"    This function returns the value of this viaDef2DTblValue object.\n"
"    value\n"
"    The returned value\n"
;

static PyObject*
oaViaDef2DTblValue_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaDef2DTblValue data;
    int convert_status=PyoaViaDef2DTblValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaDef2DTblValueObject* self=(PyoaViaDef2DTblValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoa2DLookupTbl_oaInt4_oaInt4_oaViaDefArrayValue p1;
    if (PyArg_ParseTuple(args,"O&",
          &Pyoa2DLookupTbl_oaInt4_oaInt4_oaViaDefArrayValue_Convert,&p1)) {
        data.DataCall()->get(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaDef2DTblValue_set_doc[] = 
"Class: oaViaDef2DTblValue, Function: set\n"
"  Paramegers: (oa2DLookupTbl_oaInt4_oaInt4_oaViaDefArrayValue)\n"
"    Calls: void set(const oa2DLookupTbl_oaInt4_oaInt4_oaViaDefArrayValue& value)\n"
"    Signature: set|void-void|cref-oa2DLookupTbl_oaInt4_oaInt4_oaViaDefArrayValue,\n"
"    This function sets the value of this viaDef2DTblValue to the specified value.\n"
"    value\n"
"    The value to set\n"
;

static PyObject*
oaViaDef2DTblValue_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaDef2DTblValue data;
    int convert_status=PyoaViaDef2DTblValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaDef2DTblValueObject* self=(PyoaViaDef2DTblValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoa2DLookupTbl_oaInt4_oaInt4_oaViaDefArrayValue p1;
    if (PyArg_ParseTuple(args,"O&",
          &Pyoa2DLookupTbl_oaInt4_oaInt4_oaViaDefArrayValue_Convert,&p1)) {
        data.DataCall()->set(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaDef2DTblValue_isNull_doc[] =
"Class: oaViaDef2DTblValue, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaViaDef2DTblValue_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaViaDef2DTblValue data;
    int convert_status=PyoaViaDef2DTblValue_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaViaDef2DTblValue_assign_doc[] = 
"Class: oaViaDef2DTblValue, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaViaDef2DTblValue_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaViaDef2DTblValue data;
  int convert_status=PyoaViaDef2DTblValue_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaViaDef2DTblValue p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaViaDef2DTblValue_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaViaDef2DTblValue_methodlist[] = {
    {"get",(PyCFunction)oaViaDef2DTblValue_get,METH_VARARGS,oaViaDef2DTblValue_get_doc},
    {"set",(PyCFunction)oaViaDef2DTblValue_set,METH_VARARGS,oaViaDef2DTblValue_set_doc},
    {"isNull",(PyCFunction)oaViaDef2DTblValue_tp_isNull,METH_VARARGS,oaViaDef2DTblValue_isNull_doc},
    {"assign",(PyCFunction)oaViaDef2DTblValue_tp_assign,METH_VARARGS,oaViaDef2DTblValue_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaDef2DTblValue_doc[] = 
"Class: oaViaDef2DTblValue\n"
"  The oaViaDef2DTblValue class represents a value object that contains a 2DLookup table whose lookup keys are integers and the value is an oaViaDefArrayValue object. The primary usage of this value object is to allow users to define a width based lookup table, that returns a list of valid viaDefs. The oaViaSpec object uses this value object to define the list of vias to be used in routing geometric nets given the width of the two layers that are being connected.\n"
"  See oaValue for a discussion of the usage of all of the oaValue subclasses.\n"
"Constructors:\n"
"  Paramegers: (oaViaDef2DTblValue)\n"
"    Calls: (const oaViaDef2DTblValue&)\n"
"    Signature: oaViaDef2DTblValue||cref-oaViaDef2DTblValue,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaViaDef2DTblValue_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaViaDef2DTblValue",
    sizeof(PyoaViaDef2DTblValueObject),
    0,
    (destructor)oaViaDef2DTblValue_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaViaDef2DTblValue_tp_compare,	/* tp_compare */
    (reprfunc)oaViaDef2DTblValue_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaViaDef2DTblValue_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaViaDef2DTblValue_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaValue_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaViaDef2DTblValue_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaDef2DTblValue_static_create_doc[] = 
"Class: oaViaDef2DTblValue, Function: create\n"
"  Paramegers: (oaObject,oa2DLookupTbl_oaInt4_oaInt4_oaViaDefArrayValue)\n"
"    Calls: oaViaDef2DTblValue* create(oaObject* database,const oa2DLookupTbl_oaInt4_oaInt4_oaViaDefArrayValue& value)\n"
"    Signature: create|ptr-oaViaDef2DTblValue|ptr-oaObject,cref-oa2DLookupTbl_oaInt4_oaInt4_oaViaDefArrayValue,\n"
"    This function creates an oaViaDef2DTbl value in the specified database and with the specified value.\n"
"    database\n"
"    The database in which to create the value\n"
"    value\n"
"    The 2DLookupTbl value. The default value of this table must be NULL.\n"
"    oacInvalidDatabase\n"
"    oacInvalidDefaultValueForTblValue\n"
;

static PyObject*
oaViaDef2DTblValue_static_create(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObject p1;
    PyParamoa2DLookupTbl_oaInt4_oaInt4_oaViaDefArrayValue p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaObject_Convert,&p1,
          &Pyoa2DLookupTbl_oaInt4_oaInt4_oaViaDefArrayValue_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaViaDef2DTblValuep result= (oaViaDef2DTblValue::create(p1.Data(),p2.Data()));
        return PyoaViaDef2DTblValue_FromoaViaDef2DTblValue(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaViaDef2DTblValue_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaViaDef2DTblValue_static_create,METH_VARARGS,oaViaDef2DTblValue_static_create_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaViaDef2DTblValue_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaViaDef2DTblValue_Type)<0) {
      printf("** PyType_Ready failed for: oaViaDef2DTblValue\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaViaDef2DTblValue",
           (PyObject*)(&PyoaViaDef2DTblValue_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaViaDef2DTblValue\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaViaDef2DTblValue_Type.tp_dict;
    for(method=oaViaDef2DTblValue_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaViaDefArray
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaViaDefArray_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaViaDefArray_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaViaDefArrayObject* self = (PyoaViaDefArrayObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaArrayBase_oaViaDef*)  new oaViaDefArray();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value = (oaArrayBase_oaViaDef*)  new oaViaDefArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaViaDefArray)
    {
        PyParamoaViaDefArray p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaViaDefArray_Convert,&p1)) {
            self->value = (oaArrayBase_oaViaDef*)  new oaViaDefArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaViaDefArray, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaViaDefArray)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaViaDefArray_tp_dealloc(PyoaViaDefArrayObject* self)
{
    if (!self->borrow) {
        delete (oaViaDefArray*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaViaDefArray_tp_repr(PyObject *ob)
{
    PyParamoaViaDefArray value;
    int convert_status=PyoaViaDefArray_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[35];
    sprintf(buffer,"<oaViaDefArray::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaViaDefArray_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaViaDefArray v1;
    PyParamoaViaDefArray v2;
    int convert_status1=PyoaViaDefArray_Convert(ob1,&v1);
    int convert_status2=PyoaViaDefArray_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaViaDefArray_Convert(PyObject* ob,PyParamoaViaDefArray* result)
{
    if (ob == NULL) return 1;
    if (PyoaViaDefArray_Check(ob)) {
        result->SetData( (oaViaDefArray*) ((PyoaViaDefArrayObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaViaDefArray Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaViaDefArray_FromoaViaDefArray(oaViaDefArray* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaViaDefArray_Type.tp_alloc(&PyoaViaDefArray_Type,0);
        if (bself == NULL) return bself;
        PyoaViaDefArrayObject* self = (PyoaViaDefArrayObject*)bself;
        self->value = (oaArrayBase_oaViaDef*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaDefArray_doc[] = 
"Class: oaViaDefArray\n"
"  The oaViaDefArray class implements an array of pointers to oaViaDefs. The size of the array can be different than the number of oaViaDef pointers actually stored. This is useful when the array is used as a buffer, because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaViaDefArray()\n"
"    Signature: oaViaDefArray||simple-oaUInt4,\n"
"    This function constructs an oaViaDefArray object, sets the number of oaViaDef pointers, and allocates storage for the oaViaDef pointers.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaViaDefArray(oaUInt4 sizeIn)\n"
"    Signature: oaViaDefArray||simple-oaUInt4,\n"
"    This function constructs an oaViaDefArray object, sets the number of oaViaDef pointers, and allocates storage for the oaViaDef pointers.\n"
"  Paramegers: (oaViaDefArray)\n"
"    Calls: oaViaDefArray(const oaViaDefArray& arrayIn)\n"
"    Signature: oaViaDefArray||cref-oaViaDefArray,\n"
"    This function constructs an oaViaDefArray object, creating a copy of the specified oaViaDefArray.\n"
"  Paramegers: (oaViaDefArray)\n"
"    Calls: (const oaViaDefArray&)\n"
"    Signature: oaViaDefArray||cref-oaViaDefArray,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaViaDefArray_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaViaDefArray",
    sizeof(PyoaViaDefArrayObject),
    0,
    (destructor)oaViaDefArray_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaViaDefArray_tp_compare,	/* tp_compare */
    (reprfunc)oaViaDefArray_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaViaDefArray_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaArray_oaViaDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaViaDefArray_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaViaDefArray_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaViaDefArray_Type)<0) {
      printf("** PyType_Ready failed for: oaViaDefArray\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaViaDefArray",
           (PyObject*)(&PyoaViaDefArray_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaViaDefArray\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaViaDefArrayValue
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaViaDefArrayValue_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaViaDefArrayValue_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaViaDefArrayValueObject* self = (PyoaViaDefArrayValueObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaViaDefArrayValue)
    {
        PyParamoaViaDefArrayValue p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaViaDefArrayValue_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaViaDefArrayValue, Choices are:\n"
        "    (oaViaDefArrayValue)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaViaDefArrayValue_tp_dealloc(PyoaViaDefArrayValueObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaViaDefArrayValue_tp_repr(PyObject *ob)
{
    PyParamoaViaDefArrayValue value;
    int convert_status=PyoaViaDefArrayValue_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[40];
    sprintf(buffer,"<oaViaDefArrayValue::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaViaDefArrayValue_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaViaDefArrayValue v1;
    PyParamoaViaDefArrayValue v2;
    int convert_status1=PyoaViaDefArrayValue_Convert(ob1,&v1);
    int convert_status2=PyoaViaDefArrayValue_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaViaDefArrayValue_Convert(PyObject* ob,PyParamoaViaDefArrayValue* result)
{
    if (ob == NULL) return 1;
    if (PyoaViaDefArrayValue_Check(ob)) {
        result->SetData( (oaViaDefArrayValue**) ((PyoaViaDefArrayValueObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaViaDefArrayValue Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaViaDefArrayValue_FromoaViaDefArrayValue(oaViaDefArrayValue** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaViaDefArrayValue* data=*value;
        PyObject* bself = PyoaViaDefArrayValue_Type.tp_alloc(&PyoaViaDefArrayValue_Type,0);
        if (bself == NULL) return bself;
        PyoaViaDefArrayValueObject* self = (PyoaViaDefArrayValueObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaViaDefArrayValue_FromoaViaDefArrayValue(oaViaDefArrayValue* data)
{
    if (data) {
       PyObject* bself = PyoaViaDefArrayValue_Type.tp_alloc(&PyoaViaDefArrayValue_Type,0);
       if (bself == NULL) return bself;
       PyoaViaDefArrayValueObject* self = (PyoaViaDefArrayValueObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaDefArrayValue_get_doc[] = 
"Class: oaViaDefArrayValue, Function: get\n"
"  Paramegers: (oaViaDefArray)\n"
"    Calls: void get(oaViaDefArray& value) const\n"
"    Signature: get|void-void|ref-oaViaDefArray,\n"
"    BrowseData: 0,oaViaDefArray\n"
"    This function returns the viaDef array associated with this value.\n"
"    Note: The returned value array may contain null object pointers if the associated viaDef cannot be bound, such as when it has been deleted or cannot be accessed. The names of unbound viaDefs are accessed with the oaViaDefArrayValue::getNames function.\n"
;

static PyObject*
oaViaDefArrayValue_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaDefArrayValue data;
    int convert_status=PyoaViaDefArrayValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaDefArrayValueObject* self=(PyoaViaDefArrayValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaDefArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaViaDefArray_Convert,&p1)) {
        data.DataCall()->get(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaDefArrayValue_getNames_doc[] = 
"Class: oaViaDefArrayValue, Function: getNames\n"
"  Paramegers: (oaViaDefNameArray)\n"
"    Calls: void getNames(oaViaDefNameArray& names) const\n"
"    Signature: getNames|void-void|ref-oaViaDefNameArray,\n"
"    BrowseData: 0,oaViaDefNameArray\n"
"    This function returns an array containing the names of the viaDefs associated with this value.\n"
"    names\n"
"    The returned value\n"
;

static PyObject*
oaViaDefArrayValue_getNames(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaDefArrayValue data;
    int convert_status=PyoaViaDefArrayValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaDefArrayValueObject* self=(PyoaViaDefArrayValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaDefNameArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaViaDefNameArray_Convert,&p1)) {
        data.DataCall()->getNames(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaDefArrayValue_set_doc[] = 
"Class: oaViaDefArrayValue, Function: set\n"
"  Paramegers: (oaViaDefArray)\n"
"    Calls: void set(const oaViaDefArray& value)\n"
"    Signature: set|void-void|cref-oaViaDefArray,\n"
"    This function sets the viaDef array for this value to the specified array.\n"
"    value\n"
"    The viaDef array to set.\n"
;

static PyObject*
oaViaDefArrayValue_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaDefArrayValue data;
    int convert_status=PyoaViaDefArrayValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaDefArrayValueObject* self=(PyoaViaDefArrayValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaDefArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaViaDefArray_Convert,&p1)) {
        data.DataCall()->set(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaDefArrayValue_isNull_doc[] =
"Class: oaViaDefArrayValue, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaViaDefArrayValue_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaViaDefArrayValue data;
    int convert_status=PyoaViaDefArrayValue_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaViaDefArrayValue_assign_doc[] = 
"Class: oaViaDefArrayValue, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaViaDefArrayValue_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaViaDefArrayValue data;
  int convert_status=PyoaViaDefArrayValue_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaViaDefArrayValue p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaViaDefArrayValue_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaViaDefArrayValue_methodlist[] = {
    {"get",(PyCFunction)oaViaDefArrayValue_get,METH_VARARGS,oaViaDefArrayValue_get_doc},
    {"getNames",(PyCFunction)oaViaDefArrayValue_getNames,METH_VARARGS,oaViaDefArrayValue_getNames_doc},
    {"set",(PyCFunction)oaViaDefArrayValue_set,METH_VARARGS,oaViaDefArrayValue_set_doc},
    {"isNull",(PyCFunction)oaViaDefArrayValue_tp_isNull,METH_VARARGS,oaViaDefArrayValue_isNull_doc},
    {"assign",(PyCFunction)oaViaDefArrayValue_tp_assign,METH_VARARGS,oaViaDefArrayValue_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaDefArrayValue_doc[] = 
"Class: oaViaDefArrayValue\n"
"  The oaViaDefArrayValue represents a value object that contains an array of viaDefs.\n"
"  See oaValue for a discussion of the usage of all of the oaValue subclasses.\n"
"Constructors:\n"
"  Paramegers: (oaViaDefArrayValue)\n"
"    Calls: (const oaViaDefArrayValue&)\n"
"    Signature: oaViaDefArrayValue||cref-oaViaDefArrayValue,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaViaDefArrayValue_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaViaDefArrayValue",
    sizeof(PyoaViaDefArrayValueObject),
    0,
    (destructor)oaViaDefArrayValue_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaViaDefArrayValue_tp_compare,	/* tp_compare */
    (reprfunc)oaViaDefArrayValue_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaViaDefArrayValue_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaViaDefArrayValue_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaValue_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaViaDefArrayValue_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaDefArrayValue_static_create_doc[] = 
"Class: oaViaDefArrayValue, Function: create\n"
"  Paramegers: (oaObject,oaViaDefArray)\n"
"    Calls: oaViaDefArrayValue* create(oaObject* database,const oaViaDefArray& value)\n"
"    Signature: create|ptr-oaViaDefArrayValue|ptr-oaObject,cref-oaViaDefArray,\n"
"    This function creates an ViaDef array value in the specified database.\n"
"    database\n"
"    The database in which to create the value\n"
"    value\n"
"    The viaDef array\n"
"    oacInvalidDatabase\n"
"    oacInvalidObjForValue\n"
"    oacEmptyArrayValue\n"
"    oacViaDefNotInReferencedTech\n"
"    oacConflictingViaDefNamesInTech\n"
"  Paramegers: (oaObject,oaViaDefArray)\n"
"    Calls: oaViaDefArrayValue* create(oaObject* database,oaViaDefArray& value)\n"
"    Signature: create|ptr-oaViaDefArrayValue|ptr-oaObject,ref-oaViaDefArray,\n"
"    This function is deprecated and is retained to ensure compatibility with previous versions of OpenAccess. Use the create function overload that takes a const oaViaDefArray reference instead.\n"
"    This function creates a viaDef array value in the database specified.\n"
"    database\n"
"    The database in which to create the value\n"
"    value\n"
"    The viaDef array\n"
"    oacInvalidDatabase\n"
"    oacInvalidObjForValue\n"
"    oacEmptyArrayValue\n"
"    oacViaDefNotInReferencedTech\n"
"    oacConflictingViaDefNamesInTech\n"
;

static PyObject*
oaViaDefArrayValue_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaObject,oaViaDefArray)
    {
        PyParamoaObject p1;
        PyParamoaViaDefArray p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaObject_Convert,&p1,
              &PyoaViaDefArray_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaViaDefArrayValuep result= (oaViaDefArrayValue::create(p1.Data(),p2.Data()));
            return PyoaViaDefArrayValue_FromoaViaDefArrayValue(result);
        }
    }
    PyErr_Clear();
    // Case: (oaObject,oaViaDefArray)
    {
        PyParamoaObject p1;
        PyParamoaViaDefArray p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaObject_Convert,&p1,
              &PyoaViaDefArray_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaViaDefArrayValuep result= (oaViaDefArrayValue::create(p1.Data(),p2.Data()));
            return PyoaViaDefArrayValue_FromoaViaDefArrayValue(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaViaDefArrayValue, function: create, Choices are:\n"
        "    (oaObject,oaViaDefArray)\n"
        "    (oaObject,oaViaDefArray)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaViaDefArrayValue_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaViaDefArrayValue_static_create,METH_VARARGS,oaViaDefArrayValue_static_create_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaViaDefArrayValue_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaViaDefArrayValue_Type)<0) {
      printf("** PyType_Ready failed for: oaViaDefArrayValue\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaViaDefArrayValue",
           (PyObject*)(&PyoaViaDefArrayValue_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaViaDefArrayValue\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaViaDefArrayValue_Type.tp_dict;
    for(method=oaViaDefArrayValue_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaViaDefModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaViaDefModTypeEnum_Convert(PyObject* ob,PyParamoaViaDefModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacSetResistancePerCutViaDefModType")==0) { result->SetData(oacSetResistancePerCutViaDefModType); return 1;}
        if (strcasecmp(str,"oacSetParamsStdViaDefModType")==0) { result->SetData(oacSetParamsStdViaDefModType); return 1;}
        if (strcasecmp(str,"oacCustomViaDefSetMasterViaDefModType")==0) { result->SetData(oacCustomViaDefSetMasterViaDefModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaViaDefModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaViaDefModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaViaDefModTypeEnum_FromoaViaDefModTypeEnum(oaViaDefModTypeEnum ob)
{
    if (ob==oacSetResistancePerCutViaDefModType) return PyString_FromString("oacSetResistancePerCutViaDefModType");
    if (ob==oacSetParamsStdViaDefModType) return PyString_FromString("oacSetParamsStdViaDefModType");
    if (ob==oacCustomViaDefSetMasterViaDefModType) return PyString_FromString("oacCustomViaDefSetMasterViaDefModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaViaDefModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaViaDefModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaViaDefModTypeEnum_FromoaViaDefModTypeEnum(oaViaDefModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaViaDefModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaViaDefModTypeEnum_doc[] =
"Type convert function for enum: oaViaDefModTypeEnum";
                               
static PyMethodDef PyoaViaDefModTypeEnum_method =
  {"oaViaDefModTypeEnum",(PyCFunction)PyoaViaDefModTypeEnum_TypeFunction,METH_VARARGS,oaViaDefModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaViaDefModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacSetResistancePerCutViaDefModType");
    PyDict_SetItemString(mod_dict,"oacSetResistancePerCutViaDefModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetParamsStdViaDefModType");
    PyDict_SetItemString(mod_dict,"oacSetParamsStdViaDefModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCustomViaDefSetMasterViaDefModType");
    PyDict_SetItemString(mod_dict,"oacCustomViaDefSetMasterViaDefModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaViaDefModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaViaDefModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaViaDefModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaViaDefNameArray
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaViaDefNameArray_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaViaDefNameArray_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaViaDefNameArrayObject* self = (PyoaViaDefNameArrayObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaArrayBase_oaString*)  new oaViaDefNameArray();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value = (oaArrayBase_oaString*)  new oaViaDefNameArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaViaDefNameArray)
    {
        PyParamoaViaDefNameArray p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaViaDefNameArray_Convert,&p1)) {
            self->value=(oaArrayBase_oaString*)  new oaViaDefNameArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaViaDefNameArray, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaViaDefNameArray)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaViaDefNameArray_tp_dealloc(PyoaViaDefNameArrayObject* self)
{
    if (!self->borrow) {
        delete (oaViaDefNameArray*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaViaDefNameArray_tp_repr(PyObject *ob)
{
    PyParamoaViaDefNameArray value;
    int convert_status=PyoaViaDefNameArray_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[39];
    sprintf(buffer,"<oaViaDefNameArray::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaViaDefNameArray_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaViaDefNameArray v1;
    PyParamoaViaDefNameArray v2;
    int convert_status1=PyoaViaDefNameArray_Convert(ob1,&v1);
    int convert_status2=PyoaViaDefNameArray_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaViaDefNameArray_Convert(PyObject* ob,PyParamoaViaDefNameArray* result)
{
    if (ob == NULL) return 1;
    if (PyoaViaDefNameArray_Check(ob)) {
        result->SetData( (oaViaDefNameArray*) ((PyoaViaDefNameArrayObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaViaDefNameArray Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaViaDefNameArray_FromoaViaDefNameArray(oaViaDefNameArray* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaViaDefNameArray_Type.tp_alloc(&PyoaViaDefNameArray_Type,0);
        if (bself == NULL) return bself;
        PyoaViaDefNameArrayObject* self = (PyoaViaDefNameArrayObject*)bself;
        self->value = (oaArrayBase_oaString*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaDefNameArray_doc[] = 
"Class: oaViaDefNameArray\n"
"  The ViaDefNameArray class implements an array of viaDef names.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaViaDefNameArray()\n"
"    Signature: oaViaDefNameArray||simple-oaUInt4,\n"
"    This function constructs an oaViaDefNameArray object, allocating storage for the names.\n"
"    sizeIn\n"
"    An integer value indicating the initial size of the viaDefName array.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaViaDefNameArray(oaUInt4 sizeIn)\n"
"    Signature: oaViaDefNameArray||simple-oaUInt4,\n"
"    This function constructs an oaViaDefNameArray object, allocating storage for the names.\n"
"    sizeIn\n"
"    An integer value indicating the initial size of the viaDefName array.\n"
"  Paramegers: (oaViaDefNameArray)\n"
"    Calls: (const oaViaDefNameArray&)\n"
"    Signature: oaViaDefNameArray||cref-oaViaDefNameArray,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaViaDefNameArray_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaViaDefNameArray",
    sizeof(PyoaViaDefNameArrayObject),
    0,
    (destructor)oaViaDefNameArray_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaViaDefNameArray_tp_compare,	/* tp_compare */
    (reprfunc)oaViaDefNameArray_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaViaDefNameArray_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaArray_oaString_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaViaDefNameArray_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaViaDefNameArray_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaViaDefNameArray_Type)<0) {
      printf("** PyType_Ready failed for: oaViaDefNameArray\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaViaDefNameArray",
           (PyObject*)(&PyoaViaDefNameArray_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaViaDefNameArray\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaViaDirection
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaViaDirection_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaViaDirection_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaViaDirectionObject* self = (PyoaViaDirectionObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaViaDirectionEnum)
    {
        PyParamoaViaDirectionEnum p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaViaDirectionEnum_Convert,&p1)) {
            self->value =  new oaViaDirection(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            self->value =  new oaViaDirection(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaViaDirection)
    {
        PyParamoaViaDirection p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaViaDirection_Convert,&p1)) {
            self->value= new oaViaDirection(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaViaDirection, Choices are:\n"
        "    (oaViaDirectionEnum)\n"
        "    (oaString)\n"
        "    (oaViaDirection)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaViaDirection_tp_dealloc(PyoaViaDirectionObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaViaDirection_tp_repr(PyObject *ob)
{
    PyParamoaViaDirection value;
    int convert_status=PyoaViaDirection_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    oaString sresult(value.DataCall()->getName());

    char addr[36];
    sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
    oaString buffer;
    buffer+=oaString("<oaViaDirection::");
    buffer+=oaString(addr);
    buffer+=oaString("::");
    buffer+=oaString(sresult);
    buffer+=oaString(">");
    result=PyString_FromString((char*)(const char*)buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaViaDirection_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaViaDirection v1;
    PyParamoaViaDirection v2;
    int convert_status1=PyoaViaDirection_Convert(ob1,&v1);
    int convert_status2=PyoaViaDirection_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaViaDirection_Convert(PyObject* ob,PyParamoaViaDirection* result)
{
    if (ob == NULL) return 1;
    if (PyoaViaDirection_Check(ob)) {
        result->SetData(  ((PyoaViaDirectionObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaViaDirection Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaViaDirection_FromoaViaDirection(oaViaDirection* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaViaDirection_Type.tp_alloc(&PyoaViaDirection_Type,0);
        if (bself == NULL) return bself;
        PyoaViaDirectionObject* self = (PyoaViaDirectionObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaDirection_getName_doc[] = 
"Class: oaViaDirection, Function: getName\n"
"  Paramegers: ()\n"
"    Calls: const oaString& getName() const\n"
"    Signature: getName|cref-oaString|\n"
"    BrowseData: 1\n"
"    This function returns a valid via direction name as a string based on the current via direction that the object represents.\n"
;

static PyObject*
oaViaDirection_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaDirection data;
    int convert_status=PyoaViaDirection_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaDirectionObject* self=(PyoaViaDirectionObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaString result= (data.DataCall()->getName());
        return PyoaString_FromoaString(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaDirection_oaViaDirectionEnum_doc[] = 
"Class: oaViaDirection, Function: oaViaDirectionEnum\n"
"  Paramegers: ()\n"
"    Calls: oaViaDirectionEnum oaViaDirectionEnum() const\n"
"    Signature: operator oaViaDirectionEnum|simple-oaViaDirectionEnum|\n"
"    BrowseData: 1\n"
"    This operator can be used to typecast an existing oaViaDirection object into its corresponding oaViaDirectionEnum value.\n"
;

static PyObject*
oaViaDirection_oaViaDirectionEnum(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaDirection data;
    int convert_status=PyoaViaDirection_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaDirectionObject* self=(PyoaViaDirectionObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaViaDirectionEnum result= (data.DataCall()->operator oaViaDirectionEnum());
        return PyoaViaDirectionEnum_FromoaViaDirectionEnum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaViaDirection_assign_doc[] = 
"Class: oaViaDirection, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaViaDirection_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaViaDirection data;
  int convert_status=PyoaViaDirection_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaViaDirection p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaViaDirection_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaViaDirection_methodlist[] = {
    {"getName",(PyCFunction)oaViaDirection_getName,METH_VARARGS,oaViaDirection_getName_doc},
    {"oaViaDirectionEnum",(PyCFunction)oaViaDirection_oaViaDirectionEnum,METH_VARARGS,oaViaDirection_oaViaDirectionEnum_doc},
    {"assign",(PyCFunction)oaViaDirection_tp_assign,METH_VARARGS,oaViaDirection_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaDirection_doc[] = 
"Class: oaViaDirection\n"
"  The oaViaDirection class is an enum wrapper class that describes the direction of a via.\n"
"  See Enum Wrappers in the Programmers Guide for a discussion of enum wrappers.\n"
"  oaViaDirectionEnum\n"
"Constructors:\n"
"  Paramegers: (oaViaDirectionEnum)\n"
"    Calls: oaViaDirection(oaViaDirectionEnum valueIn)\n"
"    Signature: oaViaDirection||simple-oaViaDirectionEnum,\n"
"    This is the first constructor for the oaViaDirection class enum wrapper. It takes an oaViaDirectionEnum type as input.\n"
"    valueIn\n"
"    An oaViaDirectionEnum value for the specified direction\n"
"  Paramegers: (oaString)\n"
"    Calls: oaViaDirection(const oaString& name)\n"
"    Signature: oaViaDirection||cref-oaString,\n"
"    This is the second constructor for the oaViaDirection class enum wrapper. It takes oaString type name as input.\n"
"    name\n"
"    A string name that represents a valid via direction type\n"
"    oacInvalidViaDirectionTypeName\n"
"  Paramegers: (oaViaDirection)\n"
"    Calls: (const oaViaDirection&)\n"
"    Signature: oaViaDirection||cref-oaViaDirection,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaViaDirection_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaViaDirection",
    sizeof(PyoaViaDirectionObject),
    0,
    (destructor)oaViaDirection_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaViaDirection_tp_compare,	/* tp_compare */
    (reprfunc)oaViaDirection_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaViaDirection_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaViaDirection_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaViaDirection_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaViaDirection_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaViaDirection_Type)<0) {
      printf("** PyType_Ready failed for: oaViaDirection\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaViaDirection",
           (PyObject*)(&PyoaViaDirection_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaViaDirection\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaViaDirectionEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaViaDirectionEnum_Convert(PyObject* ob,PyParamoaViaDirectionEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacLayer1ToLayer2ViaDirection")==0) { result->SetData(oacLayer1ToLayer2ViaDirection); return 1;}
        if (strcasecmp(str,"oacLayer2ToLayer1ViaDirection")==0) { result->SetData(oacLayer2ToLayer1ViaDirection); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaViaDirectionEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaViaDirectionEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaViaDirectionEnum_FromoaViaDirectionEnum(oaViaDirectionEnum ob)
{
    if (ob==oacLayer1ToLayer2ViaDirection) return PyString_FromString("oacLayer1ToLayer2ViaDirection");
    if (ob==oacLayer2ToLayer1ViaDirection) return PyString_FromString("oacLayer2ToLayer1ViaDirection");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaViaDirectionEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaViaDirectionEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaViaDirectionEnum_FromoaViaDirectionEnum(oaViaDirectionEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaViaDirectionEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaViaDirectionEnum_doc[] =
"Type convert function for enum: oaViaDirectionEnum";
                               
static PyMethodDef PyoaViaDirectionEnum_method =
  {"oaViaDirectionEnum",(PyCFunction)PyoaViaDirectionEnum_TypeFunction,METH_VARARGS,oaViaDirectionEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaViaDirectionEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacLayer1ToLayer2ViaDirection");
    PyDict_SetItemString(mod_dict,"oacLayer1ToLayer2ViaDirection",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLayer2ToLayer1ViaDirection");
    PyDict_SetItemString(mod_dict,"oacLayer2ToLayer1ViaDirection",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaViaDirectionEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaViaDirectionEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaViaDirectionEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaViaHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaViaHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaViaHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaViaHeaderObject* self = (PyoaViaHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaViaHeader)
    {
        PyParamoaViaHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaViaHeader_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaViaHeader, Choices are:\n"
        "    (oaViaHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaViaHeader_tp_dealloc(PyoaViaHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaViaHeader_tp_repr(PyObject *ob)
{
    PyParamoaViaHeader value;
    int convert_status=PyoaViaHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaViaHeader::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaString sresult;
        value.DataCall()->getViaDefName(sresult);
    
        char addr[33];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaViaHeader::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaViaHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaViaHeader v1;
    PyParamoaViaHeader v2;
    int convert_status1=PyoaViaHeader_Convert(ob1,&v1);
    int convert_status2=PyoaViaHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaViaHeader_Convert(PyObject* ob,PyParamoaViaHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaViaHeader_Check(ob)) {
        result->SetData( (oaViaHeader**) ((PyoaViaHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaViaHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaViaHeader_FromoaViaHeader(oaViaHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaViaHeader* data=*value;
        if (data->getType()==oacStdViaHeaderType) return PyoaStdViaHeader_FromoaStdViaHeader((oaStdViaHeader**)value,borrow,lock);
        if (data->getType()==oacCustomViaHeaderType) return PyoaCustomViaHeader_FromoaCustomViaHeader((oaCustomViaHeader**)value,borrow,lock);
        PyObject* bself = PyoaViaHeader_Type.tp_alloc(&PyoaViaHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaViaHeaderObject* self = (PyoaViaHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaViaHeader_FromoaViaHeader(oaViaHeader* data)
{
    if (data) {
        if (data->getType()==oacStdViaHeaderType) return PyoaStdViaHeader_FromoaStdViaHeader((oaStdViaHeader*)data);
        if (data->getType()==oacCustomViaHeaderType) return PyoaCustomViaHeader_FromoaCustomViaHeader((oaCustomViaHeader*)data);
       PyObject* bself = PyoaViaHeader_Type.tp_alloc(&PyoaViaHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaViaHeaderObject* self = (PyoaViaHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaHeader_getSubHeaders_doc[] = 
"Class: oaViaHeader, Function: getSubHeaders\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaViaHeader_oaViaHeader getSubHeaders() const\n"
"    Signature: getSubHeaders|simple-oaCollection_oaViaHeader_oaViaHeader|\n"
"    BrowseData: 1\n"
"    This function returns a collection of subHeaders in this superHeader.\n"
;

static PyObject*
oaViaHeader_getSubHeaders(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaHeader data;
    int convert_status=PyoaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaHeaderObject* self=(PyoaViaHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaViaHeader_oaViaHeader* result= new oaCollection_oaViaHeader_oaViaHeader(data.DataCall()->getSubHeaders());
        return PyoaCollection_oaViaHeader_oaViaHeader_FromoaCollection_oaViaHeader_oaViaHeader(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaHeader_getSubHeadersIter_doc[] = 
"Class: oaViaHeader, Function: getSubHeadersIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaViaHeader getSubHeadersIter() const\n"
"    Signature: getSubHeadersIter|simple-oaIter_oaViaHeader|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of subHeaders in this superHeader.\n"
;

static PyObject*
oaViaHeader_getSubHeadersIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaHeader data;
    int convert_status=PyoaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaHeaderObject* self=(PyoaViaHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaViaHeader* result= new oaIter_oaViaHeader(data.DataCall()->getSubHeaders());
        return PyoaIter_oaViaHeader_FromoaIter_oaViaHeader(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaHeader_getViaDef_doc[] = 
"Class: oaViaHeader, Function: getViaDef\n"
"  Paramegers: ()\n"
"    Calls: oaViaDef* getViaDef() const\n"
"    Signature: getViaDef|ptr-oaViaDef|\n"
"    BrowseData: 1\n"
"    oaViaHeader::getViaDef\n"
"    This function returns the viaDef object associated with this viaHeader. If the viaHeader is bound, the viaDef is returned. Otherwise, NULL is returned.\n"
;

static PyObject*
oaViaHeader_getViaDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaHeader data;
    int convert_status=PyoaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaHeaderObject* self=(PyoaViaHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaViaDefp result= (data.DataCall()->getViaDef());
        return PyoaViaDef_FromoaViaDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaHeader_getViaDefName_doc[] = 
"Class: oaViaHeader, Function: getViaDefName\n"
"  Paramegers: (oaString)\n"
"    Calls: void getViaDefName(oaString& name) const\n"
"    Signature: getViaDefName|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function returns the name of the viaDef associated with this viaHeader.\n"
;

static PyObject*
oaViaHeader_getViaDefName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaHeader data;
    int convert_status=PyoaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaHeaderObject* self=(PyoaViaHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getViaDefName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaHeader_getVias_doc[] = 
"Class: oaViaHeader, Function: getVias\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaVia_oaViaHeader getVias() const\n"
"    Signature: getVias|simple-oaCollection_oaVia_oaViaHeader|\n"
"    BrowseData: 1\n"
"    This function returns the collection of vias associated with this viaHeader.\n"
;

static PyObject*
oaViaHeader_getVias(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaHeader data;
    int convert_status=PyoaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaHeaderObject* self=(PyoaViaHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaVia_oaViaHeader* result= new oaCollection_oaVia_oaViaHeader(data.DataCall()->getVias());
        return PyoaCollection_oaVia_oaViaHeader_FromoaCollection_oaVia_oaViaHeader(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaHeader_getViasIter_doc[] = 
"Class: oaViaHeader, Function: getViasIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaVia getViasIter() const\n"
"    Signature: getViasIter|simple-oaIter_oaVia|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns the collection of vias associated with this viaHeader.\n"
;

static PyObject*
oaViaHeader_getViasIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaHeader data;
    int convert_status=PyoaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaHeaderObject* self=(PyoaViaHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaVia* result= new oaIter_oaVia(data.DataCall()->getVias());
        return PyoaIter_oaVia_FromoaIter_oaVia(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaHeader_isNull_doc[] =
"Class: oaViaHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaViaHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaViaHeader data;
    int convert_status=PyoaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaViaHeader_assign_doc[] = 
"Class: oaViaHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaViaHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaViaHeader data;
  int convert_status=PyoaViaHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaViaHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaViaHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaViaHeader_methodlist[] = {
    {"getSubHeaders",(PyCFunction)oaViaHeader_getSubHeaders,METH_VARARGS,oaViaHeader_getSubHeaders_doc},
    {"getSubHeadersIter",(PyCFunction)oaViaHeader_getSubHeadersIter,METH_VARARGS,oaViaHeader_getSubHeadersIter_doc},
    {"getViaDef",(PyCFunction)oaViaHeader_getViaDef,METH_VARARGS,oaViaHeader_getViaDef_doc},
    {"getViaDefName",(PyCFunction)oaViaHeader_getViaDefName,METH_VARARGS,oaViaHeader_getViaDefName_doc},
    {"getVias",(PyCFunction)oaViaHeader_getVias,METH_VARARGS,oaViaHeader_getVias_doc},
    {"getViasIter",(PyCFunction)oaViaHeader_getViasIter,METH_VARARGS,oaViaHeader_getViasIter_doc},
    {"isNull",(PyCFunction)oaViaHeader_tp_isNull,METH_VARARGS,oaViaHeader_isNull_doc},
    {"assign",(PyCFunction)oaViaHeader_tp_assign,METH_VARARGS,oaViaHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaHeader_doc[] = 
"Class: oaViaHeader\n"
"  The oaViaHeader class implements an object that contains information about a particular oaViaDef and all of the vias that reference it. An oaViaHeader is an automatic object that is created and destroyed by the database. A viaHeader may be either an oaStdViaHeader or oaCustomViaHeader and is associated with standard or custom vias, respectively.\n"
"  A viaHeader is automatically created whenever the first via of a particular viaDef is created. A viaHeader is destroyed when the last via using the viaDef is destroyed.\n"
"  The oaViaHeader class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaViaHeader)\n"
"    Calls: (const oaViaHeader&)\n"
"    Signature: oaViaHeader||cref-oaViaHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaViaHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaViaHeader",
    sizeof(PyoaViaHeaderObject),
    0,
    (destructor)oaViaHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaViaHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaViaHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaViaHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaViaHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaRefHeader_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaViaHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaHeader_static_find_doc[] = 
"Class: oaViaHeader, Function: find\n"
"  Paramegers: (oaBlock,oaString)\n"
"    Calls: oaViaHeader* find(const oaBlock* block,const oaString& viaDefName)\n"
"    Signature: find|ptr-oaViaHeader|cptr-oaBlock,cref-oaString,\n"
"    This function searches the specified block for an viaHeader with the specified viaDef name. If the viaHeader is found, it is returned. Otherwise, NULL is returned.\n"
"  Paramegers: (oaBlock,oaViaDef)\n"
"    Calls: oaViaHeader* find(const oaBlock* block,const oaViaDef* viaDef)\n"
"    Signature: find|ptr-oaViaHeader|cptr-oaBlock,cptr-oaViaDef,\n"
"    This function searches the specified block for a viaHeader associated with the specified viaDef. If the viaHeader is found, it is returned. Otherwise, NULL is returned.\n"
;

static PyObject*
oaViaHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaBlock,oaString)
    {
        PyParamoaBlock p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaViaHeaderp result= (oaViaHeader::find(p1.Data(),p2.Data()));
            return PyoaViaHeader_FromoaViaHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaViaDef)
    {
        PyParamoaBlock p1;
        PyParamoaViaDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaViaDef_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaViaHeaderp result= (oaViaHeader::find(p1.Data(),p2.Data()));
            return PyoaViaHeader_FromoaViaHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaViaHeader, function: find, Choices are:\n"
        "    (oaBlock,oaString)\n"
        "    (oaBlock,oaViaDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaViaHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaViaHeader_static_find,METH_VARARGS,oaViaHeader_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaViaHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaViaHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaViaHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaViaHeader",
           (PyObject*)(&PyoaViaHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaViaHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaViaHeader_Type.tp_dict;
    for(method=oaViaHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaViaHeaderModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaViaHeaderModTypeEnum_Convert(PyObject* ob,PyParamoaViaHeaderModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacBindViaHeaderModType")==0) { result->SetData(oacBindViaHeaderModType); return 1;}
        if (strcasecmp(str,"oacUnbindViaHeaderModType")==0) { result->SetData(oacUnbindViaHeaderModType); return 1;}
        if (strcasecmp(str,"oacBindDefViaHeaderModType")==0) { result->SetData(oacBindDefViaHeaderModType); return 1;}
        if (strcasecmp(str,"oacUnbindDefViaHeaderModType")==0) { result->SetData(oacUnbindDefViaHeaderModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaViaHeaderModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaViaHeaderModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaViaHeaderModTypeEnum_FromoaViaHeaderModTypeEnum(oaViaHeaderModTypeEnum ob)
{
    if (ob==oacBindViaHeaderModType) return PyString_FromString("oacBindViaHeaderModType");
    if (ob==oacUnbindViaHeaderModType) return PyString_FromString("oacUnbindViaHeaderModType");
    if (ob==oacBindDefViaHeaderModType) return PyString_FromString("oacBindDefViaHeaderModType");
    if (ob==oacUnbindDefViaHeaderModType) return PyString_FromString("oacUnbindDefViaHeaderModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaViaHeaderModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaViaHeaderModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaViaHeaderModTypeEnum_FromoaViaHeaderModTypeEnum(oaViaHeaderModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaViaHeaderModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaViaHeaderModTypeEnum_doc[] =
"Type convert function for enum: oaViaHeaderModTypeEnum";
                               
static PyMethodDef PyoaViaHeaderModTypeEnum_method =
  {"oaViaHeaderModTypeEnum",(PyCFunction)PyoaViaHeaderModTypeEnum_TypeFunction,METH_VARARGS,oaViaHeaderModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaViaHeaderModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacBindViaHeaderModType");
    PyDict_SetItemString(mod_dict,"oacBindViaHeaderModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacUnbindViaHeaderModType");
    PyDict_SetItemString(mod_dict,"oacUnbindViaHeaderModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBindDefViaHeaderModType");
    PyDict_SetItemString(mod_dict,"oacBindDefViaHeaderModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacUnbindDefViaHeaderModType");
    PyDict_SetItemString(mod_dict,"oacUnbindDefViaHeaderModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaViaHeaderModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaViaHeaderModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaViaHeaderModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaViaModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaViaModTypeEnum_Convert(PyObject* ob,PyParamoaViaModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacAddToNetViaModType")==0) { result->SetData(oacAddToNetViaModType); return 1;}
        if (strcasecmp(str,"oacRemoveFromNetViaModType")==0) { result->SetData(oacRemoveFromNetViaModType); return 1;}
        if (strcasecmp(str,"oacSetTransformViaModType")==0) { result->SetData(oacSetTransformViaModType); return 1;}
        if (strcasecmp(str,"oacSetCustomHeaderViaModType")==0) { result->SetData(oacSetCustomHeaderViaModType); return 1;}
        if (strcasecmp(str,"oacSetStdHeaderViaModType")==0) { result->SetData(oacSetStdHeaderViaModType); return 1;}
        if (strcasecmp(str,"oacSetRouteTopologyViaModType")==0) { result->SetData(oacSetRouteTopologyViaModType); return 1;}
        if (strcasecmp(str,"oacSetDirectionViaModType")==0) { result->SetData(oacSetDirectionViaModType); return 1;}
        if (strcasecmp(str,"oacSetRouteStatusViaModType")==0) { result->SetData(oacSetRouteStatusViaModType); return 1;}
        if (strcasecmp(str,"oacAddToPinViaModType")==0) { result->SetData(oacAddToPinViaModType); return 1;}
        if (strcasecmp(str,"oacRemoveFromPinViaModType")==0) { result->SetData(oacRemoveFromPinViaModType); return 1;}
        if (strcasecmp(str,"oacSetShieldedNet1ViaModType")==0) { result->SetData(oacSetShieldedNet1ViaModType); return 1;}
        if (strcasecmp(str,"oacSetShieldedNet2ViaModType")==0) { result->SetData(oacSetShieldedNet2ViaModType); return 1;}
        if (strcasecmp(str,"oacSetUnShieldedViaModType")==0) { result->SetData(oacSetUnShieldedViaModType); return 1;}
        if (strcasecmp(str,"oacSetPurposeNumViaModType")==0) { result->SetData(oacSetPurposeNumViaModType); return 1;}
        if (strcasecmp(str,"oacAddToFigGroupViaModType")==0) { result->SetData(oacAddToFigGroupViaModType); return 1;}
        if (strcasecmp(str,"oacRemoveFromFigGroupViaModType")==0) { result->SetData(oacRemoveFromFigGroupViaModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaViaModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaViaModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaViaModTypeEnum_FromoaViaModTypeEnum(oaViaModTypeEnum ob)
{
    if (ob==oacAddToNetViaModType) return PyString_FromString("oacAddToNetViaModType");
    if (ob==oacRemoveFromNetViaModType) return PyString_FromString("oacRemoveFromNetViaModType");
    if (ob==oacSetTransformViaModType) return PyString_FromString("oacSetTransformViaModType");
    if (ob==oacSetCustomHeaderViaModType) return PyString_FromString("oacSetCustomHeaderViaModType");
    if (ob==oacSetStdHeaderViaModType) return PyString_FromString("oacSetStdHeaderViaModType");
    if (ob==oacSetRouteTopologyViaModType) return PyString_FromString("oacSetRouteTopologyViaModType");
    if (ob==oacSetDirectionViaModType) return PyString_FromString("oacSetDirectionViaModType");
    if (ob==oacSetRouteStatusViaModType) return PyString_FromString("oacSetRouteStatusViaModType");
    if (ob==oacAddToPinViaModType) return PyString_FromString("oacAddToPinViaModType");
    if (ob==oacRemoveFromPinViaModType) return PyString_FromString("oacRemoveFromPinViaModType");
    if (ob==oacSetShieldedNet1ViaModType) return PyString_FromString("oacSetShieldedNet1ViaModType");
    if (ob==oacSetShieldedNet2ViaModType) return PyString_FromString("oacSetShieldedNet2ViaModType");
    if (ob==oacSetUnShieldedViaModType) return PyString_FromString("oacSetUnShieldedViaModType");
    if (ob==oacSetPurposeNumViaModType) return PyString_FromString("oacSetPurposeNumViaModType");
    if (ob==oacAddToFigGroupViaModType) return PyString_FromString("oacAddToFigGroupViaModType");
    if (ob==oacRemoveFromFigGroupViaModType) return PyString_FromString("oacRemoveFromFigGroupViaModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaViaModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaViaModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaViaModTypeEnum_FromoaViaModTypeEnum(oaViaModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaViaModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaViaModTypeEnum_doc[] =
"Type convert function for enum: oaViaModTypeEnum";
                               
static PyMethodDef PyoaViaModTypeEnum_method =
  {"oaViaModTypeEnum",(PyCFunction)PyoaViaModTypeEnum_TypeFunction,METH_VARARGS,oaViaModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaViaModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacAddToNetViaModType");
    PyDict_SetItemString(mod_dict,"oacAddToNetViaModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacRemoveFromNetViaModType");
    PyDict_SetItemString(mod_dict,"oacRemoveFromNetViaModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetTransformViaModType");
    PyDict_SetItemString(mod_dict,"oacSetTransformViaModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetCustomHeaderViaModType");
    PyDict_SetItemString(mod_dict,"oacSetCustomHeaderViaModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetStdHeaderViaModType");
    PyDict_SetItemString(mod_dict,"oacSetStdHeaderViaModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetRouteTopologyViaModType");
    PyDict_SetItemString(mod_dict,"oacSetRouteTopologyViaModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetDirectionViaModType");
    PyDict_SetItemString(mod_dict,"oacSetDirectionViaModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetRouteStatusViaModType");
    PyDict_SetItemString(mod_dict,"oacSetRouteStatusViaModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAddToPinViaModType");
    PyDict_SetItemString(mod_dict,"oacAddToPinViaModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacRemoveFromPinViaModType");
    PyDict_SetItemString(mod_dict,"oacRemoveFromPinViaModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetShieldedNet1ViaModType");
    PyDict_SetItemString(mod_dict,"oacSetShieldedNet1ViaModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetShieldedNet2ViaModType");
    PyDict_SetItemString(mod_dict,"oacSetShieldedNet2ViaModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetUnShieldedViaModType");
    PyDict_SetItemString(mod_dict,"oacSetUnShieldedViaModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetPurposeNumViaModType");
    PyDict_SetItemString(mod_dict,"oacSetPurposeNumViaModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAddToFigGroupViaModType");
    PyDict_SetItemString(mod_dict,"oacAddToFigGroupViaModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacRemoveFromFigGroupViaModType");
    PyDict_SetItemString(mod_dict,"oacRemoveFromFigGroupViaModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaViaModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaViaModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaViaModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaViaParam
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaViaParam_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaViaParam_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaViaParamObject* self = (PyoaViaParamObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaViaParam();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaViaParam)
    {
        PyParamoaViaParam p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaViaParam_Convert,&p1)) {
            self->value =  new oaViaParam(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaViaParam, Choices are:\n"
        "    ()\n"
        "    (oaViaParam)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaViaParam_tp_dealloc(PyoaViaParamObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaViaParam_tp_repr(PyObject *ob)
{
    PyParamoaViaParam value;
    int convert_status=PyoaViaParam_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[32];
    sprintf(buffer,"<oaViaParam::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaViaParam_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaViaParam v1;
    PyParamoaViaParam v2;
    int convert_status1=PyoaViaParam_Convert(ob1,&v1);
    int convert_status2=PyoaViaParam_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    if (v1.Data()==v2.Data()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaViaParam_Convert(PyObject* ob,PyParamoaViaParam* result)
{
    if (ob == NULL) return 1;
    if (PyoaViaParam_Check(ob)) {
        result->SetData(  ((PyoaViaParamObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaViaParam Failed");
    return 0;
}
int
PyoaViaParam_ConvertAof(PyObject* ob,PyParamoaViaParam* result)
{
    if (ob == NULL) return 1;
    if (ob==Py_None) {
        result->SetData(NULL);
        return 1;
    }
    if (PyoaViaParam_Check(ob)) {
        result->SetData(  ((PyoaViaParamObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaViaParam Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaViaParam_FromoaViaParam(oaViaParam* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaViaParam_Type.tp_alloc(&PyoaViaParam_Type,0);
        if (bself == NULL) return bself;
        PyoaViaParamObject* self = (PyoaViaParamObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaParam_getCutColumns_doc[] = 
"Class: oaViaParam, Function: getCutColumns\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getCutColumns() const\n"
"    Signature: getCutColumns|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of columns in the via cut matrix on the cut layer for this oaViaParam object.\n"
;

static PyObject*
oaViaParam_getCutColumns(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getCutColumns());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_getCutHeight_doc[] = 
"Class: oaViaParam, Function: getCutHeight\n"
"  Paramegers: ()\n"
"    Calls: oaDist getCutHeight() const\n"
"    Signature: getCutHeight|simple-oaDist|\n"
"    BrowseData: 1\n"
"    This function returns the height of each cut in the via cut matrix on the cut layer for this oaViaParam object.\n"
;

static PyObject*
oaViaParam_getCutHeight(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaDist result= (data.DataCall()->getCutHeight());
        return PyoaDist_FromoaDist(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_getCutLayer_doc[] = 
"Class: oaViaParam, Function: getCutLayer\n"
"  Paramegers: ()\n"
"    Calls: oaLayerNum getCutLayer() const\n"
"    Signature: getCutLayer|simple-oaLayerNum|\n"
"    BrowseData: 1\n"
"    This function returns the layer number of the cut layer previously specified for this oaViaParam object.\n"
;

static PyObject*
oaViaParam_getCutLayer(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaLayerNum result= (data.DataCall()->getCutLayer());
        return PyoaLayerNum_FromoaLayerNum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_getCutPatternVal_doc[] = 
"Class: oaViaParam, Function: getCutPatternVal\n"
"  Paramegers: (oaUInt4,oaUInt4)\n"
"    Calls: oaBoolean getCutPatternVal(oaUInt4 cutRowNum,oaUInt4 cutColNum) const\n"
"    Signature: getCutPatternVal|simple-oaBoolean|simple-oaUInt4,simple-oaUInt4,\n"
"    oaViaParam::getCutPatternVal\n"
"    This function returns the existence of a specific cut in the via cut matrix on the cut layer. Each cut is identified by a cutRowNum and cutColNum indicating the row and column of the cut. A true is returned if the cut exists and a false is returned if the cut does not exist. Note that 'cutRowNum' and 'cutColNum' values start at 0 and should not exceed the number of cut rows and columns set for the oaViaParam object. An exception is thrown if this requirement is not met.\n"
"    cutRowNum\n"
"    The row number in the cut matrix, 0 being the bottom row\n"
"    cutColNum\n"
"    The column number in the cut matrix, 0 being the left column\n"
"    oacInvalidViaParamColumnNumber\n"
"    oacInvalidViaParamRowNumber\n"
;

static PyObject*
oaViaParam_getCutPatternVal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2)) {
        oaBoolean result= (data.DataCall()->getCutPatternVal(p1.Data(),p2.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_getCutRows_doc[] = 
"Class: oaViaParam, Function: getCutRows\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getCutRows() const\n"
"    Signature: getCutRows|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of rows in the via cut matrix on the cut layer for this oaViaParam object.\n"
;

static PyObject*
oaViaParam_getCutRows(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getCutRows());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_getCutSpacing_doc[] = 
"Class: oaViaParam, Function: getCutSpacing\n"
"  Paramegers: ()\n"
"    Calls: const oaVector& getCutSpacing() const\n"
"    Signature: getCutSpacing|cref-oaVector|\n"
"    BrowseData: 1\n"
"    This function returns the 'x' and 'y' spacing between the cuts in the via cut matrix as an oaVector object reference. The spacing applies only for multiple cut vias or via definitions.\n"
;

static PyObject*
oaViaParam_getCutSpacing(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaVector* result= new oaVector(data.DataCall()->getCutSpacing());
        return PyoaVector_FromoaVector(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_getCutWidth_doc[] = 
"Class: oaViaParam, Function: getCutWidth\n"
"  Paramegers: ()\n"
"    Calls: oaDist getCutWidth() const\n"
"    Signature: getCutWidth|simple-oaDist|\n"
"    BrowseData: 1\n"
"    This function returns the width of each cut in the via cut matrix on the cut layer for this oaViaParam object.\n"
;

static PyObject*
oaViaParam_getCutWidth(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaDist result= (data.DataCall()->getCutWidth());
        return PyoaDist_FromoaDist(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_getImplant1Enc_doc[] = 
"Class: oaViaParam, Function: getImplant1Enc\n"
"  Paramegers: ()\n"
"    Calls: const oaVector& getImplant1Enc() const\n"
"    Signature: getImplant1Enc|cref-oaVector|\n"
"    BrowseData: 1\n"
"    This function returns the width and height of the implant enclosure for implant1 layer as a reference to an oaVector object whose x and y values indicate the width and height respectively. This enclosure is relative to the bounding box of the shape on Layer1.\n"
;

static PyObject*
oaViaParam_getImplant1Enc(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaVector* result= new oaVector(data.DataCall()->getImplant1Enc());
        return PyoaVector_FromoaVector(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_getImplant2Enc_doc[] = 
"Class: oaViaParam, Function: getImplant2Enc\n"
"  Paramegers: ()\n"
"    Calls: const oaVector& getImplant2Enc() const\n"
"    Signature: getImplant2Enc|cref-oaVector|\n"
"    BrowseData: 1\n"
"    This function returns the width and height of the implant enclosure for implant2 layer as a reference to an oaVector object whose x and y values indicate the width and height respectively. This enclosure is relative to the bounding box of the shape on Layer2.\n"
;

static PyObject*
oaViaParam_getImplant2Enc(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaVector* result= new oaVector(data.DataCall()->getImplant2Enc());
        return PyoaVector_FromoaVector(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_getLayer1Enc_doc[] = 
"Class: oaViaParam, Function: getLayer1Enc\n"
"  Paramegers: ()\n"
"    Calls: const oaVector& getLayer1Enc() const\n"
"    Signature: getLayer1Enc|cref-oaVector|\n"
"    BrowseData: 1\n"
"    This function returns the width and height of the layer1 enclosure as a reference to an oaVector object whose x and y values indicate the width and height respectively. This enclosure is relative to the bounding box of the via cut matrix which may consist of a single cut.\n"
;

static PyObject*
oaViaParam_getLayer1Enc(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaVector* result= new oaVector(data.DataCall()->getLayer1Enc());
        return PyoaVector_FromoaVector(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_getLayer1Offset_doc[] = 
"Class: oaViaParam, Function: getLayer1Offset\n"
"  Paramegers: ()\n"
"    Calls: const oaVector& getLayer1Offset() const\n"
"    Signature: getLayer1Offset|cref-oaVector|\n"
"    BrowseData: 1\n"
"    This function returns the current x and y offsets for the layer1 enclosure as a reference to an oaVector object whose x and y values indicate the x and y offsets respectively.\n"
;

static PyObject*
oaViaParam_getLayer1Offset(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaVector* result= new oaVector(data.DataCall()->getLayer1Offset());
        return PyoaVector_FromoaVector(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_getLayer2Enc_doc[] = 
"Class: oaViaParam, Function: getLayer2Enc\n"
"  Paramegers: ()\n"
"    Calls: const oaVector& getLayer2Enc() const\n"
"    Signature: getLayer2Enc|cref-oaVector|\n"
"    BrowseData: 1\n"
"    This function returns the width and height of the layer2 enclosure as a reference to an oaVector object whose x and y values indicate the width and height respectively. This enclosure is relative to the bounding box of the via cut matrix which may consist of a single cut.\n"
;

static PyObject*
oaViaParam_getLayer2Enc(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaVector* result= new oaVector(data.DataCall()->getLayer2Enc());
        return PyoaVector_FromoaVector(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_getLayer2Offset_doc[] = 
"Class: oaViaParam, Function: getLayer2Offset\n"
"  Paramegers: ()\n"
"    Calls: const oaVector& getLayer2Offset() const\n"
"    Signature: getLayer2Offset|cref-oaVector|\n"
"    BrowseData: 1\n"
"    This function returns the current x and y offsets for the layer2 enclosure as a reference to an oaVector object whose x and y values indicate the x and y offsets respectively.\n"
;

static PyObject*
oaViaParam_getLayer2Offset(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaVector* result= new oaVector(data.DataCall()->getLayer2Offset());
        return PyoaVector_FromoaVector(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_getOriginOffset_doc[] = 
"Class: oaViaParam, Function: getOriginOffset\n"
"  Paramegers: ()\n"
"    Calls: const oaVector& getOriginOffset() const\n"
"    Signature: getOriginOffset|cref-oaVector|\n"
"    BrowseData: 1\n"
"    oaViaParam::getOriginOffset\n"
"    This function returns the origin offset specified for this oaViaParam object as a reference to an oaVector object whose x and y values indicate the x and y offsets that apply.\n"
;

static PyObject*
oaViaParam_getOriginOffset(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaVector* result= new oaVector(data.DataCall()->getOriginOffset());
        return PyoaVector_FromoaVector(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_hasDefault_doc[] = 
"Class: oaViaParam, Function: hasDefault\n"
"  Paramegers: (oaViaParamType)\n"
"    Calls: oaBoolean hasDefault(oaViaParamType paramType) const\n"
"    Signature: hasDefault|simple-oaBoolean|simple-oaViaParamType,\n"
"    This function returns true if the specified parameter field is set to the default value; otherwise it returns false.\n"
"    paramType\n"
"    The parameter type to query to see if it uses the default value\n"
;

static PyObject*
oaViaParam_hasDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    PyParamoaViaParamType p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaViaParamType_Convert,&p1)) {
        oaBoolean result= (data.DataCall()->hasDefault(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_hasDefaultCutPattern_doc[] = 
"Class: oaViaParam, Function: hasDefaultCutPattern\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean hasDefaultCutPattern() const\n"
"    Signature: hasDefaultCutPattern|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating if a default cut pattern is in effect. A default cut pattern implies that all via cuts exist in the via cut matrix.\n"
;

static PyObject*
oaViaParam_hasDefaultCutPattern(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->hasDefaultCutPattern());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_isEqual_doc[] = 
"Class: oaViaParam, Function: isEqual\n"
"  Paramegers: (oaViaParam)\n"
"    Calls: oaBoolean isEqual(const oaViaParam& params) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaViaParam,\n"
"    This function compares this oaViaParam to the specified oaViaParam. True is returned if the data for both is equal; otherwise false is returned. Flags are not included in the comparison.\n"
"    params\n"
"    Specifies the oaViaParam object to compare to this oaViaParam object\n"
;

static PyObject*
oaViaParam_isEqual(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    PyParamoaViaParam p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaViaParam_Convert,&p1)) {
        oaBoolean result= (data.DataCall()->isEqual(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_setCutColumns_doc[] = 
"Class: oaViaParam, Function: setCutColumns\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setCutColumns(oaUInt4 cutColumns)\n"
"    Signature: setCutColumns|void-void|simple-oaUInt4,\n"
"    oaViaParam::setCutColumns\n"
"    This function sets the number of columns for the cut matrix on the cut layer for this oaViaParam object to the specified 'cutColumnsIn' value. Note that this action is a change to the existing via cut matrix configuration and this action will turn on all the via cuts in the new cut matrix which is the default setting. An oaViaParam needs to have at least one column and an exception is thrown if zero columns are specified.\n"
"    cutColumnsIn\n"
"    The number of columns to be used for the via cut matrix\n"
"    oacZeroColumnsSpecifiedForViaParam\n"
;

static PyObject*
oaViaParam_setCutColumns(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setCutColumns(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_setCutHeight_doc[] = 
"Class: oaViaParam, Function: setCutHeight\n"
"  Paramegers: (oaDist)\n"
"    Calls: void setCutHeight(oaDist height)\n"
"    Signature: setCutHeight|void-void|simple-oaDist,\n"
"    oaViaParam::setCutHeight\n"
"    This function sets the height to be used for each via cut in the via cut matrix on the cut layer for this oaViaParam object to the specified 'height' value.\n"
"    height\n"
"    The height to be used for each cut in the via cut matrix\n"
;

static PyObject*
oaViaParam_setCutHeight(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    PyParamoaDist p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaDist_Convert,&p1)) {
        data.DataCall()->setCutHeight(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_setCutLayer_doc[] = 
"Class: oaViaParam, Function: setCutLayer\n"
"  Paramegers: (oaLayerNum)\n"
"    Calls: void setCutLayer(oaLayerNum cutLayer)\n"
"    Signature: setCutLayer|void-void|simple-oaLayerNum,\n"
"    oaViaParam::setCutLayer\n"
"    This function sets the layer that should be used as the cut layer for this oaViaParam object to the specified 'cutLayerIn' value.\n"
"    cutLayerIn\n"
"    The layer number of the layer to be used as the via cut layer\n"
;

static PyObject*
oaViaParam_setCutLayer(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    PyParamoaLayerNum p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaLayerNum_Convert,&p1)) {
        data.DataCall()->setCutLayer(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_setCutPatternVal_doc[] = 
"Class: oaViaParam, Function: setCutPatternVal\n"
"  Paramegers: (oaUInt4,oaUInt4,oaBoolean)\n"
"    Calls: void setCutPatternVal(oaUInt4 cutRowNum,oaUInt4 cutColNum,oaBoolean val)\n"
"    Signature: setCutPatternVal|void-void|simple-oaUInt4,simple-oaUInt4,simple-oaBoolean,\n"
"    oaViaParam::setCutPatternVal\n"
"    This function specifies whether a particular via cut in the via cut matrix should exist or not. Each cut is identified by a cutRowNum and cutColNum indicating the row and column of the cut depending upon the specified 'val' value. Note that 'cutRowNum' and 'cutColNum' values start at 0 and should not exceed the number of cut rows and columns set for the oaViaParam object. An exception is thrown if this requirement is not met.\n"
"    Also note that this function should be used only after the rows and columns for the via cut matrix have been specified .\n"
"    cutRowNum\n"
"    The row number in the cut matrix, 0 being the bottom row\n"
"    cutColNum\n"
"    The column number in the cut matrix, 0 being the left column\n"
"    val\n"
"    A boolean 'true' indicates the existence of a cut and a boolean 'false' indicates the absence of a cut.\n"
"    oacInvalidViaParamColumnNumber\n"
"    oacInvalidViaParamRowNumber\n"
;

static PyObject*
oaViaParam_setCutPatternVal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    PyParamoaBoolean p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2,
          &PyoaBoolean_Convert,&p3)) {
        data.DataCall()->setCutPatternVal(p1.Data(),p2.Data(),p3.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_setCutRows_doc[] = 
"Class: oaViaParam, Function: setCutRows\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setCutRows(oaUInt4 cutRows)\n"
"    Signature: setCutRows|void-void|simple-oaUInt4,\n"
"    oaViaParam::setCutRows\n"
"    This function sets the number of rows for the cut matrix on the cut layer for this oaViaParam object to the specified 'cutRowsIn' value. Note that this action is a change to the existing via cut matrix configuration and this action will turn on all the via cuts in the new cut matrix which is the default setting. An oaViaParam needs to have at least one row and an exception is thrown if zero rows are specified.\n"
"    cutRowsIn\n"
"    The number of rows to be used for the via cut matrix\n"
"    oacZeroRowsSpecifiedForViaParam\n"
;

static PyObject*
oaViaParam_setCutRows(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setCutRows(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_setCutSpacing_doc[] = 
"Class: oaViaParam, Function: setCutSpacing\n"
"  Paramegers: (oaVector)\n"
"    Calls: void setCutSpacing(const oaVector& cutSpacing)\n"
"    Signature: setCutSpacing|void-void|cref-oaVector,\n"
"    oaViaParam::setCutSpacing\n"
"    This function sets the 'x' and 'y' spacing between the cuts in the via cut matrix for this object as per the specified x and y values in the oaVector 'cutSpacing' parameter. The spacing applies only for multiple cut vias or via definitions.\n"
"    cutSpacing\n"
"    The x and y spacing to be used between via cuts specified as an oaVector object\n"
;

static PyObject*
oaViaParam_setCutSpacing(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    PyParamoaVector p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaVector_Convert,&p1)) {
        data.DataCall()->setCutSpacing(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_setCutWidth_doc[] = 
"Class: oaViaParam, Function: setCutWidth\n"
"  Paramegers: (oaDist)\n"
"    Calls: void setCutWidth(oaDist width)\n"
"    Signature: setCutWidth|void-void|simple-oaDist,\n"
"    oaViaParam::setCutWidth\n"
"    This function sets the width to be used for each cut in the via cut matrix on the cut layer for this oaViaParam object to the specified 'width' value.\n"
"    width\n"
"    The width to be used for each via cut in the via cut matrix\n"
;

static PyObject*
oaViaParam_setCutWidth(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    PyParamoaDist p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaDist_Convert,&p1)) {
        data.DataCall()->setCutWidth(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_setDefault_doc[] = 
"Class: oaViaParam, Function: setDefault\n"
"  Paramegers: (oaViaParamType)\n"
"    Calls: void setDefault(oaViaParamType paramType)\n"
"    Signature: setDefault|void-void|simple-oaViaParamType,\n"
"    This function sets the specified parameter field to the default value. This will cause oaViaParam::hasDefalult() to return true for the specified parameter field. The parameter field values are reset to 1 for cut rows and columns; the other parameter field values are reset to 0.\n"
"    paramType\n"
"    The parameter type on which to set the default value\n"
;

static PyObject*
oaViaParam_setDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    PyParamoaViaParamType p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaViaParamType_Convert,&p1)) {
        data.DataCall()->setDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_setDefaultCutPattern_doc[] = 
"Class: oaViaParam, Function: setDefaultCutPattern\n"
"  Paramegers: ()\n"
"    Calls: void setDefaultCutPattern()\n"
"    Signature: setDefaultCutPattern|void-void|\n"
"    BrowseData: 0\n"
"    This function removes any cut pattern customization that may exist for this oaViaParam object and makes the default cut pattern apply. All via cuts are then assumed to exist.\n"
;

static PyObject*
oaViaParam_setDefaultCutPattern(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->setDefaultCutPattern();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_setImplant1Enc_doc[] = 
"Class: oaViaParam, Function: setImplant1Enc\n"
"  Paramegers: (oaVector)\n"
"    Calls: void setImplant1Enc(const oaVector& imp1Enc)\n"
"    Signature: setImplant1Enc|void-void|cref-oaVector,\n"
"    oaViaParam::setImplant1Enc\n"
"    This function sets the width and height of the implant enclosure for implant1 layer based on the specified 'imp1Enc' oaVector object whose x and y values indicate the width and height respectively. This enclosure is relative to the bounding box of the via cut matrix which may consist of a single cut.\n"
"    imp1Enc\n"
"    A reference to an oaVector object whose x and y values indicate the enclosure\n"
;

static PyObject*
oaViaParam_setImplant1Enc(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    PyParamoaVector p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaVector_Convert,&p1)) {
        data.DataCall()->setImplant1Enc(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_setImplant2Enc_doc[] = 
"Class: oaViaParam, Function: setImplant2Enc\n"
"  Paramegers: (oaVector)\n"
"    Calls: void setImplant2Enc(const oaVector& imp2Enc)\n"
"    Signature: setImplant2Enc|void-void|cref-oaVector,\n"
"    oaViaParam::setImplant2Enc\n"
"    This function sets the width and height of the implant enclosure for implant2 layer based on the specified 'imp2Enc' oaVector object whose x and y values indicate the width and height respectively. This enclosure is relative to the bounding box of the via cut matrix which may consist of a single cut.\n"
"    imp2Enc\n"
"    A reference to an oaVector object whose x and y values indicate the enclosure\n"
;

static PyObject*
oaViaParam_setImplant2Enc(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    PyParamoaVector p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaVector_Convert,&p1)) {
        data.DataCall()->setImplant2Enc(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_setLayer1Enc_doc[] = 
"Class: oaViaParam, Function: setLayer1Enc\n"
"  Paramegers: (oaVector)\n"
"    Calls: void setLayer1Enc(const oaVector& layer1Enc)\n"
"    Signature: setLayer1Enc|void-void|cref-oaVector,\n"
"    oaViaParam::setLayer1Enc\n"
"    This function sets the width and height of the layer1 enclosure based on the specified 'layer1Enc' oaVector object whose x and y values indicate the width and height respectively. This enclosure is relative to the bounding box of the via cut matrix which may consist of a single cut.\n"
"    layer1Enc\n"
"    A reference to an oaVector object whose x and y values indicate the enclosure\n"
;

static PyObject*
oaViaParam_setLayer1Enc(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    PyParamoaVector p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaVector_Convert,&p1)) {
        data.DataCall()->setLayer1Enc(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_setLayer1Offset_doc[] = 
"Class: oaViaParam, Function: setLayer1Offset\n"
"  Paramegers: (oaVector)\n"
"    Calls: void setLayer1Offset(const oaVector& layer1Offset)\n"
"    Signature: setLayer1Offset|void-void|cref-oaVector,\n"
"    oaViaParam::setLayer1Offset\n"
"    This function sets the current x and y offsets for the layer1 enclosure based on the specified 'layer1Offset' oaVector object whose x and y values indicate the x and y offsets respectively.\n"
"    layer1Offset\n"
"    A reference to an oaVector object whose x and y values indicate the respective offsets\n"
;

static PyObject*
oaViaParam_setLayer1Offset(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    PyParamoaVector p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaVector_Convert,&p1)) {
        data.DataCall()->setLayer1Offset(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_setLayer2Enc_doc[] = 
"Class: oaViaParam, Function: setLayer2Enc\n"
"  Paramegers: (oaVector)\n"
"    Calls: void setLayer2Enc(const oaVector& layer2Enc)\n"
"    Signature: setLayer2Enc|void-void|cref-oaVector,\n"
"    oaViaParam::setLayer2Enc\n"
"    This function sets the width and height of the layer2 enclosure based on the specified 'layer2Enc' oaVector object whose x and y values indicate the width and height respectively. This enclosure is relative to the bounding box of the via cut matrix which may consist of a single cut.\n"
"    layer2Enc\n"
"    A reference to an oaVector object whose x and y values indicate the enclosure\n"
;

static PyObject*
oaViaParam_setLayer2Enc(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    PyParamoaVector p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaVector_Convert,&p1)) {
        data.DataCall()->setLayer2Enc(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_setLayer2Offset_doc[] = 
"Class: oaViaParam, Function: setLayer2Offset\n"
"  Paramegers: (oaVector)\n"
"    Calls: void setLayer2Offset(const oaVector& layer2Offset)\n"
"    Signature: setLayer2Offset|void-void|cref-oaVector,\n"
"    oaViaParam::setLayer2Offset\n"
"    This function sets the current x and y offsets for the layer1 enclosure based on the specified 'layer2Offset' oaVector object whose x and y values indicate the x and y offsets respectively.\n"
"    layer2Offset\n"
"    A reference to an oaVector object whose x and y values indicate the respective offsets\n"
;

static PyObject*
oaViaParam_setLayer2Offset(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    PyParamoaVector p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaVector_Convert,&p1)) {
        data.DataCall()->setLayer2Offset(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParam_setOriginOffset_doc[] = 
"Class: oaViaParam, Function: setOriginOffset\n"
"  Paramegers: (oaVector)\n"
"    Calls: void setOriginOffset(const oaVector& originOffset)\n"
"    Signature: setOriginOffset|void-void|cref-oaVector,\n"
"    oaViaParam::setOriginOffset\n"
"    This function sets the origin offset for this oaViaParam object based on the specified 'originOffset' oaVector object whose x and y values indicate the x and y offsets that apply.\n"
"    originOffset\n"
"    A reference to an oaVector object whose x and y values indicate the respective offsets\n"
;

static PyObject*
oaViaParam_setOriginOffset(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParam data;
    int convert_status=PyoaViaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamObject* self=(PyoaViaParamObject*)ob;

    PyParamoaVector p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaVector_Convert,&p1)) {
        data.DataCall()->setOriginOffset(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaViaParam_assign_doc[] = 
"Class: oaViaParam, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaViaParam_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaViaParam data;
  int convert_status=PyoaViaParam_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaViaParam p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaViaParam_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaViaParam_methodlist[] = {
    {"getCutColumns",(PyCFunction)oaViaParam_getCutColumns,METH_VARARGS,oaViaParam_getCutColumns_doc},
    {"getCutHeight",(PyCFunction)oaViaParam_getCutHeight,METH_VARARGS,oaViaParam_getCutHeight_doc},
    {"getCutLayer",(PyCFunction)oaViaParam_getCutLayer,METH_VARARGS,oaViaParam_getCutLayer_doc},
    {"getCutPatternVal",(PyCFunction)oaViaParam_getCutPatternVal,METH_VARARGS,oaViaParam_getCutPatternVal_doc},
    {"getCutRows",(PyCFunction)oaViaParam_getCutRows,METH_VARARGS,oaViaParam_getCutRows_doc},
    {"getCutSpacing",(PyCFunction)oaViaParam_getCutSpacing,METH_VARARGS,oaViaParam_getCutSpacing_doc},
    {"getCutWidth",(PyCFunction)oaViaParam_getCutWidth,METH_VARARGS,oaViaParam_getCutWidth_doc},
    {"getImplant1Enc",(PyCFunction)oaViaParam_getImplant1Enc,METH_VARARGS,oaViaParam_getImplant1Enc_doc},
    {"getImplant2Enc",(PyCFunction)oaViaParam_getImplant2Enc,METH_VARARGS,oaViaParam_getImplant2Enc_doc},
    {"getLayer1Enc",(PyCFunction)oaViaParam_getLayer1Enc,METH_VARARGS,oaViaParam_getLayer1Enc_doc},
    {"getLayer1Offset",(PyCFunction)oaViaParam_getLayer1Offset,METH_VARARGS,oaViaParam_getLayer1Offset_doc},
    {"getLayer2Enc",(PyCFunction)oaViaParam_getLayer2Enc,METH_VARARGS,oaViaParam_getLayer2Enc_doc},
    {"getLayer2Offset",(PyCFunction)oaViaParam_getLayer2Offset,METH_VARARGS,oaViaParam_getLayer2Offset_doc},
    {"getOriginOffset",(PyCFunction)oaViaParam_getOriginOffset,METH_VARARGS,oaViaParam_getOriginOffset_doc},
    {"hasDefault",(PyCFunction)oaViaParam_hasDefault,METH_VARARGS,oaViaParam_hasDefault_doc},
    {"hasDefaultCutPattern",(PyCFunction)oaViaParam_hasDefaultCutPattern,METH_VARARGS,oaViaParam_hasDefaultCutPattern_doc},
    {"isEqual",(PyCFunction)oaViaParam_isEqual,METH_VARARGS,oaViaParam_isEqual_doc},
    {"setCutColumns",(PyCFunction)oaViaParam_setCutColumns,METH_VARARGS,oaViaParam_setCutColumns_doc},
    {"setCutHeight",(PyCFunction)oaViaParam_setCutHeight,METH_VARARGS,oaViaParam_setCutHeight_doc},
    {"setCutLayer",(PyCFunction)oaViaParam_setCutLayer,METH_VARARGS,oaViaParam_setCutLayer_doc},
    {"setCutPatternVal",(PyCFunction)oaViaParam_setCutPatternVal,METH_VARARGS,oaViaParam_setCutPatternVal_doc},
    {"setCutRows",(PyCFunction)oaViaParam_setCutRows,METH_VARARGS,oaViaParam_setCutRows_doc},
    {"setCutSpacing",(PyCFunction)oaViaParam_setCutSpacing,METH_VARARGS,oaViaParam_setCutSpacing_doc},
    {"setCutWidth",(PyCFunction)oaViaParam_setCutWidth,METH_VARARGS,oaViaParam_setCutWidth_doc},
    {"setDefault",(PyCFunction)oaViaParam_setDefault,METH_VARARGS,oaViaParam_setDefault_doc},
    {"setDefaultCutPattern",(PyCFunction)oaViaParam_setDefaultCutPattern,METH_VARARGS,oaViaParam_setDefaultCutPattern_doc},
    {"setImplant1Enc",(PyCFunction)oaViaParam_setImplant1Enc,METH_VARARGS,oaViaParam_setImplant1Enc_doc},
    {"setImplant2Enc",(PyCFunction)oaViaParam_setImplant2Enc,METH_VARARGS,oaViaParam_setImplant2Enc_doc},
    {"setLayer1Enc",(PyCFunction)oaViaParam_setLayer1Enc,METH_VARARGS,oaViaParam_setLayer1Enc_doc},
    {"setLayer1Offset",(PyCFunction)oaViaParam_setLayer1Offset,METH_VARARGS,oaViaParam_setLayer1Offset_doc},
    {"setLayer2Enc",(PyCFunction)oaViaParam_setLayer2Enc,METH_VARARGS,oaViaParam_setLayer2Enc_doc},
    {"setLayer2Offset",(PyCFunction)oaViaParam_setLayer2Offset,METH_VARARGS,oaViaParam_setLayer2Offset_doc},
    {"setOriginOffset",(PyCFunction)oaViaParam_setOriginOffset,METH_VARARGS,oaViaParam_setOriginOffset_doc},
    {"assign",(PyCFunction)oaViaParam_tp_assign,METH_VARARGS,oaViaParam_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaParam_doc[] = 
"Class: oaViaParam\n"
"  The oaViaParam class implements a set of standard via parameters used to create and manipulate standard via ( oaStdVia ) or standard via definition ( oaStdViaDef ) objects in the design and technology databases. oaViaParam objects are utility objects and are not persistent by themselves.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaViaParam()\n"
"    Signature: oaViaParam||\n"
"    This is the constructor for the oaViaParam class and constructs an oaViaParam object. All the parameter fields are set to use default values. The parameter field values are set to 1 for cut rows and columns; the other parameter field values are set to 0.\n"
"  Paramegers: (oaViaParam)\n"
"    Calls: oaViaParam(const oaViaParam& paramIn)\n"
"    Signature: oaViaParam||cref-oaViaParam,\n"
"    This is the copy constructor for the oaViaParam class and constructs an exact copy of the oaViaParam object whose reference is passed to it as a parameter.\n"
"    paramIn\n"
"    The oaViaParam object to copy\n"
"  Paramegers: (oaViaParam)\n"
"    Calls: (const oaViaParam&)\n"
"    Signature: oaViaParam||cref-oaViaParam,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaViaParam_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaViaParam",
    sizeof(PyoaViaParamObject),
    0,
    (destructor)oaViaParam_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaViaParam_tp_compare,	/* tp_compare */
    (reprfunc)oaViaParam_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaViaParam_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaViaParam_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaViaParam_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaViaParam_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaViaParam_Type)<0) {
      printf("** PyType_Ready failed for: oaViaParam\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaViaParam",
           (PyObject*)(&PyoaViaParam_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaViaParam\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaViaParamType
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaViaParamType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaViaParamType_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaViaParamTypeObject* self = (PyoaViaParamTypeObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaViaParamTypeEnum)
    {
        PyParamoaViaParamTypeEnum p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaViaParamTypeEnum_Convert,&p1)) {
            self->value =  new oaViaParamType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            self->value =  new oaViaParamType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaViaParamType)
    {
        PyParamoaViaParamType p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaViaParamType_Convert,&p1)) {
            self->value= new oaViaParamType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaViaParamType, Choices are:\n"
        "    (oaViaParamTypeEnum)\n"
        "    (oaString)\n"
        "    (oaViaParamType)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaViaParamType_tp_dealloc(PyoaViaParamTypeObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaViaParamType_tp_repr(PyObject *ob)
{
    PyParamoaViaParamType value;
    int convert_status=PyoaViaParamType_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    oaString sresult(value.DataCall()->getName());

    char addr[36];
    sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
    oaString buffer;
    buffer+=oaString("<oaViaParamType::");
    buffer+=oaString(addr);
    buffer+=oaString("::");
    buffer+=oaString(sresult);
    buffer+=oaString(">");
    result=PyString_FromString((char*)(const char*)buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaViaParamType_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaViaParamType v1;
    PyParamoaViaParamType v2;
    int convert_status1=PyoaViaParamType_Convert(ob1,&v1);
    int convert_status2=PyoaViaParamType_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaViaParamType_Convert(PyObject* ob,PyParamoaViaParamType* result)
{
    if (ob == NULL) return 1;
    if (PyoaViaParamType_Check(ob)) {
        result->SetData(  ((PyoaViaParamTypeObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaViaParamType Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaViaParamType_FromoaViaParamType(oaViaParamType* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaViaParamType_Type.tp_alloc(&PyoaViaParamType_Type,0);
        if (bself == NULL) return bself;
        PyoaViaParamTypeObject* self = (PyoaViaParamTypeObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaParamType_getName_doc[] = 
"Class: oaViaParamType, Function: getName\n"
"  Paramegers: ()\n"
"    Calls: const oaString& getName() const\n"
"    Signature: getName|cref-oaString|\n"
"    BrowseData: 1\n"
"    This function returns the string name associated with the encapsulated oaViaParamTypeEnum object set on this oaViaParamType.\n"
;

static PyObject*
oaViaParamType_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParamType data;
    int convert_status=PyoaViaParamType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamTypeObject* self=(PyoaViaParamTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaString result= (data.DataCall()->getName());
        return PyoaString_FromoaString(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaParamType_oaViaParamTypeEnum_doc[] = 
"Class: oaViaParamType, Function: oaViaParamTypeEnum\n"
"  Paramegers: ()\n"
"    Calls: oaViaParamTypeEnum oaViaParamTypeEnum() const\n"
"    Signature: operator oaViaParamTypeEnum|simple-oaViaParamTypeEnum|\n"
"    BrowseData: 1\n"
"    This operator returns the oaViaParamTypeEnum set on this oaViaParamType.\n"
;

static PyObject*
oaViaParamType_oaViaParamTypeEnum(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaParamType data;
    int convert_status=PyoaViaParamType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaParamTypeObject* self=(PyoaViaParamTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaViaParamTypeEnum result= (data.DataCall()->operator oaViaParamTypeEnum());
        return PyoaViaParamTypeEnum_FromoaViaParamTypeEnum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaViaParamType_assign_doc[] = 
"Class: oaViaParamType, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaViaParamType_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaViaParamType data;
  int convert_status=PyoaViaParamType_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaViaParamType p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaViaParamType_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaViaParamType_methodlist[] = {
    {"getName",(PyCFunction)oaViaParamType_getName,METH_VARARGS,oaViaParamType_getName_doc},
    {"oaViaParamTypeEnum",(PyCFunction)oaViaParamType_oaViaParamTypeEnum,METH_VARARGS,oaViaParamType_oaViaParamTypeEnum_doc},
    {"assign",(PyCFunction)oaViaParamType_tp_assign,METH_VARARGS,oaViaParamType_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaParamType_doc[] = 
"Class: oaViaParamType\n"
"  oaViaParamTypeEnum\n"
"  The oaViaParamType class is an enum wrapper class for oaViaParamTypeEnum values.\n"
"  See Enum Wrappers in the Programmers Guide for a discussion of enum wrappers.\n"
"Constructors:\n"
"  Paramegers: (oaViaParamTypeEnum)\n"
"    Calls: oaViaParamType(oaViaParamTypeEnum valueIn)\n"
"    Signature: oaViaParamType||simple-oaViaParamTypeEnum,\n"
"    This function constructs an instance of an oaViaParamType class using the specified oaViaParamTypeEnum value.\n"
"    valueIn\n"
"    A value from the enumerated list representing via parameter types that this object will represent\n"
"  Paramegers: (oaString)\n"
"    Calls: oaViaParamType(const oaString& name)\n"
"    Signature: oaViaParamType||cref-oaString,\n"
"    This function constructs an instance of an oaViaParamType class using the oaViaParamTypeEnum associated with the specified string name . This name must be defined in the legal set of names associated with oaViaParamTypeEnum.\n"
"    name\n"
"    A reference to an oaString object representing a valid oaViaParamTypeEnum name\n"
"    oacInvalidViaParamTypeName\n"
"  Paramegers: (oaViaParamType)\n"
"    Calls: (const oaViaParamType&)\n"
"    Signature: oaViaParamType||cref-oaViaParamType,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaViaParamType_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaViaParamType",
    sizeof(PyoaViaParamTypeObject),
    0,
    (destructor)oaViaParamType_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaViaParamType_tp_compare,	/* tp_compare */
    (reprfunc)oaViaParamType_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaViaParamType_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaViaParamType_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaViaParamType_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaViaParamType_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaViaParamType_Type)<0) {
      printf("** PyType_Ready failed for: oaViaParamType\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaViaParamType",
           (PyObject*)(&PyoaViaParamType_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaViaParamType\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaViaParamTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaViaParamTypeEnum_Convert(PyObject* ob,PyParamoaViaParamTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacLayer1EncViaParamType")==0) { result->SetData(oacLayer1EncViaParamType); return 1;}
        if (strcasecmp(str,"oacLayer2EncViaParamType")==0) { result->SetData(oacLayer2EncViaParamType); return 1;}
        if (strcasecmp(str,"oacImplant1EncViaParamType")==0) { result->SetData(oacImplant1EncViaParamType); return 1;}
        if (strcasecmp(str,"oacImplant2EncViaParamType")==0) { result->SetData(oacImplant2EncViaParamType); return 1;}
        if (strcasecmp(str,"oacLayer1OffsetViaParamType")==0) { result->SetData(oacLayer1OffsetViaParamType); return 1;}
        if (strcasecmp(str,"oacLayer2OffsetViaParamType")==0) { result->SetData(oacLayer2OffsetViaParamType); return 1;}
        if (strcasecmp(str,"oacCutSpacingViaParamType")==0) { result->SetData(oacCutSpacingViaParamType); return 1;}
        if (strcasecmp(str,"oacOriginOffsetViaParamType")==0) { result->SetData(oacOriginOffsetViaParamType); return 1;}
        if (strcasecmp(str,"oacCutSizeViaParamType")==0) { result->SetData(oacCutSizeViaParamType); return 1;}
        if (strcasecmp(str,"oacCutLayerViaParamType")==0) { result->SetData(oacCutLayerViaParamType); return 1;}
        if (strcasecmp(str,"oacCutColumnsViaParamType")==0) { result->SetData(oacCutColumnsViaParamType); return 1;}
        if (strcasecmp(str,"oacCutRowsViaParamType")==0) { result->SetData(oacCutRowsViaParamType); return 1;}
        if (strcasecmp(str,"oacCutWidthViaParamType")==0) { result->SetData(oacCutWidthViaParamType); return 1;}
        if (strcasecmp(str,"oacCutHeightViaParamType")==0) { result->SetData(oacCutHeightViaParamType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaViaParamTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaViaParamTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaViaParamTypeEnum_FromoaViaParamTypeEnum(oaViaParamTypeEnum ob)
{
    if (ob==oacLayer1EncViaParamType) return PyString_FromString("oacLayer1EncViaParamType");
    if (ob==oacLayer2EncViaParamType) return PyString_FromString("oacLayer2EncViaParamType");
    if (ob==oacImplant1EncViaParamType) return PyString_FromString("oacImplant1EncViaParamType");
    if (ob==oacImplant2EncViaParamType) return PyString_FromString("oacImplant2EncViaParamType");
    if (ob==oacLayer1OffsetViaParamType) return PyString_FromString("oacLayer1OffsetViaParamType");
    if (ob==oacLayer2OffsetViaParamType) return PyString_FromString("oacLayer2OffsetViaParamType");
    if (ob==oacCutSpacingViaParamType) return PyString_FromString("oacCutSpacingViaParamType");
    if (ob==oacOriginOffsetViaParamType) return PyString_FromString("oacOriginOffsetViaParamType");
    if (ob==oacCutSizeViaParamType) return PyString_FromString("oacCutSizeViaParamType");
    if (ob==oacCutLayerViaParamType) return PyString_FromString("oacCutLayerViaParamType");
    if (ob==oacCutColumnsViaParamType) return PyString_FromString("oacCutColumnsViaParamType");
    if (ob==oacCutRowsViaParamType) return PyString_FromString("oacCutRowsViaParamType");
    if (ob==oacCutWidthViaParamType) return PyString_FromString("oacCutWidthViaParamType");
    if (ob==oacCutHeightViaParamType) return PyString_FromString("oacCutHeightViaParamType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaViaParamTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaViaParamTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaViaParamTypeEnum_FromoaViaParamTypeEnum(oaViaParamTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaViaParamTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaViaParamTypeEnum_doc[] =
"Type convert function for enum: oaViaParamTypeEnum";
                               
static PyMethodDef PyoaViaParamTypeEnum_method =
  {"oaViaParamTypeEnum",(PyCFunction)PyoaViaParamTypeEnum_TypeFunction,METH_VARARGS,oaViaParamTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaViaParamTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacLayer1EncViaParamType");
    PyDict_SetItemString(mod_dict,"oacLayer1EncViaParamType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLayer2EncViaParamType");
    PyDict_SetItemString(mod_dict,"oacLayer2EncViaParamType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacImplant1EncViaParamType");
    PyDict_SetItemString(mod_dict,"oacImplant1EncViaParamType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacImplant2EncViaParamType");
    PyDict_SetItemString(mod_dict,"oacImplant2EncViaParamType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLayer1OffsetViaParamType");
    PyDict_SetItemString(mod_dict,"oacLayer1OffsetViaParamType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLayer2OffsetViaParamType");
    PyDict_SetItemString(mod_dict,"oacLayer2OffsetViaParamType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCutSpacingViaParamType");
    PyDict_SetItemString(mod_dict,"oacCutSpacingViaParamType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOriginOffsetViaParamType");
    PyDict_SetItemString(mod_dict,"oacOriginOffsetViaParamType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCutSizeViaParamType");
    PyDict_SetItemString(mod_dict,"oacCutSizeViaParamType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCutLayerViaParamType");
    PyDict_SetItemString(mod_dict,"oacCutLayerViaParamType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCutColumnsViaParamType");
    PyDict_SetItemString(mod_dict,"oacCutColumnsViaParamType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCutRowsViaParamType");
    PyDict_SetItemString(mod_dict,"oacCutRowsViaParamType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCutWidthViaParamType");
    PyDict_SetItemString(mod_dict,"oacCutWidthViaParamType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCutHeightViaParamType");
    PyDict_SetItemString(mod_dict,"oacCutHeightViaParamType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaViaParamTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaViaParamTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaViaParamTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaViaQuery
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaViaQuery_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaViaQuery_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaViaQueryObject* self = (PyoaViaQueryObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    if (is_raw) {
        PyErr_SetString(PyExc_TypeError,
            "No Constructor for pure-virtual class: oaViaQuery");
    }
    else {
        pyv_oaViaQuery* p = new pyv_oaViaQuery();
        p->pyob=self;
        self->value= (oaRegionQuery*)  p;
        return bself;
    }
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaViaQuery_tp_dealloc(PyoaViaQueryObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaViaQuery_tp_repr(PyObject *ob)
{
    PyParamoaViaQuery value;
    int convert_status=PyoaViaQuery_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[32];
    sprintf(buffer,"<oaViaQuery::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaViaQuery_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaViaQuery v1;
    PyParamoaViaQuery v2;
    int convert_status1=PyoaViaQuery_Convert(ob1,&v1);
    int convert_status2=PyoaViaQuery_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaViaQuery_Convert(PyObject* ob,PyParamoaViaQuery* result)
{
    if (ob == NULL) return 1;
    if (PyoaViaQuery_Check(ob)) {
        result->SetData( (oaViaQuery*) ((PyoaViaQueryObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaViaQuery Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaViaQuery_FromoaViaQuery(oaViaQuery* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaViaQuery_Type.tp_alloc(&PyoaViaQuery_Type,0);
        if (bself == NULL) return bself;
        PyoaViaQueryObject* self = (PyoaViaQueryObject*)bself;
        self->value = (oaRegionQuery*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaViaQuery::pyv_oaViaQuery()
 : pyob(NULL),
   oaViaQuery()
{
}

// ------------------------------------------------------------------
pyv_oaViaQuery::pyv_oaViaQuery(const oaViaQuery& p)
 : pyob(NULL),
   oaViaQuery(p)
{
}

// ------------------------------------------------------------------
void pyv_oaViaQuery::queryVia(oaVia* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"queryVia");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaViaQuery::queryVia was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaVia_FromoaVia(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaViaQuery::queryVia had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaViaQuery::endRef(oaRef* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"endRef");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaViaQuery::endRef was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaRef_FromoaRef(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaViaQuery::endRef had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaViaQuery::endRef(oaRef* p1,oaUInt4 p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"endRef");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaViaQuery::endRef was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaRef_FromoaRef(p1));
    PyTuple_SetItem(args,1,PyoaUInt4_FromoaUInt4(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaViaQuery::endRef had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaViaQuery::endRef(oaRef* p1,oaUInt4 p2,oaUInt4 p3)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"endRef");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaViaQuery::endRef was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(3);
    PyTuple_SetItem(args,0,PyoaRef_FromoaRef(p1));
    PyTuple_SetItem(args,1,PyoaUInt4_FromoaUInt4(p2));
    PyTuple_SetItem(args,2,PyoaUInt4_FromoaUInt4(p3));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaViaQuery::endRef had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
oaBoolean pyv_oaViaQuery::startRef(oaRef* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"startRef");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaViaQuery::startRef was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaRef_FromoaRef(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaViaQuery::startRef had an error.");
    }
    PyParamoaBoolean rv;
    if (PyoaBoolean_Convert(result,&rv)==0) {
        throw oaPythonException("Python Virtual Function oaBoolean::startRef has incorrect return type.");
    }
    Py_DECREF(result);
    return rv.Data();
}

// ------------------------------------------------------------------
oaBoolean pyv_oaViaQuery::startRef(oaRef* p1,oaUInt4 p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"startRef");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaViaQuery::startRef was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaRef_FromoaRef(p1));
    PyTuple_SetItem(args,1,PyoaUInt4_FromoaUInt4(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaViaQuery::startRef had an error.");
    }
    PyParamoaBoolean rv;
    if (PyoaBoolean_Convert(result,&rv)==0) {
        throw oaPythonException("Python Virtual Function oaBoolean::startRef has incorrect return type.");
    }
    Py_DECREF(result);
    return rv.Data();
}

// ------------------------------------------------------------------
oaBoolean pyv_oaViaQuery::startRef(oaRef* p1,oaUInt4 p2,oaUInt4 p3)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"startRef");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaViaQuery::startRef was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(3);
    PyTuple_SetItem(args,0,PyoaRef_FromoaRef(p1));
    PyTuple_SetItem(args,1,PyoaUInt4_FromoaUInt4(p2));
    PyTuple_SetItem(args,2,PyoaUInt4_FromoaUInt4(p3));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaViaQuery::startRef had an error.");
    }
    PyParamoaBoolean rv;
    if (PyoaBoolean_Convert(result,&rv)==0) {
        throw oaPythonException("Python Virtual Function oaBoolean::startRef has incorrect return type.");
    }
    Py_DECREF(result);
    return rv.Data();
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaQuery_getLayerNum1_doc[] = 
"Class: oaViaQuery, Function: getLayerNum1\n"
"  Paramegers: ()\n"
"    Calls: oaLayerNum getLayerNum1() const\n"
"    Signature: getLayerNum1|simple-oaLayerNum|\n"
"    BrowseData: 1\n"
"    This function returns the first layer number associated with this via query.\n"
;

static PyObject*
oaViaQuery_getLayerNum1(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaQuery data;
    int convert_status=PyoaViaQuery_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaQueryObject* self=(PyoaViaQueryObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaLayerNum result= (data.DataCall()->getLayerNum1());
        return PyoaLayerNum_FromoaLayerNum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaQuery_getLayerNum2_doc[] = 
"Class: oaViaQuery, Function: getLayerNum2\n"
"  Paramegers: ()\n"
"    Calls: oaLayerNum getLayerNum2() const\n"
"    Signature: getLayerNum2|simple-oaLayerNum|\n"
"    BrowseData: 1\n"
"    This function returns the second layer number associated with this via query.\n"
;

static PyObject*
oaViaQuery_getLayerNum2(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaQuery data;
    int convert_status=PyoaViaQuery_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaQueryObject* self=(PyoaViaQueryObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaLayerNum result= (data.DataCall()->getLayerNum2());
        return PyoaLayerNum_FromoaLayerNum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaQuery_query_doc[] = 
"Class: oaViaQuery, Function: query\n"
"  Paramegers: (oaDesign,oaBox)\n"
"    Calls: void query(oaDesign* topDesign,const oaBox& region)\n"
"    Signature: query|void-void|ptr-oaDesign,cref-oaBox,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating vias in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    The specified design for performing object querying\n"
"    region\n"
"    The region of interest\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to end the querying\n"
"  Paramegers: (oaDesign,oaBox,oaDist)\n"
"    Calls: void query(oaDesign* topDesign,const oaBox& region,oaDist filterSize)\n"
"    Signature: query|void-void|ptr-oaDesign,cref-oaBox,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating vias in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    The specified design for performing object querying\n"
"    region\n"
"    The region of interest\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to end the querying\n"
"  Paramegers: (oaDesign,oaBox,oaDist,oaUInt4)\n"
"    Calls: void query(oaDesign* topDesign,const oaBox& region,oaDist filterSize,oaUInt4 startLevel)\n"
"    Signature: query|void-void|ptr-oaDesign,cref-oaBox,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating vias in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    The specified design for performing object querying\n"
"    region\n"
"    The region of interest\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to end the querying\n"
"  Paramegers: (oaDesign,oaBox,oaDist,oaUInt4,oaUInt4)\n"
"    Calls: void query(oaDesign* topDesign,const oaBox& region,oaDist filterSize,oaUInt4 startLevel,oaUInt4 stopLevel)\n"
"    Signature: query|void-void|ptr-oaDesign,cref-oaBox,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating vias in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    The specified design for performing object querying\n"
"    region\n"
"    The region of interest\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to end the querying\n"
"  Paramegers: (oaDesign,oaLayerNum,oaBox)\n"
"    Calls: void query(oaDesign* topDesign,oaLayerNum layerNum,const oaBox& region)\n"
"    Signature: query|void-void|ptr-oaDesign,simple-oaLayerNum,cref-oaBox,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating vias in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    layerNum\n"
"    Only query objects that have this layer number\n"
"    region\n"
"    The region of interest\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to stop the querying\n"
"  Paramegers: (oaDesign,oaLayerNum,oaBox,oaDist)\n"
"    Calls: void query(oaDesign* topDesign,oaLayerNum layerNum,const oaBox& region,oaDist filterSize)\n"
"    Signature: query|void-void|ptr-oaDesign,simple-oaLayerNum,cref-oaBox,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating vias in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    layerNum\n"
"    Only query objects that have this layer number\n"
"    region\n"
"    The region of interest\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to stop the querying\n"
"  Paramegers: (oaDesign,oaLayerNum,oaBox,oaDist,oaUInt4)\n"
"    Calls: void query(oaDesign* topDesign,oaLayerNum layerNum,const oaBox& region,oaDist filterSize,oaUInt4 startLevel)\n"
"    Signature: query|void-void|ptr-oaDesign,simple-oaLayerNum,cref-oaBox,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating vias in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    layerNum\n"
"    Only query objects that have this layer number\n"
"    region\n"
"    The region of interest\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to stop the querying\n"
"  Paramegers: (oaDesign,oaLayerNum,oaBox,oaDist,oaUInt4,oaUInt4)\n"
"    Calls: void query(oaDesign* topDesign,oaLayerNum layerNum,const oaBox& region,oaDist filterSize,oaUInt4 startLevel,oaUInt4 stopLevel)\n"
"    Signature: query|void-void|ptr-oaDesign,simple-oaLayerNum,cref-oaBox,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating vias in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    layerNum\n"
"    Only query objects that have this layer number\n"
"    region\n"
"    The region of interest\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to stop the querying\n"
"  Paramegers: (oaDesign,oaLayerNum,oaLayerNum,oaBox)\n"
"    Calls: void query(oaDesign* topDesign,oaLayerNum layerNum1,oaLayerNum layerNum2,const oaBox& region)\n"
"    Signature: query|void-void|ptr-oaDesign,simple-oaLayerNum,simple-oaLayerNum,cref-oaBox,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating vias in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    layerNum1\n"
"    Only query objects that have both of the specified layer numbers\n"
"    layerNum2\n"
"    Only query objects that have both of the specified layer numbers\n"
"    region\n"
"    The region of interest\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to stop the querying\n"
"  Paramegers: (oaDesign,oaLayerNum,oaLayerNum,oaBox,oaDist)\n"
"    Calls: void query(oaDesign* topDesign,oaLayerNum layerNum1,oaLayerNum layerNum2,const oaBox& region,oaDist filterSize)\n"
"    Signature: query|void-void|ptr-oaDesign,simple-oaLayerNum,simple-oaLayerNum,cref-oaBox,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating vias in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    layerNum1\n"
"    Only query objects that have both of the specified layer numbers\n"
"    layerNum2\n"
"    Only query objects that have both of the specified layer numbers\n"
"    region\n"
"    The region of interest\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to stop the querying\n"
"  Paramegers: (oaDesign,oaLayerNum,oaLayerNum,oaBox,oaDist,oaUInt4)\n"
"    Calls: void query(oaDesign* topDesign,oaLayerNum layerNum1,oaLayerNum layerNum2,const oaBox& region,oaDist filterSize,oaUInt4 startLevel)\n"
"    Signature: query|void-void|ptr-oaDesign,simple-oaLayerNum,simple-oaLayerNum,cref-oaBox,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating vias in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    layerNum1\n"
"    Only query objects that have both of the specified layer numbers\n"
"    layerNum2\n"
"    Only query objects that have both of the specified layer numbers\n"
"    region\n"
"    The region of interest\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to stop the querying\n"
"  Paramegers: (oaDesign,oaLayerNum,oaLayerNum,oaBox,oaDist,oaUInt4,oaUInt4)\n"
"    Calls: void query(oaDesign* topDesign,oaLayerNum layerNum1,oaLayerNum layerNum2,const oaBox& region,oaDist filterSize,oaUInt4 startLevel,oaUInt4 stopLevel)\n"
"    Signature: query|void-void|ptr-oaDesign,simple-oaLayerNum,simple-oaLayerNum,cref-oaBox,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating vias in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    layerNum1\n"
"    Only query objects that have both of the specified layer numbers\n"
"    layerNum2\n"
"    Only query objects that have both of the specified layer numbers\n"
"    region\n"
"    The region of interest\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to stop the querying\n"
"  Paramegers: (oaDesign,oaBox,oaTransform)\n"
"    Calls: void query(oaDesign* topDesign,const oaBox& region,const oaTransform& xform)\n"
"    Signature: query|void-void|ptr-oaDesign,cref-oaBox,cref-oaTransform,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating vias in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    region\n"
"    The region of interest\n"
"    xform\n"
"    The transform that is currently applied to the design\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to end the querying\n"
"  Paramegers: (oaDesign,oaBox,oaTransform,oaDist)\n"
"    Calls: void query(oaDesign* topDesign,const oaBox& region,const oaTransform& xform,oaDist filterSize)\n"
"    Signature: query|void-void|ptr-oaDesign,cref-oaBox,cref-oaTransform,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating vias in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    region\n"
"    The region of interest\n"
"    xform\n"
"    The transform that is currently applied to the design\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to end the querying\n"
"  Paramegers: (oaDesign,oaBox,oaTransform,oaDist,oaUInt4)\n"
"    Calls: void query(oaDesign* topDesign,const oaBox& region,const oaTransform& xform,oaDist filterSize,oaUInt4 startLevel)\n"
"    Signature: query|void-void|ptr-oaDesign,cref-oaBox,cref-oaTransform,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating vias in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    region\n"
"    The region of interest\n"
"    xform\n"
"    The transform that is currently applied to the design\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to end the querying\n"
"  Paramegers: (oaDesign,oaBox,oaTransform,oaDist,oaUInt4,oaUInt4)\n"
"    Calls: void query(oaDesign* topDesign,const oaBox& region,const oaTransform& xform,oaDist filterSize,oaUInt4 startLevel,oaUInt4 stopLevel)\n"
"    Signature: query|void-void|ptr-oaDesign,cref-oaBox,cref-oaTransform,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating vias in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    region\n"
"    The region of interest\n"
"    xform\n"
"    The transform that is currently applied to the design\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to end the querying\n"
"  Paramegers: (oaDesign,oaLayerNum,oaBox,oaTransform)\n"
"    Calls: void query(oaDesign* topDesign,oaLayerNum layerNum,const oaBox& region,const oaTransform& xform)\n"
"    Signature: query|void-void|ptr-oaDesign,simple-oaLayerNum,cref-oaBox,cref-oaTransform,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating vias in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    layerNum\n"
"    Only query objects that have this layer number\n"
"    region\n"
"    The region of interest\n"
"    xform\n"
"    The current transform that is applied to the design\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to stop the querying\n"
"  Paramegers: (oaDesign,oaLayerNum,oaBox,oaTransform,oaDist)\n"
"    Calls: void query(oaDesign* topDesign,oaLayerNum layerNum,const oaBox& region,const oaTransform& xform,oaDist filterSize)\n"
"    Signature: query|void-void|ptr-oaDesign,simple-oaLayerNum,cref-oaBox,cref-oaTransform,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating vias in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    layerNum\n"
"    Only query objects that have this layer number\n"
"    region\n"
"    The region of interest\n"
"    xform\n"
"    The current transform that is applied to the design\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to stop the querying\n"
"  Paramegers: (oaDesign,oaLayerNum,oaBox,oaTransform,oaDist,oaUInt4)\n"
"    Calls: void query(oaDesign* topDesign,oaLayerNum layerNum,const oaBox& region,const oaTransform& xform,oaDist filterSize,oaUInt4 startLevel)\n"
"    Signature: query|void-void|ptr-oaDesign,simple-oaLayerNum,cref-oaBox,cref-oaTransform,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating vias in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    layerNum\n"
"    Only query objects that have this layer number\n"
"    region\n"
"    The region of interest\n"
"    xform\n"
"    The current transform that is applied to the design\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to stop the querying\n"
"  Paramegers: (oaDesign,oaLayerNum,oaBox,oaTransform,oaDist,oaUInt4,oaUInt4)\n"
"    Calls: void query(oaDesign* topDesign,oaLayerNum layerNum,const oaBox& region,const oaTransform& xform,oaDist filterSize,oaUInt4 startLevel,oaUInt4 stopLevel)\n"
"    Signature: query|void-void|ptr-oaDesign,simple-oaLayerNum,cref-oaBox,cref-oaTransform,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating vias in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    layerNum\n"
"    Only query objects that have this layer number\n"
"    region\n"
"    The region of interest\n"
"    xform\n"
"    The current transform that is applied to the design\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to stop the querying\n"
"  Paramegers: (oaDesign,oaLayerNum,oaLayerNum,oaBox,oaTransform)\n"
"    Calls: void query(oaDesign* topDesign,oaLayerNum layerNum1,oaLayerNum layerNum2,const oaBox& region,const oaTransform& xform)\n"
"    Signature: query|void-void|ptr-oaDesign,simple-oaLayerNum,simple-oaLayerNum,cref-oaBox,cref-oaTransform,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating vias in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    layerNum1\n"
"    Only query objects that have both of the specified layer numbers\n"
"    layerNum2\n"
"    Only query objects that have both of the specified layer numbers\n"
"    region\n"
"    The region of interest\n"
"    xform\n"
"    The current transform that is applied to the design\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to stop the querying\n"
"  Paramegers: (oaDesign,oaLayerNum,oaLayerNum,oaBox,oaTransform,oaDist)\n"
"    Calls: void query(oaDesign* topDesign,oaLayerNum layerNum1,oaLayerNum layerNum2,const oaBox& region,const oaTransform& xform,oaDist filterSize)\n"
"    Signature: query|void-void|ptr-oaDesign,simple-oaLayerNum,simple-oaLayerNum,cref-oaBox,cref-oaTransform,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating vias in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    layerNum1\n"
"    Only query objects that have both of the specified layer numbers\n"
"    layerNum2\n"
"    Only query objects that have both of the specified layer numbers\n"
"    region\n"
"    The region of interest\n"
"    xform\n"
"    The current transform that is applied to the design\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to stop the querying\n"
"  Paramegers: (oaDesign,oaLayerNum,oaLayerNum,oaBox,oaTransform,oaDist,oaUInt4)\n"
"    Calls: void query(oaDesign* topDesign,oaLayerNum layerNum1,oaLayerNum layerNum2,const oaBox& region,const oaTransform& xform,oaDist filterSize,oaUInt4 startLevel)\n"
"    Signature: query|void-void|ptr-oaDesign,simple-oaLayerNum,simple-oaLayerNum,cref-oaBox,cref-oaTransform,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating vias in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    layerNum1\n"
"    Only query objects that have both of the specified layer numbers\n"
"    layerNum2\n"
"    Only query objects that have both of the specified layer numbers\n"
"    region\n"
"    The region of interest\n"
"    xform\n"
"    The current transform that is applied to the design\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to stop the querying\n"
"  Paramegers: (oaDesign,oaLayerNum,oaLayerNum,oaBox,oaTransform,oaDist,oaUInt4,oaUInt4)\n"
"    Calls: void query(oaDesign* topDesign,oaLayerNum layerNum1,oaLayerNum layerNum2,const oaBox& region,const oaTransform& xform,oaDist filterSize,oaUInt4 startLevel,oaUInt4 stopLevel)\n"
"    Signature: query|void-void|ptr-oaDesign,simple-oaLayerNum,simple-oaLayerNum,cref-oaBox,cref-oaTransform,simple-oaDist,simple-oaUInt4,simple-oaUInt4,\n"
"    This function begins the query process to start generating vias in the specified region of the specified design hierarchy.\n"
"    topDesign\n"
"    Pointer to the top design\n"
"    layerNum1\n"
"    Only query objects that have both of the specified layer numbers\n"
"    layerNum2\n"
"    Only query objects that have both of the specified layer numbers\n"
"    region\n"
"    The region of interest\n"
"    xform\n"
"    The current transform that is applied to the design\n"
"    filterSize\n"
"    Only query objects whose size is equal to or larger than filterSize\n"
"    startLevel\n"
"    The level of block hierarchy to start the querying\n"
"    stopLevel\n"
"    The level of block hierarchy to stop the querying\n"
;

static PyObject*
oaViaQuery_query(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaQuery data;
    int convert_status=PyoaViaQuery_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaQueryObject* self=(PyoaViaQueryObject*)ob;

    // Case: (oaDesign,oaBox)
    {
        PyParamoaDesign p1;
        PyParamoaBox p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaBox_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaBox,oaDist)
    {
        PyParamoaDesign p1;
        PyParamoaBox p2;
        PyParamoaDist p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaBox_Convert,&p2,
              &PyoaDist_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaBox,oaDist,oaUInt4)
    {
        PyParamoaDesign p1;
        PyParamoaBox p2;
        PyParamoaDist p3;
        PyParamoaUInt4 p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaBox_Convert,&p2,
              &PyoaDist_Convert,&p3,
              &PyoaUInt4_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaBox,oaDist,oaUInt4,oaUInt4)
    {
        PyParamoaDesign p1;
        PyParamoaBox p2;
        PyParamoaDist p3;
        PyParamoaUInt4 p4;
        PyParamoaUInt4 p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaBox_Convert,&p2,
              &PyoaDist_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaUInt4_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaLayerNum,oaBox)
    {
        PyParamoaDesign p1;
        PyParamoaLayerNum p2;
        PyParamoaBox p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaBox_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaLayerNum,oaBox,oaDist)
    {
        PyParamoaDesign p1;
        PyParamoaLayerNum p2;
        PyParamoaBox p3;
        PyParamoaDist p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaBox_Convert,&p3,
              &PyoaDist_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaLayerNum,oaBox,oaDist,oaUInt4)
    {
        PyParamoaDesign p1;
        PyParamoaLayerNum p2;
        PyParamoaBox p3;
        PyParamoaDist p4;
        PyParamoaUInt4 p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaBox_Convert,&p3,
              &PyoaDist_Convert,&p4,
              &PyoaUInt4_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaLayerNum,oaBox,oaDist,oaUInt4,oaUInt4)
    {
        PyParamoaDesign p1;
        PyParamoaLayerNum p2;
        PyParamoaBox p3;
        PyParamoaDist p4;
        PyParamoaUInt4 p5;
        PyParamoaUInt4 p6;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaBox_Convert,&p3,
              &PyoaDist_Convert,&p4,
              &PyoaUInt4_Convert,&p5,
              &PyoaUInt4_Convert,&p6)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaLayerNum,oaLayerNum,oaBox)
    {
        PyParamoaDesign p1;
        PyParamoaLayerNum p2;
        PyParamoaLayerNum p3;
        PyParamoaBox p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaLayerNum_Convert,&p3,
              &PyoaBox_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaLayerNum,oaLayerNum,oaBox,oaDist)
    {
        PyParamoaDesign p1;
        PyParamoaLayerNum p2;
        PyParamoaLayerNum p3;
        PyParamoaBox p4;
        PyParamoaDist p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaLayerNum_Convert,&p3,
              &PyoaBox_Convert,&p4,
              &PyoaDist_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaLayerNum,oaLayerNum,oaBox,oaDist,oaUInt4)
    {
        PyParamoaDesign p1;
        PyParamoaLayerNum p2;
        PyParamoaLayerNum p3;
        PyParamoaBox p4;
        PyParamoaDist p5;
        PyParamoaUInt4 p6;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaLayerNum_Convert,&p3,
              &PyoaBox_Convert,&p4,
              &PyoaDist_Convert,&p5,
              &PyoaUInt4_Convert,&p6)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaLayerNum,oaLayerNum,oaBox,oaDist,oaUInt4,oaUInt4)
    {
        PyParamoaDesign p1;
        PyParamoaLayerNum p2;
        PyParamoaLayerNum p3;
        PyParamoaBox p4;
        PyParamoaDist p5;
        PyParamoaUInt4 p6;
        PyParamoaUInt4 p7;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaLayerNum_Convert,&p3,
              &PyoaBox_Convert,&p4,
              &PyoaDist_Convert,&p5,
              &PyoaUInt4_Convert,&p6,
              &PyoaUInt4_Convert,&p7)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaBox,oaTransform)
    {
        PyParamoaDesign p1;
        PyParamoaBox p2;
        PyParamoaTransform p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaBox_Convert,&p2,
              &PyoaTransform_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaBox,oaTransform,oaDist)
    {
        PyParamoaDesign p1;
        PyParamoaBox p2;
        PyParamoaTransform p3;
        PyParamoaDist p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaBox_Convert,&p2,
              &PyoaTransform_Convert,&p3,
              &PyoaDist_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaBox,oaTransform,oaDist,oaUInt4)
    {
        PyParamoaDesign p1;
        PyParamoaBox p2;
        PyParamoaTransform p3;
        PyParamoaDist p4;
        PyParamoaUInt4 p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaBox_Convert,&p2,
              &PyoaTransform_Convert,&p3,
              &PyoaDist_Convert,&p4,
              &PyoaUInt4_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaBox,oaTransform,oaDist,oaUInt4,oaUInt4)
    {
        PyParamoaDesign p1;
        PyParamoaBox p2;
        PyParamoaTransform p3;
        PyParamoaDist p4;
        PyParamoaUInt4 p5;
        PyParamoaUInt4 p6;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaBox_Convert,&p2,
              &PyoaTransform_Convert,&p3,
              &PyoaDist_Convert,&p4,
              &PyoaUInt4_Convert,&p5,
              &PyoaUInt4_Convert,&p6)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaLayerNum,oaBox,oaTransform)
    {
        PyParamoaDesign p1;
        PyParamoaLayerNum p2;
        PyParamoaBox p3;
        PyParamoaTransform p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaBox_Convert,&p3,
              &PyoaTransform_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaLayerNum,oaBox,oaTransform,oaDist)
    {
        PyParamoaDesign p1;
        PyParamoaLayerNum p2;
        PyParamoaBox p3;
        PyParamoaTransform p4;
        PyParamoaDist p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaBox_Convert,&p3,
              &PyoaTransform_Convert,&p4,
              &PyoaDist_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaLayerNum,oaBox,oaTransform,oaDist,oaUInt4)
    {
        PyParamoaDesign p1;
        PyParamoaLayerNum p2;
        PyParamoaBox p3;
        PyParamoaTransform p4;
        PyParamoaDist p5;
        PyParamoaUInt4 p6;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaBox_Convert,&p3,
              &PyoaTransform_Convert,&p4,
              &PyoaDist_Convert,&p5,
              &PyoaUInt4_Convert,&p6)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaLayerNum,oaBox,oaTransform,oaDist,oaUInt4,oaUInt4)
    {
        PyParamoaDesign p1;
        PyParamoaLayerNum p2;
        PyParamoaBox p3;
        PyParamoaTransform p4;
        PyParamoaDist p5;
        PyParamoaUInt4 p6;
        PyParamoaUInt4 p7;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaBox_Convert,&p3,
              &PyoaTransform_Convert,&p4,
              &PyoaDist_Convert,&p5,
              &PyoaUInt4_Convert,&p6,
              &PyoaUInt4_Convert,&p7)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaLayerNum,oaLayerNum,oaBox,oaTransform)
    {
        PyParamoaDesign p1;
        PyParamoaLayerNum p2;
        PyParamoaLayerNum p3;
        PyParamoaBox p4;
        PyParamoaTransform p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaLayerNum_Convert,&p3,
              &PyoaBox_Convert,&p4,
              &PyoaTransform_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaLayerNum,oaLayerNum,oaBox,oaTransform,oaDist)
    {
        PyParamoaDesign p1;
        PyParamoaLayerNum p2;
        PyParamoaLayerNum p3;
        PyParamoaBox p4;
        PyParamoaTransform p5;
        PyParamoaDist p6;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaLayerNum_Convert,&p3,
              &PyoaBox_Convert,&p4,
              &PyoaTransform_Convert,&p5,
              &PyoaDist_Convert,&p6)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaLayerNum,oaLayerNum,oaBox,oaTransform,oaDist,oaUInt4)
    {
        PyParamoaDesign p1;
        PyParamoaLayerNum p2;
        PyParamoaLayerNum p3;
        PyParamoaBox p4;
        PyParamoaTransform p5;
        PyParamoaDist p6;
        PyParamoaUInt4 p7;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaLayerNum_Convert,&p3,
              &PyoaBox_Convert,&p4,
              &PyoaTransform_Convert,&p5,
              &PyoaDist_Convert,&p6,
              &PyoaUInt4_Convert,&p7)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaLayerNum,oaLayerNum,oaBox,oaTransform,oaDist,oaUInt4,oaUInt4)
    {
        PyParamoaDesign p1;
        PyParamoaLayerNum p2;
        PyParamoaLayerNum p3;
        PyParamoaBox p4;
        PyParamoaTransform p5;
        PyParamoaDist p6;
        PyParamoaUInt4 p7;
        PyParamoaUInt4 p8;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaLayerNum_Convert,&p3,
              &PyoaBox_Convert,&p4,
              &PyoaTransform_Convert,&p5,
              &PyoaDist_Convert,&p6,
              &PyoaUInt4_Convert,&p7,
              &PyoaUInt4_Convert,&p8)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->query(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaViaQuery, function: query, Choices are:\n"
        "    (oaDesign,oaBox)\n"
        "    (oaDesign,oaBox,oaDist)\n"
        "    (oaDesign,oaBox,oaDist,oaUInt4)\n"
        "    (oaDesign,oaBox,oaDist,oaUInt4,oaUInt4)\n"
        "    (oaDesign,oaLayerNum,oaBox)\n"
        "    (oaDesign,oaLayerNum,oaBox,oaDist)\n"
        "    (oaDesign,oaLayerNum,oaBox,oaDist,oaUInt4)\n"
        "    (oaDesign,oaLayerNum,oaBox,oaDist,oaUInt4,oaUInt4)\n"
        "    (oaDesign,oaLayerNum,oaLayerNum,oaBox)\n"
        "    (oaDesign,oaLayerNum,oaLayerNum,oaBox,oaDist)\n"
        "    (oaDesign,oaLayerNum,oaLayerNum,oaBox,oaDist,oaUInt4)\n"
        "    (oaDesign,oaLayerNum,oaLayerNum,oaBox,oaDist,oaUInt4,oaUInt4)\n"
        "    (oaDesign,oaBox,oaTransform)\n"
        "    (oaDesign,oaBox,oaTransform,oaDist)\n"
        "    (oaDesign,oaBox,oaTransform,oaDist,oaUInt4)\n"
        "    (oaDesign,oaBox,oaTransform,oaDist,oaUInt4,oaUInt4)\n"
        "    (oaDesign,oaLayerNum,oaBox,oaTransform)\n"
        "    (oaDesign,oaLayerNum,oaBox,oaTransform,oaDist)\n"
        "    (oaDesign,oaLayerNum,oaBox,oaTransform,oaDist,oaUInt4)\n"
        "    (oaDesign,oaLayerNum,oaBox,oaTransform,oaDist,oaUInt4,oaUInt4)\n"
        "    (oaDesign,oaLayerNum,oaLayerNum,oaBox,oaTransform)\n"
        "    (oaDesign,oaLayerNum,oaLayerNum,oaBox,oaTransform,oaDist)\n"
        "    (oaDesign,oaLayerNum,oaLayerNum,oaBox,oaTransform,oaDist,oaUInt4)\n"
        "    (oaDesign,oaLayerNum,oaLayerNum,oaBox,oaTransform,oaDist,oaUInt4,oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaQuery_queryVia_doc[] = 
"Class: oaViaQuery, Function: queryVia\n"
"  Paramegers: (oaVia)\n"
"    Calls: virtual void queryVia(oaVia* via)\n"
"    Signature: queryVia|void-void|ptr-oaVia,\n"
"    This function processes each result of the via query.\n"
"    via\n"
"    Pointer to an oaVia found during querying\n"
;

static PyObject*
oaViaQuery_queryVia(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaQuery data;
    int convert_status=PyoaViaQuery_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaQueryObject* self=(PyoaViaQueryObject*)ob;

    PyParamoaVia p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaVia_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        PyErr_SetString(PyExc_TypeError,
            "Call to Pure-Virtual Function class: oaViaQuery, function: queryVia");
            return NULL;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaViaQuery_assign_doc[] = 
"Class: oaViaQuery, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaViaQuery_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaViaQuery data;
  int convert_status=PyoaViaQuery_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaViaQuery p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaViaQuery_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaViaQuery_methodlist[] = {
    {"getLayerNum1",(PyCFunction)oaViaQuery_getLayerNum1,METH_VARARGS,oaViaQuery_getLayerNum1_doc},
    {"getLayerNum2",(PyCFunction)oaViaQuery_getLayerNum2,METH_VARARGS,oaViaQuery_getLayerNum2_doc},
    {"query",(PyCFunction)oaViaQuery_query,METH_VARARGS,oaViaQuery_query_doc},
    {"queryVia",(PyCFunction)oaViaQuery_queryVia,METH_VARARGS,oaViaQuery_queryVia_doc},
    {"assign",(PyCFunction)oaViaQuery_tp_assign,METH_VARARGS,oaViaQuery_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaQuery_doc[] = 
"Class: oaViaQuery\n"
"  The oaViaQuery class implements functionality to query a specified region in a design hierarchy and quickly return all oaVia that overlap the region.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaViaQuery()\n"
"    Signature: oaViaQuery||\n"
"    This is the constructor for the oaViaQuery class.\n"
"  Paramegers: (oaViaQuery)\n"
"    Calls: (const oaViaQuery&)\n"
"    Signature: oaViaQuery||cref-oaViaQuery,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaViaQuery_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaViaQuery",
    sizeof(PyoaViaQueryObject),
    0,
    (destructor)oaViaQuery_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaViaQuery_tp_compare,	/* tp_compare */
    (reprfunc)oaViaQuery_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaViaQuery_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaViaQuery_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaRegionQuery_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaViaQuery_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaViaQuery_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaViaQuery_Type)<0) {
      printf("** PyType_Ready failed for: oaViaQuery\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaViaQuery",
           (PyObject*)(&PyoaViaQuery_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaViaQuery\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaViaSpec
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaViaSpec_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaViaSpec_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaViaSpecObject* self = (PyoaViaSpecObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaViaSpec)
    {
        PyParamoaViaSpec p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaViaSpec_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaViaSpec, Choices are:\n"
        "    (oaViaSpec)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaViaSpec_tp_dealloc(PyoaViaSpecObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaViaSpec_tp_repr(PyObject *ob)
{
    PyParamoaViaSpec value;
    int convert_status=PyoaViaSpec_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[31];
    sprintf(buffer,"<oaViaSpec::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaViaSpec_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaViaSpec v1;
    PyParamoaViaSpec v2;
    int convert_status1=PyoaViaSpec_Convert(ob1,&v1);
    int convert_status2=PyoaViaSpec_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaViaSpec_Convert(PyObject* ob,PyParamoaViaSpec* result)
{
    if (ob == NULL) return 1;
    if (PyoaViaSpec_Check(ob)) {
        result->SetData( (oaViaSpec**) ((PyoaViaSpecObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaViaSpec Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaViaSpec_FromoaViaSpec(oaViaSpec** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaViaSpec* data=*value;
        PyObject* bself = PyoaViaSpec_Type.tp_alloc(&PyoaViaSpec_Type,0);
        if (bself == NULL) return bself;
        PyoaViaSpecObject* self = (PyoaViaSpecObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaViaSpec_FromoaViaSpec(oaViaSpec* data)
{
    if (data) {
       PyObject* bself = PyoaViaSpec_Type.tp_alloc(&PyoaViaSpec_Type,0);
       if (bself == NULL) return bself;
       PyoaViaSpecObject* self = (PyoaViaSpecObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaSpec_destroy_doc[] = 
"Class: oaViaSpec, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function destroys this viaSpec, removing it from the technology database and destroying its associated values.\n"
;

static PyObject*
oaViaSpec_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaSpec data;
    int convert_status=PyoaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaSpecObject* self=(PyoaViaSpecObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaSpec_getDefaultValue_doc[] = 
"Class: oaViaSpec, Function: getDefaultValue\n"
"  Paramegers: ()\n"
"    Calls: oaViaDefArrayValue* getDefaultValue() const\n"
"    Signature: getDefaultValue|ptr-oaViaDefArrayValue|\n"
"    BrowseData: 1\n"
"    This function returns the default list of valid viaDefs associated with this viaSpec.\n"
;

static PyObject*
oaViaSpec_getDefaultValue(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaSpec data;
    int convert_status=PyoaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaSpecObject* self=(PyoaViaSpecObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaViaDefArrayValuep result= (data.DataCall()->getDefaultValue());
        return PyoaViaDefArrayValue_FromoaViaDefArrayValue(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaSpec_getLayer1_doc[] = 
"Class: oaViaSpec, Function: getLayer1\n"
"  Paramegers: ()\n"
"    Calls: oaPhysicalLayer* getLayer1() const\n"
"    Signature: getLayer1|ptr-oaPhysicalLayer|\n"
"    BrowseData: 1\n"
"    This function returns the first layer associated with this viaSpec.\n"
"    To get the layer1 number associated with this viaSpec even if the tech database containing the layer is unbound, refer to getLayer1Num .\n"
;

static PyObject*
oaViaSpec_getLayer1(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaSpec data;
    int convert_status=PyoaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaSpecObject* self=(PyoaViaSpecObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaPhysicalLayerp result= (data.DataCall()->getLayer1());
        return PyoaPhysicalLayer_FromoaPhysicalLayer(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaSpec_getLayer1Num_doc[] = 
"Class: oaViaSpec, Function: getLayer1Num\n"
"  Paramegers: ()\n"
"    Calls: oaLayerNum getLayer1Num() const\n"
"    Signature: getLayer1Num|simple-oaLayerNum|\n"
"    BrowseData: 1\n"
"    oaViaSpec::getLayer1Num\n"
"    This function returns the layer1 number of this viaSpec object even if the tech database containing the layer is unbound.\n"
;

static PyObject*
oaViaSpec_getLayer1Num(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaSpec data;
    int convert_status=PyoaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaSpecObject* self=(PyoaViaSpecObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaLayerNum result= (data.DataCall()->getLayer1Num());
        return PyoaLayerNum_FromoaLayerNum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaSpec_getLayer2_doc[] = 
"Class: oaViaSpec, Function: getLayer2\n"
"  Paramegers: ()\n"
"    Calls: oaPhysicalLayer* getLayer2() const\n"
"    Signature: getLayer2|ptr-oaPhysicalLayer|\n"
"    BrowseData: 1\n"
"    This function returns the second layer associated with this viaSpec.\n"
"    To get the layer1 number associated with this viaSpec even if the tech database containing the layer is unbound, refer to getLayer2Num .\n"
;

static PyObject*
oaViaSpec_getLayer2(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaSpec data;
    int convert_status=PyoaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaSpecObject* self=(PyoaViaSpecObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaPhysicalLayerp result= (data.DataCall()->getLayer2());
        return PyoaPhysicalLayer_FromoaPhysicalLayer(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaSpec_getLayer2Num_doc[] = 
"Class: oaViaSpec, Function: getLayer2Num\n"
"  Paramegers: ()\n"
"    Calls: oaLayerNum getLayer2Num() const\n"
"    Signature: getLayer2Num|simple-oaLayerNum|\n"
"    BrowseData: 1\n"
"    oaViaSpec::getLayer2Num\n"
"    This function returns the layer2 number of this viaSpec object even if the tech database containing the layer is unbound.\n"
"    Todo\n"
"    Add any real throws when implemented.\n"
;

static PyObject*
oaViaSpec_getLayer2Num(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaSpec data;
    int convert_status=PyoaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaSpecObject* self=(PyoaViaSpecObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaLayerNum result= (data.DataCall()->getLayer2Num());
        return PyoaLayerNum_FromoaLayerNum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaSpec_getValue_doc[] = 
"Class: oaViaSpec, Function: getValue\n"
"  Paramegers: ()\n"
"    Calls: oaViaDef2DTblValue* getValue() const\n"
"    Signature: getValue|ptr-oaViaDef2DTblValue|\n"
"    BrowseData: 1\n"
"    This function returns the width base lookup table associated with this viaSpec.\n"
;

static PyObject*
oaViaSpec_getValue(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaSpec data;
    int convert_status=PyoaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaSpecObject* self=(PyoaViaSpecObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaViaDef2DTblValuep result= (data.DataCall()->getValue());
        return PyoaViaDef2DTblValue_FromoaViaDef2DTblValue(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaSpec_setDefaultValue_doc[] = 
"Class: oaViaSpec, Function: setDefaultValue\n"
"  Paramegers: (oaViaDefArrayValue)\n"
"    Calls: void setDefaultValue(oaViaDefArrayValue* value)\n"
"    Signature: setDefaultValue|void-void|ptr-oaViaDefArrayValue,\n"
"    This function sets the default list of valid viaDefs for this viaSpec to the specified value.\n"
"    value\n"
"    Value to set\n"
"    oacViaSpecAndViaDefNotInSameTech\n"
"    oacValueAlreadyOwned\n"
;

static PyObject*
oaViaSpec_setDefaultValue(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaSpec data;
    int convert_status=PyoaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaSpecObject* self=(PyoaViaSpecObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaDefArrayValue p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaViaDefArrayValue_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->setDefaultValue(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaSpec_setValue_doc[] = 
"Class: oaViaSpec, Function: setValue\n"
"  Paramegers: (oaViaDef2DTblValue)\n"
"    Calls: void setValue(oaViaDef2DTblValue* value)\n"
"    Signature: setValue|void-void|ptr-oaViaDef2DTblValue,\n"
"    This function sets the width based lookup table for this viaSpec to the value specified\n"
"    value\n"
"    Value to set\n"
"    oacViaSpecAndViaDefNotInSameTech\n"
"    oacValueAlreadyOwned\n"
;

static PyObject*
oaViaSpec_setValue(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViaSpec data;
    int convert_status=PyoaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViaSpecObject* self=(PyoaViaSpecObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaDef2DTblValue p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaViaDef2DTblValue_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->setValue(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaSpec_isNull_doc[] =
"Class: oaViaSpec, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaViaSpec_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaViaSpec data;
    int convert_status=PyoaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaViaSpec_assign_doc[] = 
"Class: oaViaSpec, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaViaSpec_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaViaSpec data;
  int convert_status=PyoaViaSpec_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaViaSpec p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaViaSpec_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaViaSpec_methodlist[] = {
    {"destroy",(PyCFunction)oaViaSpec_destroy,METH_VARARGS,oaViaSpec_destroy_doc},
    {"getDefaultValue",(PyCFunction)oaViaSpec_getDefaultValue,METH_VARARGS,oaViaSpec_getDefaultValue_doc},
    {"getLayer1",(PyCFunction)oaViaSpec_getLayer1,METH_VARARGS,oaViaSpec_getLayer1_doc},
    {"getLayer1Num",(PyCFunction)oaViaSpec_getLayer1Num,METH_VARARGS,oaViaSpec_getLayer1Num_doc},
    {"getLayer2",(PyCFunction)oaViaSpec_getLayer2,METH_VARARGS,oaViaSpec_getLayer2_doc},
    {"getLayer2Num",(PyCFunction)oaViaSpec_getLayer2Num,METH_VARARGS,oaViaSpec_getLayer2Num_doc},
    {"getValue",(PyCFunction)oaViaSpec_getValue,METH_VARARGS,oaViaSpec_getValue_doc},
    {"setDefaultValue",(PyCFunction)oaViaSpec_setDefaultValue,METH_VARARGS,oaViaSpec_setDefaultValue_doc},
    {"setValue",(PyCFunction)oaViaSpec_setValue,METH_VARARGS,oaViaSpec_setValue_doc},
    {"isNull",(PyCFunction)oaViaSpec_tp_isNull,METH_VARARGS,oaViaSpec_isNull_doc},
    {"assign",(PyCFunction)oaViaSpec_tp_assign,METH_VARARGS,oaViaSpec_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaSpec_doc[] = 
"Class: oaViaSpec\n"
"  The oaViaSpec class provides a mechanism for defining the valid vias that can be used when routing geometric nets. A ViaSpec object is defined for a pair of layers, and potentially has two values associated with it: a default value (an oaViaDefArrayValue , which is a default array of pointers to oaViaDefs) and a lookup table value (an oaViaDef2DTblValue , which contains an oaViaDefArrayValue for each width-based key pair in the two-dimensional table). If the width-based lookup table is available, the user should lookup the list of valid vias using the width of layer1 and the width of layer2. If this returns NULL or if no lookup table is available, the default value should be used.\n"
"  Note that the valid list of oaViaDefs pointed to in an oaViaDefArray is ordered by priority since power-via and other geometric routing applications choose the first viaDef in the array that matches the layers, size and other requirements of the via needed by the application.\n"
"  The oaViaSpec class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaViaSpec)\n"
"    Calls: (const oaViaSpec&)\n"
"    Signature: oaViaSpec||cref-oaViaSpec,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaViaSpec_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaViaSpec",
    sizeof(PyoaViaSpecObject),
    0,
    (destructor)oaViaSpec_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaViaSpec_tp_compare,	/* tp_compare */
    (reprfunc)oaViaSpec_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaViaSpec_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaViaSpec_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaTechObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaViaSpec_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViaSpec_static_create_doc[] = 
"Class: oaViaSpec, Function: create\n"
"  Paramegers: (oaPhysicalLayer,oaPhysicalLayer,oaViaDefArrayValue)\n"
"    Calls: oaViaSpec* create(const oaPhysicalLayer* layer1,const oaPhysicalLayer* layer2,oaViaDefArrayValue* defaultValue)\n"
"    Signature: create|ptr-oaViaSpec|cptr-oaPhysicalLayer,cptr-oaPhysicalLayer,ptr-oaViaDefArrayValue,\n"
"    This function creates a new viaSpec for the two layers specified. Both layer1 and layer2 must be defined in the same tech database. The viaSpec is created in the same tech databases as the specified layers. The default list of valid viaDefs is set to the value specified.\n"
"    layer1\n"
"    First layer\n"
"    layer2\n"
"    Second layer\n"
"    defaultValue\n"
"    Default list of valid viaDefs\n"
"    oacLayerNotInReferencedTech\n"
"    oacConflictingLayerNamesInTech\n"
"    oacConflictingLayerNumbersInTech\n"
"    oacLayer1Layer2NotInSameTech\n"
"    oacViaSpecAndViaDefNotInSameTech\n"
"    oacValueAlreadyOwned\n"
"    oacViaSpecExists\n"
"  Paramegers: (oaPhysicalLayer,oaPhysicalLayer,oaViaDef2DTblValue)\n"
"    Calls: oaViaSpec* create(const oaPhysicalLayer* layer1,const oaPhysicalLayer* layer2,oaViaDef2DTblValue* value)\n"
"    Signature: create|ptr-oaViaSpec|cptr-oaPhysicalLayer,cptr-oaPhysicalLayer,ptr-oaViaDef2DTblValue,\n"
"    This function creates a new viaSpec for the two layers specified. Both layer1 and layer2 must be defined in the same tech database. The viaSpec is created in the same tech databases as the specified layers.\n"
"    The width-based lookup table of valid viaDefs is set to the value specified.\n"
"    layer1\n"
"    First layer\n"
"    layer2\n"
"    Second layer\n"
"    value\n"
"    Width-based viaDef lookup table\n"
"    oacLayerNotInReferencedTech\n"
"    oacConflictingLayerNamesInTech\n"
"    oacConflictingLayerNumbersInTech\n"
"    oacLayer1Layer2NotInSameTech\n"
"    oacViaSpecAndViaDefNotInSameTech\n"
"    oacValueAlreadyOwned\n"
"    oacViaSpecExists\n"
"  Paramegers: (oaPhysicalLayer,oaPhysicalLayer,oaViaDefArrayValue,oaViaDef2DTblValue)\n"
"    Calls: oaViaSpec* create(const oaPhysicalLayer* layer1,const oaPhysicalLayer* layer2,oaViaDefArrayValue* defaultValue,oaViaDef2DTblValue* value)\n"
"    Signature: create|ptr-oaViaSpec|cptr-oaPhysicalLayer,cptr-oaPhysicalLayer,ptr-oaViaDefArrayValue,ptr-oaViaDef2DTblValue,\n"
"    This function creates a new viaSpec for the two layers specified. Both layer1 and layer2 must be defined in the same tech database. The viaSpec is created in the same tech databases as the specified layers.\n"
"    The default list, and the width-based lookup table of valid viaDefs, are set to the values specified.\n"
"    layer1\n"
"    First layer\n"
"    layer2\n"
"    Second layer\n"
"    defaultValue\n"
"    Default list of valid viaDefs\n"
"    value\n"
"    Width based viaDef lookup table\n"
"    oacLayerNotInReferencedTech\n"
"    oacConflictingLayerNamesInTech\n"
"    oacConflictingLayerNumbersInTech\n"
"    oacLayer1Layer2NotInSameTech\n"
"    oacViaSpecAndViaDefNotInSameTech\n"
"    oacValueAlreadyOwned\n"
"    oacViaSpecExists\n"
"  Paramegers: (oaTech,oaPhysicalLayer,oaPhysicalLayer,oaViaDefArrayValue)\n"
"    Calls: oaViaSpec* create(oaTech* tech,const oaPhysicalLayer* layer1,const oaPhysicalLayer* layer2,oaViaDefArrayValue* defaultValue)\n"
"    Signature: create|ptr-oaViaSpec|ptr-oaTech,cptr-oaPhysicalLayer,cptr-oaPhysicalLayer,ptr-oaViaDefArrayValue,\n"
"    This function creates a viaSpec object with the specified attributes in the specified tech database. layer1 and layer2 can be in different tech databases, but those databases must be in the graph of techs rooted at the tech in which the viaSpec will be created. Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    Exceptions are thrown if the viaSpec of the given two layers already exists or if the value is already owned.\n"
"    tech\n"
"    Technology database in which to create the viaSpec object\n"
"    layer1\n"
"    The first layer for creating the viaSpec\n"
"    layer2\n"
"    The second layer for creating the viaSpec\n"
"    defaultValue\n"
"    Default list of valid viaDefs\n"
"    oacLayerNotInReferencedTech\n"
"    oacConflictingLayerNamesInTech\n"
"    oacConflictingLayerNumbersInTech\n"
"    oacViaSpecAndViaDefNotInSameTech\n"
"    oacValueAlreadyOwned\n"
"    oacViaSpecExists\n"
"  Paramegers: (oaTech,oaPhysicalLayer,oaPhysicalLayer,oaViaDef2DTblValue)\n"
"    Calls: oaViaSpec* create(oaTech* tech,const oaPhysicalLayer* layer1,const oaPhysicalLayer* layer2,oaViaDef2DTblValue* value)\n"
"    Signature: create|ptr-oaViaSpec|ptr-oaTech,cptr-oaPhysicalLayer,cptr-oaPhysicalLayer,ptr-oaViaDef2DTblValue,\n"
"    This function creates a viaSpec object with the specified attributes in the specified tech database. layer1 and layer2 can be in different tech databases, but those databases must be in the graph of techs rooted at the tech in which the viaSpec will be created. Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases\n"
"    Exceptions are thrown if the viaSpec of the given two layers already exists or if the value is already owned.\n"
"    tech\n"
"    Technology database in which to create the viaSpec object\n"
"    layer1\n"
"    First layer for creating the viaSpec\n"
"    layer2\n"
"    Second layer for creating the viaSpec\n"
"    value\n"
"    Width-based viaDef lookup table\n"
"    oacLayerNotInReferencedTech\n"
"    oacConflictingLayerNamesInTech\n"
"    oacConflictingLayerNumbersInTech\n"
"    oacViaSpecAndViaDefNotInSameTech\n"
"    oacValueAlreadyOwned\n"
"    oacViaSpecExists\n"
"  Paramegers: (oaTech,oaPhysicalLayer,oaPhysicalLayer,oaViaDefArrayValue,oaViaDef2DTblValue)\n"
"    Calls: oaViaSpec* create(oaTech* tech,const oaPhysicalLayer* layer1,const oaPhysicalLayer* layer2,oaViaDefArrayValue* defaultValue,oaViaDef2DTblValue* value)\n"
"    Signature: create|ptr-oaViaSpec|ptr-oaTech,cptr-oaPhysicalLayer,cptr-oaPhysicalLayer,ptr-oaViaDefArrayValue,ptr-oaViaDef2DTblValue,\n"
"    This function creates an viaSpec object with the specified attributes in the specified tech database. layer1 and layer2 can be in different tech databases, but those databases must be in the graph of techs rooted at the tech in which the viaSpec will be created. Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    Exceptions are thrown if the viaSpec of the given two layers already exists or if the value is already owned.\n"
"    tech\n"
"    Technology database in which to create the viaSpec object\n"
"    layer1\n"
"    First layer for creating the viaSpec\n"
"    layer2\n"
"    Second layer for creating the viaSpec\n"
"    defaultValue\n"
"    Default list of valid viaDefs\n"
"    value\n"
"    Width-based viaDef lookup table\n"
"    oacLayerNotInReferencedTech\n"
"    oacConflictingLayerNamesInTech\n"
"    oacConflictingLayerNumbersInTech\n"
"    oacViaSpecAndViaDefNotInSameTech\n"
"    oacValueAlreadyOwned\n"
"    oacViaSpecExists\n"
;

static PyObject*
oaViaSpec_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaPhysicalLayer,oaPhysicalLayer,oaViaDefArrayValue)
    {
        PyParamoaPhysicalLayer p1;
        PyParamoaPhysicalLayer p2;
        PyParamoaViaDefArrayValue p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaPhysicalLayer_Convert,&p1,
              &PyoaPhysicalLayer_Convert,&p2,
              &PyoaViaDefArrayValue_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            if (!PyValidateDbObject(p3.Data(),3)) return NULL;
            oaViaSpecp result= (oaViaSpec::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaViaSpec_FromoaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaPhysicalLayer,oaPhysicalLayer,oaViaDef2DTblValue)
    {
        PyParamoaPhysicalLayer p1;
        PyParamoaPhysicalLayer p2;
        PyParamoaViaDef2DTblValue p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaPhysicalLayer_Convert,&p1,
              &PyoaPhysicalLayer_Convert,&p2,
              &PyoaViaDef2DTblValue_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            if (!PyValidateDbObject(p3.Data(),3)) return NULL;
            oaViaSpecp result= (oaViaSpec::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaViaSpec_FromoaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaPhysicalLayer,oaPhysicalLayer,oaViaDefArrayValue,oaViaDef2DTblValue)
    {
        PyParamoaPhysicalLayer p1;
        PyParamoaPhysicalLayer p2;
        PyParamoaViaDefArrayValue p3;
        PyParamoaViaDef2DTblValue p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaPhysicalLayer_Convert,&p1,
              &PyoaPhysicalLayer_Convert,&p2,
              &PyoaViaDefArrayValue_Convert,&p3,
              &PyoaViaDef2DTblValue_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            if (!PyValidateDbObject(p3.Data(),3)) return NULL;
            if (!PyValidateDbObject(p4.Data(),4)) return NULL;
            oaViaSpecp result= (oaViaSpec::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaViaSpec_FromoaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTech,oaPhysicalLayer,oaPhysicalLayer,oaViaDefArrayValue)
    {
        PyParamoaTech p1;
        PyParamoaPhysicalLayer p2;
        PyParamoaPhysicalLayer p3;
        PyParamoaViaDefArrayValue p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaPhysicalLayer_Convert,&p2,
              &PyoaPhysicalLayer_Convert,&p3,
              &PyoaViaDefArrayValue_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            if (!PyValidateDbObject(p3.Data(),3)) return NULL;
            if (!PyValidateDbObject(p4.Data(),4)) return NULL;
            oaViaSpecp result= (oaViaSpec::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaViaSpec_FromoaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTech,oaPhysicalLayer,oaPhysicalLayer,oaViaDef2DTblValue)
    {
        PyParamoaTech p1;
        PyParamoaPhysicalLayer p2;
        PyParamoaPhysicalLayer p3;
        PyParamoaViaDef2DTblValue p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaPhysicalLayer_Convert,&p2,
              &PyoaPhysicalLayer_Convert,&p3,
              &PyoaViaDef2DTblValue_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            if (!PyValidateDbObject(p3.Data(),3)) return NULL;
            if (!PyValidateDbObject(p4.Data(),4)) return NULL;
            oaViaSpecp result= (oaViaSpec::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaViaSpec_FromoaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTech,oaPhysicalLayer,oaPhysicalLayer,oaViaDefArrayValue,oaViaDef2DTblValue)
    {
        PyParamoaTech p1;
        PyParamoaPhysicalLayer p2;
        PyParamoaPhysicalLayer p3;
        PyParamoaViaDefArrayValue p4;
        PyParamoaViaDef2DTblValue p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaPhysicalLayer_Convert,&p2,
              &PyoaPhysicalLayer_Convert,&p3,
              &PyoaViaDefArrayValue_Convert,&p4,
              &PyoaViaDef2DTblValue_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            if (!PyValidateDbObject(p3.Data(),3)) return NULL;
            if (!PyValidateDbObject(p4.Data(),4)) return NULL;
            if (!PyValidateDbObject(p5.Data(),5)) return NULL;
            oaViaSpecp result= (oaViaSpec::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
            return PyoaViaSpec_FromoaViaSpec(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaViaSpec, function: create, Choices are:\n"
        "    (oaPhysicalLayer,oaPhysicalLayer,oaViaDefArrayValue)\n"
        "    (oaPhysicalLayer,oaPhysicalLayer,oaViaDef2DTblValue)\n"
        "    (oaPhysicalLayer,oaPhysicalLayer,oaViaDefArrayValue,oaViaDef2DTblValue)\n"
        "    (oaTech,oaPhysicalLayer,oaPhysicalLayer,oaViaDefArrayValue)\n"
        "    (oaTech,oaPhysicalLayer,oaPhysicalLayer,oaViaDef2DTblValue)\n"
        "    (oaTech,oaPhysicalLayer,oaPhysicalLayer,oaViaDefArrayValue,oaViaDef2DTblValue)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViaSpec_static_find_doc[] = 
"Class: oaViaSpec, Function: find\n"
"  Paramegers: (oaPhysicalLayer,oaPhysicalLayer)\n"
"    Calls: oaViaSpec* find(const oaPhysicalLayer* layer1,const oaPhysicalLayer* layer2)\n"
"    Signature: find|ptr-oaViaSpec|cptr-oaPhysicalLayer,cptr-oaPhysicalLayer,\n"
"    This function searches the technology database associated with the given layers looking for an oaViaSpec with those layers. For this variant of the find function, the given layers must be in the same technology database, and the oaViaSpec lookup is local to that database. If a viaSpec is found, a pointer to the viaSpec is returned, otherwise NULL is returned.\n"
"    layer1\n"
"    First layer\n"
"    layer2\n"
"    Second layer\n"
"    oacLayer1Layer2NotInSameTech\n"
"  Paramegers: (oaTech,oaLayerNum,oaLayerNum)\n"
"    Calls: oaViaSpec* find(oaTech* tech,oaLayerNum layer1Num,oaLayerNum layer2Num)\n"
"    Signature: find|ptr-oaViaSpec|ptr-oaTech,simple-oaLayerNum,simple-oaLayerNum,simple-oaBoolean,\n"
"    This function searches the specified technology database looking for an oaViaSpec with the specified layer1 and layer2 numbers. The local argument specifies whether (if true) to look only in the specified technology database or (if false) to look in the specified technology database and all of its referenced databases. If a viaSpec is found, a pointer to the viaSpec is returned, otherwise NULL is returned.\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    tech\n"
"    The technology database to search\n"
"    layer1Num\n"
"    The layer number of the first layer\n"
"    layer2Num\n"
"    The layer number of the second layer\n"
"    local\n"
"    Specifies whether (if true) to look only in the specified technology database or (if false) to look in the specified technology database and all of its referenced databases.\n"
"  Paramegers: (oaTech,oaLayerNum,oaLayerNum,oaBoolean)\n"
"    Calls: oaViaSpec* find(oaTech* tech,oaLayerNum layer1Num,oaLayerNum layer2Num,oaBoolean local)\n"
"    Signature: find|ptr-oaViaSpec|ptr-oaTech,simple-oaLayerNum,simple-oaLayerNum,simple-oaBoolean,\n"
"    This function searches the specified technology database looking for an oaViaSpec with the specified layer1 and layer2 numbers. The local argument specifies whether (if true) to look only in the specified technology database or (if false) to look in the specified technology database and all of its referenced databases. If a viaSpec is found, a pointer to the viaSpec is returned, otherwise NULL is returned.\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    tech\n"
"    The technology database to search\n"
"    layer1Num\n"
"    The layer number of the first layer\n"
"    layer2Num\n"
"    The layer number of the second layer\n"
"    local\n"
"    Specifies whether (if true) to look only in the specified technology database or (if false) to look in the specified technology database and all of its referenced databases.\n"
;

static PyObject*
oaViaSpec_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaPhysicalLayer,oaPhysicalLayer)
    {
        PyParamoaPhysicalLayer p1;
        PyParamoaPhysicalLayer p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaPhysicalLayer_Convert,&p1,
              &PyoaPhysicalLayer_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaViaSpecp result= (oaViaSpec::find(p1.Data(),p2.Data()));
            return PyoaViaSpec_FromoaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTech,oaLayerNum,oaLayerNum)
    {
        PyParamoaTech p1;
        PyParamoaLayerNum p2;
        PyParamoaLayerNum p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaLayerNum_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaViaSpecp result= (oaViaSpec::find(p1.Data(),p2.Data(),p3.Data()));
            return PyoaViaSpec_FromoaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTech,oaLayerNum,oaLayerNum,oaBoolean)
    {
        PyParamoaTech p1;
        PyParamoaLayerNum p2;
        PyParamoaLayerNum p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaLayerNum_Convert,&p2,
              &PyoaLayerNum_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaViaSpecp result= (oaViaSpec::find(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaViaSpec_FromoaViaSpec(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaViaSpec, function: find, Choices are:\n"
        "    (oaPhysicalLayer,oaPhysicalLayer)\n"
        "    (oaTech,oaLayerNum,oaLayerNum)\n"
        "    (oaTech,oaLayerNum,oaLayerNum,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaViaSpec_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaViaSpec_static_create,METH_VARARGS,oaViaSpec_static_create_doc},
    {"static_find",(PyCFunction)oaViaSpec_static_find,METH_VARARGS,oaViaSpec_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaViaSpec_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaViaSpec_Type)<0) {
      printf("** PyType_Ready failed for: oaViaSpec\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaViaSpec",
           (PyObject*)(&PyoaViaSpec_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaViaSpec\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaViaSpec_Type.tp_dict;
    for(method=oaViaSpec_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaViaSpecModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaViaSpecModTypeEnum_Convert(PyObject* ob,PyParamoaViaSpecModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacSetValueViaSpecModType")==0) { result->SetData(oacSetValueViaSpecModType); return 1;}
        if (strcasecmp(str,"oacSetDefaultValueViaSpecModType")==0) { result->SetData(oacSetDefaultValueViaSpecModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaViaSpecModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaViaSpecModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaViaSpecModTypeEnum_FromoaViaSpecModTypeEnum(oaViaSpecModTypeEnum ob)
{
    if (ob==oacSetValueViaSpecModType) return PyString_FromString("oacSetValueViaSpecModType");
    if (ob==oacSetDefaultValueViaSpecModType) return PyString_FromString("oacSetDefaultValueViaSpecModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaViaSpecModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaViaSpecModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaViaSpecModTypeEnum_FromoaViaSpecModTypeEnum(oaViaSpecModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaViaSpecModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaViaSpecModTypeEnum_doc[] =
"Type convert function for enum: oaViaSpecModTypeEnum";
                               
static PyMethodDef PyoaViaSpecModTypeEnum_method =
  {"oaViaSpecModTypeEnum",(PyCFunction)PyoaViaSpecModTypeEnum_TypeFunction,METH_VARARGS,oaViaSpecModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaViaSpecModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacSetValueViaSpecModType");
    PyDict_SetItemString(mod_dict,"oacSetValueViaSpecModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetDefaultValueViaSpecModType");
    PyDict_SetItemString(mod_dict,"oacSetDefaultValueViaSpecModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaViaSpecModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaViaSpecModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaViaSpecModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaView
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaView_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaView_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaViewObject* self = (PyoaViewObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaView)
    {
        PyParamoaView p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaView_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaView, Choices are:\n"
        "    (oaView)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaView_tp_dealloc(PyoaViewObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaView_tp_repr(PyObject *ob)
{
    PyParamoaView value;
    int convert_status=PyoaView_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaView::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaScalarName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[28];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaView::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaView_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaView v1;
    PyParamoaView v2;
    int convert_status1=PyoaView_Convert(ob1,&v1);
    int convert_status2=PyoaView_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaView_Convert(PyObject* ob,PyParamoaView* result)
{
    if (ob == NULL) return 1;
    if (PyoaView_Check(ob)) {
        result->SetData( (oaView**) ((PyoaViewObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaView Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaView_FromoaView(oaView** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaView* data=*value;
        PyObject* bself = PyoaView_Type.tp_alloc(&PyoaView_Type,0);
        if (bself == NULL) return bself;
        PyoaViewObject* self = (PyoaViewObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaView_FromoaView(oaView* data)
{
    if (data) {
       PyObject* bself = PyoaView_Type.tp_alloc(&PyoaView_Type,0);
       if (bself == NULL) return bself;
       PyoaViewObject* self = (PyoaViewObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaView_destroy_doc[] = 
"Class: oaView, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function destroys this oaView.\n"
"    This function requires write access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if write access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaView_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaView data;
    int convert_status=PyoaView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViewObject* self=(PyoaViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaView_getCellViews_doc[] = 
"Class: oaView, Function: getCellViews\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaCellView_oaView getCellViews() const\n"
"    Signature: getCellViews|simple-oaCollection_oaCellView_oaView|\n"
"    BrowseData: 1\n"
"    This function returns a collection of the cellViews which are defined using this view.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaView_getCellViews(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaView data;
    int convert_status=PyoaView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViewObject* self=(PyoaViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaCellView_oaView* result= new oaCollection_oaCellView_oaView(data.DataCall()->getCellViews());
        return PyoaCollection_oaCellView_oaView_FromoaCollection_oaCellView_oaView(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaView_getCellViewsIter_doc[] = 
"Class: oaView, Function: getCellViewsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaCellView getCellViewsIter() const\n"
"    Signature: getCellViewsIter|simple-oaIter_oaCellView|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of the cellViews which are defined using this view.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaView_getCellViewsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaView data;
    int convert_status=PyoaView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViewObject* self=(PyoaViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaCellView* result= new oaIter_oaCellView(data.DataCall()->getCellViews());
        return PyoaIter_oaCellView_FromoaIter_oaCellView(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaView_getName_doc[] = 
"Class: oaView, Function: getName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getName(oaScalarName& name) const\n"
"    Signature: getName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the name of this view.\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& out) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the name of this view in the specified namespace.\n"
;

static PyObject*
oaView_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaView data;
    int convert_status=PyoaView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViewObject* self=(PyoaViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaView, function: getName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaView_getViewType_doc[] = 
"Class: oaView, Function: getViewType\n"
"  Paramegers: ()\n"
"    Calls: oaViewType* getViewType() const\n"
"    Signature: getViewType|ptr-oaViewType|\n"
"    BrowseData: 1\n"
"    This function returns the viewType of this view.\n"
;

static PyObject*
oaView_getViewType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaView data;
    int convert_status=PyoaView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViewObject* self=(PyoaViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaViewTypep result= (data.DataCall()->getViewType());
        return PyoaViewType_FromoaViewType(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaView_isNull_doc[] =
"Class: oaView, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaView_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaView data;
    int convert_status=PyoaView_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaView_assign_doc[] = 
"Class: oaView, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaView_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaView data;
  int convert_status=PyoaView_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaView p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaView_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaView_methodlist[] = {
    {"destroy",(PyCFunction)oaView_destroy,METH_VARARGS,oaView_destroy_doc},
    {"getCellViews",(PyCFunction)oaView_getCellViews,METH_VARARGS,oaView_getCellViews_doc},
    {"getCellViewsIter",(PyCFunction)oaView_getCellViewsIter,METH_VARARGS,oaView_getCellViewsIter_doc},
    {"getName",(PyCFunction)oaView_getName,METH_VARARGS,oaView_getName_doc},
    {"getViewType",(PyCFunction)oaView_getViewType,METH_VARARGS,oaView_getViewType_doc},
    {"isNull",(PyCFunction)oaView_tp_isNull,METH_VARARGS,oaView_isNull_doc},
    {"assign",(PyCFunction)oaView_tp_assign,METH_VARARGS,oaView_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaView_doc[] = 
"Class: oaView\n"
"  The oaView class implements an OpenAccess library view object.\n"
"  The oaView class can be observed by deriving from\n"
"  Note: The oaView function descriptions indicate if library access is required for the called function. If the access type must be write access, this requirement also is noted.\n"
"  For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"Constructors:\n"
"  Paramegers: (oaView)\n"
"    Calls: (const oaView&)\n"
"    Signature: oaView||cref-oaView,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaView_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaView",
    sizeof(PyoaViewObject),
    0,
    (destructor)oaView_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaView_tp_compare,	/* tp_compare */
    (reprfunc)oaView_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaView_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaView_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaDMContainer_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaView_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaView_static_find_doc[] = 
"Class: oaView, Function: find\n"
"  Paramegers: (oaLib,oaScalarName,oaViewType)\n"
"    Calls: oaView* find(const oaLib* lib,const oaScalarName& name,const oaViewType* viewType)\n"
"    Signature: find|ptr-oaView|cptr-oaLib,cref-oaScalarName,cptr-oaViewType,\n"
"    This function finds and returns the view with the specified name and viewType if it exists. If not found, NULL is returned.\n"
"    If the DM system plug-in in use does not support explicit view creation (such as, oaDMFileSys), this function will always return a view with the specified name and viewType.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    lib\n"
"    name\n"
"    viewType\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaView_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaLib p1;
    PyParamoaScalarName p2;
    PyParamoaViewType p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaLib_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaViewType_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!PyValidateDbObject(p3.Data(),3)) return NULL;
        oaViewp result= (oaView::find(p1.Data(),p2.Data(),p3.Data()));
        return PyoaView_FromoaView(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaView_static_get_doc[] = 
"Class: oaView, Function: get\n"
"  Paramegers: (oaLib,oaScalarName,oaViewType)\n"
"    Calls: oaView* get(const oaLib* lib,const oaScalarName& name,const oaViewType* viewType)\n"
"    Signature: get|ptr-oaView|cptr-oaLib,cref-oaScalarName,cptr-oaViewType,\n"
"    This function finds and returns the view with the specified name if it exists. If not found, it is created, and the new view is returned.\n"
"    This function requires write access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if write access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaView_static_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaLib p1;
    PyParamoaScalarName p2;
    PyParamoaViewType p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaLib_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaViewType_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!PyValidateDbObject(p3.Data(),3)) return NULL;
        oaViewp result= (oaView::get(p1.Data(),p2.Data(),p3.Data()));
        return PyoaView_FromoaView(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaView_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaView_static_find,METH_VARARGS,oaView_static_find_doc},
    {"static_get",(PyCFunction)oaView_static_get,METH_VARARGS,oaView_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaView_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaView_Type)<0) {
      printf("** PyType_Ready failed for: oaView\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaView",
           (PyObject*)(&PyoaView_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaView\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaView_Type.tp_dict;
    for(method=oaView_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaViewDMData
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaViewDMData_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaViewDMData_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaViewDMDataObject* self = (PyoaViewDMDataObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaViewDMData)
    {
        PyParamoaViewDMData p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaViewDMData_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaViewDMData, Choices are:\n"
        "    (oaViewDMData)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaViewDMData_tp_dealloc(PyoaViewDMDataObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaViewDMData_tp_repr(PyObject *ob)
{
    PyParamoaViewDMData value;
    int convert_status=PyoaViewDMData_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[34];
    sprintf(buffer,"<oaViewDMData::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaViewDMData_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaViewDMData v1;
    PyParamoaViewDMData v2;
    int convert_status1=PyoaViewDMData_Convert(ob1,&v1);
    int convert_status2=PyoaViewDMData_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaViewDMData_Convert(PyObject* ob,PyParamoaViewDMData* result)
{
    if (ob == NULL) return 1;
    if (PyoaViewDMData_Check(ob)) {
        result->SetData( (oaViewDMData**) ((PyoaViewDMDataObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaViewDMData Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaViewDMData_FromoaViewDMData(oaViewDMData** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaViewDMData* data=*value;
        PyObject* bself = PyoaViewDMData_Type.tp_alloc(&PyoaViewDMData_Type,0);
        if (bself == NULL) return bself;
        PyoaViewDMDataObject* self = (PyoaViewDMDataObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaViewDMData_FromoaViewDMData(oaViewDMData* data)
{
    if (data) {
       PyObject* bself = PyoaViewDMData_Type.tp_alloc(&PyoaViewDMData_Type,0);
       if (bself == NULL) return bself;
       PyoaViewDMDataObject* self = (PyoaViewDMDataObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViewDMData_getViewName_doc[] = 
"Class: oaViewDMData, Function: getViewName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getViewName(oaScalarName& viewName) const\n"
"    Signature: getViewName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the name of the view to which this ViewDMData object belongs.\n"
"    viewName\n"
"    A reference to the oaScalarName object that will be populated with the name of the view\n"
"    oacInvalidView\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getViewName(const oaNameSpace& ns,oaString& viewName) const\n"
"    Signature: getViewName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the name of the view to which this ViewDMData object belongs.\n"
"    ns\n"
"    The namespace to be used to populate the viewName parameter\n"
"    viewName\n"
"    A reference to an oaString object to be populated with the view name\n"
"    oacInvalidView\n"
;

static PyObject*
oaViewDMData_getViewName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViewDMData data;
    int convert_status=PyoaViewDMData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViewDMDataObject* self=(PyoaViewDMDataObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getViewName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getViewName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaViewDMData, function: getViewName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViewDMData_getViewType_doc[] = 
"Class: oaViewDMData, Function: getViewType\n"
"  Paramegers: ()\n"
"    Calls: oaViewType* getViewType() const\n"
"    Signature: getViewType|ptr-oaViewType|\n"
"    BrowseData: 1\n"
"    This function returns the viewType of the view to which this ViewDMData object belongs.\n"
"    oacInvalidView\n"
;

static PyObject*
oaViewDMData_getViewType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViewDMData data;
    int convert_status=PyoaViewDMData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaViewDMDataObject* self=(PyoaViewDMDataObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaViewTypep result= (data.DataCall()->getViewType());
        return PyoaViewType_FromoaViewType(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViewDMData_isNull_doc[] =
"Class: oaViewDMData, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaViewDMData_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaViewDMData data;
    int convert_status=PyoaViewDMData_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaViewDMData_assign_doc[] = 
"Class: oaViewDMData, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaViewDMData_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaViewDMData data;
  int convert_status=PyoaViewDMData_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaViewDMData p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaViewDMData_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaViewDMData_methodlist[] = {
    {"getViewName",(PyCFunction)oaViewDMData_getViewName,METH_VARARGS,oaViewDMData_getViewName_doc},
    {"getViewType",(PyCFunction)oaViewDMData_getViewType,METH_VARARGS,oaViewDMData_getViewType_doc},
    {"isNull",(PyCFunction)oaViewDMData_tp_isNull,METH_VARARGS,oaViewDMData_isNull_doc},
    {"assign",(PyCFunction)oaViewDMData_tp_assign,METH_VARARGS,oaViewDMData_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViewDMData_doc[] = 
"Class: oaViewDMData\n"
"  oaViewDMData objects represent database objects that can be associated with a DM view and can be used to persistently store properties ( oaProp objects), groups ( oaGroup objects), group members ( oaGroupMember objects) and application objects (see oaAppObject ).\n"
"Constructors:\n"
"  Paramegers: (oaViewDMData)\n"
"    Calls: (const oaViewDMData&)\n"
"    Signature: oaViewDMData||cref-oaViewDMData,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaViewDMData_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaViewDMData",
    sizeof(PyoaViewDMDataObject),
    0,
    (destructor)oaViewDMData_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaViewDMData_tp_compare,	/* tp_compare */
    (reprfunc)oaViewDMData_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaViewDMData_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaViewDMData_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaDMData_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaViewDMData_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaViewDMData_static_destroy_doc[] = 
"Class: oaViewDMData, Function: destroy\n"
"  Paramegers: (oaScalarName,oaScalarName,oaViewType)\n"
"    Calls: void destroy(const oaScalarName& libName,const oaScalarName& viewName,const oaViewType* viewType)\n"
"    Signature: destroy|void-void|cref-oaScalarName,cref-oaScalarName,cptr-oaViewType,\n"
"    This function attempts to remove the dmData from disk. It throws an exception if the dmData is currently open or if the dmData cannot be found on disk.\n"
"    libName\n"
"    The name of the library to use\n"
"    viewName\n"
"    The name of the view whose ViewDMData is to be destroyed\n"
"    viewType\n"
"    The specific viewType of the view whose ViewDMData is to be destroyed\n"
"    oacDMDataHasReadNeedWriteAccess\n"
"    oacDMDataCannotGetWriteAccess\n"
"    oacLibNotFound\n"
"    oacDestroyDMDataDoesNotExist\n"
"    oacDestroyDMDataOpen\n"
;

static PyObject*
oaViewDMData_static_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaScalarName p1;
    PyParamoaScalarName p2;
    PyParamoaViewType p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaScalarName_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaViewType_Convert,&p3)) {
        if (!PyValidateDbObject(p3.Data(),3)) return NULL;
        oaViewDMData::destroy(p1.Data(),p2.Data(),p3.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViewDMData_static_exists_doc[] = 
"Class: oaViewDMData, Function: exists\n"
"  Paramegers: (oaScalarName,oaScalarName,oaViewType)\n"
"    Calls: oaBoolean exists(const oaScalarName& libName,const oaScalarName& viewName,const oaViewType* viewType)\n"
"    Signature: exists|simple-oaBoolean|cref-oaScalarName,cref-oaScalarName,cptr-oaViewType,\n"
"    This function checks if there is a DMData open for the given library, or if a DMData file exists on disk with a non-zero size.\n"
"    libName\n"
"    The name of the library in which to look\n"
"    viewName\n"
"    The name of the view whose ViewDMData existence is to be checked\n"
"    viewType\n"
"    The viewType of the view whose ViewDMData existence is to be checked\n"
"    oacDMDataCannotGetReadAccess\n"
;

static PyObject*
oaViewDMData_static_exists(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaScalarName p1;
    PyParamoaScalarName p2;
    PyParamoaViewType p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaScalarName_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaViewType_Convert,&p3)) {
        if (!PyValidateDbObject(p3.Data(),3)) return NULL;
        oaBoolean result= (oaViewDMData::exists(p1.Data(),p2.Data(),p3.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViewDMData_static_find_doc[] = 
"Class: oaViewDMData, Function: find\n"
"  Paramegers: (oaScalarName,oaScalarName,oaViewType)\n"
"    Calls: oaViewDMData* find(const oaScalarName& libName,const oaScalarName& viewName,const oaViewType* viewType)\n"
"    Signature: find|ptr-oaViewDMData|cref-oaScalarName,cref-oaScalarName,cptr-oaViewType,\n"
"    This function attempts to find an open DM data for the given library. If successful, a pointer to the DMData object is returned; otherwise, NULL is returned.\n"
"    libName\n"
"    The name of the library in which to look\n"
"    viewName\n"
"    The name of the view whose ViewDMData is to be found\n"
"    viewType\n"
"    The viewType of the view whose ViewDMData is to be found\n"
"    oacDMDataCannotGetReadAccess\n"
;

static PyObject*
oaViewDMData_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaScalarName p1;
    PyParamoaScalarName p2;
    PyParamoaViewType p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaScalarName_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaViewType_Convert,&p3)) {
        if (!PyValidateDbObject(p3.Data(),3)) return NULL;
        oaViewDMDatap result= (oaViewDMData::find(p1.Data(),p2.Data(),p3.Data()));
        return PyoaViewDMData_FromoaViewDMData(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaViewDMData_static_open_doc[] = 
"Class: oaViewDMData, Function: open\n"
"  Paramegers: (oaScalarName,oaScalarName,oaViewType,oaChar)\n"
"    Calls: oaViewDMData* open(const oaScalarName& libName,const oaScalarName& viewName,const oaViewType* viewType,oaChar mode)\n"
"    Signature: open|ptr-oaViewDMData|cref-oaScalarName,cref-oaScalarName,cptr-oaViewType,simple-oaChar,\n"
"    This function attempts to open the oaViewDMData object for the view with the specified name and viewType in the specified library with the specified mode. If the specified mode is a write-access mode ('a'ppend or 'w'rite mode) and the oaViewDMData does not exist, it will be created. If the specified mode is a read-access mode ('r'ead-only mode) and the oaViewDMData does not exist, an oacDMDataDoesNotExist exception will be thrown.\n"
"    If successful, a pointer to the ViewDMData object is returned.\n"
"    libName\n"
"    The name of the library\n"
"    viewName\n"
"    The name of the view whose ViewDMData is to be opened\n"
"    viewType\n"
"    The viewType of the view to be opened\n"
"    mode\n"
"    The mode in which to open the ViewDMData\n"
"    oacOpenUndefinedModeDMData\n"
"    oacLibNotFound\n"
"    oacViewNotFound\n"
"    oacDMDataCannotGetReadAccess\n"
"    oacDMDataHasReadNeedWriteAccess\n"
"    oacDMDataCannotGetWriteAccess\n"
;

static PyObject*
oaViewDMData_static_open(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaScalarName p1;
    PyParamoaScalarName p2;
    PyParamoaViewType p3;
    PyParamoaChar p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaScalarName_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaViewType_Convert,&p3,
          &PyoaChar_Convert,&p4)) {
        if (!PyValidateDbObject(p3.Data(),3)) return NULL;
        oaViewDMDatap result= (oaViewDMData::open(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
        return PyoaViewDMData_FromoaViewDMData(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaViewDMData_staticmethodlist[] = {
    {"static_destroy",(PyCFunction)oaViewDMData_static_destroy,METH_VARARGS,oaViewDMData_static_destroy_doc},
    {"static_exists",(PyCFunction)oaViewDMData_static_exists,METH_VARARGS,oaViewDMData_static_exists_doc},
    {"static_find",(PyCFunction)oaViewDMData_static_find,METH_VARARGS,oaViewDMData_static_find_doc},
    {"static_open",(PyCFunction)oaViewDMData_static_open,METH_VARARGS,oaViewDMData_static_open_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaViewDMData_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaViewDMData_Type)<0) {
      printf("** PyType_Ready failed for: oaViewDMData\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaViewDMData",
           (PyObject*)(&PyoaViewDMData_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaViewDMData\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaViewDMData_Type.tp_dict;
    for(method=oaViewDMData_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}

