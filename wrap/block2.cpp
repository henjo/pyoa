
/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaAntennaModelEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaAntennaModelEnum_Convert(PyObject* ob,PyParamoaAntennaModelEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacDefaultAntennaModel")==0) { result->SetData(oacDefaultAntennaModel); return 1;}
        if (strcasecmp(str,"oacSecondAntennaModel")==0) { result->SetData(oacSecondAntennaModel); return 1;}
        if (strcasecmp(str,"oacThirdAntennaModel")==0) { result->SetData(oacThirdAntennaModel); return 1;}
        if (strcasecmp(str,"oacFourthAntennaModel")==0) { result->SetData(oacFourthAntennaModel); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaAntennaModelEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaAntennaModelEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaAntennaModelEnum_FromoaAntennaModelEnum(oaAntennaModelEnum ob)
{
    if (ob==oacDefaultAntennaModel) return PyString_FromString("oacDefaultAntennaModel");
    if (ob==oacSecondAntennaModel) return PyString_FromString("oacSecondAntennaModel");
    if (ob==oacThirdAntennaModel) return PyString_FromString("oacThirdAntennaModel");
    if (ob==oacFourthAntennaModel) return PyString_FromString("oacFourthAntennaModel");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaAntennaModelEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaAntennaModelEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaAntennaModelEnum_FromoaAntennaModelEnum(oaAntennaModelEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaAntennaModelEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaAntennaModelEnum_doc[] =
"Type convert function for enum: oaAntennaModelEnum";
                               
static PyMethodDef PyoaAntennaModelEnum_method =
  {"oaAntennaModelEnum",(PyCFunction)PyoaAntennaModelEnum_TypeFunction,METH_VARARGS,oaAntennaModelEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaAntennaModelEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacDefaultAntennaModel");
    PyDict_SetItemString(mod_dict,"oacDefaultAntennaModel",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSecondAntennaModel");
    PyDict_SetItemString(mod_dict,"oacSecondAntennaModel",value);
    Py_DECREF(value);
    value=PyString_FromString("oacThirdAntennaModel");
    PyDict_SetItemString(mod_dict,"oacThirdAntennaModel",value);
    Py_DECREF(value);
    value=PyString_FromString("oacFourthAntennaModel");
    PyDict_SetItemString(mod_dict,"oacFourthAntennaModel",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaAntennaModelEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaAntennaModelEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaAntennaModelEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaAntennaRatioArrayValue
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaAntennaRatioArrayValue_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaAntennaRatioArrayValue_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaAntennaRatioArrayValueObject* self = (PyoaAntennaRatioArrayValueObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaAntennaRatioArrayValue)
    {
        PyParamoaAntennaRatioArrayValue p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaAntennaRatioArrayValue_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaAntennaRatioArrayValue, Choices are:\n"
        "    (oaAntennaRatioArrayValue)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaAntennaRatioArrayValue_tp_dealloc(PyoaAntennaRatioArrayValueObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaAntennaRatioArrayValue_tp_repr(PyObject *ob)
{
    PyParamoaAntennaRatioArrayValue value;
    int convert_status=PyoaAntennaRatioArrayValue_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[46];
    sprintf(buffer,"<oaAntennaRatioArrayValue::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaAntennaRatioArrayValue_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaAntennaRatioArrayValue v1;
    PyParamoaAntennaRatioArrayValue v2;
    int convert_status1=PyoaAntennaRatioArrayValue_Convert(ob1,&v1);
    int convert_status2=PyoaAntennaRatioArrayValue_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaAntennaRatioArrayValue_Convert(PyObject* ob,PyParamoaAntennaRatioArrayValue* result)
{
    if (ob == NULL) return 1;
    if (PyoaAntennaRatioArrayValue_Check(ob)) {
        result->SetData( (oaAntennaRatioArrayValue**) ((PyoaAntennaRatioArrayValueObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaAntennaRatioArrayValue Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaAntennaRatioArrayValue_FromoaAntennaRatioArrayValue(oaAntennaRatioArrayValue** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaAntennaRatioArrayValue* data=*value;
        PyObject* bself = PyoaAntennaRatioArrayValue_Type.tp_alloc(&PyoaAntennaRatioArrayValue_Type,0);
        if (bself == NULL) return bself;
        PyoaAntennaRatioArrayValueObject* self = (PyoaAntennaRatioArrayValueObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaAntennaRatioArrayValue_FromoaAntennaRatioArrayValue(oaAntennaRatioArrayValue* data)
{
    if (data) {
       PyObject* bself = PyoaAntennaRatioArrayValue_Type.tp_alloc(&PyoaAntennaRatioArrayValue_Type,0);
       if (bself == NULL) return bself;
       PyoaAntennaRatioArrayValueObject* self = (PyoaAntennaRatioArrayValueObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAntennaRatioArrayValue_get_doc[] = 
"Class: oaAntennaRatioArrayValue, Function: get\n"
"  Paramegers: (oaAntennaModel)\n"
"    Calls: oaAntennaRatioValue* get(const oaAntennaModel& model) const\n"
"    Signature: get|ptr-oaAntennaRatioValue|cref-oaAntennaModel,\n"
"    This function returns the antenna ratio value for the antenna model specified\n"
"    model\n"
"    The antenna model to get the antenna ratios value for\n"
;

static PyObject*
oaAntennaRatioArrayValue_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAntennaRatioArrayValue data;
    int convert_status=PyoaAntennaRatioArrayValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAntennaRatioArrayValueObject* self=(PyoaAntennaRatioArrayValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaAntennaModel p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaAntennaModel_Convert,&p1)) {
        oaAntennaRatioValuep result= (data.DataCall()->get(p1.Data()));
        return PyoaAntennaRatioValue_FromoaAntennaRatioValue(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAntennaRatioArrayValue_set_doc[] = 
"Class: oaAntennaRatioArrayValue, Function: set\n"
"  Paramegers: (oaAntennaModel,oaAntennaRatioValue)\n"
"    Calls: void set(const oaAntennaModel& model,oaAntennaRatioValue* value)\n"
"    Signature: set|void-void|cref-oaAntennaModel,ptr-oaAntennaRatioValue,\n"
"    This function sets the antenna ratios for the antenna model specified\n"
"    model\n"
"    The model to set the ratios for\n"
"    value\n"
"    The value of the antenna ratios to set\n"
;

static PyObject*
oaAntennaRatioArrayValue_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAntennaRatioArrayValue data;
    int convert_status=PyoaAntennaRatioArrayValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAntennaRatioArrayValueObject* self=(PyoaAntennaRatioArrayValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaAntennaModel p1;
    PyParamoaAntennaRatioValue p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaAntennaModel_Convert,&p1,
          &PyoaAntennaRatioValue_Convert,&p2)) {
        if (!PyValidateDbObject(p2.Data(),2)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAntennaRatioArrayValue_isNull_doc[] =
"Class: oaAntennaRatioArrayValue, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaAntennaRatioArrayValue_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaAntennaRatioArrayValue data;
    int convert_status=PyoaAntennaRatioArrayValue_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaAntennaRatioArrayValue_assign_doc[] = 
"Class: oaAntennaRatioArrayValue, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaAntennaRatioArrayValue_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaAntennaRatioArrayValue data;
  int convert_status=PyoaAntennaRatioArrayValue_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaAntennaRatioArrayValue p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaAntennaRatioArrayValue_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaAntennaRatioArrayValue_methodlist[] = {
    {"get",(PyCFunction)oaAntennaRatioArrayValue_get,METH_VARARGS,oaAntennaRatioArrayValue_get_doc},
    {"set",(PyCFunction)oaAntennaRatioArrayValue_set,METH_VARARGS,oaAntennaRatioArrayValue_set_doc},
    {"isNull",(PyCFunction)oaAntennaRatioArrayValue_tp_isNull,METH_VARARGS,oaAntennaRatioArrayValue_isNull_doc},
    {"assign",(PyCFunction)oaAntennaRatioArrayValue_tp_assign,METH_VARARGS,oaAntennaRatioArrayValue_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAntennaRatioArrayValue_doc[] = 
"Class: oaAntennaRatioArrayValue\n"
"  The oaAntennaRatioArrayValue represents an array of antennaArrayValues, one for each antenna model.\n"
"  See oaValue for a discussion of the usage of all of the oaValue subclasses.\n"
"Constructors:\n"
"  Paramegers: (oaAntennaRatioArrayValue)\n"
"    Calls: (const oaAntennaRatioArrayValue&)\n"
"    Signature: oaAntennaRatioArrayValue||cref-oaAntennaRatioArrayValue,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaAntennaRatioArrayValue_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaAntennaRatioArrayValue",
    sizeof(PyoaAntennaRatioArrayValueObject),
    0,
    (destructor)oaAntennaRatioArrayValue_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaAntennaRatioArrayValue_tp_compare,	/* tp_compare */
    (reprfunc)oaAntennaRatioArrayValue_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaAntennaRatioArrayValue_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaAntennaRatioArrayValue_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaValue_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaAntennaRatioArrayValue_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAntennaRatioArrayValue_static_create_doc[] = 
"Class: oaAntennaRatioArrayValue, Function: create\n"
"  Paramegers: (oaObject,oaAntennaRatioValue)\n"
"    Calls: oaAntennaRatioArrayValue* create(oaObject* database,oaAntennaRatioValue* defaultModel)\n"
"    Signature: create|ptr-oaAntennaRatioArrayValue|ptr-oaObject,ptr-oaAntennaRatioValue,ptr-oaAntennaRatioValue,ptr-oaAntennaRatioValue,ptr-oaAntennaRatioValue,\n"
"    This function creates an antennaRatioArray value in the specified database. An antennaRatioValue is specified for each antenna model as needed. Only the defaultModel is required. All of the antennaRatioValues must be in the same database as the value being created.\n"
"    database\n"
"    The database to create the value in\n"
"    defaultModel\n"
"    The antenna ratios for the default model\n"
"    secondModel\n"
"    The antenna ratios for the second model\n"
"    thirdModel\n"
"    The antenna ratios for the third model\n"
"    fourthModel\n"
"    The antenna ratios for the fourth model\n"
"    oacInvalidDatabase\n"
"  Paramegers: (oaObject,oaAntennaRatioValue,oaAntennaRatioValue)\n"
"    Calls: oaAntennaRatioArrayValue* create(oaObject* database,oaAntennaRatioValue* defaultModel,oaAntennaRatioValue* secondModel)\n"
"    Signature: create|ptr-oaAntennaRatioArrayValue|ptr-oaObject,ptr-oaAntennaRatioValue,ptr-oaAntennaRatioValue,ptr-oaAntennaRatioValue,ptr-oaAntennaRatioValue,\n"
"    This function creates an antennaRatioArray value in the specified database. An antennaRatioValue is specified for each antenna model as needed. Only the defaultModel is required. All of the antennaRatioValues must be in the same database as the value being created.\n"
"    database\n"
"    The database to create the value in\n"
"    defaultModel\n"
"    The antenna ratios for the default model\n"
"    secondModel\n"
"    The antenna ratios for the second model\n"
"    thirdModel\n"
"    The antenna ratios for the third model\n"
"    fourthModel\n"
"    The antenna ratios for the fourth model\n"
"    oacInvalidDatabase\n"
"  Paramegers: (oaObject,oaAntennaRatioValue,oaAntennaRatioValue,oaAntennaRatioValue)\n"
"    Calls: oaAntennaRatioArrayValue* create(oaObject* database,oaAntennaRatioValue* defaultModel,oaAntennaRatioValue* secondModel,oaAntennaRatioValue* thirdModel)\n"
"    Signature: create|ptr-oaAntennaRatioArrayValue|ptr-oaObject,ptr-oaAntennaRatioValue,ptr-oaAntennaRatioValue,ptr-oaAntennaRatioValue,ptr-oaAntennaRatioValue,\n"
"    This function creates an antennaRatioArray value in the specified database. An antennaRatioValue is specified for each antenna model as needed. Only the defaultModel is required. All of the antennaRatioValues must be in the same database as the value being created.\n"
"    database\n"
"    The database to create the value in\n"
"    defaultModel\n"
"    The antenna ratios for the default model\n"
"    secondModel\n"
"    The antenna ratios for the second model\n"
"    thirdModel\n"
"    The antenna ratios for the third model\n"
"    fourthModel\n"
"    The antenna ratios for the fourth model\n"
"    oacInvalidDatabase\n"
"  Paramegers: (oaObject,oaAntennaRatioValue,oaAntennaRatioValue,oaAntennaRatioValue,oaAntennaRatioValue)\n"
"    Calls: oaAntennaRatioArrayValue* create(oaObject* database,oaAntennaRatioValue* defaultModel,oaAntennaRatioValue* secondModel,oaAntennaRatioValue* thirdModel,oaAntennaRatioValue* fourthModel)\n"
"    Signature: create|ptr-oaAntennaRatioArrayValue|ptr-oaObject,ptr-oaAntennaRatioValue,ptr-oaAntennaRatioValue,ptr-oaAntennaRatioValue,ptr-oaAntennaRatioValue,\n"
"    This function creates an antennaRatioArray value in the specified database. An antennaRatioValue is specified for each antenna model as needed. Only the defaultModel is required. All of the antennaRatioValues must be in the same database as the value being created.\n"
"    database\n"
"    The database to create the value in\n"
"    defaultModel\n"
"    The antenna ratios for the default model\n"
"    secondModel\n"
"    The antenna ratios for the second model\n"
"    thirdModel\n"
"    The antenna ratios for the third model\n"
"    fourthModel\n"
"    The antenna ratios for the fourth model\n"
"    oacInvalidDatabase\n"
;

static PyObject*
oaAntennaRatioArrayValue_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaObject,oaAntennaRatioValue)
    {
        PyParamoaObject p1;
        PyParamoaAntennaRatioValue p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaObject_Convert,&p1,
              &PyoaAntennaRatioValue_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaAntennaRatioArrayValuep result= (oaAntennaRatioArrayValue::create(p1.Data(),p2.Data()));
            return PyoaAntennaRatioArrayValue_FromoaAntennaRatioArrayValue(result);
        }
    }
    PyErr_Clear();
    // Case: (oaObject,oaAntennaRatioValue,oaAntennaRatioValue)
    {
        PyParamoaObject p1;
        PyParamoaAntennaRatioValue p2;
        PyParamoaAntennaRatioValue p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaObject_Convert,&p1,
              &PyoaAntennaRatioValue_Convert,&p2,
              &PyoaAntennaRatioValue_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            if (!PyValidateDbObject(p3.Data(),3)) return NULL;
            oaAntennaRatioArrayValuep result= (oaAntennaRatioArrayValue::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaAntennaRatioArrayValue_FromoaAntennaRatioArrayValue(result);
        }
    }
    PyErr_Clear();
    // Case: (oaObject,oaAntennaRatioValue,oaAntennaRatioValue,oaAntennaRatioValue)
    {
        PyParamoaObject p1;
        PyParamoaAntennaRatioValue p2;
        PyParamoaAntennaRatioValue p3;
        PyParamoaAntennaRatioValue p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaObject_Convert,&p1,
              &PyoaAntennaRatioValue_Convert,&p2,
              &PyoaAntennaRatioValue_Convert,&p3,
              &PyoaAntennaRatioValue_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            if (!PyValidateDbObject(p3.Data(),3)) return NULL;
            if (!PyValidateDbObject(p4.Data(),4)) return NULL;
            oaAntennaRatioArrayValuep result= (oaAntennaRatioArrayValue::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaAntennaRatioArrayValue_FromoaAntennaRatioArrayValue(result);
        }
    }
    PyErr_Clear();
    // Case: (oaObject,oaAntennaRatioValue,oaAntennaRatioValue,oaAntennaRatioValue,oaAntennaRatioValue)
    {
        PyParamoaObject p1;
        PyParamoaAntennaRatioValue p2;
        PyParamoaAntennaRatioValue p3;
        PyParamoaAntennaRatioValue p4;
        PyParamoaAntennaRatioValue p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaObject_Convert,&p1,
              &PyoaAntennaRatioValue_Convert,&p2,
              &PyoaAntennaRatioValue_Convert,&p3,
              &PyoaAntennaRatioValue_Convert,&p4,
              &PyoaAntennaRatioValue_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            if (!PyValidateDbObject(p3.Data(),3)) return NULL;
            if (!PyValidateDbObject(p4.Data(),4)) return NULL;
            if (!PyValidateDbObject(p5.Data(),5)) return NULL;
            oaAntennaRatioArrayValuep result= (oaAntennaRatioArrayValue::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
            return PyoaAntennaRatioArrayValue_FromoaAntennaRatioArrayValue(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaAntennaRatioArrayValue, function: create, Choices are:\n"
        "    (oaObject,oaAntennaRatioValue)\n"
        "    (oaObject,oaAntennaRatioValue,oaAntennaRatioValue)\n"
        "    (oaObject,oaAntennaRatioValue,oaAntennaRatioValue,oaAntennaRatioValue)\n"
        "    (oaObject,oaAntennaRatioValue,oaAntennaRatioValue,oaAntennaRatioValue,oaAntennaRatioValue)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaAntennaRatioArrayValue_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaAntennaRatioArrayValue_static_create,METH_VARARGS,oaAntennaRatioArrayValue_static_create_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaAntennaRatioArrayValue_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaAntennaRatioArrayValue_Type)<0) {
      printf("** PyType_Ready failed for: oaAntennaRatioArrayValue\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaAntennaRatioArrayValue",
           (PyObject*)(&PyoaAntennaRatioArrayValue_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaAntennaRatioArrayValue\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaAntennaRatioArrayValue_Type.tp_dict;
    for(method=oaAntennaRatioArrayValue_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaAntennaRatioValue
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaAntennaRatioValue_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaAntennaRatioValue_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaAntennaRatioValueObject* self = (PyoaAntennaRatioValueObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaAntennaRatioValue)
    {
        PyParamoaAntennaRatioValue p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaAntennaRatioValue_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaAntennaRatioValue, Choices are:\n"
        "    (oaAntennaRatioValue)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaAntennaRatioValue_tp_dealloc(PyoaAntennaRatioValueObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaAntennaRatioValue_tp_repr(PyObject *ob)
{
    PyParamoaAntennaRatioValue value;
    int convert_status=PyoaAntennaRatioValue_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[41];
    sprintf(buffer,"<oaAntennaRatioValue::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaAntennaRatioValue_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaAntennaRatioValue v1;
    PyParamoaAntennaRatioValue v2;
    int convert_status1=PyoaAntennaRatioValue_Convert(ob1,&v1);
    int convert_status2=PyoaAntennaRatioValue_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaAntennaRatioValue_Convert(PyObject* ob,PyParamoaAntennaRatioValue* result)
{
    if (ob == NULL) return 1;
    if (PyoaAntennaRatioValue_Check(ob)) {
        result->SetData( (oaAntennaRatioValue**) ((PyoaAntennaRatioValueObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaAntennaRatioValue Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaAntennaRatioValue_FromoaAntennaRatioValue(oaAntennaRatioValue** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaAntennaRatioValue* data=*value;
        PyObject* bself = PyoaAntennaRatioValue_Type.tp_alloc(&PyoaAntennaRatioValue_Type,0);
        if (bself == NULL) return bself;
        PyoaAntennaRatioValueObject* self = (PyoaAntennaRatioValueObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaAntennaRatioValue_FromoaAntennaRatioValue(oaAntennaRatioValue* data)
{
    if (data) {
       PyObject* bself = PyoaAntennaRatioValue_Type.tp_alloc(&PyoaAntennaRatioValue_Type,0);
       if (bself == NULL) return bself;
       PyoaAntennaRatioValueObject* self = (PyoaAntennaRatioValueObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAntennaRatioValue_getDiode_doc[] = 
"Class: oaAntennaRatioValue, Function: getDiode\n"
"  Paramegers: (oa1DLookupTbl_oaInt8_oaFloat)\n"
"    Calls: void getDiode(oa1DLookupTbl_oaInt8_oaFloat& ratio) const\n"
"    Signature: getDiode|void-void|ref-oa1DLookupTbl_oaInt8_oaFloat,\n"
"    BrowseData: 0,oa1DLookupTbl_oaInt8_oaFloat\n"
"    This function returns the diode area ratio.\n"
"    ratio\n"
"    The returned diode area ratio value\n"
;

static PyObject*
oaAntennaRatioValue_getDiode(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAntennaRatioValue data;
    int convert_status=PyoaAntennaRatioValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAntennaRatioValueObject* self=(PyoaAntennaRatioValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoa1DLookupTbl_oaInt8_oaFloat p1;
    if (PyArg_ParseTuple(args,"O&",
          &Pyoa1DLookupTbl_oaInt8_oaFloat_Convert,&p1)) {
        data.DataCall()->getDiode(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAntennaRatioValue_getGate_doc[] = 
"Class: oaAntennaRatioValue, Function: getGate\n"
"  Paramegers: ()\n"
"    Calls: oaFloat getGate() const\n"
"    Signature: getGate|simple-oaFloat|\n"
"    BrowseData: 1\n"
"    This function returns the gate area ratio.\n"
;

static PyObject*
oaAntennaRatioValue_getGate(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAntennaRatioValue data;
    int convert_status=PyoaAntennaRatioValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAntennaRatioValueObject* self=(PyoaAntennaRatioValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaFloat result= (data.DataCall()->getGate());
        return PyoaFloat_FromoaFloat(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAntennaRatioValue_isSide_doc[] = 
"Class: oaAntennaRatioValue, Function: isSide\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isSide() const\n"
"    Signature: isSide|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether the area measurement is perimeter based.\n"
;

static PyObject*
oaAntennaRatioValue_isSide(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAntennaRatioValue data;
    int convert_status=PyoaAntennaRatioValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAntennaRatioValueObject* self=(PyoaAntennaRatioValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isSide());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAntennaRatioValue_setDiode_doc[] = 
"Class: oaAntennaRatioValue, Function: setDiode\n"
"  Paramegers: (oa1DLookupTbl_oaInt8_oaFloat)\n"
"    Calls: void setDiode(const oa1DLookupTbl_oaInt8_oaFloat& ratio)\n"
"    Signature: setDiode|void-void|cref-oa1DLookupTbl_oaInt8_oaFloat,\n"
"    This function sets the diode area ratio value.\n"
"    ratio\n"
"    The value to set\n"
;

static PyObject*
oaAntennaRatioValue_setDiode(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAntennaRatioValue data;
    int convert_status=PyoaAntennaRatioValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAntennaRatioValueObject* self=(PyoaAntennaRatioValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoa1DLookupTbl_oaInt8_oaFloat p1;
    if (PyArg_ParseTuple(args,"O&",
          &Pyoa1DLookupTbl_oaInt8_oaFloat_Convert,&p1)) {
        data.DataCall()->setDiode(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAntennaRatioValue_setGate_doc[] = 
"Class: oaAntennaRatioValue, Function: setGate\n"
"  Paramegers: (oaFloat)\n"
"    Calls: void setGate(oaFloat ratio)\n"
"    Signature: setGate|void-void|simple-oaFloat,\n"
"    This function sets the gate area ratio value.\n"
"    ratio\n"
"    The value to set\n"
;

static PyObject*
oaAntennaRatioValue_setGate(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAntennaRatioValue data;
    int convert_status=PyoaAntennaRatioValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAntennaRatioValueObject* self=(PyoaAntennaRatioValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaFloat p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaFloat_Convert,&p1)) {
        data.DataCall()->setGate(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAntennaRatioValue_setSide_doc[] = 
"Class: oaAntennaRatioValue, Function: setSide\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: void setSide(oaBoolean isSide)\n"
"    Signature: setSide|void-void|simple-oaBoolean,\n"
"    This function sets a boolean indicating whether or not the area measurement is parameter based.\n"
"    isSide\n"
"    The boolean value to set\n"
;

static PyObject*
oaAntennaRatioValue_setSide(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAntennaRatioValue data;
    int convert_status=PyoaAntennaRatioValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAntennaRatioValueObject* self=(PyoaAntennaRatioValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBoolean p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBoolean_Convert,&p1)) {
        data.DataCall()->setSide(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAntennaRatioValue_isNull_doc[] =
"Class: oaAntennaRatioValue, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaAntennaRatioValue_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaAntennaRatioValue data;
    int convert_status=PyoaAntennaRatioValue_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaAntennaRatioValue_assign_doc[] = 
"Class: oaAntennaRatioValue, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaAntennaRatioValue_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaAntennaRatioValue data;
  int convert_status=PyoaAntennaRatioValue_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaAntennaRatioValue p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaAntennaRatioValue_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaAntennaRatioValue_methodlist[] = {
    {"getDiode",(PyCFunction)oaAntennaRatioValue_getDiode,METH_VARARGS,oaAntennaRatioValue_getDiode_doc},
    {"getGate",(PyCFunction)oaAntennaRatioValue_getGate,METH_VARARGS,oaAntennaRatioValue_getGate_doc},
    {"isSide",(PyCFunction)oaAntennaRatioValue_isSide,METH_VARARGS,oaAntennaRatioValue_isSide_doc},
    {"setDiode",(PyCFunction)oaAntennaRatioValue_setDiode,METH_VARARGS,oaAntennaRatioValue_setDiode_doc},
    {"setGate",(PyCFunction)oaAntennaRatioValue_setGate,METH_VARARGS,oaAntennaRatioValue_setGate_doc},
    {"setSide",(PyCFunction)oaAntennaRatioValue_setSide,METH_VARARGS,oaAntennaRatioValue_setSide_doc},
    {"isNull",(PyCFunction)oaAntennaRatioValue_tp_isNull,METH_VARARGS,oaAntennaRatioValue_isNull_doc},
    {"assign",(PyCFunction)oaAntennaRatioValue_tp_assign,METH_VARARGS,oaAntennaRatioValue_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAntennaRatioValue_doc[] = 
"Class: oaAntennaRatioValue\n"
"  This class represents the information needed to define process antenna rules. This information consists of values for the gate area ratio, the diode area ratio and a boolean indicating whether or not the area measurement is perimeter based.\n"
"  See oaValue for a discussion of the usage of all of the oaValue subclasses.\n"
"Constructors:\n"
"  Paramegers: (oaAntennaRatioValue)\n"
"    Calls: (const oaAntennaRatioValue&)\n"
"    Signature: oaAntennaRatioValue||cref-oaAntennaRatioValue,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaAntennaRatioValue_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaAntennaRatioValue",
    sizeof(PyoaAntennaRatioValueObject),
    0,
    (destructor)oaAntennaRatioValue_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaAntennaRatioValue_tp_compare,	/* tp_compare */
    (reprfunc)oaAntennaRatioValue_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaAntennaRatioValue_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaAntennaRatioValue_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaValue_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaAntennaRatioValue_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAntennaRatioValue_static_create_doc[] = 
"Class: oaAntennaRatioValue, Function: create\n"
"  Paramegers: (oaObject,oaBoolean,oaFloat,oa1DLookupTbl_oaInt8_oaFloat)\n"
"    Calls: oaAntennaRatioValue* create(oaObject* database,oaBoolean isSide,oaFloat gateRatio,const oa1DLookupTbl_oaInt8_oaFloat& diodeRatio)\n"
"    Signature: create|ptr-oaAntennaRatioValue|ptr-oaObject,simple-oaBoolean,simple-oaFloat,cref-oa1DLookupTbl_oaInt8_oaFloat,\n"
"    This function creates an antenna ratio value in the specified database.\n"
"    database\n"
"    The database to create the value in\n"
"    isSide\n"
"    A boolean indicating whether or not the area measurement is perimeter based\n"
"    gateRatio\n"
"    The gate area ratio\n"
"    diodeRatio\n"
"    The diode area ratio\n"
"    oacInvalidDatabase\n"
;

static PyObject*
oaAntennaRatioValue_static_create(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObject p1;
    PyParamoaBoolean p2;
    PyParamoaFloat p3;
    PyParamoa1DLookupTbl_oaInt8_oaFloat p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaObject_Convert,&p1,
          &PyoaBoolean_Convert,&p2,
          &PyoaFloat_Convert,&p3,
          &Pyoa1DLookupTbl_oaInt8_oaFloat_Convert,&p4)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaAntennaRatioValuep result= (oaAntennaRatioValue::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
        return PyoaAntennaRatioValue_FromoaAntennaRatioValue(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaAntennaRatioValue_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaAntennaRatioValue_static_create,METH_VARARGS,oaAntennaRatioValue_static_create_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaAntennaRatioValue_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaAntennaRatioValue_Type)<0) {
      printf("** PyType_Ready failed for: oaAntennaRatioValue\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaAntennaRatioValue",
           (PyObject*)(&PyoaAntennaRatioValue_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaAntennaRatioValue\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaAntennaRatioValue_Type.tp_dict;
    for(method=oaAntennaRatioValue_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaAppDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaAppDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaAppDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaAppDefObject* self = (PyoaAppDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaAppDef)
    {
        PyParamoaAppDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaAppDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaAppDef, Choices are:\n"
        "    (oaAppDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaAppDef_tp_dealloc(PyoaAppDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaAppDef_tp_repr(PyObject *ob)
{
    PyParamoaAppDef value;
    int convert_status=PyoaAppDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[30];
    sprintf(buffer,"<oaAppDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaAppDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaAppDef v1;
    PyParamoaAppDef v2;
    int convert_status1=PyoaAppDef_Convert(ob1,&v1);
    int convert_status2=PyoaAppDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaAppDef_Convert(PyObject* ob,PyParamoaAppDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaAppDef_Check(ob)) {
        result->SetData( (oaAppDef**) ((PyoaAppDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaAppDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaAppDef_FromoaAppDef(oaAppDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaAppDef* data=*value;
        PyObject* bself = PyoaAppDef_Type.tp_alloc(&PyoaAppDef_Type,0);
        if (bself == NULL) return bself;
        PyoaAppDefObject* self = (PyoaAppDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaAppDef_FromoaAppDef(oaAppDef* data)
{
    if (data) {
       PyObject* bself = PyoaAppDef_Type.tp_alloc(&PyoaAppDef_Type,0);
       if (bself == NULL) return bself;
       PyoaAppDefObject* self = (PyoaAppDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAppDef_destroy_doc[] = 
"Class: oaAppDef, Function: destroy\n"
"  Paramegers: (oaObject)\n"
"    Calls: void destroy(oaObject* object)\n"
"    Signature: destroy|void-void|ptr-oaObject,\n"
"    This function removes the extension data set on the specified object .\n"
"    object\n"
"    The object to search\n"
;

static PyObject*
oaAppDef_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAppDef data;
    int convert_status=PyoaAppDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAppDefObject* self=(PyoaAppDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaObject p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaObject_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->destroy(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAppDef_getName_doc[] = 
"Class: oaAppDef, Function: getName\n"
"  Paramegers: (oaString)\n"
"    Calls: void getName(oaString& name)\n"
"    Signature: getName|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function returns the name of the extension.\n"
;

static PyObject*
oaAppDef_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAppDef data;
    int convert_status=PyoaAppDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAppDefObject* self=(PyoaAppDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAppDef_isPersistent_doc[] = 
"Class: oaAppDef, Function: isPersistent\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isPersistent() const\n"
"    Signature: isPersistent|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns the value of the persistence flag for this AppDef. Persistent extension data is saved to the disk when its database is saved and will be present when the database is opened at a later time.\n"
"    Note that the first AppDef used to write a given type of extension data in a given database will determine its persistence. You cannot have some items that are persistent and some that are not for a single database and extension name.\n"
;

static PyObject*
oaAppDef_isPersistent(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAppDef data;
    int convert_status=PyoaAppDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAppDefObject* self=(PyoaAppDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isPersistent());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAppDef_isUsedIn_doc[] = 
"Class: oaAppDef, Function: isUsedIn\n"
"  Paramegers: (oaObject)\n"
"    Calls: oaBoolean isUsedIn(const oaObject* database)\n"
"    Signature: isUsedIn|simple-oaBoolean|cptr-oaObject,\n"
"    This function returns true if the extension is used in the specified database. Note that extensions that are set to the default value are not counted as being used.\n"
"    database\n"
"    The database to search\n"
"    oacInvalidDatabase\n"
;

static PyObject*
oaAppDef_isUsedIn(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAppDef data;
    int convert_status=PyoaAppDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAppDefObject* self=(PyoaAppDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaObject p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaObject_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->isUsedIn(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAppDef_remove_doc[] = 
"Class: oaAppDef, Function: remove\n"
"  Paramegers: (oaObject)\n"
"    Calls: void remove(oaObject* database)\n"
"    Signature: remove|void-void|ptr-oaObject,\n"
"    This function removes extension data of this extension from the specified database .\n"
"    database\n"
"    The database from which to remove this extension\n"
"    oacInvalidDatabase\n"
;

static PyObject*
oaAppDef_remove(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAppDef data;
    int convert_status=PyoaAppDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAppDefObject* self=(PyoaAppDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaObject p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaObject_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->remove(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAppDef_isNull_doc[] =
"Class: oaAppDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaAppDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaAppDef data;
    int convert_status=PyoaAppDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaAppDef_assign_doc[] = 
"Class: oaAppDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaAppDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaAppDef data;
  int convert_status=PyoaAppDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaAppDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaAppDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaAppDef_methodlist[] = {
    {"destroy",(PyCFunction)oaAppDef_destroy,METH_VARARGS,oaAppDef_destroy_doc},
    {"getName",(PyCFunction)oaAppDef_getName,METH_VARARGS,oaAppDef_getName_doc},
    {"isPersistent",(PyCFunction)oaAppDef_isPersistent,METH_VARARGS,oaAppDef_isPersistent_doc},
    {"isUsedIn",(PyCFunction)oaAppDef_isUsedIn,METH_VARARGS,oaAppDef_isUsedIn_doc},
    {"remove",(PyCFunction)oaAppDef_remove,METH_VARARGS,oaAppDef_remove_doc},
    {"isNull",(PyCFunction)oaAppDef_tp_isNull,METH_VARARGS,oaAppDef_isNull_doc},
    {"assign",(PyCFunction)oaAppDef_tp_assign,METH_VARARGS,oaAppDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAppDef_doc[] = 
"Class: oaAppDef\n"
"  The oaAppDef class is an abstract base class. The oaAppDef hierarchy of classes provides a way to add extension values to existing database objects. AppDefs may be used to create extensions on any managed object in an oaDesign , oaTech , or oaWafer database.\n"
"  All uses of a given AppDef across a session must be consistent. A  given  AppDef is determined by its name and the class of object it applies to. For a given name and class pair, all the other attributes - persistence, type of value, and default value - must have a consistent setting. For example, if an IntAppDef named  myData  exists on oaNets, trying to get() a FloatAppDef named  myData  on oaNets will throw an exception. However it is still legal to get() a BooleanAppDef named  myData  on oaInsts.\n"
"  An AppDef will exist in a given session either because it exists in an open database, or because the application has done a get() on it. Once an AppDef exists in a given session any attempt to create an inconsistent AppDef of the same name and object type will be an error. If a database is opened that has an AppDef stored in it that is inconsistent with a previously existing AppDef, then the newly read AppDef and its associated extension data will be ignored and will not be available to the application.\n"
"  Note: oaAppDefs and oaProps and should not be created on oaDMObjects such as oaLibs and oaCellViews. While OpenAccess does not enforce this restriction, there is no way to save such extensions. Instead, use a corresponding oaDMData object to properly represent these Props and AppDefs.\n"
"  Please refer to documentation for classes derived from oaAppDef for further information on their use. Also see Extending the Database in the Programmer's Guide for information on what classes can be extended and additional usage information. Also, see Uniqueness of Session Objects for information about the requirement that session objects be unique.\n"
"  The oaAppDef class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaAppDef)\n"
"    Calls: (const oaAppDef&)\n"
"    Signature: oaAppDef||cref-oaAppDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaAppDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaAppDef",
    sizeof(PyoaAppDefObject),
    0,
    (destructor)oaAppDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaAppDef_tp_compare,	/* tp_compare */
    (reprfunc)oaAppDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaAppDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaAppDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaSessionObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaAppDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaAppDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaAppDef_Type)<0) {
      printf("** PyType_Ready failed for: oaAppDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaAppDef",
           (PyObject*)(&PyoaAppDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaAppDef\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaAppObject
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaAppObject_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaAppObject_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaAppObjectObject* self = (PyoaAppObjectObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaAppObject)
    {
        PyParamoaAppObject p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaAppObject_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaAppObject, Choices are:\n"
        "    (oaAppObject)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaAppObject_tp_dealloc(PyoaAppObjectObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaAppObject_tp_repr(PyObject *ob)
{
    PyParamoaAppObject value;
    int convert_status=PyoaAppObject_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[33];
    sprintf(buffer,"<oaAppObject::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaAppObject_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaAppObject v1;
    PyParamoaAppObject v2;
    int convert_status1=PyoaAppObject_Convert(ob1,&v1);
    int convert_status2=PyoaAppObject_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaAppObject_Convert(PyObject* ob,PyParamoaAppObject* result)
{
    if (ob == NULL) return 1;
    if (PyoaAppObject_Check(ob)) {
        result->SetData( (oaAppObject**) ((PyoaAppObjectObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaAppObject Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaAppObject_FromoaAppObject(oaAppObject** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaAppObject* data=*value;
        PyObject* bself = PyoaAppObject_Type.tp_alloc(&PyoaAppObject_Type,0);
        if (bself == NULL) return bself;
        PyoaAppObjectObject* self = (PyoaAppObjectObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaAppObject_FromoaAppObject(oaAppObject* data)
{
    if (data) {
       PyObject* bself = PyoaAppObject_Type.tp_alloc(&PyoaAppObject_Type,0);
       if (bself == NULL) return bself;
       PyoaAppObjectObject* self = (PyoaAppObjectObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAppObject_destroy_doc[] = 
"Class: oaAppObject, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function destroys this extension object, removing it from the database.\n"
;

static PyObject*
oaAppObject_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAppObject data;
    int convert_status=PyoaAppObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAppObjectObject* self=(PyoaAppObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAppObject_getAppObjectDef_doc[] = 
"Class: oaAppObject, Function: getAppObjectDef\n"
"  Paramegers: ()\n"
"    Calls: oaAppObjectDef* getAppObjectDef() const\n"
"    Signature: getAppObjectDef|ptr-oaAppObjectDef|\n"
"    BrowseData: 1\n"
"    The function returns the oaAppObjectDef for this object.\n"
;

static PyObject*
oaAppObject_getAppObjectDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAppObject data;
    int convert_status=PyoaAppObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAppObjectObject* self=(PyoaAppObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaAppObjectDefp result= (data.DataCall()->getAppObjectDef());
        return PyoaAppObjectDef_FromoaAppObjectDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAppObject_isNull_doc[] =
"Class: oaAppObject, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaAppObject_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaAppObject data;
    int convert_status=PyoaAppObject_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaAppObject_assign_doc[] = 
"Class: oaAppObject, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaAppObject_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaAppObject data;
  int convert_status=PyoaAppObject_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaAppObject p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaAppObject_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaAppObject_methodlist[] = {
    {"destroy",(PyCFunction)oaAppObject_destroy,METH_VARARGS,oaAppObject_destroy_doc},
    {"getAppObjectDef",(PyCFunction)oaAppObject_getAppObjectDef,METH_VARARGS,oaAppObject_getAppObjectDef_doc},
    {"isNull",(PyCFunction)oaAppObject_tp_isNull,METH_VARARGS,oaAppObject_isNull_doc},
    {"assign",(PyCFunction)oaAppObject_tp_assign,METH_VARARGS,oaAppObject_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAppObject_doc[] = 
"Class: oaAppObject\n"
"  The oaAppObject class implements an extension object. You can create extension objects for object extensions that are registered in a database. Functions for creating, deleting, and querying extension object attributes are in this class.\n"
"  The oaAppObject class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaAppObject)\n"
"    Calls: (const oaAppObject&)\n"
"    Signature: oaAppObject||cref-oaAppObject,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaAppObject_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaAppObject",
    sizeof(PyoaAppObjectObject),
    0,
    (destructor)oaAppObject_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaAppObject_tp_compare,	/* tp_compare */
    (reprfunc)oaAppObject_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaAppObject_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaAppObject_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaAppObject_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAppObject_static_create_doc[] = 
"Class: oaAppObject, Function: create\n"
"  Paramegers: (oaObject,oaAppObjectDef)\n"
"    Calls: oaAppObject* create(oaObject* database,oaAppObjectDef* def)\n"
"    Signature: create|ptr-oaAppObject|ptr-oaObject,ptr-oaAppObjectDef,\n"
"    This function creates a new extension object for the ext object extension in the specified database . For more information, see Extending the Database in the Programmers Guide.\n"
"    oacInvalidAppObjectDef\n"
"    oacInvalidDatabase\n"
;

static PyObject*
oaAppObject_static_create(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObject p1;
    PyParamoaAppObjectDef p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaObject_Convert,&p1,
          &PyoaAppObjectDef_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!PyValidateDbObject(p2.Data(),2)) return NULL;
        oaAppObjectp result= (oaAppObject::create(p1.Data(),p2.Data()));
        return PyoaAppObject_FromoaAppObject(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaAppObject_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaAppObject_static_create,METH_VARARGS,oaAppObject_static_create_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaAppObject_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaAppObject_Type)<0) {
      printf("** PyType_Ready failed for: oaAppObject\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaAppObject",
           (PyObject*)(&PyoaAppObject_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaAppObject\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaAppObject_Type.tp_dict;
    for(method=oaAppObject_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaAppObjectCollection
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaAppObjectCollection_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaAppObjectCollection_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaAppObjectCollectionObject* self = (PyoaAppObjectCollectionObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaObject,oaAppObjectDef)
    {
        PyParamoaObject p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaObject_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            self->value =  new oaAppObjectCollection(p1.Data(),p2.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaAppObjectCollection)
    {
        PyParamoaAppObjectCollection p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaAppObjectCollection_Convert,&p1)) {
            self->value =  new oaAppObjectCollection(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaAppObjectCollection, Choices are:\n"
        "    (oaObject,oaAppObjectDef)\n"
        "    (oaAppObjectCollection)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaAppObjectCollection_tp_dealloc(PyoaAppObjectCollectionObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaAppObjectCollection_tp_repr(PyObject *ob)
{
    PyParamoaAppObjectCollection value;
    int convert_status=PyoaAppObjectCollection_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaAppObjectCollection::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaAppObjectCollection_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaAppObjectCollection v1;
    PyParamoaAppObjectCollection v2;
    int convert_status1=PyoaAppObjectCollection_Convert(ob1,&v1);
    int convert_status2=PyoaAppObjectCollection_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaAppObjectCollection_Convert(PyObject* ob,PyParamoaAppObjectCollection* result)
{
    if (ob == NULL) return 1;
    if (PyoaAppObjectCollection_Check(ob)) {
        result->SetData(  ((PyoaAppObjectCollectionObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaAppObjectCollection Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaAppObjectCollection_FromoaAppObjectCollection(oaAppObjectCollection* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaAppObjectCollection_Type.tp_alloc(&PyoaAppObjectCollection_Type,0);
        if (bself == NULL) return bself;
        PyoaAppObjectCollectionObject* self = (PyoaAppObjectCollectionObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAppObjectCollection_getCount_doc[] = 
"Class: oaAppObjectCollection, Function: getCount\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getCount() const\n"
"    Signature: getCount|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    Function getCount\n"
;

static PyObject*
oaAppObjectCollection_getCount(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAppObjectCollection data;
    int convert_status=PyoaAppObjectCollection_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAppObjectCollectionObject* self=(PyoaAppObjectCollectionObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getCount());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAppObjectCollection_includes_doc[] = 
"Class: oaAppObjectCollection, Function: includes\n"
"  Paramegers: (oaAppObject)\n"
"    Calls: oaBoolean includes(const oaAppObject* object) const\n"
"    Signature: includes|simple-oaBoolean|cptr-oaAppObject,\n"
"    Function includes\n"
;

static PyObject*
oaAppObjectCollection_includes(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAppObjectCollection data;
    int convert_status=PyoaAppObjectCollection_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAppObjectCollectionObject* self=(PyoaAppObjectCollectionObject*)ob;

    PyParamoaAppObject p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaAppObject_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->includes(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAppObjectCollection_isEmpty_doc[] = 
"Class: oaAppObjectCollection, Function: isEmpty\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isEmpty() const\n"
"    Signature: isEmpty|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    Function isEmpty\n"
;

static PyObject*
oaAppObjectCollection_isEmpty(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAppObjectCollection data;
    int convert_status=PyoaAppObjectCollection_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAppObjectCollectionObject* self=(PyoaAppObjectCollectionObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isEmpty());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaAppObjectCollection_assign_doc[] = 
"Class: oaAppObjectCollection, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaAppObjectCollection_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaAppObjectCollection data;
  int convert_status=PyoaAppObjectCollection_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaAppObjectCollection p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaAppObjectCollection_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaAppObjectCollection_methodlist[] = {
    {"getCount",(PyCFunction)oaAppObjectCollection_getCount,METH_VARARGS,oaAppObjectCollection_getCount_doc},
    {"includes",(PyCFunction)oaAppObjectCollection_includes,METH_VARARGS,oaAppObjectCollection_includes_doc},
    {"isEmpty",(PyCFunction)oaAppObjectCollection_isEmpty,METH_VARARGS,oaAppObjectCollection_isEmpty_doc},
    {"assign",(PyCFunction)oaAppObjectCollection_tp_assign,METH_VARARGS,oaAppObjectCollection_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAppObjectCollection_doc[] = 
"Class: oaAppObjectCollection\n"
"  Class type oaAppObjectCollection\n"
"Constructors:\n"
"  Paramegers: (oaObject,oaAppObjectDef)\n"
"    Calls: oaAppObjectCollection(const oaObject* database,const oaAppObjectDef* def)\n"
"    Signature: oaAppObjectCollection||cptr-oaObject,cptr-oaAppObjectDef,\n"
"    Constructor oaAppObjectCollection\n"
"  Paramegers: (oaAppObjectCollection)\n"
"    Calls: oaAppObjectCollection(const oaAppObjectCollection& c)\n"
"    Signature: oaAppObjectCollection||cref-oaAppObjectCollection,\n"
"    Constructor oaAppObjectCollection\n"
"  Paramegers: (oaAppObjectCollection)\n"
"    Calls: (const oaAppObjectCollection&)\n"
"    Signature: oaAppObjectCollection||cref-oaAppObjectCollection,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaAppObjectCollection_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaAppObjectCollection",
    sizeof(PyoaAppObjectCollectionObject),
    0,
    (destructor)oaAppObjectCollection_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaAppObjectCollection_tp_compare,	/* tp_compare */
    (reprfunc)oaAppObjectCollection_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaAppObjectCollection_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaAppObjectCollection_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaAppObjectCollection_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaAppObjectCollection_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaAppObjectCollection_Type)<0) {
      printf("** PyType_Ready failed for: oaAppObjectCollection\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaAppObjectCollection",
           (PyObject*)(&PyoaAppObjectCollection_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaAppObjectCollection\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaAppObjectDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaAppObjectDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaAppObjectDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaAppObjectDefObject* self = (PyoaAppObjectDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaAppObjectDef)
    {
        PyParamoaAppObjectDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaAppObjectDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaAppObjectDef, Choices are:\n"
        "    (oaAppObjectDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaAppObjectDef_tp_dealloc(PyoaAppObjectDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaAppObjectDef_tp_repr(PyObject *ob)
{
    PyParamoaAppObjectDef value;
    int convert_status=PyoaAppObjectDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[36];
    sprintf(buffer,"<oaAppObjectDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaAppObjectDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaAppObjectDef v1;
    PyParamoaAppObjectDef v2;
    int convert_status1=PyoaAppObjectDef_Convert(ob1,&v1);
    int convert_status2=PyoaAppObjectDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaAppObjectDef_Convert(PyObject* ob,PyParamoaAppObjectDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaAppObjectDef_Check(ob)) {
        result->SetData( (oaAppObjectDef**) ((PyoaAppObjectDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaAppObjectDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaAppObjectDef_FromoaAppObjectDef(oaAppObjectDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaAppObjectDef* data=*value;
        PyObject* bself = PyoaAppObjectDef_Type.tp_alloc(&PyoaAppObjectDef_Type,0);
        if (bself == NULL) return bself;
        PyoaAppObjectDefObject* self = (PyoaAppObjectDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaAppObjectDef_FromoaAppObjectDef(oaAppObjectDef* data)
{
    if (data) {
       PyObject* bself = PyoaAppObjectDef_Type.tp_alloc(&PyoaAppObjectDef_Type,0);
       if (bself == NULL) return bself;
       PyoaAppObjectDefObject* self = (PyoaAppObjectDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAppObjectDef_getName_doc[] = 
"Class: oaAppObjectDef, Function: getName\n"
"  Paramegers: (oaString)\n"
"    Calls: void getName(oaString& name) const\n"
"    Signature: getName|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the name of this object extension.\n"
"    name\n"
"    The string to fill out with this extensions name.\n"
;

static PyObject*
oaAppObjectDef_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAppObjectDef data;
    int convert_status=PyoaAppObjectDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAppObjectDefObject* self=(PyoaAppObjectDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAppObjectDef_getTimeStamp_doc[] = 
"Class: oaAppObjectDef, Function: getTimeStamp\n"
"  Paramegers: (oaObject)\n"
"    Calls: oaTimeStamp& getTimeStamp(const oaObject* database)\n"
"    Signature: getTimeStamp|ref-oaTimeStamp|cptr-oaObject,\n"
"    This function returns the timestamp for the appObjectTbl in the specified database.\n"
"    database\n"
"    The database to search for this extension.\n"
"    oacInvalidDatabase\n"
;

static PyObject*
oaAppObjectDef_getTimeStamp(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAppObjectDef data;
    int convert_status=PyoaAppObjectDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAppObjectDefObject* self=(PyoaAppObjectDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaObject p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaObject_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaTimeStamp* result=&(data.DataCall()->getTimeStamp(p1.Data()));
        return PyoaTimeStamp_FromoaTimeStamp(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAppObjectDef_isUsedIn_doc[] = 
"Class: oaAppObjectDef, Function: isUsedIn\n"
"  Paramegers: (oaObject)\n"
"    Calls: oaBoolean isUsedIn(const oaObject* database)\n"
"    Signature: isUsedIn|simple-oaBoolean|cptr-oaObject,\n"
"    This function returns true if the specified extension is used in the specified database .\n"
"    database\n"
"    The database to search for this extension\n"
"    oacInvalidDatabase\n"
;

static PyObject*
oaAppObjectDef_isUsedIn(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAppObjectDef data;
    int convert_status=PyoaAppObjectDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAppObjectDefObject* self=(PyoaAppObjectDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaObject p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaObject_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->isUsedIn(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAppObjectDef_remove_doc[] = 
"Class: oaAppObjectDef, Function: remove\n"
"  Paramegers: (oaObject)\n"
"    Calls: void remove(oaObject* database)\n"
"    Signature: remove|void-void|ptr-oaObject,\n"
"    This function destroys all oaAppObjects for this oaAppObjectDef in the specified database.\n"
"    oacInvalidDatabase\n"
;

static PyObject*
oaAppObjectDef_remove(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAppObjectDef data;
    int convert_status=PyoaAppObjectDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAppObjectDefObject* self=(PyoaAppObjectDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaObject p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaObject_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->remove(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAppObjectDef_isNull_doc[] =
"Class: oaAppObjectDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaAppObjectDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaAppObjectDef data;
    int convert_status=PyoaAppObjectDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaAppObjectDef_assign_doc[] = 
"Class: oaAppObjectDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaAppObjectDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaAppObjectDef data;
  int convert_status=PyoaAppObjectDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaAppObjectDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaAppObjectDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaAppObjectDef_methodlist[] = {
    {"getName",(PyCFunction)oaAppObjectDef_getName,METH_VARARGS,oaAppObjectDef_getName_doc},
    {"getTimeStamp",(PyCFunction)oaAppObjectDef_getTimeStamp,METH_VARARGS,oaAppObjectDef_getTimeStamp_doc},
    {"isUsedIn",(PyCFunction)oaAppObjectDef_isUsedIn,METH_VARARGS,oaAppObjectDef_isUsedIn_doc},
    {"remove",(PyCFunction)oaAppObjectDef_remove,METH_VARARGS,oaAppObjectDef_remove_doc},
    {"isNull",(PyCFunction)oaAppObjectDef_tp_isNull,METH_VARARGS,oaAppObjectDef_isNull_doc},
    {"assign",(PyCFunction)oaAppObjectDef_tp_assign,METH_VARARGS,oaAppObjectDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAppObjectDef_doc[] = 
"Class: oaAppObjectDef\n"
"  The oaAppObjectDef class registers an object extension with a specified extension name in the specified database.\n"
"Constructors:\n"
"  Paramegers: (oaAppObjectDef)\n"
"    Calls: (const oaAppObjectDef&)\n"
"    Signature: oaAppObjectDef||cref-oaAppObjectDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaAppObjectDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaAppObjectDef",
    sizeof(PyoaAppObjectDefObject),
    0,
    (destructor)oaAppObjectDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaAppObjectDef_tp_compare,	/* tp_compare */
    (reprfunc)oaAppObjectDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaAppObjectDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaAppObjectDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaSessionObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaAppObjectDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAppObjectDef_static_find_doc[] = 
"Class: oaAppObjectDef, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaAppObjectDef* find(const oaString& nameIn)\n"
"    Signature: find|ptr-oaAppObjectDef|cref-oaString,\n"
"    This function returns the oaAppObjectDef with the specified name if it exists.\n"
"    nameIn\n"
"    The name of the oaAppObjectDef to search for\n"
;

static PyObject*
oaAppObjectDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        oaAppObjectDefp result= (oaAppObjectDef::find(p1.Data()));
        return PyoaAppObjectDef_FromoaAppObjectDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAppObjectDef_static_get_doc[] = 
"Class: oaAppObjectDef, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaAppObjectDef* get(const oaString& nameIn)\n"
"    Signature: get|ptr-oaAppObjectDef|cref-oaString,\n"
"    This function returns the oaAppObjectDef with the specified name, creating it if it does not yet exist.\n"
"    nameIn\n"
"    The name of the oaAppObjectDef to create.\n"
;

static PyObject*
oaAppObjectDef_static_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        oaAppObjectDefp result= (oaAppObjectDef::get(p1.Data()));
        return PyoaAppObjectDef_FromoaAppObjectDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaAppObjectDef_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaAppObjectDef_static_find,METH_VARARGS,oaAppObjectDef_static_find_doc},
    {"static_get",(PyCFunction)oaAppObjectDef_static_get,METH_VARARGS,oaAppObjectDef_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaAppObjectDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaAppObjectDef_Type)<0) {
      printf("** PyType_Ready failed for: oaAppObjectDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaAppObjectDef",
           (PyObject*)(&PyoaAppObjectDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaAppObjectDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaAppObjectDef_Type.tp_dict;
    for(method=oaAppObjectDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaAppObjectDefCollection
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaAppObjectDefCollection_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaAppObjectDefCollection_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaAppObjectDefCollectionObject* self = (PyoaAppObjectDefCollectionObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaObject)
    {
        PyParamoaObject p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaObject_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            self->value =  new oaAppObjectDefCollection(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaAppObjectDefCollection)
    {
        PyParamoaAppObjectDefCollection p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaAppObjectDefCollection_Convert,&p1)) {
            self->value =  new oaAppObjectDefCollection(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaAppObjectDefCollection, Choices are:\n"
        "    (oaObject)\n"
        "    (oaAppObjectDefCollection)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaAppObjectDefCollection_tp_dealloc(PyoaAppObjectDefCollectionObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaAppObjectDefCollection_tp_repr(PyObject *ob)
{
    PyParamoaAppObjectDefCollection value;
    int convert_status=PyoaAppObjectDefCollection_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[46];
    sprintf(buffer,"<oaAppObjectDefCollection::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaAppObjectDefCollection_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaAppObjectDefCollection v1;
    PyParamoaAppObjectDefCollection v2;
    int convert_status1=PyoaAppObjectDefCollection_Convert(ob1,&v1);
    int convert_status2=PyoaAppObjectDefCollection_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaAppObjectDefCollection_Convert(PyObject* ob,PyParamoaAppObjectDefCollection* result)
{
    if (ob == NULL) return 1;
    if (PyoaAppObjectDefCollection_Check(ob)) {
        result->SetData(  ((PyoaAppObjectDefCollectionObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaAppObjectDefCollection Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaAppObjectDefCollection_FromoaAppObjectDefCollection(oaAppObjectDefCollection* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaAppObjectDefCollection_Type.tp_alloc(&PyoaAppObjectDefCollection_Type,0);
        if (bself == NULL) return bself;
        PyoaAppObjectDefCollectionObject* self = (PyoaAppObjectDefCollectionObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAppObjectDefCollection_getCount_doc[] = 
"Class: oaAppObjectDefCollection, Function: getCount\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getCount() const\n"
"    Signature: getCount|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of extension types in this collection.\n"
;

static PyObject*
oaAppObjectDefCollection_getCount(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAppObjectDefCollection data;
    int convert_status=PyoaAppObjectDefCollection_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAppObjectDefCollectionObject* self=(PyoaAppObjectDefCollectionObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getCount());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAppObjectDefCollection_includes_doc[] = 
"Class: oaAppObjectDefCollection, Function: includes\n"
"  Paramegers: (oaAppObjectDef)\n"
"    Calls: oaBoolean includes(const oaAppObjectDef* object) const\n"
"    Signature: includes|simple-oaBoolean|cptr-oaAppObjectDef,\n"
"    This function returns true if an extension type, with the name and type of the specified oaAppObjectDef object, is in this collection.\n"
"    appObjectDef\n"
"    The extension type to search for.\n"
;

static PyObject*
oaAppObjectDefCollection_includes(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAppObjectDefCollection data;
    int convert_status=PyoaAppObjectDefCollection_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAppObjectDefCollectionObject* self=(PyoaAppObjectDefCollectionObject*)ob;

    PyParamoaAppObjectDef p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaAppObjectDef_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->includes(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAppObjectDefCollection_isEmpty_doc[] = 
"Class: oaAppObjectDefCollection, Function: isEmpty\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isEmpty() const\n"
"    Signature: isEmpty|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns true if there are no extension types in this collection.\n"
;

static PyObject*
oaAppObjectDefCollection_isEmpty(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAppObjectDefCollection data;
    int convert_status=PyoaAppObjectDefCollection_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAppObjectDefCollectionObject* self=(PyoaAppObjectDefCollectionObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isEmpty());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaAppObjectDefCollection_assign_doc[] = 
"Class: oaAppObjectDefCollection, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaAppObjectDefCollection_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaAppObjectDefCollection data;
  int convert_status=PyoaAppObjectDefCollection_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaAppObjectDefCollection p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaAppObjectDefCollection_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaAppObjectDefCollection_methodlist[] = {
    {"getCount",(PyCFunction)oaAppObjectDefCollection_getCount,METH_VARARGS,oaAppObjectDefCollection_getCount_doc},
    {"includes",(PyCFunction)oaAppObjectDefCollection_includes,METH_VARARGS,oaAppObjectDefCollection_includes_doc},
    {"isEmpty",(PyCFunction)oaAppObjectDefCollection_isEmpty,METH_VARARGS,oaAppObjectDefCollection_isEmpty_doc},
    {"assign",(PyCFunction)oaAppObjectDefCollection_tp_assign,METH_VARARGS,oaAppObjectDefCollection_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAppObjectDefCollection_doc[] = 
"Class: oaAppObjectDefCollection\n"
"  The oaAppObjectDefCollection class stores a collection of extension types. Use the oaAppObjectDefIter class to iterate over the extension types in this collection.\n"
"Constructors:\n"
"  Paramegers: (oaObject)\n"
"    Calls: oaAppObjectDefCollection(const oaObject* database)\n"
"    Signature: oaAppObjectDefCollection||cptr-oaObject,\n"
"    This function constructs an oaAppObjectDefCollection objects using the extension types that have a value on the given object.\n"
"    database\n"
"    The database to obtain the extension types from\n"
"  Paramegers: (oaAppObjectDefCollection)\n"
"    Calls: oaAppObjectDefCollection(const oaAppObjectDefCollection& c)\n"
"    Signature: oaAppObjectDefCollection||cref-oaAppObjectDefCollection,\n"
"    This function constructs an oaAppObjectDefCollection object based on the given collection.\n"
"    c\n"
"    The collection of oaAppObjectDef objects to iterate over.\n"
"  Paramegers: (oaAppObjectDefCollection)\n"
"    Calls: (const oaAppObjectDefCollection&)\n"
"    Signature: oaAppObjectDefCollection||cref-oaAppObjectDefCollection,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaAppObjectDefCollection_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaAppObjectDefCollection",
    sizeof(PyoaAppObjectDefCollectionObject),
    0,
    (destructor)oaAppObjectDefCollection_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaAppObjectDefCollection_tp_compare,	/* tp_compare */
    (reprfunc)oaAppObjectDefCollection_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaAppObjectDefCollection_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaAppObjectDefCollection_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaAppObjectDefCollection_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaAppObjectDefCollection_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaAppObjectDefCollection_Type)<0) {
      printf("** PyType_Ready failed for: oaAppObjectDefCollection\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaAppObjectDefCollection",
           (PyObject*)(&PyoaAppObjectDefCollection_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaAppObjectDefCollection\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaAppObjectModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaAppObjectModTypeEnum_Convert(PyObject* ob,PyParamoaAppObjectModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaAppObjectModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaAppObjectModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaAppObjectModTypeEnum_FromoaAppObjectModTypeEnum(oaAppObjectModTypeEnum ob)
{

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaAppObjectModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaAppObjectModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaAppObjectModTypeEnum_FromoaAppObjectModTypeEnum(oaAppObjectModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaAppObjectModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaAppObjectModTypeEnum_doc[] =
"Type convert function for enum: oaAppObjectModTypeEnum";
                               
static PyMethodDef PyoaAppObjectModTypeEnum_method =
  {"oaAppObjectModTypeEnum",(PyCFunction)PyoaAppObjectModTypeEnum_TypeFunction,METH_VARARGS,oaAppObjectModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaAppObjectModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaAppObjectModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaAppObjectModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaAppObjectModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaAppProp
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaAppProp_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaAppProp_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaAppPropObject* self = (PyoaAppPropObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaAppProp)
    {
        PyParamoaAppProp p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaAppProp_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaAppProp, Choices are:\n"
        "    (oaAppProp)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaAppProp_tp_dealloc(PyoaAppPropObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaAppProp_tp_repr(PyObject *ob)
{
    PyParamoaAppProp value;
    int convert_status=PyoaAppProp_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaAppProp::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaString sresult;
        value.DataCall()->getName(sresult);
    
        char addr[31];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaAppProp::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaAppProp_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaAppProp v1;
    PyParamoaAppProp v2;
    int convert_status1=PyoaAppProp_Convert(ob1,&v1);
    int convert_status2=PyoaAppProp_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaAppProp_Convert(PyObject* ob,PyParamoaAppProp* result)
{
    if (ob == NULL) return 1;
    if (PyoaAppProp_Check(ob)) {
        result->SetData( (oaAppProp**) ((PyoaAppPropObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaAppProp Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaAppProp_FromoaAppProp(oaAppProp** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaAppProp* data=*value;
        PyObject* bself = PyoaAppProp_Type.tp_alloc(&PyoaAppProp_Type,0);
        if (bself == NULL) return bself;
        PyoaAppPropObject* self = (PyoaAppPropObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaAppProp_FromoaAppProp(oaAppProp* data)
{
    if (data) {
       PyObject* bself = PyoaAppProp_Type.tp_alloc(&PyoaAppProp_Type,0);
       if (bself == NULL) return bself;
       PyoaAppPropObject* self = (PyoaAppPropObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAppProp_getAppType_doc[] = 
"Class: oaAppProp, Function: getAppType\n"
"  Paramegers: (oaString)\n"
"    Calls: void getAppType(oaString& appType) const\n"
"    Signature: getAppType|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function returns the application type of this property.\n"
;

static PyObject*
oaAppProp_getAppType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAppProp data;
    int convert_status=PyoaAppProp_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAppPropObject* self=(PyoaAppPropObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getAppType(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAppProp_getSize_doc[] = 
"Class: oaAppProp, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size of this property value.\n"
;

static PyObject*
oaAppProp_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAppProp data;
    int convert_status=PyoaAppProp_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAppPropObject* self=(PyoaAppPropObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAppProp_getValue_doc[] = 
"Class: oaAppProp, Function: getValue\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getValue(oaByte* value) const\n"
"    Signature: getValue|void-void|ptr-oaByte,\n"
"    This function returns the value of this property.\n"
;

static PyObject*
oaAppProp_getValue(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAppProp data;
    int convert_status=PyoaAppProp_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAppPropObject* self=(PyoaAppPropObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match property size");
            return NULL;
        }
        data.DataCall()->getValue(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAppProp_setValue_doc[] = 
"Class: oaAppProp, Function: setValue\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void setValue(const oaByte* value)\n"
"    Signature: setValue|void-void|simple-oaUInt4,cptr-oaByte,\n"
"    This function sets the value of this property.\n"
;

static PyObject*
oaAppProp_setValue(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAppProp data;
    int convert_status=PyoaAppProp_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAppPropObject* self=(PyoaAppPropObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        data.DataCall()->setValue(p1.Len(),p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAppProp_isNull_doc[] =
"Class: oaAppProp, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaAppProp_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaAppProp data;
    int convert_status=PyoaAppProp_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaAppProp_assign_doc[] = 
"Class: oaAppProp, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaAppProp_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaAppProp data;
  int convert_status=PyoaAppProp_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaAppProp p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaAppProp_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaAppProp_methodlist[] = {
    {"getAppType",(PyCFunction)oaAppProp_getAppType,METH_VARARGS,oaAppProp_getAppType_doc},
    {"getSize",(PyCFunction)oaAppProp_getSize,METH_VARARGS,oaAppProp_getSize_doc},
    {"getValue",(PyCFunction)oaAppProp_getValue,METH_VARARGS,oaAppProp_getValue_doc},
    {"setValue",(PyCFunction)oaAppProp_setValue,METH_VARARGS,oaAppProp_setValue_doc},
    {"isNull",(PyCFunction)oaAppProp_tp_isNull,METH_VARARGS,oaAppProp_isNull_doc},
    {"assign",(PyCFunction)oaAppProp_tp_assign,METH_VARARGS,oaAppProp_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAppProp_doc[] = 
"Class: oaAppProp\n"
"  The oaAppProp class is an application-specific property whose value is an arbitrary set of bytes. The database does not provide any interpretation of those bytes. If the value stored on an oaAppProp instance contains multi-byte fields (such as an integer), the database cannot do byte-swapping for these fields if they are written on one type of machine and read on another type of machine.\n"
"  Properties are application-defined values that can be added to any managed object in oaDesign , oaTech , and oaWafer databases except for the following paged objects: oaDevice , oaNode , oaParasiticNetwork , and oaSubNetwork .\n"
"  To create properties on DM Objects, create the corresponding oaDMData object (using oaLibDMData::open , oaCellDMData::open , oaViewDMData::open , or oaCellViewDMData::open ), then create properties on that oaDMData object.\n"
"  See oaProp for a general discussion of properties.\n"
"Constructors:\n"
"  Paramegers: (oaAppProp)\n"
"    Calls: (const oaAppProp&)\n"
"    Signature: oaAppProp||cref-oaAppProp,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaAppProp_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaAppProp",
    sizeof(PyoaAppPropObject),
    0,
    (destructor)oaAppProp_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaAppProp_tp_compare,	/* tp_compare */
    (reprfunc)oaAppProp_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaAppProp_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaAppProp_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaProp_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaAppProp_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAppProp_static_create_doc[] = 
"Class: oaAppProp, Function: create\n"
"  Paramegers: (oaObject,oaString,oaString,[oaByte])\n"
"    Calls: oaAppProp* create(oaObject* object,const oaString& name,const oaString& appType,const oaByte* value)\n"
"    Signature: create|ptr-oaAppProp|ptr-oaObject,cref-oaString,cref-oaString,simple-oaUInt4,cptr-oaByte,\n"
"    This function creates an application property with the specified attributes. The specified name is checked to verify it is unique for properties on the specified object .\n"
"    oacPropNameUsed\n"
"    oacInvalidObjForProp\n"
;

static PyObject*
oaAppProp_static_create(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObject p1;
    PyParamoaString p2;
    PyParamoaString p3;
    PyParamoaByte_Array p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaObject_Convert,&p1,
          &PyoaString_Convert,&p2,
          &PyoaString_Convert,&p3,
          &PyoaByte_Array_Convert,&p4)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaAppPropp result= (oaAppProp::create(p1.Data(),p2.Data(),p3.Data(),p4.Len(),p4.Data()));
        return PyoaAppProp_FromoaAppProp(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaAppProp_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaAppProp_static_create,METH_VARARGS,oaAppProp_static_create_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaAppProp_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaAppProp_Type)<0) {
      printf("** PyType_Ready failed for: oaAppProp\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaAppProp",
           (PyObject*)(&PyoaAppProp_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaAppProp\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaAppProp_Type.tp_dict;
    for(method=oaAppProp_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArc
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArc_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArc_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArcObject* self = (PyoaArcObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaArc)
    {
        PyParamoaArc p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaArc_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArc, Choices are:\n"
        "    (oaArc)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArc_tp_dealloc(PyoaArcObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArc_tp_repr(PyObject *ob)
{
    PyParamoaArc value;
    int convert_status=PyoaArc_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[27];
    sprintf(buffer,"<oaArc::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArc_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArc v1;
    PyParamoaArc v2;
    int convert_status1=PyoaArc_Convert(ob1,&v1);
    int convert_status2=PyoaArc_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArc_Convert(PyObject* ob,PyParamoaArc* result)
{
    if (ob == NULL) return 1;
    if (PyoaArc_Check(ob)) {
        result->SetData( (oaArc**) ((PyoaArcObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArc Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArc_FromoaArc(oaArc** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaArc* data=*value;
        PyObject* bself = PyoaArc_Type.tp_alloc(&PyoaArc_Type,0);
        if (bself == NULL) return bself;
        PyoaArcObject* self = (PyoaArcObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaArc_FromoaArc(oaArc* data)
{
    if (data) {
       PyObject* bself = PyoaArc_Type.tp_alloc(&PyoaArc_Type,0);
       if (bself == NULL) return bself;
       PyoaArcObject* self = (PyoaArcObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArc_convertToLine_doc[] = 
"Class: oaArc, Function: convertToLine\n"
"  Paramegers: ()\n"
"    Calls: oaLine* convertToLine()\n"
"    Signature: convertToLine|ptr-oaLine|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function converts this arc to an oaLine using the specified number of sides.\n"
"    numSides\n"
"    Number of segments used to represent the arc as a line, which must be at least two; the default number of sides is 16.\n"
"    oacArcNumSidesInvalid\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaLine* convertToLine(oaUInt4 numSides)\n"
"    Signature: convertToLine|ptr-oaLine|simple-oaUInt4,\n"
"    This function converts this arc to an oaLine using the specified number of sides.\n"
"    numSides\n"
"    Number of segments used to represent the arc as a line, which must be at least two; the default number of sides is 16.\n"
"    oacArcNumSidesInvalid\n"
;

static PyObject*
oaArc_convertToLine(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArc data;
    int convert_status=PyoaArc_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArcObject* self=(PyoaArcObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaLinep result= (data.DataCall()->convertToLine());
            return PyoaLine_FromoaLine(result);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaLinep result= (data.DataCall()->convertToLine(p1.Data()));
            return PyoaLine_FromoaLine(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArc, function: convertToLine, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArc_getEllipseBBox_doc[] = 
"Class: oaArc, Function: getEllipseBBox\n"
"  Paramegers: (oaBox)\n"
"    Calls: void getEllipseBBox(oaBox& bBox) const\n"
"    Signature: getEllipseBBox|void-void|ref-oaBox,\n"
"    BrowseData: 0,oaBox\n"
"    This function returns the ellipse bounding box associated with this arc.\n"
"    bBox\n"
"    Returned ellipse bounding box.\n"
;

static PyObject*
oaArc_getEllipseBBox(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArc data;
    int convert_status=PyoaArc_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArcObject* self=(PyoaArcObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBox p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBox_Convert,&p1)) {
        data.DataCall()->getEllipseBBox(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArc_getPoints_doc[] = 
"Class: oaArc, Function: getPoints\n"
"  Paramegers: (oaPointArray)\n"
"    Calls: void getPoints(oaPointArray& points) const\n"
"    Signature: getPoints|void-void|ref-oaPointArray,simple-oaUInt4,\n"
"    BrowseData: 0,oaPointArray\n"
"    This function returns a point array that delineates this arc. numSegs specifies the number of segments to use to delineate the arc, and determines the number of points returned in the pointArray -- specifically, the returned pointArray will contain numSegs+1 points.\n"
"    See oaArc::genPoints for a static function that generates and returns a point array that delineates an arc for a specified set of arc parameters.\n"
"    points\n"
"    Returned series of points delineating a line that represents this arc (returned pointArray will contain numSegs+1 points).\n"
"    numSegs\n"
"    Number of segments to use to delineate the arc.\n"
"  Paramegers: (oaPointArray,oaUInt4)\n"
"    Calls: void getPoints(oaPointArray& points,oaUInt4 numSegs) const\n"
"    Signature: getPoints|void-void|ref-oaPointArray,simple-oaUInt4,\n"
"    This function returns a point array that delineates this arc. numSegs specifies the number of segments to use to delineate the arc, and determines the number of points returned in the pointArray -- specifically, the returned pointArray will contain numSegs+1 points.\n"
"    See oaArc::genPoints for a static function that generates and returns a point array that delineates an arc for a specified set of arc parameters.\n"
"    points\n"
"    Returned series of points delineating a line that represents this arc (returned pointArray will contain numSegs+1 points).\n"
"    numSegs\n"
"    Number of segments to use to delineate the arc.\n"
;

static PyObject*
oaArc_getPoints(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArc data;
    int convert_status=PyoaArc_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArcObject* self=(PyoaArcObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaPointArray)
    {
        PyParamoaPointArray p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaPointArray_Convert,&p1)) {
            data.DataCall()->getPoints(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaPointArray,oaUInt4)
    {
        PyParamoaPointArray p1;
        PyParamoaUInt4 p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaPointArray_Convert,&p1,
              &PyoaUInt4_Convert,&p2)) {
            data.DataCall()->getPoints(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArc, function: getPoints, Choices are:\n"
        "    (oaPointArray)\n"
        "    (oaPointArray,oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArc_getStartAngle_doc[] = 
"Class: oaArc, Function: getStartAngle\n"
"  Paramegers: ()\n"
"    Calls: oaDouble getStartAngle() const\n"
"    Signature: getStartAngle|simple-oaDouble|\n"
"    BrowseData: 1\n"
"    This function retrieves the start angle of this arc in radians.\n"
;

static PyObject*
oaArc_getStartAngle(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArc data;
    int convert_status=PyoaArc_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArcObject* self=(PyoaArcObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaDouble result= (data.DataCall()->getStartAngle());
        return PyoaDouble_FromoaDouble(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArc_getStopAngle_doc[] = 
"Class: oaArc, Function: getStopAngle\n"
"  Paramegers: ()\n"
"    Calls: oaDouble getStopAngle() const\n"
"    Signature: getStopAngle|simple-oaDouble|\n"
"    BrowseData: 1\n"
"    This function retrieves the stop angle of this arc in radians.\n"
;

static PyObject*
oaArc_getStopAngle(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArc data;
    int convert_status=PyoaArc_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArcObject* self=(PyoaArcObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaDouble result= (data.DataCall()->getStopAngle());
        return PyoaDouble_FromoaDouble(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArc_set_doc[] = 
"Class: oaArc, Function: set\n"
"  Paramegers: (oaBox,oaDouble,oaDouble)\n"
"    Calls: void set(const oaBox& ellipseBBox,oaDouble startAngle,oaDouble stopAngle)\n"
"    Signature: set|void-void|cref-oaBox,simple-oaDouble,simple-oaDouble,\n"
"    This function resets the ellipse bBox and start/stop angles of this arc to the specified values.\n"
"    ellipseBBox\n"
"    Ellipse bounding box to set on this arc.\n"
"    startAngle\n"
"    Start angle to set in radians.\n"
"    stopAngle\n"
"    Stop angle in radians\n"
"    oacArcEllipseBBoxInvalid\n"
"    oacArcAnglesInvalid\n"
;

static PyObject*
oaArc_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArc data;
    int convert_status=PyoaArc_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArcObject* self=(PyoaArcObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBox p1;
    PyParamoaDouble p2;
    PyParamoaDouble p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaBox_Convert,&p1,
          &PyoaDouble_Convert,&p2,
          &PyoaDouble_Convert,&p3)) {
        data.DataCall()->set(p1.Data(),p2.Data(),p3.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArc_isNull_doc[] =
"Class: oaArc, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaArc_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaArc data;
    int convert_status=PyoaArc_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaArc_assign_doc[] = 
"Class: oaArc, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArc_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArc data;
  int convert_status=PyoaArc_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArc p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArc_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArc_methodlist[] = {
    {"convertToLine",(PyCFunction)oaArc_convertToLine,METH_VARARGS,oaArc_convertToLine_doc},
    {"getEllipseBBox",(PyCFunction)oaArc_getEllipseBBox,METH_VARARGS,oaArc_getEllipseBBox_doc},
    {"getPoints",(PyCFunction)oaArc_getPoints,METH_VARARGS,oaArc_getPoints_doc},
    {"getStartAngle",(PyCFunction)oaArc_getStartAngle,METH_VARARGS,oaArc_getStartAngle_doc},
    {"getStopAngle",(PyCFunction)oaArc_getStopAngle,METH_VARARGS,oaArc_getStopAngle_doc},
    {"set",(PyCFunction)oaArc_set,METH_VARARGS,oaArc_set_doc},
    {"isNull",(PyCFunction)oaArc_tp_isNull,METH_VARARGS,oaArc_isNull_doc},
    {"assign",(PyCFunction)oaArc_tp_assign,METH_VARARGS,oaArc_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArc_doc[] = 
"Class: oaArc\n"
"  The oaArc class implements an arc shape. An arc is a segment on the circumference of an ellipse, and can be defined by three parameters: an ellipse bounding box, a start angle, and a stop angle (these parameters are shown in the figures below). The oaArc::create function uses these three input parameters to create and return a pointer to an arc segment.\n"
"  How Arcs are Specified in OpenAccess\n"
"  In OpenAccess, arc angles are specified in positive radians, and are defined counterclockwise from a reference line that emanates from the center of the ellipse on which the arc is defined (at the intersection of imaginary x/y axes that pass through the ellipse center point). The positive (right-side) x axis is at 0 radians; the positive (upper) y axis is at pi/2 radians; and the left x axis is at pi radians. In OpenAccess, the arc sweep angle -- that is, the stop angle minus the start angle -- must be equal to or less than pi radians (equal to or less than 180 degrees).\n"
"  The figures below show two valid arc segments with sweep angles that do not exceed pi radians (180 degrees). Note that the figures also depict a bounding box for each arc segment -- this is a box that fully encloses the arc segment and intersects the arc at its start and stop angles. This arc bounding box, together with the ellipse bounding box, can be input to oaArc::calcArc to obtain the arc start and stop angles for input to the oaArc::create function. Also, oaArc::calcBBox will return the arc bounding box when passed the ellipse bounding box and the arc start and stop angles.\n"
"Constructors:\n"
"  Paramegers: (oaArc)\n"
"    Calls: (const oaArc&)\n"
"    Signature: oaArc||cref-oaArc,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArc_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArc",
    sizeof(PyoaArcObject),
    0,
    (destructor)oaArc_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArc_tp_compare,	/* tp_compare */
    (reprfunc)oaArc_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArc_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArc_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaShape_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArc_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArc_static_calcArc_doc[] = 
"Class: oaArc, Function: calcArc\n"
"  Paramegers: (oaPoint,oaPoint,oaPoint,oaBox,oaDouble,oaDouble)\n"
"    Calls: void calcArc(const oaPoint& p1,const oaPoint& p2,const oaPoint& p3,oaBox& ellipseBBox,oaDouble& startAngle,oaDouble& stopAngle)\n"
"    Signature: calcArc|void-void|cref-oaPoint,cref-oaPoint,cref-oaPoint,ref-oaBox,ref-oaDouble,ref-oaDouble,\n"
"    This utility function converts input points, p1 , p2 , and p3 into return parameters, ellipseBBox , startAngle , and stopAngle . The returned values are needed to create an arc with oaArc::create . OpenAccess verifies that the three input points represent a valid arc.\n"
"    The order in which the points are supplied is not relevant. OpenAccess determines the appropriate return parameters based on the rules for arc sweep angles. Refer to How Arcs are Specified in OpenAccess for more information.\n"
"    p1\n"
"    Location of the first oaPoint on the arc.\n"
"    p2\n"
"    Location of the second oaPoint on the arc.\n"
"    p3\n"
"    Location of the third oaPoint on the arc.\n"
"    ellipseBBox\n"
"    Returned ellipse bounding box.\n"
"    startAngle\n"
"    Returned starting angle of the arc in radians.\n"
"    stopAngle\n"
"    Returned ending angle of the arc in radians.\n"
"    oacArcPointsColinear\n"
"    oacArcTooLarge\n"
"  Paramegers: (oaBox,oaBox,oaDouble,oaDouble)\n"
"    Calls: void calcArc(const oaBox& ellipseBBox,oaBox& bBox,oaDouble& startAngle,oaDouble& stopAngle)\n"
"    Signature: calcArc|void-void|cref-oaBox,ref-oaBox,ref-oaDouble,ref-oaDouble,\n"
"    This utility function takes the specified ellipseBBox and bBox as input parameters and fills in the startAngle and stopAngle parameters (these latter two parameters along with the ellipseBBox are needed to create an arc with oaArc::create ).\n"
"    The input parameters are checked to verify that they represent a valid arc.\n"
"    ellipseBBox\n"
"    Ellipse bounding box.\n"
"    bBox\n"
"    Arc bounding box, which can be a minimum or larger arc bounding box as long as it intersects the arc at its ellipse start and stop angles; OpenAccess will trim the box to its minimum size.\n"
"    startAngle\n"
"    Returned starting angle of the arc in radians.\n"
"    stopAngle\n"
"    Returned stopping angle of the arc in radians.\n"
"    oacArcWrongNumIntercepts\n"
;

static PyObject*
oaArc_static_calcArc(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaPoint,oaPoint,oaPoint,oaBox,oaDouble,oaDouble)
    {
        PyParamoaPoint p1;
        PyParamoaPoint p2;
        PyParamoaPoint p3;
        PyParamoaBox p4;
        PyParamoaDouble p5;
        PyParamoaDouble p6;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&",
              &PyoaPoint_Convert,&p1,
              &PyoaPoint_Convert,&p2,
              &PyoaPoint_Convert,&p3,
              &PyoaBox_Convert,&p4,
              &PyoaDouble_Convert,&p5,
              &PyoaDouble_Convert,&p6)) {
            oaArc::calcArc(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaBox,oaBox,oaDouble,oaDouble)
    {
        PyParamoaBox p1;
        PyParamoaBox p2;
        PyParamoaDouble p3;
        PyParamoaDouble p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaBox_Convert,&p1,
              &PyoaBox_Convert,&p2,
              &PyoaDouble_Convert,&p3,
              &PyoaDouble_Convert,&p4)) {
            oaArc::calcArc(p1.Data(),p2.Data(),p3.Data(),p4.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArc, function: calcArc, Choices are:\n"
        "    (oaPoint,oaPoint,oaPoint,oaBox,oaDouble,oaDouble)\n"
        "    (oaBox,oaBox,oaDouble,oaDouble)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArc_static_calcBBox_doc[] = 
"Class: oaArc, Function: calcBBox\n"
"  Paramegers: (oaBox,oaDouble,oaDouble,oaBox)\n"
"    Calls: void calcBBox(const oaBox& ellipseBBox,oaDouble startAngle,oaDouble stopAngle,oaBox& bBox)\n"
"    Signature: calcBBox|void-void|cref-oaBox,simple-oaDouble,simple-oaDouble,ref-oaBox,\n"
"    This utility function calculates and returns the bBox of an arc (the arc bounding box) based on the specified ellipseBBox , startAngle and stopAngle parameters. The input parameters are checked to verify they represent a valid arc.\n"
"    ellipseBBox\n"
"    Ellipse bounding box.\n"
"    startAngle\n"
"    Starting angle of the arc in radians.\n"
"    stopAngle\n"
"    Ending angle of the arc in radians.\n"
"    bBox\n"
"    Returned arc bounding box; OpenAccess trims the box to its minimum size.\n"
;

static PyObject*
oaArc_static_calcBBox(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox p1;
    PyParamoaDouble p2;
    PyParamoaDouble p3;
    PyParamoaBox p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaBox_Convert,&p1,
          &PyoaDouble_Convert,&p2,
          &PyoaDouble_Convert,&p3,
          &PyoaBox_Convert,&p4)) {
        oaArc::calcBBox(p1.Data(),p2.Data(),p3.Data(),p4.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArc_static_create_doc[] = 
"Class: oaArc, Function: create\n"
"  Paramegers: (oaBlock,oaLayerNum,oaPurposeNum,oaBox,oaDouble,oaDouble)\n"
"    Calls: oaArc* create(oaBlock* block,oaLayerNum layerNum,oaPurposeNum purposeNum,const oaBox& ellipseBBox,oaDouble startAngle,oaDouble stopAngle)\n"
"    Signature: create|ptr-oaArc|ptr-oaBlock,simple-oaLayerNum,simple-oaPurposeNum,cref-oaBox,simple-oaDouble,simple-oaDouble,\n"
"    This function creates an arc in the specified block with the specified layer/purpose pair using the specified ellipseBBox , startAngle , and endAngle parameters. The latter three parameters are checked to verify that they represent a valid arc.\n"
"    Note that the ellipseBBox cannot be arealess, stopAngle minus startAngle must be equal to or less than pi radians (180 degrees) and must be greater than 0 (startAngle and stopAngle must be positive and stopAngle must be greater than startAngle).\n"
"    block\n"
"    Pointer to the block in which the arc will be created.\n"
"    layerNum\n"
"    Layer number for the arc.\n"
"    purposeNum\n"
"    Purpose number for the arc.\n"
"    ellipseBBox\n"
"    Ellipse bounding box for the arc.\n"
"    startAngle\n"
"    Starting angle of the arc in radians.\n"
"    stopAngle\n"
"    Ending angle of the arc in radians.\n"
"    oacArcEllipseBBoxInvalid\n"
"    oacArcAnglesInvalid\n"
;

static PyObject*
oaArc_static_create(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaLayerNum p2;
    PyParamoaPurposeNum p3;
    PyParamoaBox p4;
    PyParamoaDouble p5;
    PyParamoaDouble p6;
    if (PyArg_ParseTuple(args,"O&O&O&O&O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaLayerNum_Convert,&p2,
          &PyoaPurposeNum_Convert,&p3,
          &PyoaBox_Convert,&p4,
          &PyoaDouble_Convert,&p5,
          &PyoaDouble_Convert,&p6)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaArcp result= (oaArc::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data()));
        return PyoaArc_FromoaArc(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArc_static_genPoints_doc[] = 
"Class: oaArc, Function: genPoints\n"
"  Paramegers: (oaBox,oaDouble,oaDouble,oaUInt4,oaPointArray)\n"
"    Calls: void genPoints(const oaBox& ellipseBBox,oaDouble startAngle,oaDouble stopAngle,oaUInt4 numEdges,oaPointArray& boundary)\n"
"    Signature: genPoints|void-void|cref-oaBox,simple-oaDouble,simple-oaDouble,simple-oaUInt4,ref-oaPointArray,\n"
"    This function calculates and returns a point array in points that delineates the arc specified by the ellipseBBox , startAngle , and stopAngle parameters. The number of edges delineated by the point array are specified by numEdges . The point array delineates the arc by representing it as a sequence of points connecting virtual line segments that approximate the arc.\n"
"    See oaArc::getPoints for a function that generates and returns a point array that delineates an existing oaArc object.\n"
"    ellipseBBox\n"
"    Ellipse bounding box.\n"
"    startAngle\n"
"    Starting angle of the arc in radians.\n"
"    stopAngle\n"
"    Ending angle of the arc in radians.\n"
"    numEdges\n"
"    Number of edges to use to delineate the arc.\n"
"    points\n"
"    Returned point array that represents the delineated arc.\n"
;

static PyObject*
oaArc_static_genPoints(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBox p1;
    PyParamoaDouble p2;
    PyParamoaDouble p3;
    PyParamoaUInt4 p4;
    PyParamoaPointArray p5;
    if (PyArg_ParseTuple(args,"O&O&O&O&O&",
          &PyoaBox_Convert,&p1,
          &PyoaDouble_Convert,&p2,
          &PyoaDouble_Convert,&p3,
          &PyoaUInt4_Convert,&p4,
          &PyoaPointArray_Convert,&p5)) {
        oaArc::genPoints(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaArc_staticmethodlist[] = {
    {"static_calcArc",(PyCFunction)oaArc_static_calcArc,METH_VARARGS,oaArc_static_calcArc_doc},
    {"static_calcBBox",(PyCFunction)oaArc_static_calcBBox,METH_VARARGS,oaArc_static_calcBBox_doc},
    {"static_create",(PyCFunction)oaArc_static_create,METH_VARARGS,oaArc_static_create_doc},
    {"static_genPoints",(PyCFunction)oaArc_static_genPoints,METH_VARARGS,oaArc_static_genPoints_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArc_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArc_Type)<0) {
      printf("** PyType_Ready failed for: oaArc\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArc",
           (PyObject*)(&PyoaArc_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArc\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaArc_Type.tp_dict;
    for(method=oaArc_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaAreaBlockage
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaAreaBlockage_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaAreaBlockage_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaAreaBlockageObject* self = (PyoaAreaBlockageObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaAreaBlockage)
    {
        PyParamoaAreaBlockage p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaAreaBlockage_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaAreaBlockage, Choices are:\n"
        "    (oaAreaBlockage)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaAreaBlockage_tp_dealloc(PyoaAreaBlockageObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaAreaBlockage_tp_repr(PyObject *ob)
{
    PyParamoaAreaBlockage value;
    int convert_status=PyoaAreaBlockage_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[36];
    sprintf(buffer,"<oaAreaBlockage::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaAreaBlockage_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaAreaBlockage v1;
    PyParamoaAreaBlockage v2;
    int convert_status1=PyoaAreaBlockage_Convert(ob1,&v1);
    int convert_status2=PyoaAreaBlockage_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaAreaBlockage_Convert(PyObject* ob,PyParamoaAreaBlockage* result)
{
    if (ob == NULL) return 1;
    if (PyoaAreaBlockage_Check(ob)) {
        result->SetData( (oaAreaBlockage**) ((PyoaAreaBlockageObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaAreaBlockage Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaAreaBlockage_FromoaAreaBlockage(oaAreaBlockage** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaAreaBlockage* data=*value;
        PyObject* bself = PyoaAreaBlockage_Type.tp_alloc(&PyoaAreaBlockage_Type,0);
        if (bself == NULL) return bself;
        PyoaAreaBlockageObject* self = (PyoaAreaBlockageObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaAreaBlockage_FromoaAreaBlockage(oaAreaBlockage* data)
{
    if (data) {
       PyObject* bself = PyoaAreaBlockage_Type.tp_alloc(&PyoaAreaBlockage_Type,0);
       if (bself == NULL) return bself;
       PyoaAreaBlockageObject* self = (PyoaAreaBlockageObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAreaBlockage_setPoints_doc[] = 
"Class: oaAreaBlockage, Function: setPoints\n"
"  Paramegers: (oaPointArray)\n"
"    Calls: void setPoints(const oaPointArray& points)\n"
"    Signature: setPoints|void-void|cref-oaPointArray,\n"
"    This function updates the shape of the blockages to the shape specified by the pointArray\n"
"    points\n"
"    The pointArray describing the new shape of the blockage\n"
"    oacBlockageHasExtraPoints\n"
"    oacBlockageTooFewPoints\n"
;

static PyObject*
oaAreaBlockage_setPoints(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAreaBlockage data;
    int convert_status=PyoaAreaBlockage_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAreaBlockageObject* self=(PyoaAreaBlockageObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaPointArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaPointArray_Convert,&p1)) {
        data.DataCall()->setPoints(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAreaBlockage_transform_doc[] = 
"Class: oaAreaBlockage, Function: transform\n"
"  Paramegers: (oaDouble,oaDouble)\n"
"    Calls: void transform(oaDouble scale,oaDouble angle)\n"
"    Signature: transform|void-void|simple-oaDouble,simple-oaDouble,\n"
"    This function transforms this blockage by the specified scale factor and rotation angle. If this blockage is a leader in a group, every object in the group is moved with the specified transform.\n"
"    scale\n"
"    The scale for the transformation\n"
"    angle\n"
"    The angle of the transformation\n"
;

static PyObject*
oaAreaBlockage_transform(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAreaBlockage data;
    int convert_status=PyoaAreaBlockage_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAreaBlockageObject* self=(PyoaAreaBlockageObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDouble p1;
    PyParamoaDouble p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaDouble_Convert,&p1,
          &PyoaDouble_Convert,&p2)) {
        data.DataCall()->transform(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAreaBlockage_isNull_doc[] =
"Class: oaAreaBlockage, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaAreaBlockage_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaAreaBlockage data;
    int convert_status=PyoaAreaBlockage_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaAreaBlockage_assign_doc[] = 
"Class: oaAreaBlockage, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaAreaBlockage_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaAreaBlockage data;
  int convert_status=PyoaAreaBlockage_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaAreaBlockage p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaAreaBlockage_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaAreaBlockage_methodlist[] = {
    {"setPoints",(PyCFunction)oaAreaBlockage_setPoints,METH_VARARGS,oaAreaBlockage_setPoints_doc},
    {"transform",(PyCFunction)oaAreaBlockage_transform,METH_VARARGS,oaAreaBlockage_transform_doc},
    {"isNull",(PyCFunction)oaAreaBlockage_tp_isNull,METH_VARARGS,oaAreaBlockage_isNull_doc},
    {"assign",(PyCFunction)oaAreaBlockage_tp_assign,METH_VARARGS,oaAreaBlockage_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAreaBlockage_doc[] = 
"Class: oaAreaBlockage\n"
"  An area blockage is a type of blockage representing an area. The shape of a blockage is described using an oaPointArray . Coincident and collinear points are illegal in the point array for an area blockage.\n"
"  The area blockage is most commonly used to prevent standard cells from being placed within a certain area.\n"
"Constructors:\n"
"  Paramegers: (oaAreaBlockage)\n"
"    Calls: (const oaAreaBlockage&)\n"
"    Signature: oaAreaBlockage||cref-oaAreaBlockage,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaAreaBlockage_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaAreaBlockage",
    sizeof(PyoaAreaBlockageObject),
    0,
    (destructor)oaAreaBlockage_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaAreaBlockage_tp_compare,	/* tp_compare */
    (reprfunc)oaAreaBlockage_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaAreaBlockage_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaAreaBlockage_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaBlockage_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaAreaBlockage_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAreaBlockage_static_create_doc[] = 
"Class: oaAreaBlockage, Function: create\n"
"  Paramegers: (oaBlock,oaPointArray)\n"
"    Calls: oaAreaBlockage* create(oaBlock* block,const oaPointArray& points)\n"
"    Signature: create|ptr-oaAreaBlockage|ptr-oaBlock,cref-oaPointArray,ptr-oaBlockObject,\n"
"    This is the constructor for an area blockage.\n"
"    block\n"
"    The block in which to create the area blockage\n"
"    points\n"
"    The pointArray describing the shape of the blockage\n"
"    owner\n"
"    The optional owner of the blockage\n"
"    oacBlockageHasExtraPoints\n"
"    oacBlockageTooFewPoints\n"
"    oacInvalidBlockageOwner\n"
"  Paramegers: (oaBlock,oaPointArray,oaBlockObject)\n"
"    Calls: oaAreaBlockage* create(oaBlock* block,const oaPointArray& points,oaBlockObject* owner)\n"
"    Signature: create|ptr-oaAreaBlockage|ptr-oaBlock,cref-oaPointArray,ptr-oaBlockObject,\n"
"    This is the constructor for an area blockage.\n"
"    block\n"
"    The block in which to create the area blockage\n"
"    points\n"
"    The pointArray describing the shape of the blockage\n"
"    owner\n"
"    The optional owner of the blockage\n"
"    oacBlockageHasExtraPoints\n"
"    oacBlockageTooFewPoints\n"
"    oacInvalidBlockageOwner\n"
;

static PyObject*
oaAreaBlockage_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaBlock,oaPointArray)
    {
        PyParamoaBlock p1;
        PyParamoaPointArray p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaPointArray_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaAreaBlockagep result= (oaAreaBlockage::create(p1.Data(),p2.Data()));
            return PyoaAreaBlockage_FromoaAreaBlockage(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaPointArray,oaBlockObject)
    {
        PyParamoaBlock p1;
        PyParamoaPointArray p2;
        PyParamoaBlockObject p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaPointArray_Convert,&p2,
              &PyoaBlockObject_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p3.Data(),3)) return NULL;
            oaAreaBlockagep result= (oaAreaBlockage::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaAreaBlockage_FromoaAreaBlockage(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaAreaBlockage, function: create, Choices are:\n"
        "    (oaBlock,oaPointArray)\n"
        "    (oaBlock,oaPointArray,oaBlockObject)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaAreaBlockage_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaAreaBlockage_static_create,METH_VARARGS,oaAreaBlockage_static_create_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaAreaBlockage_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaAreaBlockage_Type)<0) {
      printf("** PyType_Ready failed for: oaAreaBlockage\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaAreaBlockage",
           (PyObject*)(&PyoaAreaBlockage_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaAreaBlockage\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaAreaBlockage_Type.tp_dict;
    for(method=oaAreaBlockage_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaAreaBoundary
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaAreaBoundary_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaAreaBoundary_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaAreaBoundaryObject* self = (PyoaAreaBoundaryObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaAreaBoundary)
    {
        PyParamoaAreaBoundary p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaAreaBoundary_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaAreaBoundary, Choices are:\n"
        "    (oaAreaBoundary)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaAreaBoundary_tp_dealloc(PyoaAreaBoundaryObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaAreaBoundary_tp_repr(PyObject *ob)
{
    PyParamoaAreaBoundary value;
    int convert_status=PyoaAreaBoundary_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[36];
    sprintf(buffer,"<oaAreaBoundary::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaAreaBoundary_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaAreaBoundary v1;
    PyParamoaAreaBoundary v2;
    int convert_status1=PyoaAreaBoundary_Convert(ob1,&v1);
    int convert_status2=PyoaAreaBoundary_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaAreaBoundary_Convert(PyObject* ob,PyParamoaAreaBoundary* result)
{
    if (ob == NULL) return 1;
    if (PyoaAreaBoundary_Check(ob)) {
        result->SetData( (oaAreaBoundary**) ((PyoaAreaBoundaryObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaAreaBoundary Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaAreaBoundary_FromoaAreaBoundary(oaAreaBoundary** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaAreaBoundary* data=*value;
        PyObject* bself = PyoaAreaBoundary_Type.tp_alloc(&PyoaAreaBoundary_Type,0);
        if (bself == NULL) return bself;
        PyoaAreaBoundaryObject* self = (PyoaAreaBoundaryObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaAreaBoundary_FromoaAreaBoundary(oaAreaBoundary* data)
{
    if (data) {
       PyObject* bself = PyoaAreaBoundary_Type.tp_alloc(&PyoaAreaBoundary_Type,0);
       if (bself == NULL) return bself;
       PyoaAreaBoundaryObject* self = (PyoaAreaBoundaryObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAreaBoundary_getName_doc[] = 
"Class: oaAreaBoundary, Function: getName\n"
"  Paramegers: (oaString)\n"
"    Calls: void getName(oaString& name) const\n"
"    Signature: getName|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out name with the name of this boundary.\n"
"    name\n"
"    returned name of this boundary\n"
;

static PyObject*
oaAreaBoundary_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAreaBoundary data;
    int convert_status=PyoaAreaBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAreaBoundaryObject* self=(PyoaAreaBoundaryObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAreaBoundary_setName_doc[] = 
"Class: oaAreaBoundary, Function: setName\n"
"  Paramegers: (oaString)\n"
"    Calls: void setName(const oaString& name)\n"
"    Signature: setName|void-void|cref-oaString,\n"
"    This function sets the name of this boundary to the specified name .\n"
"    name\n"
"    input name of boundary to set\n"
"    oacBoundaryNameExists\n"
;

static PyObject*
oaAreaBoundary_setName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAreaBoundary data;
    int convert_status=PyoaAreaBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAreaBoundaryObject* self=(PyoaAreaBoundaryObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->setName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAreaBoundary_isNull_doc[] =
"Class: oaAreaBoundary, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaAreaBoundary_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaAreaBoundary data;
    int convert_status=PyoaAreaBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaAreaBoundary_assign_doc[] = 
"Class: oaAreaBoundary, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaAreaBoundary_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaAreaBoundary data;
  int convert_status=PyoaAreaBoundary_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaAreaBoundary p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaAreaBoundary_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaAreaBoundary_methodlist[] = {
    {"getName",(PyCFunction)oaAreaBoundary_getName,METH_VARARGS,oaAreaBoundary_getName_doc},
    {"setName",(PyCFunction)oaAreaBoundary_setName,METH_VARARGS,oaAreaBoundary_setName_doc},
    {"isNull",(PyCFunction)oaAreaBoundary_tp_isNull,METH_VARARGS,oaAreaBoundary_isNull_doc},
    {"assign",(PyCFunction)oaAreaBoundary_tp_assign,METH_VARARGS,oaAreaBoundary_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAreaBoundary_doc[] = 
"Class: oaAreaBoundary\n"
"  The oaAreaBoundary class represents a generic boundary in a physical block. This class is used to indicate a region of a block for various purposes defined by a design methodology. For example, it might be an area that is intended to follow a given design style, or an area with a particular supply voltage.\n"
"  Area boundaries are named and there can be multiple area boundaries in a given oaBlock .\n"
"Constructors:\n"
"  Paramegers: (oaAreaBoundary)\n"
"    Calls: (const oaAreaBoundary&)\n"
"    Signature: oaAreaBoundary||cref-oaAreaBoundary,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaAreaBoundary_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaAreaBoundary",
    sizeof(PyoaAreaBoundaryObject),
    0,
    (destructor)oaAreaBoundary_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaAreaBoundary_tp_compare,	/* tp_compare */
    (reprfunc)oaAreaBoundary_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaAreaBoundary_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaAreaBoundary_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaBoundary_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaAreaBoundary_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAreaBoundary_static_create_doc[] = 
"Class: oaAreaBoundary, Function: create\n"
"  Paramegers: (oaBlock,oaString,oaPointArray)\n"
"    Calls: oaAreaBoundary* create(oaBlock* block,const oaString& name,const oaPointArray& points)\n"
"    Signature: create|ptr-oaAreaBoundary|ptr-oaBlock,cref-oaString,cref-oaPointArray,cptr-oaString,\n"
"    This function creates a new area boundary object in the specified block with the specified attributes. With this form of the create() function, the caller supplies a name that must be unique for all boundaries in this block. if a boundary with the specified name already exists in the specified block, this function throws an exception. The specified points pointArray is checked to verify that there are at least three points and no collinear or coincident points.\n"
"    If the boundary edgeNames are not supplied, the edges are automatically named, using the form EDGE_ n , where n starts at zero and increments by one for each edge.\n"
"    Note: The order of the points actually set on the oaAreaBoundary is not guaranteed to be the same as the order of points passed to the create() function. Consequently, the order of points returned by a subsequent oaAreaBoundary::getPoints() may be different from the order of points specified in points .\n"
"    block\n"
"    pointer to block in which to create the oaAreaBoundary object\n"
"    name\n"
"    name of the area boundary\n"
"    points\n"
"    oaPointArray of points that describe this boundary\n"
"    edgeNames\n"
"    pointer to array of boundary edge names\n"
"    oacBoundaryHasExtraPoints\n"
"    oacBoundaryTooFewPoints\n"
"    oacBoundaryNameExists\n"
"  Paramegers: (oaBlock,oaString,oaPointArray,[oaString])\n"
"    Calls: oaAreaBoundary* create(oaBlock* block,const oaString& name,const oaPointArray& points,const oaString* edgeNames)\n"
"    Signature: create|ptr-oaAreaBoundary|ptr-oaBlock,cref-oaString,cref-oaPointArray,cptr-oaString,\n"
"    This function creates a new area boundary object in the specified block with the specified attributes. With this form of the create() function, the caller supplies a name that must be unique for all boundaries in this block. if a boundary with the specified name already exists in the specified block, this function throws an exception. The specified points pointArray is checked to verify that there are at least three points and no collinear or coincident points.\n"
"    If the boundary edgeNames are not supplied, the edges are automatically named, using the form EDGE_ n , where n starts at zero and increments by one for each edge.\n"
"    Note: The order of the points actually set on the oaAreaBoundary is not guaranteed to be the same as the order of points passed to the create() function. Consequently, the order of points returned by a subsequent oaAreaBoundary::getPoints() may be different from the order of points specified in points .\n"
"    block\n"
"    pointer to block in which to create the oaAreaBoundary object\n"
"    name\n"
"    name of the area boundary\n"
"    points\n"
"    oaPointArray of points that describe this boundary\n"
"    edgeNames\n"
"    pointer to array of boundary edge names\n"
"    oacBoundaryHasExtraPoints\n"
"    oacBoundaryTooFewPoints\n"
"    oacBoundaryNameExists\n"
"  Paramegers: (oaBlock,oaPointArray)\n"
"    Calls: oaAreaBoundary* create(oaBlock* block,const oaPointArray& points)\n"
"    Signature: create|ptr-oaAreaBoundary|ptr-oaBlock,cref-oaPointArray,cptr-oaString,\n"
"    This function creates a new area boundary object in the specified block with the specified location and edge names. The specified points pointArray is checked to verify that there are at least three points and no collinear or coincident points.\n"
"    This form of the create function automatically generates a name for the new boundary, with the format B__%d, where d is an integer that makes this name unique among the boundaries of the block.\n"
"    If the boundary edgeNames are not supplied, the edges are automatically named, using the form EDGE_ n , where n starts at zero and increments by one for each edge.\n"
"    Note: The order of the points actually set on the oaAreaBoundary is not guaranteed to be the same as the order of points passed to the create() function. Consequently, the order of points returned by a subsequent oaAreaBoundary::getPoints() may be different from the order of points specified in points .\n"
"    block\n"
"    pointer to block in which to create the oaAreaBoundary object\n"
"    points\n"
"    oaPointArray of points that describe this boundary\n"
"    edgeNames\n"
"    pointer to array of boundary edge names\n"
"    oacBoundaryHasExtraPoints\n"
"    oacBoundaryTooFewPoints\n"
"  Paramegers: (oaBlock,oaPointArray,[oaString])\n"
"    Calls: oaAreaBoundary* create(oaBlock* block,const oaPointArray& points,const oaString* edgeNames)\n"
"    Signature: create|ptr-oaAreaBoundary|ptr-oaBlock,cref-oaPointArray,cptr-oaString,\n"
"    This function creates a new area boundary object in the specified block with the specified location and edge names. The specified points pointArray is checked to verify that there are at least three points and no collinear or coincident points.\n"
"    This form of the create function automatically generates a name for the new boundary, with the format B__%d, where d is an integer that makes this name unique among the boundaries of the block.\n"
"    If the boundary edgeNames are not supplied, the edges are automatically named, using the form EDGE_ n , where n starts at zero and increments by one for each edge.\n"
"    Note: The order of the points actually set on the oaAreaBoundary is not guaranteed to be the same as the order of points passed to the create() function. Consequently, the order of points returned by a subsequent oaAreaBoundary::getPoints() may be different from the order of points specified in points .\n"
"    block\n"
"    pointer to block in which to create the oaAreaBoundary object\n"
"    points\n"
"    oaPointArray of points that describe this boundary\n"
"    edgeNames\n"
"    pointer to array of boundary edge names\n"
"    oacBoundaryHasExtraPoints\n"
"    oacBoundaryTooFewPoints\n"
;

static PyObject*
oaAreaBoundary_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaBlock,oaString,oaPointArray)
    {
        PyParamoaBlock p1;
        PyParamoaString p2;
        PyParamoaPointArray p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaPointArray_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaAreaBoundaryp result= (oaAreaBoundary::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaAreaBoundary_FromoaAreaBoundary(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaString,oaPointArray,[oaString])
    {
        PyParamoaBlock p1;
        PyParamoaString p2;
        PyParamoaPointArray p3;
        PyParamoaString_Array p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaPointArray_Convert,&p3,
              &PyoaString_Array_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!(p3.Data().getNumElements()==p4.Len())) {
                PyErr_SetString(PyExc_TypeError,
                    "number of edges does not match number of points");
                return NULL;
            }
            oaAreaBoundaryp result= (oaAreaBoundary::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaAreaBoundary_FromoaAreaBoundary(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaPointArray)
    {
        PyParamoaBlock p1;
        PyParamoaPointArray p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaPointArray_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaAreaBoundaryp result= (oaAreaBoundary::create(p1.Data(),p2.Data()));
            return PyoaAreaBoundary_FromoaAreaBoundary(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaPointArray,[oaString])
    {
        PyParamoaBlock p1;
        PyParamoaPointArray p2;
        PyParamoaString_Array p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaPointArray_Convert,&p2,
              &PyoaString_Array_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!(p2.Data().getNumElements()==p3.Len())) {
                PyErr_SetString(PyExc_TypeError,
                    "number of edges does not match number of points");
                return NULL;
            }
            oaAreaBoundaryp result= (oaAreaBoundary::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaAreaBoundary_FromoaAreaBoundary(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaAreaBoundary, function: create, Choices are:\n"
        "    (oaBlock,oaString,oaPointArray)\n"
        "    (oaBlock,oaString,oaPointArray,[oaString])\n"
        "    (oaBlock,oaPointArray)\n"
        "    (oaBlock,oaPointArray,[oaString])\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAreaBoundary_static_find_doc[] = 
"Class: oaAreaBoundary, Function: find\n"
"  Paramegers: (oaBlock,oaString)\n"
"    Calls: oaAreaBoundary* find(const oaBlock* block,const oaString& name)\n"
"    Signature: find|ptr-oaAreaBoundary|cptr-oaBlock,cref-oaString,\n"
"    This function searches the specified block for an area boundary with the specified name . A pointer to the boundary is returned if found, otherwise NULL is returned.\n"
"    block\n"
"    pointer to block to search\n"
"    name\n"
"    name of boundary to find\n"
;

static PyObject*
oaAreaBoundary_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaAreaBoundaryp result= (oaAreaBoundary::find(p1.Data(),p2.Data()));
        return PyoaAreaBoundary_FromoaAreaBoundary(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaAreaBoundary_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaAreaBoundary_static_create,METH_VARARGS,oaAreaBoundary_static_create_doc},
    {"static_find",(PyCFunction)oaAreaBoundary_static_find,METH_VARARGS,oaAreaBoundary_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaAreaBoundary_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaAreaBoundary_Type)<0) {
      printf("** PyType_Ready failed for: oaAreaBoundary\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaAreaBoundary",
           (PyObject*)(&PyoaAreaBoundary_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaAreaBoundary\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaAreaBoundary_Type.tp_dict;
    for(method=oaAreaBoundary_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaAreaHalo
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaAreaHalo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaAreaHalo_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaAreaHaloObject* self = (PyoaAreaHaloObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaAreaHalo)
    {
        PyParamoaAreaHalo p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaAreaHalo_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaAreaHalo, Choices are:\n"
        "    (oaAreaHalo)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaAreaHalo_tp_dealloc(PyoaAreaHaloObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaAreaHalo_tp_repr(PyObject *ob)
{
    PyParamoaAreaHalo value;
    int convert_status=PyoaAreaHalo_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[32];
    sprintf(buffer,"<oaAreaHalo::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaAreaHalo_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaAreaHalo v1;
    PyParamoaAreaHalo v2;
    int convert_status1=PyoaAreaHalo_Convert(ob1,&v1);
    int convert_status2=PyoaAreaHalo_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaAreaHalo_Convert(PyObject* ob,PyParamoaAreaHalo* result)
{
    if (ob == NULL) return 1;
    if (PyoaAreaHalo_Check(ob)) {
        result->SetData( (oaAreaHalo**) ((PyoaAreaHaloObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaAreaHalo Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaAreaHalo_FromoaAreaHalo(oaAreaHalo** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaAreaHalo* data=*value;
        PyObject* bself = PyoaAreaHalo_Type.tp_alloc(&PyoaAreaHalo_Type,0);
        if (bself == NULL) return bself;
        PyoaAreaHaloObject* self = (PyoaAreaHaloObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaAreaHalo_FromoaAreaHalo(oaAreaHalo* data)
{
    if (data) {
       PyObject* bself = PyoaAreaHalo_Type.tp_alloc(&PyoaAreaHalo_Type,0);
       if (bself == NULL) return bself;
       PyoaAreaHaloObject* self = (PyoaAreaHaloObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAreaHalo_getOffsets_doc[] = 
"Class: oaAreaHalo, Function: getOffsets\n"
"  Paramegers: (oaDist,oaDist,oaDist,oaDist)\n"
"    Calls: void getOffsets(oaDist& left,oaDist& bottom,oaDist& right,oaDist& top) const\n"
"    Signature: getOffsets|void-void|ref-oaDist,ref-oaDist,ref-oaDist,ref-oaDist,\n"
"    BrowseData: 0,oaDist,oaDist,oaDist,oaDist\n"
"    This function returns the offsets for the halo of the blockage\n"
"    left\n"
"    The left offset for the halo\n"
"    bottom\n"
"    The bottom offset for the halo\n"
"    right\n"
"    The right offset for the halo\n"
"    top\n"
"    The top offset for the halo\n"
;

static PyObject*
oaAreaHalo_getOffsets(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAreaHalo data;
    int convert_status=PyoaAreaHalo_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAreaHaloObject* self=(PyoaAreaHaloObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDist p1;
    PyParamoaDist p2;
    PyParamoaDist p3;
    PyParamoaDist p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaDist_Convert,&p1,
          &PyoaDist_Convert,&p2,
          &PyoaDist_Convert,&p3,
          &PyoaDist_Convert,&p4)) {
        data.DataCall()->getOffsets(p1.Data(),p2.Data(),p3.Data(),p4.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAreaHalo_setOffsets_doc[] = 
"Class: oaAreaHalo, Function: setOffsets\n"
"  Paramegers: (oaDist,oaDist,oaDist,oaDist)\n"
"    Calls: void setOffsets(oaDist left,oaDist bottom,oaDist right,oaDist top)\n"
"    Signature: setOffsets|void-void|simple-oaDist,simple-oaDist,simple-oaDist,simple-oaDist,\n"
"    This function updates the offsets for the halo of the blockage\n"
"    left\n"
"    The left offset for the halo\n"
"    bottom\n"
"    The bottom offset for the halo\n"
"    right\n"
"    The right offset for the halo\n"
"    top\n"
"    The top offset for the halo\n"
;

static PyObject*
oaAreaHalo_setOffsets(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAreaHalo data;
    int convert_status=PyoaAreaHalo_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaAreaHaloObject* self=(PyoaAreaHaloObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDist p1;
    PyParamoaDist p2;
    PyParamoaDist p3;
    PyParamoaDist p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaDist_Convert,&p1,
          &PyoaDist_Convert,&p2,
          &PyoaDist_Convert,&p3,
          &PyoaDist_Convert,&p4)) {
        data.DataCall()->setOffsets(p1.Data(),p2.Data(),p3.Data(),p4.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAreaHalo_isNull_doc[] =
"Class: oaAreaHalo, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaAreaHalo_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaAreaHalo data;
    int convert_status=PyoaAreaHalo_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaAreaHalo_assign_doc[] = 
"Class: oaAreaHalo, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaAreaHalo_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaAreaHalo data;
  int convert_status=PyoaAreaHalo_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaAreaHalo p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaAreaHalo_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaAreaHalo_methodlist[] = {
    {"getOffsets",(PyCFunction)oaAreaHalo_getOffsets,METH_VARARGS,oaAreaHalo_getOffsets_doc},
    {"setOffsets",(PyCFunction)oaAreaHalo_setOffsets,METH_VARARGS,oaAreaHalo_setOffsets_doc},
    {"isNull",(PyCFunction)oaAreaHalo_tp_isNull,METH_VARARGS,oaAreaHalo_isNull_doc},
    {"assign",(PyCFunction)oaAreaHalo_tp_assign,METH_VARARGS,oaAreaHalo_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAreaHalo_doc[] = 
"Class: oaAreaHalo\n"
"  An area halo is a type of blockage associated with an instance or a master, representing an area around the master's prBoundary. The shape of the halo is determined from the shape of the prBoundary of the master and the given offsets, and it is automatically updated to reflect changes in the master's prBoundary.\n"
"  The area halo is most commonly used to prevent standard cells from being placed within a certain range of an instance. This is usually done to make sure there is enough space to properly route to the (presumably) large number of pins on the side of a block. However, this object may also be used for blockage types other than placement.\n"
"  Note that the oaAreaHalo object officially supports rectilinear boundaries only i.e. the owner, if it is an oaPRBoundary object should represent a rectilinear figure, or, if it is an explicit instance, the singleton oaPRBoundary for the instance master should be rectilinear. Clients can use an oaAreaBlockage object to describe a halo with a fixed shape which can be rectilinear or non-rectilinear.\n"
"Constructors:\n"
"  Paramegers: (oaAreaHalo)\n"
"    Calls: (const oaAreaHalo&)\n"
"    Signature: oaAreaHalo||cref-oaAreaHalo,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaAreaHalo_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaAreaHalo",
    sizeof(PyoaAreaHaloObject),
    0,
    (destructor)oaAreaHalo_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaAreaHalo_tp_compare,	/* tp_compare */
    (reprfunc)oaAreaHalo_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaAreaHalo_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaAreaHalo_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaBlockage_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaAreaHalo_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaAreaHalo_static_create_doc[] = 
"Class: oaAreaHalo, Function: create\n"
"  Paramegers: (oaBlockObject)\n"
"    Calls: oaAreaHalo* create(oaBlockObject* owner)\n"
"    Signature: create|ptr-oaAreaHalo|ptr-oaBlockObject,simple-oaDist,simple-oaDist,simple-oaDist,simple-oaDist,\n"
"    This is the constructor for an area halo. Only one area halo can exist per owner object. Attempting to create multiple area halos on an object will result in an exception being thrown.\n"
"    Note that the left, bottom, right and top halo offset values should be specified relative to the respective edges of the prBoundary in the master. When an instance is transformed, the edges of the instance s halo follow the edges of the prBoundary, regardless of whether the owner of the halo is the prBoundary or the instance.\n"
"    owner\n"
"    The instance or prBoundary around which to create the blockage\n"
"    left\n"
"    The left offset for the halo\n"
"    bottom\n"
"    The bottom offset for the halo\n"
"    right\n"
"    The right offset for the halo\n"
"    top\n"
"    The top offset for the halo\n"
"    oacInvalidBlockageOwner\n"
"    oacAreaHaloAlreadyExists\n"
"  Paramegers: (oaBlockObject,oaDist)\n"
"    Calls: oaAreaHalo* create(oaBlockObject* owner,oaDist left)\n"
"    Signature: create|ptr-oaAreaHalo|ptr-oaBlockObject,simple-oaDist,simple-oaDist,simple-oaDist,simple-oaDist,\n"
"    This is the constructor for an area halo. Only one area halo can exist per owner object. Attempting to create multiple area halos on an object will result in an exception being thrown.\n"
"    Note that the left, bottom, right and top halo offset values should be specified relative to the respective edges of the prBoundary in the master. When an instance is transformed, the edges of the instance s halo follow the edges of the prBoundary, regardless of whether the owner of the halo is the prBoundary or the instance.\n"
"    owner\n"
"    The instance or prBoundary around which to create the blockage\n"
"    left\n"
"    The left offset for the halo\n"
"    bottom\n"
"    The bottom offset for the halo\n"
"    right\n"
"    The right offset for the halo\n"
"    top\n"
"    The top offset for the halo\n"
"    oacInvalidBlockageOwner\n"
"    oacAreaHaloAlreadyExists\n"
"  Paramegers: (oaBlockObject,oaDist,oaDist)\n"
"    Calls: oaAreaHalo* create(oaBlockObject* owner,oaDist left,oaDist bottom)\n"
"    Signature: create|ptr-oaAreaHalo|ptr-oaBlockObject,simple-oaDist,simple-oaDist,simple-oaDist,simple-oaDist,\n"
"    This is the constructor for an area halo. Only one area halo can exist per owner object. Attempting to create multiple area halos on an object will result in an exception being thrown.\n"
"    Note that the left, bottom, right and top halo offset values should be specified relative to the respective edges of the prBoundary in the master. When an instance is transformed, the edges of the instance s halo follow the edges of the prBoundary, regardless of whether the owner of the halo is the prBoundary or the instance.\n"
"    owner\n"
"    The instance or prBoundary around which to create the blockage\n"
"    left\n"
"    The left offset for the halo\n"
"    bottom\n"
"    The bottom offset for the halo\n"
"    right\n"
"    The right offset for the halo\n"
"    top\n"
"    The top offset for the halo\n"
"    oacInvalidBlockageOwner\n"
"    oacAreaHaloAlreadyExists\n"
"  Paramegers: (oaBlockObject,oaDist,oaDist,oaDist)\n"
"    Calls: oaAreaHalo* create(oaBlockObject* owner,oaDist left,oaDist bottom,oaDist right)\n"
"    Signature: create|ptr-oaAreaHalo|ptr-oaBlockObject,simple-oaDist,simple-oaDist,simple-oaDist,simple-oaDist,\n"
"    This is the constructor for an area halo. Only one area halo can exist per owner object. Attempting to create multiple area halos on an object will result in an exception being thrown.\n"
"    Note that the left, bottom, right and top halo offset values should be specified relative to the respective edges of the prBoundary in the master. When an instance is transformed, the edges of the instance s halo follow the edges of the prBoundary, regardless of whether the owner of the halo is the prBoundary or the instance.\n"
"    owner\n"
"    The instance or prBoundary around which to create the blockage\n"
"    left\n"
"    The left offset for the halo\n"
"    bottom\n"
"    The bottom offset for the halo\n"
"    right\n"
"    The right offset for the halo\n"
"    top\n"
"    The top offset for the halo\n"
"    oacInvalidBlockageOwner\n"
"    oacAreaHaloAlreadyExists\n"
"  Paramegers: (oaBlockObject,oaDist,oaDist,oaDist,oaDist)\n"
"    Calls: oaAreaHalo* create(oaBlockObject* owner,oaDist left,oaDist bottom,oaDist right,oaDist top)\n"
"    Signature: create|ptr-oaAreaHalo|ptr-oaBlockObject,simple-oaDist,simple-oaDist,simple-oaDist,simple-oaDist,\n"
"    This is the constructor for an area halo. Only one area halo can exist per owner object. Attempting to create multiple area halos on an object will result in an exception being thrown.\n"
"    Note that the left, bottom, right and top halo offset values should be specified relative to the respective edges of the prBoundary in the master. When an instance is transformed, the edges of the instance s halo follow the edges of the prBoundary, regardless of whether the owner of the halo is the prBoundary or the instance.\n"
"    owner\n"
"    The instance or prBoundary around which to create the blockage\n"
"    left\n"
"    The left offset for the halo\n"
"    bottom\n"
"    The bottom offset for the halo\n"
"    right\n"
"    The right offset for the halo\n"
"    top\n"
"    The top offset for the halo\n"
"    oacInvalidBlockageOwner\n"
"    oacAreaHaloAlreadyExists\n"
;

static PyObject*
oaAreaHalo_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaBlockObject)
    {
        PyParamoaBlockObject p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBlockObject_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaAreaHalop result= (oaAreaHalo::create(p1.Data()));
            return PyoaAreaHalo_FromoaAreaHalo(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlockObject,oaDist)
    {
        PyParamoaBlockObject p1;
        PyParamoaDist p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBlockObject_Convert,&p1,
              &PyoaDist_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaAreaHalop result= (oaAreaHalo::create(p1.Data(),p2.Data()));
            return PyoaAreaHalo_FromoaAreaHalo(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlockObject,oaDist,oaDist)
    {
        PyParamoaBlockObject p1;
        PyParamoaDist p2;
        PyParamoaDist p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaBlockObject_Convert,&p1,
              &PyoaDist_Convert,&p2,
              &PyoaDist_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaAreaHalop result= (oaAreaHalo::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaAreaHalo_FromoaAreaHalo(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlockObject,oaDist,oaDist,oaDist)
    {
        PyParamoaBlockObject p1;
        PyParamoaDist p2;
        PyParamoaDist p3;
        PyParamoaDist p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaBlockObject_Convert,&p1,
              &PyoaDist_Convert,&p2,
              &PyoaDist_Convert,&p3,
              &PyoaDist_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaAreaHalop result= (oaAreaHalo::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaAreaHalo_FromoaAreaHalo(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlockObject,oaDist,oaDist,oaDist,oaDist)
    {
        PyParamoaBlockObject p1;
        PyParamoaDist p2;
        PyParamoaDist p3;
        PyParamoaDist p4;
        PyParamoaDist p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaBlockObject_Convert,&p1,
              &PyoaDist_Convert,&p2,
              &PyoaDist_Convert,&p3,
              &PyoaDist_Convert,&p4,
              &PyoaDist_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaAreaHalop result= (oaAreaHalo::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
            return PyoaAreaHalo_FromoaAreaHalo(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaAreaHalo, function: create, Choices are:\n"
        "    (oaBlockObject)\n"
        "    (oaBlockObject,oaDist)\n"
        "    (oaBlockObject,oaDist,oaDist)\n"
        "    (oaBlockObject,oaDist,oaDist,oaDist)\n"
        "    (oaBlockObject,oaDist,oaDist,oaDist,oaDist)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaAreaHalo_static_find_doc[] = 
"Class: oaAreaHalo, Function: find\n"
"  Paramegers: (oaBlockObject)\n"
"    Calls: oaAreaHalo* find(const oaBlockObject* owner)\n"
"    Signature: find|ptr-oaAreaHalo|cptr-oaBlockObject,\n"
"    This function returns the area halo for the specified owner if one exists.\n"
"    owner\n"
"    The instance or prBoundary around which to create the blockage\n"
"    oacInvalidBlockageOwner\n"
;

static PyObject*
oaAreaHalo_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlockObject p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBlockObject_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaAreaHalop result= (oaAreaHalo::find(p1.Data()));
        return PyoaAreaHalo_FromoaAreaHalo(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaAreaHalo_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaAreaHalo_static_create,METH_VARARGS,oaAreaHalo_static_create_doc},
    {"static_find",(PyCFunction)oaAreaHalo_static_find,METH_VARARGS,oaAreaHalo_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaAreaHalo_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaAreaHalo_Type)<0) {
      printf("** PyType_Ready failed for: oaAreaHalo\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaAreaHalo",
           (PyObject*)(&PyoaAreaHalo_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaAreaHalo\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaAreaHalo_Type.tp_dict;
    for(method=oaAreaHalo_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaAnalysisPoint
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaAnalysisPoint_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaAnalysisPoint_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaAnalysisPointObject* self = (PyoaArrayBase_oaAnalysisPointObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaAnalysisPoint();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaAnalysisPoint(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaAnalysisPoint)
    {
        PyParamoaArrayBase_oaAnalysisPoint p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaAnalysisPoint_Convert,&p1)) {
            self->value =  new oaArrayBase_oaAnalysisPoint(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaAnalysisPoint])
    {
        PyParamoaAnalysisPoint_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaAnalysisPoint_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaAnalysisPoint(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaAnalysisPoint, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaAnalysisPoint)\n"
        "    ([oaAnalysisPoint])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaAnalysisPoint_tp_dealloc(PyoaArrayBase_oaAnalysisPointObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaAnalysisPoint_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaAnalysisPoint value;
    int convert_status=PyoaArrayBase_oaAnalysisPoint_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[49];
    sprintf(buffer,"<oaArrayBase_oaAnalysisPoint::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaAnalysisPoint_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaAnalysisPoint v1;
    PyParamoaArrayBase_oaAnalysisPoint v2;
    int convert_status1=PyoaArrayBase_oaAnalysisPoint_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaAnalysisPoint_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaAnalysisPoint_Convert(PyObject* ob,PyParamoaArrayBase_oaAnalysisPoint* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaAnalysisPoint_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaAnalysisPointObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaAnalysisPoint Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaAnalysisPoint_FromoaArrayBase_oaAnalysisPoint(oaArrayBase_oaAnalysisPoint* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaAnalysisPoint_Type.tp_alloc(&PyoaArrayBase_oaAnalysisPoint_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaAnalysisPointObject* self = (PyoaArrayBase_oaAnalysisPointObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaAnalysisPoint_index_get_doc[] = 
"Class: oaArrayBase_oaAnalysisPoint, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaAnalysisPoint_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaAnalysisPointObject* self=(PyoaArrayBase_oaAnalysisPointObject*)ob;
  try {
    PyParamoaArrayBase_oaAnalysisPoint data;
    int convert_status=PyoaArrayBase_oaAnalysisPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaAnalysisPointObject* self=(PyoaArrayBase_oaAnalysisPointObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaAnalysisPointp* result=&(data.Data()[index]);
    return PyoaAnalysisPoint_FromoaAnalysisPoint(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaAnalysisPoint_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaAnalysisPoint data;
    int convert_status=PyoaArrayBase_oaAnalysisPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaAnalysisPointObject* self=(PyoaArrayBase_oaAnalysisPointObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaAnalysisPoint_index_set_doc[] = 
"Class: oaArrayBase_oaAnalysisPoint, Function: index_set\n"
;

static int
oaArrayBase_oaAnalysisPoint_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaAnalysisPoint data;
    int convert_status=PyoaArrayBase_oaAnalysisPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaAnalysisPointObject* self=(PyoaArrayBase_oaAnalysisPointObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaAnalysisPoint result;
    if (PyoaAnalysisPoint_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaAnalysisPoint_get_doc[] = 
"Class: oaArrayBase_oaAnalysisPoint, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaAnalysisPoint*& get(oaUInt4 index)\n"
"    Signature: get|ptrref-oaAnalysisPoint|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaAnalysisPoint_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaAnalysisPoint data;
    int convert_status=PyoaArrayBase_oaAnalysisPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaAnalysisPointObject* self=(PyoaArrayBase_oaAnalysisPointObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaAnalysisPointp* result=&(data.DataCall()->get(p1.Data()));
        return PyoaAnalysisPoint_FromoaAnalysisPoint(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaAnalysisPoint_getNumElements_doc[] = 
"Class: oaArrayBase_oaAnalysisPoint, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaAnalysisPoint_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaAnalysisPoint data;
    int convert_status=PyoaArrayBase_oaAnalysisPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaAnalysisPointObject* self=(PyoaArrayBase_oaAnalysisPointObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaAnalysisPoint_getSize_doc[] = 
"Class: oaArrayBase_oaAnalysisPoint, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaAnalysisPoint_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaAnalysisPoint data;
    int convert_status=PyoaArrayBase_oaAnalysisPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaAnalysisPointObject* self=(PyoaArrayBase_oaAnalysisPointObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaAnalysisPoint_set_doc[] = 
"Class: oaArrayBase_oaAnalysisPoint, Function: set\n"
"  Paramegers: ([oaAnalysisPoint])\n"
"    Calls: void set( array)\n"
"    Signature: set|void-void|cpptr-oaAnalysisPoint,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaAnalysisPoint_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaAnalysisPoint data;
    int convert_status=PyoaArrayBase_oaAnalysisPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaAnalysisPointObject* self=(PyoaArrayBase_oaAnalysisPointObject*)ob;

    PyParamoaAnalysisPoint_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaAnalysisPoint_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaAnalysisPoint_setNumElements_doc[] = 
"Class: oaArrayBase_oaAnalysisPoint, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaAnalysisPoint_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaAnalysisPoint data;
    int convert_status=PyoaArrayBase_oaAnalysisPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaAnalysisPointObject* self=(PyoaArrayBase_oaAnalysisPointObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaAnalysisPoint_setSize_doc[] = 
"Class: oaArrayBase_oaAnalysisPoint, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaAnalysisPoint_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaAnalysisPoint data;
    int convert_status=PyoaArrayBase_oaAnalysisPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaAnalysisPointObject* self=(PyoaArrayBase_oaAnalysisPointObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaAnalysisPoint, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaAnalysisPoint_assign_doc[] = 
"Class: oaArrayBase_oaAnalysisPoint, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaAnalysisPoint_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaAnalysisPoint data;
  int convert_status=PyoaArrayBase_oaAnalysisPoint_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaAnalysisPoint p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaAnalysisPoint_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaAnalysisPoint_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaAnalysisPoint_get,METH_VARARGS,oaArrayBase_oaAnalysisPoint_get_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaAnalysisPoint_getNumElements,METH_VARARGS,oaArrayBase_oaAnalysisPoint_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaAnalysisPoint_getSize,METH_VARARGS,oaArrayBase_oaAnalysisPoint_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaAnalysisPoint_set,METH_VARARGS,oaArrayBase_oaAnalysisPoint_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaAnalysisPoint_setNumElements,METH_VARARGS,oaArrayBase_oaAnalysisPoint_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaAnalysisPoint_setSize,METH_VARARGS,oaArrayBase_oaAnalysisPoint_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaAnalysisPoint_tp_assign,METH_VARARGS,oaArrayBase_oaAnalysisPoint_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaAnalysisPoint_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaAnalysisPoint_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaAnalysisPoint_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaAnalysisPoint_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaAnalysisPoint_doc[] = 
"Class: oaArrayBase_oaAnalysisPoint\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaAnalysisPoint()\n"
"    Signature: oaArrayBase_oaAnalysisPoint||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaAnalysisPoint(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaAnalysisPoint||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaAnalysisPoint)\n"
"    Calls: oaArrayBase_oaAnalysisPoint(const oaArrayBase_oaAnalysisPoint& array)\n"
"    Signature: oaArrayBase_oaAnalysisPoint||cref-oaArrayBase_oaAnalysisPoint,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaAnalysisPoint])\n"
"    Calls: oaArrayBase_oaAnalysisPoint( array)\n"
"    Signature: oaArrayBase_oaAnalysisPoint||cpptr-oaAnalysisPoint,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaAnalysisPoint)\n"
"    Calls: (const oaArrayBase_oaAnalysisPoint&)\n"
"    Signature: oaArrayBase_oaAnalysisPoint||cref-oaArrayBase_oaAnalysisPoint,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaAnalysisPoint_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaAnalysisPoint",
    sizeof(PyoaArrayBase_oaAnalysisPointObject),
    0,
    (destructor)oaArrayBase_oaAnalysisPoint_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaAnalysisPoint_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaAnalysisPoint_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaAnalysisPoint_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaAnalysisPoint_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaAnalysisPoint_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaAnalysisPoint_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaAnalysisPoint_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaAnalysisPoint_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaAnalysisPoint\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaAnalysisPoint",
           (PyObject*)(&PyoaArrayBase_oaAnalysisPoint_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaAnalysisPoint\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaAntennaArea
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaAntennaArea_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaAntennaArea_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaAntennaAreaObject* self = (PyoaArrayBase_oaAntennaAreaObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaAntennaArea();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaAntennaArea(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaAntennaArea)
    {
        PyParamoaArrayBase_oaAntennaArea p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaAntennaArea_Convert,&p1)) {
            self->value =  new oaArrayBase_oaAntennaArea(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaAntennaArea])
    {
        PyParamoaAntennaArea_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaAntennaArea_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaAntennaArea(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaAntennaArea, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaAntennaArea)\n"
        "    ([oaAntennaArea])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaAntennaArea_tp_dealloc(PyoaArrayBase_oaAntennaAreaObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaAntennaArea_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaAntennaArea value;
    int convert_status=PyoaArrayBase_oaAntennaArea_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[47];
    sprintf(buffer,"<oaArrayBase_oaAntennaArea::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaAntennaArea_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaAntennaArea v1;
    PyParamoaArrayBase_oaAntennaArea v2;
    int convert_status1=PyoaArrayBase_oaAntennaArea_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaAntennaArea_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaAntennaArea_Convert(PyObject* ob,PyParamoaArrayBase_oaAntennaArea* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaAntennaArea_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaAntennaAreaObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaAntennaArea Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaAntennaArea_FromoaArrayBase_oaAntennaArea(oaArrayBase_oaAntennaArea* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaAntennaArea_Type.tp_alloc(&PyoaArrayBase_oaAntennaArea_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaAntennaAreaObject* self = (PyoaArrayBase_oaAntennaAreaObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaAntennaArea_index_get_doc[] = 
"Class: oaArrayBase_oaAntennaArea, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaAntennaArea_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaAntennaAreaObject* self=(PyoaArrayBase_oaAntennaAreaObject*)ob;
  try {
    PyParamoaArrayBase_oaAntennaArea data;
    int convert_status=PyoaArrayBase_oaAntennaArea_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaAntennaAreaObject* self=(PyoaArrayBase_oaAntennaAreaObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaAntennaArea* result=&(data.Data()[index]);
    return PyoaAntennaArea_FromoaAntennaArea(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaAntennaArea_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaAntennaArea data;
    int convert_status=PyoaArrayBase_oaAntennaArea_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaAntennaAreaObject* self=(PyoaArrayBase_oaAntennaAreaObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaAntennaArea_index_set_doc[] = 
"Class: oaArrayBase_oaAntennaArea, Function: index_set\n"
;

static int
oaArrayBase_oaAntennaArea_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaAntennaArea data;
    int convert_status=PyoaArrayBase_oaAntennaArea_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaAntennaAreaObject* self=(PyoaArrayBase_oaAntennaAreaObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaAntennaArea result;
    if (PyoaAntennaArea_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaAntennaArea_get_doc[] = 
"Class: oaArrayBase_oaAntennaArea, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaAntennaArea& get(oaUInt4 index)\n"
"    Signature: get|ref-oaAntennaArea|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaAntennaArea_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaAntennaArea data;
    int convert_status=PyoaArrayBase_oaAntennaArea_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaAntennaAreaObject* self=(PyoaArrayBase_oaAntennaAreaObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaAntennaArea* result=&(data.DataCall()->get(p1.Data()));
        return PyoaAntennaArea_FromoaAntennaArea(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaAntennaArea_getElements_doc[] = 
"Class: oaArrayBase_oaAntennaArea, Function: getElements\n"
"  Paramegers: ()\n"
"    Calls: const oaAntennaArea* getElements() const\n"
"    Signature: getElements|cptr-oaAntennaArea|\n"
"    BrowseData: 1\n"
"    This function returns a const pointer to the elements in this oaArrayBase<T> array. This may be useful to those applications that want to memcpy the data in this array.\n"
;

static PyObject*
oaArrayBase_oaAntennaArea_getElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaAntennaArea data;
    int convert_status=PyoaArrayBase_oaAntennaArea_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaAntennaAreaObject* self=(PyoaArrayBase_oaAntennaAreaObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaAntennaArea* result=(oaAntennaArea*)(data.DataCall()->getElements());
        return PyoaAntennaArea_Array_FromoaAntennaArea_Array(result,(data.Data().getNumElements()),ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaAntennaArea_getNumElements_doc[] = 
"Class: oaArrayBase_oaAntennaArea, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaAntennaArea_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaAntennaArea data;
    int convert_status=PyoaArrayBase_oaAntennaArea_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaAntennaAreaObject* self=(PyoaArrayBase_oaAntennaAreaObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaAntennaArea_getSize_doc[] = 
"Class: oaArrayBase_oaAntennaArea, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaAntennaArea_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaAntennaArea data;
    int convert_status=PyoaArrayBase_oaAntennaArea_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaAntennaAreaObject* self=(PyoaArrayBase_oaAntennaAreaObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaAntennaArea_set_doc[] = 
"Class: oaArrayBase_oaAntennaArea, Function: set\n"
"  Paramegers: ([oaAntennaArea])\n"
"    Calls: void set(const oaAntennaArea* array)\n"
"    Signature: set|void-void|cptr-oaAntennaArea,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaAntennaArea_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaAntennaArea data;
    int convert_status=PyoaArrayBase_oaAntennaArea_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaAntennaAreaObject* self=(PyoaArrayBase_oaAntennaAreaObject*)ob;

    PyParamoaAntennaArea_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaAntennaArea_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaAntennaArea_setNumElements_doc[] = 
"Class: oaArrayBase_oaAntennaArea, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaAntennaArea_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaAntennaArea data;
    int convert_status=PyoaArrayBase_oaAntennaArea_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaAntennaAreaObject* self=(PyoaArrayBase_oaAntennaAreaObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaAntennaArea_setSize_doc[] = 
"Class: oaArrayBase_oaAntennaArea, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaAntennaArea_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaAntennaArea data;
    int convert_status=PyoaArrayBase_oaAntennaArea_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaAntennaAreaObject* self=(PyoaArrayBase_oaAntennaAreaObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaAntennaArea, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaAntennaArea_assign_doc[] = 
"Class: oaArrayBase_oaAntennaArea, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaAntennaArea_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaAntennaArea data;
  int convert_status=PyoaArrayBase_oaAntennaArea_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaAntennaArea p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaAntennaArea_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaAntennaArea_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaAntennaArea_get,METH_VARARGS,oaArrayBase_oaAntennaArea_get_doc},
    {"getElements",(PyCFunction)oaArrayBase_oaAntennaArea_getElements,METH_VARARGS,oaArrayBase_oaAntennaArea_getElements_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaAntennaArea_getNumElements,METH_VARARGS,oaArrayBase_oaAntennaArea_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaAntennaArea_getSize,METH_VARARGS,oaArrayBase_oaAntennaArea_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaAntennaArea_set,METH_VARARGS,oaArrayBase_oaAntennaArea_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaAntennaArea_setNumElements,METH_VARARGS,oaArrayBase_oaAntennaArea_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaAntennaArea_setSize,METH_VARARGS,oaArrayBase_oaAntennaArea_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaAntennaArea_tp_assign,METH_VARARGS,oaArrayBase_oaAntennaArea_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaAntennaArea_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaAntennaArea_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaAntennaArea_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaAntennaArea_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaAntennaArea_doc[] = 
"Class: oaArrayBase_oaAntennaArea\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaAntennaArea()\n"
"    Signature: oaArrayBase_oaAntennaArea||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaAntennaArea(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaAntennaArea||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaAntennaArea)\n"
"    Calls: oaArrayBase_oaAntennaArea(const oaArrayBase_oaAntennaArea& array)\n"
"    Signature: oaArrayBase_oaAntennaArea||cref-oaArrayBase_oaAntennaArea,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaAntennaArea])\n"
"    Calls: oaArrayBase_oaAntennaArea(const oaAntennaArea* array)\n"
"    Signature: oaArrayBase_oaAntennaArea||cptr-oaAntennaArea,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaAntennaArea)\n"
"    Calls: (const oaArrayBase_oaAntennaArea&)\n"
"    Signature: oaArrayBase_oaAntennaArea||cref-oaArrayBase_oaAntennaArea,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaAntennaArea_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaAntennaArea",
    sizeof(PyoaArrayBase_oaAntennaAreaObject),
    0,
    (destructor)oaArrayBase_oaAntennaArea_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaAntennaArea_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaAntennaArea_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaAntennaArea_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaAntennaArea_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaAntennaArea_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaAntennaArea_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaAntennaArea_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaAntennaArea_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaAntennaArea\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaAntennaArea",
           (PyObject*)(&PyoaArrayBase_oaAntennaArea_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaAntennaArea\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaBox
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaBox_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaBox_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaBoxObject* self = (PyoaArrayBase_oaBoxObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaBox();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaBox(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaBox)
    {
        PyParamoaArrayBase_oaBox p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaBox_Convert,&p1)) {
            self->value =  new oaArrayBase_oaBox(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaBox])
    {
        PyParamoaBox_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBox_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaBox(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaBox, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaBox)\n"
        "    ([oaBox])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaBox_tp_dealloc(PyoaArrayBase_oaBoxObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaBox_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaBox value;
    int convert_status=PyoaArrayBase_oaBox_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[39];
    sprintf(buffer,"<oaArrayBase_oaBox::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaBox_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaBox v1;
    PyParamoaArrayBase_oaBox v2;
    int convert_status1=PyoaArrayBase_oaBox_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaBox_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaBox_Convert(PyObject* ob,PyParamoaArrayBase_oaBox* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaBox_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaBoxObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaBox Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaBox_FromoaArrayBase_oaBox(oaArrayBase_oaBox* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaBox_Type.tp_alloc(&PyoaArrayBase_oaBox_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaBoxObject* self = (PyoaArrayBase_oaBoxObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaBox_index_get_doc[] = 
"Class: oaArrayBase_oaBox, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaBox_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaBoxObject* self=(PyoaArrayBase_oaBoxObject*)ob;
  try {
    PyParamoaArrayBase_oaBox data;
    int convert_status=PyoaArrayBase_oaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaBoxObject* self=(PyoaArrayBase_oaBoxObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaBox* result=&(data.Data()[index]);
    return PyoaBox_FromoaBox(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaBox_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaBox data;
    int convert_status=PyoaArrayBase_oaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaBoxObject* self=(PyoaArrayBase_oaBoxObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaBox_index_set_doc[] = 
"Class: oaArrayBase_oaBox, Function: index_set\n"
;

static int
oaArrayBase_oaBox_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaBox data;
    int convert_status=PyoaArrayBase_oaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaBoxObject* self=(PyoaArrayBase_oaBoxObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaBox result;
    if (PyoaBox_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaBox_get_doc[] = 
"Class: oaArrayBase_oaBox, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaBox& get(oaUInt4 index)\n"
"    Signature: get|ref-oaBox|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaBox_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaBox data;
    int convert_status=PyoaArrayBase_oaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaBoxObject* self=(PyoaArrayBase_oaBoxObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaBox* result=&(data.DataCall()->get(p1.Data()));
        return PyoaBox_FromoaBox(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaBox_getElements_doc[] = 
"Class: oaArrayBase_oaBox, Function: getElements\n"
"  Paramegers: ()\n"
"    Calls: const oaBox* getElements() const\n"
"    Signature: getElements|cptr-oaBox|\n"
"    BrowseData: 1\n"
"    This function returns a const pointer to the elements in this oaArrayBase<T> array. This may be useful to those applications that want to memcpy the data in this array.\n"
;

static PyObject*
oaArrayBase_oaBox_getElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaBox data;
    int convert_status=PyoaArrayBase_oaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaBoxObject* self=(PyoaArrayBase_oaBoxObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaBox* result=(oaBox*)(data.DataCall()->getElements());
        return PyoaBox_Array_FromoaBox_Array(result,(data.Data().getNumElements()),ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaBox_getNumElements_doc[] = 
"Class: oaArrayBase_oaBox, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaBox_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaBox data;
    int convert_status=PyoaArrayBase_oaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaBoxObject* self=(PyoaArrayBase_oaBoxObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaBox_getSize_doc[] = 
"Class: oaArrayBase_oaBox, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaBox_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaBox data;
    int convert_status=PyoaArrayBase_oaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaBoxObject* self=(PyoaArrayBase_oaBoxObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaBox_set_doc[] = 
"Class: oaArrayBase_oaBox, Function: set\n"
"  Paramegers: ([oaBox])\n"
"    Calls: void set(const oaBox* array)\n"
"    Signature: set|void-void|cptr-oaBox,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaBox_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaBox data;
    int convert_status=PyoaArrayBase_oaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaBoxObject* self=(PyoaArrayBase_oaBoxObject*)ob;

    PyParamoaBox_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBox_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaBox_setNumElements_doc[] = 
"Class: oaArrayBase_oaBox, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaBox_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaBox data;
    int convert_status=PyoaArrayBase_oaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaBoxObject* self=(PyoaArrayBase_oaBoxObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaBox_setSize_doc[] = 
"Class: oaArrayBase_oaBox, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaBox_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaBox data;
    int convert_status=PyoaArrayBase_oaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaBoxObject* self=(PyoaArrayBase_oaBoxObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaBox, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaBox_assign_doc[] = 
"Class: oaArrayBase_oaBox, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaBox_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaBox data;
  int convert_status=PyoaArrayBase_oaBox_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaBox p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaBox_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaBox_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaBox_get,METH_VARARGS,oaArrayBase_oaBox_get_doc},
    {"getElements",(PyCFunction)oaArrayBase_oaBox_getElements,METH_VARARGS,oaArrayBase_oaBox_getElements_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaBox_getNumElements,METH_VARARGS,oaArrayBase_oaBox_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaBox_getSize,METH_VARARGS,oaArrayBase_oaBox_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaBox_set,METH_VARARGS,oaArrayBase_oaBox_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaBox_setNumElements,METH_VARARGS,oaArrayBase_oaBox_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaBox_setSize,METH_VARARGS,oaArrayBase_oaBox_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaBox_tp_assign,METH_VARARGS,oaArrayBase_oaBox_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaBox_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaBox_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaBox_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaBox_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaBox_doc[] = 
"Class: oaArrayBase_oaBox\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaBox()\n"
"    Signature: oaArrayBase_oaBox||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaBox(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaBox||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaBox)\n"
"    Calls: oaArrayBase_oaBox(const oaArrayBase_oaBox& array)\n"
"    Signature: oaArrayBase_oaBox||cref-oaArrayBase_oaBox,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaBox])\n"
"    Calls: oaArrayBase_oaBox(const oaBox* array)\n"
"    Signature: oaArrayBase_oaBox||cptr-oaBox,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaBox)\n"
"    Calls: (const oaArrayBase_oaBox&)\n"
"    Signature: oaArrayBase_oaBox||cref-oaArrayBase_oaBox,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaBox_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaBox",
    sizeof(PyoaArrayBase_oaBoxObject),
    0,
    (destructor)oaArrayBase_oaBox_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaBox_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaBox_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaBox_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaBox_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaBox_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaBox_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaBox_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaBox_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaBox\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaBox",
           (PyObject*)(&PyoaArrayBase_oaBox_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaBox\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaBuildInfo
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaBuildInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaBuildInfo_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaBuildInfoObject* self = (PyoaArrayBase_oaBuildInfoObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaBuildInfo();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaBuildInfo(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaBuildInfo)
    {
        PyParamoaArrayBase_oaBuildInfo p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaBuildInfo_Convert,&p1)) {
            self->value =  new oaArrayBase_oaBuildInfo(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaBuildInfo])
    {
        PyParamoaBuildInfo_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBuildInfo_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaBuildInfo(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaBuildInfo, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaBuildInfo)\n"
        "    ([oaBuildInfo])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaBuildInfo_tp_dealloc(PyoaArrayBase_oaBuildInfoObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaBuildInfo_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaBuildInfo value;
    int convert_status=PyoaArrayBase_oaBuildInfo_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[45];
    sprintf(buffer,"<oaArrayBase_oaBuildInfo::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaBuildInfo_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaBuildInfo v1;
    PyParamoaArrayBase_oaBuildInfo v2;
    int convert_status1=PyoaArrayBase_oaBuildInfo_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaBuildInfo_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaBuildInfo_Convert(PyObject* ob,PyParamoaArrayBase_oaBuildInfo* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaBuildInfo_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaBuildInfoObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaBuildInfo Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaBuildInfo_FromoaArrayBase_oaBuildInfo(oaArrayBase_oaBuildInfo* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaBuildInfo_Type.tp_alloc(&PyoaArrayBase_oaBuildInfo_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaBuildInfoObject* self = (PyoaArrayBase_oaBuildInfoObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaBuildInfo_index_get_doc[] = 
"Class: oaArrayBase_oaBuildInfo, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaBuildInfo_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaBuildInfoObject* self=(PyoaArrayBase_oaBuildInfoObject*)ob;
  try {
    PyParamoaArrayBase_oaBuildInfo data;
    int convert_status=PyoaArrayBase_oaBuildInfo_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaBuildInfoObject* self=(PyoaArrayBase_oaBuildInfoObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaBuildInfop* result=&(data.Data()[index]);
    return PyoaBuildInfo_FromoaBuildInfo(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaBuildInfo_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaBuildInfo data;
    int convert_status=PyoaArrayBase_oaBuildInfo_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaBuildInfoObject* self=(PyoaArrayBase_oaBuildInfoObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaBuildInfo_index_set_doc[] = 
"Class: oaArrayBase_oaBuildInfo, Function: index_set\n"
;

static int
oaArrayBase_oaBuildInfo_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaBuildInfo data;
    int convert_status=PyoaArrayBase_oaBuildInfo_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaBuildInfoObject* self=(PyoaArrayBase_oaBuildInfoObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaBuildInfo result;
    if (PyoaBuildInfo_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaBuildInfo_get_doc[] = 
"Class: oaArrayBase_oaBuildInfo, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaBuildInfo*& get(oaUInt4 index)\n"
"    Signature: get|ptrref-oaBuildInfo|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaBuildInfo_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaBuildInfo data;
    int convert_status=PyoaArrayBase_oaBuildInfo_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaBuildInfoObject* self=(PyoaArrayBase_oaBuildInfoObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaBuildInfop* result=&(data.DataCall()->get(p1.Data()));
        return PyoaBuildInfo_FromoaBuildInfo(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaBuildInfo_getNumElements_doc[] = 
"Class: oaArrayBase_oaBuildInfo, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaBuildInfo_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaBuildInfo data;
    int convert_status=PyoaArrayBase_oaBuildInfo_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaBuildInfoObject* self=(PyoaArrayBase_oaBuildInfoObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaBuildInfo_getSize_doc[] = 
"Class: oaArrayBase_oaBuildInfo, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaBuildInfo_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaBuildInfo data;
    int convert_status=PyoaArrayBase_oaBuildInfo_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaBuildInfoObject* self=(PyoaArrayBase_oaBuildInfoObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaBuildInfo_set_doc[] = 
"Class: oaArrayBase_oaBuildInfo, Function: set\n"
"  Paramegers: ([oaBuildInfo])\n"
"    Calls: void set( array)\n"
"    Signature: set|void-void|cpptr-oaBuildInfo,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaBuildInfo_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaBuildInfo data;
    int convert_status=PyoaArrayBase_oaBuildInfo_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaBuildInfoObject* self=(PyoaArrayBase_oaBuildInfoObject*)ob;

    PyParamoaBuildInfo_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBuildInfo_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaBuildInfo_setNumElements_doc[] = 
"Class: oaArrayBase_oaBuildInfo, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaBuildInfo_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaBuildInfo data;
    int convert_status=PyoaArrayBase_oaBuildInfo_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaBuildInfoObject* self=(PyoaArrayBase_oaBuildInfoObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaBuildInfo_setSize_doc[] = 
"Class: oaArrayBase_oaBuildInfo, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaBuildInfo_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaBuildInfo data;
    int convert_status=PyoaArrayBase_oaBuildInfo_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaBuildInfoObject* self=(PyoaArrayBase_oaBuildInfoObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaBuildInfo, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaBuildInfo_assign_doc[] = 
"Class: oaArrayBase_oaBuildInfo, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaBuildInfo_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaBuildInfo data;
  int convert_status=PyoaArrayBase_oaBuildInfo_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaBuildInfo p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaBuildInfo_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaBuildInfo_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaBuildInfo_get,METH_VARARGS,oaArrayBase_oaBuildInfo_get_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaBuildInfo_getNumElements,METH_VARARGS,oaArrayBase_oaBuildInfo_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaBuildInfo_getSize,METH_VARARGS,oaArrayBase_oaBuildInfo_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaBuildInfo_set,METH_VARARGS,oaArrayBase_oaBuildInfo_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaBuildInfo_setNumElements,METH_VARARGS,oaArrayBase_oaBuildInfo_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaBuildInfo_setSize,METH_VARARGS,oaArrayBase_oaBuildInfo_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaBuildInfo_tp_assign,METH_VARARGS,oaArrayBase_oaBuildInfo_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaBuildInfo_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaBuildInfo_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaBuildInfo_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaBuildInfo_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaBuildInfo_doc[] = 
"Class: oaArrayBase_oaBuildInfo\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaBuildInfo()\n"
"    Signature: oaArrayBase_oaBuildInfo||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaBuildInfo(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaBuildInfo||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaBuildInfo)\n"
"    Calls: oaArrayBase_oaBuildInfo(const oaArrayBase_oaBuildInfo& array)\n"
"    Signature: oaArrayBase_oaBuildInfo||cref-oaArrayBase_oaBuildInfo,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaBuildInfo])\n"
"    Calls: oaArrayBase_oaBuildInfo( array)\n"
"    Signature: oaArrayBase_oaBuildInfo||cpptr-oaBuildInfo,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaBuildInfo)\n"
"    Calls: (const oaArrayBase_oaBuildInfo&)\n"
"    Signature: oaArrayBase_oaBuildInfo||cref-oaArrayBase_oaBuildInfo,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaBuildInfo_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaBuildInfo",
    sizeof(PyoaArrayBase_oaBuildInfoObject),
    0,
    (destructor)oaArrayBase_oaBuildInfo_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaBuildInfo_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaBuildInfo_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaBuildInfo_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaBuildInfo_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaBuildInfo_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaBuildInfo_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaBuildInfo_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaBuildInfo_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaBuildInfo\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaBuildInfo",
           (PyObject*)(&PyoaArrayBase_oaBuildInfo_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaBuildInfo\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaComplex_oaDouble
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaComplex_oaDouble_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaComplex_oaDouble_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaComplex_oaDoubleObject* self = (PyoaArrayBase_oaComplex_oaDoubleObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaComplex_oaDouble();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaComplex_oaDouble(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaComplex_oaDouble)
    {
        PyParamoaArrayBase_oaComplex_oaDouble p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaComplex_oaDouble_Convert,&p1)) {
            self->value =  new oaArrayBase_oaComplex_oaDouble(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaComplex_oaDouble])
    {
        PyParamoaComplex_oaDouble_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaComplex_oaDouble_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaComplex_oaDouble(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaComplex_oaDouble, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaComplex_oaDouble)\n"
        "    ([oaComplex_oaDouble])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaComplex_oaDouble_tp_dealloc(PyoaArrayBase_oaComplex_oaDoubleObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaComplex_oaDouble_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaComplex_oaDouble value;
    int convert_status=PyoaArrayBase_oaComplex_oaDouble_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[52];
    sprintf(buffer,"<oaArrayBase_oaComplex_oaDouble::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaComplex_oaDouble_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaComplex_oaDouble v1;
    PyParamoaArrayBase_oaComplex_oaDouble v2;
    int convert_status1=PyoaArrayBase_oaComplex_oaDouble_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaComplex_oaDouble_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaComplex_oaDouble_Convert(PyObject* ob,PyParamoaArrayBase_oaComplex_oaDouble* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaComplex_oaDouble_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaComplex_oaDoubleObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaComplex_oaDouble Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaComplex_oaDouble_FromoaArrayBase_oaComplex_oaDouble(oaArrayBase_oaComplex_oaDouble* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaComplex_oaDouble_Type.tp_alloc(&PyoaArrayBase_oaComplex_oaDouble_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaComplex_oaDoubleObject* self = (PyoaArrayBase_oaComplex_oaDoubleObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaComplex_oaDouble_index_get_doc[] = 
"Class: oaArrayBase_oaComplex_oaDouble, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaComplex_oaDouble_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaComplex_oaDoubleObject* self=(PyoaArrayBase_oaComplex_oaDoubleObject*)ob;
  try {
    PyParamoaArrayBase_oaComplex_oaDouble data;
    int convert_status=PyoaArrayBase_oaComplex_oaDouble_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaComplex_oaDoubleObject* self=(PyoaArrayBase_oaComplex_oaDoubleObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaComplex_oaDouble* result=&(data.Data()[index]);
    return PyoaComplex_oaDouble_FromoaComplex_oaDouble(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaComplex_oaDouble_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaComplex_oaDouble data;
    int convert_status=PyoaArrayBase_oaComplex_oaDouble_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaComplex_oaDoubleObject* self=(PyoaArrayBase_oaComplex_oaDoubleObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaComplex_oaDouble_index_set_doc[] = 
"Class: oaArrayBase_oaComplex_oaDouble, Function: index_set\n"
;

static int
oaArrayBase_oaComplex_oaDouble_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaComplex_oaDouble data;
    int convert_status=PyoaArrayBase_oaComplex_oaDouble_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaComplex_oaDoubleObject* self=(PyoaArrayBase_oaComplex_oaDoubleObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaComplex_oaDouble result;
    if (PyoaComplex_oaDouble_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaComplex_oaDouble_get_doc[] = 
"Class: oaArrayBase_oaComplex_oaDouble, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaComplex_oaDouble& get(oaUInt4 index)\n"
"    Signature: get|ref-oaComplex_oaDouble|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaComplex_oaDouble_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaComplex_oaDouble data;
    int convert_status=PyoaArrayBase_oaComplex_oaDouble_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaComplex_oaDoubleObject* self=(PyoaArrayBase_oaComplex_oaDoubleObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaComplex_oaDouble* result=&(data.DataCall()->get(p1.Data()));
        return PyoaComplex_oaDouble_FromoaComplex_oaDouble(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaComplex_oaDouble_getElements_doc[] = 
"Class: oaArrayBase_oaComplex_oaDouble, Function: getElements\n"
"  Paramegers: ()\n"
"    Calls: const oaComplex_oaDouble* getElements() const\n"
"    Signature: getElements|cptr-oaComplex_oaDouble|\n"
"    BrowseData: 1\n"
"    This function returns a const pointer to the elements in this oaArrayBase<T> array. This may be useful to those applications that want to memcpy the data in this array.\n"
;

static PyObject*
oaArrayBase_oaComplex_oaDouble_getElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaComplex_oaDouble data;
    int convert_status=PyoaArrayBase_oaComplex_oaDouble_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaComplex_oaDoubleObject* self=(PyoaArrayBase_oaComplex_oaDoubleObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaComplex_oaDouble* result=(oaComplex_oaDouble*)(data.DataCall()->getElements());
        return PyoaComplex_oaDouble_Array_FromoaComplex_oaDouble_Array(result,(data.Data().getNumElements()),ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaComplex_oaDouble_getNumElements_doc[] = 
"Class: oaArrayBase_oaComplex_oaDouble, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaComplex_oaDouble_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaComplex_oaDouble data;
    int convert_status=PyoaArrayBase_oaComplex_oaDouble_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaComplex_oaDoubleObject* self=(PyoaArrayBase_oaComplex_oaDoubleObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaComplex_oaDouble_getSize_doc[] = 
"Class: oaArrayBase_oaComplex_oaDouble, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaComplex_oaDouble_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaComplex_oaDouble data;
    int convert_status=PyoaArrayBase_oaComplex_oaDouble_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaComplex_oaDoubleObject* self=(PyoaArrayBase_oaComplex_oaDoubleObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaComplex_oaDouble_set_doc[] = 
"Class: oaArrayBase_oaComplex_oaDouble, Function: set\n"
"  Paramegers: ([oaComplex_oaDouble])\n"
"    Calls: void set(const oaComplex_oaDouble* array)\n"
"    Signature: set|void-void|cptr-oaComplex_oaDouble,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaComplex_oaDouble_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaComplex_oaDouble data;
    int convert_status=PyoaArrayBase_oaComplex_oaDouble_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaComplex_oaDoubleObject* self=(PyoaArrayBase_oaComplex_oaDoubleObject*)ob;

    PyParamoaComplex_oaDouble_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaComplex_oaDouble_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaComplex_oaDouble_setNumElements_doc[] = 
"Class: oaArrayBase_oaComplex_oaDouble, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaComplex_oaDouble_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaComplex_oaDouble data;
    int convert_status=PyoaArrayBase_oaComplex_oaDouble_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaComplex_oaDoubleObject* self=(PyoaArrayBase_oaComplex_oaDoubleObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaComplex_oaDouble_setSize_doc[] = 
"Class: oaArrayBase_oaComplex_oaDouble, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaComplex_oaDouble_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaComplex_oaDouble data;
    int convert_status=PyoaArrayBase_oaComplex_oaDouble_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaComplex_oaDoubleObject* self=(PyoaArrayBase_oaComplex_oaDoubleObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaComplex_oaDouble, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaComplex_oaDouble_assign_doc[] = 
"Class: oaArrayBase_oaComplex_oaDouble, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaComplex_oaDouble_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaComplex_oaDouble data;
  int convert_status=PyoaArrayBase_oaComplex_oaDouble_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaComplex_oaDouble p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaComplex_oaDouble_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaComplex_oaDouble_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaComplex_oaDouble_get,METH_VARARGS,oaArrayBase_oaComplex_oaDouble_get_doc},
    {"getElements",(PyCFunction)oaArrayBase_oaComplex_oaDouble_getElements,METH_VARARGS,oaArrayBase_oaComplex_oaDouble_getElements_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaComplex_oaDouble_getNumElements,METH_VARARGS,oaArrayBase_oaComplex_oaDouble_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaComplex_oaDouble_getSize,METH_VARARGS,oaArrayBase_oaComplex_oaDouble_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaComplex_oaDouble_set,METH_VARARGS,oaArrayBase_oaComplex_oaDouble_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaComplex_oaDouble_setNumElements,METH_VARARGS,oaArrayBase_oaComplex_oaDouble_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaComplex_oaDouble_setSize,METH_VARARGS,oaArrayBase_oaComplex_oaDouble_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaComplex_oaDouble_tp_assign,METH_VARARGS,oaArrayBase_oaComplex_oaDouble_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaComplex_oaDouble_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaComplex_oaDouble_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaComplex_oaDouble_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaComplex_oaDouble_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaComplex_oaDouble_doc[] = 
"Class: oaArrayBase_oaComplex_oaDouble\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaComplex_oaDouble()\n"
"    Signature: oaArrayBase_oaComplex_oaDouble||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaComplex_oaDouble(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaComplex_oaDouble||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaComplex_oaDouble)\n"
"    Calls: oaArrayBase_oaComplex_oaDouble(const oaArrayBase_oaComplex_oaDouble& array)\n"
"    Signature: oaArrayBase_oaComplex_oaDouble||cref-oaArrayBase_oaComplex_oaDouble,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaComplex_oaDouble])\n"
"    Calls: oaArrayBase_oaComplex_oaDouble(const oaComplex_oaDouble* array)\n"
"    Signature: oaArrayBase_oaComplex_oaDouble||cptr-oaComplex_oaDouble,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaComplex_oaDouble)\n"
"    Calls: (const oaArrayBase_oaComplex_oaDouble&)\n"
"    Signature: oaArrayBase_oaComplex_oaDouble||cref-oaArrayBase_oaComplex_oaDouble,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaComplex_oaDouble_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaComplex_oaDouble",
    sizeof(PyoaArrayBase_oaComplex_oaDoubleObject),
    0,
    (destructor)oaArrayBase_oaComplex_oaDouble_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaComplex_oaDouble_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaComplex_oaDouble_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaComplex_oaDouble_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaComplex_oaDouble_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaComplex_oaDouble_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaComplex_oaDouble_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaComplex_oaDouble_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaComplex_oaDouble_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaComplex_oaDouble\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaComplex_oaDouble",
           (PyObject*)(&PyoaArrayBase_oaComplex_oaDouble_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaComplex_oaDouble\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaComplex_oaFloat
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaComplex_oaFloat_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaComplex_oaFloat_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaComplex_oaFloatObject* self = (PyoaArrayBase_oaComplex_oaFloatObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaComplex_oaFloat();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaComplex_oaFloat(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaComplex_oaFloat)
    {
        PyParamoaArrayBase_oaComplex_oaFloat p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaComplex_oaFloat_Convert,&p1)) {
            self->value =  new oaArrayBase_oaComplex_oaFloat(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaComplex_oaFloat])
    {
        PyParamoaComplex_oaFloat_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaComplex_oaFloat_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaComplex_oaFloat(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaComplex_oaFloat, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaComplex_oaFloat)\n"
        "    ([oaComplex_oaFloat])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaComplex_oaFloat_tp_dealloc(PyoaArrayBase_oaComplex_oaFloatObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaComplex_oaFloat_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaComplex_oaFloat value;
    int convert_status=PyoaArrayBase_oaComplex_oaFloat_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[51];
    sprintf(buffer,"<oaArrayBase_oaComplex_oaFloat::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaComplex_oaFloat_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaComplex_oaFloat v1;
    PyParamoaArrayBase_oaComplex_oaFloat v2;
    int convert_status1=PyoaArrayBase_oaComplex_oaFloat_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaComplex_oaFloat_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaComplex_oaFloat_Convert(PyObject* ob,PyParamoaArrayBase_oaComplex_oaFloat* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaComplex_oaFloat_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaComplex_oaFloatObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaComplex_oaFloat Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaComplex_oaFloat_FromoaArrayBase_oaComplex_oaFloat(oaArrayBase_oaComplex_oaFloat* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaComplex_oaFloat_Type.tp_alloc(&PyoaArrayBase_oaComplex_oaFloat_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaComplex_oaFloatObject* self = (PyoaArrayBase_oaComplex_oaFloatObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaComplex_oaFloat_index_get_doc[] = 
"Class: oaArrayBase_oaComplex_oaFloat, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaComplex_oaFloat_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaComplex_oaFloatObject* self=(PyoaArrayBase_oaComplex_oaFloatObject*)ob;
  try {
    PyParamoaArrayBase_oaComplex_oaFloat data;
    int convert_status=PyoaArrayBase_oaComplex_oaFloat_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaComplex_oaFloatObject* self=(PyoaArrayBase_oaComplex_oaFloatObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaComplex_oaFloat* result=&(data.Data()[index]);
    return PyoaComplex_oaFloat_FromoaComplex_oaFloat(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaComplex_oaFloat_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaComplex_oaFloat data;
    int convert_status=PyoaArrayBase_oaComplex_oaFloat_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaComplex_oaFloatObject* self=(PyoaArrayBase_oaComplex_oaFloatObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaComplex_oaFloat_index_set_doc[] = 
"Class: oaArrayBase_oaComplex_oaFloat, Function: index_set\n"
;

static int
oaArrayBase_oaComplex_oaFloat_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaComplex_oaFloat data;
    int convert_status=PyoaArrayBase_oaComplex_oaFloat_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaComplex_oaFloatObject* self=(PyoaArrayBase_oaComplex_oaFloatObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaComplex_oaFloat result;
    if (PyoaComplex_oaFloat_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaComplex_oaFloat_get_doc[] = 
"Class: oaArrayBase_oaComplex_oaFloat, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaComplex_oaFloat& get(oaUInt4 index)\n"
"    Signature: get|ref-oaComplex_oaFloat|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaComplex_oaFloat_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaComplex_oaFloat data;
    int convert_status=PyoaArrayBase_oaComplex_oaFloat_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaComplex_oaFloatObject* self=(PyoaArrayBase_oaComplex_oaFloatObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaComplex_oaFloat* result=&(data.DataCall()->get(p1.Data()));
        return PyoaComplex_oaFloat_FromoaComplex_oaFloat(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaComplex_oaFloat_getElements_doc[] = 
"Class: oaArrayBase_oaComplex_oaFloat, Function: getElements\n"
"  Paramegers: ()\n"
"    Calls: const oaComplex_oaFloat* getElements() const\n"
"    Signature: getElements|cptr-oaComplex_oaFloat|\n"
"    BrowseData: 1\n"
"    This function returns a const pointer to the elements in this oaArrayBase<T> array. This may be useful to those applications that want to memcpy the data in this array.\n"
;

static PyObject*
oaArrayBase_oaComplex_oaFloat_getElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaComplex_oaFloat data;
    int convert_status=PyoaArrayBase_oaComplex_oaFloat_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaComplex_oaFloatObject* self=(PyoaArrayBase_oaComplex_oaFloatObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaComplex_oaFloat* result=(oaComplex_oaFloat*)(data.DataCall()->getElements());
        return PyoaComplex_oaFloat_Array_FromoaComplex_oaFloat_Array(result,(data.Data().getNumElements()),ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaComplex_oaFloat_getNumElements_doc[] = 
"Class: oaArrayBase_oaComplex_oaFloat, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaComplex_oaFloat_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaComplex_oaFloat data;
    int convert_status=PyoaArrayBase_oaComplex_oaFloat_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaComplex_oaFloatObject* self=(PyoaArrayBase_oaComplex_oaFloatObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaComplex_oaFloat_getSize_doc[] = 
"Class: oaArrayBase_oaComplex_oaFloat, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaComplex_oaFloat_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaComplex_oaFloat data;
    int convert_status=PyoaArrayBase_oaComplex_oaFloat_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaComplex_oaFloatObject* self=(PyoaArrayBase_oaComplex_oaFloatObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaComplex_oaFloat_set_doc[] = 
"Class: oaArrayBase_oaComplex_oaFloat, Function: set\n"
"  Paramegers: ([oaComplex_oaFloat])\n"
"    Calls: void set(const oaComplex_oaFloat* array)\n"
"    Signature: set|void-void|cptr-oaComplex_oaFloat,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaComplex_oaFloat_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaComplex_oaFloat data;
    int convert_status=PyoaArrayBase_oaComplex_oaFloat_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaComplex_oaFloatObject* self=(PyoaArrayBase_oaComplex_oaFloatObject*)ob;

    PyParamoaComplex_oaFloat_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaComplex_oaFloat_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaComplex_oaFloat_setNumElements_doc[] = 
"Class: oaArrayBase_oaComplex_oaFloat, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaComplex_oaFloat_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaComplex_oaFloat data;
    int convert_status=PyoaArrayBase_oaComplex_oaFloat_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaComplex_oaFloatObject* self=(PyoaArrayBase_oaComplex_oaFloatObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaComplex_oaFloat_setSize_doc[] = 
"Class: oaArrayBase_oaComplex_oaFloat, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaComplex_oaFloat_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaComplex_oaFloat data;
    int convert_status=PyoaArrayBase_oaComplex_oaFloat_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaComplex_oaFloatObject* self=(PyoaArrayBase_oaComplex_oaFloatObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaComplex_oaFloat, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaComplex_oaFloat_assign_doc[] = 
"Class: oaArrayBase_oaComplex_oaFloat, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaComplex_oaFloat_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaComplex_oaFloat data;
  int convert_status=PyoaArrayBase_oaComplex_oaFloat_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaComplex_oaFloat p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaComplex_oaFloat_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaComplex_oaFloat_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaComplex_oaFloat_get,METH_VARARGS,oaArrayBase_oaComplex_oaFloat_get_doc},
    {"getElements",(PyCFunction)oaArrayBase_oaComplex_oaFloat_getElements,METH_VARARGS,oaArrayBase_oaComplex_oaFloat_getElements_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaComplex_oaFloat_getNumElements,METH_VARARGS,oaArrayBase_oaComplex_oaFloat_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaComplex_oaFloat_getSize,METH_VARARGS,oaArrayBase_oaComplex_oaFloat_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaComplex_oaFloat_set,METH_VARARGS,oaArrayBase_oaComplex_oaFloat_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaComplex_oaFloat_setNumElements,METH_VARARGS,oaArrayBase_oaComplex_oaFloat_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaComplex_oaFloat_setSize,METH_VARARGS,oaArrayBase_oaComplex_oaFloat_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaComplex_oaFloat_tp_assign,METH_VARARGS,oaArrayBase_oaComplex_oaFloat_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaComplex_oaFloat_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaComplex_oaFloat_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaComplex_oaFloat_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaComplex_oaFloat_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaComplex_oaFloat_doc[] = 
"Class: oaArrayBase_oaComplex_oaFloat\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaComplex_oaFloat()\n"
"    Signature: oaArrayBase_oaComplex_oaFloat||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaComplex_oaFloat(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaComplex_oaFloat||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaComplex_oaFloat)\n"
"    Calls: oaArrayBase_oaComplex_oaFloat(const oaArrayBase_oaComplex_oaFloat& array)\n"
"    Signature: oaArrayBase_oaComplex_oaFloat||cref-oaArrayBase_oaComplex_oaFloat,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaComplex_oaFloat])\n"
"    Calls: oaArrayBase_oaComplex_oaFloat(const oaComplex_oaFloat* array)\n"
"    Signature: oaArrayBase_oaComplex_oaFloat||cptr-oaComplex_oaFloat,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaComplex_oaFloat)\n"
"    Calls: (const oaArrayBase_oaComplex_oaFloat&)\n"
"    Signature: oaArrayBase_oaComplex_oaFloat||cref-oaArrayBase_oaComplex_oaFloat,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaComplex_oaFloat_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaComplex_oaFloat",
    sizeof(PyoaArrayBase_oaComplex_oaFloatObject),
    0,
    (destructor)oaArrayBase_oaComplex_oaFloat_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaComplex_oaFloat_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaComplex_oaFloat_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaComplex_oaFloat_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaComplex_oaFloat_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaComplex_oaFloat_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaComplex_oaFloat_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaComplex_oaFloat_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaComplex_oaFloat_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaComplex_oaFloat\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaComplex_oaFloat",
           (PyObject*)(&PyoaArrayBase_oaComplex_oaFloat_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaComplex_oaFloat\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaConstraintParam
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaConstraintParam_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaConstraintParam_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaConstraintParamObject* self = (PyoaArrayBase_oaConstraintParamObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaConstraintParam();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaConstraintParam(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaConstraintParam)
    {
        PyParamoaArrayBase_oaConstraintParam p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaConstraintParam_Convert,&p1)) {
            self->value =  new oaArrayBase_oaConstraintParam(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaConstraintParam])
    {
        PyParamoaConstraintParam_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaConstraintParam_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaConstraintParam(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaConstraintParam, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaConstraintParam)\n"
        "    ([oaConstraintParam])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaConstraintParam_tp_dealloc(PyoaArrayBase_oaConstraintParamObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaConstraintParam_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaConstraintParam value;
    int convert_status=PyoaArrayBase_oaConstraintParam_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[51];
    sprintf(buffer,"<oaArrayBase_oaConstraintParam::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaConstraintParam_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaConstraintParam v1;
    PyParamoaArrayBase_oaConstraintParam v2;
    int convert_status1=PyoaArrayBase_oaConstraintParam_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaConstraintParam_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaConstraintParam_Convert(PyObject* ob,PyParamoaArrayBase_oaConstraintParam* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaConstraintParam_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaConstraintParamObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaConstraintParam Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaConstraintParam_FromoaArrayBase_oaConstraintParam(oaArrayBase_oaConstraintParam* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaConstraintParam_Type.tp_alloc(&PyoaArrayBase_oaConstraintParam_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaConstraintParamObject* self = (PyoaArrayBase_oaConstraintParamObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaConstraintParam_index_get_doc[] = 
"Class: oaArrayBase_oaConstraintParam, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaConstraintParam_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaConstraintParamObject* self=(PyoaArrayBase_oaConstraintParamObject*)ob;
  try {
    PyParamoaArrayBase_oaConstraintParam data;
    int convert_status=PyoaArrayBase_oaConstraintParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaConstraintParamObject* self=(PyoaArrayBase_oaConstraintParamObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaConstraintParamp* result=&(data.Data()[index]);
    return PyoaConstraintParam_FromoaConstraintParam(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaConstraintParam_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaConstraintParam data;
    int convert_status=PyoaArrayBase_oaConstraintParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaConstraintParamObject* self=(PyoaArrayBase_oaConstraintParamObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaConstraintParam_index_set_doc[] = 
"Class: oaArrayBase_oaConstraintParam, Function: index_set\n"
;

static int
oaArrayBase_oaConstraintParam_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaConstraintParam data;
    int convert_status=PyoaArrayBase_oaConstraintParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaConstraintParamObject* self=(PyoaArrayBase_oaConstraintParamObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaConstraintParam result;
    if (PyoaConstraintParam_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaConstraintParam_get_doc[] = 
"Class: oaArrayBase_oaConstraintParam, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaConstraintParam*& get(oaUInt4 index)\n"
"    Signature: get|ptrref-oaConstraintParam|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaConstraintParam_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaConstraintParam data;
    int convert_status=PyoaArrayBase_oaConstraintParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaConstraintParamObject* self=(PyoaArrayBase_oaConstraintParamObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaConstraintParamp* result=&(data.DataCall()->get(p1.Data()));
        return PyoaConstraintParam_FromoaConstraintParam(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaConstraintParam_getNumElements_doc[] = 
"Class: oaArrayBase_oaConstraintParam, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaConstraintParam_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaConstraintParam data;
    int convert_status=PyoaArrayBase_oaConstraintParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaConstraintParamObject* self=(PyoaArrayBase_oaConstraintParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaConstraintParam_getSize_doc[] = 
"Class: oaArrayBase_oaConstraintParam, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaConstraintParam_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaConstraintParam data;
    int convert_status=PyoaArrayBase_oaConstraintParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaConstraintParamObject* self=(PyoaArrayBase_oaConstraintParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaConstraintParam_set_doc[] = 
"Class: oaArrayBase_oaConstraintParam, Function: set\n"
"  Paramegers: ([oaConstraintParam])\n"
"    Calls: void set( array)\n"
"    Signature: set|void-void|cpptr-oaConstraintParam,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaConstraintParam_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaConstraintParam data;
    int convert_status=PyoaArrayBase_oaConstraintParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaConstraintParamObject* self=(PyoaArrayBase_oaConstraintParamObject*)ob;

    PyParamoaConstraintParam_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaConstraintParam_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaConstraintParam_setNumElements_doc[] = 
"Class: oaArrayBase_oaConstraintParam, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaConstraintParam_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaConstraintParam data;
    int convert_status=PyoaArrayBase_oaConstraintParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaConstraintParamObject* self=(PyoaArrayBase_oaConstraintParamObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaConstraintParam_setSize_doc[] = 
"Class: oaArrayBase_oaConstraintParam, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaConstraintParam_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaConstraintParam data;
    int convert_status=PyoaArrayBase_oaConstraintParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaConstraintParamObject* self=(PyoaArrayBase_oaConstraintParamObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaConstraintParam, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaConstraintParam_assign_doc[] = 
"Class: oaArrayBase_oaConstraintParam, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaConstraintParam_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaConstraintParam data;
  int convert_status=PyoaArrayBase_oaConstraintParam_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaConstraintParam p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaConstraintParam_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaConstraintParam_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaConstraintParam_get,METH_VARARGS,oaArrayBase_oaConstraintParam_get_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaConstraintParam_getNumElements,METH_VARARGS,oaArrayBase_oaConstraintParam_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaConstraintParam_getSize,METH_VARARGS,oaArrayBase_oaConstraintParam_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaConstraintParam_set,METH_VARARGS,oaArrayBase_oaConstraintParam_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaConstraintParam_setNumElements,METH_VARARGS,oaArrayBase_oaConstraintParam_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaConstraintParam_setSize,METH_VARARGS,oaArrayBase_oaConstraintParam_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaConstraintParam_tp_assign,METH_VARARGS,oaArrayBase_oaConstraintParam_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaConstraintParam_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaConstraintParam_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaConstraintParam_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaConstraintParam_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaConstraintParam_doc[] = 
"Class: oaArrayBase_oaConstraintParam\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaConstraintParam()\n"
"    Signature: oaArrayBase_oaConstraintParam||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaConstraintParam(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaConstraintParam||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaConstraintParam)\n"
"    Calls: oaArrayBase_oaConstraintParam(const oaArrayBase_oaConstraintParam& array)\n"
"    Signature: oaArrayBase_oaConstraintParam||cref-oaArrayBase_oaConstraintParam,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaConstraintParam])\n"
"    Calls: oaArrayBase_oaConstraintParam( array)\n"
"    Signature: oaArrayBase_oaConstraintParam||cpptr-oaConstraintParam,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaConstraintParam)\n"
"    Calls: (const oaArrayBase_oaConstraintParam&)\n"
"    Signature: oaArrayBase_oaConstraintParam||cref-oaArrayBase_oaConstraintParam,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaConstraintParam_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaConstraintParam",
    sizeof(PyoaArrayBase_oaConstraintParamObject),
    0,
    (destructor)oaArrayBase_oaConstraintParam_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaConstraintParam_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaConstraintParam_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaConstraintParam_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaConstraintParam_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaConstraintParam_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaConstraintParam_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaConstraintParam_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaConstraintParam_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaConstraintParam\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaConstraintParam",
           (PyObject*)(&PyoaArrayBase_oaConstraintParam_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaConstraintParam\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaDBType
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaDBType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaDBType_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaDBTypeObject* self = (PyoaArrayBase_oaDBTypeObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaDBType();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaDBType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaDBType)
    {
        PyParamoaArrayBase_oaDBType p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaDBType_Convert,&p1)) {
            self->value =  new oaArrayBase_oaDBType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaDBType])
    {
        PyParamoaDBType_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDBType_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaDBType(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaDBType, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaDBType)\n"
        "    ([oaDBType])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaDBType_tp_dealloc(PyoaArrayBase_oaDBTypeObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaDBType_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaDBType value;
    int convert_status=PyoaArrayBase_oaDBType_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaArrayBase_oaDBType::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaDBType_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaDBType v1;
    PyParamoaArrayBase_oaDBType v2;
    int convert_status1=PyoaArrayBase_oaDBType_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaDBType_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaDBType_Convert(PyObject* ob,PyParamoaArrayBase_oaDBType* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaDBType_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaDBTypeObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaDBType Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaDBType_FromoaArrayBase_oaDBType(oaArrayBase_oaDBType* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaDBType_Type.tp_alloc(&PyoaArrayBase_oaDBType_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaDBTypeObject* self = (PyoaArrayBase_oaDBTypeObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaDBType_index_get_doc[] = 
"Class: oaArrayBase_oaDBType, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaDBType_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaDBTypeObject* self=(PyoaArrayBase_oaDBTypeObject*)ob;
  try {
    PyParamoaArrayBase_oaDBType data;
    int convert_status=PyoaArrayBase_oaDBType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDBTypeObject* self=(PyoaArrayBase_oaDBTypeObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaDBType* result=&(data.Data()[index]);
    return PyoaDBType_FromoaDBType(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaDBType_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaDBType data;
    int convert_status=PyoaArrayBase_oaDBType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDBTypeObject* self=(PyoaArrayBase_oaDBTypeObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaDBType_index_set_doc[] = 
"Class: oaArrayBase_oaDBType, Function: index_set\n"
;

static int
oaArrayBase_oaDBType_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaDBType data;
    int convert_status=PyoaArrayBase_oaDBType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDBTypeObject* self=(PyoaArrayBase_oaDBTypeObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaDBType result;
    if (PyoaDBType_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaDBType_get_doc[] = 
"Class: oaArrayBase_oaDBType, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaDBType& get(oaUInt4 index)\n"
"    Signature: get|ref-oaDBType|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaDBType_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDBType data;
    int convert_status=PyoaArrayBase_oaDBType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDBTypeObject* self=(PyoaArrayBase_oaDBTypeObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaDBType* result=&(data.DataCall()->get(p1.Data()));
        return PyoaDBType_FromoaDBType(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDBType_getElements_doc[] = 
"Class: oaArrayBase_oaDBType, Function: getElements\n"
"  Paramegers: ()\n"
"    Calls: const oaDBType* getElements() const\n"
"    Signature: getElements|cptr-oaDBType|\n"
"    BrowseData: 1\n"
"    This function returns a const pointer to the elements in this oaArrayBase<T> array. This may be useful to those applications that want to memcpy the data in this array.\n"
;

static PyObject*
oaArrayBase_oaDBType_getElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDBType data;
    int convert_status=PyoaArrayBase_oaDBType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDBTypeObject* self=(PyoaArrayBase_oaDBTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaDBType* result=(oaDBType*)(data.DataCall()->getElements());
        return PyoaDBType_Array_FromoaDBType_Array(result,(data.Data().getNumElements()),ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDBType_getNumElements_doc[] = 
"Class: oaArrayBase_oaDBType, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaDBType_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDBType data;
    int convert_status=PyoaArrayBase_oaDBType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDBTypeObject* self=(PyoaArrayBase_oaDBTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDBType_getSize_doc[] = 
"Class: oaArrayBase_oaDBType, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaDBType_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDBType data;
    int convert_status=PyoaArrayBase_oaDBType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDBTypeObject* self=(PyoaArrayBase_oaDBTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDBType_set_doc[] = 
"Class: oaArrayBase_oaDBType, Function: set\n"
"  Paramegers: ([oaDBType])\n"
"    Calls: void set(const oaDBType* array)\n"
"    Signature: set|void-void|cptr-oaDBType,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaDBType_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDBType data;
    int convert_status=PyoaArrayBase_oaDBType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDBTypeObject* self=(PyoaArrayBase_oaDBTypeObject*)ob;

    PyParamoaDBType_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaDBType_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDBType_setNumElements_doc[] = 
"Class: oaArrayBase_oaDBType, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaDBType_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDBType data;
    int convert_status=PyoaArrayBase_oaDBType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDBTypeObject* self=(PyoaArrayBase_oaDBTypeObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDBType_setSize_doc[] = 
"Class: oaArrayBase_oaDBType, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaDBType_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDBType data;
    int convert_status=PyoaArrayBase_oaDBType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDBTypeObject* self=(PyoaArrayBase_oaDBTypeObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaDBType, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaDBType_assign_doc[] = 
"Class: oaArrayBase_oaDBType, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaDBType_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaDBType data;
  int convert_status=PyoaArrayBase_oaDBType_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaDBType p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaDBType_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaDBType_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaDBType_get,METH_VARARGS,oaArrayBase_oaDBType_get_doc},
    {"getElements",(PyCFunction)oaArrayBase_oaDBType_getElements,METH_VARARGS,oaArrayBase_oaDBType_getElements_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaDBType_getNumElements,METH_VARARGS,oaArrayBase_oaDBType_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaDBType_getSize,METH_VARARGS,oaArrayBase_oaDBType_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaDBType_set,METH_VARARGS,oaArrayBase_oaDBType_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaDBType_setNumElements,METH_VARARGS,oaArrayBase_oaDBType_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaDBType_setSize,METH_VARARGS,oaArrayBase_oaDBType_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaDBType_tp_assign,METH_VARARGS,oaArrayBase_oaDBType_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaDBType_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaDBType_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaDBType_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaDBType_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaDBType_doc[] = 
"Class: oaArrayBase_oaDBType\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaDBType()\n"
"    Signature: oaArrayBase_oaDBType||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaDBType(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaDBType||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaDBType)\n"
"    Calls: oaArrayBase_oaDBType(const oaArrayBase_oaDBType& array)\n"
"    Signature: oaArrayBase_oaDBType||cref-oaArrayBase_oaDBType,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaDBType])\n"
"    Calls: oaArrayBase_oaDBType(const oaDBType* array)\n"
"    Signature: oaArrayBase_oaDBType||cptr-oaDBType,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaDBType)\n"
"    Calls: (const oaArrayBase_oaDBType&)\n"
"    Signature: oaArrayBase_oaDBType||cref-oaArrayBase_oaDBType,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaDBType_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaDBType",
    sizeof(PyoaArrayBase_oaDBTypeObject),
    0,
    (destructor)oaArrayBase_oaDBType_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaDBType_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaDBType_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaDBType_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaDBType_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaDBType_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaDBType_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaDBType_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaDBType_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaDBType\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaDBType",
           (PyObject*)(&PyoaArrayBase_oaDBType_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaDBType\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaDMAttr
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaDMAttr_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaDMAttr_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaDMAttrObject* self = (PyoaArrayBase_oaDMAttrObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaDMAttr();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaDMAttr(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaDMAttr)
    {
        PyParamoaArrayBase_oaDMAttr p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaDMAttr_Convert,&p1)) {
            self->value =  new oaArrayBase_oaDMAttr(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaDMAttr])
    {
        PyParamoaDMAttr_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDMAttr_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaDMAttr(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaDMAttr, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaDMAttr)\n"
        "    ([oaDMAttr])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaDMAttr_tp_dealloc(PyoaArrayBase_oaDMAttrObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaDMAttr_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaDMAttr value;
    int convert_status=PyoaArrayBase_oaDMAttr_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaArrayBase_oaDMAttr::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaDMAttr_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaDMAttr v1;
    PyParamoaArrayBase_oaDMAttr v2;
    int convert_status1=PyoaArrayBase_oaDMAttr_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaDMAttr_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaDMAttr_Convert(PyObject* ob,PyParamoaArrayBase_oaDMAttr* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaDMAttr_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaDMAttrObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaDMAttr Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaDMAttr_FromoaArrayBase_oaDMAttr(oaArrayBase_oaDMAttr* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaDMAttr_Type.tp_alloc(&PyoaArrayBase_oaDMAttr_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaDMAttrObject* self = (PyoaArrayBase_oaDMAttrObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaDMAttr_index_get_doc[] = 
"Class: oaArrayBase_oaDMAttr, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaDMAttr_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaDMAttrObject* self=(PyoaArrayBase_oaDMAttrObject*)ob;
  try {
    PyParamoaArrayBase_oaDMAttr data;
    int convert_status=PyoaArrayBase_oaDMAttr_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDMAttrObject* self=(PyoaArrayBase_oaDMAttrObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaDMAttr* result=&(data.Data()[index]);
    return PyoaDMAttr_FromoaDMAttr(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaDMAttr_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaDMAttr data;
    int convert_status=PyoaArrayBase_oaDMAttr_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDMAttrObject* self=(PyoaArrayBase_oaDMAttrObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaDMAttr_index_set_doc[] = 
"Class: oaArrayBase_oaDMAttr, Function: index_set\n"
;

static int
oaArrayBase_oaDMAttr_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaDMAttr data;
    int convert_status=PyoaArrayBase_oaDMAttr_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDMAttrObject* self=(PyoaArrayBase_oaDMAttrObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaDMAttr result;
    if (PyoaDMAttr_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaDMAttr_get_doc[] = 
"Class: oaArrayBase_oaDMAttr, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaDMAttr& get(oaUInt4 index)\n"
"    Signature: get|ref-oaDMAttr|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaDMAttr_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDMAttr data;
    int convert_status=PyoaArrayBase_oaDMAttr_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDMAttrObject* self=(PyoaArrayBase_oaDMAttrObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaDMAttr* result=&(data.DataCall()->get(p1.Data()));
        return PyoaDMAttr_FromoaDMAttr(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDMAttr_getElements_doc[] = 
"Class: oaArrayBase_oaDMAttr, Function: getElements\n"
"  Paramegers: ()\n"
"    Calls: const oaDMAttr* getElements() const\n"
"    Signature: getElements|cptr-oaDMAttr|\n"
"    BrowseData: 1\n"
"    This function returns a const pointer to the elements in this oaArrayBase<T> array. This may be useful to those applications that want to memcpy the data in this array.\n"
;

static PyObject*
oaArrayBase_oaDMAttr_getElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDMAttr data;
    int convert_status=PyoaArrayBase_oaDMAttr_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDMAttrObject* self=(PyoaArrayBase_oaDMAttrObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaDMAttr* result=(oaDMAttr*)(data.DataCall()->getElements());
        return PyoaDMAttr_Array_FromoaDMAttr_Array(result,(data.Data().getNumElements()),ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDMAttr_getNumElements_doc[] = 
"Class: oaArrayBase_oaDMAttr, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaDMAttr_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDMAttr data;
    int convert_status=PyoaArrayBase_oaDMAttr_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDMAttrObject* self=(PyoaArrayBase_oaDMAttrObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDMAttr_getSize_doc[] = 
"Class: oaArrayBase_oaDMAttr, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaDMAttr_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDMAttr data;
    int convert_status=PyoaArrayBase_oaDMAttr_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDMAttrObject* self=(PyoaArrayBase_oaDMAttrObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDMAttr_set_doc[] = 
"Class: oaArrayBase_oaDMAttr, Function: set\n"
"  Paramegers: ([oaDMAttr])\n"
"    Calls: void set(const oaDMAttr* array)\n"
"    Signature: set|void-void|cptr-oaDMAttr,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaDMAttr_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDMAttr data;
    int convert_status=PyoaArrayBase_oaDMAttr_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDMAttrObject* self=(PyoaArrayBase_oaDMAttrObject*)ob;

    PyParamoaDMAttr_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaDMAttr_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDMAttr_setNumElements_doc[] = 
"Class: oaArrayBase_oaDMAttr, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaDMAttr_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDMAttr data;
    int convert_status=PyoaArrayBase_oaDMAttr_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDMAttrObject* self=(PyoaArrayBase_oaDMAttrObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDMAttr_setSize_doc[] = 
"Class: oaArrayBase_oaDMAttr, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaDMAttr_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDMAttr data;
    int convert_status=PyoaArrayBase_oaDMAttr_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDMAttrObject* self=(PyoaArrayBase_oaDMAttrObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaDMAttr, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaDMAttr_assign_doc[] = 
"Class: oaArrayBase_oaDMAttr, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaDMAttr_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaDMAttr data;
  int convert_status=PyoaArrayBase_oaDMAttr_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaDMAttr p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaDMAttr_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaDMAttr_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaDMAttr_get,METH_VARARGS,oaArrayBase_oaDMAttr_get_doc},
    {"getElements",(PyCFunction)oaArrayBase_oaDMAttr_getElements,METH_VARARGS,oaArrayBase_oaDMAttr_getElements_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaDMAttr_getNumElements,METH_VARARGS,oaArrayBase_oaDMAttr_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaDMAttr_getSize,METH_VARARGS,oaArrayBase_oaDMAttr_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaDMAttr_set,METH_VARARGS,oaArrayBase_oaDMAttr_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaDMAttr_setNumElements,METH_VARARGS,oaArrayBase_oaDMAttr_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaDMAttr_setSize,METH_VARARGS,oaArrayBase_oaDMAttr_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaDMAttr_tp_assign,METH_VARARGS,oaArrayBase_oaDMAttr_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaDMAttr_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaDMAttr_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaDMAttr_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaDMAttr_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaDMAttr_doc[] = 
"Class: oaArrayBase_oaDMAttr\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaDMAttr()\n"
"    Signature: oaArrayBase_oaDMAttr||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaDMAttr(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaDMAttr||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaDMAttr)\n"
"    Calls: oaArrayBase_oaDMAttr(const oaArrayBase_oaDMAttr& array)\n"
"    Signature: oaArrayBase_oaDMAttr||cref-oaArrayBase_oaDMAttr,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaDMAttr])\n"
"    Calls: oaArrayBase_oaDMAttr(const oaDMAttr* array)\n"
"    Signature: oaArrayBase_oaDMAttr||cptr-oaDMAttr,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaDMAttr)\n"
"    Calls: (const oaArrayBase_oaDMAttr&)\n"
"    Signature: oaArrayBase_oaDMAttr||cref-oaArrayBase_oaDMAttr,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaDMAttr_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaDMAttr",
    sizeof(PyoaArrayBase_oaDMAttrObject),
    0,
    (destructor)oaArrayBase_oaDMAttr_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaDMAttr_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaDMAttr_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaDMAttr_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaDMAttr_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaDMAttr_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaDMAttr_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaDMAttr_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaDMAttr_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaDMAttr\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaDMAttr",
           (PyObject*)(&PyoaArrayBase_oaDMAttr_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaDMAttr\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaDerivedLayerParam
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaDerivedLayerParam_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaDerivedLayerParam_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaDerivedLayerParamObject* self = (PyoaArrayBase_oaDerivedLayerParamObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaDerivedLayerParam();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaDerivedLayerParam(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaDerivedLayerParam)
    {
        PyParamoaArrayBase_oaDerivedLayerParam p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaDerivedLayerParam_Convert,&p1)) {
            self->value =  new oaArrayBase_oaDerivedLayerParam(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaDerivedLayerParam])
    {
        PyParamoaDerivedLayerParam_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDerivedLayerParam_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaDerivedLayerParam(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaDerivedLayerParam, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaDerivedLayerParam)\n"
        "    ([oaDerivedLayerParam])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaDerivedLayerParam_tp_dealloc(PyoaArrayBase_oaDerivedLayerParamObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaDerivedLayerParam_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaDerivedLayerParam value;
    int convert_status=PyoaArrayBase_oaDerivedLayerParam_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[53];
    sprintf(buffer,"<oaArrayBase_oaDerivedLayerParam::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaDerivedLayerParam_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaDerivedLayerParam v1;
    PyParamoaArrayBase_oaDerivedLayerParam v2;
    int convert_status1=PyoaArrayBase_oaDerivedLayerParam_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaDerivedLayerParam_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaDerivedLayerParam_Convert(PyObject* ob,PyParamoaArrayBase_oaDerivedLayerParam* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaDerivedLayerParam_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaDerivedLayerParamObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaDerivedLayerParam Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaDerivedLayerParam_FromoaArrayBase_oaDerivedLayerParam(oaArrayBase_oaDerivedLayerParam* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaDerivedLayerParam_Type.tp_alloc(&PyoaArrayBase_oaDerivedLayerParam_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaDerivedLayerParamObject* self = (PyoaArrayBase_oaDerivedLayerParamObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaDerivedLayerParam_index_get_doc[] = 
"Class: oaArrayBase_oaDerivedLayerParam, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaDerivedLayerParam_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaDerivedLayerParamObject* self=(PyoaArrayBase_oaDerivedLayerParamObject*)ob;
  try {
    PyParamoaArrayBase_oaDerivedLayerParam data;
    int convert_status=PyoaArrayBase_oaDerivedLayerParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDerivedLayerParamObject* self=(PyoaArrayBase_oaDerivedLayerParamObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaDerivedLayerParamp* result=&(data.Data()[index]);
    return PyoaDerivedLayerParam_FromoaDerivedLayerParam(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaDerivedLayerParam_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaDerivedLayerParam data;
    int convert_status=PyoaArrayBase_oaDerivedLayerParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDerivedLayerParamObject* self=(PyoaArrayBase_oaDerivedLayerParamObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaDerivedLayerParam_index_set_doc[] = 
"Class: oaArrayBase_oaDerivedLayerParam, Function: index_set\n"
;

static int
oaArrayBase_oaDerivedLayerParam_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaDerivedLayerParam data;
    int convert_status=PyoaArrayBase_oaDerivedLayerParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDerivedLayerParamObject* self=(PyoaArrayBase_oaDerivedLayerParamObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaDerivedLayerParam result;
    if (PyoaDerivedLayerParam_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaDerivedLayerParam_get_doc[] = 
"Class: oaArrayBase_oaDerivedLayerParam, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaDerivedLayerParam*& get(oaUInt4 index)\n"
"    Signature: get|ptrref-oaDerivedLayerParam|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaDerivedLayerParam_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDerivedLayerParam data;
    int convert_status=PyoaArrayBase_oaDerivedLayerParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDerivedLayerParamObject* self=(PyoaArrayBase_oaDerivedLayerParamObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaDerivedLayerParamp* result=&(data.DataCall()->get(p1.Data()));
        return PyoaDerivedLayerParam_FromoaDerivedLayerParam(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDerivedLayerParam_getNumElements_doc[] = 
"Class: oaArrayBase_oaDerivedLayerParam, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaDerivedLayerParam_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDerivedLayerParam data;
    int convert_status=PyoaArrayBase_oaDerivedLayerParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDerivedLayerParamObject* self=(PyoaArrayBase_oaDerivedLayerParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDerivedLayerParam_getSize_doc[] = 
"Class: oaArrayBase_oaDerivedLayerParam, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaDerivedLayerParam_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDerivedLayerParam data;
    int convert_status=PyoaArrayBase_oaDerivedLayerParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDerivedLayerParamObject* self=(PyoaArrayBase_oaDerivedLayerParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDerivedLayerParam_set_doc[] = 
"Class: oaArrayBase_oaDerivedLayerParam, Function: set\n"
"  Paramegers: ([oaDerivedLayerParam])\n"
"    Calls: void set( array)\n"
"    Signature: set|void-void|cpptr-oaDerivedLayerParam,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaDerivedLayerParam_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDerivedLayerParam data;
    int convert_status=PyoaArrayBase_oaDerivedLayerParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDerivedLayerParamObject* self=(PyoaArrayBase_oaDerivedLayerParamObject*)ob;

    PyParamoaDerivedLayerParam_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaDerivedLayerParam_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDerivedLayerParam_setNumElements_doc[] = 
"Class: oaArrayBase_oaDerivedLayerParam, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaDerivedLayerParam_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDerivedLayerParam data;
    int convert_status=PyoaArrayBase_oaDerivedLayerParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDerivedLayerParamObject* self=(PyoaArrayBase_oaDerivedLayerParamObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDerivedLayerParam_setSize_doc[] = 
"Class: oaArrayBase_oaDerivedLayerParam, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaDerivedLayerParam_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDerivedLayerParam data;
    int convert_status=PyoaArrayBase_oaDerivedLayerParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDerivedLayerParamObject* self=(PyoaArrayBase_oaDerivedLayerParamObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaDerivedLayerParam, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaDerivedLayerParam_assign_doc[] = 
"Class: oaArrayBase_oaDerivedLayerParam, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaDerivedLayerParam_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaDerivedLayerParam data;
  int convert_status=PyoaArrayBase_oaDerivedLayerParam_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaDerivedLayerParam p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaDerivedLayerParam_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaDerivedLayerParam_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaDerivedLayerParam_get,METH_VARARGS,oaArrayBase_oaDerivedLayerParam_get_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaDerivedLayerParam_getNumElements,METH_VARARGS,oaArrayBase_oaDerivedLayerParam_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaDerivedLayerParam_getSize,METH_VARARGS,oaArrayBase_oaDerivedLayerParam_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaDerivedLayerParam_set,METH_VARARGS,oaArrayBase_oaDerivedLayerParam_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaDerivedLayerParam_setNumElements,METH_VARARGS,oaArrayBase_oaDerivedLayerParam_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaDerivedLayerParam_setSize,METH_VARARGS,oaArrayBase_oaDerivedLayerParam_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaDerivedLayerParam_tp_assign,METH_VARARGS,oaArrayBase_oaDerivedLayerParam_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaDerivedLayerParam_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaDerivedLayerParam_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaDerivedLayerParam_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaDerivedLayerParam_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaDerivedLayerParam_doc[] = 
"Class: oaArrayBase_oaDerivedLayerParam\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaDerivedLayerParam()\n"
"    Signature: oaArrayBase_oaDerivedLayerParam||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaDerivedLayerParam(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaDerivedLayerParam||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaDerivedLayerParam)\n"
"    Calls: oaArrayBase_oaDerivedLayerParam(const oaArrayBase_oaDerivedLayerParam& array)\n"
"    Signature: oaArrayBase_oaDerivedLayerParam||cref-oaArrayBase_oaDerivedLayerParam,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaDerivedLayerParam])\n"
"    Calls: oaArrayBase_oaDerivedLayerParam( array)\n"
"    Signature: oaArrayBase_oaDerivedLayerParam||cpptr-oaDerivedLayerParam,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaDerivedLayerParam)\n"
"    Calls: (const oaArrayBase_oaDerivedLayerParam&)\n"
"    Signature: oaArrayBase_oaDerivedLayerParam||cref-oaArrayBase_oaDerivedLayerParam,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaDerivedLayerParam_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaDerivedLayerParam",
    sizeof(PyoaArrayBase_oaDerivedLayerParamObject),
    0,
    (destructor)oaArrayBase_oaDerivedLayerParam_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaDerivedLayerParam_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaDerivedLayerParam_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaDerivedLayerParam_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaDerivedLayerParam_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaDerivedLayerParam_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaDerivedLayerParam_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaDerivedLayerParam_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaDerivedLayerParam_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaDerivedLayerParam\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaDerivedLayerParam",
           (PyObject*)(&PyoaArrayBase_oaDerivedLayerParam_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaDerivedLayerParam\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaDesignObject
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaDesignObject_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaDesignObject_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaDesignObjectObject* self = (PyoaArrayBase_oaDesignObjectObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaDesignObject();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaDesignObject(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaDesignObject)
    {
        PyParamoaArrayBase_oaDesignObject p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaDesignObject_Convert,&p1)) {
            self->value =  new oaArrayBase_oaDesignObject(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaDesignObject])
    {
        PyParamoaDesignObject_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDesignObject_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaDesignObject(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaDesignObject, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaDesignObject)\n"
        "    ([oaDesignObject])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaDesignObject_tp_dealloc(PyoaArrayBase_oaDesignObjectObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaDesignObject_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaDesignObject value;
    int convert_status=PyoaArrayBase_oaDesignObject_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[48];
    sprintf(buffer,"<oaArrayBase_oaDesignObject::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaDesignObject_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaDesignObject v1;
    PyParamoaArrayBase_oaDesignObject v2;
    int convert_status1=PyoaArrayBase_oaDesignObject_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaDesignObject_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaDesignObject_Convert(PyObject* ob,PyParamoaArrayBase_oaDesignObject* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaDesignObject_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaDesignObjectObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaDesignObject Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaDesignObject_FromoaArrayBase_oaDesignObject(oaArrayBase_oaDesignObject* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaDesignObject_Type.tp_alloc(&PyoaArrayBase_oaDesignObject_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaDesignObjectObject* self = (PyoaArrayBase_oaDesignObjectObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaDesignObject_index_get_doc[] = 
"Class: oaArrayBase_oaDesignObject, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaDesignObject_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaDesignObjectObject* self=(PyoaArrayBase_oaDesignObjectObject*)ob;
  try {
    PyParamoaArrayBase_oaDesignObject data;
    int convert_status=PyoaArrayBase_oaDesignObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDesignObjectObject* self=(PyoaArrayBase_oaDesignObjectObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaDesignObjectp* result=&(data.Data()[index]);
    return PyoaDesignObject_FromoaDesignObject(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaDesignObject_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaDesignObject data;
    int convert_status=PyoaArrayBase_oaDesignObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDesignObjectObject* self=(PyoaArrayBase_oaDesignObjectObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaDesignObject_index_set_doc[] = 
"Class: oaArrayBase_oaDesignObject, Function: index_set\n"
;

static int
oaArrayBase_oaDesignObject_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaDesignObject data;
    int convert_status=PyoaArrayBase_oaDesignObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDesignObjectObject* self=(PyoaArrayBase_oaDesignObjectObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaDesignObject result;
    if (PyoaDesignObject_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaDesignObject_get_doc[] = 
"Class: oaArrayBase_oaDesignObject, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaDesignObject*& get(oaUInt4 index)\n"
"    Signature: get|ptrref-oaDesignObject|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaDesignObject_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDesignObject data;
    int convert_status=PyoaArrayBase_oaDesignObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDesignObjectObject* self=(PyoaArrayBase_oaDesignObjectObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaDesignObjectp* result=&(data.DataCall()->get(p1.Data()));
        return PyoaDesignObject_FromoaDesignObject(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDesignObject_getNumElements_doc[] = 
"Class: oaArrayBase_oaDesignObject, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaDesignObject_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDesignObject data;
    int convert_status=PyoaArrayBase_oaDesignObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDesignObjectObject* self=(PyoaArrayBase_oaDesignObjectObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDesignObject_getSize_doc[] = 
"Class: oaArrayBase_oaDesignObject, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaDesignObject_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDesignObject data;
    int convert_status=PyoaArrayBase_oaDesignObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDesignObjectObject* self=(PyoaArrayBase_oaDesignObjectObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDesignObject_set_doc[] = 
"Class: oaArrayBase_oaDesignObject, Function: set\n"
"  Paramegers: ([oaDesignObject])\n"
"    Calls: void set( array)\n"
"    Signature: set|void-void|cpptr-oaDesignObject,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaDesignObject_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDesignObject data;
    int convert_status=PyoaArrayBase_oaDesignObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDesignObjectObject* self=(PyoaArrayBase_oaDesignObjectObject*)ob;

    PyParamoaDesignObject_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaDesignObject_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDesignObject_setNumElements_doc[] = 
"Class: oaArrayBase_oaDesignObject, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaDesignObject_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDesignObject data;
    int convert_status=PyoaArrayBase_oaDesignObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDesignObjectObject* self=(PyoaArrayBase_oaDesignObjectObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDesignObject_setSize_doc[] = 
"Class: oaArrayBase_oaDesignObject, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaDesignObject_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDesignObject data;
    int convert_status=PyoaArrayBase_oaDesignObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDesignObjectObject* self=(PyoaArrayBase_oaDesignObjectObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaDesignObject, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaDesignObject_assign_doc[] = 
"Class: oaArrayBase_oaDesignObject, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaDesignObject_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaDesignObject data;
  int convert_status=PyoaArrayBase_oaDesignObject_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaDesignObject p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaDesignObject_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaDesignObject_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaDesignObject_get,METH_VARARGS,oaArrayBase_oaDesignObject_get_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaDesignObject_getNumElements,METH_VARARGS,oaArrayBase_oaDesignObject_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaDesignObject_getSize,METH_VARARGS,oaArrayBase_oaDesignObject_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaDesignObject_set,METH_VARARGS,oaArrayBase_oaDesignObject_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaDesignObject_setNumElements,METH_VARARGS,oaArrayBase_oaDesignObject_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaDesignObject_setSize,METH_VARARGS,oaArrayBase_oaDesignObject_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaDesignObject_tp_assign,METH_VARARGS,oaArrayBase_oaDesignObject_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaDesignObject_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaDesignObject_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaDesignObject_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaDesignObject_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaDesignObject_doc[] = 
"Class: oaArrayBase_oaDesignObject\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaDesignObject()\n"
"    Signature: oaArrayBase_oaDesignObject||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaDesignObject(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaDesignObject||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaDesignObject)\n"
"    Calls: oaArrayBase_oaDesignObject(const oaArrayBase_oaDesignObject& array)\n"
"    Signature: oaArrayBase_oaDesignObject||cref-oaArrayBase_oaDesignObject,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaDesignObject])\n"
"    Calls: oaArrayBase_oaDesignObject( array)\n"
"    Signature: oaArrayBase_oaDesignObject||cpptr-oaDesignObject,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaDesignObject)\n"
"    Calls: (const oaArrayBase_oaDesignObject&)\n"
"    Signature: oaArrayBase_oaDesignObject||cref-oaArrayBase_oaDesignObject,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaDesignObject_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaDesignObject",
    sizeof(PyoaArrayBase_oaDesignObjectObject),
    0,
    (destructor)oaArrayBase_oaDesignObject_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaDesignObject_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaDesignObject_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaDesignObject_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaDesignObject_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaDesignObject_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaDesignObject_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaDesignObject_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaDesignObject_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaDesignObject\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaDesignObject",
           (PyObject*)(&PyoaArrayBase_oaDesignObject_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaDesignObject\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaDualInt
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaDualInt_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaDualInt_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaDualIntObject* self = (PyoaArrayBase_oaDualIntObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaDualInt();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaDualInt(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaDualInt)
    {
        PyParamoaArrayBase_oaDualInt p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaDualInt_Convert,&p1)) {
            self->value =  new oaArrayBase_oaDualInt(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaDualInt])
    {
        PyParamoaDualInt_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDualInt_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaDualInt(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaDualInt, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaDualInt)\n"
        "    ([oaDualInt])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaDualInt_tp_dealloc(PyoaArrayBase_oaDualIntObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaDualInt_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaDualInt value;
    int convert_status=PyoaArrayBase_oaDualInt_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaArrayBase_oaDualInt::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaDualInt_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaDualInt v1;
    PyParamoaArrayBase_oaDualInt v2;
    int convert_status1=PyoaArrayBase_oaDualInt_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaDualInt_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaDualInt_Convert(PyObject* ob,PyParamoaArrayBase_oaDualInt* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaDualInt_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaDualIntObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaDualInt Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaDualInt_FromoaArrayBase_oaDualInt(oaArrayBase_oaDualInt* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaDualInt_Type.tp_alloc(&PyoaArrayBase_oaDualInt_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaDualIntObject* self = (PyoaArrayBase_oaDualIntObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaDualInt_index_get_doc[] = 
"Class: oaArrayBase_oaDualInt, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaDualInt_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaDualIntObject* self=(PyoaArrayBase_oaDualIntObject*)ob;
  try {
    PyParamoaArrayBase_oaDualInt data;
    int convert_status=PyoaArrayBase_oaDualInt_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDualIntObject* self=(PyoaArrayBase_oaDualIntObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaDualInt* result=&(data.Data()[index]);
    return PyoaDualInt_FromoaDualInt(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaDualInt_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaDualInt data;
    int convert_status=PyoaArrayBase_oaDualInt_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDualIntObject* self=(PyoaArrayBase_oaDualIntObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaDualInt_index_set_doc[] = 
"Class: oaArrayBase_oaDualInt, Function: index_set\n"
;

static int
oaArrayBase_oaDualInt_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaDualInt data;
    int convert_status=PyoaArrayBase_oaDualInt_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDualIntObject* self=(PyoaArrayBase_oaDualIntObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaDualInt result;
    if (PyoaDualInt_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaDualInt_get_doc[] = 
"Class: oaArrayBase_oaDualInt, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaDualInt& get(oaUInt4 index)\n"
"    Signature: get|ref-oaDualInt|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaDualInt_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDualInt data;
    int convert_status=PyoaArrayBase_oaDualInt_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDualIntObject* self=(PyoaArrayBase_oaDualIntObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaDualInt* result=&(data.DataCall()->get(p1.Data()));
        return PyoaDualInt_FromoaDualInt(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDualInt_getElements_doc[] = 
"Class: oaArrayBase_oaDualInt, Function: getElements\n"
"  Paramegers: ()\n"
"    Calls: const oaDualInt* getElements() const\n"
"    Signature: getElements|cptr-oaDualInt|\n"
"    BrowseData: 1\n"
"    This function returns a const pointer to the elements in this oaArrayBase<T> array. This may be useful to those applications that want to memcpy the data in this array.\n"
;

static PyObject*
oaArrayBase_oaDualInt_getElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDualInt data;
    int convert_status=PyoaArrayBase_oaDualInt_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDualIntObject* self=(PyoaArrayBase_oaDualIntObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaDualInt* result=(oaDualInt*)(data.DataCall()->getElements());
        return PyoaDualInt_Array_FromoaDualInt_Array(result,(data.Data().getNumElements()),ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDualInt_getNumElements_doc[] = 
"Class: oaArrayBase_oaDualInt, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaDualInt_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDualInt data;
    int convert_status=PyoaArrayBase_oaDualInt_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDualIntObject* self=(PyoaArrayBase_oaDualIntObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDualInt_getSize_doc[] = 
"Class: oaArrayBase_oaDualInt, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaDualInt_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDualInt data;
    int convert_status=PyoaArrayBase_oaDualInt_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDualIntObject* self=(PyoaArrayBase_oaDualIntObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDualInt_set_doc[] = 
"Class: oaArrayBase_oaDualInt, Function: set\n"
"  Paramegers: ([oaDualInt])\n"
"    Calls: void set(const oaDualInt* array)\n"
"    Signature: set|void-void|cptr-oaDualInt,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaDualInt_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDualInt data;
    int convert_status=PyoaArrayBase_oaDualInt_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDualIntObject* self=(PyoaArrayBase_oaDualIntObject*)ob;

    PyParamoaDualInt_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaDualInt_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDualInt_setNumElements_doc[] = 
"Class: oaArrayBase_oaDualInt, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaDualInt_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDualInt data;
    int convert_status=PyoaArrayBase_oaDualInt_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDualIntObject* self=(PyoaArrayBase_oaDualIntObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaDualInt_setSize_doc[] = 
"Class: oaArrayBase_oaDualInt, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaDualInt_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaDualInt data;
    int convert_status=PyoaArrayBase_oaDualInt_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaDualIntObject* self=(PyoaArrayBase_oaDualIntObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaDualInt, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaDualInt_assign_doc[] = 
"Class: oaArrayBase_oaDualInt, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaDualInt_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaDualInt data;
  int convert_status=PyoaArrayBase_oaDualInt_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaDualInt p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaDualInt_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaDualInt_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaDualInt_get,METH_VARARGS,oaArrayBase_oaDualInt_get_doc},
    {"getElements",(PyCFunction)oaArrayBase_oaDualInt_getElements,METH_VARARGS,oaArrayBase_oaDualInt_getElements_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaDualInt_getNumElements,METH_VARARGS,oaArrayBase_oaDualInt_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaDualInt_getSize,METH_VARARGS,oaArrayBase_oaDualInt_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaDualInt_set,METH_VARARGS,oaArrayBase_oaDualInt_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaDualInt_setNumElements,METH_VARARGS,oaArrayBase_oaDualInt_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaDualInt_setSize,METH_VARARGS,oaArrayBase_oaDualInt_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaDualInt_tp_assign,METH_VARARGS,oaArrayBase_oaDualInt_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaDualInt_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaDualInt_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaDualInt_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaDualInt_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaDualInt_doc[] = 
"Class: oaArrayBase_oaDualInt\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaDualInt()\n"
"    Signature: oaArrayBase_oaDualInt||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaDualInt(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaDualInt||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaDualInt)\n"
"    Calls: oaArrayBase_oaDualInt(const oaArrayBase_oaDualInt& array)\n"
"    Signature: oaArrayBase_oaDualInt||cref-oaArrayBase_oaDualInt,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaDualInt])\n"
"    Calls: oaArrayBase_oaDualInt(const oaDualInt* array)\n"
"    Signature: oaArrayBase_oaDualInt||cptr-oaDualInt,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaDualInt)\n"
"    Calls: (const oaArrayBase_oaDualInt&)\n"
"    Signature: oaArrayBase_oaDualInt||cref-oaArrayBase_oaDualInt,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaDualInt_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaDualInt",
    sizeof(PyoaArrayBase_oaDualIntObject),
    0,
    (destructor)oaArrayBase_oaDualInt_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaDualInt_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaDualInt_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaDualInt_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaDualInt_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaDualInt_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaDualInt_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaDualInt_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaDualInt_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaDualInt\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaDualInt",
           (PyObject*)(&PyoaArrayBase_oaDualInt_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaDualInt\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaFeature
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaFeature_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaFeature_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaFeatureObject* self = (PyoaArrayBase_oaFeatureObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaFeature();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaFeature(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaFeature)
    {
        PyParamoaArrayBase_oaFeature p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaFeature_Convert,&p1)) {
            self->value =  new oaArrayBase_oaFeature(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaFeature])
    {
        PyParamoaFeature_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaFeature_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaFeature(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaFeature, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaFeature)\n"
        "    ([oaFeature])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaFeature_tp_dealloc(PyoaArrayBase_oaFeatureObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaFeature_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaFeature value;
    int convert_status=PyoaArrayBase_oaFeature_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaArrayBase_oaFeature::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaFeature_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaFeature v1;
    PyParamoaArrayBase_oaFeature v2;
    int convert_status1=PyoaArrayBase_oaFeature_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaFeature_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaFeature_Convert(PyObject* ob,PyParamoaArrayBase_oaFeature* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaFeature_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaFeatureObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaFeature Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaFeature_FromoaArrayBase_oaFeature(oaArrayBase_oaFeature* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaFeature_Type.tp_alloc(&PyoaArrayBase_oaFeature_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaFeatureObject* self = (PyoaArrayBase_oaFeatureObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaFeature_index_get_doc[] = 
"Class: oaArrayBase_oaFeature, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaFeature_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaFeatureObject* self=(PyoaArrayBase_oaFeatureObject*)ob;
  try {
    PyParamoaArrayBase_oaFeature data;
    int convert_status=PyoaArrayBase_oaFeature_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaFeatureObject* self=(PyoaArrayBase_oaFeatureObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaFeaturep* result=&(data.Data()[index]);
    return PyoaFeature_FromoaFeature(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaFeature_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaFeature data;
    int convert_status=PyoaArrayBase_oaFeature_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaFeatureObject* self=(PyoaArrayBase_oaFeatureObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaFeature_index_set_doc[] = 
"Class: oaArrayBase_oaFeature, Function: index_set\n"
;

static int
oaArrayBase_oaFeature_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaFeature data;
    int convert_status=PyoaArrayBase_oaFeature_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaFeatureObject* self=(PyoaArrayBase_oaFeatureObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaFeature result;
    if (PyoaFeature_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaFeature_get_doc[] = 
"Class: oaArrayBase_oaFeature, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaFeature*& get(oaUInt4 index)\n"
"    Signature: get|ptrref-oaFeature|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaFeature_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaFeature data;
    int convert_status=PyoaArrayBase_oaFeature_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaFeatureObject* self=(PyoaArrayBase_oaFeatureObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaFeaturep* result=&(data.DataCall()->get(p1.Data()));
        return PyoaFeature_FromoaFeature(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaFeature_getNumElements_doc[] = 
"Class: oaArrayBase_oaFeature, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaFeature_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaFeature data;
    int convert_status=PyoaArrayBase_oaFeature_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaFeatureObject* self=(PyoaArrayBase_oaFeatureObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaFeature_getSize_doc[] = 
"Class: oaArrayBase_oaFeature, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaFeature_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaFeature data;
    int convert_status=PyoaArrayBase_oaFeature_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaFeatureObject* self=(PyoaArrayBase_oaFeatureObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaFeature_set_doc[] = 
"Class: oaArrayBase_oaFeature, Function: set\n"
"  Paramegers: ([oaFeature])\n"
"    Calls: void set( array)\n"
"    Signature: set|void-void|cpptr-oaFeature,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaFeature_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaFeature data;
    int convert_status=PyoaArrayBase_oaFeature_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaFeatureObject* self=(PyoaArrayBase_oaFeatureObject*)ob;

    PyParamoaFeature_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaFeature_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaFeature_setNumElements_doc[] = 
"Class: oaArrayBase_oaFeature, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaFeature_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaFeature data;
    int convert_status=PyoaArrayBase_oaFeature_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaFeatureObject* self=(PyoaArrayBase_oaFeatureObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaFeature_setSize_doc[] = 
"Class: oaArrayBase_oaFeature, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaFeature_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaFeature data;
    int convert_status=PyoaArrayBase_oaFeature_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaFeatureObject* self=(PyoaArrayBase_oaFeatureObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaFeature, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaFeature_assign_doc[] = 
"Class: oaArrayBase_oaFeature, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaFeature_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaFeature data;
  int convert_status=PyoaArrayBase_oaFeature_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaFeature p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaFeature_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaFeature_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaFeature_get,METH_VARARGS,oaArrayBase_oaFeature_get_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaFeature_getNumElements,METH_VARARGS,oaArrayBase_oaFeature_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaFeature_getSize,METH_VARARGS,oaArrayBase_oaFeature_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaFeature_set,METH_VARARGS,oaArrayBase_oaFeature_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaFeature_setNumElements,METH_VARARGS,oaArrayBase_oaFeature_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaFeature_setSize,METH_VARARGS,oaArrayBase_oaFeature_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaFeature_tp_assign,METH_VARARGS,oaArrayBase_oaFeature_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaFeature_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaFeature_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaFeature_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaFeature_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaFeature_doc[] = 
"Class: oaArrayBase_oaFeature\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaFeature()\n"
"    Signature: oaArrayBase_oaFeature||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaFeature(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaFeature||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaFeature)\n"
"    Calls: oaArrayBase_oaFeature(const oaArrayBase_oaFeature& array)\n"
"    Signature: oaArrayBase_oaFeature||cref-oaArrayBase_oaFeature,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaFeature])\n"
"    Calls: oaArrayBase_oaFeature( array)\n"
"    Signature: oaArrayBase_oaFeature||cpptr-oaFeature,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaFeature)\n"
"    Calls: (const oaArrayBase_oaFeature&)\n"
"    Signature: oaArrayBase_oaFeature||cref-oaArrayBase_oaFeature,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaFeature_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaFeature",
    sizeof(PyoaArrayBase_oaFeatureObject),
    0,
    (destructor)oaArrayBase_oaFeature_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaFeature_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaFeature_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaFeature_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaFeature_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaFeature_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaFeature_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaFeature_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaFeature_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaFeature\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaFeature",
           (PyObject*)(&PyoaArrayBase_oaFeature_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaFeature\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaFig
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaFig_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaFig_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaFigObject* self = (PyoaArrayBase_oaFigObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaFig();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaFig(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaFig)
    {
        PyParamoaArrayBase_oaFig p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaFig_Convert,&p1)) {
            self->value =  new oaArrayBase_oaFig(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaFig])
    {
        PyParamoaFig_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaFig_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaFig(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaFig, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaFig)\n"
        "    ([oaFig])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaFig_tp_dealloc(PyoaArrayBase_oaFigObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaFig_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaFig value;
    int convert_status=PyoaArrayBase_oaFig_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[39];
    sprintf(buffer,"<oaArrayBase_oaFig::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaFig_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaFig v1;
    PyParamoaArrayBase_oaFig v2;
    int convert_status1=PyoaArrayBase_oaFig_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaFig_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaFig_Convert(PyObject* ob,PyParamoaArrayBase_oaFig* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaFig_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaFigObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaFig Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaFig_FromoaArrayBase_oaFig(oaArrayBase_oaFig* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaFig_Type.tp_alloc(&PyoaArrayBase_oaFig_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaFigObject* self = (PyoaArrayBase_oaFigObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaFig_index_get_doc[] = 
"Class: oaArrayBase_oaFig, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaFig_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaFigObject* self=(PyoaArrayBase_oaFigObject*)ob;
  try {
    PyParamoaArrayBase_oaFig data;
    int convert_status=PyoaArrayBase_oaFig_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaFigObject* self=(PyoaArrayBase_oaFigObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaFigp* result=&(data.Data()[index]);
    return PyoaFig_FromoaFig(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaFig_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaFig data;
    int convert_status=PyoaArrayBase_oaFig_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaFigObject* self=(PyoaArrayBase_oaFigObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaFig_index_set_doc[] = 
"Class: oaArrayBase_oaFig, Function: index_set\n"
;

static int
oaArrayBase_oaFig_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaFig data;
    int convert_status=PyoaArrayBase_oaFig_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaFigObject* self=(PyoaArrayBase_oaFigObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaFig result;
    if (PyoaFig_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaFig_get_doc[] = 
"Class: oaArrayBase_oaFig, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaFig*& get(oaUInt4 index)\n"
"    Signature: get|ptrref-oaFig|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaFig_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaFig data;
    int convert_status=PyoaArrayBase_oaFig_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaFigObject* self=(PyoaArrayBase_oaFigObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaFigp* result=&(data.DataCall()->get(p1.Data()));
        return PyoaFig_FromoaFig(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaFig_getNumElements_doc[] = 
"Class: oaArrayBase_oaFig, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaFig_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaFig data;
    int convert_status=PyoaArrayBase_oaFig_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaFigObject* self=(PyoaArrayBase_oaFigObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaFig_getSize_doc[] = 
"Class: oaArrayBase_oaFig, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaFig_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaFig data;
    int convert_status=PyoaArrayBase_oaFig_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaFigObject* self=(PyoaArrayBase_oaFigObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaFig_set_doc[] = 
"Class: oaArrayBase_oaFig, Function: set\n"
"  Paramegers: ([oaFig])\n"
"    Calls: void set( array)\n"
"    Signature: set|void-void|cpptr-oaFig,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaFig_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaFig data;
    int convert_status=PyoaArrayBase_oaFig_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaFigObject* self=(PyoaArrayBase_oaFigObject*)ob;

    PyParamoaFig_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaFig_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaFig_setNumElements_doc[] = 
"Class: oaArrayBase_oaFig, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaFig_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaFig data;
    int convert_status=PyoaArrayBase_oaFig_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaFigObject* self=(PyoaArrayBase_oaFigObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaFig_setSize_doc[] = 
"Class: oaArrayBase_oaFig, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaFig_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaFig data;
    int convert_status=PyoaArrayBase_oaFig_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaFigObject* self=(PyoaArrayBase_oaFigObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaFig, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaFig_assign_doc[] = 
"Class: oaArrayBase_oaFig, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaFig_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaFig data;
  int convert_status=PyoaArrayBase_oaFig_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaFig p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaFig_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaFig_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaFig_get,METH_VARARGS,oaArrayBase_oaFig_get_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaFig_getNumElements,METH_VARARGS,oaArrayBase_oaFig_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaFig_getSize,METH_VARARGS,oaArrayBase_oaFig_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaFig_set,METH_VARARGS,oaArrayBase_oaFig_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaFig_setNumElements,METH_VARARGS,oaArrayBase_oaFig_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaFig_setSize,METH_VARARGS,oaArrayBase_oaFig_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaFig_tp_assign,METH_VARARGS,oaArrayBase_oaFig_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaFig_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaFig_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaFig_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaFig_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaFig_doc[] = 
"Class: oaArrayBase_oaFig\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaFig()\n"
"    Signature: oaArrayBase_oaFig||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaFig(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaFig||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaFig)\n"
"    Calls: oaArrayBase_oaFig(const oaArrayBase_oaFig& array)\n"
"    Signature: oaArrayBase_oaFig||cref-oaArrayBase_oaFig,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaFig])\n"
"    Calls: oaArrayBase_oaFig( array)\n"
"    Signature: oaArrayBase_oaFig||cpptr-oaFig,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaFig)\n"
"    Calls: (const oaArrayBase_oaFig&)\n"
"    Signature: oaArrayBase_oaFig||cref-oaArrayBase_oaFig,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaFig_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaFig",
    sizeof(PyoaArrayBase_oaFigObject),
    0,
    (destructor)oaArrayBase_oaFig_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaFig_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaFig_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaFig_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaFig_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaFig_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaFig_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaFig_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaFig_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaFig\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaFig",
           (PyObject*)(&PyoaArrayBase_oaFig_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaFig\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaLayerMap
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaLayerMap_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaLayerMap_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaLayerMapObject* self = (PyoaArrayBase_oaLayerMapObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaLayerMap();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaLayerMap(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaLayerMap)
    {
        PyParamoaArrayBase_oaLayerMap p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaLayerMap_Convert,&p1)) {
            self->value =  new oaArrayBase_oaLayerMap(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaLayerMap])
    {
        PyParamoaLayerMap_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaLayerMap_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaLayerMap(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaLayerMap, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaLayerMap)\n"
        "    ([oaLayerMap])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaLayerMap_tp_dealloc(PyoaArrayBase_oaLayerMapObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaLayerMap_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaLayerMap value;
    int convert_status=PyoaArrayBase_oaLayerMap_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[44];
    sprintf(buffer,"<oaArrayBase_oaLayerMap::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaLayerMap_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaLayerMap v1;
    PyParamoaArrayBase_oaLayerMap v2;
    int convert_status1=PyoaArrayBase_oaLayerMap_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaLayerMap_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaLayerMap_Convert(PyObject* ob,PyParamoaArrayBase_oaLayerMap* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaLayerMap_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaLayerMapObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaLayerMap Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaLayerMap_FromoaArrayBase_oaLayerMap(oaArrayBase_oaLayerMap* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaLayerMap_Type.tp_alloc(&PyoaArrayBase_oaLayerMap_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaLayerMapObject* self = (PyoaArrayBase_oaLayerMapObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaLayerMap_index_get_doc[] = 
"Class: oaArrayBase_oaLayerMap, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaLayerMap_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaLayerMapObject* self=(PyoaArrayBase_oaLayerMapObject*)ob;
  try {
    PyParamoaArrayBase_oaLayerMap data;
    int convert_status=PyoaArrayBase_oaLayerMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLayerMapObject* self=(PyoaArrayBase_oaLayerMapObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaLayerMap* result=&(data.Data()[index]);
    return PyoaLayerMap_FromoaLayerMap(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaLayerMap_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaLayerMap data;
    int convert_status=PyoaArrayBase_oaLayerMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLayerMapObject* self=(PyoaArrayBase_oaLayerMapObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaLayerMap_index_set_doc[] = 
"Class: oaArrayBase_oaLayerMap, Function: index_set\n"
;

static int
oaArrayBase_oaLayerMap_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaLayerMap data;
    int convert_status=PyoaArrayBase_oaLayerMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLayerMapObject* self=(PyoaArrayBase_oaLayerMapObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaLayerMap result;
    if (PyoaLayerMap_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaLayerMap_get_doc[] = 
"Class: oaArrayBase_oaLayerMap, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaLayerMap& get(oaUInt4 index)\n"
"    Signature: get|ref-oaLayerMap|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaLayerMap_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaLayerMap data;
    int convert_status=PyoaArrayBase_oaLayerMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLayerMapObject* self=(PyoaArrayBase_oaLayerMapObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaLayerMap* result=&(data.DataCall()->get(p1.Data()));
        return PyoaLayerMap_FromoaLayerMap(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaLayerMap_getElements_doc[] = 
"Class: oaArrayBase_oaLayerMap, Function: getElements\n"
"  Paramegers: ()\n"
"    Calls: const oaLayerMap* getElements() const\n"
"    Signature: getElements|cptr-oaLayerMap|\n"
"    BrowseData: 1\n"
"    This function returns a const pointer to the elements in this oaArrayBase<T> array. This may be useful to those applications that want to memcpy the data in this array.\n"
;

static PyObject*
oaArrayBase_oaLayerMap_getElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaLayerMap data;
    int convert_status=PyoaArrayBase_oaLayerMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLayerMapObject* self=(PyoaArrayBase_oaLayerMapObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaLayerMap* result=(oaLayerMap*)(data.DataCall()->getElements());
        return PyoaLayerMap_Array_FromoaLayerMap_Array(result,(data.Data().getNumElements()),ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaLayerMap_getNumElements_doc[] = 
"Class: oaArrayBase_oaLayerMap, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaLayerMap_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaLayerMap data;
    int convert_status=PyoaArrayBase_oaLayerMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLayerMapObject* self=(PyoaArrayBase_oaLayerMapObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaLayerMap_getSize_doc[] = 
"Class: oaArrayBase_oaLayerMap, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaLayerMap_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaLayerMap data;
    int convert_status=PyoaArrayBase_oaLayerMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLayerMapObject* self=(PyoaArrayBase_oaLayerMapObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaLayerMap_set_doc[] = 
"Class: oaArrayBase_oaLayerMap, Function: set\n"
"  Paramegers: ([oaLayerMap])\n"
"    Calls: void set(const oaLayerMap* array)\n"
"    Signature: set|void-void|cptr-oaLayerMap,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaLayerMap_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaLayerMap data;
    int convert_status=PyoaArrayBase_oaLayerMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLayerMapObject* self=(PyoaArrayBase_oaLayerMapObject*)ob;

    PyParamoaLayerMap_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaLayerMap_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaLayerMap_setNumElements_doc[] = 
"Class: oaArrayBase_oaLayerMap, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaLayerMap_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaLayerMap data;
    int convert_status=PyoaArrayBase_oaLayerMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLayerMapObject* self=(PyoaArrayBase_oaLayerMapObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaLayerMap_setSize_doc[] = 
"Class: oaArrayBase_oaLayerMap, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaLayerMap_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaLayerMap data;
    int convert_status=PyoaArrayBase_oaLayerMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLayerMapObject* self=(PyoaArrayBase_oaLayerMapObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaLayerMap, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaLayerMap_assign_doc[] = 
"Class: oaArrayBase_oaLayerMap, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaLayerMap_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaLayerMap data;
  int convert_status=PyoaArrayBase_oaLayerMap_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaLayerMap p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaLayerMap_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaLayerMap_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaLayerMap_get,METH_VARARGS,oaArrayBase_oaLayerMap_get_doc},
    {"getElements",(PyCFunction)oaArrayBase_oaLayerMap_getElements,METH_VARARGS,oaArrayBase_oaLayerMap_getElements_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaLayerMap_getNumElements,METH_VARARGS,oaArrayBase_oaLayerMap_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaLayerMap_getSize,METH_VARARGS,oaArrayBase_oaLayerMap_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaLayerMap_set,METH_VARARGS,oaArrayBase_oaLayerMap_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaLayerMap_setNumElements,METH_VARARGS,oaArrayBase_oaLayerMap_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaLayerMap_setSize,METH_VARARGS,oaArrayBase_oaLayerMap_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaLayerMap_tp_assign,METH_VARARGS,oaArrayBase_oaLayerMap_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaLayerMap_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaLayerMap_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaLayerMap_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaLayerMap_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaLayerMap_doc[] = 
"Class: oaArrayBase_oaLayerMap\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaLayerMap()\n"
"    Signature: oaArrayBase_oaLayerMap||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaLayerMap(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaLayerMap||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaLayerMap)\n"
"    Calls: oaArrayBase_oaLayerMap(const oaArrayBase_oaLayerMap& array)\n"
"    Signature: oaArrayBase_oaLayerMap||cref-oaArrayBase_oaLayerMap,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaLayerMap])\n"
"    Calls: oaArrayBase_oaLayerMap(const oaLayerMap* array)\n"
"    Signature: oaArrayBase_oaLayerMap||cptr-oaLayerMap,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaLayerMap)\n"
"    Calls: (const oaArrayBase_oaLayerMap&)\n"
"    Signature: oaArrayBase_oaLayerMap||cref-oaArrayBase_oaLayerMap,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaLayerMap_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaLayerMap",
    sizeof(PyoaArrayBase_oaLayerMapObject),
    0,
    (destructor)oaArrayBase_oaLayerMap_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaLayerMap_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaLayerMap_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaLayerMap_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaLayerMap_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaLayerMap_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaLayerMap_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaLayerMap_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaLayerMap_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaLayerMap\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaLayerMap",
           (PyObject*)(&PyoaArrayBase_oaLayerMap_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaLayerMap\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaLayerNum
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaLayerNum_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaLayerNum_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaLayerNumObject* self = (PyoaArrayBase_oaLayerNumObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaLayerNum();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaLayerNum(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaLayerNum)
    {
        PyParamoaArrayBase_oaLayerNum p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaLayerNum_Convert,&p1)) {
            self->value =  new oaArrayBase_oaLayerNum(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaLayerNum])
    {
        PyParamoaLayerNum_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaLayerNum_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaLayerNum(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaLayerNum, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaLayerNum)\n"
        "    ([oaLayerNum])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaLayerNum_tp_dealloc(PyoaArrayBase_oaLayerNumObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaLayerNum_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaLayerNum value;
    int convert_status=PyoaArrayBase_oaLayerNum_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[44];
    sprintf(buffer,"<oaArrayBase_oaLayerNum::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaLayerNum_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaLayerNum v1;
    PyParamoaArrayBase_oaLayerNum v2;
    int convert_status1=PyoaArrayBase_oaLayerNum_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaLayerNum_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaLayerNum_Convert(PyObject* ob,PyParamoaArrayBase_oaLayerNum* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaLayerNum_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaLayerNumObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaLayerNum Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaLayerNum_FromoaArrayBase_oaLayerNum(oaArrayBase_oaLayerNum* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaLayerNum_Type.tp_alloc(&PyoaArrayBase_oaLayerNum_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaLayerNumObject* self = (PyoaArrayBase_oaLayerNumObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaLayerNum_index_get_doc[] = 
"Class: oaArrayBase_oaLayerNum, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaLayerNum_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaLayerNumObject* self=(PyoaArrayBase_oaLayerNumObject*)ob;
  try {
    PyParamoaArrayBase_oaLayerNum data;
    int convert_status=PyoaArrayBase_oaLayerNum_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLayerNumObject* self=(PyoaArrayBase_oaLayerNumObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaLayerNum* result=&(data.Data()[index]);
    return PyoaLayerNum_FromoaLayerNum(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaLayerNum_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaLayerNum data;
    int convert_status=PyoaArrayBase_oaLayerNum_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLayerNumObject* self=(PyoaArrayBase_oaLayerNumObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaLayerNum_index_set_doc[] = 
"Class: oaArrayBase_oaLayerNum, Function: index_set\n"
;

static int
oaArrayBase_oaLayerNum_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaLayerNum data;
    int convert_status=PyoaArrayBase_oaLayerNum_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLayerNumObject* self=(PyoaArrayBase_oaLayerNumObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaLayerNum result;
    if (PyoaLayerNum_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaLayerNum_get_doc[] = 
"Class: oaArrayBase_oaLayerNum, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaLayerNum& get(oaUInt4 index)\n"
"    Signature: get|ref-oaLayerNum|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaLayerNum_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaLayerNum data;
    int convert_status=PyoaArrayBase_oaLayerNum_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLayerNumObject* self=(PyoaArrayBase_oaLayerNumObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaLayerNum* result=&(data.DataCall()->get(p1.Data()));
        return PyoaLayerNum_FromoaLayerNum(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaLayerNum_getElements_doc[] = 
"Class: oaArrayBase_oaLayerNum, Function: getElements\n"
"  Paramegers: ()\n"
"    Calls: const oaLayerNum* getElements() const\n"
"    Signature: getElements|cptr-oaLayerNum|\n"
"    BrowseData: 1\n"
"    This function returns a const pointer to the elements in this oaArrayBase<T> array. This may be useful to those applications that want to memcpy the data in this array.\n"
;

static PyObject*
oaArrayBase_oaLayerNum_getElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaLayerNum data;
    int convert_status=PyoaArrayBase_oaLayerNum_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLayerNumObject* self=(PyoaArrayBase_oaLayerNumObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaLayerNum* result=(oaLayerNum*)(data.DataCall()->getElements());
        return PyoaLayerNum_Array_FromoaLayerNum_Array(result,(data.Data().getNumElements()),ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaLayerNum_getNumElements_doc[] = 
"Class: oaArrayBase_oaLayerNum, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaLayerNum_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaLayerNum data;
    int convert_status=PyoaArrayBase_oaLayerNum_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLayerNumObject* self=(PyoaArrayBase_oaLayerNumObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaLayerNum_getSize_doc[] = 
"Class: oaArrayBase_oaLayerNum, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaLayerNum_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaLayerNum data;
    int convert_status=PyoaArrayBase_oaLayerNum_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLayerNumObject* self=(PyoaArrayBase_oaLayerNumObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaLayerNum_set_doc[] = 
"Class: oaArrayBase_oaLayerNum, Function: set\n"
"  Paramegers: ([oaLayerNum])\n"
"    Calls: void set(const oaLayerNum* array)\n"
"    Signature: set|void-void|cptr-oaLayerNum,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaLayerNum_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaLayerNum data;
    int convert_status=PyoaArrayBase_oaLayerNum_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLayerNumObject* self=(PyoaArrayBase_oaLayerNumObject*)ob;

    PyParamoaLayerNum_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaLayerNum_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaLayerNum_setNumElements_doc[] = 
"Class: oaArrayBase_oaLayerNum, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaLayerNum_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaLayerNum data;
    int convert_status=PyoaArrayBase_oaLayerNum_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLayerNumObject* self=(PyoaArrayBase_oaLayerNumObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaLayerNum_setSize_doc[] = 
"Class: oaArrayBase_oaLayerNum, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaLayerNum_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaLayerNum data;
    int convert_status=PyoaArrayBase_oaLayerNum_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLayerNumObject* self=(PyoaArrayBase_oaLayerNumObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaLayerNum, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaLayerNum_assign_doc[] = 
"Class: oaArrayBase_oaLayerNum, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaLayerNum_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaLayerNum data;
  int convert_status=PyoaArrayBase_oaLayerNum_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaLayerNum p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaLayerNum_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaLayerNum_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaLayerNum_get,METH_VARARGS,oaArrayBase_oaLayerNum_get_doc},
    {"getElements",(PyCFunction)oaArrayBase_oaLayerNum_getElements,METH_VARARGS,oaArrayBase_oaLayerNum_getElements_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaLayerNum_getNumElements,METH_VARARGS,oaArrayBase_oaLayerNum_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaLayerNum_getSize,METH_VARARGS,oaArrayBase_oaLayerNum_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaLayerNum_set,METH_VARARGS,oaArrayBase_oaLayerNum_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaLayerNum_setNumElements,METH_VARARGS,oaArrayBase_oaLayerNum_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaLayerNum_setSize,METH_VARARGS,oaArrayBase_oaLayerNum_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaLayerNum_tp_assign,METH_VARARGS,oaArrayBase_oaLayerNum_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaLayerNum_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaLayerNum_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaLayerNum_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaLayerNum_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaLayerNum_doc[] = 
"Class: oaArrayBase_oaLayerNum\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaLayerNum()\n"
"    Signature: oaArrayBase_oaLayerNum||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaLayerNum(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaLayerNum||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaLayerNum)\n"
"    Calls: oaArrayBase_oaLayerNum(const oaArrayBase_oaLayerNum& array)\n"
"    Signature: oaArrayBase_oaLayerNum||cref-oaArrayBase_oaLayerNum,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaLayerNum])\n"
"    Calls: oaArrayBase_oaLayerNum(const oaLayerNum* array)\n"
"    Signature: oaArrayBase_oaLayerNum||cptr-oaLayerNum,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaLayerNum)\n"
"    Calls: (const oaArrayBase_oaLayerNum&)\n"
"    Signature: oaArrayBase_oaLayerNum||cref-oaArrayBase_oaLayerNum,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaLayerNum_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaLayerNum",
    sizeof(PyoaArrayBase_oaLayerNumObject),
    0,
    (destructor)oaArrayBase_oaLayerNum_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaLayerNum_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaLayerNum_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaLayerNum_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaLayerNum_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaLayerNum_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaLayerNum_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaLayerNum_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaLayerNum_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaLayerNum\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaLayerNum",
           (PyObject*)(&PyoaArrayBase_oaLayerNum_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaLayerNum\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaLib
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaLib_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaLib_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaLibObject* self = (PyoaArrayBase_oaLibObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaLib();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaLib(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaLib)
    {
        PyParamoaArrayBase_oaLib p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaLib_Convert,&p1)) {
            self->value =  new oaArrayBase_oaLib(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaLib])
    {
        PyParamoaLib_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaLib_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaLib(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaLib, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaLib)\n"
        "    ([oaLib])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaLib_tp_dealloc(PyoaArrayBase_oaLibObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaLib_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaLib value;
    int convert_status=PyoaArrayBase_oaLib_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[39];
    sprintf(buffer,"<oaArrayBase_oaLib::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaLib_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaLib v1;
    PyParamoaArrayBase_oaLib v2;
    int convert_status1=PyoaArrayBase_oaLib_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaLib_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaLib_Convert(PyObject* ob,PyParamoaArrayBase_oaLib* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaLib_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaLibObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaLib Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaLib_FromoaArrayBase_oaLib(oaArrayBase_oaLib* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaLib_Type.tp_alloc(&PyoaArrayBase_oaLib_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaLibObject* self = (PyoaArrayBase_oaLibObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaLib_index_get_doc[] = 
"Class: oaArrayBase_oaLib, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaLib_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaLibObject* self=(PyoaArrayBase_oaLibObject*)ob;
  try {
    PyParamoaArrayBase_oaLib data;
    int convert_status=PyoaArrayBase_oaLib_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLibObject* self=(PyoaArrayBase_oaLibObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaLibp* result=&(data.Data()[index]);
    return PyoaLib_FromoaLib(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaLib_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaLib data;
    int convert_status=PyoaArrayBase_oaLib_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLibObject* self=(PyoaArrayBase_oaLibObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaLib_index_set_doc[] = 
"Class: oaArrayBase_oaLib, Function: index_set\n"
;

static int
oaArrayBase_oaLib_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaLib data;
    int convert_status=PyoaArrayBase_oaLib_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLibObject* self=(PyoaArrayBase_oaLibObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaLib result;
    if (PyoaLib_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaLib_get_doc[] = 
"Class: oaArrayBase_oaLib, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaLib*& get(oaUInt4 index)\n"
"    Signature: get|ptrref-oaLib|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaLib_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaLib data;
    int convert_status=PyoaArrayBase_oaLib_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLibObject* self=(PyoaArrayBase_oaLibObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaLibp* result=&(data.DataCall()->get(p1.Data()));
        return PyoaLib_FromoaLib(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaLib_getNumElements_doc[] = 
"Class: oaArrayBase_oaLib, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaLib_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaLib data;
    int convert_status=PyoaArrayBase_oaLib_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLibObject* self=(PyoaArrayBase_oaLibObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaLib_getSize_doc[] = 
"Class: oaArrayBase_oaLib, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaLib_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaLib data;
    int convert_status=PyoaArrayBase_oaLib_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLibObject* self=(PyoaArrayBase_oaLibObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaLib_set_doc[] = 
"Class: oaArrayBase_oaLib, Function: set\n"
"  Paramegers: ([oaLib])\n"
"    Calls: void set( array)\n"
"    Signature: set|void-void|cpptr-oaLib,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaLib_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaLib data;
    int convert_status=PyoaArrayBase_oaLib_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLibObject* self=(PyoaArrayBase_oaLibObject*)ob;

    PyParamoaLib_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaLib_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaLib_setNumElements_doc[] = 
"Class: oaArrayBase_oaLib, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaLib_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaLib data;
    int convert_status=PyoaArrayBase_oaLib_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLibObject* self=(PyoaArrayBase_oaLibObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaLib_setSize_doc[] = 
"Class: oaArrayBase_oaLib, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaLib_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaLib data;
    int convert_status=PyoaArrayBase_oaLib_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaLibObject* self=(PyoaArrayBase_oaLibObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaLib, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaLib_assign_doc[] = 
"Class: oaArrayBase_oaLib, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaLib_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaLib data;
  int convert_status=PyoaArrayBase_oaLib_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaLib p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaLib_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaLib_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaLib_get,METH_VARARGS,oaArrayBase_oaLib_get_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaLib_getNumElements,METH_VARARGS,oaArrayBase_oaLib_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaLib_getSize,METH_VARARGS,oaArrayBase_oaLib_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaLib_set,METH_VARARGS,oaArrayBase_oaLib_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaLib_setNumElements,METH_VARARGS,oaArrayBase_oaLib_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaLib_setSize,METH_VARARGS,oaArrayBase_oaLib_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaLib_tp_assign,METH_VARARGS,oaArrayBase_oaLib_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaLib_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaLib_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaLib_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaLib_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaLib_doc[] = 
"Class: oaArrayBase_oaLib\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaLib()\n"
"    Signature: oaArrayBase_oaLib||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaLib(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaLib||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaLib)\n"
"    Calls: oaArrayBase_oaLib(const oaArrayBase_oaLib& array)\n"
"    Signature: oaArrayBase_oaLib||cref-oaArrayBase_oaLib,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaLib])\n"
"    Calls: oaArrayBase_oaLib( array)\n"
"    Signature: oaArrayBase_oaLib||cpptr-oaLib,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaLib)\n"
"    Calls: (const oaArrayBase_oaLib&)\n"
"    Signature: oaArrayBase_oaLib||cref-oaArrayBase_oaLib,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaLib_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaLib",
    sizeof(PyoaArrayBase_oaLibObject),
    0,
    (destructor)oaArrayBase_oaLib_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaLib_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaLib_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaLib_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaLib_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaLib_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaLib_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaLib_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaLib_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaLib\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaLib",
           (PyObject*)(&PyoaArrayBase_oaLib_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaLib\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaModTerm
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaModTerm_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaModTerm_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaModTermObject* self = (PyoaArrayBase_oaModTermObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaModTerm();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaModTerm(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaModTerm)
    {
        PyParamoaArrayBase_oaModTerm p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaModTerm_Convert,&p1)) {
            self->value =  new oaArrayBase_oaModTerm(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaModTerm])
    {
        PyParamoaModTerm_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaModTerm_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaModTerm(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaModTerm, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaModTerm)\n"
        "    ([oaModTerm])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaModTerm_tp_dealloc(PyoaArrayBase_oaModTermObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaModTerm_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaModTerm value;
    int convert_status=PyoaArrayBase_oaModTerm_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaArrayBase_oaModTerm::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaModTerm_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaModTerm v1;
    PyParamoaArrayBase_oaModTerm v2;
    int convert_status1=PyoaArrayBase_oaModTerm_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaModTerm_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaModTerm_Convert(PyObject* ob,PyParamoaArrayBase_oaModTerm* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaModTerm_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaModTermObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaModTerm Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaModTerm_FromoaArrayBase_oaModTerm(oaArrayBase_oaModTerm* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaModTerm_Type.tp_alloc(&PyoaArrayBase_oaModTerm_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaModTermObject* self = (PyoaArrayBase_oaModTermObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaModTerm_index_get_doc[] = 
"Class: oaArrayBase_oaModTerm, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaModTerm_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaModTermObject* self=(PyoaArrayBase_oaModTermObject*)ob;
  try {
    PyParamoaArrayBase_oaModTerm data;
    int convert_status=PyoaArrayBase_oaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaModTermObject* self=(PyoaArrayBase_oaModTermObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaModTermp* result=&(data.Data()[index]);
    return PyoaModTerm_FromoaModTerm(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaModTerm_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaModTerm data;
    int convert_status=PyoaArrayBase_oaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaModTermObject* self=(PyoaArrayBase_oaModTermObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaModTerm_index_set_doc[] = 
"Class: oaArrayBase_oaModTerm, Function: index_set\n"
;

static int
oaArrayBase_oaModTerm_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaModTerm data;
    int convert_status=PyoaArrayBase_oaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaModTermObject* self=(PyoaArrayBase_oaModTermObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaModTerm result;
    if (PyoaModTerm_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaModTerm_get_doc[] = 
"Class: oaArrayBase_oaModTerm, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaModTerm*& get(oaUInt4 index)\n"
"    Signature: get|ptrref-oaModTerm|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaModTerm_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaModTerm data;
    int convert_status=PyoaArrayBase_oaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaModTermObject* self=(PyoaArrayBase_oaModTermObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaModTermp* result=&(data.DataCall()->get(p1.Data()));
        return PyoaModTerm_FromoaModTerm(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaModTerm_getNumElements_doc[] = 
"Class: oaArrayBase_oaModTerm, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaModTerm_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaModTerm data;
    int convert_status=PyoaArrayBase_oaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaModTermObject* self=(PyoaArrayBase_oaModTermObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaModTerm_getSize_doc[] = 
"Class: oaArrayBase_oaModTerm, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaModTerm_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaModTerm data;
    int convert_status=PyoaArrayBase_oaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaModTermObject* self=(PyoaArrayBase_oaModTermObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaModTerm_set_doc[] = 
"Class: oaArrayBase_oaModTerm, Function: set\n"
"  Paramegers: ([oaModTerm])\n"
"    Calls: void set( array)\n"
"    Signature: set|void-void|cpptr-oaModTerm,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaModTerm_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaModTerm data;
    int convert_status=PyoaArrayBase_oaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaModTermObject* self=(PyoaArrayBase_oaModTermObject*)ob;

    PyParamoaModTerm_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaModTerm_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaModTerm_setNumElements_doc[] = 
"Class: oaArrayBase_oaModTerm, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaModTerm_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaModTerm data;
    int convert_status=PyoaArrayBase_oaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaModTermObject* self=(PyoaArrayBase_oaModTermObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaModTerm_setSize_doc[] = 
"Class: oaArrayBase_oaModTerm, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaModTerm_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaModTerm data;
    int convert_status=PyoaArrayBase_oaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaModTermObject* self=(PyoaArrayBase_oaModTermObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaModTerm, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaModTerm_assign_doc[] = 
"Class: oaArrayBase_oaModTerm, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaModTerm_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaModTerm data;
  int convert_status=PyoaArrayBase_oaModTerm_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaModTerm p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaModTerm_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaModTerm_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaModTerm_get,METH_VARARGS,oaArrayBase_oaModTerm_get_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaModTerm_getNumElements,METH_VARARGS,oaArrayBase_oaModTerm_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaModTerm_getSize,METH_VARARGS,oaArrayBase_oaModTerm_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaModTerm_set,METH_VARARGS,oaArrayBase_oaModTerm_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaModTerm_setNumElements,METH_VARARGS,oaArrayBase_oaModTerm_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaModTerm_setSize,METH_VARARGS,oaArrayBase_oaModTerm_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaModTerm_tp_assign,METH_VARARGS,oaArrayBase_oaModTerm_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaModTerm_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaModTerm_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaModTerm_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaModTerm_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaModTerm_doc[] = 
"Class: oaArrayBase_oaModTerm\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaModTerm()\n"
"    Signature: oaArrayBase_oaModTerm||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaModTerm(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaModTerm||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaModTerm)\n"
"    Calls: oaArrayBase_oaModTerm(const oaArrayBase_oaModTerm& array)\n"
"    Signature: oaArrayBase_oaModTerm||cref-oaArrayBase_oaModTerm,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaModTerm])\n"
"    Calls: oaArrayBase_oaModTerm( array)\n"
"    Signature: oaArrayBase_oaModTerm||cpptr-oaModTerm,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaModTerm)\n"
"    Calls: (const oaArrayBase_oaModTerm&)\n"
"    Signature: oaArrayBase_oaModTerm||cref-oaArrayBase_oaModTerm,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaModTerm_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaModTerm",
    sizeof(PyoaArrayBase_oaModTermObject),
    0,
    (destructor)oaArrayBase_oaModTerm_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaModTerm_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaModTerm_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaModTerm_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaModTerm_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaModTerm_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaModTerm_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaModTerm_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaModTerm_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaModTerm\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaModTerm",
           (PyObject*)(&PyoaArrayBase_oaModTerm_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaModTerm\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaObject
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaObject_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaObject_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaObjectObject* self = (PyoaArrayBase_oaObjectObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaObject();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaObject(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaObject)
    {
        PyParamoaArrayBase_oaObject p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaObject_Convert,&p1)) {
            self->value =  new oaArrayBase_oaObject(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaObject])
    {
        PyParamoaObject_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaObject_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaObject(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaObject, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaObject)\n"
        "    ([oaObject])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaObject_tp_dealloc(PyoaArrayBase_oaObjectObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaObject_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaObject value;
    int convert_status=PyoaArrayBase_oaObject_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaArrayBase_oaObject::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaObject_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaObject v1;
    PyParamoaArrayBase_oaObject v2;
    int convert_status1=PyoaArrayBase_oaObject_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaObject_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaObject_Convert(PyObject* ob,PyParamoaArrayBase_oaObject* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaObject_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaObjectObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaObject Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaObject_FromoaArrayBase_oaObject(oaArrayBase_oaObject* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaObject_Type.tp_alloc(&PyoaArrayBase_oaObject_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaObjectObject* self = (PyoaArrayBase_oaObjectObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaObject_index_get_doc[] = 
"Class: oaArrayBase_oaObject, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaObject_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaObjectObject* self=(PyoaArrayBase_oaObjectObject*)ob;
  try {
    PyParamoaArrayBase_oaObject data;
    int convert_status=PyoaArrayBase_oaObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaObjectObject* self=(PyoaArrayBase_oaObjectObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaObjectp* result=&(data.Data()[index]);
    return PyoaObject_FromoaObject(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaObject_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaObject data;
    int convert_status=PyoaArrayBase_oaObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaObjectObject* self=(PyoaArrayBase_oaObjectObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaObject_index_set_doc[] = 
"Class: oaArrayBase_oaObject, Function: index_set\n"
;

static int
oaArrayBase_oaObject_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaObject data;
    int convert_status=PyoaArrayBase_oaObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaObjectObject* self=(PyoaArrayBase_oaObjectObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaObject result;
    if (PyoaObject_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaObject_get_doc[] = 
"Class: oaArrayBase_oaObject, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObject*& get(oaUInt4 index)\n"
"    Signature: get|ptrref-oaObject|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaObject_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaObject data;
    int convert_status=PyoaArrayBase_oaObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaObjectObject* self=(PyoaArrayBase_oaObjectObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaObjectp* result=&(data.DataCall()->get(p1.Data()));
        return PyoaObject_FromoaObject(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaObject_getNumElements_doc[] = 
"Class: oaArrayBase_oaObject, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaObject_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaObject data;
    int convert_status=PyoaArrayBase_oaObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaObjectObject* self=(PyoaArrayBase_oaObjectObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaObject_getSize_doc[] = 
"Class: oaArrayBase_oaObject, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaObject_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaObject data;
    int convert_status=PyoaArrayBase_oaObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaObjectObject* self=(PyoaArrayBase_oaObjectObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaObject_set_doc[] = 
"Class: oaArrayBase_oaObject, Function: set\n"
"  Paramegers: ([oaObject])\n"
"    Calls: void set( array)\n"
"    Signature: set|void-void|cpptr-oaObject,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaObject_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaObject data;
    int convert_status=PyoaArrayBase_oaObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaObjectObject* self=(PyoaArrayBase_oaObjectObject*)ob;

    PyParamoaObject_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaObject_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaObject_setNumElements_doc[] = 
"Class: oaArrayBase_oaObject, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaObject_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaObject data;
    int convert_status=PyoaArrayBase_oaObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaObjectObject* self=(PyoaArrayBase_oaObjectObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaObject_setSize_doc[] = 
"Class: oaArrayBase_oaObject, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaObject_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaObject data;
    int convert_status=PyoaArrayBase_oaObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaObjectObject* self=(PyoaArrayBase_oaObjectObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaObject, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaObject_assign_doc[] = 
"Class: oaArrayBase_oaObject, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaObject_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaObject data;
  int convert_status=PyoaArrayBase_oaObject_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaObject p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaObject_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaObject_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaObject_get,METH_VARARGS,oaArrayBase_oaObject_get_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaObject_getNumElements,METH_VARARGS,oaArrayBase_oaObject_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaObject_getSize,METH_VARARGS,oaArrayBase_oaObject_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaObject_set,METH_VARARGS,oaArrayBase_oaObject_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaObject_setNumElements,METH_VARARGS,oaArrayBase_oaObject_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaObject_setSize,METH_VARARGS,oaArrayBase_oaObject_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaObject_tp_assign,METH_VARARGS,oaArrayBase_oaObject_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaObject_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaObject_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaObject_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaObject_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaObject_doc[] = 
"Class: oaArrayBase_oaObject\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaObject()\n"
"    Signature: oaArrayBase_oaObject||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaObject(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaObject||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaObject)\n"
"    Calls: oaArrayBase_oaObject(const oaArrayBase_oaObject& array)\n"
"    Signature: oaArrayBase_oaObject||cref-oaArrayBase_oaObject,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaObject])\n"
"    Calls: oaArrayBase_oaObject( array)\n"
"    Signature: oaArrayBase_oaObject||cpptr-oaObject,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaObject)\n"
"    Calls: (const oaArrayBase_oaObject&)\n"
"    Signature: oaArrayBase_oaObject||cref-oaArrayBase_oaObject,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaObject_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaObject",
    sizeof(PyoaArrayBase_oaObjectObject),
    0,
    (destructor)oaArrayBase_oaObject_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaObject_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaObject_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaObject_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaObject_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaObject_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaObject_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaObject_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaObject_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaObject\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaObject",
           (PyObject*)(&PyoaArrayBase_oaObject_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaObject\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaOccTerm
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaOccTerm_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaOccTerm_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaOccTermObject* self = (PyoaArrayBase_oaOccTermObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaOccTerm();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaOccTerm(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaOccTerm)
    {
        PyParamoaArrayBase_oaOccTerm p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaOccTerm_Convert,&p1)) {
            self->value =  new oaArrayBase_oaOccTerm(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaOccTerm])
    {
        PyParamoaOccTerm_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaOccTerm_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaOccTerm(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaOccTerm, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaOccTerm)\n"
        "    ([oaOccTerm])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaOccTerm_tp_dealloc(PyoaArrayBase_oaOccTermObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaOccTerm_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaOccTerm value;
    int convert_status=PyoaArrayBase_oaOccTerm_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaArrayBase_oaOccTerm::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaOccTerm_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaOccTerm v1;
    PyParamoaArrayBase_oaOccTerm v2;
    int convert_status1=PyoaArrayBase_oaOccTerm_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaOccTerm_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaOccTerm_Convert(PyObject* ob,PyParamoaArrayBase_oaOccTerm* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaOccTerm_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaOccTermObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaOccTerm Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaOccTerm_FromoaArrayBase_oaOccTerm(oaArrayBase_oaOccTerm* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaOccTerm_Type.tp_alloc(&PyoaArrayBase_oaOccTerm_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaOccTermObject* self = (PyoaArrayBase_oaOccTermObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaOccTerm_index_get_doc[] = 
"Class: oaArrayBase_oaOccTerm, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaOccTerm_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaOccTermObject* self=(PyoaArrayBase_oaOccTermObject*)ob;
  try {
    PyParamoaArrayBase_oaOccTerm data;
    int convert_status=PyoaArrayBase_oaOccTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaOccTermObject* self=(PyoaArrayBase_oaOccTermObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaOccTermp* result=&(data.Data()[index]);
    return PyoaOccTerm_FromoaOccTerm(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaOccTerm_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaOccTerm data;
    int convert_status=PyoaArrayBase_oaOccTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaOccTermObject* self=(PyoaArrayBase_oaOccTermObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaOccTerm_index_set_doc[] = 
"Class: oaArrayBase_oaOccTerm, Function: index_set\n"
;

static int
oaArrayBase_oaOccTerm_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaOccTerm data;
    int convert_status=PyoaArrayBase_oaOccTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaOccTermObject* self=(PyoaArrayBase_oaOccTermObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaOccTerm result;
    if (PyoaOccTerm_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaOccTerm_get_doc[] = 
"Class: oaArrayBase_oaOccTerm, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaOccTerm*& get(oaUInt4 index)\n"
"    Signature: get|ptrref-oaOccTerm|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaOccTerm_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaOccTerm data;
    int convert_status=PyoaArrayBase_oaOccTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaOccTermObject* self=(PyoaArrayBase_oaOccTermObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaOccTermp* result=&(data.DataCall()->get(p1.Data()));
        return PyoaOccTerm_FromoaOccTerm(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaOccTerm_getNumElements_doc[] = 
"Class: oaArrayBase_oaOccTerm, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaOccTerm_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaOccTerm data;
    int convert_status=PyoaArrayBase_oaOccTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaOccTermObject* self=(PyoaArrayBase_oaOccTermObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaOccTerm_getSize_doc[] = 
"Class: oaArrayBase_oaOccTerm, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaOccTerm_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaOccTerm data;
    int convert_status=PyoaArrayBase_oaOccTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaOccTermObject* self=(PyoaArrayBase_oaOccTermObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaOccTerm_set_doc[] = 
"Class: oaArrayBase_oaOccTerm, Function: set\n"
"  Paramegers: ([oaOccTerm])\n"
"    Calls: void set( array)\n"
"    Signature: set|void-void|cpptr-oaOccTerm,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaOccTerm_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaOccTerm data;
    int convert_status=PyoaArrayBase_oaOccTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaOccTermObject* self=(PyoaArrayBase_oaOccTermObject*)ob;

    PyParamoaOccTerm_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccTerm_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaOccTerm_setNumElements_doc[] = 
"Class: oaArrayBase_oaOccTerm, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaOccTerm_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaOccTerm data;
    int convert_status=PyoaArrayBase_oaOccTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaOccTermObject* self=(PyoaArrayBase_oaOccTermObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaOccTerm_setSize_doc[] = 
"Class: oaArrayBase_oaOccTerm, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaOccTerm_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaOccTerm data;
    int convert_status=PyoaArrayBase_oaOccTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaOccTermObject* self=(PyoaArrayBase_oaOccTermObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaOccTerm, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaOccTerm_assign_doc[] = 
"Class: oaArrayBase_oaOccTerm, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaOccTerm_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaOccTerm data;
  int convert_status=PyoaArrayBase_oaOccTerm_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaOccTerm p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaOccTerm_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaOccTerm_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaOccTerm_get,METH_VARARGS,oaArrayBase_oaOccTerm_get_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaOccTerm_getNumElements,METH_VARARGS,oaArrayBase_oaOccTerm_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaOccTerm_getSize,METH_VARARGS,oaArrayBase_oaOccTerm_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaOccTerm_set,METH_VARARGS,oaArrayBase_oaOccTerm_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaOccTerm_setNumElements,METH_VARARGS,oaArrayBase_oaOccTerm_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaOccTerm_setSize,METH_VARARGS,oaArrayBase_oaOccTerm_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaOccTerm_tp_assign,METH_VARARGS,oaArrayBase_oaOccTerm_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaOccTerm_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaOccTerm_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaOccTerm_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaOccTerm_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaOccTerm_doc[] = 
"Class: oaArrayBase_oaOccTerm\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaOccTerm()\n"
"    Signature: oaArrayBase_oaOccTerm||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaOccTerm(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaOccTerm||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaOccTerm)\n"
"    Calls: oaArrayBase_oaOccTerm(const oaArrayBase_oaOccTerm& array)\n"
"    Signature: oaArrayBase_oaOccTerm||cref-oaArrayBase_oaOccTerm,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaOccTerm])\n"
"    Calls: oaArrayBase_oaOccTerm( array)\n"
"    Signature: oaArrayBase_oaOccTerm||cpptr-oaOccTerm,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaOccTerm)\n"
"    Calls: (const oaArrayBase_oaOccTerm&)\n"
"    Signature: oaArrayBase_oaOccTerm||cref-oaArrayBase_oaOccTerm,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaOccTerm_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaOccTerm",
    sizeof(PyoaArrayBase_oaOccTermObject),
    0,
    (destructor)oaArrayBase_oaOccTerm_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaOccTerm_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaOccTerm_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaOccTerm_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaOccTerm_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaOccTerm_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaOccTerm_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaOccTerm_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaOccTerm_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaOccTerm\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaOccTerm",
           (PyObject*)(&PyoaArrayBase_oaOccTerm_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaOccTerm\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaParam
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaParam_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaParam_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaParamObject* self = (PyoaArrayBase_oaParamObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaParam();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaParam(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaParam)
    {
        PyParamoaArrayBase_oaParam p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaParam_Convert,&p1)) {
            self->value =  new oaArrayBase_oaParam(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaParam])
    {
        PyParamoaParam_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaParam_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaParam(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaParam, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaParam)\n"
        "    ([oaParam])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaParam_tp_dealloc(PyoaArrayBase_oaParamObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaParam_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaParam value;
    int convert_status=PyoaArrayBase_oaParam_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[41];
    sprintf(buffer,"<oaArrayBase_oaParam::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaParam_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaParam v1;
    PyParamoaArrayBase_oaParam v2;
    int convert_status1=PyoaArrayBase_oaParam_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaParam_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaParam_Convert(PyObject* ob,PyParamoaArrayBase_oaParam* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaParam_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaParamObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaParam Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaParam_FromoaArrayBase_oaParam(oaArrayBase_oaParam* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaParam_Type.tp_alloc(&PyoaArrayBase_oaParam_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaParamObject* self = (PyoaArrayBase_oaParamObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaParam_index_get_doc[] = 
"Class: oaArrayBase_oaParam, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaParam_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaParamObject* self=(PyoaArrayBase_oaParamObject*)ob;
  try {
    PyParamoaArrayBase_oaParam data;
    int convert_status=PyoaArrayBase_oaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaParamObject* self=(PyoaArrayBase_oaParamObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaParam* result=&(data.Data()[index]);
    return PyoaParam_FromoaParam(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaParam_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaParam data;
    int convert_status=PyoaArrayBase_oaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaParamObject* self=(PyoaArrayBase_oaParamObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaParam_index_set_doc[] = 
"Class: oaArrayBase_oaParam, Function: index_set\n"
;

static int
oaArrayBase_oaParam_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaParam data;
    int convert_status=PyoaArrayBase_oaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaParamObject* self=(PyoaArrayBase_oaParamObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaParam result;
    if (PyoaParam_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaParam_get_doc[] = 
"Class: oaArrayBase_oaParam, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaParam& get(oaUInt4 index)\n"
"    Signature: get|ref-oaParam|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaParam_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaParam data;
    int convert_status=PyoaArrayBase_oaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaParamObject* self=(PyoaArrayBase_oaParamObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaParam* result=&(data.DataCall()->get(p1.Data()));
        return PyoaParam_FromoaParam(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaParam_getElements_doc[] = 
"Class: oaArrayBase_oaParam, Function: getElements\n"
"  Paramegers: ()\n"
"    Calls: const oaParam* getElements() const\n"
"    Signature: getElements|cptr-oaParam|\n"
"    BrowseData: 1\n"
"    This function returns a const pointer to the elements in this oaArrayBase<T> array. This may be useful to those applications that want to memcpy the data in this array.\n"
;

static PyObject*
oaArrayBase_oaParam_getElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaParam data;
    int convert_status=PyoaArrayBase_oaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaParamObject* self=(PyoaArrayBase_oaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaParam* result=(oaParam*)(data.DataCall()->getElements());
        return PyoaParam_Array_FromoaParam_Array(result,(data.Data().getNumElements()),ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaParam_getNumElements_doc[] = 
"Class: oaArrayBase_oaParam, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaParam_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaParam data;
    int convert_status=PyoaArrayBase_oaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaParamObject* self=(PyoaArrayBase_oaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaParam_getSize_doc[] = 
"Class: oaArrayBase_oaParam, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaParam_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaParam data;
    int convert_status=PyoaArrayBase_oaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaParamObject* self=(PyoaArrayBase_oaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaParam_set_doc[] = 
"Class: oaArrayBase_oaParam, Function: set\n"
"  Paramegers: ([oaParam])\n"
"    Calls: void set(const oaParam* array)\n"
"    Signature: set|void-void|cptr-oaParam,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaParam_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaParam data;
    int convert_status=PyoaArrayBase_oaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaParamObject* self=(PyoaArrayBase_oaParamObject*)ob;

    PyParamoaParam_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaParam_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaParam_setNumElements_doc[] = 
"Class: oaArrayBase_oaParam, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaParam_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaParam data;
    int convert_status=PyoaArrayBase_oaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaParamObject* self=(PyoaArrayBase_oaParamObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaParam_setSize_doc[] = 
"Class: oaArrayBase_oaParam, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaParam_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaParam data;
    int convert_status=PyoaArrayBase_oaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaParamObject* self=(PyoaArrayBase_oaParamObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaParam, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaParam_assign_doc[] = 
"Class: oaArrayBase_oaParam, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaParam_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaParam data;
  int convert_status=PyoaArrayBase_oaParam_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaParam p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaParam_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaParam_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaParam_get,METH_VARARGS,oaArrayBase_oaParam_get_doc},
    {"getElements",(PyCFunction)oaArrayBase_oaParam_getElements,METH_VARARGS,oaArrayBase_oaParam_getElements_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaParam_getNumElements,METH_VARARGS,oaArrayBase_oaParam_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaParam_getSize,METH_VARARGS,oaArrayBase_oaParam_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaParam_set,METH_VARARGS,oaArrayBase_oaParam_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaParam_setNumElements,METH_VARARGS,oaArrayBase_oaParam_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaParam_setSize,METH_VARARGS,oaArrayBase_oaParam_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaParam_tp_assign,METH_VARARGS,oaArrayBase_oaParam_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaParam_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaParam_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaParam_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaParam_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaParam_doc[] = 
"Class: oaArrayBase_oaParam\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaParam()\n"
"    Signature: oaArrayBase_oaParam||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaParam(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaParam||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaParam)\n"
"    Calls: oaArrayBase_oaParam(const oaArrayBase_oaParam& array)\n"
"    Signature: oaArrayBase_oaParam||cref-oaArrayBase_oaParam,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaParam])\n"
"    Calls: oaArrayBase_oaParam(const oaParam* array)\n"
"    Signature: oaArrayBase_oaParam||cptr-oaParam,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaParam)\n"
"    Calls: (const oaArrayBase_oaParam&)\n"
"    Signature: oaArrayBase_oaParam||cref-oaArrayBase_oaParam,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaParam_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaParam",
    sizeof(PyoaArrayBase_oaParamObject),
    0,
    (destructor)oaArrayBase_oaParam_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaParam_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaParam_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaParam_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaParam_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaParam_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaParam_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaParam_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaParam_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaParam\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaParam",
           (PyObject*)(&PyoaArrayBase_oaParam_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaParam\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaPoint
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaPoint_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaPoint_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaPointObject* self = (PyoaArrayBase_oaPointObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaPoint();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaPoint(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaPoint)
    {
        PyParamoaArrayBase_oaPoint p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaPoint_Convert,&p1)) {
            self->value =  new oaArrayBase_oaPoint(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaPoint])
    {
        PyParamoaPoint_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaPoint_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaPoint(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaPoint, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaPoint)\n"
        "    ([oaPoint])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaPoint_tp_dealloc(PyoaArrayBase_oaPointObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaPoint_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaPoint value;
    int convert_status=PyoaArrayBase_oaPoint_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[41];
    sprintf(buffer,"<oaArrayBase_oaPoint::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaPoint_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaPoint v1;
    PyParamoaArrayBase_oaPoint v2;
    int convert_status1=PyoaArrayBase_oaPoint_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaPoint_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaPoint_Convert(PyObject* ob,PyParamoaArrayBase_oaPoint* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaPoint_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaPointObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaPoint Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaPoint_FromoaArrayBase_oaPoint(oaArrayBase_oaPoint* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaPoint_Type.tp_alloc(&PyoaArrayBase_oaPoint_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaPointObject* self = (PyoaArrayBase_oaPointObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaPoint_index_get_doc[] = 
"Class: oaArrayBase_oaPoint, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaPoint_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaPointObject* self=(PyoaArrayBase_oaPointObject*)ob;
  try {
    PyParamoaArrayBase_oaPoint data;
    int convert_status=PyoaArrayBase_oaPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaPointObject* self=(PyoaArrayBase_oaPointObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaPoint* result=&(data.Data()[index]);
    return PyoaPoint_FromoaPoint(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaPoint_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaPoint data;
    int convert_status=PyoaArrayBase_oaPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaPointObject* self=(PyoaArrayBase_oaPointObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaPoint_index_set_doc[] = 
"Class: oaArrayBase_oaPoint, Function: index_set\n"
;

static int
oaArrayBase_oaPoint_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaPoint data;
    int convert_status=PyoaArrayBase_oaPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaPointObject* self=(PyoaArrayBase_oaPointObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaPoint result;
    if (PyoaPoint_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaPoint_get_doc[] = 
"Class: oaArrayBase_oaPoint, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaPoint& get(oaUInt4 index)\n"
"    Signature: get|ref-oaPoint|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaPoint_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaPoint data;
    int convert_status=PyoaArrayBase_oaPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaPointObject* self=(PyoaArrayBase_oaPointObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaPoint* result=&(data.DataCall()->get(p1.Data()));
        return PyoaPoint_FromoaPoint(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaPoint_getElements_doc[] = 
"Class: oaArrayBase_oaPoint, Function: getElements\n"
"  Paramegers: ()\n"
"    Calls: const oaPoint* getElements() const\n"
"    Signature: getElements|cptr-oaPoint|\n"
"    BrowseData: 1\n"
"    This function returns a const pointer to the elements in this oaArrayBase<T> array. This may be useful to those applications that want to memcpy the data in this array.\n"
;

static PyObject*
oaArrayBase_oaPoint_getElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaPoint data;
    int convert_status=PyoaArrayBase_oaPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaPointObject* self=(PyoaArrayBase_oaPointObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaPoint* result=(oaPoint*)(data.DataCall()->getElements());
        return PyoaPoint_Array_FromoaPoint_Array(result,(data.Data().getNumElements()),ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaPoint_getNumElements_doc[] = 
"Class: oaArrayBase_oaPoint, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaPoint_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaPoint data;
    int convert_status=PyoaArrayBase_oaPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaPointObject* self=(PyoaArrayBase_oaPointObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaPoint_getSize_doc[] = 
"Class: oaArrayBase_oaPoint, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaPoint_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaPoint data;
    int convert_status=PyoaArrayBase_oaPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaPointObject* self=(PyoaArrayBase_oaPointObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaPoint_set_doc[] = 
"Class: oaArrayBase_oaPoint, Function: set\n"
"  Paramegers: ([oaPoint])\n"
"    Calls: void set(const oaPoint* array)\n"
"    Signature: set|void-void|cptr-oaPoint,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaPoint_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaPoint data;
    int convert_status=PyoaArrayBase_oaPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaPointObject* self=(PyoaArrayBase_oaPointObject*)ob;

    PyParamoaPoint_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaPoint_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaPoint_setNumElements_doc[] = 
"Class: oaArrayBase_oaPoint, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaPoint_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaPoint data;
    int convert_status=PyoaArrayBase_oaPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaPointObject* self=(PyoaArrayBase_oaPointObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaPoint_setSize_doc[] = 
"Class: oaArrayBase_oaPoint, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaPoint_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaPoint data;
    int convert_status=PyoaArrayBase_oaPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaPointObject* self=(PyoaArrayBase_oaPointObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaPoint, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaPoint_assign_doc[] = 
"Class: oaArrayBase_oaPoint, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaPoint_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaPoint data;
  int convert_status=PyoaArrayBase_oaPoint_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaPoint p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaPoint_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaPoint_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaPoint_get,METH_VARARGS,oaArrayBase_oaPoint_get_doc},
    {"getElements",(PyCFunction)oaArrayBase_oaPoint_getElements,METH_VARARGS,oaArrayBase_oaPoint_getElements_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaPoint_getNumElements,METH_VARARGS,oaArrayBase_oaPoint_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaPoint_getSize,METH_VARARGS,oaArrayBase_oaPoint_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaPoint_set,METH_VARARGS,oaArrayBase_oaPoint_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaPoint_setNumElements,METH_VARARGS,oaArrayBase_oaPoint_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaPoint_setSize,METH_VARARGS,oaArrayBase_oaPoint_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaPoint_tp_assign,METH_VARARGS,oaArrayBase_oaPoint_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaPoint_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaPoint_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaPoint_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaPoint_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaPoint_doc[] = 
"Class: oaArrayBase_oaPoint\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaPoint()\n"
"    Signature: oaArrayBase_oaPoint||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaPoint(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaPoint||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaPoint)\n"
"    Calls: oaArrayBase_oaPoint(const oaArrayBase_oaPoint& array)\n"
"    Signature: oaArrayBase_oaPoint||cref-oaArrayBase_oaPoint,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaPoint])\n"
"    Calls: oaArrayBase_oaPoint(const oaPoint* array)\n"
"    Signature: oaArrayBase_oaPoint||cptr-oaPoint,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaPoint)\n"
"    Calls: (const oaArrayBase_oaPoint&)\n"
"    Signature: oaArrayBase_oaPoint||cref-oaArrayBase_oaPoint,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaPoint_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaPoint",
    sizeof(PyoaArrayBase_oaPointObject),
    0,
    (destructor)oaArrayBase_oaPoint_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaPoint_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaPoint_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaPoint_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaPoint_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaPoint_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaPoint_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaPoint_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaPoint_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaPoint\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaPoint",
           (PyObject*)(&PyoaArrayBase_oaPoint_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaPoint\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaSiteRef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaSiteRef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaSiteRef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaSiteRefObject* self = (PyoaArrayBase_oaSiteRefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaSiteRef();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaSiteRef(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaSiteRef)
    {
        PyParamoaArrayBase_oaSiteRef p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaSiteRef_Convert,&p1)) {
            self->value =  new oaArrayBase_oaSiteRef(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaSiteRef])
    {
        PyParamoaSiteRef_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSiteRef_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaSiteRef(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaSiteRef, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaSiteRef)\n"
        "    ([oaSiteRef])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaSiteRef_tp_dealloc(PyoaArrayBase_oaSiteRefObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaSiteRef_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaSiteRef value;
    int convert_status=PyoaArrayBase_oaSiteRef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaArrayBase_oaSiteRef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaSiteRef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaSiteRef v1;
    PyParamoaArrayBase_oaSiteRef v2;
    int convert_status1=PyoaArrayBase_oaSiteRef_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaSiteRef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaSiteRef_Convert(PyObject* ob,PyParamoaArrayBase_oaSiteRef* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaSiteRef_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaSiteRefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaSiteRef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaSiteRef_FromoaArrayBase_oaSiteRef(oaArrayBase_oaSiteRef* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaSiteRef_Type.tp_alloc(&PyoaArrayBase_oaSiteRef_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaSiteRefObject* self = (PyoaArrayBase_oaSiteRefObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaSiteRef_index_get_doc[] = 
"Class: oaArrayBase_oaSiteRef, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaSiteRef_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaSiteRefObject* self=(PyoaArrayBase_oaSiteRefObject*)ob;
  try {
    PyParamoaArrayBase_oaSiteRef data;
    int convert_status=PyoaArrayBase_oaSiteRef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaSiteRefObject* self=(PyoaArrayBase_oaSiteRefObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaSiteRef* result=&(data.Data()[index]);
    return PyoaSiteRef_FromoaSiteRef(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaSiteRef_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaSiteRef data;
    int convert_status=PyoaArrayBase_oaSiteRef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaSiteRefObject* self=(PyoaArrayBase_oaSiteRefObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaSiteRef_index_set_doc[] = 
"Class: oaArrayBase_oaSiteRef, Function: index_set\n"
;

static int
oaArrayBase_oaSiteRef_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaSiteRef data;
    int convert_status=PyoaArrayBase_oaSiteRef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaSiteRefObject* self=(PyoaArrayBase_oaSiteRefObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaSiteRef result;
    if (PyoaSiteRef_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaSiteRef_get_doc[] = 
"Class: oaArrayBase_oaSiteRef, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaSiteRef& get(oaUInt4 index)\n"
"    Signature: get|ref-oaSiteRef|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaSiteRef_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaSiteRef data;
    int convert_status=PyoaArrayBase_oaSiteRef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaSiteRefObject* self=(PyoaArrayBase_oaSiteRefObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaSiteRef* result=&(data.DataCall()->get(p1.Data()));
        return PyoaSiteRef_FromoaSiteRef(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaSiteRef_getElements_doc[] = 
"Class: oaArrayBase_oaSiteRef, Function: getElements\n"
"  Paramegers: ()\n"
"    Calls: const oaSiteRef* getElements() const\n"
"    Signature: getElements|cptr-oaSiteRef|\n"
"    BrowseData: 1\n"
"    This function returns a const pointer to the elements in this oaArrayBase<T> array. This may be useful to those applications that want to memcpy the data in this array.\n"
;

static PyObject*
oaArrayBase_oaSiteRef_getElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaSiteRef data;
    int convert_status=PyoaArrayBase_oaSiteRef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaSiteRefObject* self=(PyoaArrayBase_oaSiteRefObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaSiteRef* result=(oaSiteRef*)(data.DataCall()->getElements());
        return PyoaSiteRef_Array_FromoaSiteRef_Array(result,(data.Data().getNumElements()),ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaSiteRef_getNumElements_doc[] = 
"Class: oaArrayBase_oaSiteRef, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaSiteRef_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaSiteRef data;
    int convert_status=PyoaArrayBase_oaSiteRef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaSiteRefObject* self=(PyoaArrayBase_oaSiteRefObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaSiteRef_getSize_doc[] = 
"Class: oaArrayBase_oaSiteRef, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaSiteRef_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaSiteRef data;
    int convert_status=PyoaArrayBase_oaSiteRef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaSiteRefObject* self=(PyoaArrayBase_oaSiteRefObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaSiteRef_set_doc[] = 
"Class: oaArrayBase_oaSiteRef, Function: set\n"
"  Paramegers: ([oaSiteRef])\n"
"    Calls: void set(const oaSiteRef* array)\n"
"    Signature: set|void-void|cptr-oaSiteRef,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaSiteRef_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaSiteRef data;
    int convert_status=PyoaArrayBase_oaSiteRef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaSiteRefObject* self=(PyoaArrayBase_oaSiteRefObject*)ob;

    PyParamoaSiteRef_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaSiteRef_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaSiteRef_setNumElements_doc[] = 
"Class: oaArrayBase_oaSiteRef, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaSiteRef_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaSiteRef data;
    int convert_status=PyoaArrayBase_oaSiteRef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaSiteRefObject* self=(PyoaArrayBase_oaSiteRefObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaSiteRef_setSize_doc[] = 
"Class: oaArrayBase_oaSiteRef, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaSiteRef_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaSiteRef data;
    int convert_status=PyoaArrayBase_oaSiteRef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaSiteRefObject* self=(PyoaArrayBase_oaSiteRefObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaSiteRef, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaSiteRef_assign_doc[] = 
"Class: oaArrayBase_oaSiteRef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaSiteRef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaSiteRef data;
  int convert_status=PyoaArrayBase_oaSiteRef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaSiteRef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaSiteRef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaSiteRef_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaSiteRef_get,METH_VARARGS,oaArrayBase_oaSiteRef_get_doc},
    {"getElements",(PyCFunction)oaArrayBase_oaSiteRef_getElements,METH_VARARGS,oaArrayBase_oaSiteRef_getElements_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaSiteRef_getNumElements,METH_VARARGS,oaArrayBase_oaSiteRef_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaSiteRef_getSize,METH_VARARGS,oaArrayBase_oaSiteRef_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaSiteRef_set,METH_VARARGS,oaArrayBase_oaSiteRef_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaSiteRef_setNumElements,METH_VARARGS,oaArrayBase_oaSiteRef_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaSiteRef_setSize,METH_VARARGS,oaArrayBase_oaSiteRef_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaSiteRef_tp_assign,METH_VARARGS,oaArrayBase_oaSiteRef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaSiteRef_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaSiteRef_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaSiteRef_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaSiteRef_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaSiteRef_doc[] = 
"Class: oaArrayBase_oaSiteRef\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaSiteRef()\n"
"    Signature: oaArrayBase_oaSiteRef||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaSiteRef(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaSiteRef||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaSiteRef)\n"
"    Calls: oaArrayBase_oaSiteRef(const oaArrayBase_oaSiteRef& array)\n"
"    Signature: oaArrayBase_oaSiteRef||cref-oaArrayBase_oaSiteRef,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaSiteRef])\n"
"    Calls: oaArrayBase_oaSiteRef(const oaSiteRef* array)\n"
"    Signature: oaArrayBase_oaSiteRef||cptr-oaSiteRef,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaSiteRef)\n"
"    Calls: (const oaArrayBase_oaSiteRef&)\n"
"    Signature: oaArrayBase_oaSiteRef||cref-oaArrayBase_oaSiteRef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaSiteRef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaSiteRef",
    sizeof(PyoaArrayBase_oaSiteRefObject),
    0,
    (destructor)oaArrayBase_oaSiteRef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaSiteRef_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaSiteRef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaSiteRef_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaSiteRef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaSiteRef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaSiteRef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaSiteRef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaSiteRef_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaSiteRef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaSiteRef",
           (PyObject*)(&PyoaArrayBase_oaSiteRef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaSiteRef\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaString
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaString_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaString_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaStringObject* self = (PyoaArrayBase_oaStringObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaString();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaString(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaString)
    {
        PyParamoaArrayBase_oaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaString_Convert,&p1)) {
            self->value =  new oaArrayBase_oaString(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaString])
    {
        PyParamoaString_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaString(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaString, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaString)\n"
        "    ([oaString])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaString_tp_dealloc(PyoaArrayBase_oaStringObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaString_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaString value;
    int convert_status=PyoaArrayBase_oaString_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaArrayBase_oaString::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaString_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaString v1;
    PyParamoaArrayBase_oaString v2;
    int convert_status1=PyoaArrayBase_oaString_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaString_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaString_Convert(PyObject* ob,PyParamoaArrayBase_oaString* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaString_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaStringObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaString Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaString_FromoaArrayBase_oaString(oaArrayBase_oaString* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaString_Type.tp_alloc(&PyoaArrayBase_oaString_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaStringObject* self = (PyoaArrayBase_oaStringObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaString_index_get_doc[] = 
"Class: oaArrayBase_oaString, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaString_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaStringObject* self=(PyoaArrayBase_oaStringObject*)ob;
  try {
    PyParamoaArrayBase_oaString data;
    int convert_status=PyoaArrayBase_oaString_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaStringObject* self=(PyoaArrayBase_oaStringObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaString* result=&(data.Data()[index]);
    return PyoaString_FromoaString(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaString_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaString data;
    int convert_status=PyoaArrayBase_oaString_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaStringObject* self=(PyoaArrayBase_oaStringObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaString_index_set_doc[] = 
"Class: oaArrayBase_oaString, Function: index_set\n"
;

static int
oaArrayBase_oaString_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaString data;
    int convert_status=PyoaArrayBase_oaString_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaStringObject* self=(PyoaArrayBase_oaStringObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaString result;
    if (PyoaString_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaString_get_doc[] = 
"Class: oaArrayBase_oaString, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaString& get(oaUInt4 index)\n"
"    Signature: get|ref-oaString|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaString_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaString data;
    int convert_status=PyoaArrayBase_oaString_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaStringObject* self=(PyoaArrayBase_oaStringObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaString* result=&(data.DataCall()->get(p1.Data()));
        return PyoaString_FromoaString(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaString_getElements_doc[] = 
"Class: oaArrayBase_oaString, Function: getElements\n"
"  Paramegers: ()\n"
"    Calls: const oaString* getElements() const\n"
"    Signature: getElements|cptr-oaString|\n"
"    BrowseData: 1\n"
"    This function returns a const pointer to the elements in this oaArrayBase<T> array. This may be useful to those applications that want to memcpy the data in this array.\n"
;

static PyObject*
oaArrayBase_oaString_getElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaString data;
    int convert_status=PyoaArrayBase_oaString_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaStringObject* self=(PyoaArrayBase_oaStringObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaString* result=(oaString*)(data.DataCall()->getElements());
        return PyoaString_Array_FromoaString_Array(result,(data.Data().getNumElements()),ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaString_getNumElements_doc[] = 
"Class: oaArrayBase_oaString, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaString_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaString data;
    int convert_status=PyoaArrayBase_oaString_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaStringObject* self=(PyoaArrayBase_oaStringObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaString_getSize_doc[] = 
"Class: oaArrayBase_oaString, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaString_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaString data;
    int convert_status=PyoaArrayBase_oaString_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaStringObject* self=(PyoaArrayBase_oaStringObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaString_set_doc[] = 
"Class: oaArrayBase_oaString, Function: set\n"
"  Paramegers: ([oaString])\n"
"    Calls: void set(const oaString* array)\n"
"    Signature: set|void-void|cptr-oaString,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaString_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaString data;
    int convert_status=PyoaArrayBase_oaString_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaStringObject* self=(PyoaArrayBase_oaStringObject*)ob;

    PyParamoaString_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaString_setNumElements_doc[] = 
"Class: oaArrayBase_oaString, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaString_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaString data;
    int convert_status=PyoaArrayBase_oaString_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaStringObject* self=(PyoaArrayBase_oaStringObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaString_setSize_doc[] = 
"Class: oaArrayBase_oaString, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaString_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaString data;
    int convert_status=PyoaArrayBase_oaString_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaStringObject* self=(PyoaArrayBase_oaStringObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaString, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaString_assign_doc[] = 
"Class: oaArrayBase_oaString, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaString_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaString data;
  int convert_status=PyoaArrayBase_oaString_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaString p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaString_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaString_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaString_get,METH_VARARGS,oaArrayBase_oaString_get_doc},
    {"getElements",(PyCFunction)oaArrayBase_oaString_getElements,METH_VARARGS,oaArrayBase_oaString_getElements_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaString_getNumElements,METH_VARARGS,oaArrayBase_oaString_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaString_getSize,METH_VARARGS,oaArrayBase_oaString_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaString_set,METH_VARARGS,oaArrayBase_oaString_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaString_setNumElements,METH_VARARGS,oaArrayBase_oaString_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaString_setSize,METH_VARARGS,oaArrayBase_oaString_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaString_tp_assign,METH_VARARGS,oaArrayBase_oaString_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaString_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaString_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaString_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaString_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaString_doc[] = 
"Class: oaArrayBase_oaString\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaString()\n"
"    Signature: oaArrayBase_oaString||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaString(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaString||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaString)\n"
"    Calls: oaArrayBase_oaString(const oaArrayBase_oaString& array)\n"
"    Signature: oaArrayBase_oaString||cref-oaArrayBase_oaString,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaString])\n"
"    Calls: oaArrayBase_oaString(const oaString* array)\n"
"    Signature: oaArrayBase_oaString||cptr-oaString,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaString)\n"
"    Calls: (const oaArrayBase_oaString&)\n"
"    Signature: oaArrayBase_oaString||cref-oaArrayBase_oaString,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaString_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaString",
    sizeof(PyoaArrayBase_oaStringObject),
    0,
    (destructor)oaArrayBase_oaString_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaString_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaString_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaString_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaString_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaString_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaString_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaString_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaString_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaString\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaString",
           (PyObject*)(&PyoaArrayBase_oaString_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaString\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaTech
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaTech_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaTech_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaTechObject* self = (PyoaArrayBase_oaTechObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaTech();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaTech(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaTech)
    {
        PyParamoaArrayBase_oaTech p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaTech_Convert,&p1)) {
            self->value =  new oaArrayBase_oaTech(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaTech])
    {
        PyParamoaTech_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaTech_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaTech(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaTech, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaTech)\n"
        "    ([oaTech])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaTech_tp_dealloc(PyoaArrayBase_oaTechObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaTech_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaTech value;
    int convert_status=PyoaArrayBase_oaTech_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[40];
    sprintf(buffer,"<oaArrayBase_oaTech::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaTech_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaTech v1;
    PyParamoaArrayBase_oaTech v2;
    int convert_status1=PyoaArrayBase_oaTech_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaTech_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaTech_Convert(PyObject* ob,PyParamoaArrayBase_oaTech* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaTech_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaTechObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaTech Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaTech_FromoaArrayBase_oaTech(oaArrayBase_oaTech* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaTech_Type.tp_alloc(&PyoaArrayBase_oaTech_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaTechObject* self = (PyoaArrayBase_oaTechObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaTech_index_get_doc[] = 
"Class: oaArrayBase_oaTech, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaTech_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaTechObject* self=(PyoaArrayBase_oaTechObject*)ob;
  try {
    PyParamoaArrayBase_oaTech data;
    int convert_status=PyoaArrayBase_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTechObject* self=(PyoaArrayBase_oaTechObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaTechp* result=&(data.Data()[index]);
    return PyoaTech_FromoaTech(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaTech_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaTech data;
    int convert_status=PyoaArrayBase_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTechObject* self=(PyoaArrayBase_oaTechObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaTech_index_set_doc[] = 
"Class: oaArrayBase_oaTech, Function: index_set\n"
;

static int
oaArrayBase_oaTech_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaTech data;
    int convert_status=PyoaArrayBase_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTechObject* self=(PyoaArrayBase_oaTechObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaTech result;
    if (PyoaTech_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaTech_get_doc[] = 
"Class: oaArrayBase_oaTech, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaTech*& get(oaUInt4 index)\n"
"    Signature: get|ptrref-oaTech|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaTech_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaTech data;
    int convert_status=PyoaArrayBase_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTechObject* self=(PyoaArrayBase_oaTechObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaTechp* result=&(data.DataCall()->get(p1.Data()));
        return PyoaTech_FromoaTech(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaTech_getNumElements_doc[] = 
"Class: oaArrayBase_oaTech, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaTech_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaTech data;
    int convert_status=PyoaArrayBase_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTechObject* self=(PyoaArrayBase_oaTechObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaTech_getSize_doc[] = 
"Class: oaArrayBase_oaTech, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaTech_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaTech data;
    int convert_status=PyoaArrayBase_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTechObject* self=(PyoaArrayBase_oaTechObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaTech_set_doc[] = 
"Class: oaArrayBase_oaTech, Function: set\n"
"  Paramegers: ([oaTech])\n"
"    Calls: void set( array)\n"
"    Signature: set|void-void|cpptr-oaTech,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaTech_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaTech data;
    int convert_status=PyoaArrayBase_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTechObject* self=(PyoaArrayBase_oaTechObject*)ob;

    PyParamoaTech_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTech_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaTech_setNumElements_doc[] = 
"Class: oaArrayBase_oaTech, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaTech_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaTech data;
    int convert_status=PyoaArrayBase_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTechObject* self=(PyoaArrayBase_oaTechObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaTech_setSize_doc[] = 
"Class: oaArrayBase_oaTech, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaTech_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaTech data;
    int convert_status=PyoaArrayBase_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTechObject* self=(PyoaArrayBase_oaTechObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaTech, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaTech_assign_doc[] = 
"Class: oaArrayBase_oaTech, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaTech_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaTech data;
  int convert_status=PyoaArrayBase_oaTech_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaTech p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaTech_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaTech_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaTech_get,METH_VARARGS,oaArrayBase_oaTech_get_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaTech_getNumElements,METH_VARARGS,oaArrayBase_oaTech_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaTech_getSize,METH_VARARGS,oaArrayBase_oaTech_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaTech_set,METH_VARARGS,oaArrayBase_oaTech_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaTech_setNumElements,METH_VARARGS,oaArrayBase_oaTech_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaTech_setSize,METH_VARARGS,oaArrayBase_oaTech_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaTech_tp_assign,METH_VARARGS,oaArrayBase_oaTech_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaTech_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaTech_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaTech_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaTech_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaTech_doc[] = 
"Class: oaArrayBase_oaTech\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaTech()\n"
"    Signature: oaArrayBase_oaTech||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaTech(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaTech||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaTech)\n"
"    Calls: oaArrayBase_oaTech(const oaArrayBase_oaTech& array)\n"
"    Signature: oaArrayBase_oaTech||cref-oaArrayBase_oaTech,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaTech])\n"
"    Calls: oaArrayBase_oaTech( array)\n"
"    Signature: oaArrayBase_oaTech||cpptr-oaTech,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaTech)\n"
"    Calls: (const oaArrayBase_oaTech&)\n"
"    Signature: oaArrayBase_oaTech||cref-oaArrayBase_oaTech,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaTech_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaTech",
    sizeof(PyoaArrayBase_oaTechObject),
    0,
    (destructor)oaArrayBase_oaTech_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaTech_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaTech_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaTech_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaTech_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaTech_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaTech_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaTech_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaTech_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaTech\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaTech",
           (PyObject*)(&PyoaArrayBase_oaTech_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaTech\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaTechHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaTechHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaTechHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaTechHeaderObject* self = (PyoaArrayBase_oaTechHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaTechHeader();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaTechHeader(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaTechHeader)
    {
        PyParamoaArrayBase_oaTechHeader p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaTechHeader_Convert,&p1)) {
            self->value =  new oaArrayBase_oaTechHeader(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaTechHeader])
    {
        PyParamoaTechHeader_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaTechHeader_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaTechHeader(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaTechHeader, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaTechHeader)\n"
        "    ([oaTechHeader])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaTechHeader_tp_dealloc(PyoaArrayBase_oaTechHeaderObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaTechHeader_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaTechHeader value;
    int convert_status=PyoaArrayBase_oaTechHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[46];
    sprintf(buffer,"<oaArrayBase_oaTechHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaTechHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaTechHeader v1;
    PyParamoaArrayBase_oaTechHeader v2;
    int convert_status1=PyoaArrayBase_oaTechHeader_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaTechHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaTechHeader_Convert(PyObject* ob,PyParamoaArrayBase_oaTechHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaTechHeader_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaTechHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaTechHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaTechHeader_FromoaArrayBase_oaTechHeader(oaArrayBase_oaTechHeader* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaTechHeader_Type.tp_alloc(&PyoaArrayBase_oaTechHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaTechHeaderObject* self = (PyoaArrayBase_oaTechHeaderObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaTechHeader_index_get_doc[] = 
"Class: oaArrayBase_oaTechHeader, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaTechHeader_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaTechHeaderObject* self=(PyoaArrayBase_oaTechHeaderObject*)ob;
  try {
    PyParamoaArrayBase_oaTechHeader data;
    int convert_status=PyoaArrayBase_oaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTechHeaderObject* self=(PyoaArrayBase_oaTechHeaderObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaTechHeaderp* result=&(data.Data()[index]);
    return PyoaTechHeader_FromoaTechHeader(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaTechHeader_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaTechHeader data;
    int convert_status=PyoaArrayBase_oaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTechHeaderObject* self=(PyoaArrayBase_oaTechHeaderObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaTechHeader_index_set_doc[] = 
"Class: oaArrayBase_oaTechHeader, Function: index_set\n"
;

static int
oaArrayBase_oaTechHeader_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaTechHeader data;
    int convert_status=PyoaArrayBase_oaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTechHeaderObject* self=(PyoaArrayBase_oaTechHeaderObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaTechHeader result;
    if (PyoaTechHeader_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaTechHeader_get_doc[] = 
"Class: oaArrayBase_oaTechHeader, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaTechHeader*& get(oaUInt4 index)\n"
"    Signature: get|ptrref-oaTechHeader|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaTechHeader_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaTechHeader data;
    int convert_status=PyoaArrayBase_oaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTechHeaderObject* self=(PyoaArrayBase_oaTechHeaderObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaTechHeaderp* result=&(data.DataCall()->get(p1.Data()));
        return PyoaTechHeader_FromoaTechHeader(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaTechHeader_getNumElements_doc[] = 
"Class: oaArrayBase_oaTechHeader, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaTechHeader_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaTechHeader data;
    int convert_status=PyoaArrayBase_oaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTechHeaderObject* self=(PyoaArrayBase_oaTechHeaderObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaTechHeader_getSize_doc[] = 
"Class: oaArrayBase_oaTechHeader, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaTechHeader_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaTechHeader data;
    int convert_status=PyoaArrayBase_oaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTechHeaderObject* self=(PyoaArrayBase_oaTechHeaderObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaTechHeader_set_doc[] = 
"Class: oaArrayBase_oaTechHeader, Function: set\n"
"  Paramegers: ([oaTechHeader])\n"
"    Calls: void set( array)\n"
"    Signature: set|void-void|cpptr-oaTechHeader,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaTechHeader_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaTechHeader data;
    int convert_status=PyoaArrayBase_oaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTechHeaderObject* self=(PyoaArrayBase_oaTechHeaderObject*)ob;

    PyParamoaTechHeader_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTechHeader_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaTechHeader_setNumElements_doc[] = 
"Class: oaArrayBase_oaTechHeader, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaTechHeader_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaTechHeader data;
    int convert_status=PyoaArrayBase_oaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTechHeaderObject* self=(PyoaArrayBase_oaTechHeaderObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaTechHeader_setSize_doc[] = 
"Class: oaArrayBase_oaTechHeader, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaTechHeader_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaTechHeader data;
    int convert_status=PyoaArrayBase_oaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTechHeaderObject* self=(PyoaArrayBase_oaTechHeaderObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaTechHeader, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaTechHeader_assign_doc[] = 
"Class: oaArrayBase_oaTechHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaTechHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaTechHeader data;
  int convert_status=PyoaArrayBase_oaTechHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaTechHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaTechHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaTechHeader_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaTechHeader_get,METH_VARARGS,oaArrayBase_oaTechHeader_get_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaTechHeader_getNumElements,METH_VARARGS,oaArrayBase_oaTechHeader_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaTechHeader_getSize,METH_VARARGS,oaArrayBase_oaTechHeader_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaTechHeader_set,METH_VARARGS,oaArrayBase_oaTechHeader_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaTechHeader_setNumElements,METH_VARARGS,oaArrayBase_oaTechHeader_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaTechHeader_setSize,METH_VARARGS,oaArrayBase_oaTechHeader_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaTechHeader_tp_assign,METH_VARARGS,oaArrayBase_oaTechHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaTechHeader_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaTechHeader_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaTechHeader_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaTechHeader_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaTechHeader_doc[] = 
"Class: oaArrayBase_oaTechHeader\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaTechHeader()\n"
"    Signature: oaArrayBase_oaTechHeader||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaTechHeader(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaTechHeader||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaTechHeader)\n"
"    Calls: oaArrayBase_oaTechHeader(const oaArrayBase_oaTechHeader& array)\n"
"    Signature: oaArrayBase_oaTechHeader||cref-oaArrayBase_oaTechHeader,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaTechHeader])\n"
"    Calls: oaArrayBase_oaTechHeader( array)\n"
"    Signature: oaArrayBase_oaTechHeader||cpptr-oaTechHeader,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaTechHeader)\n"
"    Calls: (const oaArrayBase_oaTechHeader&)\n"
"    Signature: oaArrayBase_oaTechHeader||cref-oaArrayBase_oaTechHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaTechHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaTechHeader",
    sizeof(PyoaArrayBase_oaTechHeaderObject),
    0,
    (destructor)oaArrayBase_oaTechHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaTechHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaTechHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaTechHeader_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaTechHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaTechHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaTechHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaTechHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaTechHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaTechHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaTechHeader",
           (PyObject*)(&PyoaArrayBase_oaTechHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaTechHeader\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaTerm
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaTerm_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaTerm_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaTermObject* self = (PyoaArrayBase_oaTermObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaTerm();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaTerm(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaTerm)
    {
        PyParamoaArrayBase_oaTerm p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaTerm_Convert,&p1)) {
            self->value =  new oaArrayBase_oaTerm(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaTerm])
    {
        PyParamoaTerm_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaTerm_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaTerm(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaTerm, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaTerm)\n"
        "    ([oaTerm])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaTerm_tp_dealloc(PyoaArrayBase_oaTermObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaTerm_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaTerm value;
    int convert_status=PyoaArrayBase_oaTerm_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[40];
    sprintf(buffer,"<oaArrayBase_oaTerm::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaTerm_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaTerm v1;
    PyParamoaArrayBase_oaTerm v2;
    int convert_status1=PyoaArrayBase_oaTerm_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaTerm_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaTerm_Convert(PyObject* ob,PyParamoaArrayBase_oaTerm* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaTerm_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaTermObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaTerm Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaTerm_FromoaArrayBase_oaTerm(oaArrayBase_oaTerm* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaTerm_Type.tp_alloc(&PyoaArrayBase_oaTerm_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaTermObject* self = (PyoaArrayBase_oaTermObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaTerm_index_get_doc[] = 
"Class: oaArrayBase_oaTerm, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaTerm_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaTermObject* self=(PyoaArrayBase_oaTermObject*)ob;
  try {
    PyParamoaArrayBase_oaTerm data;
    int convert_status=PyoaArrayBase_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTermObject* self=(PyoaArrayBase_oaTermObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaTermp* result=&(data.Data()[index]);
    return PyoaTerm_FromoaTerm(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaTerm_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaTerm data;
    int convert_status=PyoaArrayBase_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTermObject* self=(PyoaArrayBase_oaTermObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaTerm_index_set_doc[] = 
"Class: oaArrayBase_oaTerm, Function: index_set\n"
;

static int
oaArrayBase_oaTerm_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaTerm data;
    int convert_status=PyoaArrayBase_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTermObject* self=(PyoaArrayBase_oaTermObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaTerm result;
    if (PyoaTerm_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaTerm_get_doc[] = 
"Class: oaArrayBase_oaTerm, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaTerm*& get(oaUInt4 index)\n"
"    Signature: get|ptrref-oaTerm|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaTerm_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaTerm data;
    int convert_status=PyoaArrayBase_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTermObject* self=(PyoaArrayBase_oaTermObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaTermp* result=&(data.DataCall()->get(p1.Data()));
        return PyoaTerm_FromoaTerm(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaTerm_getNumElements_doc[] = 
"Class: oaArrayBase_oaTerm, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaTerm_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaTerm data;
    int convert_status=PyoaArrayBase_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTermObject* self=(PyoaArrayBase_oaTermObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaTerm_getSize_doc[] = 
"Class: oaArrayBase_oaTerm, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaTerm_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaTerm data;
    int convert_status=PyoaArrayBase_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTermObject* self=(PyoaArrayBase_oaTermObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaTerm_set_doc[] = 
"Class: oaArrayBase_oaTerm, Function: set\n"
"  Paramegers: ([oaTerm])\n"
"    Calls: void set( array)\n"
"    Signature: set|void-void|cpptr-oaTerm,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaTerm_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaTerm data;
    int convert_status=PyoaArrayBase_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTermObject* self=(PyoaArrayBase_oaTermObject*)ob;

    PyParamoaTerm_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTerm_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaTerm_setNumElements_doc[] = 
"Class: oaArrayBase_oaTerm, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaTerm_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaTerm data;
    int convert_status=PyoaArrayBase_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTermObject* self=(PyoaArrayBase_oaTermObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaTerm_setSize_doc[] = 
"Class: oaArrayBase_oaTerm, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaTerm_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaTerm data;
    int convert_status=PyoaArrayBase_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTermObject* self=(PyoaArrayBase_oaTermObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaTerm, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaTerm_assign_doc[] = 
"Class: oaArrayBase_oaTerm, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaTerm_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaTerm data;
  int convert_status=PyoaArrayBase_oaTerm_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaTerm p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaTerm_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaTerm_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaTerm_get,METH_VARARGS,oaArrayBase_oaTerm_get_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaTerm_getNumElements,METH_VARARGS,oaArrayBase_oaTerm_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaTerm_getSize,METH_VARARGS,oaArrayBase_oaTerm_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaTerm_set,METH_VARARGS,oaArrayBase_oaTerm_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaTerm_setNumElements,METH_VARARGS,oaArrayBase_oaTerm_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaTerm_setSize,METH_VARARGS,oaArrayBase_oaTerm_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaTerm_tp_assign,METH_VARARGS,oaArrayBase_oaTerm_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaTerm_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaTerm_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaTerm_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaTerm_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaTerm_doc[] = 
"Class: oaArrayBase_oaTerm\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaTerm()\n"
"    Signature: oaArrayBase_oaTerm||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaTerm(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaTerm||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaTerm)\n"
"    Calls: oaArrayBase_oaTerm(const oaArrayBase_oaTerm& array)\n"
"    Signature: oaArrayBase_oaTerm||cref-oaArrayBase_oaTerm,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaTerm])\n"
"    Calls: oaArrayBase_oaTerm( array)\n"
"    Signature: oaArrayBase_oaTerm||cpptr-oaTerm,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaTerm)\n"
"    Calls: (const oaArrayBase_oaTerm&)\n"
"    Signature: oaArrayBase_oaTerm||cref-oaArrayBase_oaTerm,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaTerm_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaTerm",
    sizeof(PyoaArrayBase_oaTermObject),
    0,
    (destructor)oaArrayBase_oaTerm_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaTerm_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaTerm_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaTerm_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaTerm_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaTerm_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaTerm_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaTerm_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaTerm_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaTerm\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaTerm",
           (PyObject*)(&PyoaArrayBase_oaTerm_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaTerm\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaType
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaType_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaTypeObject* self = (PyoaArrayBase_oaTypeObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaType();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaType)
    {
        PyParamoaArrayBase_oaType p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaType_Convert,&p1)) {
            self->value =  new oaArrayBase_oaType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaType])
    {
        PyParamoaType_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaType_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaType(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaType, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaType)\n"
        "    ([oaType])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaType_tp_dealloc(PyoaArrayBase_oaTypeObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaType_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaType value;
    int convert_status=PyoaArrayBase_oaType_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[40];
    sprintf(buffer,"<oaArrayBase_oaType::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaType_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaType v1;
    PyParamoaArrayBase_oaType v2;
    int convert_status1=PyoaArrayBase_oaType_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaType_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaType_Convert(PyObject* ob,PyParamoaArrayBase_oaType* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaType_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaTypeObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaType Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaType_FromoaArrayBase_oaType(oaArrayBase_oaType* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaType_Type.tp_alloc(&PyoaArrayBase_oaType_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaTypeObject* self = (PyoaArrayBase_oaTypeObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaType_index_get_doc[] = 
"Class: oaArrayBase_oaType, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaType_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaTypeObject* self=(PyoaArrayBase_oaTypeObject*)ob;
  try {
    PyParamoaArrayBase_oaType data;
    int convert_status=PyoaArrayBase_oaType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTypeObject* self=(PyoaArrayBase_oaTypeObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaType* result=&(data.Data()[index]);
    return PyoaType_FromoaType(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaType_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaType data;
    int convert_status=PyoaArrayBase_oaType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTypeObject* self=(PyoaArrayBase_oaTypeObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaType_index_set_doc[] = 
"Class: oaArrayBase_oaType, Function: index_set\n"
;

static int
oaArrayBase_oaType_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaType data;
    int convert_status=PyoaArrayBase_oaType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTypeObject* self=(PyoaArrayBase_oaTypeObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaType result;
    if (PyoaType_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaType_get_doc[] = 
"Class: oaArrayBase_oaType, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaType& get(oaUInt4 index)\n"
"    Signature: get|ref-oaType|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaType_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaType data;
    int convert_status=PyoaArrayBase_oaType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTypeObject* self=(PyoaArrayBase_oaTypeObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaType* result=&(data.DataCall()->get(p1.Data()));
        return PyoaType_FromoaType(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaType_getElements_doc[] = 
"Class: oaArrayBase_oaType, Function: getElements\n"
"  Paramegers: ()\n"
"    Calls: const oaType* getElements() const\n"
"    Signature: getElements|cptr-oaType|\n"
"    BrowseData: 1\n"
"    This function returns a const pointer to the elements in this oaArrayBase<T> array. This may be useful to those applications that want to memcpy the data in this array.\n"
;

static PyObject*
oaArrayBase_oaType_getElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaType data;
    int convert_status=PyoaArrayBase_oaType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTypeObject* self=(PyoaArrayBase_oaTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaType* result=(oaType*)(data.DataCall()->getElements());
        return PyoaType_Array_FromoaType_Array(result,(data.Data().getNumElements()),ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaType_getNumElements_doc[] = 
"Class: oaArrayBase_oaType, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaType_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaType data;
    int convert_status=PyoaArrayBase_oaType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTypeObject* self=(PyoaArrayBase_oaTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaType_getSize_doc[] = 
"Class: oaArrayBase_oaType, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaType_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaType data;
    int convert_status=PyoaArrayBase_oaType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTypeObject* self=(PyoaArrayBase_oaTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaType_set_doc[] = 
"Class: oaArrayBase_oaType, Function: set\n"
"  Paramegers: ([oaType])\n"
"    Calls: void set(const oaType* array)\n"
"    Signature: set|void-void|cptr-oaType,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaType_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaType data;
    int convert_status=PyoaArrayBase_oaType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTypeObject* self=(PyoaArrayBase_oaTypeObject*)ob;

    PyParamoaType_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaType_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaType_setNumElements_doc[] = 
"Class: oaArrayBase_oaType, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaType_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaType data;
    int convert_status=PyoaArrayBase_oaType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTypeObject* self=(PyoaArrayBase_oaTypeObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaType_setSize_doc[] = 
"Class: oaArrayBase_oaType, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaType_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaType data;
    int convert_status=PyoaArrayBase_oaType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaTypeObject* self=(PyoaArrayBase_oaTypeObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaType, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaType_assign_doc[] = 
"Class: oaArrayBase_oaType, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaType_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaType data;
  int convert_status=PyoaArrayBase_oaType_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaType p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaType_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaType_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaType_get,METH_VARARGS,oaArrayBase_oaType_get_doc},
    {"getElements",(PyCFunction)oaArrayBase_oaType_getElements,METH_VARARGS,oaArrayBase_oaType_getElements_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaType_getNumElements,METH_VARARGS,oaArrayBase_oaType_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaType_getSize,METH_VARARGS,oaArrayBase_oaType_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaType_set,METH_VARARGS,oaArrayBase_oaType_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaType_setNumElements,METH_VARARGS,oaArrayBase_oaType_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaType_setSize,METH_VARARGS,oaArrayBase_oaType_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaType_tp_assign,METH_VARARGS,oaArrayBase_oaType_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaType_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaType_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaType_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaType_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaType_doc[] = 
"Class: oaArrayBase_oaType\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaType()\n"
"    Signature: oaArrayBase_oaType||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaType(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaType||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaType)\n"
"    Calls: oaArrayBase_oaType(const oaArrayBase_oaType& array)\n"
"    Signature: oaArrayBase_oaType||cref-oaArrayBase_oaType,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaType])\n"
"    Calls: oaArrayBase_oaType(const oaType* array)\n"
"    Signature: oaArrayBase_oaType||cptr-oaType,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaType)\n"
"    Calls: (const oaArrayBase_oaType&)\n"
"    Signature: oaArrayBase_oaType||cref-oaArrayBase_oaType,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaType_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaType",
    sizeof(PyoaArrayBase_oaTypeObject),
    0,
    (destructor)oaArrayBase_oaType_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaType_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaType_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaType_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaType_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaType_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaType_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaType_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaType_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaType\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaType",
           (PyObject*)(&PyoaArrayBase_oaType_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaType\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaValue
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaValue_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaValue_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaValueObject* self = (PyoaArrayBase_oaValueObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaValue();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaValue(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaValue)
    {
        PyParamoaArrayBase_oaValue p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaValue_Convert,&p1)) {
            self->value =  new oaArrayBase_oaValue(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaValue])
    {
        PyParamoaValue_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaValue_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaValue(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaValue, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaValue)\n"
        "    ([oaValue])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaValue_tp_dealloc(PyoaArrayBase_oaValueObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaValue_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaValue value;
    int convert_status=PyoaArrayBase_oaValue_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[41];
    sprintf(buffer,"<oaArrayBase_oaValue::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaValue_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaValue v1;
    PyParamoaArrayBase_oaValue v2;
    int convert_status1=PyoaArrayBase_oaValue_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaValue_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaValue_Convert(PyObject* ob,PyParamoaArrayBase_oaValue* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaValue_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaValueObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaValue Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaValue_FromoaArrayBase_oaValue(oaArrayBase_oaValue* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaValue_Type.tp_alloc(&PyoaArrayBase_oaValue_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaValueObject* self = (PyoaArrayBase_oaValueObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaValue_index_get_doc[] = 
"Class: oaArrayBase_oaValue, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaValue_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaValueObject* self=(PyoaArrayBase_oaValueObject*)ob;
  try {
    PyParamoaArrayBase_oaValue data;
    int convert_status=PyoaArrayBase_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaValueObject* self=(PyoaArrayBase_oaValueObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaValuep* result=&(data.Data()[index]);
    return PyoaValue_FromoaValue(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaValue_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaValue data;
    int convert_status=PyoaArrayBase_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaValueObject* self=(PyoaArrayBase_oaValueObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaValue_index_set_doc[] = 
"Class: oaArrayBase_oaValue, Function: index_set\n"
;

static int
oaArrayBase_oaValue_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaValue data;
    int convert_status=PyoaArrayBase_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaValueObject* self=(PyoaArrayBase_oaValueObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaValue result;
    if (PyoaValue_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaValue_get_doc[] = 
"Class: oaArrayBase_oaValue, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaValue*& get(oaUInt4 index)\n"
"    Signature: get|ptrref-oaValue|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaValue_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaValue data;
    int convert_status=PyoaArrayBase_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaValueObject* self=(PyoaArrayBase_oaValueObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaValuep* result=&(data.DataCall()->get(p1.Data()));
        return PyoaValue_FromoaValue(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaValue_getNumElements_doc[] = 
"Class: oaArrayBase_oaValue, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaValue_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaValue data;
    int convert_status=PyoaArrayBase_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaValueObject* self=(PyoaArrayBase_oaValueObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaValue_getSize_doc[] = 
"Class: oaArrayBase_oaValue, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaValue_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaValue data;
    int convert_status=PyoaArrayBase_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaValueObject* self=(PyoaArrayBase_oaValueObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaValue_set_doc[] = 
"Class: oaArrayBase_oaValue, Function: set\n"
"  Paramegers: ([oaValue])\n"
"    Calls: void set( array)\n"
"    Signature: set|void-void|cpptr-oaValue,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaValue_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaValue data;
    int convert_status=PyoaArrayBase_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaValueObject* self=(PyoaArrayBase_oaValueObject*)ob;

    PyParamoaValue_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaValue_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaValue_setNumElements_doc[] = 
"Class: oaArrayBase_oaValue, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaValue_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaValue data;
    int convert_status=PyoaArrayBase_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaValueObject* self=(PyoaArrayBase_oaValueObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaValue_setSize_doc[] = 
"Class: oaArrayBase_oaValue, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaValue_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaValue data;
    int convert_status=PyoaArrayBase_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaValueObject* self=(PyoaArrayBase_oaValueObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaValue, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaValue_assign_doc[] = 
"Class: oaArrayBase_oaValue, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaValue_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaValue data;
  int convert_status=PyoaArrayBase_oaValue_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaValue p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaValue_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaValue_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaValue_get,METH_VARARGS,oaArrayBase_oaValue_get_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaValue_getNumElements,METH_VARARGS,oaArrayBase_oaValue_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaValue_getSize,METH_VARARGS,oaArrayBase_oaValue_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaValue_set,METH_VARARGS,oaArrayBase_oaValue_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaValue_setNumElements,METH_VARARGS,oaArrayBase_oaValue_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaValue_setSize,METH_VARARGS,oaArrayBase_oaValue_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaValue_tp_assign,METH_VARARGS,oaArrayBase_oaValue_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaValue_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaValue_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaValue_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaValue_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaValue_doc[] = 
"Class: oaArrayBase_oaValue\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaValue()\n"
"    Signature: oaArrayBase_oaValue||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaValue(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaValue||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaValue)\n"
"    Calls: oaArrayBase_oaValue(const oaArrayBase_oaValue& array)\n"
"    Signature: oaArrayBase_oaValue||cref-oaArrayBase_oaValue,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaValue])\n"
"    Calls: oaArrayBase_oaValue( array)\n"
"    Signature: oaArrayBase_oaValue||cpptr-oaValue,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaValue)\n"
"    Calls: (const oaArrayBase_oaValue&)\n"
"    Signature: oaArrayBase_oaValue||cref-oaArrayBase_oaValue,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaValue_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaValue",
    sizeof(PyoaArrayBase_oaValueObject),
    0,
    (destructor)oaArrayBase_oaValue_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaValue_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaValue_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaValue_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaValue_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaValue_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaValue_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaValue_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaValue_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaValue\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaValue",
           (PyObject*)(&PyoaArrayBase_oaValue_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaValue\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayBase_oaViaDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaViaDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayBase_oaViaDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayBase_oaViaDefObject* self = (PyoaArrayBase_oaViaDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaArrayBase_oaViaDef();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaArrayBase_oaViaDef(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArrayBase_oaViaDef)
    {
        PyParamoaArrayBase_oaViaDef p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArrayBase_oaViaDef_Convert,&p1)) {
            self->value =  new oaArrayBase_oaViaDef(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaViaDef])
    {
        PyParamoaViaDef_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaViaDef_Array_Convert,&p1)) {
            self->value =  new oaArrayBase_oaViaDef(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayBase_oaViaDef, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArrayBase_oaViaDef)\n"
        "    ([oaViaDef])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayBase_oaViaDef_tp_dealloc(PyoaArrayBase_oaViaDefObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayBase_oaViaDef_tp_repr(PyObject *ob)
{
    PyParamoaArrayBase_oaViaDef value;
    int convert_status=PyoaArrayBase_oaViaDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaArrayBase_oaViaDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayBase_oaViaDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayBase_oaViaDef v1;
    PyParamoaArrayBase_oaViaDef v2;
    int convert_status1=PyoaArrayBase_oaViaDef_Convert(ob1,&v1);
    int convert_status2=PyoaArrayBase_oaViaDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayBase_oaViaDef_Convert(PyObject* ob,PyParamoaArrayBase_oaViaDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayBase_oaViaDef_Check(ob)) {
        result->SetData(  ((PyoaArrayBase_oaViaDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayBase_oaViaDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayBase_oaViaDef_FromoaArrayBase_oaViaDef(oaArrayBase_oaViaDef* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArrayBase_oaViaDef_Type.tp_alloc(&PyoaArrayBase_oaViaDef_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayBase_oaViaDefObject* self = (PyoaArrayBase_oaViaDefObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaViaDef_index_get_doc[] = 
"Class: oaArrayBase_oaViaDef, Function: index_get\n"
;

static PyObject*
oaArrayBase_oaViaDef_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaArrayBase_oaViaDefObject* self=(PyoaArrayBase_oaViaDefObject*)ob;
  try {
    PyParamoaArrayBase_oaViaDef data;
    int convert_status=PyoaArrayBase_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaViaDefObject* self=(PyoaArrayBase_oaViaDefObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaViaDefp* result=&(data.Data()[index]);
    return PyoaViaDef_FromoaViaDef(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaArrayBase_oaViaDef_index_get_length(PyObject* ob)
{
    PyParamoaArrayBase_oaViaDef data;
    int convert_status=PyoaArrayBase_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaViaDefObject* self=(PyoaArrayBase_oaViaDefObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaViaDef_index_set_doc[] = 
"Class: oaArrayBase_oaViaDef, Function: index_set\n"
;

static int
oaArrayBase_oaViaDef_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaArrayBase_oaViaDef data;
    int convert_status=PyoaArrayBase_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaViaDefObject* self=(PyoaArrayBase_oaViaDefObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaViaDef result;
    if (PyoaViaDef_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayBase_oaViaDef_get_doc[] = 
"Class: oaArrayBase_oaViaDef, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaViaDef*& get(oaUInt4 index)\n"
"    Signature: get|ptrref-oaViaDef|simple-oaUInt4,\n"
"    This function returns a reference to the element in this array at the specified index . Note that this function does not check whether the index is valid.\n"
"    index\n"
"    Specifies the index element in the array to access\n"
;

static PyObject*
oaArrayBase_oaViaDef_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaViaDef data;
    int convert_status=PyoaArrayBase_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaViaDefObject* self=(PyoaArrayBase_oaViaDefObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaViaDefp* result=&(data.DataCall()->get(p1.Data()));
        return PyoaViaDef_FromoaViaDef(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaViaDef_getNumElements_doc[] = 
"Class: oaArrayBase_oaViaDef, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements this oaArrayBase<T> array contains.\n"
;

static PyObject*
oaArrayBase_oaViaDef_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaViaDef data;
    int convert_status=PyoaArrayBase_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaViaDefObject* self=(PyoaArrayBase_oaViaDefObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaViaDef_getSize_doc[] = 
"Class: oaArrayBase_oaViaDef, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the allocated size of this oaArrayBase<T> array. The number of elements may be less than the allocated size of the array.\n"
;

static PyObject*
oaArrayBase_oaViaDef_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaViaDef data;
    int convert_status=PyoaArrayBase_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaViaDefObject* self=(PyoaArrayBase_oaViaDefObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaViaDef_set_doc[] = 
"Class: oaArrayBase_oaViaDef, Function: set\n"
"  Paramegers: ([oaViaDef])\n"
"    Calls: void set( array)\n"
"    Signature: set|void-void|cpptr-oaViaDef,simple-oaUInt4,\n"
"    This function copies numElements from the specified C-style array to this array. The size of this array is set to numElements .\n"
"    array\n"
"    pointer to the array to copy\n"
"    numElements\n"
"    number of elements to copy\n"
;

static PyObject*
oaArrayBase_oaViaDef_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaViaDef data;
    int convert_status=PyoaArrayBase_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaViaDefObject* self=(PyoaArrayBase_oaViaDefObject*)ob;

    PyParamoaViaDef_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaViaDef_Array_Convert,&p1)) {
        data.DataCall()->set(p1.Data(),p1.Len());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaViaDef_setNumElements_doc[] = 
"Class: oaArrayBase_oaViaDef, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 n)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in this oaArrayBase<T> array to the specified n value. The specified value is not checked against the actual size of the array. This is normally used when an application first sets the size of the array, fills it in, and then sets the number of elements the array contains.\n"
"    n\n"
"    Specifies the number of elements this array contains\n"
;

static PyObject*
oaArrayBase_oaViaDef_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaViaDef data;
    int convert_status=PyoaArrayBase_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaViaDefObject* self=(PyoaArrayBase_oaViaDefObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayBase_oaViaDef_setSize_doc[] = 
"Class: oaArrayBase_oaViaDef, Function: setSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setSize(oaUInt4 newSize)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: void setSize(oaUInt4 newSize,oaBoolean saveElements)\n"
"    Signature: setSize|void-void|simple-oaUInt4,simple-oaBoolean,\n"
"    This function resizes this oaArrayBase<T> to contain the specified newSize number of elements. If saveData is false, this oaArrayBase<T> is not initialized. If true, the original data is preserved. If newSize is less than numObjs, all of the data will not be preserved.\n"
"    newSize\n"
"    the new size of the oaArrayBase<T>\n"
"    saveElements\n"
"    indicates whether the resized array will be reinitialized (saveElements = false) or the current data (up to and including the number of elements specified by newSize ) will be preserved (saveElements = true)\n"
;

static PyObject*
oaArrayBase_oaViaDef_setSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayBase_oaViaDef data;
    int convert_status=PyoaArrayBase_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayBase_oaViaDefObject* self=(PyoaArrayBase_oaViaDefObject*)ob;

    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            data.DataCall()->setSize(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->setSize(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayBase_oaViaDef, function: setSize, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArrayBase_oaViaDef_assign_doc[] = 
"Class: oaArrayBase_oaViaDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayBase_oaViaDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayBase_oaViaDef data;
  int convert_status=PyoaArrayBase_oaViaDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayBase_oaViaDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayBase_oaViaDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayBase_oaViaDef_methodlist[] = {
    {"get",(PyCFunction)oaArrayBase_oaViaDef_get,METH_VARARGS,oaArrayBase_oaViaDef_get_doc},
    {"getNumElements",(PyCFunction)oaArrayBase_oaViaDef_getNumElements,METH_VARARGS,oaArrayBase_oaViaDef_getNumElements_doc},
    {"getSize",(PyCFunction)oaArrayBase_oaViaDef_getSize,METH_VARARGS,oaArrayBase_oaViaDef_getSize_doc},
    {"set",(PyCFunction)oaArrayBase_oaViaDef_set,METH_VARARGS,oaArrayBase_oaViaDef_set_doc},
    {"setNumElements",(PyCFunction)oaArrayBase_oaViaDef_setNumElements,METH_VARARGS,oaArrayBase_oaViaDef_setNumElements_doc},
    {"setSize",(PyCFunction)oaArrayBase_oaViaDef_setSize,METH_VARARGS,oaArrayBase_oaViaDef_setSize_doc},
    {"assign",(PyCFunction)oaArrayBase_oaViaDef_tp_assign,METH_VARARGS,oaArrayBase_oaViaDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaArrayBase_oaViaDef_as_sequence = {
    (Pyoa_inquiry)oaArrayBase_oaViaDef_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaArrayBase_oaViaDef_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaArrayBase_oaViaDef_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaArrayBase_oaViaDef_doc[] = 
"Class: oaArrayBase_oaViaDef\n"
"  The oaArrayBase<> class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is being used as a buffer because it reduces the need to re-allocate the array.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArrayBase_oaViaDef()\n"
"    Signature: oaArrayBase_oaViaDef||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArrayBase_oaViaDef(oaUInt4 size)\n"
"    Signature: oaArrayBase_oaViaDef||simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor allocates enough storage to hold the specified size number of elements.\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArrayBase_oaViaDef)\n"
"    Calls: oaArrayBase_oaViaDef(const oaArrayBase_oaViaDef& array)\n"
"    Signature: oaArrayBase_oaViaDef||cref-oaArrayBase_oaViaDef,\n"
"    This oaArrayBase<T> constructor copies the elements of the specified oaArrayBase<T> array .\n"
"    array\n"
"    The oaArrayBase<T> to copy\n"
"  Paramegers: ([oaViaDef])\n"
"    Calls: oaArrayBase_oaViaDef( array)\n"
"    Signature: oaArrayBase_oaViaDef||cpptr-oaViaDef,simple-oaUInt4,\n"
"    This oaArrayBase<T> constructor uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    array[] C-style array of T elements\n"
"    numElementsIn\n"
"    numElementsIn number elements\n"
"  Paramegers: (oaArrayBase_oaViaDef)\n"
"    Calls: (const oaArrayBase_oaViaDef&)\n"
"    Signature: oaArrayBase_oaViaDef||cref-oaArrayBase_oaViaDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayBase_oaViaDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayBase_oaViaDef",
    sizeof(PyoaArrayBase_oaViaDefObject),
    0,
    (destructor)oaArrayBase_oaViaDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayBase_oaViaDef_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayBase_oaViaDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaArrayBase_oaViaDef_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayBase_oaViaDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayBase_oaViaDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayBase_oaViaDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayBase_oaViaDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayBase_oaViaDef_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayBase_oaViaDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayBase_oaViaDef",
           (PyObject*)(&PyoaArrayBase_oaViaDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayBase_oaViaDef\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArrayInst
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArrayInst_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArrayInst_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArrayInstObject* self = (PyoaArrayInstObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaArrayInst)
    {
        PyParamoaArrayInst p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaArrayInst_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArrayInst, Choices are:\n"
        "    (oaArrayInst)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArrayInst_tp_dealloc(PyoaArrayInstObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArrayInst_tp_repr(PyObject *ob)
{
    PyParamoaArrayInst value;
    int convert_status=PyoaArrayInst_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaArrayInst::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaScalarName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[33];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaArrayInst::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArrayInst_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArrayInst v1;
    PyParamoaArrayInst v2;
    int convert_status1=PyoaArrayInst_Convert(ob1,&v1);
    int convert_status2=PyoaArrayInst_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArrayInst_Convert(PyObject* ob,PyParamoaArrayInst* result)
{
    if (ob == NULL) return 1;
    if (PyoaArrayInst_Check(ob)) {
        result->SetData( (oaArrayInst**) ((PyoaArrayInstObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArrayInst Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayInst_FromoaArrayInst(oaArrayInst** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaArrayInst* data=*value;
        PyObject* bself = PyoaArrayInst_Type.tp_alloc(&PyoaArrayInst_Type,0);
        if (bself == NULL) return bself;
        PyoaArrayInstObject* self = (PyoaArrayInstObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaArrayInst_FromoaArrayInst(oaArrayInst* data)
{
    if (data) {
       PyObject* bself = PyoaArrayInst_Type.tp_alloc(&PyoaArrayInst_Type,0);
       if (bself == NULL) return bself;
       PyoaArrayInstObject* self = (PyoaArrayInstObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayInst_getBBox_doc[] = 
"Class: oaArrayInst, Function: getBBox\n"
"  Paramegers: (oaUInt4,oaUInt4,oaBox)\n"
"    Calls: void getBBox(oaUInt4 row,oaUInt4 col,oaBox& bBox) const\n"
"    Signature: getBBox|void-void|simple-oaUInt4,simple-oaUInt4,ref-oaBox,\n"
"    This function fills out bBox with the effective bounding box of the specified element of this arrayInst.\n"
;

static PyObject*
oaArrayInst_getBBox(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayInst data;
    int convert_status=PyoaArrayInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayInstObject* self=(PyoaArrayInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    PyParamoaBox p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2,
          &PyoaBox_Convert,&p3)) {
        data.DataCall()->getBBox(p1.Data(),p2.Data(),p3.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayInst_getDX_doc[] = 
"Class: oaArrayInst, Function: getDX\n"
"  Paramegers: ()\n"
"    Calls: oaOffset getDX() const\n"
"    Signature: getDX|simple-oaOffset|\n"
"    BrowseData: 1\n"
"    This function returns the spacing between columns of this arrayInst.\n"
;

static PyObject*
oaArrayInst_getDX(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayInst data;
    int convert_status=PyoaArrayInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayInstObject* self=(PyoaArrayInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaOffset result= (data.DataCall()->getDX());
        return PyoaOffset_FromoaOffset(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayInst_getDY_doc[] = 
"Class: oaArrayInst, Function: getDY\n"
"  Paramegers: ()\n"
"    Calls: oaOffset getDY() const\n"
"    Signature: getDY|simple-oaOffset|\n"
"    BrowseData: 1\n"
"    This function returns the spacing between rows of this arrayInst.\n"
;

static PyObject*
oaArrayInst_getDY(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayInst data;
    int convert_status=PyoaArrayInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayInstObject* self=(PyoaArrayInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaOffset result= (data.DataCall()->getDY());
        return PyoaOffset_FromoaOffset(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayInst_getName_doc[] = 
"Class: oaArrayInst, Function: getName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getName(oaScalarName& name) const\n"
"    Signature: getName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the name of this arrayInst.\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the name of this arrayInst in the specified nameSpace.\n"
;

static PyObject*
oaArrayInst_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayInst data;
    int convert_status=PyoaArrayInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayInstObject* self=(PyoaArrayInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayInst, function: getName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayInst_getNumCols_doc[] = 
"Class: oaArrayInst, Function: getNumCols\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumCols() const\n"
"    Signature: getNumCols|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of columns in this arrayInst.\n"
;

static PyObject*
oaArrayInst_getNumCols(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayInst data;
    int convert_status=PyoaArrayInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayInstObject* self=(PyoaArrayInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumCols());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayInst_getNumRows_doc[] = 
"Class: oaArrayInst, Function: getNumRows\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumRows() const\n"
"    Signature: getNumRows|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of rows in this arrayInst.\n"
;

static PyObject*
oaArrayInst_getNumRows(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayInst data;
    int convert_status=PyoaArrayInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayInstObject* self=(PyoaArrayInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumRows());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayInst_getOverlap_doc[] = 
"Class: oaArrayInst, Function: getOverlap\n"
"  Paramegers: (oaBox,oaDist,oaDist,oaDist,oaDist)\n"
"    Calls: void getOverlap(const oaBox& region,oaDist& xMin,oaDist& xMax,oaDist& yMin,oaDist& yMax) const\n"
"    Signature: getOverlap|void-void|cref-oaBox,ref-oaDist,ref-oaDist,ref-oaDist,ref-oaDist,\n"
"    This function calculates the elements of this arrayInst that are overlapped, either fully or partially, by the specified region .\n"
;

static PyObject*
oaArrayInst_getOverlap(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayInst data;
    int convert_status=PyoaArrayInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayInstObject* self=(PyoaArrayInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBox p1;
    PyParamoaDist p2;
    PyParamoaDist p3;
    PyParamoaDist p4;
    PyParamoaDist p5;
    if (PyArg_ParseTuple(args,"O&O&O&O&O&",
          &PyoaBox_Convert,&p1,
          &PyoaDist_Convert,&p2,
          &PyoaDist_Convert,&p3,
          &PyoaDist_Convert,&p4,
          &PyoaDist_Convert,&p5)) {
        data.DataCall()->getOverlap(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayInst_getTransform_doc[] = 
"Class: oaArrayInst, Function: getTransform\n"
"  Paramegers: (oaUInt4,oaUInt4,oaTransform)\n"
"    Calls: void getTransform(oaUInt4 row,oaUInt4 col,oaTransform& xform) const\n"
"    Signature: getTransform|void-void|simple-oaUInt4,simple-oaUInt4,ref-oaTransform,\n"
"    This function fills out xform with the effective transform of the specified element of the arrayInst represented by this arrayInstData.\n"
;

static PyObject*
oaArrayInst_getTransform(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayInst data;
    int convert_status=PyoaArrayInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayInstObject* self=(PyoaArrayInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    PyParamoaTransform p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2,
          &PyoaTransform_Convert,&p3)) {
        data.DataCall()->getTransform(p1.Data(),p2.Data(),p3.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayInst_setDX_doc[] = 
"Class: oaArrayInst, Function: setDX\n"
"  Paramegers: (oaOffset)\n"
"    Calls: void setDX(oaOffset dX)\n"
"    Signature: setDX|void-void|simple-oaOffset,\n"
"    This function sets the offset spacing between columns of this arrayInst.\n"
;

static PyObject*
oaArrayInst_setDX(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayInst data;
    int convert_status=PyoaArrayInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayInstObject* self=(PyoaArrayInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaOffset p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOffset_Convert,&p1)) {
        data.DataCall()->setDX(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayInst_setDY_doc[] = 
"Class: oaArrayInst, Function: setDY\n"
"  Paramegers: (oaOffset)\n"
"    Calls: void setDY(oaOffset dY)\n"
"    Signature: setDY|void-void|simple-oaOffset,\n"
"    This function sets the offset spacing between rows of this arrayInst.\n"
;

static PyObject*
oaArrayInst_setDY(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayInst data;
    int convert_status=PyoaArrayInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayInstObject* self=(PyoaArrayInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaOffset p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOffset_Convert,&p1)) {
        data.DataCall()->setDY(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayInst_setName_doc[] = 
"Class: oaArrayInst, Function: setName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void setName(const oaScalarName& name)\n"
"    Signature: setName|void-void|cref-oaScalarName,\n"
"    This function changes the name of this instance to the specified name .\n"
"    Exceptions are thrown if:\n"
"    the specified name does not imply a scalar name\n"
"    an instance already exists with the specified name\n"
"    a vectorInstDef exists with the specified name\n"
"    oacInvalidHierInstName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
;

static PyObject*
oaArrayInst_setName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayInst data;
    int convert_status=PyoaArrayInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayInstObject* self=(PyoaArrayInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScalarName p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaScalarName_Convert,&p1)) {
        data.DataCall()->setName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayInst_setNumCols_doc[] = 
"Class: oaArrayInst, Function: setNumCols\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumCols(oaUInt4 numCols)\n"
"    Signature: setNumCols|void-void|simple-oaUInt4,\n"
"    This function sets the number of columns in this arrayInst.\n"
"    oacInvalidArrayInstCols\n"
;

static PyObject*
oaArrayInst_setNumCols(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayInst data;
    int convert_status=PyoaArrayInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayInstObject* self=(PyoaArrayInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumCols(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayInst_setNumRows_doc[] = 
"Class: oaArrayInst, Function: setNumRows\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumRows(oaUInt4 numRows)\n"
"    Signature: setNumRows|void-void|simple-oaUInt4,\n"
"    This function sets the number of rows in this arrayInst.\n"
"    oacInvalidArrayInstRows\n"
;

static PyObject*
oaArrayInst_setNumRows(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArrayInst data;
    int convert_status=PyoaArrayInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArrayInstObject* self=(PyoaArrayInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumRows(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayInst_isNull_doc[] =
"Class: oaArrayInst, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaArrayInst_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaArrayInst data;
    int convert_status=PyoaArrayInst_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaArrayInst_assign_doc[] = 
"Class: oaArrayInst, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArrayInst_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArrayInst data;
  int convert_status=PyoaArrayInst_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArrayInst p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArrayInst_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArrayInst_methodlist[] = {
    {"getBBox",(PyCFunction)oaArrayInst_getBBox,METH_VARARGS,oaArrayInst_getBBox_doc},
    {"getDX",(PyCFunction)oaArrayInst_getDX,METH_VARARGS,oaArrayInst_getDX_doc},
    {"getDY",(PyCFunction)oaArrayInst_getDY,METH_VARARGS,oaArrayInst_getDY_doc},
    {"getName",(PyCFunction)oaArrayInst_getName,METH_VARARGS,oaArrayInst_getName_doc},
    {"getNumCols",(PyCFunction)oaArrayInst_getNumCols,METH_VARARGS,oaArrayInst_getNumCols_doc},
    {"getNumRows",(PyCFunction)oaArrayInst_getNumRows,METH_VARARGS,oaArrayInst_getNumRows_doc},
    {"getOverlap",(PyCFunction)oaArrayInst_getOverlap,METH_VARARGS,oaArrayInst_getOverlap_doc},
    {"getTransform",(PyCFunction)oaArrayInst_getTransform,METH_VARARGS,oaArrayInst_getTransform_doc},
    {"setDX",(PyCFunction)oaArrayInst_setDX,METH_VARARGS,oaArrayInst_setDX_doc},
    {"setDY",(PyCFunction)oaArrayInst_setDY,METH_VARARGS,oaArrayInst_setDY_doc},
    {"setName",(PyCFunction)oaArrayInst_setName,METH_VARARGS,oaArrayInst_setName_doc},
    {"setNumCols",(PyCFunction)oaArrayInst_setNumCols,METH_VARARGS,oaArrayInst_setNumCols_doc},
    {"setNumRows",(PyCFunction)oaArrayInst_setNumRows,METH_VARARGS,oaArrayInst_setNumRows_doc},
    {"isNull",(PyCFunction)oaArrayInst_tp_isNull,METH_VARARGS,oaArrayInst_isNull_doc},
    {"assign",(PyCFunction)oaArrayInst_tp_assign,METH_VARARGS,oaArrayInst_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayInst_doc[] = 
"Class: oaArrayInst\n"
"  The oaArrayInst class implements an oaArrayInst database object that represents an array of instances of one master design. Every cell in the array has the same orientation. The oaArrayInst object is primarily used in the physical layout design -- for example, it can be used to represent an array of memory cells.\n"
"  Note that oaArrayInsts do not provide any mechanism for specifying the connectivity between elements of the array. They act just like oaScalarInsts in that there is a single copy of their terminals, and the width of the nets connecting to them is unaffected by the array dimensions.\n"
"Constructors:\n"
"  Paramegers: (oaArrayInst)\n"
"    Calls: (const oaArrayInst&)\n"
"    Signature: oaArrayInst||cref-oaArrayInst,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArrayInst_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArrayInst",
    sizeof(PyoaArrayInstObject),
    0,
    (destructor)oaArrayInst_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArrayInst_tp_compare,	/* tp_compare */
    (reprfunc)oaArrayInst_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArrayInst_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArrayInst_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaBitInst_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArrayInst_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArrayInst_static_create_doc[] = 
"Class: oaArrayInst, Function: create\n"
"  Paramegers: (oaBlock,oaDesign,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4)\n"
"    Calls: oaArrayInst* create(oaBlock* block,oaDesign* master,const oaScalarName& name,const oaTransform& xform,oaOffset dX,oaOffset dY,oaUInt4 numRows,oaUInt4 numCols)\n"
"    Signature: create|ptr-oaArrayInst|ptr-oaBlock,ptr-oaDesign,cref-oaScalarName,cref-oaTransform,simple-oaOffset,simple-oaOffset,simple-oaUInt4,simple-oaUInt4,cptr-oaParamArray,simple-oaPlacementStatus,\n"
"    This function creates an oaArrayInst object with the specified attributes, with a unique name you specify.\n"
"    Exceptions are thrown if:\n"
"    the specified name does not imply a scalar name\n"
"    an instance already exists with the specified name\n"
"    a vectorInstDef exists with the specified name\n"
"    oaArrayInst* if the instance was created\n"
"    block\n"
"    The block in which to place the instance\n"
"    master\n"
"    The design used as the master\n"
"    name\n"
"    A unique name to give to the instance\n"
"    xform\n"
"    An instance transform that applies to the entire array\n"
"    dX\n"
"    The offset spacing between instance placements in the X direction\n"
"    dY\n"
"    The offset spacing between instance placements in the Y direction\n"
"    numRows\n"
"    The number of rows in the Y direction\n"
"    numCols\n"
"    The number of columns in the X direction\n"
"    params\n"
"    Optionally makes an array of parameterized instances\n"
"    status\n"
"    Specifies the placement status of this instance\n"
"    oacInvalidArrayInstRows\n"
"    oacInvalidArrayInstCols\n"
"    oacInvalidSuperMaster\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"    oacInvalidHierInstName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"  Paramegers: (oaBlock,oaDesign,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4,oaParamArray)\n"
"    Calls: oaArrayInst* create(oaBlock* block,oaDesign* master,const oaScalarName& name,const oaTransform& xform,oaOffset dX,oaOffset dY,oaUInt4 numRows,oaUInt4 numCols,const oaParamArray* params)\n"
"    Signature: create|ptr-oaArrayInst|ptr-oaBlock,ptr-oaDesign,cref-oaScalarName,cref-oaTransform,simple-oaOffset,simple-oaOffset,simple-oaUInt4,simple-oaUInt4,cptr-oaParamArray,simple-oaPlacementStatus,\n"
"    This function creates an oaArrayInst object with the specified attributes, with a unique name you specify.\n"
"    Exceptions are thrown if:\n"
"    the specified name does not imply a scalar name\n"
"    an instance already exists with the specified name\n"
"    a vectorInstDef exists with the specified name\n"
"    oaArrayInst* if the instance was created\n"
"    block\n"
"    The block in which to place the instance\n"
"    master\n"
"    The design used as the master\n"
"    name\n"
"    A unique name to give to the instance\n"
"    xform\n"
"    An instance transform that applies to the entire array\n"
"    dX\n"
"    The offset spacing between instance placements in the X direction\n"
"    dY\n"
"    The offset spacing between instance placements in the Y direction\n"
"    numRows\n"
"    The number of rows in the Y direction\n"
"    numCols\n"
"    The number of columns in the X direction\n"
"    params\n"
"    Optionally makes an array of parameterized instances\n"
"    status\n"
"    Specifies the placement status of this instance\n"
"    oacInvalidArrayInstRows\n"
"    oacInvalidArrayInstCols\n"
"    oacInvalidSuperMaster\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"    oacInvalidHierInstName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"  Paramegers: (oaBlock,oaDesign,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4,oaParamArray,oaPlacementStatus)\n"
"    Calls: oaArrayInst* create(oaBlock* block,oaDesign* master,const oaScalarName& name,const oaTransform& xform,oaOffset dX,oaOffset dY,oaUInt4 numRows,oaUInt4 numCols,const oaParamArray* params,oaPlacementStatus status)\n"
"    Signature: create|ptr-oaArrayInst|ptr-oaBlock,ptr-oaDesign,cref-oaScalarName,cref-oaTransform,simple-oaOffset,simple-oaOffset,simple-oaUInt4,simple-oaUInt4,cptr-oaParamArray,simple-oaPlacementStatus,\n"
"    This function creates an oaArrayInst object with the specified attributes, with a unique name you specify.\n"
"    Exceptions are thrown if:\n"
"    the specified name does not imply a scalar name\n"
"    an instance already exists with the specified name\n"
"    a vectorInstDef exists with the specified name\n"
"    oaArrayInst* if the instance was created\n"
"    block\n"
"    The block in which to place the instance\n"
"    master\n"
"    The design used as the master\n"
"    name\n"
"    A unique name to give to the instance\n"
"    xform\n"
"    An instance transform that applies to the entire array\n"
"    dX\n"
"    The offset spacing between instance placements in the X direction\n"
"    dY\n"
"    The offset spacing between instance placements in the Y direction\n"
"    numRows\n"
"    The number of rows in the Y direction\n"
"    numCols\n"
"    The number of columns in the X direction\n"
"    params\n"
"    Optionally makes an array of parameterized instances\n"
"    status\n"
"    Specifies the placement status of this instance\n"
"    oacInvalidArrayInstRows\n"
"    oacInvalidArrayInstCols\n"
"    oacInvalidSuperMaster\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"    oacInvalidHierInstName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"  Paramegers: (oaBlock,oaDesign,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4)\n"
"    Calls: oaArrayInst* create(oaBlock* block,oaDesign* master,const oaTransform& xform,oaOffset dX,oaOffset dY,oaUInt4 numRows,oaUInt4 numCols)\n"
"    Signature: create|ptr-oaArrayInst|ptr-oaBlock,ptr-oaDesign,cref-oaTransform,simple-oaOffset,simple-oaOffset,simple-oaUInt4,simple-oaUInt4,cptr-oaParamArray,simple-oaPlacementStatus,\n"
"    This function creates an oaArrayInst object with the specified attributes, automatically assigning a unique name.\n"
"    oaArrayInst* if the instance was created\n"
"    block\n"
"    The block in which to place the instance\n"
"    master\n"
"    The design used as the master\n"
"    xform\n"
"    An instance transform that applies to the entire array\n"
"    dX\n"
"    The offset spacing between instance placements in the X direction\n"
"    dY\n"
"    The offset spacing between instance placements in the Y direction\n"
"    numRows\n"
"    The number of rows in the Y direction\n"
"    numCols\n"
"    The number of columns in the X direction\n"
"    params\n"
"    Optionally makes an array of parameterized instances\n"
"    status\n"
"    Specifies the placement status of this instance\n"
"    oacInvalidArrayInstRows\n"
"    oacInvalidArrayInstCols\n"
"    oacInvalidSuperMaster\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"  Paramegers: (oaBlock,oaDesign,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4,oaParamArray)\n"
"    Calls: oaArrayInst* create(oaBlock* block,oaDesign* master,const oaTransform& xform,oaOffset dX,oaOffset dY,oaUInt4 numRows,oaUInt4 numCols,const oaParamArray* params)\n"
"    Signature: create|ptr-oaArrayInst|ptr-oaBlock,ptr-oaDesign,cref-oaTransform,simple-oaOffset,simple-oaOffset,simple-oaUInt4,simple-oaUInt4,cptr-oaParamArray,simple-oaPlacementStatus,\n"
"    This function creates an oaArrayInst object with the specified attributes, automatically assigning a unique name.\n"
"    oaArrayInst* if the instance was created\n"
"    block\n"
"    The block in which to place the instance\n"
"    master\n"
"    The design used as the master\n"
"    xform\n"
"    An instance transform that applies to the entire array\n"
"    dX\n"
"    The offset spacing between instance placements in the X direction\n"
"    dY\n"
"    The offset spacing between instance placements in the Y direction\n"
"    numRows\n"
"    The number of rows in the Y direction\n"
"    numCols\n"
"    The number of columns in the X direction\n"
"    params\n"
"    Optionally makes an array of parameterized instances\n"
"    status\n"
"    Specifies the placement status of this instance\n"
"    oacInvalidArrayInstRows\n"
"    oacInvalidArrayInstCols\n"
"    oacInvalidSuperMaster\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"  Paramegers: (oaBlock,oaDesign,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4,oaParamArray,oaPlacementStatus)\n"
"    Calls: oaArrayInst* create(oaBlock* block,oaDesign* master,const oaTransform& xform,oaOffset dX,oaOffset dY,oaUInt4 numRows,oaUInt4 numCols,const oaParamArray* params,oaPlacementStatus status)\n"
"    Signature: create|ptr-oaArrayInst|ptr-oaBlock,ptr-oaDesign,cref-oaTransform,simple-oaOffset,simple-oaOffset,simple-oaUInt4,simple-oaUInt4,cptr-oaParamArray,simple-oaPlacementStatus,\n"
"    This function creates an oaArrayInst object with the specified attributes, automatically assigning a unique name.\n"
"    oaArrayInst* if the instance was created\n"
"    block\n"
"    The block in which to place the instance\n"
"    master\n"
"    The design used as the master\n"
"    xform\n"
"    An instance transform that applies to the entire array\n"
"    dX\n"
"    The offset spacing between instance placements in the X direction\n"
"    dY\n"
"    The offset spacing between instance placements in the Y direction\n"
"    numRows\n"
"    The number of rows in the Y direction\n"
"    numCols\n"
"    The number of columns in the X direction\n"
"    params\n"
"    Optionally makes an array of parameterized instances\n"
"    status\n"
"    Specifies the placement status of this instance\n"
"    oacInvalidArrayInstRows\n"
"    oacInvalidArrayInstCols\n"
"    oacInvalidSuperMaster\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"  Paramegers: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4)\n"
"    Calls: oaArrayInst* create(oaBlock* block,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName,const oaScalarName& name,const oaTransform& xform,oaOffset dX,oaOffset dY,oaUInt4 numRows,oaUInt4 numCols)\n"
"    Signature: create|ptr-oaArrayInst|ptr-oaBlock,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cref-oaTransform,simple-oaOffset,simple-oaOffset,simple-oaUInt4,simple-oaUInt4,cptr-oaParamArray,simple-oaPlacementStatus,\n"
"    This function creates an oaArrayInst object with the specified attributes and a unique name that you specify. The libName , cellName , and viewName arguments for the master are required. The master does not need to be open to create instances.\n"
"    Exceptions are thrown if:\n"
"    the specified name does not imply a scalar name\n"
"    an instance already exists with the specified name\n"
"    a vectorInstDef exists with the specified name\n"
"    oaArrayInst* if the instance was created\n"
"    block\n"
"    The block in which to place the instance\n"
"    libName\n"
"    The name of an existing library\n"
"    cellName\n"
"    The name of an existing cell\n"
"    viewName\n"
"    The name of an existing design\n"
"    name\n"
"    A unique name to give to the instance\n"
"    xform\n"
"    An instance transform that applies to the entire array\n"
"    dX\n"
"    The offset spacing between instance placements in the X direction\n"
"    dY\n"
"    The offset spacing between instance placements in the Y direction\n"
"    numRows\n"
"    The number of rows in the Y direction\n"
"    numCols\n"
"    The number of columns in the X direction\n"
"    params\n"
"    Optionally makes an array of parameterized instances\n"
"    status\n"
"    Specifies the placement status of this instance\n"
"    oacInvalidArrayInstRows\n"
"    oacInvalidArrayInstCols\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"    oacInvalidHierInstName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"  Paramegers: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4,oaParamArray)\n"
"    Calls: oaArrayInst* create(oaBlock* block,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName,const oaScalarName& name,const oaTransform& xform,oaOffset dX,oaOffset dY,oaUInt4 numRows,oaUInt4 numCols,const oaParamArray* params)\n"
"    Signature: create|ptr-oaArrayInst|ptr-oaBlock,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cref-oaTransform,simple-oaOffset,simple-oaOffset,simple-oaUInt4,simple-oaUInt4,cptr-oaParamArray,simple-oaPlacementStatus,\n"
"    This function creates an oaArrayInst object with the specified attributes and a unique name that you specify. The libName , cellName , and viewName arguments for the master are required. The master does not need to be open to create instances.\n"
"    Exceptions are thrown if:\n"
"    the specified name does not imply a scalar name\n"
"    an instance already exists with the specified name\n"
"    a vectorInstDef exists with the specified name\n"
"    oaArrayInst* if the instance was created\n"
"    block\n"
"    The block in which to place the instance\n"
"    libName\n"
"    The name of an existing library\n"
"    cellName\n"
"    The name of an existing cell\n"
"    viewName\n"
"    The name of an existing design\n"
"    name\n"
"    A unique name to give to the instance\n"
"    xform\n"
"    An instance transform that applies to the entire array\n"
"    dX\n"
"    The offset spacing between instance placements in the X direction\n"
"    dY\n"
"    The offset spacing between instance placements in the Y direction\n"
"    numRows\n"
"    The number of rows in the Y direction\n"
"    numCols\n"
"    The number of columns in the X direction\n"
"    params\n"
"    Optionally makes an array of parameterized instances\n"
"    status\n"
"    Specifies the placement status of this instance\n"
"    oacInvalidArrayInstRows\n"
"    oacInvalidArrayInstCols\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"    oacInvalidHierInstName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"  Paramegers: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4,oaParamArray,oaPlacementStatus)\n"
"    Calls: oaArrayInst* create(oaBlock* block,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName,const oaScalarName& name,const oaTransform& xform,oaOffset dX,oaOffset dY,oaUInt4 numRows,oaUInt4 numCols,const oaParamArray* params,oaPlacementStatus status)\n"
"    Signature: create|ptr-oaArrayInst|ptr-oaBlock,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cref-oaTransform,simple-oaOffset,simple-oaOffset,simple-oaUInt4,simple-oaUInt4,cptr-oaParamArray,simple-oaPlacementStatus,\n"
"    This function creates an oaArrayInst object with the specified attributes and a unique name that you specify. The libName , cellName , and viewName arguments for the master are required. The master does not need to be open to create instances.\n"
"    Exceptions are thrown if:\n"
"    the specified name does not imply a scalar name\n"
"    an instance already exists with the specified name\n"
"    a vectorInstDef exists with the specified name\n"
"    oaArrayInst* if the instance was created\n"
"    block\n"
"    The block in which to place the instance\n"
"    libName\n"
"    The name of an existing library\n"
"    cellName\n"
"    The name of an existing cell\n"
"    viewName\n"
"    The name of an existing design\n"
"    name\n"
"    A unique name to give to the instance\n"
"    xform\n"
"    An instance transform that applies to the entire array\n"
"    dX\n"
"    The offset spacing between instance placements in the X direction\n"
"    dY\n"
"    The offset spacing between instance placements in the Y direction\n"
"    numRows\n"
"    The number of rows in the Y direction\n"
"    numCols\n"
"    The number of columns in the X direction\n"
"    params\n"
"    Optionally makes an array of parameterized instances\n"
"    status\n"
"    Specifies the placement status of this instance\n"
"    oacInvalidArrayInstRows\n"
"    oacInvalidArrayInstCols\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"    oacInvalidHierInstName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"  Paramegers: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4)\n"
"    Calls: oaArrayInst* create(oaBlock* block,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName,const oaTransform& xform,oaOffset dX,oaOffset dY,oaUInt4 numRows,oaUInt4 numCols)\n"
"    Signature: create|ptr-oaArrayInst|ptr-oaBlock,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cref-oaTransform,simple-oaOffset,simple-oaOffset,simple-oaUInt4,simple-oaUInt4,cptr-oaParamArray,simple-oaPlacementStatus,\n"
"    )\n"
"    This function creates an oaArrayInst object with the specified attributes, automatically assigning a unique name. The libName , cellName , and viewName arguments for the master are required. The master does not need to be open to create instances.\n"
"    oaArrayInst* if the instance was created\n"
"    block\n"
"    The block in which to place the instance\n"
"    libName\n"
"    The name of an existing library\n"
"    cellName\n"
"    The name of an existing cell\n"
"    viewName\n"
"    The name of an existing design\n"
"    xform\n"
"    An instance transform that applies to the entire array\n"
"    dX\n"
"    The offset spacing between instance placements in the X direction\n"
"    dY\n"
"    The offset spacing between instance placements in the Y direction\n"
"    numRows\n"
"    The number of rows in the Y direction\n"
"    numCols\n"
"    The number of columns in the X direction\n"
"    params\n"
"    Optionally makes an array of parameterized instances\n"
"    status\n"
"    Specifies the placement status of this instance\n"
"    oacInvalidArrayInstRows\n"
"    oacInvalidArrayInstCols\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"  Paramegers: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4,oaParamArray)\n"
"    Calls: oaArrayInst* create(oaBlock* block,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName,const oaTransform& xform,oaOffset dX,oaOffset dY,oaUInt4 numRows,oaUInt4 numCols,const oaParamArray* params)\n"
"    Signature: create|ptr-oaArrayInst|ptr-oaBlock,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cref-oaTransform,simple-oaOffset,simple-oaOffset,simple-oaUInt4,simple-oaUInt4,cptr-oaParamArray,simple-oaPlacementStatus,\n"
"    )\n"
"    This function creates an oaArrayInst object with the specified attributes, automatically assigning a unique name. The libName , cellName , and viewName arguments for the master are required. The master does not need to be open to create instances.\n"
"    oaArrayInst* if the instance was created\n"
"    block\n"
"    The block in which to place the instance\n"
"    libName\n"
"    The name of an existing library\n"
"    cellName\n"
"    The name of an existing cell\n"
"    viewName\n"
"    The name of an existing design\n"
"    xform\n"
"    An instance transform that applies to the entire array\n"
"    dX\n"
"    The offset spacing between instance placements in the X direction\n"
"    dY\n"
"    The offset spacing between instance placements in the Y direction\n"
"    numRows\n"
"    The number of rows in the Y direction\n"
"    numCols\n"
"    The number of columns in the X direction\n"
"    params\n"
"    Optionally makes an array of parameterized instances\n"
"    status\n"
"    Specifies the placement status of this instance\n"
"    oacInvalidArrayInstRows\n"
"    oacInvalidArrayInstCols\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
"  Paramegers: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4,oaParamArray,oaPlacementStatus)\n"
"    Calls: oaArrayInst* create(oaBlock* block,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName,const oaTransform& xform,oaOffset dX,oaOffset dY,oaUInt4 numRows,oaUInt4 numCols,const oaParamArray* params,oaPlacementStatus status)\n"
"    Signature: create|ptr-oaArrayInst|ptr-oaBlock,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cref-oaTransform,simple-oaOffset,simple-oaOffset,simple-oaUInt4,simple-oaUInt4,cptr-oaParamArray,simple-oaPlacementStatus,\n"
"    )\n"
"    This function creates an oaArrayInst object with the specified attributes, automatically assigning a unique name. The libName , cellName , and viewName arguments for the master are required. The master does not need to be open to create instances.\n"
"    oaArrayInst* if the instance was created\n"
"    block\n"
"    The block in which to place the instance\n"
"    libName\n"
"    The name of an existing library\n"
"    cellName\n"
"    The name of an existing cell\n"
"    viewName\n"
"    The name of an existing design\n"
"    xform\n"
"    An instance transform that applies to the entire array\n"
"    dX\n"
"    The offset spacing between instance placements in the X direction\n"
"    dY\n"
"    The offset spacing between instance placements in the Y direction\n"
"    numRows\n"
"    The number of rows in the Y direction\n"
"    numCols\n"
"    The number of columns in the X direction\n"
"    params\n"
"    Optionally makes an array of parameterized instances\n"
"    status\n"
"    Specifies the placement status of this instance\n"
"    oacInvalidArrayInstRows\n"
"    oacInvalidArrayInstCols\n"
"    oacParamsSuppliedForNonPCellInstMaster\n"
;

static PyObject*
oaArrayInst_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaBlock,oaDesign,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4)
    {
        PyParamoaBlock p1;
        PyParamoaDesign p2;
        PyParamoaScalarName p3;
        PyParamoaTransform p4;
        PyParamoaOffset p5;
        PyParamoaOffset p6;
        PyParamoaUInt4 p7;
        PyParamoaUInt4 p8;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaDesign_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaTransform_Convert,&p4,
              &PyoaOffset_Convert,&p5,
              &PyoaOffset_Convert,&p6,
              &PyoaUInt4_Convert,&p7,
              &PyoaUInt4_Convert,&p8)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaArrayInstp result= (oaArrayInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.Data()));
            return PyoaArrayInst_FromoaArrayInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaDesign,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4,oaParamArray)
    {
        PyParamoaBlock p1;
        PyParamoaDesign p2;
        PyParamoaScalarName p3;
        PyParamoaTransform p4;
        PyParamoaOffset p5;
        PyParamoaOffset p6;
        PyParamoaUInt4 p7;
        PyParamoaUInt4 p8;
        PyParamoaParamArray p9;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaDesign_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaTransform_Convert,&p4,
              &PyoaOffset_Convert,&p5,
              &PyoaOffset_Convert,&p6,
              &PyoaUInt4_Convert,&p7,
              &PyoaUInt4_Convert,&p8,
              &PyoaParamArray_ConvertAof,&p9)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaArrayInstp result= (oaArrayInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.Data(),p9.DataAof()));
            return PyoaArrayInst_FromoaArrayInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaDesign,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4,oaParamArray,oaPlacementStatus)
    {
        PyParamoaBlock p1;
        PyParamoaDesign p2;
        PyParamoaScalarName p3;
        PyParamoaTransform p4;
        PyParamoaOffset p5;
        PyParamoaOffset p6;
        PyParamoaUInt4 p7;
        PyParamoaUInt4 p8;
        PyParamoaParamArray p9;
        PyParamoaPlacementStatus p10;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaDesign_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaTransform_Convert,&p4,
              &PyoaOffset_Convert,&p5,
              &PyoaOffset_Convert,&p6,
              &PyoaUInt4_Convert,&p7,
              &PyoaUInt4_Convert,&p8,
              &PyoaParamArray_ConvertAof,&p9,
              &PyoaPlacementStatus_Convert,&p10)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaArrayInstp result= (oaArrayInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.Data(),p9.DataAof(),p10.Data()));
            return PyoaArrayInst_FromoaArrayInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaDesign,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4)
    {
        PyParamoaBlock p1;
        PyParamoaDesign p2;
        PyParamoaTransform p3;
        PyParamoaOffset p4;
        PyParamoaOffset p5;
        PyParamoaUInt4 p6;
        PyParamoaUInt4 p7;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaDesign_Convert,&p2,
              &PyoaTransform_Convert,&p3,
              &PyoaOffset_Convert,&p4,
              &PyoaOffset_Convert,&p5,
              &PyoaUInt4_Convert,&p6,
              &PyoaUInt4_Convert,&p7)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaArrayInstp result= (oaArrayInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data()));
            return PyoaArrayInst_FromoaArrayInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaDesign,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4,oaParamArray)
    {
        PyParamoaBlock p1;
        PyParamoaDesign p2;
        PyParamoaTransform p3;
        PyParamoaOffset p4;
        PyParamoaOffset p5;
        PyParamoaUInt4 p6;
        PyParamoaUInt4 p7;
        PyParamoaParamArray p8;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaDesign_Convert,&p2,
              &PyoaTransform_Convert,&p3,
              &PyoaOffset_Convert,&p4,
              &PyoaOffset_Convert,&p5,
              &PyoaUInt4_Convert,&p6,
              &PyoaUInt4_Convert,&p7,
              &PyoaParamArray_ConvertAof,&p8)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaArrayInstp result= (oaArrayInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.DataAof()));
            return PyoaArrayInst_FromoaArrayInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaDesign,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4,oaParamArray,oaPlacementStatus)
    {
        PyParamoaBlock p1;
        PyParamoaDesign p2;
        PyParamoaTransform p3;
        PyParamoaOffset p4;
        PyParamoaOffset p5;
        PyParamoaUInt4 p6;
        PyParamoaUInt4 p7;
        PyParamoaParamArray p8;
        PyParamoaPlacementStatus p9;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaDesign_Convert,&p2,
              &PyoaTransform_Convert,&p3,
              &PyoaOffset_Convert,&p4,
              &PyoaOffset_Convert,&p5,
              &PyoaUInt4_Convert,&p6,
              &PyoaUInt4_Convert,&p7,
              &PyoaParamArray_ConvertAof,&p8,
              &PyoaPlacementStatus_Convert,&p9)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaArrayInstp result= (oaArrayInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.DataAof(),p9.Data()));
            return PyoaArrayInst_FromoaArrayInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4)
    {
        PyParamoaBlock p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        PyParamoaScalarName p5;
        PyParamoaTransform p6;
        PyParamoaOffset p7;
        PyParamoaOffset p8;
        PyParamoaUInt4 p9;
        PyParamoaUInt4 p10;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4,
              &PyoaScalarName_Convert,&p5,
              &PyoaTransform_Convert,&p6,
              &PyoaOffset_Convert,&p7,
              &PyoaOffset_Convert,&p8,
              &PyoaUInt4_Convert,&p9,
              &PyoaUInt4_Convert,&p10)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaArrayInstp result= (oaArrayInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.Data(),p9.Data(),p10.Data()));
            return PyoaArrayInst_FromoaArrayInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4,oaParamArray)
    {
        PyParamoaBlock p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        PyParamoaScalarName p5;
        PyParamoaTransform p6;
        PyParamoaOffset p7;
        PyParamoaOffset p8;
        PyParamoaUInt4 p9;
        PyParamoaUInt4 p10;
        PyParamoaParamArray p11;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4,
              &PyoaScalarName_Convert,&p5,
              &PyoaTransform_Convert,&p6,
              &PyoaOffset_Convert,&p7,
              &PyoaOffset_Convert,&p8,
              &PyoaUInt4_Convert,&p9,
              &PyoaUInt4_Convert,&p10,
              &PyoaParamArray_ConvertAof,&p11)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaArrayInstp result= (oaArrayInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.Data(),p9.Data(),p10.Data(),p11.DataAof()));
            return PyoaArrayInst_FromoaArrayInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4,oaParamArray,oaPlacementStatus)
    {
        PyParamoaBlock p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        PyParamoaScalarName p5;
        PyParamoaTransform p6;
        PyParamoaOffset p7;
        PyParamoaOffset p8;
        PyParamoaUInt4 p9;
        PyParamoaUInt4 p10;
        PyParamoaParamArray p11;
        PyParamoaPlacementStatus p12;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4,
              &PyoaScalarName_Convert,&p5,
              &PyoaTransform_Convert,&p6,
              &PyoaOffset_Convert,&p7,
              &PyoaOffset_Convert,&p8,
              &PyoaUInt4_Convert,&p9,
              &PyoaUInt4_Convert,&p10,
              &PyoaParamArray_ConvertAof,&p11,
              &PyoaPlacementStatus_Convert,&p12)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaArrayInstp result= (oaArrayInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.Data(),p9.Data(),p10.Data(),p11.DataAof(),p12.Data()));
            return PyoaArrayInst_FromoaArrayInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4)
    {
        PyParamoaBlock p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        PyParamoaTransform p5;
        PyParamoaOffset p6;
        PyParamoaOffset p7;
        PyParamoaUInt4 p8;
        PyParamoaUInt4 p9;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4,
              &PyoaTransform_Convert,&p5,
              &PyoaOffset_Convert,&p6,
              &PyoaOffset_Convert,&p7,
              &PyoaUInt4_Convert,&p8,
              &PyoaUInt4_Convert,&p9)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaArrayInstp result= (oaArrayInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.Data(),p9.Data()));
            return PyoaArrayInst_FromoaArrayInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4,oaParamArray)
    {
        PyParamoaBlock p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        PyParamoaTransform p5;
        PyParamoaOffset p6;
        PyParamoaOffset p7;
        PyParamoaUInt4 p8;
        PyParamoaUInt4 p9;
        PyParamoaParamArray p10;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4,
              &PyoaTransform_Convert,&p5,
              &PyoaOffset_Convert,&p6,
              &PyoaOffset_Convert,&p7,
              &PyoaUInt4_Convert,&p8,
              &PyoaUInt4_Convert,&p9,
              &PyoaParamArray_ConvertAof,&p10)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaArrayInstp result= (oaArrayInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.Data(),p9.Data(),p10.DataAof()));
            return PyoaArrayInst_FromoaArrayInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4,oaParamArray,oaPlacementStatus)
    {
        PyParamoaBlock p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        PyParamoaTransform p5;
        PyParamoaOffset p6;
        PyParamoaOffset p7;
        PyParamoaUInt4 p8;
        PyParamoaUInt4 p9;
        PyParamoaParamArray p10;
        PyParamoaPlacementStatus p11;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4,
              &PyoaTransform_Convert,&p5,
              &PyoaOffset_Convert,&p6,
              &PyoaOffset_Convert,&p7,
              &PyoaUInt4_Convert,&p8,
              &PyoaUInt4_Convert,&p9,
              &PyoaParamArray_ConvertAof,&p10,
              &PyoaPlacementStatus_Convert,&p11)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaArrayInstp result= (oaArrayInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.Data(),p9.Data(),p10.DataAof(),p11.Data()));
            return PyoaArrayInst_FromoaArrayInst(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArrayInst, function: create, Choices are:\n"
        "    (oaBlock,oaDesign,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4)\n"
        "    (oaBlock,oaDesign,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4,oaParamArray)\n"
        "    (oaBlock,oaDesign,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4,oaParamArray,oaPlacementStatus)\n"
        "    (oaBlock,oaDesign,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4)\n"
        "    (oaBlock,oaDesign,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4,oaParamArray)\n"
        "    (oaBlock,oaDesign,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4,oaParamArray,oaPlacementStatus)\n"
        "    (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4)\n"
        "    (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4,oaParamArray)\n"
        "    (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4,oaParamArray,oaPlacementStatus)\n"
        "    (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4)\n"
        "    (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4,oaParamArray)\n"
        "    (oaBlock,oaScalarName,oaScalarName,oaScalarName,oaTransform,oaOffset,oaOffset,oaUInt4,oaUInt4,oaParamArray,oaPlacementStatus)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayInst_static_find_doc[] = 
"Class: oaArrayInst, Function: find\n"
"  Paramegers: (oaBlock,oaScalarName)\n"
"    Calls: oaArrayInst* find(const oaBlock* block,const oaScalarName& name)\n"
"    Signature: find|ptr-oaArrayInst|cptr-oaBlock,cref-oaScalarName,\n"
"    This function searches the specified block for an arrayInst with the specified name . If found, the arrayInst is returned. Otherwise, NULL is returned. A NULL return does not guarantee the arrayInst name is not used by another type of instance.\n"
"    oaArrayInst* if the instance was found\n"
"    block\n"
"    The block to search\n"
"    name\n"
"    The name to find\n"
;

static PyObject*
oaArrayInst_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaArrayInstp result= (oaArrayInst::find(p1.Data(),p2.Data()));
        return PyoaArrayInst_FromoaArrayInst(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArrayInst_static_isValidName_doc[] = 
"Class: oaArrayInst, Function: isValidName\n"
"  Paramegers: (oaBlock,oaScalarName)\n"
"    Calls: oaBoolean isValidName(oaBlock* block,const oaScalarName& name)\n"
"    Signature: isValidName|simple-oaBoolean|ptr-oaBlock,cref-oaScalarName,\n"
"    This function returns a boolean value that indicates if the specified name is valid for a new oaArrayInst in the specified block .\n"
;

static PyObject*
oaArrayInst_static_isValidName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (oaArrayInst::isValidName(p1.Data(),p2.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaArrayInst_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaArrayInst_static_create,METH_VARARGS,oaArrayInst_static_create_doc},
    {"static_find",(PyCFunction)oaArrayInst_static_find,METH_VARARGS,oaArrayInst_static_find_doc},
    {"static_isValidName",(PyCFunction)oaArrayInst_static_isValidName,METH_VARARGS,oaArrayInst_static_isValidName_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArrayInst_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArrayInst_Type)<0) {
      printf("** PyType_Ready failed for: oaArrayInst\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArrayInst",
           (PyObject*)(&PyoaArrayInst_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArrayInst\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaArrayInst_Type.tp_dict;
    for(method=oaArrayInst_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArraySiteDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArraySiteDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArraySiteDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArraySiteDefObject* self = (PyoaArraySiteDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaArraySiteDef)
    {
        PyParamoaArraySiteDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaArraySiteDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArraySiteDef, Choices are:\n"
        "    (oaArraySiteDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArraySiteDef_tp_dealloc(PyoaArraySiteDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArraySiteDef_tp_repr(PyObject *ob)
{
    PyParamoaArraySiteDef value;
    int convert_status=PyoaArraySiteDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaArraySiteDef::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaString sresult;
        value.DataCall()->getName(sresult);
    
        char addr[36];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaArraySiteDef::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArraySiteDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArraySiteDef v1;
    PyParamoaArraySiteDef v2;
    int convert_status1=PyoaArraySiteDef_Convert(ob1,&v1);
    int convert_status2=PyoaArraySiteDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArraySiteDef_Convert(PyObject* ob,PyParamoaArraySiteDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaArraySiteDef_Check(ob)) {
        result->SetData( (oaArraySiteDef**) ((PyoaArraySiteDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArraySiteDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArraySiteDef_FromoaArraySiteDef(oaArraySiteDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaArraySiteDef* data=*value;
        PyObject* bself = PyoaArraySiteDef_Type.tp_alloc(&PyoaArraySiteDef_Type,0);
        if (bself == NULL) return bself;
        PyoaArraySiteDefObject* self = (PyoaArraySiteDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaArraySiteDef_FromoaArraySiteDef(oaArraySiteDef* data)
{
    if (data) {
       PyObject* bself = PyoaArraySiteDef_Type.tp_alloc(&PyoaArraySiteDef_Type,0);
       if (bself == NULL) return bself;
       PyoaArraySiteDefObject* self = (PyoaArraySiteDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArraySiteDef_getSitePattern_doc[] = 
"Class: oaArraySiteDef, Function: getSitePattern\n"
"  Paramegers: (oaSitePattern)\n"
"    Calls: void getSitePattern(oaSitePattern& sitePattern) const\n"
"    Signature: getSitePattern|void-void|ref-oaSitePattern,\n"
"    BrowseData: 0,oaSitePattern\n"
"    This function fills out the sitePattern of oaScalarSiteDefs for the siteDef.\n"
"    sitePattern\n"
"    The pattern of oaScalarSiteDefs to fill out\n"
;

static PyObject*
oaArraySiteDef_getSitePattern(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArraySiteDef data;
    int convert_status=PyoaArraySiteDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArraySiteDefObject* self=(PyoaArraySiteDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaSitePattern p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaSitePattern_Convert,&p1)) {
        data.DataCall()->getSitePattern(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArraySiteDef_setSitePattern_doc[] = 
"Class: oaArraySiteDef, Function: setSitePattern\n"
"  Paramegers: (oaSitePattern)\n"
"    Calls: void setSitePattern(const oaSitePattern& sitePattern)\n"
"    Signature: setSitePattern|void-void|cref-oaSitePattern,\n"
"    This function sets the sitePattern of oaScalarSiteDefs for the siteDef.\n"
"    sitePattern\n"
"    The pattern of oaScalarSiteDefs to use\n"
;

static PyObject*
oaArraySiteDef_setSitePattern(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArraySiteDef data;
    int convert_status=PyoaArraySiteDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArraySiteDefObject* self=(PyoaArraySiteDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaSitePattern p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaSitePattern_Convert,&p1)) {
        data.DataCall()->setSitePattern(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArraySiteDef_isNull_doc[] =
"Class: oaArraySiteDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaArraySiteDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaArraySiteDef data;
    int convert_status=PyoaArraySiteDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaArraySiteDef_assign_doc[] = 
"Class: oaArraySiteDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArraySiteDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArraySiteDef data;
  int convert_status=PyoaArraySiteDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArraySiteDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArraySiteDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArraySiteDef_methodlist[] = {
    {"getSitePattern",(PyCFunction)oaArraySiteDef_getSitePattern,METH_VARARGS,oaArraySiteDef_getSitePattern_doc},
    {"setSitePattern",(PyCFunction)oaArraySiteDef_setSitePattern,METH_VARARGS,oaArraySiteDef_setSitePattern_doc},
    {"isNull",(PyCFunction)oaArraySiteDef_tp_isNull,METH_VARARGS,oaArraySiteDef_isNull_doc},
    {"assign",(PyCFunction)oaArraySiteDef_tp_assign,METH_VARARGS,oaArraySiteDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArraySiteDef_doc[] = 
"Class: oaArraySiteDef\n"
"  The oaArraySiteDef class defines an array of scalar sites. An array site has a pattern, which is a list of oaScalarSiteDefs and transformations. This is used to determine the width and height of the siteDef.\n"
"Constructors:\n"
"  Paramegers: (oaArraySiteDef)\n"
"    Calls: (const oaArraySiteDef&)\n"
"    Signature: oaArraySiteDef||cref-oaArraySiteDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArraySiteDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArraySiteDef",
    sizeof(PyoaArraySiteDefObject),
    0,
    (destructor)oaArraySiteDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArraySiteDef_tp_compare,	/* tp_compare */
    (reprfunc)oaArraySiteDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArraySiteDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArraySiteDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaSiteDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArraySiteDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArraySiteDef_static_create_doc[] = 
"Class: oaArraySiteDef, Function: create\n"
"  Paramegers: (oaTech,oaString,oaSiteDefType,oaSitePattern)\n"
"    Calls: oaArraySiteDef* create(oaTech* tech,const oaString& name,oaSiteDefType type,const oaSitePattern& sitePattern)\n"
"    Signature: create|ptr-oaArraySiteDef|ptr-oaTech,cref-oaString,simple-oaSiteDefType,cref-oaSitePattern,simple-oaBoolean,simple-oaBoolean,simple-oaBoolean,\n"
"    This function creates an oaArraySiteDef object in the specified technology database with the specified attributes.\n"
"    tech\n"
"    The technology database in which to create the siteDef\n"
"    name\n"
"    The name of the siteDef to create\n"
"    type\n"
"    The type of siteDef to create\n"
"    pattern\n"
"    The pattern of oaScalarSiteDefs to use\n"
"    isSymmetricInX\n"
"    The X symmetry of the siteDef to create\n"
"    isSymmetricInY\n"
"    The Y symmetry of the siteDef to create\n"
"    isSymmetricInRot\n"
"    The rotation symmetry of the siteDef to create\n"
"    oacSiteDefExists\n"
"  Paramegers: (oaTech,oaString,oaSiteDefType,oaSitePattern,oaBoolean)\n"
"    Calls: oaArraySiteDef* create(oaTech* tech,const oaString& name,oaSiteDefType type,const oaSitePattern& sitePattern,oaBoolean isSymmetricInX)\n"
"    Signature: create|ptr-oaArraySiteDef|ptr-oaTech,cref-oaString,simple-oaSiteDefType,cref-oaSitePattern,simple-oaBoolean,simple-oaBoolean,simple-oaBoolean,\n"
"    This function creates an oaArraySiteDef object in the specified technology database with the specified attributes.\n"
"    tech\n"
"    The technology database in which to create the siteDef\n"
"    name\n"
"    The name of the siteDef to create\n"
"    type\n"
"    The type of siteDef to create\n"
"    pattern\n"
"    The pattern of oaScalarSiteDefs to use\n"
"    isSymmetricInX\n"
"    The X symmetry of the siteDef to create\n"
"    isSymmetricInY\n"
"    The Y symmetry of the siteDef to create\n"
"    isSymmetricInRot\n"
"    The rotation symmetry of the siteDef to create\n"
"    oacSiteDefExists\n"
"  Paramegers: (oaTech,oaString,oaSiteDefType,oaSitePattern,oaBoolean,oaBoolean)\n"
"    Calls: oaArraySiteDef* create(oaTech* tech,const oaString& name,oaSiteDefType type,const oaSitePattern& sitePattern,oaBoolean isSymmetricInX,oaBoolean isSymmetricInY)\n"
"    Signature: create|ptr-oaArraySiteDef|ptr-oaTech,cref-oaString,simple-oaSiteDefType,cref-oaSitePattern,simple-oaBoolean,simple-oaBoolean,simple-oaBoolean,\n"
"    This function creates an oaArraySiteDef object in the specified technology database with the specified attributes.\n"
"    tech\n"
"    The technology database in which to create the siteDef\n"
"    name\n"
"    The name of the siteDef to create\n"
"    type\n"
"    The type of siteDef to create\n"
"    pattern\n"
"    The pattern of oaScalarSiteDefs to use\n"
"    isSymmetricInX\n"
"    The X symmetry of the siteDef to create\n"
"    isSymmetricInY\n"
"    The Y symmetry of the siteDef to create\n"
"    isSymmetricInRot\n"
"    The rotation symmetry of the siteDef to create\n"
"    oacSiteDefExists\n"
"  Paramegers: (oaTech,oaString,oaSiteDefType,oaSitePattern,oaBoolean,oaBoolean,oaBoolean)\n"
"    Calls: oaArraySiteDef* create(oaTech* tech,const oaString& name,oaSiteDefType type,const oaSitePattern& sitePattern,oaBoolean isSymmetricInX,oaBoolean isSymmetricInY,oaBoolean isSymmetricInRot)\n"
"    Signature: create|ptr-oaArraySiteDef|ptr-oaTech,cref-oaString,simple-oaSiteDefType,cref-oaSitePattern,simple-oaBoolean,simple-oaBoolean,simple-oaBoolean,\n"
"    This function creates an oaArraySiteDef object in the specified technology database with the specified attributes.\n"
"    tech\n"
"    The technology database in which to create the siteDef\n"
"    name\n"
"    The name of the siteDef to create\n"
"    type\n"
"    The type of siteDef to create\n"
"    pattern\n"
"    The pattern of oaScalarSiteDefs to use\n"
"    isSymmetricInX\n"
"    The X symmetry of the siteDef to create\n"
"    isSymmetricInY\n"
"    The Y symmetry of the siteDef to create\n"
"    isSymmetricInRot\n"
"    The rotation symmetry of the siteDef to create\n"
"    oacSiteDefExists\n"
;

static PyObject*
oaArraySiteDef_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaTech,oaString,oaSiteDefType,oaSitePattern)
    {
        PyParamoaTech p1;
        PyParamoaString p2;
        PyParamoaSiteDefType p3;
        PyParamoaSitePattern p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaSiteDefType_Convert,&p3,
              &PyoaSitePattern_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaArraySiteDefp result= (oaArraySiteDef::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaArraySiteDef_FromoaArraySiteDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTech,oaString,oaSiteDefType,oaSitePattern,oaBoolean)
    {
        PyParamoaTech p1;
        PyParamoaString p2;
        PyParamoaSiteDefType p3;
        PyParamoaSitePattern p4;
        PyParamoaBoolean p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaSiteDefType_Convert,&p3,
              &PyoaSitePattern_Convert,&p4,
              &PyoaBoolean_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaArraySiteDefp result= (oaArraySiteDef::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
            return PyoaArraySiteDef_FromoaArraySiteDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTech,oaString,oaSiteDefType,oaSitePattern,oaBoolean,oaBoolean)
    {
        PyParamoaTech p1;
        PyParamoaString p2;
        PyParamoaSiteDefType p3;
        PyParamoaSitePattern p4;
        PyParamoaBoolean p5;
        PyParamoaBoolean p6;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaSiteDefType_Convert,&p3,
              &PyoaSitePattern_Convert,&p4,
              &PyoaBoolean_Convert,&p5,
              &PyoaBoolean_Convert,&p6)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaArraySiteDefp result= (oaArraySiteDef::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data()));
            return PyoaArraySiteDef_FromoaArraySiteDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTech,oaString,oaSiteDefType,oaSitePattern,oaBoolean,oaBoolean,oaBoolean)
    {
        PyParamoaTech p1;
        PyParamoaString p2;
        PyParamoaSiteDefType p3;
        PyParamoaSitePattern p4;
        PyParamoaBoolean p5;
        PyParamoaBoolean p6;
        PyParamoaBoolean p7;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaSiteDefType_Convert,&p3,
              &PyoaSitePattern_Convert,&p4,
              &PyoaBoolean_Convert,&p5,
              &PyoaBoolean_Convert,&p6,
              &PyoaBoolean_Convert,&p7)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaArraySiteDefp result= (oaArraySiteDef::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data()));
            return PyoaArraySiteDef_FromoaArraySiteDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArraySiteDef, function: create, Choices are:\n"
        "    (oaTech,oaString,oaSiteDefType,oaSitePattern)\n"
        "    (oaTech,oaString,oaSiteDefType,oaSitePattern,oaBoolean)\n"
        "    (oaTech,oaString,oaSiteDefType,oaSitePattern,oaBoolean,oaBoolean)\n"
        "    (oaTech,oaString,oaSiteDefType,oaSitePattern,oaBoolean,oaBoolean,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaArraySiteDef_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaArraySiteDef_static_create,METH_VARARGS,oaArraySiteDef_static_create_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArraySiteDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArraySiteDef_Type)<0) {
      printf("** PyType_Ready failed for: oaArraySiteDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArraySiteDef",
           (PyObject*)(&PyoaArraySiteDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArraySiteDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaArraySiteDef_Type.tp_dict;
    for(method=oaArraySiteDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArray_oaAnalysisPoint
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArray_oaAnalysisPoint_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArray_oaAnalysisPoint_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArray_oaAnalysisPointObject* self = (PyoaArray_oaAnalysisPointObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaArrayBase_oaAnalysisPoint*)  new oaArray_oaAnalysisPoint();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value = (oaArrayBase_oaAnalysisPoint*)  new oaArray_oaAnalysisPoint(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArray_oaAnalysisPoint)
    {
        PyParamoaArray_oaAnalysisPoint p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArray_oaAnalysisPoint_Convert,&p1)) {
            self->value = (oaArrayBase_oaAnalysisPoint*)  new oaArray_oaAnalysisPoint(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaAnalysisPoint])
    {
        PyParamoaAnalysisPoint_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaAnalysisPoint_Array_Convert,&p1)) {
            self->value = (oaArrayBase_oaAnalysisPoint*)  new oaArray_oaAnalysisPoint(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArray_oaAnalysisPoint, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArray_oaAnalysisPoint)\n"
        "    ([oaAnalysisPoint])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArray_oaAnalysisPoint_tp_dealloc(PyoaArray_oaAnalysisPointObject* self)
{
    if (!self->borrow) {
        delete (oaArray_oaAnalysisPoint*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArray_oaAnalysisPoint_tp_repr(PyObject *ob)
{
    PyParamoaArray_oaAnalysisPoint value;
    int convert_status=PyoaArray_oaAnalysisPoint_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[45];
    sprintf(buffer,"<oaArray_oaAnalysisPoint::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArray_oaAnalysisPoint_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArray_oaAnalysisPoint v1;
    PyParamoaArray_oaAnalysisPoint v2;
    int convert_status1=PyoaArray_oaAnalysisPoint_Convert(ob1,&v1);
    int convert_status2=PyoaArray_oaAnalysisPoint_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArray_oaAnalysisPoint_Convert(PyObject* ob,PyParamoaArray_oaAnalysisPoint* result)
{
    if (ob == NULL) return 1;
    if (PyoaArray_oaAnalysisPoint_Check(ob)) {
        result->SetData( (oaArray_oaAnalysisPoint*) ((PyoaArray_oaAnalysisPointObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArray_oaAnalysisPoint Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArray_oaAnalysisPoint_FromoaArray_oaAnalysisPoint(oaArray_oaAnalysisPoint* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArray_oaAnalysisPoint_Type.tp_alloc(&PyoaArray_oaAnalysisPoint_Type,0);
        if (bself == NULL) return bself;
        PyoaArray_oaAnalysisPointObject* self = (PyoaArray_oaAnalysisPointObject*)bself;
        self->value = (oaArrayBase_oaAnalysisPoint*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArray_oaAnalysisPoint_append_doc[] = 
"Class: oaArray_oaAnalysisPoint, Function: append\n"
"  Paramegers: (oaAnalysisPoint)\n"
"    Calls: void append( element)\n"
"    Signature: append|void-void|cptrref-oaAnalysisPoint,\n"
"    This function appends the specified element to the end of this array. This function will increase the size of the array if necessary and will increment the number of elements in the array.\n"
"    element\n"
"    The element to append to this array\n"
"  Paramegers: (oaArray_oaAnalysisPoint)\n"
"    Calls: void append(const oaArray_oaAnalysisPoint& arrayIn)\n"
"    Signature: append|void-void|cref-oaArray_oaAnalysisPoint,\n"
"    oaArray::append\n"
"    This function appends the specified array to the end of this array. This function will increase the size of the array if necessary to fit the specified array contents and will update the number of elements in this array.\n"
"    arrayIn\n"
"    The array of elements to append to this array\n"
;

static PyObject*
oaArray_oaAnalysisPoint_append(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArray_oaAnalysisPoint data;
    int convert_status=PyoaArray_oaAnalysisPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArray_oaAnalysisPointObject* self=(PyoaArray_oaAnalysisPointObject*)ob;

    // Case: (oaAnalysisPoint)
    {
        PyParamoaAnalysisPoint p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaAnalysisPoint_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->append(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaArray_oaAnalysisPoint)
    {
        PyParamoaArray_oaAnalysisPoint p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArray_oaAnalysisPoint_Convert,&p1)) {
            data.DataCall()->append(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArray_oaAnalysisPoint, function: append, Choices are:\n"
        "    (oaAnalysisPoint)\n"
        "    (oaArray_oaAnalysisPoint)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArray_oaAnalysisPoint_find_doc[] = 
"Class: oaArray_oaAnalysisPoint, Function: find\n"
"  Paramegers: (oaAnalysisPoint)\n"
"    Calls: oaUInt4 find( element) const\n"
"    Signature: find|simple-oaUInt4|cptrref-oaAnalysisPoint,\n"
"    This function searches this array for the specified element. The position of the element in the array is returned if found. Otherwise, the value oacNullIndex is returned.\n"
"    element\n"
"    The element to search for in this array\n"
;

static PyObject*
oaArray_oaAnalysisPoint_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArray_oaAnalysisPoint data;
    int convert_status=PyoaArray_oaAnalysisPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArray_oaAnalysisPointObject* self=(PyoaArray_oaAnalysisPointObject*)ob;

    PyParamoaAnalysisPoint p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaAnalysisPoint_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (data.DataCall()->find(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArray_oaAnalysisPoint_remove_doc[] = 
"Class: oaArray_oaAnalysisPoint, Function: remove\n"
"  Paramegers: (oaAnalysisPoint)\n"
"    Calls: void remove( element)\n"
"    Signature: remove|void-void|cptrref-oaAnalysisPoint,\n"
"    This function removes the specified element from this array, shifting the remaining elements up to fill in the gap. The number of elements is decremented accordingly.\n"
"    element\n"
"    The element to remove from this array\n"
;

static PyObject*
oaArray_oaAnalysisPoint_remove(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArray_oaAnalysisPoint data;
    int convert_status=PyoaArray_oaAnalysisPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArray_oaAnalysisPointObject* self=(PyoaArray_oaAnalysisPointObject*)ob;

    PyParamoaAnalysisPoint p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaAnalysisPoint_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->remove(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArray_oaAnalysisPoint_assign_doc[] = 
"Class: oaArray_oaAnalysisPoint, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArray_oaAnalysisPoint_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArray_oaAnalysisPoint data;
  int convert_status=PyoaArray_oaAnalysisPoint_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArray_oaAnalysisPoint p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArray_oaAnalysisPoint_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArray_oaAnalysisPoint_methodlist[] = {
    {"append",(PyCFunction)oaArray_oaAnalysisPoint_append,METH_VARARGS,oaArray_oaAnalysisPoint_append_doc},
    {"find",(PyCFunction)oaArray_oaAnalysisPoint_find,METH_VARARGS,oaArray_oaAnalysisPoint_find_doc},
    {"remove",(PyCFunction)oaArray_oaAnalysisPoint_remove,METH_VARARGS,oaArray_oaAnalysisPoint_remove_doc},
    {"assign",(PyCFunction)oaArray_oaAnalysisPoint_tp_assign,METH_VARARGS,oaArray_oaAnalysisPoint_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArray_oaAnalysisPoint_doc[] = 
"Class: oaArray_oaAnalysisPoint\n"
"  The oaArray class is an abstract class that is the base for many of the array classes used in the OpenAccess API. The oaArray<> template extends the oaArrayBase<> template with some higher-level operations that allow it to function more like a typical container. It supports the basic management facilities for an array of a specified element type. This includes sizing of the array and operators to access and manipulate the data it contains.\n"
"  Different objects derive an array class that is specific to what they need to manipulate with the array, such as the oaTermArray and oaModTermArray classes. These object specific arrays may add to the basic capabilities provided by the oaArray class.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArray_oaAnalysisPoint()\n"
"    Signature: oaArray_oaAnalysisPoint||simple-oaUInt4,\n"
"    This is the constructor for the oaArray<T> template class that constructs an array allocated with enough storage to hold the number of elements specified by size .\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArray_oaAnalysisPoint(oaUInt4 size)\n"
"    Signature: oaArray_oaAnalysisPoint||simple-oaUInt4,\n"
"    This is the constructor for the oaArray<T> template class that constructs an array allocated with enough storage to hold the number of elements specified by size .\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArray_oaAnalysisPoint)\n"
"    Calls: oaArray_oaAnalysisPoint(const oaArray_oaAnalysisPoint& array)\n"
"    Signature: oaArray_oaAnalysisPoint||cref-oaArray_oaAnalysisPoint,\n"
"    This is the constructor for the oaArray<T> template class that constructs an array by making a copy of the specified array.\n"
"    array\n"
"    The array to be copied\n"
"  Paramegers: ([oaAnalysisPoint])\n"
"    Calls: oaArray_oaAnalysisPoint( array)\n"
"    Signature: oaArray_oaAnalysisPoint||cpptr-oaAnalysisPoint,simple-oaUInt4,\n"
"    This is the constructor for the oaArray<T> template that uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    C-style array of T elements\n"
"    numElementsIn\n"
"    number of elements\n"
"  Paramegers: (oaArray_oaAnalysisPoint)\n"
"    Calls: (const oaArray_oaAnalysisPoint&)\n"
"    Signature: oaArray_oaAnalysisPoint||cref-oaArray_oaAnalysisPoint,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArray_oaAnalysisPoint_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArray_oaAnalysisPoint",
    sizeof(PyoaArray_oaAnalysisPointObject),
    0,
    (destructor)oaArray_oaAnalysisPoint_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArray_oaAnalysisPoint_tp_compare,	/* tp_compare */
    (reprfunc)oaArray_oaAnalysisPoint_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArray_oaAnalysisPoint_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArray_oaAnalysisPoint_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaArrayBase_oaAnalysisPoint_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArray_oaAnalysisPoint_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArray_oaAnalysisPoint_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArray_oaAnalysisPoint_Type)<0) {
      printf("** PyType_Ready failed for: oaArray_oaAnalysisPoint\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArray_oaAnalysisPoint",
           (PyObject*)(&PyoaArray_oaAnalysisPoint_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArray_oaAnalysisPoint\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArray_oaAntennaArea
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArray_oaAntennaArea_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArray_oaAntennaArea_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArray_oaAntennaAreaObject* self = (PyoaArray_oaAntennaAreaObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaArrayBase_oaAntennaArea*)  new oaArray_oaAntennaArea();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value = (oaArrayBase_oaAntennaArea*)  new oaArray_oaAntennaArea(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArray_oaAntennaArea)
    {
        PyParamoaArray_oaAntennaArea p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArray_oaAntennaArea_Convert,&p1)) {
            self->value = (oaArrayBase_oaAntennaArea*)  new oaArray_oaAntennaArea(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaAntennaArea])
    {
        PyParamoaAntennaArea_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaAntennaArea_Array_Convert,&p1)) {
            self->value = (oaArrayBase_oaAntennaArea*)  new oaArray_oaAntennaArea(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArray_oaAntennaArea, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArray_oaAntennaArea)\n"
        "    ([oaAntennaArea])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArray_oaAntennaArea_tp_dealloc(PyoaArray_oaAntennaAreaObject* self)
{
    if (!self->borrow) {
        delete (oaArray_oaAntennaArea*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArray_oaAntennaArea_tp_repr(PyObject *ob)
{
    PyParamoaArray_oaAntennaArea value;
    int convert_status=PyoaArray_oaAntennaArea_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaArray_oaAntennaArea::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArray_oaAntennaArea_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArray_oaAntennaArea v1;
    PyParamoaArray_oaAntennaArea v2;
    int convert_status1=PyoaArray_oaAntennaArea_Convert(ob1,&v1);
    int convert_status2=PyoaArray_oaAntennaArea_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArray_oaAntennaArea_Convert(PyObject* ob,PyParamoaArray_oaAntennaArea* result)
{
    if (ob == NULL) return 1;
    if (PyoaArray_oaAntennaArea_Check(ob)) {
        result->SetData( (oaArray_oaAntennaArea*) ((PyoaArray_oaAntennaAreaObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArray_oaAntennaArea Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArray_oaAntennaArea_FromoaArray_oaAntennaArea(oaArray_oaAntennaArea* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArray_oaAntennaArea_Type.tp_alloc(&PyoaArray_oaAntennaArea_Type,0);
        if (bself == NULL) return bself;
        PyoaArray_oaAntennaAreaObject* self = (PyoaArray_oaAntennaAreaObject*)bself;
        self->value = (oaArrayBase_oaAntennaArea*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArray_oaAntennaArea_append_doc[] = 
"Class: oaArray_oaAntennaArea, Function: append\n"
"  Paramegers: (oaAntennaArea)\n"
"    Calls: void append(const oaAntennaArea& element)\n"
"    Signature: append|void-void|cref-oaAntennaArea,\n"
"    This function appends the specified element to the end of this array. This function will increase the size of the array if necessary and will increment the number of elements in the array.\n"
"    element\n"
"    The element to append to this array\n"
"  Paramegers: (oaArray_oaAntennaArea)\n"
"    Calls: void append(const oaArray_oaAntennaArea& arrayIn)\n"
"    Signature: append|void-void|cref-oaArray_oaAntennaArea,\n"
"    oaArray::append\n"
"    This function appends the specified array to the end of this array. This function will increase the size of the array if necessary to fit the specified array contents and will update the number of elements in this array.\n"
"    arrayIn\n"
"    The array of elements to append to this array\n"
;

static PyObject*
oaArray_oaAntennaArea_append(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArray_oaAntennaArea data;
    int convert_status=PyoaArray_oaAntennaArea_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArray_oaAntennaAreaObject* self=(PyoaArray_oaAntennaAreaObject*)ob;

    // Case: (oaAntennaArea)
    {
        PyParamoaAntennaArea p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaAntennaArea_Convert,&p1)) {
            data.DataCall()->append(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaArray_oaAntennaArea)
    {
        PyParamoaArray_oaAntennaArea p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArray_oaAntennaArea_Convert,&p1)) {
            data.DataCall()->append(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArray_oaAntennaArea, function: append, Choices are:\n"
        "    (oaAntennaArea)\n"
        "    (oaArray_oaAntennaArea)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArray_oaAntennaArea_find_doc[] = 
"Class: oaArray_oaAntennaArea, Function: find\n"
"  Paramegers: (oaAntennaArea)\n"
"    Calls: oaUInt4 find(const oaAntennaArea& element) const\n"
"    Signature: find|simple-oaUInt4|cref-oaAntennaArea,\n"
"    This function searches this array for the specified element. The position of the element in the array is returned if found. Otherwise, the value oacNullIndex is returned.\n"
"    element\n"
"    The element to search for in this array\n"
;

static PyObject*
oaArray_oaAntennaArea_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArray_oaAntennaArea data;
    int convert_status=PyoaArray_oaAntennaArea_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArray_oaAntennaAreaObject* self=(PyoaArray_oaAntennaAreaObject*)ob;

    PyParamoaAntennaArea p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaAntennaArea_Convert,&p1)) {
        oaUInt4 result= (data.DataCall()->find(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArray_oaAntennaArea_remove_doc[] = 
"Class: oaArray_oaAntennaArea, Function: remove\n"
"  Paramegers: (oaAntennaArea)\n"
"    Calls: void remove(const oaAntennaArea& element)\n"
"    Signature: remove|void-void|cref-oaAntennaArea,\n"
"    This function removes the specified element from this array, shifting the remaining elements up to fill in the gap. The number of elements is decremented accordingly.\n"
"    element\n"
"    The element to remove from this array\n"
;

static PyObject*
oaArray_oaAntennaArea_remove(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArray_oaAntennaArea data;
    int convert_status=PyoaArray_oaAntennaArea_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArray_oaAntennaAreaObject* self=(PyoaArray_oaAntennaAreaObject*)ob;

    PyParamoaAntennaArea p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaAntennaArea_Convert,&p1)) {
        data.DataCall()->remove(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArray_oaAntennaArea_assign_doc[] = 
"Class: oaArray_oaAntennaArea, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArray_oaAntennaArea_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArray_oaAntennaArea data;
  int convert_status=PyoaArray_oaAntennaArea_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArray_oaAntennaArea p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArray_oaAntennaArea_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArray_oaAntennaArea_methodlist[] = {
    {"append",(PyCFunction)oaArray_oaAntennaArea_append,METH_VARARGS,oaArray_oaAntennaArea_append_doc},
    {"find",(PyCFunction)oaArray_oaAntennaArea_find,METH_VARARGS,oaArray_oaAntennaArea_find_doc},
    {"remove",(PyCFunction)oaArray_oaAntennaArea_remove,METH_VARARGS,oaArray_oaAntennaArea_remove_doc},
    {"assign",(PyCFunction)oaArray_oaAntennaArea_tp_assign,METH_VARARGS,oaArray_oaAntennaArea_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArray_oaAntennaArea_doc[] = 
"Class: oaArray_oaAntennaArea\n"
"  The oaArray class is an abstract class that is the base for many of the array classes used in the OpenAccess API. The oaArray<> template extends the oaArrayBase<> template with some higher-level operations that allow it to function more like a typical container. It supports the basic management facilities for an array of a specified element type. This includes sizing of the array and operators to access and manipulate the data it contains.\n"
"  Different objects derive an array class that is specific to what they need to manipulate with the array, such as the oaTermArray and oaModTermArray classes. These object specific arrays may add to the basic capabilities provided by the oaArray class.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArray_oaAntennaArea()\n"
"    Signature: oaArray_oaAntennaArea||simple-oaUInt4,\n"
"    This is the constructor for the oaArray<T> template class that constructs an array allocated with enough storage to hold the number of elements specified by size .\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArray_oaAntennaArea(oaUInt4 size)\n"
"    Signature: oaArray_oaAntennaArea||simple-oaUInt4,\n"
"    This is the constructor for the oaArray<T> template class that constructs an array allocated with enough storage to hold the number of elements specified by size .\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArray_oaAntennaArea)\n"
"    Calls: oaArray_oaAntennaArea(const oaArray_oaAntennaArea& array)\n"
"    Signature: oaArray_oaAntennaArea||cref-oaArray_oaAntennaArea,\n"
"    This is the constructor for the oaArray<T> template class that constructs an array by making a copy of the specified array.\n"
"    array\n"
"    The array to be copied\n"
"  Paramegers: ([oaAntennaArea])\n"
"    Calls: oaArray_oaAntennaArea(const oaAntennaArea* array)\n"
"    Signature: oaArray_oaAntennaArea||cptr-oaAntennaArea,simple-oaUInt4,\n"
"    This is the constructor for the oaArray<T> template that uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    C-style array of T elements\n"
"    numElementsIn\n"
"    number of elements\n"
"  Paramegers: (oaArray_oaAntennaArea)\n"
"    Calls: (const oaArray_oaAntennaArea&)\n"
"    Signature: oaArray_oaAntennaArea||cref-oaArray_oaAntennaArea,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArray_oaAntennaArea_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArray_oaAntennaArea",
    sizeof(PyoaArray_oaAntennaAreaObject),
    0,
    (destructor)oaArray_oaAntennaArea_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArray_oaAntennaArea_tp_compare,	/* tp_compare */
    (reprfunc)oaArray_oaAntennaArea_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArray_oaAntennaArea_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArray_oaAntennaArea_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaArrayBase_oaAntennaArea_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArray_oaAntennaArea_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArray_oaAntennaArea_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArray_oaAntennaArea_Type)<0) {
      printf("** PyType_Ready failed for: oaArray_oaAntennaArea\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArray_oaAntennaArea",
           (PyObject*)(&PyoaArray_oaAntennaArea_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArray_oaAntennaArea\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArray_oaBox
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArray_oaBox_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArray_oaBox_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArray_oaBoxObject* self = (PyoaArray_oaBoxObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaArrayBase_oaBox*)  new oaArray_oaBox();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value = (oaArrayBase_oaBox*)  new oaArray_oaBox(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArray_oaBox)
    {
        PyParamoaArray_oaBox p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArray_oaBox_Convert,&p1)) {
            self->value = (oaArrayBase_oaBox*)  new oaArray_oaBox(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaBox])
    {
        PyParamoaBox_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBox_Array_Convert,&p1)) {
            self->value = (oaArrayBase_oaBox*)  new oaArray_oaBox(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArray_oaBox, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArray_oaBox)\n"
        "    ([oaBox])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArray_oaBox_tp_dealloc(PyoaArray_oaBoxObject* self)
{
    if (!self->borrow) {
        delete (oaArray_oaBox*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArray_oaBox_tp_repr(PyObject *ob)
{
    PyParamoaArray_oaBox value;
    int convert_status=PyoaArray_oaBox_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[35];
    sprintf(buffer,"<oaArray_oaBox::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArray_oaBox_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArray_oaBox v1;
    PyParamoaArray_oaBox v2;
    int convert_status1=PyoaArray_oaBox_Convert(ob1,&v1);
    int convert_status2=PyoaArray_oaBox_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArray_oaBox_Convert(PyObject* ob,PyParamoaArray_oaBox* result)
{
    if (ob == NULL) return 1;
    if (PyoaArray_oaBox_Check(ob)) {
        result->SetData( (oaArray_oaBox*) ((PyoaArray_oaBoxObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArray_oaBox Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArray_oaBox_FromoaArray_oaBox(oaArray_oaBox* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArray_oaBox_Type.tp_alloc(&PyoaArray_oaBox_Type,0);
        if (bself == NULL) return bself;
        PyoaArray_oaBoxObject* self = (PyoaArray_oaBoxObject*)bself;
        self->value = (oaArrayBase_oaBox*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArray_oaBox_append_doc[] = 
"Class: oaArray_oaBox, Function: append\n"
"  Paramegers: (oaBox)\n"
"    Calls: void append(const oaBox& element)\n"
"    Signature: append|void-void|cref-oaBox,\n"
"    This function appends the specified element to the end of this array. This function will increase the size of the array if necessary and will increment the number of elements in the array.\n"
"    element\n"
"    The element to append to this array\n"
"  Paramegers: (oaArray_oaBox)\n"
"    Calls: void append(const oaArray_oaBox& arrayIn)\n"
"    Signature: append|void-void|cref-oaArray_oaBox,\n"
"    oaArray::append\n"
"    This function appends the specified array to the end of this array. This function will increase the size of the array if necessary to fit the specified array contents and will update the number of elements in this array.\n"
"    arrayIn\n"
"    The array of elements to append to this array\n"
;

static PyObject*
oaArray_oaBox_append(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArray_oaBox data;
    int convert_status=PyoaArray_oaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArray_oaBoxObject* self=(PyoaArray_oaBoxObject*)ob;

    // Case: (oaBox)
    {
        PyParamoaBox p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBox_Convert,&p1)) {
            data.DataCall()->append(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaArray_oaBox)
    {
        PyParamoaArray_oaBox p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArray_oaBox_Convert,&p1)) {
            data.DataCall()->append(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArray_oaBox, function: append, Choices are:\n"
        "    (oaBox)\n"
        "    (oaArray_oaBox)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArray_oaBox_find_doc[] = 
"Class: oaArray_oaBox, Function: find\n"
"  Paramegers: (oaBox)\n"
"    Calls: oaUInt4 find(const oaBox& element) const\n"
"    Signature: find|simple-oaUInt4|cref-oaBox,\n"
"    This function searches this array for the specified element. The position of the element in the array is returned if found. Otherwise, the value oacNullIndex is returned.\n"
"    element\n"
"    The element to search for in this array\n"
;

static PyObject*
oaArray_oaBox_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArray_oaBox data;
    int convert_status=PyoaArray_oaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArray_oaBoxObject* self=(PyoaArray_oaBoxObject*)ob;

    PyParamoaBox p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBox_Convert,&p1)) {
        oaUInt4 result= (data.DataCall()->find(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArray_oaBox_remove_doc[] = 
"Class: oaArray_oaBox, Function: remove\n"
"  Paramegers: (oaBox)\n"
"    Calls: void remove(const oaBox& element)\n"
"    Signature: remove|void-void|cref-oaBox,\n"
"    This function removes the specified element from this array, shifting the remaining elements up to fill in the gap. The number of elements is decremented accordingly.\n"
"    element\n"
"    The element to remove from this array\n"
;

static PyObject*
oaArray_oaBox_remove(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArray_oaBox data;
    int convert_status=PyoaArray_oaBox_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArray_oaBoxObject* self=(PyoaArray_oaBoxObject*)ob;

    PyParamoaBox p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBox_Convert,&p1)) {
        data.DataCall()->remove(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArray_oaBox_assign_doc[] = 
"Class: oaArray_oaBox, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArray_oaBox_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArray_oaBox data;
  int convert_status=PyoaArray_oaBox_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArray_oaBox p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArray_oaBox_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArray_oaBox_methodlist[] = {
    {"append",(PyCFunction)oaArray_oaBox_append,METH_VARARGS,oaArray_oaBox_append_doc},
    {"find",(PyCFunction)oaArray_oaBox_find,METH_VARARGS,oaArray_oaBox_find_doc},
    {"remove",(PyCFunction)oaArray_oaBox_remove,METH_VARARGS,oaArray_oaBox_remove_doc},
    {"assign",(PyCFunction)oaArray_oaBox_tp_assign,METH_VARARGS,oaArray_oaBox_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArray_oaBox_doc[] = 
"Class: oaArray_oaBox\n"
"  The oaArray class is an abstract class that is the base for many of the array classes used in the OpenAccess API. The oaArray<> template extends the oaArrayBase<> template with some higher-level operations that allow it to function more like a typical container. It supports the basic management facilities for an array of a specified element type. This includes sizing of the array and operators to access and manipulate the data it contains.\n"
"  Different objects derive an array class that is specific to what they need to manipulate with the array, such as the oaTermArray and oaModTermArray classes. These object specific arrays may add to the basic capabilities provided by the oaArray class.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArray_oaBox()\n"
"    Signature: oaArray_oaBox||simple-oaUInt4,\n"
"    This is the constructor for the oaArray<T> template class that constructs an array allocated with enough storage to hold the number of elements specified by size .\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArray_oaBox(oaUInt4 size)\n"
"    Signature: oaArray_oaBox||simple-oaUInt4,\n"
"    This is the constructor for the oaArray<T> template class that constructs an array allocated with enough storage to hold the number of elements specified by size .\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArray_oaBox)\n"
"    Calls: oaArray_oaBox(const oaArray_oaBox& array)\n"
"    Signature: oaArray_oaBox||cref-oaArray_oaBox,\n"
"    This is the constructor for the oaArray<T> template class that constructs an array by making a copy of the specified array.\n"
"    array\n"
"    The array to be copied\n"
"  Paramegers: ([oaBox])\n"
"    Calls: oaArray_oaBox(const oaBox* array)\n"
"    Signature: oaArray_oaBox||cptr-oaBox,simple-oaUInt4,\n"
"    This is the constructor for the oaArray<T> template that uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    C-style array of T elements\n"
"    numElementsIn\n"
"    number of elements\n"
"  Paramegers: (oaArray_oaBox)\n"
"    Calls: (const oaArray_oaBox&)\n"
"    Signature: oaArray_oaBox||cref-oaArray_oaBox,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArray_oaBox_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArray_oaBox",
    sizeof(PyoaArray_oaBoxObject),
    0,
    (destructor)oaArray_oaBox_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArray_oaBox_tp_compare,	/* tp_compare */
    (reprfunc)oaArray_oaBox_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArray_oaBox_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArray_oaBox_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaArrayBase_oaBox_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArray_oaBox_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArray_oaBox_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArray_oaBox_Type)<0) {
      printf("** PyType_Ready failed for: oaArray_oaBox\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArray_oaBox",
           (PyObject*)(&PyoaArray_oaBox_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArray_oaBox\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaArray_oaBuildInfo
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaArray_oaBuildInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaArray_oaBuildInfo_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaArray_oaBuildInfoObject* self = (PyoaArray_oaBuildInfoObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaArrayBase_oaBuildInfo*)  new oaArray_oaBuildInfo();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value = (oaArrayBase_oaBuildInfo*)  new oaArray_oaBuildInfo(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaArray_oaBuildInfo)
    {
        PyParamoaArray_oaBuildInfo p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArray_oaBuildInfo_Convert,&p1)) {
            self->value = (oaArrayBase_oaBuildInfo*)  new oaArray_oaBuildInfo(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaBuildInfo])
    {
        PyParamoaBuildInfo_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBuildInfo_Array_Convert,&p1)) {
            self->value = (oaArrayBase_oaBuildInfo*)  new oaArray_oaBuildInfo(p1.Data(),p1.Len());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaArray_oaBuildInfo, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaArray_oaBuildInfo)\n"
        "    ([oaBuildInfo])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaArray_oaBuildInfo_tp_dealloc(PyoaArray_oaBuildInfoObject* self)
{
    if (!self->borrow) {
        delete (oaArray_oaBuildInfo*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaArray_oaBuildInfo_tp_repr(PyObject *ob)
{
    PyParamoaArray_oaBuildInfo value;
    int convert_status=PyoaArray_oaBuildInfo_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[41];
    sprintf(buffer,"<oaArray_oaBuildInfo::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaArray_oaBuildInfo_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaArray_oaBuildInfo v1;
    PyParamoaArray_oaBuildInfo v2;
    int convert_status1=PyoaArray_oaBuildInfo_Convert(ob1,&v1);
    int convert_status2=PyoaArray_oaBuildInfo_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaArray_oaBuildInfo_Convert(PyObject* ob,PyParamoaArray_oaBuildInfo* result)
{
    if (ob == NULL) return 1;
    if (PyoaArray_oaBuildInfo_Check(ob)) {
        result->SetData( (oaArray_oaBuildInfo*) ((PyoaArray_oaBuildInfoObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaArray_oaBuildInfo Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaArray_oaBuildInfo_FromoaArray_oaBuildInfo(oaArray_oaBuildInfo* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaArray_oaBuildInfo_Type.tp_alloc(&PyoaArray_oaBuildInfo_Type,0);
        if (bself == NULL) return bself;
        PyoaArray_oaBuildInfoObject* self = (PyoaArray_oaBuildInfoObject*)bself;
        self->value = (oaArrayBase_oaBuildInfo*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArray_oaBuildInfo_append_doc[] = 
"Class: oaArray_oaBuildInfo, Function: append\n"
"  Paramegers: (oaBuildInfo)\n"
"    Calls: void append( element)\n"
"    Signature: append|void-void|cptrref-oaBuildInfo,\n"
"    This function appends the specified element to the end of this array. This function will increase the size of the array if necessary and will increment the number of elements in the array.\n"
"    element\n"
"    The element to append to this array\n"
"  Paramegers: (oaArray_oaBuildInfo)\n"
"    Calls: void append(const oaArray_oaBuildInfo& arrayIn)\n"
"    Signature: append|void-void|cref-oaArray_oaBuildInfo,\n"
"    oaArray::append\n"
"    This function appends the specified array to the end of this array. This function will increase the size of the array if necessary to fit the specified array contents and will update the number of elements in this array.\n"
"    arrayIn\n"
"    The array of elements to append to this array\n"
;

static PyObject*
oaArray_oaBuildInfo_append(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArray_oaBuildInfo data;
    int convert_status=PyoaArray_oaBuildInfo_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArray_oaBuildInfoObject* self=(PyoaArray_oaBuildInfoObject*)ob;

    // Case: (oaBuildInfo)
    {
        PyParamoaBuildInfo p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBuildInfo_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->append(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaArray_oaBuildInfo)
    {
        PyParamoaArray_oaBuildInfo p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaArray_oaBuildInfo_Convert,&p1)) {
            data.DataCall()->append(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaArray_oaBuildInfo, function: append, Choices are:\n"
        "    (oaBuildInfo)\n"
        "    (oaArray_oaBuildInfo)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArray_oaBuildInfo_find_doc[] = 
"Class: oaArray_oaBuildInfo, Function: find\n"
"  Paramegers: (oaBuildInfo)\n"
"    Calls: oaUInt4 find( element) const\n"
"    Signature: find|simple-oaUInt4|cptrref-oaBuildInfo,\n"
"    This function searches this array for the specified element. The position of the element in the array is returned if found. Otherwise, the value oacNullIndex is returned.\n"
"    element\n"
"    The element to search for in this array\n"
;

static PyObject*
oaArray_oaBuildInfo_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArray_oaBuildInfo data;
    int convert_status=PyoaArray_oaBuildInfo_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArray_oaBuildInfoObject* self=(PyoaArray_oaBuildInfoObject*)ob;

    PyParamoaBuildInfo p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBuildInfo_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (data.DataCall()->find(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaArray_oaBuildInfo_remove_doc[] = 
"Class: oaArray_oaBuildInfo, Function: remove\n"
"  Paramegers: (oaBuildInfo)\n"
"    Calls: void remove( element)\n"
"    Signature: remove|void-void|cptrref-oaBuildInfo,\n"
"    This function removes the specified element from this array, shifting the remaining elements up to fill in the gap. The number of elements is decremented accordingly.\n"
"    element\n"
"    The element to remove from this array\n"
;

static PyObject*
oaArray_oaBuildInfo_remove(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaArray_oaBuildInfo data;
    int convert_status=PyoaArray_oaBuildInfo_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaArray_oaBuildInfoObject* self=(PyoaArray_oaBuildInfoObject*)ob;

    PyParamoaBuildInfo p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBuildInfo_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->remove(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaArray_oaBuildInfo_assign_doc[] = 
"Class: oaArray_oaBuildInfo, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaArray_oaBuildInfo_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaArray_oaBuildInfo data;
  int convert_status=PyoaArray_oaBuildInfo_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaArray_oaBuildInfo p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaArray_oaBuildInfo_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaArray_oaBuildInfo_methodlist[] = {
    {"append",(PyCFunction)oaArray_oaBuildInfo_append,METH_VARARGS,oaArray_oaBuildInfo_append_doc},
    {"find",(PyCFunction)oaArray_oaBuildInfo_find,METH_VARARGS,oaArray_oaBuildInfo_find_doc},
    {"remove",(PyCFunction)oaArray_oaBuildInfo_remove,METH_VARARGS,oaArray_oaBuildInfo_remove_doc},
    {"assign",(PyCFunction)oaArray_oaBuildInfo_tp_assign,METH_VARARGS,oaArray_oaBuildInfo_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaArray_oaBuildInfo_doc[] = 
"Class: oaArray_oaBuildInfo\n"
"  The oaArray class is an abstract class that is the base for many of the array classes used in the OpenAccess API. The oaArray<> template extends the oaArrayBase<> template with some higher-level operations that allow it to function more like a typical container. It supports the basic management facilities for an array of a specified element type. This includes sizing of the array and operators to access and manipulate the data it contains.\n"
"  Different objects derive an array class that is specific to what they need to manipulate with the array, such as the oaTermArray and oaModTermArray classes. These object specific arrays may add to the basic capabilities provided by the oaArray class.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaArray_oaBuildInfo()\n"
"    Signature: oaArray_oaBuildInfo||simple-oaUInt4,\n"
"    This is the constructor for the oaArray<T> template class that constructs an array allocated with enough storage to hold the number of elements specified by size .\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaArray_oaBuildInfo(oaUInt4 size)\n"
"    Signature: oaArray_oaBuildInfo||simple-oaUInt4,\n"
"    This is the constructor for the oaArray<T> template class that constructs an array allocated with enough storage to hold the number of elements specified by size .\n"
"    size\n"
"    Specifies the storage to allocate for size elements\n"
"  Paramegers: (oaArray_oaBuildInfo)\n"
"    Calls: oaArray_oaBuildInfo(const oaArray_oaBuildInfo& array)\n"
"    Signature: oaArray_oaBuildInfo||cref-oaArray_oaBuildInfo,\n"
"    This is the constructor for the oaArray<T> template class that constructs an array by making a copy of the specified array.\n"
"    array\n"
"    The array to be copied\n"
"  Paramegers: ([oaBuildInfo])\n"
"    Calls: oaArray_oaBuildInfo( array)\n"
"    Signature: oaArray_oaBuildInfo||cpptr-oaBuildInfo,simple-oaUInt4,\n"
"    This is the constructor for the oaArray<T> template that uses a C-style array[] of T elements to specify the initial contents of the array.\n"
"    array[]\n"
"    C-style array of T elements\n"
"    numElementsIn\n"
"    number of elements\n"
"  Paramegers: (oaArray_oaBuildInfo)\n"
"    Calls: (const oaArray_oaBuildInfo&)\n"
"    Signature: oaArray_oaBuildInfo||cref-oaArray_oaBuildInfo,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaArray_oaBuildInfo_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaArray_oaBuildInfo",
    sizeof(PyoaArray_oaBuildInfoObject),
    0,
    (destructor)oaArray_oaBuildInfo_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaArray_oaBuildInfo_tp_compare,	/* tp_compare */
    (reprfunc)oaArray_oaBuildInfo_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaArray_oaBuildInfo_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaArray_oaBuildInfo_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaArrayBase_oaBuildInfo_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaArray_oaBuildInfo_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaArray_oaBuildInfo_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaArray_oaBuildInfo_Type)<0) {
      printf("** PyType_Ready failed for: oaArray_oaBuildInfo\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaArray_oaBuildInfo",
           (PyObject*)(&PyoaArray_oaBuildInfo_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaArray_oaBuildInfo\n");
       return -1;
    }
    return 0;
}

