
/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaPurpose
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaPurpose_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaPurpose_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaPurposeObject* self = (PyoaStringAppDef_oaPurposeObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaPurpose)
    {
        PyParamoaStringAppDef_oaPurpose p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaPurpose_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaPurpose, Choices are:\n"
        "    (oaStringAppDef_oaPurpose)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaPurpose_tp_dealloc(PyoaStringAppDef_oaPurposeObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaPurpose_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaPurpose value;
    int convert_status=PyoaStringAppDef_oaPurpose_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[46];
    sprintf(buffer,"<oaStringAppDef_oaPurpose::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaPurpose_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaPurpose v1;
    PyParamoaStringAppDef_oaPurpose v2;
    int convert_status1=PyoaStringAppDef_oaPurpose_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaPurpose_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaPurpose_Convert(PyObject* ob,PyParamoaStringAppDef_oaPurpose* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaPurpose_Check(ob)) {
        result->SetData( (oaStringAppDef_oaPurpose**) ((PyoaStringAppDef_oaPurposeObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaPurpose Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaPurpose_FromoaStringAppDef_oaPurpose(oaStringAppDef_oaPurpose** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaPurpose* data=*value;
        PyObject* bself = PyoaStringAppDef_oaPurpose_Type.tp_alloc(&PyoaStringAppDef_oaPurpose_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaPurposeObject* self = (PyoaStringAppDef_oaPurposeObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaPurpose_FromoaStringAppDef_oaPurpose(oaStringAppDef_oaPurpose* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaPurpose_Type.tp_alloc(&PyoaStringAppDef_oaPurpose_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaPurposeObject* self = (PyoaStringAppDef_oaPurposeObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaPurpose_get_doc[] = 
"Class: oaStringAppDef_oaPurpose, Function: get\n"
"  Paramegers: (oaPurpose,oaString)\n"
"    Calls: void get(const oaPurpose* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaPurpose,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaPurpose_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaPurpose data;
    int convert_status=PyoaStringAppDef_oaPurpose_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaPurposeObject* self=(PyoaStringAppDef_oaPurposeObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaPurpose p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaPurpose_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaPurpose_getDefault_doc[] = 
"Class: oaStringAppDef_oaPurpose, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaPurpose_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaPurpose data;
    int convert_status=PyoaStringAppDef_oaPurpose_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaPurposeObject* self=(PyoaStringAppDef_oaPurposeObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaPurpose_set_doc[] = 
"Class: oaStringAppDef_oaPurpose, Function: set\n"
"  Paramegers: (oaPurpose,oaString)\n"
"    Calls: void set(oaPurpose* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaPurpose,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaPurpose_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaPurpose data;
    int convert_status=PyoaStringAppDef_oaPurpose_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaPurposeObject* self=(PyoaStringAppDef_oaPurposeObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaPurpose p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaPurpose_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaPurpose_isNull_doc[] =
"Class: oaStringAppDef_oaPurpose, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaPurpose_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaPurpose data;
    int convert_status=PyoaStringAppDef_oaPurpose_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaPurpose_assign_doc[] = 
"Class: oaStringAppDef_oaPurpose, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaPurpose_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaPurpose data;
  int convert_status=PyoaStringAppDef_oaPurpose_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaPurpose p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaPurpose_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaPurpose_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaPurpose_get,METH_VARARGS,oaStringAppDef_oaPurpose_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaPurpose_getDefault,METH_VARARGS,oaStringAppDef_oaPurpose_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaPurpose_set,METH_VARARGS,oaStringAppDef_oaPurpose_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaPurpose_tp_isNull,METH_VARARGS,oaStringAppDef_oaPurpose_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaPurpose_tp_assign,METH_VARARGS,oaStringAppDef_oaPurpose_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaPurpose_doc[] = 
"Class: oaStringAppDef_oaPurpose\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaPurpose)\n"
"    Calls: (const oaStringAppDef_oaPurpose&)\n"
"    Signature: oaStringAppDef_oaPurpose||cref-oaStringAppDef_oaPurpose,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaPurpose_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaPurpose",
    sizeof(PyoaStringAppDef_oaPurposeObject),
    0,
    (destructor)oaStringAppDef_oaPurpose_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaPurpose_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaPurpose_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaPurpose_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaPurpose_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaPurpose_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaPurpose_static_find_doc[] = 
"Class: oaStringAppDef_oaPurpose, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaPurpose* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaPurpose|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaPurpose* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaPurpose|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaPurpose_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaPurposep result= (oaStringAppDef_oaPurpose::find(p1.Data()));
            return PyoaStringAppDef_oaPurpose_FromoaStringAppDef_oaPurpose(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaPurposep result= (oaStringAppDef_oaPurpose::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaPurpose_FromoaStringAppDef_oaPurpose(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaPurpose, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaPurpose_static_get_doc[] = 
"Class: oaStringAppDef_oaPurpose, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaPurpose* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaPurpose|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaPurpose* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaPurpose|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaPurpose* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaPurpose|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaPurpose* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaPurpose|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaPurpose* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaPurpose|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaPurpose* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaPurpose|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaPurpose_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaPurposep result= (oaStringAppDef_oaPurpose::get(p1.Data()));
            return PyoaStringAppDef_oaPurpose_FromoaStringAppDef_oaPurpose(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaPurposep result= (oaStringAppDef_oaPurpose::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaPurpose_FromoaStringAppDef_oaPurpose(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaPurposep result= (oaStringAppDef_oaPurpose::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaPurpose_FromoaStringAppDef_oaPurpose(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaPurposep result= (oaStringAppDef_oaPurpose::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaPurpose_FromoaStringAppDef_oaPurpose(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaPurposep result= (oaStringAppDef_oaPurpose::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaPurpose_FromoaStringAppDef_oaPurpose(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaPurposep result= (oaStringAppDef_oaPurpose::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaPurpose_FromoaStringAppDef_oaPurpose(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaPurpose, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaPurpose_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaPurpose_static_find,METH_VARARGS,oaStringAppDef_oaPurpose_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaPurpose_static_get,METH_VARARGS,oaStringAppDef_oaPurpose_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaPurpose_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaPurpose_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaPurpose\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaPurpose",
           (PyObject*)(&PyoaStringAppDef_oaPurpose_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaPurpose\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaPurpose_Type.tp_dict;
    for(method=oaStringAppDef_oaPurpose_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaReducedModel
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaReducedModel_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaReducedModel_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaReducedModelObject* self = (PyoaStringAppDef_oaReducedModelObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaReducedModel)
    {
        PyParamoaStringAppDef_oaReducedModel p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaReducedModel_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaReducedModel, Choices are:\n"
        "    (oaStringAppDef_oaReducedModel)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaReducedModel_tp_dealloc(PyoaStringAppDef_oaReducedModelObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaReducedModel_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaReducedModel value;
    int convert_status=PyoaStringAppDef_oaReducedModel_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[51];
    sprintf(buffer,"<oaStringAppDef_oaReducedModel::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaReducedModel_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaReducedModel v1;
    PyParamoaStringAppDef_oaReducedModel v2;
    int convert_status1=PyoaStringAppDef_oaReducedModel_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaReducedModel_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaReducedModel_Convert(PyObject* ob,PyParamoaStringAppDef_oaReducedModel* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaReducedModel_Check(ob)) {
        result->SetData( (oaStringAppDef_oaReducedModel**) ((PyoaStringAppDef_oaReducedModelObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaReducedModel Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaReducedModel_FromoaStringAppDef_oaReducedModel(oaStringAppDef_oaReducedModel** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaReducedModel* data=*value;
        PyObject* bself = PyoaStringAppDef_oaReducedModel_Type.tp_alloc(&PyoaStringAppDef_oaReducedModel_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaReducedModelObject* self = (PyoaStringAppDef_oaReducedModelObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaReducedModel_FromoaStringAppDef_oaReducedModel(oaStringAppDef_oaReducedModel* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaReducedModel_Type.tp_alloc(&PyoaStringAppDef_oaReducedModel_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaReducedModelObject* self = (PyoaStringAppDef_oaReducedModelObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaReducedModel_get_doc[] = 
"Class: oaStringAppDef_oaReducedModel, Function: get\n"
"  Paramegers: (oaReducedModel,oaString)\n"
"    Calls: void get(const oaReducedModel* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaReducedModel,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaReducedModel_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaReducedModel data;
    int convert_status=PyoaStringAppDef_oaReducedModel_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaReducedModelObject* self=(PyoaStringAppDef_oaReducedModelObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaReducedModel p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaReducedModel_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaReducedModel_getDefault_doc[] = 
"Class: oaStringAppDef_oaReducedModel, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaReducedModel_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaReducedModel data;
    int convert_status=PyoaStringAppDef_oaReducedModel_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaReducedModelObject* self=(PyoaStringAppDef_oaReducedModelObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaReducedModel_set_doc[] = 
"Class: oaStringAppDef_oaReducedModel, Function: set\n"
"  Paramegers: (oaReducedModel,oaString)\n"
"    Calls: void set(oaReducedModel* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaReducedModel,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaReducedModel_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaReducedModel data;
    int convert_status=PyoaStringAppDef_oaReducedModel_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaReducedModelObject* self=(PyoaStringAppDef_oaReducedModelObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaReducedModel p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaReducedModel_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaReducedModel_isNull_doc[] =
"Class: oaStringAppDef_oaReducedModel, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaReducedModel_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaReducedModel data;
    int convert_status=PyoaStringAppDef_oaReducedModel_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaReducedModel_assign_doc[] = 
"Class: oaStringAppDef_oaReducedModel, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaReducedModel_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaReducedModel data;
  int convert_status=PyoaStringAppDef_oaReducedModel_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaReducedModel p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaReducedModel_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaReducedModel_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaReducedModel_get,METH_VARARGS,oaStringAppDef_oaReducedModel_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaReducedModel_getDefault,METH_VARARGS,oaStringAppDef_oaReducedModel_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaReducedModel_set,METH_VARARGS,oaStringAppDef_oaReducedModel_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaReducedModel_tp_isNull,METH_VARARGS,oaStringAppDef_oaReducedModel_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaReducedModel_tp_assign,METH_VARARGS,oaStringAppDef_oaReducedModel_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaReducedModel_doc[] = 
"Class: oaStringAppDef_oaReducedModel\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaReducedModel)\n"
"    Calls: (const oaStringAppDef_oaReducedModel&)\n"
"    Signature: oaStringAppDef_oaReducedModel||cref-oaStringAppDef_oaReducedModel,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaReducedModel_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaReducedModel",
    sizeof(PyoaStringAppDef_oaReducedModelObject),
    0,
    (destructor)oaStringAppDef_oaReducedModel_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaReducedModel_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaReducedModel_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaReducedModel_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaReducedModel_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaReducedModel_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaReducedModel_static_find_doc[] = 
"Class: oaStringAppDef_oaReducedModel, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaReducedModel* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaReducedModel|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaReducedModel* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaReducedModel|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaReducedModel_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaReducedModelp result= (oaStringAppDef_oaReducedModel::find(p1.Data()));
            return PyoaStringAppDef_oaReducedModel_FromoaStringAppDef_oaReducedModel(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaReducedModelp result= (oaStringAppDef_oaReducedModel::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaReducedModel_FromoaStringAppDef_oaReducedModel(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaReducedModel, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaReducedModel_static_get_doc[] = 
"Class: oaStringAppDef_oaReducedModel, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaReducedModel* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaReducedModel|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaReducedModel* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaReducedModel|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaReducedModel* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaReducedModel|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaReducedModel* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaReducedModel|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaReducedModel* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaReducedModel|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaReducedModel* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaReducedModel|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaReducedModel_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaReducedModelp result= (oaStringAppDef_oaReducedModel::get(p1.Data()));
            return PyoaStringAppDef_oaReducedModel_FromoaStringAppDef_oaReducedModel(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaReducedModelp result= (oaStringAppDef_oaReducedModel::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaReducedModel_FromoaStringAppDef_oaReducedModel(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaReducedModelp result= (oaStringAppDef_oaReducedModel::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaReducedModel_FromoaStringAppDef_oaReducedModel(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaReducedModelp result= (oaStringAppDef_oaReducedModel::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaReducedModel_FromoaStringAppDef_oaReducedModel(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaReducedModelp result= (oaStringAppDef_oaReducedModel::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaReducedModel_FromoaStringAppDef_oaReducedModel(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaReducedModelp result= (oaStringAppDef_oaReducedModel::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaReducedModel_FromoaStringAppDef_oaReducedModel(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaReducedModel, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaReducedModel_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaReducedModel_static_find,METH_VARARGS,oaStringAppDef_oaReducedModel_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaReducedModel_static_get,METH_VARARGS,oaStringAppDef_oaReducedModel_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaReducedModel_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaReducedModel_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaReducedModel\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaReducedModel",
           (PyObject*)(&PyoaStringAppDef_oaReducedModel_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaReducedModel\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaReducedModel_Type.tp_dict;
    for(method=oaStringAppDef_oaReducedModel_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaReticle
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaReticle_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaReticle_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaReticleObject* self = (PyoaStringAppDef_oaReticleObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaReticle)
    {
        PyParamoaStringAppDef_oaReticle p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaReticle_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaReticle, Choices are:\n"
        "    (oaStringAppDef_oaReticle)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaReticle_tp_dealloc(PyoaStringAppDef_oaReticleObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaReticle_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaReticle value;
    int convert_status=PyoaStringAppDef_oaReticle_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[46];
    sprintf(buffer,"<oaStringAppDef_oaReticle::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaReticle_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaReticle v1;
    PyParamoaStringAppDef_oaReticle v2;
    int convert_status1=PyoaStringAppDef_oaReticle_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaReticle_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaReticle_Convert(PyObject* ob,PyParamoaStringAppDef_oaReticle* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaReticle_Check(ob)) {
        result->SetData( (oaStringAppDef_oaReticle**) ((PyoaStringAppDef_oaReticleObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaReticle Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaReticle_FromoaStringAppDef_oaReticle(oaStringAppDef_oaReticle** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaReticle* data=*value;
        PyObject* bself = PyoaStringAppDef_oaReticle_Type.tp_alloc(&PyoaStringAppDef_oaReticle_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaReticleObject* self = (PyoaStringAppDef_oaReticleObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaReticle_FromoaStringAppDef_oaReticle(oaStringAppDef_oaReticle* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaReticle_Type.tp_alloc(&PyoaStringAppDef_oaReticle_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaReticleObject* self = (PyoaStringAppDef_oaReticleObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaReticle_get_doc[] = 
"Class: oaStringAppDef_oaReticle, Function: get\n"
"  Paramegers: (oaReticle,oaString)\n"
"    Calls: void get(const oaReticle* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaReticle,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaReticle_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaReticle data;
    int convert_status=PyoaStringAppDef_oaReticle_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaReticleObject* self=(PyoaStringAppDef_oaReticleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaReticle p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaReticle_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaReticle_getDefault_doc[] = 
"Class: oaStringAppDef_oaReticle, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaReticle_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaReticle data;
    int convert_status=PyoaStringAppDef_oaReticle_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaReticleObject* self=(PyoaStringAppDef_oaReticleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaReticle_set_doc[] = 
"Class: oaStringAppDef_oaReticle, Function: set\n"
"  Paramegers: (oaReticle,oaString)\n"
"    Calls: void set(oaReticle* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaReticle,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaReticle_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaReticle data;
    int convert_status=PyoaStringAppDef_oaReticle_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaReticleObject* self=(PyoaStringAppDef_oaReticleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaReticle p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaReticle_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaReticle_isNull_doc[] =
"Class: oaStringAppDef_oaReticle, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaReticle_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaReticle data;
    int convert_status=PyoaStringAppDef_oaReticle_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaReticle_assign_doc[] = 
"Class: oaStringAppDef_oaReticle, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaReticle_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaReticle data;
  int convert_status=PyoaStringAppDef_oaReticle_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaReticle p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaReticle_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaReticle_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaReticle_get,METH_VARARGS,oaStringAppDef_oaReticle_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaReticle_getDefault,METH_VARARGS,oaStringAppDef_oaReticle_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaReticle_set,METH_VARARGS,oaStringAppDef_oaReticle_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaReticle_tp_isNull,METH_VARARGS,oaStringAppDef_oaReticle_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaReticle_tp_assign,METH_VARARGS,oaStringAppDef_oaReticle_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaReticle_doc[] = 
"Class: oaStringAppDef_oaReticle\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaReticle)\n"
"    Calls: (const oaStringAppDef_oaReticle&)\n"
"    Signature: oaStringAppDef_oaReticle||cref-oaStringAppDef_oaReticle,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaReticle_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaReticle",
    sizeof(PyoaStringAppDef_oaReticleObject),
    0,
    (destructor)oaStringAppDef_oaReticle_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaReticle_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaReticle_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaReticle_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaReticle_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaReticle_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaReticle_static_find_doc[] = 
"Class: oaStringAppDef_oaReticle, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaReticle* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaReticle|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaReticle* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaReticle|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaReticle_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaReticlep result= (oaStringAppDef_oaReticle::find(p1.Data()));
            return PyoaStringAppDef_oaReticle_FromoaStringAppDef_oaReticle(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaReticlep result= (oaStringAppDef_oaReticle::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaReticle_FromoaStringAppDef_oaReticle(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaReticle, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaReticle_static_get_doc[] = 
"Class: oaStringAppDef_oaReticle, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaReticle* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaReticle|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaReticle* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaReticle|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaReticle* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaReticle|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaReticle* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaReticle|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaReticle* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaReticle|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaReticle* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaReticle|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaReticle_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaReticlep result= (oaStringAppDef_oaReticle::get(p1.Data()));
            return PyoaStringAppDef_oaReticle_FromoaStringAppDef_oaReticle(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaReticlep result= (oaStringAppDef_oaReticle::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaReticle_FromoaStringAppDef_oaReticle(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaReticlep result= (oaStringAppDef_oaReticle::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaReticle_FromoaStringAppDef_oaReticle(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaReticlep result= (oaStringAppDef_oaReticle::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaReticle_FromoaStringAppDef_oaReticle(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaReticlep result= (oaStringAppDef_oaReticle::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaReticle_FromoaStringAppDef_oaReticle(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaReticlep result= (oaStringAppDef_oaReticle::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaReticle_FromoaStringAppDef_oaReticle(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaReticle, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaReticle_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaReticle_static_find,METH_VARARGS,oaStringAppDef_oaReticle_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaReticle_static_get,METH_VARARGS,oaStringAppDef_oaReticle_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaReticle_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaReticle_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaReticle\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaReticle",
           (PyObject*)(&PyoaStringAppDef_oaReticle_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaReticle\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaReticle_Type.tp_dict;
    for(method=oaStringAppDef_oaReticle_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaReticleRef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaReticleRef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaReticleRef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaReticleRefObject* self = (PyoaStringAppDef_oaReticleRefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaReticleRef)
    {
        PyParamoaStringAppDef_oaReticleRef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaReticleRef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaReticleRef, Choices are:\n"
        "    (oaStringAppDef_oaReticleRef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaReticleRef_tp_dealloc(PyoaStringAppDef_oaReticleRefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaReticleRef_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaReticleRef value;
    int convert_status=PyoaStringAppDef_oaReticleRef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[49];
    sprintf(buffer,"<oaStringAppDef_oaReticleRef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaReticleRef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaReticleRef v1;
    PyParamoaStringAppDef_oaReticleRef v2;
    int convert_status1=PyoaStringAppDef_oaReticleRef_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaReticleRef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaReticleRef_Convert(PyObject* ob,PyParamoaStringAppDef_oaReticleRef* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaReticleRef_Check(ob)) {
        result->SetData( (oaStringAppDef_oaReticleRef**) ((PyoaStringAppDef_oaReticleRefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaReticleRef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaReticleRef_FromoaStringAppDef_oaReticleRef(oaStringAppDef_oaReticleRef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaReticleRef* data=*value;
        PyObject* bself = PyoaStringAppDef_oaReticleRef_Type.tp_alloc(&PyoaStringAppDef_oaReticleRef_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaReticleRefObject* self = (PyoaStringAppDef_oaReticleRefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaReticleRef_FromoaStringAppDef_oaReticleRef(oaStringAppDef_oaReticleRef* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaReticleRef_Type.tp_alloc(&PyoaStringAppDef_oaReticleRef_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaReticleRefObject* self = (PyoaStringAppDef_oaReticleRefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaReticleRef_get_doc[] = 
"Class: oaStringAppDef_oaReticleRef, Function: get\n"
"  Paramegers: (oaReticleRef,oaString)\n"
"    Calls: void get(const oaReticleRef* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaReticleRef,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaReticleRef_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaReticleRef data;
    int convert_status=PyoaStringAppDef_oaReticleRef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaReticleRefObject* self=(PyoaStringAppDef_oaReticleRefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaReticleRef p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaReticleRef_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaReticleRef_getDefault_doc[] = 
"Class: oaStringAppDef_oaReticleRef, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaReticleRef_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaReticleRef data;
    int convert_status=PyoaStringAppDef_oaReticleRef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaReticleRefObject* self=(PyoaStringAppDef_oaReticleRefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaReticleRef_set_doc[] = 
"Class: oaStringAppDef_oaReticleRef, Function: set\n"
"  Paramegers: (oaReticleRef,oaString)\n"
"    Calls: void set(oaReticleRef* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaReticleRef,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaReticleRef_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaReticleRef data;
    int convert_status=PyoaStringAppDef_oaReticleRef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaReticleRefObject* self=(PyoaStringAppDef_oaReticleRefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaReticleRef p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaReticleRef_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaReticleRef_isNull_doc[] =
"Class: oaStringAppDef_oaReticleRef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaReticleRef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaReticleRef data;
    int convert_status=PyoaStringAppDef_oaReticleRef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaReticleRef_assign_doc[] = 
"Class: oaStringAppDef_oaReticleRef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaReticleRef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaReticleRef data;
  int convert_status=PyoaStringAppDef_oaReticleRef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaReticleRef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaReticleRef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaReticleRef_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaReticleRef_get,METH_VARARGS,oaStringAppDef_oaReticleRef_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaReticleRef_getDefault,METH_VARARGS,oaStringAppDef_oaReticleRef_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaReticleRef_set,METH_VARARGS,oaStringAppDef_oaReticleRef_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaReticleRef_tp_isNull,METH_VARARGS,oaStringAppDef_oaReticleRef_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaReticleRef_tp_assign,METH_VARARGS,oaStringAppDef_oaReticleRef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaReticleRef_doc[] = 
"Class: oaStringAppDef_oaReticleRef\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaReticleRef)\n"
"    Calls: (const oaStringAppDef_oaReticleRef&)\n"
"    Signature: oaStringAppDef_oaReticleRef||cref-oaStringAppDef_oaReticleRef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaReticleRef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaReticleRef",
    sizeof(PyoaStringAppDef_oaReticleRefObject),
    0,
    (destructor)oaStringAppDef_oaReticleRef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaReticleRef_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaReticleRef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaReticleRef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaReticleRef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaReticleRef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaReticleRef_static_find_doc[] = 
"Class: oaStringAppDef_oaReticleRef, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaReticleRef* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaReticleRef|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaReticleRef* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaReticleRef|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaReticleRef_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaReticleRefp result= (oaStringAppDef_oaReticleRef::find(p1.Data()));
            return PyoaStringAppDef_oaReticleRef_FromoaStringAppDef_oaReticleRef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaReticleRefp result= (oaStringAppDef_oaReticleRef::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaReticleRef_FromoaStringAppDef_oaReticleRef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaReticleRef, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaReticleRef_static_get_doc[] = 
"Class: oaStringAppDef_oaReticleRef, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaReticleRef* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaReticleRef|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaReticleRef* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaReticleRef|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaReticleRef* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaReticleRef|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaReticleRef* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaReticleRef|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaReticleRef* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaReticleRef|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaReticleRef* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaReticleRef|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaReticleRef_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaReticleRefp result= (oaStringAppDef_oaReticleRef::get(p1.Data()));
            return PyoaStringAppDef_oaReticleRef_FromoaStringAppDef_oaReticleRef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaReticleRefp result= (oaStringAppDef_oaReticleRef::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaReticleRef_FromoaStringAppDef_oaReticleRef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaReticleRefp result= (oaStringAppDef_oaReticleRef::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaReticleRef_FromoaStringAppDef_oaReticleRef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaReticleRefp result= (oaStringAppDef_oaReticleRef::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaReticleRef_FromoaStringAppDef_oaReticleRef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaReticleRefp result= (oaStringAppDef_oaReticleRef::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaReticleRef_FromoaStringAppDef_oaReticleRef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaReticleRefp result= (oaStringAppDef_oaReticleRef::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaReticleRef_FromoaStringAppDef_oaReticleRef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaReticleRef, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaReticleRef_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaReticleRef_static_find,METH_VARARGS,oaStringAppDef_oaReticleRef_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaReticleRef_static_get,METH_VARARGS,oaStringAppDef_oaReticleRef_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaReticleRef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaReticleRef_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaReticleRef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaReticleRef",
           (PyObject*)(&PyoaStringAppDef_oaReticleRef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaReticleRef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaReticleRef_Type.tp_dict;
    for(method=oaStringAppDef_oaReticleRef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaRoute
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaRoute_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaRoute_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaRouteObject* self = (PyoaStringAppDef_oaRouteObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaRoute)
    {
        PyParamoaStringAppDef_oaRoute p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaRoute_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaRoute, Choices are:\n"
        "    (oaStringAppDef_oaRoute)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaRoute_tp_dealloc(PyoaStringAppDef_oaRouteObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaRoute_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaRoute value;
    int convert_status=PyoaStringAppDef_oaRoute_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[44];
    sprintf(buffer,"<oaStringAppDef_oaRoute::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaRoute_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaRoute v1;
    PyParamoaStringAppDef_oaRoute v2;
    int convert_status1=PyoaStringAppDef_oaRoute_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaRoute_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaRoute_Convert(PyObject* ob,PyParamoaStringAppDef_oaRoute* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaRoute_Check(ob)) {
        result->SetData( (oaStringAppDef_oaRoute**) ((PyoaStringAppDef_oaRouteObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaRoute Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaRoute_FromoaStringAppDef_oaRoute(oaStringAppDef_oaRoute** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaRoute* data=*value;
        PyObject* bself = PyoaStringAppDef_oaRoute_Type.tp_alloc(&PyoaStringAppDef_oaRoute_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaRouteObject* self = (PyoaStringAppDef_oaRouteObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaRoute_FromoaStringAppDef_oaRoute(oaStringAppDef_oaRoute* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaRoute_Type.tp_alloc(&PyoaStringAppDef_oaRoute_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaRouteObject* self = (PyoaStringAppDef_oaRouteObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaRoute_get_doc[] = 
"Class: oaStringAppDef_oaRoute, Function: get\n"
"  Paramegers: (oaRoute,oaString)\n"
"    Calls: void get(const oaRoute* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaRoute,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaRoute_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaRoute data;
    int convert_status=PyoaStringAppDef_oaRoute_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaRouteObject* self=(PyoaStringAppDef_oaRouteObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaRoute p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaRoute_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaRoute_getDefault_doc[] = 
"Class: oaStringAppDef_oaRoute, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaRoute_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaRoute data;
    int convert_status=PyoaStringAppDef_oaRoute_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaRouteObject* self=(PyoaStringAppDef_oaRouteObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaRoute_set_doc[] = 
"Class: oaStringAppDef_oaRoute, Function: set\n"
"  Paramegers: (oaRoute,oaString)\n"
"    Calls: void set(oaRoute* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaRoute,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaRoute_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaRoute data;
    int convert_status=PyoaStringAppDef_oaRoute_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaRouteObject* self=(PyoaStringAppDef_oaRouteObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaRoute p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaRoute_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaRoute_isNull_doc[] =
"Class: oaStringAppDef_oaRoute, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaRoute_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaRoute data;
    int convert_status=PyoaStringAppDef_oaRoute_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaRoute_assign_doc[] = 
"Class: oaStringAppDef_oaRoute, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaRoute_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaRoute data;
  int convert_status=PyoaStringAppDef_oaRoute_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaRoute p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaRoute_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaRoute_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaRoute_get,METH_VARARGS,oaStringAppDef_oaRoute_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaRoute_getDefault,METH_VARARGS,oaStringAppDef_oaRoute_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaRoute_set,METH_VARARGS,oaStringAppDef_oaRoute_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaRoute_tp_isNull,METH_VARARGS,oaStringAppDef_oaRoute_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaRoute_tp_assign,METH_VARARGS,oaStringAppDef_oaRoute_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaRoute_doc[] = 
"Class: oaStringAppDef_oaRoute\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaRoute)\n"
"    Calls: (const oaStringAppDef_oaRoute&)\n"
"    Signature: oaStringAppDef_oaRoute||cref-oaStringAppDef_oaRoute,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaRoute_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaRoute",
    sizeof(PyoaStringAppDef_oaRouteObject),
    0,
    (destructor)oaStringAppDef_oaRoute_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaRoute_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaRoute_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaRoute_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaRoute_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaRoute_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaRoute_static_find_doc[] = 
"Class: oaStringAppDef_oaRoute, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaRoute* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaRoute|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaRoute* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaRoute|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaRoute_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaRoutep result= (oaStringAppDef_oaRoute::find(p1.Data()));
            return PyoaStringAppDef_oaRoute_FromoaStringAppDef_oaRoute(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaRoutep result= (oaStringAppDef_oaRoute::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaRoute_FromoaStringAppDef_oaRoute(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaRoute, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaRoute_static_get_doc[] = 
"Class: oaStringAppDef_oaRoute, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaRoute* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaRoute|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaRoute* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaRoute|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaRoute* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaRoute|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaRoute* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaRoute|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaRoute* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaRoute|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaRoute* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaRoute|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaRoute_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaRoutep result= (oaStringAppDef_oaRoute::get(p1.Data()));
            return PyoaStringAppDef_oaRoute_FromoaStringAppDef_oaRoute(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaRoutep result= (oaStringAppDef_oaRoute::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaRoute_FromoaStringAppDef_oaRoute(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaRoutep result= (oaStringAppDef_oaRoute::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaRoute_FromoaStringAppDef_oaRoute(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaRoutep result= (oaStringAppDef_oaRoute::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaRoute_FromoaStringAppDef_oaRoute(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaRoutep result= (oaStringAppDef_oaRoute::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaRoute_FromoaStringAppDef_oaRoute(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaRoutep result= (oaStringAppDef_oaRoute::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaRoute_FromoaStringAppDef_oaRoute(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaRoute, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaRoute_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaRoute_static_find,METH_VARARGS,oaStringAppDef_oaRoute_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaRoute_static_get,METH_VARARGS,oaStringAppDef_oaRoute_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaRoute_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaRoute_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaRoute\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaRoute",
           (PyObject*)(&PyoaStringAppDef_oaRoute_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaRoute\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaRoute_Type.tp_dict;
    for(method=oaStringAppDef_oaRoute_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaRow
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaRow_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaRow_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaRowObject* self = (PyoaStringAppDef_oaRowObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaRow)
    {
        PyParamoaStringAppDef_oaRow p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaRow_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaRow, Choices are:\n"
        "    (oaStringAppDef_oaRow)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaRow_tp_dealloc(PyoaStringAppDef_oaRowObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaRow_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaRow value;
    int convert_status=PyoaStringAppDef_oaRow_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaStringAppDef_oaRow::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaRow_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaRow v1;
    PyParamoaStringAppDef_oaRow v2;
    int convert_status1=PyoaStringAppDef_oaRow_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaRow_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaRow_Convert(PyObject* ob,PyParamoaStringAppDef_oaRow* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaRow_Check(ob)) {
        result->SetData( (oaStringAppDef_oaRow**) ((PyoaStringAppDef_oaRowObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaRow Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaRow_FromoaStringAppDef_oaRow(oaStringAppDef_oaRow** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaRow* data=*value;
        PyObject* bself = PyoaStringAppDef_oaRow_Type.tp_alloc(&PyoaStringAppDef_oaRow_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaRowObject* self = (PyoaStringAppDef_oaRowObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaRow_FromoaStringAppDef_oaRow(oaStringAppDef_oaRow* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaRow_Type.tp_alloc(&PyoaStringAppDef_oaRow_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaRowObject* self = (PyoaStringAppDef_oaRowObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaRow_get_doc[] = 
"Class: oaStringAppDef_oaRow, Function: get\n"
"  Paramegers: (oaRow,oaString)\n"
"    Calls: void get(const oaRow* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaRow,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaRow_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaRow data;
    int convert_status=PyoaStringAppDef_oaRow_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaRowObject* self=(PyoaStringAppDef_oaRowObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaRow p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaRow_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaRow_getDefault_doc[] = 
"Class: oaStringAppDef_oaRow, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaRow_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaRow data;
    int convert_status=PyoaStringAppDef_oaRow_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaRowObject* self=(PyoaStringAppDef_oaRowObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaRow_set_doc[] = 
"Class: oaStringAppDef_oaRow, Function: set\n"
"  Paramegers: (oaRow,oaString)\n"
"    Calls: void set(oaRow* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaRow,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaRow_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaRow data;
    int convert_status=PyoaStringAppDef_oaRow_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaRowObject* self=(PyoaStringAppDef_oaRowObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaRow p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaRow_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaRow_isNull_doc[] =
"Class: oaStringAppDef_oaRow, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaRow_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaRow data;
    int convert_status=PyoaStringAppDef_oaRow_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaRow_assign_doc[] = 
"Class: oaStringAppDef_oaRow, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaRow_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaRow data;
  int convert_status=PyoaStringAppDef_oaRow_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaRow p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaRow_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaRow_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaRow_get,METH_VARARGS,oaStringAppDef_oaRow_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaRow_getDefault,METH_VARARGS,oaStringAppDef_oaRow_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaRow_set,METH_VARARGS,oaStringAppDef_oaRow_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaRow_tp_isNull,METH_VARARGS,oaStringAppDef_oaRow_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaRow_tp_assign,METH_VARARGS,oaStringAppDef_oaRow_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaRow_doc[] = 
"Class: oaStringAppDef_oaRow\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaRow)\n"
"    Calls: (const oaStringAppDef_oaRow&)\n"
"    Signature: oaStringAppDef_oaRow||cref-oaStringAppDef_oaRow,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaRow_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaRow",
    sizeof(PyoaStringAppDef_oaRowObject),
    0,
    (destructor)oaStringAppDef_oaRow_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaRow_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaRow_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaRow_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaRow_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaRow_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaRow_static_find_doc[] = 
"Class: oaStringAppDef_oaRow, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaRow* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaRow|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaRow* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaRow|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaRow_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaRowp result= (oaStringAppDef_oaRow::find(p1.Data()));
            return PyoaStringAppDef_oaRow_FromoaStringAppDef_oaRow(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaRowp result= (oaStringAppDef_oaRow::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaRow_FromoaStringAppDef_oaRow(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaRow, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaRow_static_get_doc[] = 
"Class: oaStringAppDef_oaRow, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaRow* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaRow|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaRow* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaRow|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaRow* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaRow|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaRow* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaRow|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaRow* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaRow|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaRow* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaRow|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaRow_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaRowp result= (oaStringAppDef_oaRow::get(p1.Data()));
            return PyoaStringAppDef_oaRow_FromoaStringAppDef_oaRow(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaRowp result= (oaStringAppDef_oaRow::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaRow_FromoaStringAppDef_oaRow(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaRowp result= (oaStringAppDef_oaRow::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaRow_FromoaStringAppDef_oaRow(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaRowp result= (oaStringAppDef_oaRow::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaRow_FromoaStringAppDef_oaRow(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaRowp result= (oaStringAppDef_oaRow::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaRow_FromoaStringAppDef_oaRow(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaRowp result= (oaStringAppDef_oaRow::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaRow_FromoaStringAppDef_oaRow(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaRow, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaRow_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaRow_static_find,METH_VARARGS,oaStringAppDef_oaRow_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaRow_static_get,METH_VARARGS,oaStringAppDef_oaRow_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaRow_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaRow_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaRow\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaRow",
           (PyObject*)(&PyoaStringAppDef_oaRow_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaRow\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaRow_Type.tp_dict;
    for(method=oaStringAppDef_oaRow_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaRowHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaRowHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaRowHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaRowHeaderObject* self = (PyoaStringAppDef_oaRowHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaRowHeader)
    {
        PyParamoaStringAppDef_oaRowHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaRowHeader_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaRowHeader, Choices are:\n"
        "    (oaStringAppDef_oaRowHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaRowHeader_tp_dealloc(PyoaStringAppDef_oaRowHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaRowHeader_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaRowHeader value;
    int convert_status=PyoaStringAppDef_oaRowHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[48];
    sprintf(buffer,"<oaStringAppDef_oaRowHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaRowHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaRowHeader v1;
    PyParamoaStringAppDef_oaRowHeader v2;
    int convert_status1=PyoaStringAppDef_oaRowHeader_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaRowHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaRowHeader_Convert(PyObject* ob,PyParamoaStringAppDef_oaRowHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaRowHeader_Check(ob)) {
        result->SetData( (oaStringAppDef_oaRowHeader**) ((PyoaStringAppDef_oaRowHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaRowHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaRowHeader_FromoaStringAppDef_oaRowHeader(oaStringAppDef_oaRowHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaRowHeader* data=*value;
        PyObject* bself = PyoaStringAppDef_oaRowHeader_Type.tp_alloc(&PyoaStringAppDef_oaRowHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaRowHeaderObject* self = (PyoaStringAppDef_oaRowHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaRowHeader_FromoaStringAppDef_oaRowHeader(oaStringAppDef_oaRowHeader* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaRowHeader_Type.tp_alloc(&PyoaStringAppDef_oaRowHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaRowHeaderObject* self = (PyoaStringAppDef_oaRowHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaRowHeader_get_doc[] = 
"Class: oaStringAppDef_oaRowHeader, Function: get\n"
"  Paramegers: (oaRowHeader,oaString)\n"
"    Calls: void get(const oaRowHeader* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaRowHeader,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaRowHeader_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaRowHeader data;
    int convert_status=PyoaStringAppDef_oaRowHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaRowHeaderObject* self=(PyoaStringAppDef_oaRowHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaRowHeader p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaRowHeader_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaRowHeader_getDefault_doc[] = 
"Class: oaStringAppDef_oaRowHeader, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaRowHeader_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaRowHeader data;
    int convert_status=PyoaStringAppDef_oaRowHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaRowHeaderObject* self=(PyoaStringAppDef_oaRowHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaRowHeader_set_doc[] = 
"Class: oaStringAppDef_oaRowHeader, Function: set\n"
"  Paramegers: (oaRowHeader,oaString)\n"
"    Calls: void set(oaRowHeader* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaRowHeader,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaRowHeader_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaRowHeader data;
    int convert_status=PyoaStringAppDef_oaRowHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaRowHeaderObject* self=(PyoaStringAppDef_oaRowHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaRowHeader p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaRowHeader_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaRowHeader_isNull_doc[] =
"Class: oaStringAppDef_oaRowHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaRowHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaRowHeader data;
    int convert_status=PyoaStringAppDef_oaRowHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaRowHeader_assign_doc[] = 
"Class: oaStringAppDef_oaRowHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaRowHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaRowHeader data;
  int convert_status=PyoaStringAppDef_oaRowHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaRowHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaRowHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaRowHeader_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaRowHeader_get,METH_VARARGS,oaStringAppDef_oaRowHeader_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaRowHeader_getDefault,METH_VARARGS,oaStringAppDef_oaRowHeader_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaRowHeader_set,METH_VARARGS,oaStringAppDef_oaRowHeader_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaRowHeader_tp_isNull,METH_VARARGS,oaStringAppDef_oaRowHeader_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaRowHeader_tp_assign,METH_VARARGS,oaStringAppDef_oaRowHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaRowHeader_doc[] = 
"Class: oaStringAppDef_oaRowHeader\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaRowHeader)\n"
"    Calls: (const oaStringAppDef_oaRowHeader&)\n"
"    Signature: oaStringAppDef_oaRowHeader||cref-oaStringAppDef_oaRowHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaRowHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaRowHeader",
    sizeof(PyoaStringAppDef_oaRowHeaderObject),
    0,
    (destructor)oaStringAppDef_oaRowHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaRowHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaRowHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaRowHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaRowHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaRowHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaRowHeader_static_find_doc[] = 
"Class: oaStringAppDef_oaRowHeader, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaRowHeader* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaRowHeader|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaRowHeader* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaRowHeader|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaRowHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaRowHeaderp result= (oaStringAppDef_oaRowHeader::find(p1.Data()));
            return PyoaStringAppDef_oaRowHeader_FromoaStringAppDef_oaRowHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaRowHeaderp result= (oaStringAppDef_oaRowHeader::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaRowHeader_FromoaStringAppDef_oaRowHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaRowHeader, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaRowHeader_static_get_doc[] = 
"Class: oaStringAppDef_oaRowHeader, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaRowHeader* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaRowHeader|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaRowHeader* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaRowHeader|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaRowHeader* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaRowHeader|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaRowHeader* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaRowHeader|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaRowHeader* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaRowHeader|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaRowHeader* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaRowHeader|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaRowHeader_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaRowHeaderp result= (oaStringAppDef_oaRowHeader::get(p1.Data()));
            return PyoaStringAppDef_oaRowHeader_FromoaStringAppDef_oaRowHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaRowHeaderp result= (oaStringAppDef_oaRowHeader::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaRowHeader_FromoaStringAppDef_oaRowHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaRowHeaderp result= (oaStringAppDef_oaRowHeader::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaRowHeader_FromoaStringAppDef_oaRowHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaRowHeaderp result= (oaStringAppDef_oaRowHeader::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaRowHeader_FromoaStringAppDef_oaRowHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaRowHeaderp result= (oaStringAppDef_oaRowHeader::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaRowHeader_FromoaStringAppDef_oaRowHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaRowHeaderp result= (oaStringAppDef_oaRowHeader::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaRowHeader_FromoaStringAppDef_oaRowHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaRowHeader, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaRowHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaRowHeader_static_find,METH_VARARGS,oaStringAppDef_oaRowHeader_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaRowHeader_static_get,METH_VARARGS,oaStringAppDef_oaRowHeader_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaRowHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaRowHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaRowHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaRowHeader",
           (PyObject*)(&PyoaStringAppDef_oaRowHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaRowHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaRowHeader_Type.tp_dict;
    for(method=oaStringAppDef_oaRowHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaScanChain
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaScanChain_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaScanChain_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaScanChainObject* self = (PyoaStringAppDef_oaScanChainObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaScanChain)
    {
        PyParamoaStringAppDef_oaScanChain p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaScanChain_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaScanChain, Choices are:\n"
        "    (oaStringAppDef_oaScanChain)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaScanChain_tp_dealloc(PyoaStringAppDef_oaScanChainObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaScanChain_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaScanChain value;
    int convert_status=PyoaStringAppDef_oaScanChain_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[48];
    sprintf(buffer,"<oaStringAppDef_oaScanChain::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaScanChain_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaScanChain v1;
    PyParamoaStringAppDef_oaScanChain v2;
    int convert_status1=PyoaStringAppDef_oaScanChain_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaScanChain_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaScanChain_Convert(PyObject* ob,PyParamoaStringAppDef_oaScanChain* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaScanChain_Check(ob)) {
        result->SetData( (oaStringAppDef_oaScanChain**) ((PyoaStringAppDef_oaScanChainObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaScanChain Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaScanChain_FromoaStringAppDef_oaScanChain(oaStringAppDef_oaScanChain** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaScanChain* data=*value;
        PyObject* bself = PyoaStringAppDef_oaScanChain_Type.tp_alloc(&PyoaStringAppDef_oaScanChain_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaScanChainObject* self = (PyoaStringAppDef_oaScanChainObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaScanChain_FromoaStringAppDef_oaScanChain(oaStringAppDef_oaScanChain* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaScanChain_Type.tp_alloc(&PyoaStringAppDef_oaScanChain_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaScanChainObject* self = (PyoaStringAppDef_oaScanChainObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaScanChain_get_doc[] = 
"Class: oaStringAppDef_oaScanChain, Function: get\n"
"  Paramegers: (oaScanChain,oaString)\n"
"    Calls: void get(const oaScanChain* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaScanChain,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaScanChain_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaScanChain data;
    int convert_status=PyoaStringAppDef_oaScanChain_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaScanChainObject* self=(PyoaStringAppDef_oaScanChainObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScanChain p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaScanChain_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaScanChain_getDefault_doc[] = 
"Class: oaStringAppDef_oaScanChain, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaScanChain_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaScanChain data;
    int convert_status=PyoaStringAppDef_oaScanChain_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaScanChainObject* self=(PyoaStringAppDef_oaScanChainObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaScanChain_set_doc[] = 
"Class: oaStringAppDef_oaScanChain, Function: set\n"
"  Paramegers: (oaScanChain,oaString)\n"
"    Calls: void set(oaScanChain* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaScanChain,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaScanChain_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaScanChain data;
    int convert_status=PyoaStringAppDef_oaScanChain_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaScanChainObject* self=(PyoaStringAppDef_oaScanChainObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScanChain p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaScanChain_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaScanChain_isNull_doc[] =
"Class: oaStringAppDef_oaScanChain, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaScanChain_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaScanChain data;
    int convert_status=PyoaStringAppDef_oaScanChain_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaScanChain_assign_doc[] = 
"Class: oaStringAppDef_oaScanChain, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaScanChain_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaScanChain data;
  int convert_status=PyoaStringAppDef_oaScanChain_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaScanChain p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaScanChain_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaScanChain_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaScanChain_get,METH_VARARGS,oaStringAppDef_oaScanChain_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaScanChain_getDefault,METH_VARARGS,oaStringAppDef_oaScanChain_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaScanChain_set,METH_VARARGS,oaStringAppDef_oaScanChain_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaScanChain_tp_isNull,METH_VARARGS,oaStringAppDef_oaScanChain_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaScanChain_tp_assign,METH_VARARGS,oaStringAppDef_oaScanChain_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaScanChain_doc[] = 
"Class: oaStringAppDef_oaScanChain\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaScanChain)\n"
"    Calls: (const oaStringAppDef_oaScanChain&)\n"
"    Signature: oaStringAppDef_oaScanChain||cref-oaStringAppDef_oaScanChain,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaScanChain_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaScanChain",
    sizeof(PyoaStringAppDef_oaScanChainObject),
    0,
    (destructor)oaStringAppDef_oaScanChain_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaScanChain_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaScanChain_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaScanChain_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaScanChain_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaScanChain_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaScanChain_static_find_doc[] = 
"Class: oaStringAppDef_oaScanChain, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaScanChain* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaScanChain|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaScanChain* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaScanChain|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaScanChain_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaScanChainp result= (oaStringAppDef_oaScanChain::find(p1.Data()));
            return PyoaStringAppDef_oaScanChain_FromoaStringAppDef_oaScanChain(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaScanChainp result= (oaStringAppDef_oaScanChain::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaScanChain_FromoaStringAppDef_oaScanChain(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaScanChain, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaScanChain_static_get_doc[] = 
"Class: oaStringAppDef_oaScanChain, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaScanChain* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaScanChain|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaScanChain* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaScanChain|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaScanChain* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaScanChain|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaScanChain* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaScanChain|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaScanChain* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaScanChain|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaScanChain* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaScanChain|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaScanChain_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaScanChainp result= (oaStringAppDef_oaScanChain::get(p1.Data()));
            return PyoaStringAppDef_oaScanChain_FromoaStringAppDef_oaScanChain(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaScanChainp result= (oaStringAppDef_oaScanChain::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaScanChain_FromoaStringAppDef_oaScanChain(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaScanChainp result= (oaStringAppDef_oaScanChain::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaScanChain_FromoaStringAppDef_oaScanChain(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaScanChainp result= (oaStringAppDef_oaScanChain::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaScanChain_FromoaStringAppDef_oaScanChain(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaScanChainp result= (oaStringAppDef_oaScanChain::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaScanChain_FromoaStringAppDef_oaScanChain(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaScanChainp result= (oaStringAppDef_oaScanChain::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaScanChain_FromoaStringAppDef_oaScanChain(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaScanChain, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaScanChain_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaScanChain_static_find,METH_VARARGS,oaStringAppDef_oaScanChain_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaScanChain_static_get,METH_VARARGS,oaStringAppDef_oaScanChain_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaScanChain_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaScanChain_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaScanChain\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaScanChain",
           (PyObject*)(&PyoaStringAppDef_oaScanChain_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaScanChain\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaScanChain_Type.tp_dict;
    for(method=oaStringAppDef_oaScanChain_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaScanChainInst
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaScanChainInst_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaScanChainInst_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaScanChainInstObject* self = (PyoaStringAppDef_oaScanChainInstObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaScanChainInst)
    {
        PyParamoaStringAppDef_oaScanChainInst p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaScanChainInst_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaScanChainInst, Choices are:\n"
        "    (oaStringAppDef_oaScanChainInst)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaScanChainInst_tp_dealloc(PyoaStringAppDef_oaScanChainInstObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaScanChainInst_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaScanChainInst value;
    int convert_status=PyoaStringAppDef_oaScanChainInst_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[52];
    sprintf(buffer,"<oaStringAppDef_oaScanChainInst::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaScanChainInst_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaScanChainInst v1;
    PyParamoaStringAppDef_oaScanChainInst v2;
    int convert_status1=PyoaStringAppDef_oaScanChainInst_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaScanChainInst_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaScanChainInst_Convert(PyObject* ob,PyParamoaStringAppDef_oaScanChainInst* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaScanChainInst_Check(ob)) {
        result->SetData( (oaStringAppDef_oaScanChainInst**) ((PyoaStringAppDef_oaScanChainInstObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaScanChainInst Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaScanChainInst_FromoaStringAppDef_oaScanChainInst(oaStringAppDef_oaScanChainInst** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaScanChainInst* data=*value;
        PyObject* bself = PyoaStringAppDef_oaScanChainInst_Type.tp_alloc(&PyoaStringAppDef_oaScanChainInst_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaScanChainInstObject* self = (PyoaStringAppDef_oaScanChainInstObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaScanChainInst_FromoaStringAppDef_oaScanChainInst(oaStringAppDef_oaScanChainInst* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaScanChainInst_Type.tp_alloc(&PyoaStringAppDef_oaScanChainInst_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaScanChainInstObject* self = (PyoaStringAppDef_oaScanChainInstObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaScanChainInst_get_doc[] = 
"Class: oaStringAppDef_oaScanChainInst, Function: get\n"
"  Paramegers: (oaScanChainInst,oaString)\n"
"    Calls: void get(const oaScanChainInst* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaScanChainInst,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaScanChainInst_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaScanChainInst data;
    int convert_status=PyoaStringAppDef_oaScanChainInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaScanChainInstObject* self=(PyoaStringAppDef_oaScanChainInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScanChainInst p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaScanChainInst_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaScanChainInst_getDefault_doc[] = 
"Class: oaStringAppDef_oaScanChainInst, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaScanChainInst_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaScanChainInst data;
    int convert_status=PyoaStringAppDef_oaScanChainInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaScanChainInstObject* self=(PyoaStringAppDef_oaScanChainInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaScanChainInst_set_doc[] = 
"Class: oaStringAppDef_oaScanChainInst, Function: set\n"
"  Paramegers: (oaScanChainInst,oaString)\n"
"    Calls: void set(oaScanChainInst* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaScanChainInst,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaScanChainInst_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaScanChainInst data;
    int convert_status=PyoaStringAppDef_oaScanChainInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaScanChainInstObject* self=(PyoaStringAppDef_oaScanChainInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScanChainInst p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaScanChainInst_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaScanChainInst_isNull_doc[] =
"Class: oaStringAppDef_oaScanChainInst, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaScanChainInst_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaScanChainInst data;
    int convert_status=PyoaStringAppDef_oaScanChainInst_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaScanChainInst_assign_doc[] = 
"Class: oaStringAppDef_oaScanChainInst, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaScanChainInst_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaScanChainInst data;
  int convert_status=PyoaStringAppDef_oaScanChainInst_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaScanChainInst p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaScanChainInst_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaScanChainInst_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaScanChainInst_get,METH_VARARGS,oaStringAppDef_oaScanChainInst_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaScanChainInst_getDefault,METH_VARARGS,oaStringAppDef_oaScanChainInst_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaScanChainInst_set,METH_VARARGS,oaStringAppDef_oaScanChainInst_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaScanChainInst_tp_isNull,METH_VARARGS,oaStringAppDef_oaScanChainInst_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaScanChainInst_tp_assign,METH_VARARGS,oaStringAppDef_oaScanChainInst_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaScanChainInst_doc[] = 
"Class: oaStringAppDef_oaScanChainInst\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaScanChainInst)\n"
"    Calls: (const oaStringAppDef_oaScanChainInst&)\n"
"    Signature: oaStringAppDef_oaScanChainInst||cref-oaStringAppDef_oaScanChainInst,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaScanChainInst_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaScanChainInst",
    sizeof(PyoaStringAppDef_oaScanChainInstObject),
    0,
    (destructor)oaStringAppDef_oaScanChainInst_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaScanChainInst_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaScanChainInst_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaScanChainInst_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaScanChainInst_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaScanChainInst_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaScanChainInst_static_find_doc[] = 
"Class: oaStringAppDef_oaScanChainInst, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaScanChainInst* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaScanChainInst|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaScanChainInst* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaScanChainInst|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaScanChainInst_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaScanChainInstp result= (oaStringAppDef_oaScanChainInst::find(p1.Data()));
            return PyoaStringAppDef_oaScanChainInst_FromoaStringAppDef_oaScanChainInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaScanChainInstp result= (oaStringAppDef_oaScanChainInst::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaScanChainInst_FromoaStringAppDef_oaScanChainInst(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaScanChainInst, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaScanChainInst_static_get_doc[] = 
"Class: oaStringAppDef_oaScanChainInst, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaScanChainInst* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaScanChainInst|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaScanChainInst* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaScanChainInst|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaScanChainInst* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaScanChainInst|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaScanChainInst* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaScanChainInst|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaScanChainInst* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaScanChainInst|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaScanChainInst* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaScanChainInst|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaScanChainInst_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaScanChainInstp result= (oaStringAppDef_oaScanChainInst::get(p1.Data()));
            return PyoaStringAppDef_oaScanChainInst_FromoaStringAppDef_oaScanChainInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaScanChainInstp result= (oaStringAppDef_oaScanChainInst::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaScanChainInst_FromoaStringAppDef_oaScanChainInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaScanChainInstp result= (oaStringAppDef_oaScanChainInst::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaScanChainInst_FromoaStringAppDef_oaScanChainInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaScanChainInstp result= (oaStringAppDef_oaScanChainInst::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaScanChainInst_FromoaStringAppDef_oaScanChainInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaScanChainInstp result= (oaStringAppDef_oaScanChainInst::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaScanChainInst_FromoaStringAppDef_oaScanChainInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaScanChainInstp result= (oaStringAppDef_oaScanChainInst::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaScanChainInst_FromoaStringAppDef_oaScanChainInst(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaScanChainInst, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaScanChainInst_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaScanChainInst_static_find,METH_VARARGS,oaStringAppDef_oaScanChainInst_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaScanChainInst_static_get,METH_VARARGS,oaStringAppDef_oaScanChainInst_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaScanChainInst_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaScanChainInst_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaScanChainInst\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaScanChainInst",
           (PyObject*)(&PyoaStringAppDef_oaScanChainInst_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaScanChainInst\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaScanChainInst_Type.tp_dict;
    for(method=oaStringAppDef_oaScanChainInst_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaScanChainSet
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaScanChainSet_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaScanChainSet_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaScanChainSetObject* self = (PyoaStringAppDef_oaScanChainSetObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaScanChainSet)
    {
        PyParamoaStringAppDef_oaScanChainSet p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaScanChainSet_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaScanChainSet, Choices are:\n"
        "    (oaStringAppDef_oaScanChainSet)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaScanChainSet_tp_dealloc(PyoaStringAppDef_oaScanChainSetObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaScanChainSet_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaScanChainSet value;
    int convert_status=PyoaStringAppDef_oaScanChainSet_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[51];
    sprintf(buffer,"<oaStringAppDef_oaScanChainSet::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaScanChainSet_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaScanChainSet v1;
    PyParamoaStringAppDef_oaScanChainSet v2;
    int convert_status1=PyoaStringAppDef_oaScanChainSet_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaScanChainSet_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaScanChainSet_Convert(PyObject* ob,PyParamoaStringAppDef_oaScanChainSet* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaScanChainSet_Check(ob)) {
        result->SetData( (oaStringAppDef_oaScanChainSet**) ((PyoaStringAppDef_oaScanChainSetObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaScanChainSet Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaScanChainSet_FromoaStringAppDef_oaScanChainSet(oaStringAppDef_oaScanChainSet** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaScanChainSet* data=*value;
        PyObject* bself = PyoaStringAppDef_oaScanChainSet_Type.tp_alloc(&PyoaStringAppDef_oaScanChainSet_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaScanChainSetObject* self = (PyoaStringAppDef_oaScanChainSetObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaScanChainSet_FromoaStringAppDef_oaScanChainSet(oaStringAppDef_oaScanChainSet* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaScanChainSet_Type.tp_alloc(&PyoaStringAppDef_oaScanChainSet_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaScanChainSetObject* self = (PyoaStringAppDef_oaScanChainSetObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaScanChainSet_get_doc[] = 
"Class: oaStringAppDef_oaScanChainSet, Function: get\n"
"  Paramegers: (oaScanChainSet,oaString)\n"
"    Calls: void get(const oaScanChainSet* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaScanChainSet,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaScanChainSet_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaScanChainSet data;
    int convert_status=PyoaStringAppDef_oaScanChainSet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaScanChainSetObject* self=(PyoaStringAppDef_oaScanChainSetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScanChainSet p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaScanChainSet_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaScanChainSet_getDefault_doc[] = 
"Class: oaStringAppDef_oaScanChainSet, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaScanChainSet_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaScanChainSet data;
    int convert_status=PyoaStringAppDef_oaScanChainSet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaScanChainSetObject* self=(PyoaStringAppDef_oaScanChainSetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaScanChainSet_set_doc[] = 
"Class: oaStringAppDef_oaScanChainSet, Function: set\n"
"  Paramegers: (oaScanChainSet,oaString)\n"
"    Calls: void set(oaScanChainSet* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaScanChainSet,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaScanChainSet_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaScanChainSet data;
    int convert_status=PyoaStringAppDef_oaScanChainSet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaScanChainSetObject* self=(PyoaStringAppDef_oaScanChainSetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScanChainSet p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaScanChainSet_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaScanChainSet_isNull_doc[] =
"Class: oaStringAppDef_oaScanChainSet, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaScanChainSet_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaScanChainSet data;
    int convert_status=PyoaStringAppDef_oaScanChainSet_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaScanChainSet_assign_doc[] = 
"Class: oaStringAppDef_oaScanChainSet, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaScanChainSet_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaScanChainSet data;
  int convert_status=PyoaStringAppDef_oaScanChainSet_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaScanChainSet p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaScanChainSet_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaScanChainSet_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaScanChainSet_get,METH_VARARGS,oaStringAppDef_oaScanChainSet_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaScanChainSet_getDefault,METH_VARARGS,oaStringAppDef_oaScanChainSet_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaScanChainSet_set,METH_VARARGS,oaStringAppDef_oaScanChainSet_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaScanChainSet_tp_isNull,METH_VARARGS,oaStringAppDef_oaScanChainSet_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaScanChainSet_tp_assign,METH_VARARGS,oaStringAppDef_oaScanChainSet_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaScanChainSet_doc[] = 
"Class: oaStringAppDef_oaScanChainSet\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaScanChainSet)\n"
"    Calls: (const oaStringAppDef_oaScanChainSet&)\n"
"    Signature: oaStringAppDef_oaScanChainSet||cref-oaStringAppDef_oaScanChainSet,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaScanChainSet_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaScanChainSet",
    sizeof(PyoaStringAppDef_oaScanChainSetObject),
    0,
    (destructor)oaStringAppDef_oaScanChainSet_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaScanChainSet_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaScanChainSet_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaScanChainSet_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaScanChainSet_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaScanChainSet_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaScanChainSet_static_find_doc[] = 
"Class: oaStringAppDef_oaScanChainSet, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaScanChainSet* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaScanChainSet|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaScanChainSet* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaScanChainSet|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaScanChainSet_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaScanChainSetp result= (oaStringAppDef_oaScanChainSet::find(p1.Data()));
            return PyoaStringAppDef_oaScanChainSet_FromoaStringAppDef_oaScanChainSet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaScanChainSetp result= (oaStringAppDef_oaScanChainSet::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaScanChainSet_FromoaStringAppDef_oaScanChainSet(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaScanChainSet, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaScanChainSet_static_get_doc[] = 
"Class: oaStringAppDef_oaScanChainSet, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaScanChainSet* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaScanChainSet|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaScanChainSet* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaScanChainSet|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaScanChainSet* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaScanChainSet|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaScanChainSet* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaScanChainSet|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaScanChainSet* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaScanChainSet|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaScanChainSet* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaScanChainSet|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaScanChainSet_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaScanChainSetp result= (oaStringAppDef_oaScanChainSet::get(p1.Data()));
            return PyoaStringAppDef_oaScanChainSet_FromoaStringAppDef_oaScanChainSet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaScanChainSetp result= (oaStringAppDef_oaScanChainSet::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaScanChainSet_FromoaStringAppDef_oaScanChainSet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaScanChainSetp result= (oaStringAppDef_oaScanChainSet::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaScanChainSet_FromoaStringAppDef_oaScanChainSet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaScanChainSetp result= (oaStringAppDef_oaScanChainSet::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaScanChainSet_FromoaStringAppDef_oaScanChainSet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaScanChainSetp result= (oaStringAppDef_oaScanChainSet::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaScanChainSet_FromoaStringAppDef_oaScanChainSet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaScanChainSetp result= (oaStringAppDef_oaScanChainSet::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaScanChainSet_FromoaStringAppDef_oaScanChainSet(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaScanChainSet, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaScanChainSet_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaScanChainSet_static_find,METH_VARARGS,oaStringAppDef_oaScanChainSet_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaScanChainSet_static_get,METH_VARARGS,oaStringAppDef_oaScanChainSet_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaScanChainSet_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaScanChainSet_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaScanChainSet\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaScanChainSet",
           (PyObject*)(&PyoaStringAppDef_oaScanChainSet_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaScanChainSet\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaScanChainSet_Type.tp_dict;
    for(method=oaStringAppDef_oaScanChainSet_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaShape
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaShape_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaShape_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaShapeObject* self = (PyoaStringAppDef_oaShapeObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaShape)
    {
        PyParamoaStringAppDef_oaShape p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaShape_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaShape, Choices are:\n"
        "    (oaStringAppDef_oaShape)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaShape_tp_dealloc(PyoaStringAppDef_oaShapeObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaShape_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaShape value;
    int convert_status=PyoaStringAppDef_oaShape_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[44];
    sprintf(buffer,"<oaStringAppDef_oaShape::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaShape_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaShape v1;
    PyParamoaStringAppDef_oaShape v2;
    int convert_status1=PyoaStringAppDef_oaShape_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaShape_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaShape_Convert(PyObject* ob,PyParamoaStringAppDef_oaShape* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaShape_Check(ob)) {
        result->SetData( (oaStringAppDef_oaShape**) ((PyoaStringAppDef_oaShapeObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaShape Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaShape_FromoaStringAppDef_oaShape(oaStringAppDef_oaShape** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaShape* data=*value;
        PyObject* bself = PyoaStringAppDef_oaShape_Type.tp_alloc(&PyoaStringAppDef_oaShape_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaShapeObject* self = (PyoaStringAppDef_oaShapeObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaShape_FromoaStringAppDef_oaShape(oaStringAppDef_oaShape* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaShape_Type.tp_alloc(&PyoaStringAppDef_oaShape_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaShapeObject* self = (PyoaStringAppDef_oaShapeObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaShape_get_doc[] = 
"Class: oaStringAppDef_oaShape, Function: get\n"
"  Paramegers: (oaShape,oaString)\n"
"    Calls: void get(const oaShape* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaShape,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaShape_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaShape data;
    int convert_status=PyoaStringAppDef_oaShape_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaShapeObject* self=(PyoaStringAppDef_oaShapeObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaShape p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaShape_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaShape_getDefault_doc[] = 
"Class: oaStringAppDef_oaShape, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaShape_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaShape data;
    int convert_status=PyoaStringAppDef_oaShape_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaShapeObject* self=(PyoaStringAppDef_oaShapeObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaShape_set_doc[] = 
"Class: oaStringAppDef_oaShape, Function: set\n"
"  Paramegers: (oaShape,oaString)\n"
"    Calls: void set(oaShape* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaShape,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaShape_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaShape data;
    int convert_status=PyoaStringAppDef_oaShape_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaShapeObject* self=(PyoaStringAppDef_oaShapeObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaShape p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaShape_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaShape_isNull_doc[] =
"Class: oaStringAppDef_oaShape, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaShape_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaShape data;
    int convert_status=PyoaStringAppDef_oaShape_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaShape_assign_doc[] = 
"Class: oaStringAppDef_oaShape, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaShape_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaShape data;
  int convert_status=PyoaStringAppDef_oaShape_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaShape p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaShape_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaShape_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaShape_get,METH_VARARGS,oaStringAppDef_oaShape_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaShape_getDefault,METH_VARARGS,oaStringAppDef_oaShape_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaShape_set,METH_VARARGS,oaStringAppDef_oaShape_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaShape_tp_isNull,METH_VARARGS,oaStringAppDef_oaShape_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaShape_tp_assign,METH_VARARGS,oaStringAppDef_oaShape_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaShape_doc[] = 
"Class: oaStringAppDef_oaShape\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaShape)\n"
"    Calls: (const oaStringAppDef_oaShape&)\n"
"    Signature: oaStringAppDef_oaShape||cref-oaStringAppDef_oaShape,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaShape_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaShape",
    sizeof(PyoaStringAppDef_oaShapeObject),
    0,
    (destructor)oaStringAppDef_oaShape_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaShape_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaShape_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaShape_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaShape_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaShape_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaShape_static_find_doc[] = 
"Class: oaStringAppDef_oaShape, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaShape* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaShape|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaShape* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaShape|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaShape_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaShapep result= (oaStringAppDef_oaShape::find(p1.Data()));
            return PyoaStringAppDef_oaShape_FromoaStringAppDef_oaShape(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaShapep result= (oaStringAppDef_oaShape::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaShape_FromoaStringAppDef_oaShape(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaShape, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaShape_static_get_doc[] = 
"Class: oaStringAppDef_oaShape, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaShape* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaShape|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaShape* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaShape|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaShape* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaShape|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaShape* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaShape|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaShape* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaShape|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaShape* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaShape|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaShape_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaShapep result= (oaStringAppDef_oaShape::get(p1.Data()));
            return PyoaStringAppDef_oaShape_FromoaStringAppDef_oaShape(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaShapep result= (oaStringAppDef_oaShape::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaShape_FromoaStringAppDef_oaShape(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaShapep result= (oaStringAppDef_oaShape::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaShape_FromoaStringAppDef_oaShape(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaShapep result= (oaStringAppDef_oaShape::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaShape_FromoaStringAppDef_oaShape(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaShapep result= (oaStringAppDef_oaShape::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaShape_FromoaStringAppDef_oaShape(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaShapep result= (oaStringAppDef_oaShape::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaShape_FromoaStringAppDef_oaShape(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaShape, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaShape_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaShape_static_find,METH_VARARGS,oaStringAppDef_oaShape_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaShape_static_get,METH_VARARGS,oaStringAppDef_oaShape_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaShape_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaShape_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaShape\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaShape",
           (PyObject*)(&PyoaStringAppDef_oaShape_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaShape\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaShape_Type.tp_dict;
    for(method=oaStringAppDef_oaShape_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaSiteDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaSiteDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaSiteDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaSiteDefObject* self = (PyoaStringAppDef_oaSiteDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaSiteDef)
    {
        PyParamoaStringAppDef_oaSiteDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaSiteDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaSiteDef, Choices are:\n"
        "    (oaStringAppDef_oaSiteDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaSiteDef_tp_dealloc(PyoaStringAppDef_oaSiteDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaSiteDef_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaSiteDef value;
    int convert_status=PyoaStringAppDef_oaSiteDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[46];
    sprintf(buffer,"<oaStringAppDef_oaSiteDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaSiteDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaSiteDef v1;
    PyParamoaStringAppDef_oaSiteDef v2;
    int convert_status1=PyoaStringAppDef_oaSiteDef_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaSiteDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaSiteDef_Convert(PyObject* ob,PyParamoaStringAppDef_oaSiteDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaSiteDef_Check(ob)) {
        result->SetData( (oaStringAppDef_oaSiteDef**) ((PyoaStringAppDef_oaSiteDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaSiteDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaSiteDef_FromoaStringAppDef_oaSiteDef(oaStringAppDef_oaSiteDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaSiteDef* data=*value;
        PyObject* bself = PyoaStringAppDef_oaSiteDef_Type.tp_alloc(&PyoaStringAppDef_oaSiteDef_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaSiteDefObject* self = (PyoaStringAppDef_oaSiteDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaSiteDef_FromoaStringAppDef_oaSiteDef(oaStringAppDef_oaSiteDef* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaSiteDef_Type.tp_alloc(&PyoaStringAppDef_oaSiteDef_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaSiteDefObject* self = (PyoaStringAppDef_oaSiteDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaSiteDef_get_doc[] = 
"Class: oaStringAppDef_oaSiteDef, Function: get\n"
"  Paramegers: (oaSiteDef,oaString)\n"
"    Calls: void get(const oaSiteDef* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaSiteDef,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaSiteDef_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaSiteDef data;
    int convert_status=PyoaStringAppDef_oaSiteDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaSiteDefObject* self=(PyoaStringAppDef_oaSiteDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaSiteDef p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaSiteDef_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaSiteDef_getDefault_doc[] = 
"Class: oaStringAppDef_oaSiteDef, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaSiteDef_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaSiteDef data;
    int convert_status=PyoaStringAppDef_oaSiteDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaSiteDefObject* self=(PyoaStringAppDef_oaSiteDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaSiteDef_set_doc[] = 
"Class: oaStringAppDef_oaSiteDef, Function: set\n"
"  Paramegers: (oaSiteDef,oaString)\n"
"    Calls: void set(oaSiteDef* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaSiteDef,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaSiteDef_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaSiteDef data;
    int convert_status=PyoaStringAppDef_oaSiteDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaSiteDefObject* self=(PyoaStringAppDef_oaSiteDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaSiteDef p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaSiteDef_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaSiteDef_isNull_doc[] =
"Class: oaStringAppDef_oaSiteDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaSiteDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaSiteDef data;
    int convert_status=PyoaStringAppDef_oaSiteDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaSiteDef_assign_doc[] = 
"Class: oaStringAppDef_oaSiteDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaSiteDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaSiteDef data;
  int convert_status=PyoaStringAppDef_oaSiteDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaSiteDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaSiteDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaSiteDef_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaSiteDef_get,METH_VARARGS,oaStringAppDef_oaSiteDef_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaSiteDef_getDefault,METH_VARARGS,oaStringAppDef_oaSiteDef_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaSiteDef_set,METH_VARARGS,oaStringAppDef_oaSiteDef_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaSiteDef_tp_isNull,METH_VARARGS,oaStringAppDef_oaSiteDef_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaSiteDef_tp_assign,METH_VARARGS,oaStringAppDef_oaSiteDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaSiteDef_doc[] = 
"Class: oaStringAppDef_oaSiteDef\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaSiteDef)\n"
"    Calls: (const oaStringAppDef_oaSiteDef&)\n"
"    Signature: oaStringAppDef_oaSiteDef||cref-oaStringAppDef_oaSiteDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaSiteDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaSiteDef",
    sizeof(PyoaStringAppDef_oaSiteDefObject),
    0,
    (destructor)oaStringAppDef_oaSiteDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaSiteDef_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaSiteDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaSiteDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaSiteDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaSiteDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaSiteDef_static_find_doc[] = 
"Class: oaStringAppDef_oaSiteDef, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaSiteDef* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaSiteDef|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaSiteDef* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaSiteDef|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaSiteDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaSiteDefp result= (oaStringAppDef_oaSiteDef::find(p1.Data()));
            return PyoaStringAppDef_oaSiteDef_FromoaStringAppDef_oaSiteDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaSiteDefp result= (oaStringAppDef_oaSiteDef::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaSiteDef_FromoaStringAppDef_oaSiteDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaSiteDef, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaSiteDef_static_get_doc[] = 
"Class: oaStringAppDef_oaSiteDef, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaSiteDef* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaSiteDef|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaSiteDef* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaSiteDef|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaSiteDef* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaSiteDef|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaSiteDef* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaSiteDef|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaSiteDef* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaSiteDef|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaSiteDef* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaSiteDef|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaSiteDef_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaSiteDefp result= (oaStringAppDef_oaSiteDef::get(p1.Data()));
            return PyoaStringAppDef_oaSiteDef_FromoaStringAppDef_oaSiteDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaSiteDefp result= (oaStringAppDef_oaSiteDef::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaSiteDef_FromoaStringAppDef_oaSiteDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaSiteDefp result= (oaStringAppDef_oaSiteDef::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaSiteDef_FromoaStringAppDef_oaSiteDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaSiteDefp result= (oaStringAppDef_oaSiteDef::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaSiteDef_FromoaStringAppDef_oaSiteDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaSiteDefp result= (oaStringAppDef_oaSiteDef::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaSiteDef_FromoaStringAppDef_oaSiteDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaSiteDefp result= (oaStringAppDef_oaSiteDef::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaSiteDef_FromoaStringAppDef_oaSiteDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaSiteDef, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaSiteDef_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaSiteDef_static_find,METH_VARARGS,oaStringAppDef_oaSiteDef_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaSiteDef_static_get,METH_VARARGS,oaStringAppDef_oaSiteDef_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaSiteDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaSiteDef_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaSiteDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaSiteDef",
           (PyObject*)(&PyoaStringAppDef_oaSiteDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaSiteDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaSiteDef_Type.tp_dict;
    for(method=oaStringAppDef_oaSiteDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaSteiner
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaSteiner_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaSteiner_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaSteinerObject* self = (PyoaStringAppDef_oaSteinerObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaSteiner)
    {
        PyParamoaStringAppDef_oaSteiner p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaSteiner_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaSteiner, Choices are:\n"
        "    (oaStringAppDef_oaSteiner)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaSteiner_tp_dealloc(PyoaStringAppDef_oaSteinerObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaSteiner_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaSteiner value;
    int convert_status=PyoaStringAppDef_oaSteiner_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[46];
    sprintf(buffer,"<oaStringAppDef_oaSteiner::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaSteiner_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaSteiner v1;
    PyParamoaStringAppDef_oaSteiner v2;
    int convert_status1=PyoaStringAppDef_oaSteiner_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaSteiner_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaSteiner_Convert(PyObject* ob,PyParamoaStringAppDef_oaSteiner* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaSteiner_Check(ob)) {
        result->SetData( (oaStringAppDef_oaSteiner**) ((PyoaStringAppDef_oaSteinerObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaSteiner Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaSteiner_FromoaStringAppDef_oaSteiner(oaStringAppDef_oaSteiner** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaSteiner* data=*value;
        PyObject* bself = PyoaStringAppDef_oaSteiner_Type.tp_alloc(&PyoaStringAppDef_oaSteiner_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaSteinerObject* self = (PyoaStringAppDef_oaSteinerObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaSteiner_FromoaStringAppDef_oaSteiner(oaStringAppDef_oaSteiner* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaSteiner_Type.tp_alloc(&PyoaStringAppDef_oaSteiner_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaSteinerObject* self = (PyoaStringAppDef_oaSteinerObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaSteiner_get_doc[] = 
"Class: oaStringAppDef_oaSteiner, Function: get\n"
"  Paramegers: (oaSteiner,oaString)\n"
"    Calls: void get(const oaSteiner* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaSteiner,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaSteiner_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaSteiner data;
    int convert_status=PyoaStringAppDef_oaSteiner_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaSteinerObject* self=(PyoaStringAppDef_oaSteinerObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaSteiner p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaSteiner_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaSteiner_getDefault_doc[] = 
"Class: oaStringAppDef_oaSteiner, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaSteiner_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaSteiner data;
    int convert_status=PyoaStringAppDef_oaSteiner_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaSteinerObject* self=(PyoaStringAppDef_oaSteinerObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaSteiner_set_doc[] = 
"Class: oaStringAppDef_oaSteiner, Function: set\n"
"  Paramegers: (oaSteiner,oaString)\n"
"    Calls: void set(oaSteiner* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaSteiner,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaSteiner_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaSteiner data;
    int convert_status=PyoaStringAppDef_oaSteiner_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaSteinerObject* self=(PyoaStringAppDef_oaSteinerObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaSteiner p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaSteiner_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaSteiner_isNull_doc[] =
"Class: oaStringAppDef_oaSteiner, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaSteiner_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaSteiner data;
    int convert_status=PyoaStringAppDef_oaSteiner_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaSteiner_assign_doc[] = 
"Class: oaStringAppDef_oaSteiner, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaSteiner_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaSteiner data;
  int convert_status=PyoaStringAppDef_oaSteiner_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaSteiner p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaSteiner_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaSteiner_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaSteiner_get,METH_VARARGS,oaStringAppDef_oaSteiner_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaSteiner_getDefault,METH_VARARGS,oaStringAppDef_oaSteiner_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaSteiner_set,METH_VARARGS,oaStringAppDef_oaSteiner_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaSteiner_tp_isNull,METH_VARARGS,oaStringAppDef_oaSteiner_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaSteiner_tp_assign,METH_VARARGS,oaStringAppDef_oaSteiner_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaSteiner_doc[] = 
"Class: oaStringAppDef_oaSteiner\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaSteiner)\n"
"    Calls: (const oaStringAppDef_oaSteiner&)\n"
"    Signature: oaStringAppDef_oaSteiner||cref-oaStringAppDef_oaSteiner,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaSteiner_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaSteiner",
    sizeof(PyoaStringAppDef_oaSteinerObject),
    0,
    (destructor)oaStringAppDef_oaSteiner_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaSteiner_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaSteiner_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaSteiner_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaSteiner_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaSteiner_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaSteiner_static_find_doc[] = 
"Class: oaStringAppDef_oaSteiner, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaSteiner* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaSteiner|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaSteiner* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaSteiner|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaSteiner_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaSteinerp result= (oaStringAppDef_oaSteiner::find(p1.Data()));
            return PyoaStringAppDef_oaSteiner_FromoaStringAppDef_oaSteiner(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaSteinerp result= (oaStringAppDef_oaSteiner::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaSteiner_FromoaStringAppDef_oaSteiner(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaSteiner, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaSteiner_static_get_doc[] = 
"Class: oaStringAppDef_oaSteiner, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaSteiner* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaSteiner|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaSteiner* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaSteiner|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaSteiner* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaSteiner|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaSteiner* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaSteiner|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaSteiner* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaSteiner|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaSteiner* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaSteiner|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaSteiner_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaSteinerp result= (oaStringAppDef_oaSteiner::get(p1.Data()));
            return PyoaStringAppDef_oaSteiner_FromoaStringAppDef_oaSteiner(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaSteinerp result= (oaStringAppDef_oaSteiner::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaSteiner_FromoaStringAppDef_oaSteiner(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaSteinerp result= (oaStringAppDef_oaSteiner::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaSteiner_FromoaStringAppDef_oaSteiner(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaSteinerp result= (oaStringAppDef_oaSteiner::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaSteiner_FromoaStringAppDef_oaSteiner(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaSteinerp result= (oaStringAppDef_oaSteiner::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaSteiner_FromoaStringAppDef_oaSteiner(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaSteinerp result= (oaStringAppDef_oaSteiner::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaSteiner_FromoaStringAppDef_oaSteiner(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaSteiner, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaSteiner_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaSteiner_static_find,METH_VARARGS,oaStringAppDef_oaSteiner_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaSteiner_static_get,METH_VARARGS,oaStringAppDef_oaSteiner_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaSteiner_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaSteiner_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaSteiner\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaSteiner",
           (PyObject*)(&PyoaStringAppDef_oaSteiner_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaSteiner\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaSteiner_Type.tp_dict;
    for(method=oaStringAppDef_oaSteiner_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaStepperMap
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaStepperMap_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaStepperMap_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaStepperMapObject* self = (PyoaStringAppDef_oaStepperMapObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaStepperMap)
    {
        PyParamoaStringAppDef_oaStepperMap p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaStepperMap_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaStepperMap, Choices are:\n"
        "    (oaStringAppDef_oaStepperMap)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaStepperMap_tp_dealloc(PyoaStringAppDef_oaStepperMapObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaStepperMap_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaStepperMap value;
    int convert_status=PyoaStringAppDef_oaStepperMap_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[49];
    sprintf(buffer,"<oaStringAppDef_oaStepperMap::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaStepperMap_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaStepperMap v1;
    PyParamoaStringAppDef_oaStepperMap v2;
    int convert_status1=PyoaStringAppDef_oaStepperMap_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaStepperMap_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaStepperMap_Convert(PyObject* ob,PyParamoaStringAppDef_oaStepperMap* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaStepperMap_Check(ob)) {
        result->SetData( (oaStringAppDef_oaStepperMap**) ((PyoaStringAppDef_oaStepperMapObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaStepperMap Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaStepperMap_FromoaStringAppDef_oaStepperMap(oaStringAppDef_oaStepperMap** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaStepperMap* data=*value;
        PyObject* bself = PyoaStringAppDef_oaStepperMap_Type.tp_alloc(&PyoaStringAppDef_oaStepperMap_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaStepperMapObject* self = (PyoaStringAppDef_oaStepperMapObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaStepperMap_FromoaStringAppDef_oaStepperMap(oaStringAppDef_oaStepperMap* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaStepperMap_Type.tp_alloc(&PyoaStringAppDef_oaStepperMap_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaStepperMapObject* self = (PyoaStringAppDef_oaStepperMapObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaStepperMap_get_doc[] = 
"Class: oaStringAppDef_oaStepperMap, Function: get\n"
"  Paramegers: (oaStepperMap,oaString)\n"
"    Calls: void get(const oaStepperMap* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaStepperMap,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaStepperMap_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaStepperMap data;
    int convert_status=PyoaStringAppDef_oaStepperMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaStepperMapObject* self=(PyoaStringAppDef_oaStepperMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaStepperMap p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaStepperMap_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaStepperMap_getDefault_doc[] = 
"Class: oaStringAppDef_oaStepperMap, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaStepperMap_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaStepperMap data;
    int convert_status=PyoaStringAppDef_oaStepperMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaStepperMapObject* self=(PyoaStringAppDef_oaStepperMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaStepperMap_set_doc[] = 
"Class: oaStringAppDef_oaStepperMap, Function: set\n"
"  Paramegers: (oaStepperMap,oaString)\n"
"    Calls: void set(oaStepperMap* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaStepperMap,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaStepperMap_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaStepperMap data;
    int convert_status=PyoaStringAppDef_oaStepperMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaStepperMapObject* self=(PyoaStringAppDef_oaStepperMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaStepperMap p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaStepperMap_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaStepperMap_isNull_doc[] =
"Class: oaStringAppDef_oaStepperMap, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaStepperMap_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaStepperMap data;
    int convert_status=PyoaStringAppDef_oaStepperMap_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaStepperMap_assign_doc[] = 
"Class: oaStringAppDef_oaStepperMap, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaStepperMap_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaStepperMap data;
  int convert_status=PyoaStringAppDef_oaStepperMap_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaStepperMap p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaStepperMap_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaStepperMap_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaStepperMap_get,METH_VARARGS,oaStringAppDef_oaStepperMap_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaStepperMap_getDefault,METH_VARARGS,oaStringAppDef_oaStepperMap_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaStepperMap_set,METH_VARARGS,oaStringAppDef_oaStepperMap_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaStepperMap_tp_isNull,METH_VARARGS,oaStringAppDef_oaStepperMap_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaStepperMap_tp_assign,METH_VARARGS,oaStringAppDef_oaStepperMap_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaStepperMap_doc[] = 
"Class: oaStringAppDef_oaStepperMap\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaStepperMap)\n"
"    Calls: (const oaStringAppDef_oaStepperMap&)\n"
"    Signature: oaStringAppDef_oaStepperMap||cref-oaStringAppDef_oaStepperMap,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaStepperMap_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaStepperMap",
    sizeof(PyoaStringAppDef_oaStepperMapObject),
    0,
    (destructor)oaStringAppDef_oaStepperMap_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaStepperMap_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaStepperMap_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaStepperMap_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaStepperMap_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaStepperMap_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaStepperMap_static_find_doc[] = 
"Class: oaStringAppDef_oaStepperMap, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaStepperMap* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaStepperMap|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaStepperMap* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaStepperMap|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaStepperMap_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaStepperMapp result= (oaStringAppDef_oaStepperMap::find(p1.Data()));
            return PyoaStringAppDef_oaStepperMap_FromoaStringAppDef_oaStepperMap(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaStepperMapp result= (oaStringAppDef_oaStepperMap::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaStepperMap_FromoaStringAppDef_oaStepperMap(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaStepperMap, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaStepperMap_static_get_doc[] = 
"Class: oaStringAppDef_oaStepperMap, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaStepperMap* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaStepperMap|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaStepperMap* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaStepperMap|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaStepperMap* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaStepperMap|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaStepperMap* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaStepperMap|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaStepperMap* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaStepperMap|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaStepperMap* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaStepperMap|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaStepperMap_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaStepperMapp result= (oaStringAppDef_oaStepperMap::get(p1.Data()));
            return PyoaStringAppDef_oaStepperMap_FromoaStringAppDef_oaStepperMap(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaStepperMapp result= (oaStringAppDef_oaStepperMap::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaStepperMap_FromoaStringAppDef_oaStepperMap(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaStepperMapp result= (oaStringAppDef_oaStepperMap::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaStepperMap_FromoaStringAppDef_oaStepperMap(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaStepperMapp result= (oaStringAppDef_oaStepperMap::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaStepperMap_FromoaStringAppDef_oaStepperMap(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaStepperMapp result= (oaStringAppDef_oaStepperMap::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaStepperMap_FromoaStringAppDef_oaStepperMap(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaStepperMapp result= (oaStringAppDef_oaStepperMap::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaStepperMap_FromoaStringAppDef_oaStepperMap(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaStepperMap, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaStepperMap_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaStepperMap_static_find,METH_VARARGS,oaStringAppDef_oaStepperMap_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaStepperMap_static_get,METH_VARARGS,oaStringAppDef_oaStepperMap_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaStepperMap_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaStepperMap_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaStepperMap\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaStepperMap",
           (PyObject*)(&PyoaStringAppDef_oaStepperMap_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaStepperMap\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaStepperMap_Type.tp_dict;
    for(method=oaStringAppDef_oaStepperMap_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaTech
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaTech_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaTech_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaTechObject* self = (PyoaStringAppDef_oaTechObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaTech)
    {
        PyParamoaStringAppDef_oaTech p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaTech_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaTech, Choices are:\n"
        "    (oaStringAppDef_oaTech)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaTech_tp_dealloc(PyoaStringAppDef_oaTechObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaTech_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaTech value;
    int convert_status=PyoaStringAppDef_oaTech_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaStringAppDef_oaTech::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaTech_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaTech v1;
    PyParamoaStringAppDef_oaTech v2;
    int convert_status1=PyoaStringAppDef_oaTech_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaTech_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaTech_Convert(PyObject* ob,PyParamoaStringAppDef_oaTech* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaTech_Check(ob)) {
        result->SetData( (oaStringAppDef_oaTech**) ((PyoaStringAppDef_oaTechObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaTech Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaTech_FromoaStringAppDef_oaTech(oaStringAppDef_oaTech** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaTech* data=*value;
        PyObject* bself = PyoaStringAppDef_oaTech_Type.tp_alloc(&PyoaStringAppDef_oaTech_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaTechObject* self = (PyoaStringAppDef_oaTechObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaTech_FromoaStringAppDef_oaTech(oaStringAppDef_oaTech* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaTech_Type.tp_alloc(&PyoaStringAppDef_oaTech_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaTechObject* self = (PyoaStringAppDef_oaTechObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaTech_get_doc[] = 
"Class: oaStringAppDef_oaTech, Function: get\n"
"  Paramegers: (oaTech,oaString)\n"
"    Calls: void get(const oaTech* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaTech,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaTech_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaTech data;
    int convert_status=PyoaStringAppDef_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaTechObject* self=(PyoaStringAppDef_oaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTech p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTech_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaTech_getDefault_doc[] = 
"Class: oaStringAppDef_oaTech, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaTech_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaTech data;
    int convert_status=PyoaStringAppDef_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaTechObject* self=(PyoaStringAppDef_oaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaTech_set_doc[] = 
"Class: oaStringAppDef_oaTech, Function: set\n"
"  Paramegers: (oaTech,oaString)\n"
"    Calls: void set(oaTech* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaTech,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaTech_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaTech data;
    int convert_status=PyoaStringAppDef_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaTechObject* self=(PyoaStringAppDef_oaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTech p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTech_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaTech_isNull_doc[] =
"Class: oaStringAppDef_oaTech, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaTech_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaTech data;
    int convert_status=PyoaStringAppDef_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaTech_assign_doc[] = 
"Class: oaStringAppDef_oaTech, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaTech_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaTech data;
  int convert_status=PyoaStringAppDef_oaTech_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaTech p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaTech_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaTech_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaTech_get,METH_VARARGS,oaStringAppDef_oaTech_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaTech_getDefault,METH_VARARGS,oaStringAppDef_oaTech_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaTech_set,METH_VARARGS,oaStringAppDef_oaTech_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaTech_tp_isNull,METH_VARARGS,oaStringAppDef_oaTech_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaTech_tp_assign,METH_VARARGS,oaStringAppDef_oaTech_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaTech_doc[] = 
"Class: oaStringAppDef_oaTech\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaTech)\n"
"    Calls: (const oaStringAppDef_oaTech&)\n"
"    Signature: oaStringAppDef_oaTech||cref-oaStringAppDef_oaTech,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaTech_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaTech",
    sizeof(PyoaStringAppDef_oaTechObject),
    0,
    (destructor)oaStringAppDef_oaTech_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaTech_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaTech_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaTech_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaTech_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaTech_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaTech_static_find_doc[] = 
"Class: oaStringAppDef_oaTech, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaTech* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaTech|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaTech* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaTech|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaTech_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaTechp result= (oaStringAppDef_oaTech::find(p1.Data()));
            return PyoaStringAppDef_oaTech_FromoaStringAppDef_oaTech(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaTechp result= (oaStringAppDef_oaTech::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaTech_FromoaStringAppDef_oaTech(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaTech, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaTech_static_get_doc[] = 
"Class: oaStringAppDef_oaTech, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaTech* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaTech|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaTech* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaTech|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaTech* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaTech|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaTech* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaTech|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaTech* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaTech|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaTech* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaTech|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaTech_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaTechp result= (oaStringAppDef_oaTech::get(p1.Data()));
            return PyoaStringAppDef_oaTech_FromoaStringAppDef_oaTech(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaTechp result= (oaStringAppDef_oaTech::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaTech_FromoaStringAppDef_oaTech(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaTechp result= (oaStringAppDef_oaTech::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaTech_FromoaStringAppDef_oaTech(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaTechp result= (oaStringAppDef_oaTech::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaTech_FromoaStringAppDef_oaTech(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaTechp result= (oaStringAppDef_oaTech::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaTech_FromoaStringAppDef_oaTech(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaTechp result= (oaStringAppDef_oaTech::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaTech_FromoaStringAppDef_oaTech(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaTech, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaTech_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaTech_static_find,METH_VARARGS,oaStringAppDef_oaTech_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaTech_static_get,METH_VARARGS,oaStringAppDef_oaTech_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaTech_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaTech_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaTech\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaTech",
           (PyObject*)(&PyoaStringAppDef_oaTech_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaTech\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaTech_Type.tp_dict;
    for(method=oaStringAppDef_oaTech_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaTechHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaTechHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaTechHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaTechHeaderObject* self = (PyoaStringAppDef_oaTechHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaTechHeader)
    {
        PyParamoaStringAppDef_oaTechHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaTechHeader_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaTechHeader, Choices are:\n"
        "    (oaStringAppDef_oaTechHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaTechHeader_tp_dealloc(PyoaStringAppDef_oaTechHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaTechHeader_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaTechHeader value;
    int convert_status=PyoaStringAppDef_oaTechHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[49];
    sprintf(buffer,"<oaStringAppDef_oaTechHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaTechHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaTechHeader v1;
    PyParamoaStringAppDef_oaTechHeader v2;
    int convert_status1=PyoaStringAppDef_oaTechHeader_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaTechHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaTechHeader_Convert(PyObject* ob,PyParamoaStringAppDef_oaTechHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaTechHeader_Check(ob)) {
        result->SetData( (oaStringAppDef_oaTechHeader**) ((PyoaStringAppDef_oaTechHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaTechHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaTechHeader_FromoaStringAppDef_oaTechHeader(oaStringAppDef_oaTechHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaTechHeader* data=*value;
        PyObject* bself = PyoaStringAppDef_oaTechHeader_Type.tp_alloc(&PyoaStringAppDef_oaTechHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaTechHeaderObject* self = (PyoaStringAppDef_oaTechHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaTechHeader_FromoaStringAppDef_oaTechHeader(oaStringAppDef_oaTechHeader* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaTechHeader_Type.tp_alloc(&PyoaStringAppDef_oaTechHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaTechHeaderObject* self = (PyoaStringAppDef_oaTechHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaTechHeader_get_doc[] = 
"Class: oaStringAppDef_oaTechHeader, Function: get\n"
"  Paramegers: (oaTechHeader,oaString)\n"
"    Calls: void get(const oaTechHeader* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaTechHeader,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaTechHeader_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaTechHeader data;
    int convert_status=PyoaStringAppDef_oaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaTechHeaderObject* self=(PyoaStringAppDef_oaTechHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechHeader p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTechHeader_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaTechHeader_getDefault_doc[] = 
"Class: oaStringAppDef_oaTechHeader, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaTechHeader_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaTechHeader data;
    int convert_status=PyoaStringAppDef_oaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaTechHeaderObject* self=(PyoaStringAppDef_oaTechHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaTechHeader_set_doc[] = 
"Class: oaStringAppDef_oaTechHeader, Function: set\n"
"  Paramegers: (oaTechHeader,oaString)\n"
"    Calls: void set(oaTechHeader* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaTechHeader,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaTechHeader_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaTechHeader data;
    int convert_status=PyoaStringAppDef_oaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaTechHeaderObject* self=(PyoaStringAppDef_oaTechHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechHeader p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTechHeader_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaTechHeader_isNull_doc[] =
"Class: oaStringAppDef_oaTechHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaTechHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaTechHeader data;
    int convert_status=PyoaStringAppDef_oaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaTechHeader_assign_doc[] = 
"Class: oaStringAppDef_oaTechHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaTechHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaTechHeader data;
  int convert_status=PyoaStringAppDef_oaTechHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaTechHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaTechHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaTechHeader_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaTechHeader_get,METH_VARARGS,oaStringAppDef_oaTechHeader_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaTechHeader_getDefault,METH_VARARGS,oaStringAppDef_oaTechHeader_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaTechHeader_set,METH_VARARGS,oaStringAppDef_oaTechHeader_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaTechHeader_tp_isNull,METH_VARARGS,oaStringAppDef_oaTechHeader_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaTechHeader_tp_assign,METH_VARARGS,oaStringAppDef_oaTechHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaTechHeader_doc[] = 
"Class: oaStringAppDef_oaTechHeader\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaTechHeader)\n"
"    Calls: (const oaStringAppDef_oaTechHeader&)\n"
"    Signature: oaStringAppDef_oaTechHeader||cref-oaStringAppDef_oaTechHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaTechHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaTechHeader",
    sizeof(PyoaStringAppDef_oaTechHeaderObject),
    0,
    (destructor)oaStringAppDef_oaTechHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaTechHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaTechHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaTechHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaTechHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaTechHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaTechHeader_static_find_doc[] = 
"Class: oaStringAppDef_oaTechHeader, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaTechHeader* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaTechHeader|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaTechHeader* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaTechHeader|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaTechHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaTechHeaderp result= (oaStringAppDef_oaTechHeader::find(p1.Data()));
            return PyoaStringAppDef_oaTechHeader_FromoaStringAppDef_oaTechHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaTechHeaderp result= (oaStringAppDef_oaTechHeader::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaTechHeader_FromoaStringAppDef_oaTechHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaTechHeader, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaTechHeader_static_get_doc[] = 
"Class: oaStringAppDef_oaTechHeader, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaTechHeader* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaTechHeader|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaTechHeader* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaTechHeader|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaTechHeader* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaTechHeader|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaTechHeader* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaTechHeader|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaTechHeader* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaTechHeader|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaTechHeader* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaTechHeader|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaTechHeader_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaTechHeaderp result= (oaStringAppDef_oaTechHeader::get(p1.Data()));
            return PyoaStringAppDef_oaTechHeader_FromoaStringAppDef_oaTechHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaTechHeaderp result= (oaStringAppDef_oaTechHeader::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaTechHeader_FromoaStringAppDef_oaTechHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaTechHeaderp result= (oaStringAppDef_oaTechHeader::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaTechHeader_FromoaStringAppDef_oaTechHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaTechHeaderp result= (oaStringAppDef_oaTechHeader::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaTechHeader_FromoaStringAppDef_oaTechHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaTechHeaderp result= (oaStringAppDef_oaTechHeader::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaTechHeader_FromoaStringAppDef_oaTechHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaTechHeaderp result= (oaStringAppDef_oaTechHeader::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaTechHeader_FromoaStringAppDef_oaTechHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaTechHeader, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaTechHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaTechHeader_static_find,METH_VARARGS,oaStringAppDef_oaTechHeader_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaTechHeader_static_get,METH_VARARGS,oaStringAppDef_oaTechHeader_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaTechHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaTechHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaTechHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaTechHeader",
           (PyObject*)(&PyoaStringAppDef_oaTechHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaTechHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaTechHeader_Type.tp_dict;
    for(method=oaStringAppDef_oaTechHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaTechLayerHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaTechLayerHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaTechLayerHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaTechLayerHeaderObject* self = (PyoaStringAppDef_oaTechLayerHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaTechLayerHeader)
    {
        PyParamoaStringAppDef_oaTechLayerHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaTechLayerHeader_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaTechLayerHeader, Choices are:\n"
        "    (oaStringAppDef_oaTechLayerHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaTechLayerHeader_tp_dealloc(PyoaStringAppDef_oaTechLayerHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaTechLayerHeader_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaTechLayerHeader value;
    int convert_status=PyoaStringAppDef_oaTechLayerHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[54];
    sprintf(buffer,"<oaStringAppDef_oaTechLayerHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaTechLayerHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaTechLayerHeader v1;
    PyParamoaStringAppDef_oaTechLayerHeader v2;
    int convert_status1=PyoaStringAppDef_oaTechLayerHeader_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaTechLayerHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaTechLayerHeader_Convert(PyObject* ob,PyParamoaStringAppDef_oaTechLayerHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaTechLayerHeader_Check(ob)) {
        result->SetData( (oaStringAppDef_oaTechLayerHeader**) ((PyoaStringAppDef_oaTechLayerHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaTechLayerHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaTechLayerHeader_FromoaStringAppDef_oaTechLayerHeader(oaStringAppDef_oaTechLayerHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaTechLayerHeader* data=*value;
        PyObject* bself = PyoaStringAppDef_oaTechLayerHeader_Type.tp_alloc(&PyoaStringAppDef_oaTechLayerHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaTechLayerHeaderObject* self = (PyoaStringAppDef_oaTechLayerHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaTechLayerHeader_FromoaStringAppDef_oaTechLayerHeader(oaStringAppDef_oaTechLayerHeader* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaTechLayerHeader_Type.tp_alloc(&PyoaStringAppDef_oaTechLayerHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaTechLayerHeaderObject* self = (PyoaStringAppDef_oaTechLayerHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaTechLayerHeader_get_doc[] = 
"Class: oaStringAppDef_oaTechLayerHeader, Function: get\n"
"  Paramegers: (oaTechLayerHeader,oaString)\n"
"    Calls: void get(const oaTechLayerHeader* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaTechLayerHeader,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaTechLayerHeader_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaTechLayerHeader data;
    int convert_status=PyoaStringAppDef_oaTechLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaTechLayerHeaderObject* self=(PyoaStringAppDef_oaTechLayerHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechLayerHeader p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTechLayerHeader_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaTechLayerHeader_getDefault_doc[] = 
"Class: oaStringAppDef_oaTechLayerHeader, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaTechLayerHeader_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaTechLayerHeader data;
    int convert_status=PyoaStringAppDef_oaTechLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaTechLayerHeaderObject* self=(PyoaStringAppDef_oaTechLayerHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaTechLayerHeader_set_doc[] = 
"Class: oaStringAppDef_oaTechLayerHeader, Function: set\n"
"  Paramegers: (oaTechLayerHeader,oaString)\n"
"    Calls: void set(oaTechLayerHeader* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaTechLayerHeader,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaTechLayerHeader_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaTechLayerHeader data;
    int convert_status=PyoaStringAppDef_oaTechLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaTechLayerHeaderObject* self=(PyoaStringAppDef_oaTechLayerHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechLayerHeader p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTechLayerHeader_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaTechLayerHeader_isNull_doc[] =
"Class: oaStringAppDef_oaTechLayerHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaTechLayerHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaTechLayerHeader data;
    int convert_status=PyoaStringAppDef_oaTechLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaTechLayerHeader_assign_doc[] = 
"Class: oaStringAppDef_oaTechLayerHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaTechLayerHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaTechLayerHeader data;
  int convert_status=PyoaStringAppDef_oaTechLayerHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaTechLayerHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaTechLayerHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaTechLayerHeader_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaTechLayerHeader_get,METH_VARARGS,oaStringAppDef_oaTechLayerHeader_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaTechLayerHeader_getDefault,METH_VARARGS,oaStringAppDef_oaTechLayerHeader_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaTechLayerHeader_set,METH_VARARGS,oaStringAppDef_oaTechLayerHeader_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaTechLayerHeader_tp_isNull,METH_VARARGS,oaStringAppDef_oaTechLayerHeader_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaTechLayerHeader_tp_assign,METH_VARARGS,oaStringAppDef_oaTechLayerHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaTechLayerHeader_doc[] = 
"Class: oaStringAppDef_oaTechLayerHeader\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaTechLayerHeader)\n"
"    Calls: (const oaStringAppDef_oaTechLayerHeader&)\n"
"    Signature: oaStringAppDef_oaTechLayerHeader||cref-oaStringAppDef_oaTechLayerHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaTechLayerHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaTechLayerHeader",
    sizeof(PyoaStringAppDef_oaTechLayerHeaderObject),
    0,
    (destructor)oaStringAppDef_oaTechLayerHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaTechLayerHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaTechLayerHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaTechLayerHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaTechLayerHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaTechLayerHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaTechLayerHeader_static_find_doc[] = 
"Class: oaStringAppDef_oaTechLayerHeader, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaTechLayerHeader* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaTechLayerHeader|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaTechLayerHeader* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaTechLayerHeader|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaTechLayerHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaTechLayerHeaderp result= (oaStringAppDef_oaTechLayerHeader::find(p1.Data()));
            return PyoaStringAppDef_oaTechLayerHeader_FromoaStringAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaTechLayerHeaderp result= (oaStringAppDef_oaTechLayerHeader::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaTechLayerHeader_FromoaStringAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaTechLayerHeader, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaTechLayerHeader_static_get_doc[] = 
"Class: oaStringAppDef_oaTechLayerHeader, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaTechLayerHeader* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaTechLayerHeader|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaTechLayerHeader* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaTechLayerHeader|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaTechLayerHeader* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaTechLayerHeader|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaTechLayerHeader* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaTechLayerHeader|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaTechLayerHeader* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaTechLayerHeader|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaTechLayerHeader* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaTechLayerHeader|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaTechLayerHeader_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaTechLayerHeaderp result= (oaStringAppDef_oaTechLayerHeader::get(p1.Data()));
            return PyoaStringAppDef_oaTechLayerHeader_FromoaStringAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaTechLayerHeaderp result= (oaStringAppDef_oaTechLayerHeader::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaTechLayerHeader_FromoaStringAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaTechLayerHeaderp result= (oaStringAppDef_oaTechLayerHeader::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaTechLayerHeader_FromoaStringAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaTechLayerHeaderp result= (oaStringAppDef_oaTechLayerHeader::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaTechLayerHeader_FromoaStringAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaTechLayerHeaderp result= (oaStringAppDef_oaTechLayerHeader::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaTechLayerHeader_FromoaStringAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaTechLayerHeaderp result= (oaStringAppDef_oaTechLayerHeader::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaTechLayerHeader_FromoaStringAppDef_oaTechLayerHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaTechLayerHeader, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaTechLayerHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaTechLayerHeader_static_find,METH_VARARGS,oaStringAppDef_oaTechLayerHeader_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaTechLayerHeader_static_get,METH_VARARGS,oaStringAppDef_oaTechLayerHeader_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaTechLayerHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaTechLayerHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaTechLayerHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaTechLayerHeader",
           (PyObject*)(&PyoaStringAppDef_oaTechLayerHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaTechLayerHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaTechLayerHeader_Type.tp_dict;
    for(method=oaStringAppDef_oaTechLayerHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaTechViaDefHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaTechViaDefHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaTechViaDefHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaTechViaDefHeaderObject* self = (PyoaStringAppDef_oaTechViaDefHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaTechViaDefHeader)
    {
        PyParamoaStringAppDef_oaTechViaDefHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaTechViaDefHeader_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaTechViaDefHeader, Choices are:\n"
        "    (oaStringAppDef_oaTechViaDefHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaTechViaDefHeader_tp_dealloc(PyoaStringAppDef_oaTechViaDefHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaTechViaDefHeader_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaTechViaDefHeader value;
    int convert_status=PyoaStringAppDef_oaTechViaDefHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[55];
    sprintf(buffer,"<oaStringAppDef_oaTechViaDefHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaTechViaDefHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaTechViaDefHeader v1;
    PyParamoaStringAppDef_oaTechViaDefHeader v2;
    int convert_status1=PyoaStringAppDef_oaTechViaDefHeader_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaTechViaDefHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaTechViaDefHeader_Convert(PyObject* ob,PyParamoaStringAppDef_oaTechViaDefHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaTechViaDefHeader_Check(ob)) {
        result->SetData( (oaStringAppDef_oaTechViaDefHeader**) ((PyoaStringAppDef_oaTechViaDefHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaTechViaDefHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaTechViaDefHeader_FromoaStringAppDef_oaTechViaDefHeader(oaStringAppDef_oaTechViaDefHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaTechViaDefHeader* data=*value;
        PyObject* bself = PyoaStringAppDef_oaTechViaDefHeader_Type.tp_alloc(&PyoaStringAppDef_oaTechViaDefHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaTechViaDefHeaderObject* self = (PyoaStringAppDef_oaTechViaDefHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaTechViaDefHeader_FromoaStringAppDef_oaTechViaDefHeader(oaStringAppDef_oaTechViaDefHeader* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaTechViaDefHeader_Type.tp_alloc(&PyoaStringAppDef_oaTechViaDefHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaTechViaDefHeaderObject* self = (PyoaStringAppDef_oaTechViaDefHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaTechViaDefHeader_get_doc[] = 
"Class: oaStringAppDef_oaTechViaDefHeader, Function: get\n"
"  Paramegers: (oaTechViaDefHeader,oaString)\n"
"    Calls: void get(const oaTechViaDefHeader* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaTechViaDefHeader,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaTechViaDefHeader_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaTechViaDefHeader data;
    int convert_status=PyoaStringAppDef_oaTechViaDefHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaTechViaDefHeaderObject* self=(PyoaStringAppDef_oaTechViaDefHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechViaDefHeader p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTechViaDefHeader_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaTechViaDefHeader_getDefault_doc[] = 
"Class: oaStringAppDef_oaTechViaDefHeader, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaTechViaDefHeader_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaTechViaDefHeader data;
    int convert_status=PyoaStringAppDef_oaTechViaDefHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaTechViaDefHeaderObject* self=(PyoaStringAppDef_oaTechViaDefHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaTechViaDefHeader_set_doc[] = 
"Class: oaStringAppDef_oaTechViaDefHeader, Function: set\n"
"  Paramegers: (oaTechViaDefHeader,oaString)\n"
"    Calls: void set(oaTechViaDefHeader* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaTechViaDefHeader,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaTechViaDefHeader_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaTechViaDefHeader data;
    int convert_status=PyoaStringAppDef_oaTechViaDefHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaTechViaDefHeaderObject* self=(PyoaStringAppDef_oaTechViaDefHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechViaDefHeader p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTechViaDefHeader_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaTechViaDefHeader_isNull_doc[] =
"Class: oaStringAppDef_oaTechViaDefHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaTechViaDefHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaTechViaDefHeader data;
    int convert_status=PyoaStringAppDef_oaTechViaDefHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaTechViaDefHeader_assign_doc[] = 
"Class: oaStringAppDef_oaTechViaDefHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaTechViaDefHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaTechViaDefHeader data;
  int convert_status=PyoaStringAppDef_oaTechViaDefHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaTechViaDefHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaTechViaDefHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaTechViaDefHeader_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaTechViaDefHeader_get,METH_VARARGS,oaStringAppDef_oaTechViaDefHeader_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaTechViaDefHeader_getDefault,METH_VARARGS,oaStringAppDef_oaTechViaDefHeader_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaTechViaDefHeader_set,METH_VARARGS,oaStringAppDef_oaTechViaDefHeader_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaTechViaDefHeader_tp_isNull,METH_VARARGS,oaStringAppDef_oaTechViaDefHeader_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaTechViaDefHeader_tp_assign,METH_VARARGS,oaStringAppDef_oaTechViaDefHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaTechViaDefHeader_doc[] = 
"Class: oaStringAppDef_oaTechViaDefHeader\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaTechViaDefHeader)\n"
"    Calls: (const oaStringAppDef_oaTechViaDefHeader&)\n"
"    Signature: oaStringAppDef_oaTechViaDefHeader||cref-oaStringAppDef_oaTechViaDefHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaTechViaDefHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaTechViaDefHeader",
    sizeof(PyoaStringAppDef_oaTechViaDefHeaderObject),
    0,
    (destructor)oaStringAppDef_oaTechViaDefHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaTechViaDefHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaTechViaDefHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaTechViaDefHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaTechViaDefHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaTechViaDefHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaTechViaDefHeader_static_find_doc[] = 
"Class: oaStringAppDef_oaTechViaDefHeader, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaTechViaDefHeader* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaTechViaDefHeader|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaTechViaDefHeader* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaTechViaDefHeader|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaTechViaDefHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaTechViaDefHeaderp result= (oaStringAppDef_oaTechViaDefHeader::find(p1.Data()));
            return PyoaStringAppDef_oaTechViaDefHeader_FromoaStringAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaTechViaDefHeaderp result= (oaStringAppDef_oaTechViaDefHeader::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaTechViaDefHeader_FromoaStringAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaTechViaDefHeader, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaTechViaDefHeader_static_get_doc[] = 
"Class: oaStringAppDef_oaTechViaDefHeader, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaTechViaDefHeader* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaTechViaDefHeader|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaTechViaDefHeader* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaTechViaDefHeader|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaTechViaDefHeader* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaTechViaDefHeader|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaTechViaDefHeader* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaTechViaDefHeader|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaTechViaDefHeader* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaTechViaDefHeader|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaTechViaDefHeader* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaTechViaDefHeader|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaTechViaDefHeader_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaTechViaDefHeaderp result= (oaStringAppDef_oaTechViaDefHeader::get(p1.Data()));
            return PyoaStringAppDef_oaTechViaDefHeader_FromoaStringAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaTechViaDefHeaderp result= (oaStringAppDef_oaTechViaDefHeader::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaTechViaDefHeader_FromoaStringAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaTechViaDefHeaderp result= (oaStringAppDef_oaTechViaDefHeader::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaTechViaDefHeader_FromoaStringAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaTechViaDefHeaderp result= (oaStringAppDef_oaTechViaDefHeader::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaTechViaDefHeader_FromoaStringAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaTechViaDefHeaderp result= (oaStringAppDef_oaTechViaDefHeader::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaTechViaDefHeader_FromoaStringAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaTechViaDefHeaderp result= (oaStringAppDef_oaTechViaDefHeader::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaTechViaDefHeader_FromoaStringAppDef_oaTechViaDefHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaTechViaDefHeader, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaTechViaDefHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaTechViaDefHeader_static_find,METH_VARARGS,oaStringAppDef_oaTechViaDefHeader_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaTechViaDefHeader_static_get,METH_VARARGS,oaStringAppDef_oaTechViaDefHeader_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaTechViaDefHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaTechViaDefHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaTechViaDefHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaTechViaDefHeader",
           (PyObject*)(&PyoaStringAppDef_oaTechViaDefHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaTechViaDefHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaTechViaDefHeader_Type.tp_dict;
    for(method=oaStringAppDef_oaTechViaDefHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaTerm
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaTerm_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaTerm_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaTermObject* self = (PyoaStringAppDef_oaTermObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaTerm)
    {
        PyParamoaStringAppDef_oaTerm p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaTerm_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaTerm, Choices are:\n"
        "    (oaStringAppDef_oaTerm)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaTerm_tp_dealloc(PyoaStringAppDef_oaTermObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaTerm_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaTerm value;
    int convert_status=PyoaStringAppDef_oaTerm_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaStringAppDef_oaTerm::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaTerm_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaTerm v1;
    PyParamoaStringAppDef_oaTerm v2;
    int convert_status1=PyoaStringAppDef_oaTerm_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaTerm_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaTerm_Convert(PyObject* ob,PyParamoaStringAppDef_oaTerm* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaTerm_Check(ob)) {
        result->SetData( (oaStringAppDef_oaTerm**) ((PyoaStringAppDef_oaTermObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaTerm Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaTerm_FromoaStringAppDef_oaTerm(oaStringAppDef_oaTerm** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaTerm* data=*value;
        PyObject* bself = PyoaStringAppDef_oaTerm_Type.tp_alloc(&PyoaStringAppDef_oaTerm_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaTermObject* self = (PyoaStringAppDef_oaTermObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaTerm_FromoaStringAppDef_oaTerm(oaStringAppDef_oaTerm* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaTerm_Type.tp_alloc(&PyoaStringAppDef_oaTerm_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaTermObject* self = (PyoaStringAppDef_oaTermObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaTerm_get_doc[] = 
"Class: oaStringAppDef_oaTerm, Function: get\n"
"  Paramegers: (oaTerm,oaString)\n"
"    Calls: void get(const oaTerm* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaTerm,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaTerm_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaTerm data;
    int convert_status=PyoaStringAppDef_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaTermObject* self=(PyoaStringAppDef_oaTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTerm p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTerm_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaTerm_getDefault_doc[] = 
"Class: oaStringAppDef_oaTerm, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaTerm_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaTerm data;
    int convert_status=PyoaStringAppDef_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaTermObject* self=(PyoaStringAppDef_oaTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaTerm_set_doc[] = 
"Class: oaStringAppDef_oaTerm, Function: set\n"
"  Paramegers: (oaTerm,oaString)\n"
"    Calls: void set(oaTerm* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaTerm,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaTerm_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaTerm data;
    int convert_status=PyoaStringAppDef_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaTermObject* self=(PyoaStringAppDef_oaTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTerm p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTerm_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaTerm_isNull_doc[] =
"Class: oaStringAppDef_oaTerm, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaTerm_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaTerm data;
    int convert_status=PyoaStringAppDef_oaTerm_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaTerm_assign_doc[] = 
"Class: oaStringAppDef_oaTerm, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaTerm_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaTerm data;
  int convert_status=PyoaStringAppDef_oaTerm_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaTerm p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaTerm_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaTerm_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaTerm_get,METH_VARARGS,oaStringAppDef_oaTerm_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaTerm_getDefault,METH_VARARGS,oaStringAppDef_oaTerm_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaTerm_set,METH_VARARGS,oaStringAppDef_oaTerm_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaTerm_tp_isNull,METH_VARARGS,oaStringAppDef_oaTerm_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaTerm_tp_assign,METH_VARARGS,oaStringAppDef_oaTerm_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaTerm_doc[] = 
"Class: oaStringAppDef_oaTerm\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaTerm)\n"
"    Calls: (const oaStringAppDef_oaTerm&)\n"
"    Signature: oaStringAppDef_oaTerm||cref-oaStringAppDef_oaTerm,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaTerm_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaTerm",
    sizeof(PyoaStringAppDef_oaTermObject),
    0,
    (destructor)oaStringAppDef_oaTerm_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaTerm_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaTerm_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaTerm_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaTerm_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaTerm_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaTerm_static_find_doc[] = 
"Class: oaStringAppDef_oaTerm, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaTerm* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaTerm|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaTerm* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaTerm|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaTerm_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaTermp result= (oaStringAppDef_oaTerm::find(p1.Data()));
            return PyoaStringAppDef_oaTerm_FromoaStringAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaTermp result= (oaStringAppDef_oaTerm::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaTerm_FromoaStringAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaTerm, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaTerm_static_get_doc[] = 
"Class: oaStringAppDef_oaTerm, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaTerm* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaTerm|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaTerm* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaTerm|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaTerm* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaTerm|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaTerm* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaTerm|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaTerm* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaTerm|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaTerm* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaTerm|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaTerm_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaTermp result= (oaStringAppDef_oaTerm::get(p1.Data()));
            return PyoaStringAppDef_oaTerm_FromoaStringAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaTermp result= (oaStringAppDef_oaTerm::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaTerm_FromoaStringAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaTermp result= (oaStringAppDef_oaTerm::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaTerm_FromoaStringAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaTermp result= (oaStringAppDef_oaTerm::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaTerm_FromoaStringAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaTermp result= (oaStringAppDef_oaTerm::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaTerm_FromoaStringAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaTermp result= (oaStringAppDef_oaTerm::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaTerm_FromoaStringAppDef_oaTerm(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaTerm, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaTerm_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaTerm_static_find,METH_VARARGS,oaStringAppDef_oaTerm_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaTerm_static_get,METH_VARARGS,oaStringAppDef_oaTerm_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaTerm_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaTerm_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaTerm\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaTerm",
           (PyObject*)(&PyoaStringAppDef_oaTerm_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaTerm\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaTerm_Type.tp_dict;
    for(method=oaStringAppDef_oaTerm_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaTrackPattern
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaTrackPattern_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaTrackPattern_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaTrackPatternObject* self = (PyoaStringAppDef_oaTrackPatternObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaTrackPattern)
    {
        PyParamoaStringAppDef_oaTrackPattern p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaTrackPattern_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaTrackPattern, Choices are:\n"
        "    (oaStringAppDef_oaTrackPattern)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaTrackPattern_tp_dealloc(PyoaStringAppDef_oaTrackPatternObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaTrackPattern_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaTrackPattern value;
    int convert_status=PyoaStringAppDef_oaTrackPattern_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[51];
    sprintf(buffer,"<oaStringAppDef_oaTrackPattern::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaTrackPattern_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaTrackPattern v1;
    PyParamoaStringAppDef_oaTrackPattern v2;
    int convert_status1=PyoaStringAppDef_oaTrackPattern_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaTrackPattern_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaTrackPattern_Convert(PyObject* ob,PyParamoaStringAppDef_oaTrackPattern* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaTrackPattern_Check(ob)) {
        result->SetData( (oaStringAppDef_oaTrackPattern**) ((PyoaStringAppDef_oaTrackPatternObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaTrackPattern Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaTrackPattern_FromoaStringAppDef_oaTrackPattern(oaStringAppDef_oaTrackPattern** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaTrackPattern* data=*value;
        PyObject* bself = PyoaStringAppDef_oaTrackPattern_Type.tp_alloc(&PyoaStringAppDef_oaTrackPattern_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaTrackPatternObject* self = (PyoaStringAppDef_oaTrackPatternObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaTrackPattern_FromoaStringAppDef_oaTrackPattern(oaStringAppDef_oaTrackPattern* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaTrackPattern_Type.tp_alloc(&PyoaStringAppDef_oaTrackPattern_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaTrackPatternObject* self = (PyoaStringAppDef_oaTrackPatternObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaTrackPattern_get_doc[] = 
"Class: oaStringAppDef_oaTrackPattern, Function: get\n"
"  Paramegers: (oaTrackPattern,oaString)\n"
"    Calls: void get(const oaTrackPattern* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaTrackPattern,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaTrackPattern_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaTrackPattern data;
    int convert_status=PyoaStringAppDef_oaTrackPattern_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaTrackPatternObject* self=(PyoaStringAppDef_oaTrackPatternObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTrackPattern p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTrackPattern_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaTrackPattern_getDefault_doc[] = 
"Class: oaStringAppDef_oaTrackPattern, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaTrackPattern_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaTrackPattern data;
    int convert_status=PyoaStringAppDef_oaTrackPattern_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaTrackPatternObject* self=(PyoaStringAppDef_oaTrackPatternObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaTrackPattern_set_doc[] = 
"Class: oaStringAppDef_oaTrackPattern, Function: set\n"
"  Paramegers: (oaTrackPattern,oaString)\n"
"    Calls: void set(oaTrackPattern* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaTrackPattern,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaTrackPattern_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaTrackPattern data;
    int convert_status=PyoaStringAppDef_oaTrackPattern_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaTrackPatternObject* self=(PyoaStringAppDef_oaTrackPatternObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTrackPattern p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTrackPattern_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaTrackPattern_isNull_doc[] =
"Class: oaStringAppDef_oaTrackPattern, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaTrackPattern_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaTrackPattern data;
    int convert_status=PyoaStringAppDef_oaTrackPattern_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaTrackPattern_assign_doc[] = 
"Class: oaStringAppDef_oaTrackPattern, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaTrackPattern_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaTrackPattern data;
  int convert_status=PyoaStringAppDef_oaTrackPattern_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaTrackPattern p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaTrackPattern_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaTrackPattern_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaTrackPattern_get,METH_VARARGS,oaStringAppDef_oaTrackPattern_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaTrackPattern_getDefault,METH_VARARGS,oaStringAppDef_oaTrackPattern_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaTrackPattern_set,METH_VARARGS,oaStringAppDef_oaTrackPattern_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaTrackPattern_tp_isNull,METH_VARARGS,oaStringAppDef_oaTrackPattern_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaTrackPattern_tp_assign,METH_VARARGS,oaStringAppDef_oaTrackPattern_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaTrackPattern_doc[] = 
"Class: oaStringAppDef_oaTrackPattern\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaTrackPattern)\n"
"    Calls: (const oaStringAppDef_oaTrackPattern&)\n"
"    Signature: oaStringAppDef_oaTrackPattern||cref-oaStringAppDef_oaTrackPattern,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaTrackPattern_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaTrackPattern",
    sizeof(PyoaStringAppDef_oaTrackPatternObject),
    0,
    (destructor)oaStringAppDef_oaTrackPattern_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaTrackPattern_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaTrackPattern_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaTrackPattern_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaTrackPattern_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaTrackPattern_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaTrackPattern_static_find_doc[] = 
"Class: oaStringAppDef_oaTrackPattern, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaTrackPattern* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaTrackPattern|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaTrackPattern* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaTrackPattern|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaTrackPattern_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaTrackPatternp result= (oaStringAppDef_oaTrackPattern::find(p1.Data()));
            return PyoaStringAppDef_oaTrackPattern_FromoaStringAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaTrackPatternp result= (oaStringAppDef_oaTrackPattern::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaTrackPattern_FromoaStringAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaTrackPattern, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaTrackPattern_static_get_doc[] = 
"Class: oaStringAppDef_oaTrackPattern, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaTrackPattern* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaTrackPattern|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaTrackPattern* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaTrackPattern|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaTrackPattern* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaTrackPattern|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaTrackPattern* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaTrackPattern|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaTrackPattern* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaTrackPattern|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaTrackPattern* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaTrackPattern|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaTrackPattern_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaTrackPatternp result= (oaStringAppDef_oaTrackPattern::get(p1.Data()));
            return PyoaStringAppDef_oaTrackPattern_FromoaStringAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaTrackPatternp result= (oaStringAppDef_oaTrackPattern::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaTrackPattern_FromoaStringAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaTrackPatternp result= (oaStringAppDef_oaTrackPattern::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaTrackPattern_FromoaStringAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaTrackPatternp result= (oaStringAppDef_oaTrackPattern::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaTrackPattern_FromoaStringAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaTrackPatternp result= (oaStringAppDef_oaTrackPattern::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaTrackPattern_FromoaStringAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaTrackPatternp result= (oaStringAppDef_oaTrackPattern::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaTrackPattern_FromoaStringAppDef_oaTrackPattern(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaTrackPattern, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaTrackPattern_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaTrackPattern_static_find,METH_VARARGS,oaStringAppDef_oaTrackPattern_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaTrackPattern_static_get,METH_VARARGS,oaStringAppDef_oaTrackPattern_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaTrackPattern_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaTrackPattern_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaTrackPattern\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaTrackPattern",
           (PyObject*)(&PyoaStringAppDef_oaTrackPattern_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaTrackPattern\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaTrackPattern_Type.tp_dict;
    for(method=oaStringAppDef_oaTrackPattern_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaValue
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaValue_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaValue_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaValueObject* self = (PyoaStringAppDef_oaValueObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaValue)
    {
        PyParamoaStringAppDef_oaValue p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaValue_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaValue, Choices are:\n"
        "    (oaStringAppDef_oaValue)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaValue_tp_dealloc(PyoaStringAppDef_oaValueObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaValue_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaValue value;
    int convert_status=PyoaStringAppDef_oaValue_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[44];
    sprintf(buffer,"<oaStringAppDef_oaValue::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaValue_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaValue v1;
    PyParamoaStringAppDef_oaValue v2;
    int convert_status1=PyoaStringAppDef_oaValue_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaValue_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaValue_Convert(PyObject* ob,PyParamoaStringAppDef_oaValue* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaValue_Check(ob)) {
        result->SetData( (oaStringAppDef_oaValue**) ((PyoaStringAppDef_oaValueObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaValue Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaValue_FromoaStringAppDef_oaValue(oaStringAppDef_oaValue** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaValue* data=*value;
        PyObject* bself = PyoaStringAppDef_oaValue_Type.tp_alloc(&PyoaStringAppDef_oaValue_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaValueObject* self = (PyoaStringAppDef_oaValueObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaValue_FromoaStringAppDef_oaValue(oaStringAppDef_oaValue* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaValue_Type.tp_alloc(&PyoaStringAppDef_oaValue_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaValueObject* self = (PyoaStringAppDef_oaValueObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaValue_get_doc[] = 
"Class: oaStringAppDef_oaValue, Function: get\n"
"  Paramegers: (oaValue,oaString)\n"
"    Calls: void get(const oaValue* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaValue,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaValue_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaValue data;
    int convert_status=PyoaStringAppDef_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaValueObject* self=(PyoaStringAppDef_oaValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaValue p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaValue_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaValue_getDefault_doc[] = 
"Class: oaStringAppDef_oaValue, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaValue_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaValue data;
    int convert_status=PyoaStringAppDef_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaValueObject* self=(PyoaStringAppDef_oaValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaValue_set_doc[] = 
"Class: oaStringAppDef_oaValue, Function: set\n"
"  Paramegers: (oaValue,oaString)\n"
"    Calls: void set(oaValue* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaValue,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaValue_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaValue data;
    int convert_status=PyoaStringAppDef_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaValueObject* self=(PyoaStringAppDef_oaValueObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaValue p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaValue_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaValue_isNull_doc[] =
"Class: oaStringAppDef_oaValue, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaValue_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaValue data;
    int convert_status=PyoaStringAppDef_oaValue_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaValue_assign_doc[] = 
"Class: oaStringAppDef_oaValue, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaValue_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaValue data;
  int convert_status=PyoaStringAppDef_oaValue_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaValue p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaValue_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaValue_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaValue_get,METH_VARARGS,oaStringAppDef_oaValue_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaValue_getDefault,METH_VARARGS,oaStringAppDef_oaValue_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaValue_set,METH_VARARGS,oaStringAppDef_oaValue_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaValue_tp_isNull,METH_VARARGS,oaStringAppDef_oaValue_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaValue_tp_assign,METH_VARARGS,oaStringAppDef_oaValue_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaValue_doc[] = 
"Class: oaStringAppDef_oaValue\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaValue)\n"
"    Calls: (const oaStringAppDef_oaValue&)\n"
"    Signature: oaStringAppDef_oaValue||cref-oaStringAppDef_oaValue,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaValue_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaValue",
    sizeof(PyoaStringAppDef_oaValueObject),
    0,
    (destructor)oaStringAppDef_oaValue_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaValue_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaValue_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaValue_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaValue_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaValue_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaValue_static_find_doc[] = 
"Class: oaStringAppDef_oaValue, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaValue* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaValue|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaValue* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaValue|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaValue_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaValuep result= (oaStringAppDef_oaValue::find(p1.Data()));
            return PyoaStringAppDef_oaValue_FromoaStringAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaValuep result= (oaStringAppDef_oaValue::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaValue_FromoaStringAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaValue, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaValue_static_get_doc[] = 
"Class: oaStringAppDef_oaValue, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaValue* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaValue|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaValue* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaValue|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaValue* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaValue|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaValue* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaValue|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaValue* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaValue|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaValue* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaValue|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaValue_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaValuep result= (oaStringAppDef_oaValue::get(p1.Data()));
            return PyoaStringAppDef_oaValue_FromoaStringAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaValuep result= (oaStringAppDef_oaValue::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaValue_FromoaStringAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaValuep result= (oaStringAppDef_oaValue::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaValue_FromoaStringAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaValuep result= (oaStringAppDef_oaValue::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaValue_FromoaStringAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaValuep result= (oaStringAppDef_oaValue::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaValue_FromoaStringAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaValuep result= (oaStringAppDef_oaValue::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaValue_FromoaStringAppDef_oaValue(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaValue, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaValue_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaValue_static_find,METH_VARARGS,oaStringAppDef_oaValue_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaValue_static_get,METH_VARARGS,oaStringAppDef_oaValue_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaValue_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaValue_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaValue\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaValue",
           (PyObject*)(&PyoaStringAppDef_oaValue_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaValue\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaValue_Type.tp_dict;
    for(method=oaStringAppDef_oaValue_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaVectorInstDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaVectorInstDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaVectorInstDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaVectorInstDefObject* self = (PyoaStringAppDef_oaVectorInstDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaVectorInstDef)
    {
        PyParamoaStringAppDef_oaVectorInstDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaVectorInstDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaVectorInstDef, Choices are:\n"
        "    (oaStringAppDef_oaVectorInstDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaVectorInstDef_tp_dealloc(PyoaStringAppDef_oaVectorInstDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaVectorInstDef_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaVectorInstDef value;
    int convert_status=PyoaStringAppDef_oaVectorInstDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[52];
    sprintf(buffer,"<oaStringAppDef_oaVectorInstDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaVectorInstDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaVectorInstDef v1;
    PyParamoaStringAppDef_oaVectorInstDef v2;
    int convert_status1=PyoaStringAppDef_oaVectorInstDef_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaVectorInstDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaVectorInstDef_Convert(PyObject* ob,PyParamoaStringAppDef_oaVectorInstDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaVectorInstDef_Check(ob)) {
        result->SetData( (oaStringAppDef_oaVectorInstDef**) ((PyoaStringAppDef_oaVectorInstDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaVectorInstDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaVectorInstDef_FromoaStringAppDef_oaVectorInstDef(oaStringAppDef_oaVectorInstDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaVectorInstDef* data=*value;
        PyObject* bself = PyoaStringAppDef_oaVectorInstDef_Type.tp_alloc(&PyoaStringAppDef_oaVectorInstDef_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaVectorInstDefObject* self = (PyoaStringAppDef_oaVectorInstDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaVectorInstDef_FromoaStringAppDef_oaVectorInstDef(oaStringAppDef_oaVectorInstDef* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaVectorInstDef_Type.tp_alloc(&PyoaStringAppDef_oaVectorInstDef_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaVectorInstDefObject* self = (PyoaStringAppDef_oaVectorInstDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaVectorInstDef_get_doc[] = 
"Class: oaStringAppDef_oaVectorInstDef, Function: get\n"
"  Paramegers: (oaVectorInstDef,oaString)\n"
"    Calls: void get(const oaVectorInstDef* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaVectorInstDef,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaVectorInstDef_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaVectorInstDef data;
    int convert_status=PyoaStringAppDef_oaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaVectorInstDefObject* self=(PyoaStringAppDef_oaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaVectorInstDef p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaVectorInstDef_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaVectorInstDef_getDefault_doc[] = 
"Class: oaStringAppDef_oaVectorInstDef, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaVectorInstDef_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaVectorInstDef data;
    int convert_status=PyoaStringAppDef_oaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaVectorInstDefObject* self=(PyoaStringAppDef_oaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaVectorInstDef_set_doc[] = 
"Class: oaStringAppDef_oaVectorInstDef, Function: set\n"
"  Paramegers: (oaVectorInstDef,oaString)\n"
"    Calls: void set(oaVectorInstDef* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaVectorInstDef,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaVectorInstDef_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaVectorInstDef data;
    int convert_status=PyoaStringAppDef_oaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaVectorInstDefObject* self=(PyoaStringAppDef_oaVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaVectorInstDef p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaVectorInstDef_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaVectorInstDef_isNull_doc[] =
"Class: oaStringAppDef_oaVectorInstDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaVectorInstDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaVectorInstDef data;
    int convert_status=PyoaStringAppDef_oaVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaVectorInstDef_assign_doc[] = 
"Class: oaStringAppDef_oaVectorInstDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaVectorInstDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaVectorInstDef data;
  int convert_status=PyoaStringAppDef_oaVectorInstDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaVectorInstDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaVectorInstDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaVectorInstDef_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaVectorInstDef_get,METH_VARARGS,oaStringAppDef_oaVectorInstDef_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaVectorInstDef_getDefault,METH_VARARGS,oaStringAppDef_oaVectorInstDef_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaVectorInstDef_set,METH_VARARGS,oaStringAppDef_oaVectorInstDef_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaVectorInstDef_tp_isNull,METH_VARARGS,oaStringAppDef_oaVectorInstDef_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaVectorInstDef_tp_assign,METH_VARARGS,oaStringAppDef_oaVectorInstDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaVectorInstDef_doc[] = 
"Class: oaStringAppDef_oaVectorInstDef\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaVectorInstDef)\n"
"    Calls: (const oaStringAppDef_oaVectorInstDef&)\n"
"    Signature: oaStringAppDef_oaVectorInstDef||cref-oaStringAppDef_oaVectorInstDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaVectorInstDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaVectorInstDef",
    sizeof(PyoaStringAppDef_oaVectorInstDefObject),
    0,
    (destructor)oaStringAppDef_oaVectorInstDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaVectorInstDef_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaVectorInstDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaVectorInstDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaVectorInstDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaVectorInstDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaVectorInstDef_static_find_doc[] = 
"Class: oaStringAppDef_oaVectorInstDef, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaVectorInstDef* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaVectorInstDef|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaVectorInstDef* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaVectorInstDef|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaVectorInstDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaVectorInstDefp result= (oaStringAppDef_oaVectorInstDef::find(p1.Data()));
            return PyoaStringAppDef_oaVectorInstDef_FromoaStringAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaVectorInstDefp result= (oaStringAppDef_oaVectorInstDef::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaVectorInstDef_FromoaStringAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaVectorInstDef, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaVectorInstDef_static_get_doc[] = 
"Class: oaStringAppDef_oaVectorInstDef, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaVectorInstDef* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaVectorInstDef|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaVectorInstDef* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaVectorInstDef|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaVectorInstDef* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaVectorInstDef|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaVectorInstDef* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaVectorInstDef|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaVectorInstDef* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaVectorInstDef|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaVectorInstDef* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaVectorInstDef|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaVectorInstDef_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaVectorInstDefp result= (oaStringAppDef_oaVectorInstDef::get(p1.Data()));
            return PyoaStringAppDef_oaVectorInstDef_FromoaStringAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaVectorInstDefp result= (oaStringAppDef_oaVectorInstDef::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaVectorInstDef_FromoaStringAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaVectorInstDefp result= (oaStringAppDef_oaVectorInstDef::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaVectorInstDef_FromoaStringAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaVectorInstDefp result= (oaStringAppDef_oaVectorInstDef::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaVectorInstDef_FromoaStringAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaVectorInstDefp result= (oaStringAppDef_oaVectorInstDef::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaVectorInstDef_FromoaStringAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaVectorInstDefp result= (oaStringAppDef_oaVectorInstDef::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaVectorInstDef_FromoaStringAppDef_oaVectorInstDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaVectorInstDef, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaVectorInstDef_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaVectorInstDef_static_find,METH_VARARGS,oaStringAppDef_oaVectorInstDef_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaVectorInstDef_static_get,METH_VARARGS,oaStringAppDef_oaVectorInstDef_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaVectorInstDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaVectorInstDef_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaVectorInstDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaVectorInstDef",
           (PyObject*)(&PyoaStringAppDef_oaVectorInstDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaVectorInstDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaVectorInstDef_Type.tp_dict;
    for(method=oaStringAppDef_oaVectorInstDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaVia
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaVia_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaVia_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaViaObject* self = (PyoaStringAppDef_oaViaObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaVia)
    {
        PyParamoaStringAppDef_oaVia p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaVia_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaVia, Choices are:\n"
        "    (oaStringAppDef_oaVia)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaVia_tp_dealloc(PyoaStringAppDef_oaViaObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaVia_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaVia value;
    int convert_status=PyoaStringAppDef_oaVia_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaStringAppDef_oaVia::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaVia_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaVia v1;
    PyParamoaStringAppDef_oaVia v2;
    int convert_status1=PyoaStringAppDef_oaVia_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaVia_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaVia_Convert(PyObject* ob,PyParamoaStringAppDef_oaVia* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaVia_Check(ob)) {
        result->SetData( (oaStringAppDef_oaVia**) ((PyoaStringAppDef_oaViaObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaVia Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaVia_FromoaStringAppDef_oaVia(oaStringAppDef_oaVia** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaVia* data=*value;
        PyObject* bself = PyoaStringAppDef_oaVia_Type.tp_alloc(&PyoaStringAppDef_oaVia_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaViaObject* self = (PyoaStringAppDef_oaViaObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaVia_FromoaStringAppDef_oaVia(oaStringAppDef_oaVia* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaVia_Type.tp_alloc(&PyoaStringAppDef_oaVia_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaViaObject* self = (PyoaStringAppDef_oaViaObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaVia_get_doc[] = 
"Class: oaStringAppDef_oaVia, Function: get\n"
"  Paramegers: (oaVia,oaString)\n"
"    Calls: void get(const oaVia* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaVia,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaVia_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaVia data;
    int convert_status=PyoaStringAppDef_oaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaViaObject* self=(PyoaStringAppDef_oaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaVia p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaVia_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaVia_getDefault_doc[] = 
"Class: oaStringAppDef_oaVia, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaVia_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaVia data;
    int convert_status=PyoaStringAppDef_oaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaViaObject* self=(PyoaStringAppDef_oaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaVia_set_doc[] = 
"Class: oaStringAppDef_oaVia, Function: set\n"
"  Paramegers: (oaVia,oaString)\n"
"    Calls: void set(oaVia* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaVia,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaVia_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaVia data;
    int convert_status=PyoaStringAppDef_oaVia_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaViaObject* self=(PyoaStringAppDef_oaViaObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaVia p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaVia_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaVia_isNull_doc[] =
"Class: oaStringAppDef_oaVia, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaVia_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaVia data;
    int convert_status=PyoaStringAppDef_oaVia_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaVia_assign_doc[] = 
"Class: oaStringAppDef_oaVia, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaVia_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaVia data;
  int convert_status=PyoaStringAppDef_oaVia_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaVia p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaVia_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaVia_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaVia_get,METH_VARARGS,oaStringAppDef_oaVia_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaVia_getDefault,METH_VARARGS,oaStringAppDef_oaVia_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaVia_set,METH_VARARGS,oaStringAppDef_oaVia_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaVia_tp_isNull,METH_VARARGS,oaStringAppDef_oaVia_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaVia_tp_assign,METH_VARARGS,oaStringAppDef_oaVia_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaVia_doc[] = 
"Class: oaStringAppDef_oaVia\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaVia)\n"
"    Calls: (const oaStringAppDef_oaVia&)\n"
"    Signature: oaStringAppDef_oaVia||cref-oaStringAppDef_oaVia,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaVia_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaVia",
    sizeof(PyoaStringAppDef_oaViaObject),
    0,
    (destructor)oaStringAppDef_oaVia_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaVia_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaVia_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaVia_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaVia_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaVia_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaVia_static_find_doc[] = 
"Class: oaStringAppDef_oaVia, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaVia* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaVia|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaVia* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaVia|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaVia_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaViap result= (oaStringAppDef_oaVia::find(p1.Data()));
            return PyoaStringAppDef_oaVia_FromoaStringAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaViap result= (oaStringAppDef_oaVia::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaVia_FromoaStringAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaVia, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaVia_static_get_doc[] = 
"Class: oaStringAppDef_oaVia, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaVia* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaVia|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaVia* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaVia|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaVia* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaVia|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaVia* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaVia|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaVia* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaVia|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaVia* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaVia|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaVia_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaViap result= (oaStringAppDef_oaVia::get(p1.Data()));
            return PyoaStringAppDef_oaVia_FromoaStringAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaViap result= (oaStringAppDef_oaVia::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaVia_FromoaStringAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaViap result= (oaStringAppDef_oaVia::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaVia_FromoaStringAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaViap result= (oaStringAppDef_oaVia::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaVia_FromoaStringAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaViap result= (oaStringAppDef_oaVia::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaVia_FromoaStringAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaViap result= (oaStringAppDef_oaVia::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaVia_FromoaStringAppDef_oaVia(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaVia, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaVia_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaVia_static_find,METH_VARARGS,oaStringAppDef_oaVia_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaVia_static_get,METH_VARARGS,oaStringAppDef_oaVia_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaVia_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaVia_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaVia\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaVia",
           (PyObject*)(&PyoaStringAppDef_oaVia_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaVia\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaVia_Type.tp_dict;
    for(method=oaStringAppDef_oaVia_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaViaDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaViaDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaViaDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaViaDefObject* self = (PyoaStringAppDef_oaViaDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaViaDef)
    {
        PyParamoaStringAppDef_oaViaDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaViaDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaViaDef, Choices are:\n"
        "    (oaStringAppDef_oaViaDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaViaDef_tp_dealloc(PyoaStringAppDef_oaViaDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaViaDef_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaViaDef value;
    int convert_status=PyoaStringAppDef_oaViaDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[45];
    sprintf(buffer,"<oaStringAppDef_oaViaDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaViaDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaViaDef v1;
    PyParamoaStringAppDef_oaViaDef v2;
    int convert_status1=PyoaStringAppDef_oaViaDef_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaViaDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaViaDef_Convert(PyObject* ob,PyParamoaStringAppDef_oaViaDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaViaDef_Check(ob)) {
        result->SetData( (oaStringAppDef_oaViaDef**) ((PyoaStringAppDef_oaViaDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaViaDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaViaDef_FromoaStringAppDef_oaViaDef(oaStringAppDef_oaViaDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaViaDef* data=*value;
        PyObject* bself = PyoaStringAppDef_oaViaDef_Type.tp_alloc(&PyoaStringAppDef_oaViaDef_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaViaDefObject* self = (PyoaStringAppDef_oaViaDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaViaDef_FromoaStringAppDef_oaViaDef(oaStringAppDef_oaViaDef* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaViaDef_Type.tp_alloc(&PyoaStringAppDef_oaViaDef_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaViaDefObject* self = (PyoaStringAppDef_oaViaDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaViaDef_get_doc[] = 
"Class: oaStringAppDef_oaViaDef, Function: get\n"
"  Paramegers: (oaViaDef,oaString)\n"
"    Calls: void get(const oaViaDef* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaViaDef,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaViaDef_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaViaDef data;
    int convert_status=PyoaStringAppDef_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaViaDefObject* self=(PyoaStringAppDef_oaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaDef p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViaDef_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaViaDef_getDefault_doc[] = 
"Class: oaStringAppDef_oaViaDef, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaViaDef_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaViaDef data;
    int convert_status=PyoaStringAppDef_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaViaDefObject* self=(PyoaStringAppDef_oaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaViaDef_set_doc[] = 
"Class: oaStringAppDef_oaViaDef, Function: set\n"
"  Paramegers: (oaViaDef,oaString)\n"
"    Calls: void set(oaViaDef* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaViaDef,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaViaDef_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaViaDef data;
    int convert_status=PyoaStringAppDef_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaViaDefObject* self=(PyoaStringAppDef_oaViaDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaDef p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViaDef_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaViaDef_isNull_doc[] =
"Class: oaStringAppDef_oaViaDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaViaDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaViaDef data;
    int convert_status=PyoaStringAppDef_oaViaDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaViaDef_assign_doc[] = 
"Class: oaStringAppDef_oaViaDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaViaDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaViaDef data;
  int convert_status=PyoaStringAppDef_oaViaDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaViaDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaViaDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaViaDef_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaViaDef_get,METH_VARARGS,oaStringAppDef_oaViaDef_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaViaDef_getDefault,METH_VARARGS,oaStringAppDef_oaViaDef_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaViaDef_set,METH_VARARGS,oaStringAppDef_oaViaDef_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaViaDef_tp_isNull,METH_VARARGS,oaStringAppDef_oaViaDef_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaViaDef_tp_assign,METH_VARARGS,oaStringAppDef_oaViaDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaViaDef_doc[] = 
"Class: oaStringAppDef_oaViaDef\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaViaDef)\n"
"    Calls: (const oaStringAppDef_oaViaDef&)\n"
"    Signature: oaStringAppDef_oaViaDef||cref-oaStringAppDef_oaViaDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaViaDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaViaDef",
    sizeof(PyoaStringAppDef_oaViaDefObject),
    0,
    (destructor)oaStringAppDef_oaViaDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaViaDef_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaViaDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaViaDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaViaDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaViaDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaViaDef_static_find_doc[] = 
"Class: oaStringAppDef_oaViaDef, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaViaDef* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaViaDef|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaViaDef* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaViaDef|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaViaDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaViaDefp result= (oaStringAppDef_oaViaDef::find(p1.Data()));
            return PyoaStringAppDef_oaViaDef_FromoaStringAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaViaDefp result= (oaStringAppDef_oaViaDef::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaViaDef_FromoaStringAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaViaDef, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaViaDef_static_get_doc[] = 
"Class: oaStringAppDef_oaViaDef, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaViaDef* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaViaDef|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaViaDef* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaViaDef|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaViaDef* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaViaDef|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaViaDef* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaViaDef|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaViaDef* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaViaDef|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaViaDef* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaViaDef|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaViaDef_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaViaDefp result= (oaStringAppDef_oaViaDef::get(p1.Data()));
            return PyoaStringAppDef_oaViaDef_FromoaStringAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaViaDefp result= (oaStringAppDef_oaViaDef::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaViaDef_FromoaStringAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaViaDefp result= (oaStringAppDef_oaViaDef::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaViaDef_FromoaStringAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaViaDefp result= (oaStringAppDef_oaViaDef::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaViaDef_FromoaStringAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaViaDefp result= (oaStringAppDef_oaViaDef::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaViaDef_FromoaStringAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaViaDefp result= (oaStringAppDef_oaViaDef::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaViaDef_FromoaStringAppDef_oaViaDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaViaDef, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaViaDef_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaViaDef_static_find,METH_VARARGS,oaStringAppDef_oaViaDef_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaViaDef_static_get,METH_VARARGS,oaStringAppDef_oaViaDef_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaViaDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaViaDef_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaViaDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaViaDef",
           (PyObject*)(&PyoaStringAppDef_oaViaDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaViaDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaViaDef_Type.tp_dict;
    for(method=oaStringAppDef_oaViaDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaViaHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaViaHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaViaHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaViaHeaderObject* self = (PyoaStringAppDef_oaViaHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaViaHeader)
    {
        PyParamoaStringAppDef_oaViaHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaViaHeader_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaViaHeader, Choices are:\n"
        "    (oaStringAppDef_oaViaHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaViaHeader_tp_dealloc(PyoaStringAppDef_oaViaHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaViaHeader_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaViaHeader value;
    int convert_status=PyoaStringAppDef_oaViaHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[48];
    sprintf(buffer,"<oaStringAppDef_oaViaHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaViaHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaViaHeader v1;
    PyParamoaStringAppDef_oaViaHeader v2;
    int convert_status1=PyoaStringAppDef_oaViaHeader_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaViaHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaViaHeader_Convert(PyObject* ob,PyParamoaStringAppDef_oaViaHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaViaHeader_Check(ob)) {
        result->SetData( (oaStringAppDef_oaViaHeader**) ((PyoaStringAppDef_oaViaHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaViaHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaViaHeader_FromoaStringAppDef_oaViaHeader(oaStringAppDef_oaViaHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaViaHeader* data=*value;
        PyObject* bself = PyoaStringAppDef_oaViaHeader_Type.tp_alloc(&PyoaStringAppDef_oaViaHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaViaHeaderObject* self = (PyoaStringAppDef_oaViaHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaViaHeader_FromoaStringAppDef_oaViaHeader(oaStringAppDef_oaViaHeader* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaViaHeader_Type.tp_alloc(&PyoaStringAppDef_oaViaHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaViaHeaderObject* self = (PyoaStringAppDef_oaViaHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaViaHeader_get_doc[] = 
"Class: oaStringAppDef_oaViaHeader, Function: get\n"
"  Paramegers: (oaViaHeader,oaString)\n"
"    Calls: void get(const oaViaHeader* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaViaHeader,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaViaHeader_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaViaHeader data;
    int convert_status=PyoaStringAppDef_oaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaViaHeaderObject* self=(PyoaStringAppDef_oaViaHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaHeader p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViaHeader_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaViaHeader_getDefault_doc[] = 
"Class: oaStringAppDef_oaViaHeader, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaViaHeader_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaViaHeader data;
    int convert_status=PyoaStringAppDef_oaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaViaHeaderObject* self=(PyoaStringAppDef_oaViaHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaViaHeader_set_doc[] = 
"Class: oaStringAppDef_oaViaHeader, Function: set\n"
"  Paramegers: (oaViaHeader,oaString)\n"
"    Calls: void set(oaViaHeader* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaViaHeader,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaViaHeader_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaViaHeader data;
    int convert_status=PyoaStringAppDef_oaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaViaHeaderObject* self=(PyoaStringAppDef_oaViaHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaHeader p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViaHeader_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaViaHeader_isNull_doc[] =
"Class: oaStringAppDef_oaViaHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaViaHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaViaHeader data;
    int convert_status=PyoaStringAppDef_oaViaHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaViaHeader_assign_doc[] = 
"Class: oaStringAppDef_oaViaHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaViaHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaViaHeader data;
  int convert_status=PyoaStringAppDef_oaViaHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaViaHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaViaHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaViaHeader_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaViaHeader_get,METH_VARARGS,oaStringAppDef_oaViaHeader_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaViaHeader_getDefault,METH_VARARGS,oaStringAppDef_oaViaHeader_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaViaHeader_set,METH_VARARGS,oaStringAppDef_oaViaHeader_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaViaHeader_tp_isNull,METH_VARARGS,oaStringAppDef_oaViaHeader_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaViaHeader_tp_assign,METH_VARARGS,oaStringAppDef_oaViaHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaViaHeader_doc[] = 
"Class: oaStringAppDef_oaViaHeader\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaViaHeader)\n"
"    Calls: (const oaStringAppDef_oaViaHeader&)\n"
"    Signature: oaStringAppDef_oaViaHeader||cref-oaStringAppDef_oaViaHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaViaHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaViaHeader",
    sizeof(PyoaStringAppDef_oaViaHeaderObject),
    0,
    (destructor)oaStringAppDef_oaViaHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaViaHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaViaHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaViaHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaViaHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaViaHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaViaHeader_static_find_doc[] = 
"Class: oaStringAppDef_oaViaHeader, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaViaHeader* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaViaHeader|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaViaHeader* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaViaHeader|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaViaHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaViaHeaderp result= (oaStringAppDef_oaViaHeader::find(p1.Data()));
            return PyoaStringAppDef_oaViaHeader_FromoaStringAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaViaHeaderp result= (oaStringAppDef_oaViaHeader::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaViaHeader_FromoaStringAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaViaHeader, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaViaHeader_static_get_doc[] = 
"Class: oaStringAppDef_oaViaHeader, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaViaHeader* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaViaHeader|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaViaHeader* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaViaHeader|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaViaHeader* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaViaHeader|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaViaHeader* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaViaHeader|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaViaHeader* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaViaHeader|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaViaHeader* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaViaHeader|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaViaHeader_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaViaHeaderp result= (oaStringAppDef_oaViaHeader::get(p1.Data()));
            return PyoaStringAppDef_oaViaHeader_FromoaStringAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaViaHeaderp result= (oaStringAppDef_oaViaHeader::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaViaHeader_FromoaStringAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaViaHeaderp result= (oaStringAppDef_oaViaHeader::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaViaHeader_FromoaStringAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaViaHeaderp result= (oaStringAppDef_oaViaHeader::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaViaHeader_FromoaStringAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaViaHeaderp result= (oaStringAppDef_oaViaHeader::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaViaHeader_FromoaStringAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaViaHeaderp result= (oaStringAppDef_oaViaHeader::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaViaHeader_FromoaStringAppDef_oaViaHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaViaHeader, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaViaHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaViaHeader_static_find,METH_VARARGS,oaStringAppDef_oaViaHeader_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaViaHeader_static_get,METH_VARARGS,oaStringAppDef_oaViaHeader_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaViaHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaViaHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaViaHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaViaHeader",
           (PyObject*)(&PyoaStringAppDef_oaViaHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaViaHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaViaHeader_Type.tp_dict;
    for(method=oaStringAppDef_oaViaHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaViaSpec
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaViaSpec_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaViaSpec_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaViaSpecObject* self = (PyoaStringAppDef_oaViaSpecObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaViaSpec)
    {
        PyParamoaStringAppDef_oaViaSpec p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaViaSpec_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaViaSpec, Choices are:\n"
        "    (oaStringAppDef_oaViaSpec)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaViaSpec_tp_dealloc(PyoaStringAppDef_oaViaSpecObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaViaSpec_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaViaSpec value;
    int convert_status=PyoaStringAppDef_oaViaSpec_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[46];
    sprintf(buffer,"<oaStringAppDef_oaViaSpec::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaViaSpec_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaViaSpec v1;
    PyParamoaStringAppDef_oaViaSpec v2;
    int convert_status1=PyoaStringAppDef_oaViaSpec_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaViaSpec_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaViaSpec_Convert(PyObject* ob,PyParamoaStringAppDef_oaViaSpec* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaViaSpec_Check(ob)) {
        result->SetData( (oaStringAppDef_oaViaSpec**) ((PyoaStringAppDef_oaViaSpecObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaViaSpec Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaViaSpec_FromoaStringAppDef_oaViaSpec(oaStringAppDef_oaViaSpec** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaViaSpec* data=*value;
        PyObject* bself = PyoaStringAppDef_oaViaSpec_Type.tp_alloc(&PyoaStringAppDef_oaViaSpec_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaViaSpecObject* self = (PyoaStringAppDef_oaViaSpecObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaViaSpec_FromoaStringAppDef_oaViaSpec(oaStringAppDef_oaViaSpec* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaViaSpec_Type.tp_alloc(&PyoaStringAppDef_oaViaSpec_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaViaSpecObject* self = (PyoaStringAppDef_oaViaSpecObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaViaSpec_get_doc[] = 
"Class: oaStringAppDef_oaViaSpec, Function: get\n"
"  Paramegers: (oaViaSpec,oaString)\n"
"    Calls: void get(const oaViaSpec* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaViaSpec,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaViaSpec_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaViaSpec data;
    int convert_status=PyoaStringAppDef_oaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaViaSpecObject* self=(PyoaStringAppDef_oaViaSpecObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaSpec p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViaSpec_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaViaSpec_getDefault_doc[] = 
"Class: oaStringAppDef_oaViaSpec, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaViaSpec_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaViaSpec data;
    int convert_status=PyoaStringAppDef_oaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaViaSpecObject* self=(PyoaStringAppDef_oaViaSpecObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaViaSpec_set_doc[] = 
"Class: oaStringAppDef_oaViaSpec, Function: set\n"
"  Paramegers: (oaViaSpec,oaString)\n"
"    Calls: void set(oaViaSpec* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaViaSpec,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaViaSpec_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaViaSpec data;
    int convert_status=PyoaStringAppDef_oaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaViaSpecObject* self=(PyoaStringAppDef_oaViaSpecObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViaSpec p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViaSpec_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaViaSpec_isNull_doc[] =
"Class: oaStringAppDef_oaViaSpec, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaViaSpec_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaViaSpec data;
    int convert_status=PyoaStringAppDef_oaViaSpec_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaViaSpec_assign_doc[] = 
"Class: oaStringAppDef_oaViaSpec, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaViaSpec_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaViaSpec data;
  int convert_status=PyoaStringAppDef_oaViaSpec_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaViaSpec p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaViaSpec_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaViaSpec_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaViaSpec_get,METH_VARARGS,oaStringAppDef_oaViaSpec_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaViaSpec_getDefault,METH_VARARGS,oaStringAppDef_oaViaSpec_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaViaSpec_set,METH_VARARGS,oaStringAppDef_oaViaSpec_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaViaSpec_tp_isNull,METH_VARARGS,oaStringAppDef_oaViaSpec_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaViaSpec_tp_assign,METH_VARARGS,oaStringAppDef_oaViaSpec_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaViaSpec_doc[] = 
"Class: oaStringAppDef_oaViaSpec\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaViaSpec)\n"
"    Calls: (const oaStringAppDef_oaViaSpec&)\n"
"    Signature: oaStringAppDef_oaViaSpec||cref-oaStringAppDef_oaViaSpec,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaViaSpec_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaViaSpec",
    sizeof(PyoaStringAppDef_oaViaSpecObject),
    0,
    (destructor)oaStringAppDef_oaViaSpec_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaViaSpec_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaViaSpec_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaViaSpec_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaViaSpec_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaViaSpec_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaViaSpec_static_find_doc[] = 
"Class: oaStringAppDef_oaViaSpec, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaViaSpec* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaViaSpec|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaViaSpec* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaViaSpec|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaViaSpec_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaViaSpecp result= (oaStringAppDef_oaViaSpec::find(p1.Data()));
            return PyoaStringAppDef_oaViaSpec_FromoaStringAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaViaSpecp result= (oaStringAppDef_oaViaSpec::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaViaSpec_FromoaStringAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaViaSpec, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaViaSpec_static_get_doc[] = 
"Class: oaStringAppDef_oaViaSpec, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaViaSpec* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaViaSpec|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaViaSpec* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaViaSpec|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaViaSpec* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaViaSpec|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaViaSpec* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaViaSpec|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaViaSpec* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaViaSpec|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaViaSpec* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaViaSpec|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaViaSpec_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaViaSpecp result= (oaStringAppDef_oaViaSpec::get(p1.Data()));
            return PyoaStringAppDef_oaViaSpec_FromoaStringAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaViaSpecp result= (oaStringAppDef_oaViaSpec::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaViaSpec_FromoaStringAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaViaSpecp result= (oaStringAppDef_oaViaSpec::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaViaSpec_FromoaStringAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaViaSpecp result= (oaStringAppDef_oaViaSpec::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaViaSpec_FromoaStringAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaViaSpecp result= (oaStringAppDef_oaViaSpec::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaViaSpec_FromoaStringAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaViaSpecp result= (oaStringAppDef_oaViaSpec::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaViaSpec_FromoaStringAppDef_oaViaSpec(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaViaSpec, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaViaSpec_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaViaSpec_static_find,METH_VARARGS,oaStringAppDef_oaViaSpec_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaViaSpec_static_get,METH_VARARGS,oaStringAppDef_oaViaSpec_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaViaSpec_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaViaSpec_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaViaSpec\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaViaSpec",
           (PyObject*)(&PyoaStringAppDef_oaViaSpec_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaViaSpec\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaViaSpec_Type.tp_dict;
    for(method=oaStringAppDef_oaViaSpec_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaView
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaView_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaView_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaViewObject* self = (PyoaStringAppDef_oaViewObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaView)
    {
        PyParamoaStringAppDef_oaView p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaView_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaView, Choices are:\n"
        "    (oaStringAppDef_oaView)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaView_tp_dealloc(PyoaStringAppDef_oaViewObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaView_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaView value;
    int convert_status=PyoaStringAppDef_oaView_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaStringAppDef_oaView::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaView_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaView v1;
    PyParamoaStringAppDef_oaView v2;
    int convert_status1=PyoaStringAppDef_oaView_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaView_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaView_Convert(PyObject* ob,PyParamoaStringAppDef_oaView* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaView_Check(ob)) {
        result->SetData( (oaStringAppDef_oaView**) ((PyoaStringAppDef_oaViewObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaView Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaView_FromoaStringAppDef_oaView(oaStringAppDef_oaView** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaView* data=*value;
        PyObject* bself = PyoaStringAppDef_oaView_Type.tp_alloc(&PyoaStringAppDef_oaView_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaViewObject* self = (PyoaStringAppDef_oaViewObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaView_FromoaStringAppDef_oaView(oaStringAppDef_oaView* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaView_Type.tp_alloc(&PyoaStringAppDef_oaView_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaViewObject* self = (PyoaStringAppDef_oaViewObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaView_get_doc[] = 
"Class: oaStringAppDef_oaView, Function: get\n"
"  Paramegers: (oaView,oaString)\n"
"    Calls: void get(const oaView* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaView,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaView_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaView data;
    int convert_status=PyoaStringAppDef_oaView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaViewObject* self=(PyoaStringAppDef_oaViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaView p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaView_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaView_getDefault_doc[] = 
"Class: oaStringAppDef_oaView, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaView_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaView data;
    int convert_status=PyoaStringAppDef_oaView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaViewObject* self=(PyoaStringAppDef_oaViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaView_set_doc[] = 
"Class: oaStringAppDef_oaView, Function: set\n"
"  Paramegers: (oaView,oaString)\n"
"    Calls: void set(oaView* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaView,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaView_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaView data;
    int convert_status=PyoaStringAppDef_oaView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaViewObject* self=(PyoaStringAppDef_oaViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaView p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaView_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaView_isNull_doc[] =
"Class: oaStringAppDef_oaView, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaView_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaView data;
    int convert_status=PyoaStringAppDef_oaView_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaView_assign_doc[] = 
"Class: oaStringAppDef_oaView, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaView_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaView data;
  int convert_status=PyoaStringAppDef_oaView_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaView p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaView_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaView_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaView_get,METH_VARARGS,oaStringAppDef_oaView_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaView_getDefault,METH_VARARGS,oaStringAppDef_oaView_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaView_set,METH_VARARGS,oaStringAppDef_oaView_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaView_tp_isNull,METH_VARARGS,oaStringAppDef_oaView_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaView_tp_assign,METH_VARARGS,oaStringAppDef_oaView_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaView_doc[] = 
"Class: oaStringAppDef_oaView\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaView)\n"
"    Calls: (const oaStringAppDef_oaView&)\n"
"    Signature: oaStringAppDef_oaView||cref-oaStringAppDef_oaView,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaView_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaView",
    sizeof(PyoaStringAppDef_oaViewObject),
    0,
    (destructor)oaStringAppDef_oaView_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaView_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaView_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaView_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaView_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaView_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaView_static_find_doc[] = 
"Class: oaStringAppDef_oaView, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaView* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaView|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaView* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaView|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaView_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaViewp result= (oaStringAppDef_oaView::find(p1.Data()));
            return PyoaStringAppDef_oaView_FromoaStringAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaViewp result= (oaStringAppDef_oaView::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaView_FromoaStringAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaView, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaView_static_get_doc[] = 
"Class: oaStringAppDef_oaView, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaView* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaView|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaView* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaView|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaView* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaView|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaView* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaView|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaView* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaView|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaView* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaView|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaView_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaViewp result= (oaStringAppDef_oaView::get(p1.Data()));
            return PyoaStringAppDef_oaView_FromoaStringAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaViewp result= (oaStringAppDef_oaView::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaView_FromoaStringAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaViewp result= (oaStringAppDef_oaView::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaView_FromoaStringAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaViewp result= (oaStringAppDef_oaView::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaView_FromoaStringAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaViewp result= (oaStringAppDef_oaView::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaView_FromoaStringAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaViewp result= (oaStringAppDef_oaView::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaView_FromoaStringAppDef_oaView(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaView, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaView_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaView_static_find,METH_VARARGS,oaStringAppDef_oaView_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaView_static_get,METH_VARARGS,oaStringAppDef_oaView_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaView_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaView_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaView\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaView",
           (PyObject*)(&PyoaStringAppDef_oaView_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaView\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaView_Type.tp_dict;
    for(method=oaStringAppDef_oaView_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaWafer
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaWafer_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaWafer_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaWaferObject* self = (PyoaStringAppDef_oaWaferObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaWafer)
    {
        PyParamoaStringAppDef_oaWafer p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaWafer_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaWafer, Choices are:\n"
        "    (oaStringAppDef_oaWafer)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaWafer_tp_dealloc(PyoaStringAppDef_oaWaferObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaWafer_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaWafer value;
    int convert_status=PyoaStringAppDef_oaWafer_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[44];
    sprintf(buffer,"<oaStringAppDef_oaWafer::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaWafer_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaWafer v1;
    PyParamoaStringAppDef_oaWafer v2;
    int convert_status1=PyoaStringAppDef_oaWafer_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaWafer_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaWafer_Convert(PyObject* ob,PyParamoaStringAppDef_oaWafer* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaWafer_Check(ob)) {
        result->SetData( (oaStringAppDef_oaWafer**) ((PyoaStringAppDef_oaWaferObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaWafer Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaWafer_FromoaStringAppDef_oaWafer(oaStringAppDef_oaWafer** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaWafer* data=*value;
        PyObject* bself = PyoaStringAppDef_oaWafer_Type.tp_alloc(&PyoaStringAppDef_oaWafer_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaWaferObject* self = (PyoaStringAppDef_oaWaferObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaWafer_FromoaStringAppDef_oaWafer(oaStringAppDef_oaWafer* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaWafer_Type.tp_alloc(&PyoaStringAppDef_oaWafer_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaWaferObject* self = (PyoaStringAppDef_oaWaferObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaWafer_get_doc[] = 
"Class: oaStringAppDef_oaWafer, Function: get\n"
"  Paramegers: (oaWafer,oaString)\n"
"    Calls: void get(const oaWafer* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaWafer,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaWafer_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaWafer data;
    int convert_status=PyoaStringAppDef_oaWafer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaWaferObject* self=(PyoaStringAppDef_oaWaferObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWafer p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaWafer_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaWafer_getDefault_doc[] = 
"Class: oaStringAppDef_oaWafer, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaWafer_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaWafer data;
    int convert_status=PyoaStringAppDef_oaWafer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaWaferObject* self=(PyoaStringAppDef_oaWaferObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaWafer_set_doc[] = 
"Class: oaStringAppDef_oaWafer, Function: set\n"
"  Paramegers: (oaWafer,oaString)\n"
"    Calls: void set(oaWafer* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaWafer,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaWafer_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaWafer data;
    int convert_status=PyoaStringAppDef_oaWafer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaWaferObject* self=(PyoaStringAppDef_oaWaferObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWafer p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaWafer_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaWafer_isNull_doc[] =
"Class: oaStringAppDef_oaWafer, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaWafer_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaWafer data;
    int convert_status=PyoaStringAppDef_oaWafer_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaWafer_assign_doc[] = 
"Class: oaStringAppDef_oaWafer, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaWafer_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaWafer data;
  int convert_status=PyoaStringAppDef_oaWafer_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaWafer p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaWafer_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaWafer_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaWafer_get,METH_VARARGS,oaStringAppDef_oaWafer_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaWafer_getDefault,METH_VARARGS,oaStringAppDef_oaWafer_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaWafer_set,METH_VARARGS,oaStringAppDef_oaWafer_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaWafer_tp_isNull,METH_VARARGS,oaStringAppDef_oaWafer_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaWafer_tp_assign,METH_VARARGS,oaStringAppDef_oaWafer_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaWafer_doc[] = 
"Class: oaStringAppDef_oaWafer\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaWafer)\n"
"    Calls: (const oaStringAppDef_oaWafer&)\n"
"    Signature: oaStringAppDef_oaWafer||cref-oaStringAppDef_oaWafer,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaWafer_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaWafer",
    sizeof(PyoaStringAppDef_oaWaferObject),
    0,
    (destructor)oaStringAppDef_oaWafer_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaWafer_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaWafer_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaWafer_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaWafer_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaWafer_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaWafer_static_find_doc[] = 
"Class: oaStringAppDef_oaWafer, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaWafer* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaWafer|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaWafer* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaWafer|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaWafer_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaWaferp result= (oaStringAppDef_oaWafer::find(p1.Data()));
            return PyoaStringAppDef_oaWafer_FromoaStringAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaWaferp result= (oaStringAppDef_oaWafer::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaWafer_FromoaStringAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaWafer, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaWafer_static_get_doc[] = 
"Class: oaStringAppDef_oaWafer, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaWafer* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaWafer|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaWafer* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaWafer|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaWafer* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaWafer|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaWafer* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaWafer|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaWafer* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaWafer|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaWafer* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaWafer|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaWafer_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaWaferp result= (oaStringAppDef_oaWafer::get(p1.Data()));
            return PyoaStringAppDef_oaWafer_FromoaStringAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaWaferp result= (oaStringAppDef_oaWafer::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaWafer_FromoaStringAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaWaferp result= (oaStringAppDef_oaWafer::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaWafer_FromoaStringAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaWaferp result= (oaStringAppDef_oaWafer::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaWafer_FromoaStringAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaWaferp result= (oaStringAppDef_oaWafer::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaWafer_FromoaStringAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaWaferp result= (oaStringAppDef_oaWafer::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaWafer_FromoaStringAppDef_oaWafer(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaWafer, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaWafer_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaWafer_static_find,METH_VARARGS,oaStringAppDef_oaWafer_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaWafer_static_get,METH_VARARGS,oaStringAppDef_oaWafer_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaWafer_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaWafer_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaWafer\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaWafer",
           (PyObject*)(&PyoaStringAppDef_oaWafer_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaWafer\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaWafer_Type.tp_dict;
    for(method=oaStringAppDef_oaWafer_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaWaferDesc
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaWaferDesc_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaWaferDesc_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaWaferDescObject* self = (PyoaStringAppDef_oaWaferDescObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaWaferDesc)
    {
        PyParamoaStringAppDef_oaWaferDesc p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaWaferDesc_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaWaferDesc, Choices are:\n"
        "    (oaStringAppDef_oaWaferDesc)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaWaferDesc_tp_dealloc(PyoaStringAppDef_oaWaferDescObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaWaferDesc_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaWaferDesc value;
    int convert_status=PyoaStringAppDef_oaWaferDesc_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[48];
    sprintf(buffer,"<oaStringAppDef_oaWaferDesc::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaWaferDesc_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaWaferDesc v1;
    PyParamoaStringAppDef_oaWaferDesc v2;
    int convert_status1=PyoaStringAppDef_oaWaferDesc_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaWaferDesc_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaWaferDesc_Convert(PyObject* ob,PyParamoaStringAppDef_oaWaferDesc* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaWaferDesc_Check(ob)) {
        result->SetData( (oaStringAppDef_oaWaferDesc**) ((PyoaStringAppDef_oaWaferDescObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaWaferDesc Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaWaferDesc_FromoaStringAppDef_oaWaferDesc(oaStringAppDef_oaWaferDesc** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaWaferDesc* data=*value;
        PyObject* bself = PyoaStringAppDef_oaWaferDesc_Type.tp_alloc(&PyoaStringAppDef_oaWaferDesc_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaWaferDescObject* self = (PyoaStringAppDef_oaWaferDescObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaWaferDesc_FromoaStringAppDef_oaWaferDesc(oaStringAppDef_oaWaferDesc* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaWaferDesc_Type.tp_alloc(&PyoaStringAppDef_oaWaferDesc_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaWaferDescObject* self = (PyoaStringAppDef_oaWaferDescObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaWaferDesc_get_doc[] = 
"Class: oaStringAppDef_oaWaferDesc, Function: get\n"
"  Paramegers: (oaWaferDesc,oaString)\n"
"    Calls: void get(const oaWaferDesc* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaWaferDesc,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaWaferDesc_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaWaferDesc data;
    int convert_status=PyoaStringAppDef_oaWaferDesc_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaWaferDescObject* self=(PyoaStringAppDef_oaWaferDescObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWaferDesc p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaWaferDesc_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaWaferDesc_getDefault_doc[] = 
"Class: oaStringAppDef_oaWaferDesc, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaWaferDesc_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaWaferDesc data;
    int convert_status=PyoaStringAppDef_oaWaferDesc_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaWaferDescObject* self=(PyoaStringAppDef_oaWaferDescObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaWaferDesc_set_doc[] = 
"Class: oaStringAppDef_oaWaferDesc, Function: set\n"
"  Paramegers: (oaWaferDesc,oaString)\n"
"    Calls: void set(oaWaferDesc* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaWaferDesc,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaWaferDesc_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaWaferDesc data;
    int convert_status=PyoaStringAppDef_oaWaferDesc_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaWaferDescObject* self=(PyoaStringAppDef_oaWaferDescObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWaferDesc p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaWaferDesc_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaWaferDesc_isNull_doc[] =
"Class: oaStringAppDef_oaWaferDesc, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaWaferDesc_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaWaferDesc data;
    int convert_status=PyoaStringAppDef_oaWaferDesc_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaWaferDesc_assign_doc[] = 
"Class: oaStringAppDef_oaWaferDesc, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaWaferDesc_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaWaferDesc data;
  int convert_status=PyoaStringAppDef_oaWaferDesc_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaWaferDesc p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaWaferDesc_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaWaferDesc_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaWaferDesc_get,METH_VARARGS,oaStringAppDef_oaWaferDesc_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaWaferDesc_getDefault,METH_VARARGS,oaStringAppDef_oaWaferDesc_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaWaferDesc_set,METH_VARARGS,oaStringAppDef_oaWaferDesc_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaWaferDesc_tp_isNull,METH_VARARGS,oaStringAppDef_oaWaferDesc_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaWaferDesc_tp_assign,METH_VARARGS,oaStringAppDef_oaWaferDesc_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaWaferDesc_doc[] = 
"Class: oaStringAppDef_oaWaferDesc\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaWaferDesc)\n"
"    Calls: (const oaStringAppDef_oaWaferDesc&)\n"
"    Signature: oaStringAppDef_oaWaferDesc||cref-oaStringAppDef_oaWaferDesc,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaWaferDesc_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaWaferDesc",
    sizeof(PyoaStringAppDef_oaWaferDescObject),
    0,
    (destructor)oaStringAppDef_oaWaferDesc_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaWaferDesc_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaWaferDesc_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaWaferDesc_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaWaferDesc_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaWaferDesc_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaWaferDesc_static_find_doc[] = 
"Class: oaStringAppDef_oaWaferDesc, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaWaferDesc* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaWaferDesc|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaWaferDesc* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaWaferDesc|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaWaferDesc_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaWaferDescp result= (oaStringAppDef_oaWaferDesc::find(p1.Data()));
            return PyoaStringAppDef_oaWaferDesc_FromoaStringAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaWaferDescp result= (oaStringAppDef_oaWaferDesc::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaWaferDesc_FromoaStringAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaWaferDesc, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaWaferDesc_static_get_doc[] = 
"Class: oaStringAppDef_oaWaferDesc, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaWaferDesc* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaWaferDesc|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaWaferDesc* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaWaferDesc|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaWaferDesc* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaWaferDesc|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaWaferDesc* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaWaferDesc|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaWaferDesc* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaWaferDesc|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaWaferDesc* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaWaferDesc|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaWaferDesc_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaWaferDescp result= (oaStringAppDef_oaWaferDesc::get(p1.Data()));
            return PyoaStringAppDef_oaWaferDesc_FromoaStringAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaWaferDescp result= (oaStringAppDef_oaWaferDesc::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaWaferDesc_FromoaStringAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaWaferDescp result= (oaStringAppDef_oaWaferDesc::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaWaferDesc_FromoaStringAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaWaferDescp result= (oaStringAppDef_oaWaferDesc::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaWaferDesc_FromoaStringAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaWaferDescp result= (oaStringAppDef_oaWaferDesc::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaWaferDesc_FromoaStringAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaWaferDescp result= (oaStringAppDef_oaWaferDesc::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaWaferDesc_FromoaStringAppDef_oaWaferDesc(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaWaferDesc, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaWaferDesc_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaWaferDesc_static_find,METH_VARARGS,oaStringAppDef_oaWaferDesc_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaWaferDesc_static_get,METH_VARARGS,oaStringAppDef_oaWaferDesc_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaWaferDesc_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaWaferDesc_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaWaferDesc\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaWaferDesc",
           (PyObject*)(&PyoaStringAppDef_oaWaferDesc_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaWaferDesc\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaWaferDesc_Type.tp_dict;
    for(method=oaStringAppDef_oaWaferDesc_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringAppDef_oaWaferFeature
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaWaferFeature_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringAppDef_oaWaferFeature_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringAppDef_oaWaferFeatureObject* self = (PyoaStringAppDef_oaWaferFeatureObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringAppDef_oaWaferFeature)
    {
        PyParamoaStringAppDef_oaWaferFeature p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringAppDef_oaWaferFeature_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringAppDef_oaWaferFeature, Choices are:\n"
        "    (oaStringAppDef_oaWaferFeature)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringAppDef_oaWaferFeature_tp_dealloc(PyoaStringAppDef_oaWaferFeatureObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringAppDef_oaWaferFeature_tp_repr(PyObject *ob)
{
    PyParamoaStringAppDef_oaWaferFeature value;
    int convert_status=PyoaStringAppDef_oaWaferFeature_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[51];
    sprintf(buffer,"<oaStringAppDef_oaWaferFeature::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringAppDef_oaWaferFeature_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringAppDef_oaWaferFeature v1;
    PyParamoaStringAppDef_oaWaferFeature v2;
    int convert_status1=PyoaStringAppDef_oaWaferFeature_Convert(ob1,&v1);
    int convert_status2=PyoaStringAppDef_oaWaferFeature_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringAppDef_oaWaferFeature_Convert(PyObject* ob,PyParamoaStringAppDef_oaWaferFeature* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringAppDef_oaWaferFeature_Check(ob)) {
        result->SetData( (oaStringAppDef_oaWaferFeature**) ((PyoaStringAppDef_oaWaferFeatureObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringAppDef_oaWaferFeature Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaWaferFeature_FromoaStringAppDef_oaWaferFeature(oaStringAppDef_oaWaferFeature** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringAppDef_oaWaferFeature* data=*value;
        PyObject* bself = PyoaStringAppDef_oaWaferFeature_Type.tp_alloc(&PyoaStringAppDef_oaWaferFeature_Type,0);
        if (bself == NULL) return bself;
        PyoaStringAppDef_oaWaferFeatureObject* self = (PyoaStringAppDef_oaWaferFeatureObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringAppDef_oaWaferFeature_FromoaStringAppDef_oaWaferFeature(oaStringAppDef_oaWaferFeature* data)
{
    if (data) {
       PyObject* bself = PyoaStringAppDef_oaWaferFeature_Type.tp_alloc(&PyoaStringAppDef_oaWaferFeature_Type,0);
       if (bself == NULL) return bself;
       PyoaStringAppDef_oaWaferFeatureObject* self = (PyoaStringAppDef_oaWaferFeatureObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaWaferFeature_get_doc[] = 
"Class: oaStringAppDef_oaWaferFeature, Function: get\n"
"  Paramegers: (oaWaferFeature,oaString)\n"
"    Calls: void get(const oaWaferFeature* object,oaString& value)\n"
"    Signature: get|void-void|cptr-oaWaferFeature,ref-oaString,\n"
"    This function returns the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaWaferFeature_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaWaferFeature data;
    int convert_status=PyoaStringAppDef_oaWaferFeature_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaWaferFeatureObject* self=(PyoaStringAppDef_oaWaferFeatureObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWaferFeature p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaWaferFeature_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaWaferFeature_getDefault_doc[] = 
"Class: oaStringAppDef_oaWaferFeature, Function: getDefault\n"
"  Paramegers: (oaString)\n"
"    Calls: void getDefault(oaString& value) const\n"
"    Signature: getDefault|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills out the default value for this string extension.\n"
"    value\n"
"    The string to be filled out with the default value\n"
;

static PyObject*
oaStringAppDef_oaWaferFeature_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaWaferFeature data;
    int convert_status=PyoaStringAppDef_oaWaferFeature_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaWaferFeatureObject* self=(PyoaStringAppDef_oaWaferFeatureObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaWaferFeature_set_doc[] = 
"Class: oaStringAppDef_oaWaferFeature, Function: set\n"
"  Paramegers: (oaWaferFeature,oaString)\n"
"    Calls: void set(oaWaferFeature* object,const oaString& value)\n"
"    Signature: set|void-void|ptr-oaWaferFeature,cref-oaString,\n"
"    This function sets the value of this string extension.\n"
"    object\n"
"    The object type with which this extension is associated\n"
"    value\n"
"    The value of the string extension\n"
"    oacInvalidDesignObjectForAppDef\n"
;

static PyObject*
oaStringAppDef_oaWaferFeature_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringAppDef_oaWaferFeature data;
    int convert_status=PyoaStringAppDef_oaWaferFeature_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringAppDef_oaWaferFeatureObject* self=(PyoaStringAppDef_oaWaferFeatureObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaWaferFeature p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaWaferFeature_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaWaferFeature_isNull_doc[] =
"Class: oaStringAppDef_oaWaferFeature, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringAppDef_oaWaferFeature_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringAppDef_oaWaferFeature data;
    int convert_status=PyoaStringAppDef_oaWaferFeature_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringAppDef_oaWaferFeature_assign_doc[] = 
"Class: oaStringAppDef_oaWaferFeature, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringAppDef_oaWaferFeature_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringAppDef_oaWaferFeature data;
  int convert_status=PyoaStringAppDef_oaWaferFeature_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringAppDef_oaWaferFeature p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringAppDef_oaWaferFeature_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringAppDef_oaWaferFeature_methodlist[] = {
    {"get",(PyCFunction)oaStringAppDef_oaWaferFeature_get,METH_VARARGS,oaStringAppDef_oaWaferFeature_get_doc},
    {"getDefault",(PyCFunction)oaStringAppDef_oaWaferFeature_getDefault,METH_VARARGS,oaStringAppDef_oaWaferFeature_getDefault_doc},
    {"set",(PyCFunction)oaStringAppDef_oaWaferFeature_set,METH_VARARGS,oaStringAppDef_oaWaferFeature_set_doc},
    {"isNull",(PyCFunction)oaStringAppDef_oaWaferFeature_tp_isNull,METH_VARARGS,oaStringAppDef_oaWaferFeature_isNull_doc},
    {"assign",(PyCFunction)oaStringAppDef_oaWaferFeature_tp_assign,METH_VARARGS,oaStringAppDef_oaWaferFeature_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaWaferFeature_doc[] = 
"Class: oaStringAppDef_oaWaferFeature\n"
"  The oaStringAppDef class implements an application-specific extension to a particular type of data in a database.\n"
"  When these classes are created, a string field is added to each object of the specified dataType. The default value of the string field is the empty string. Applications can use the new string field for whatever purpose is necessary.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaStringAppDef_oaWaferFeature)\n"
"    Calls: (const oaStringAppDef_oaWaferFeature&)\n"
"    Signature: oaStringAppDef_oaWaferFeature||cref-oaStringAppDef_oaWaferFeature,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringAppDef_oaWaferFeature_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringAppDef_oaWaferFeature",
    sizeof(PyoaStringAppDef_oaWaferFeatureObject),
    0,
    (destructor)oaStringAppDef_oaWaferFeature_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringAppDef_oaWaferFeature_tp_compare,	/* tp_compare */
    (reprfunc)oaStringAppDef_oaWaferFeature_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringAppDef_oaWaferFeature_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringAppDef_oaWaferFeature_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringAppDef_oaWaferFeature_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringAppDef_oaWaferFeature_static_find_doc[] = 
"Class: oaStringAppDef_oaWaferFeature, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaWaferFeature* find(const oaString& name)\n"
"    Signature: find|ptr-oaStringAppDef_oaWaferFeature|cref-oaString,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaWaferFeature* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaStringAppDef_oaWaferFeature|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaStringAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaStringAppDef_oaWaferFeature_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaWaferFeaturep result= (oaStringAppDef_oaWaferFeature::find(p1.Data()));
            return PyoaStringAppDef_oaWaferFeature_FromoaStringAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaWaferFeaturep result= (oaStringAppDef_oaWaferFeature::find(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaWaferFeature_FromoaStringAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaWaferFeature, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringAppDef_oaWaferFeature_static_get_doc[] = 
"Class: oaStringAppDef_oaWaferFeature, Function: get\n"
"  Paramegers: (oaString)\n"
"    Calls: oaStringAppDef_oaWaferFeature* get(const oaString& name)\n"
"    Signature: get|ptr-oaStringAppDef_oaWaferFeature|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaStringAppDef_oaWaferFeature* get(const oaString& name,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaWaferFeature|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaWaferFeature* get(const oaString& name,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaWaferFeature|cref-oaString,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name . You can create a string extension on any object except another extension.\n"
"    name\n"
"    The name given to the oaStringAppDef object\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaStringAppDef_oaWaferFeature* get(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: get|ptr-oaStringAppDef_oaWaferFeature|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString)\n"
"    Calls: oaStringAppDef_oaWaferFeature* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue)\n"
"    Signature: get|ptr-oaStringAppDef_oaWaferFeature|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
"    Calls: oaStringAppDef_oaWaferFeature* get(const oaString& name,const oaAppObjectDef* objDef,const oaString& defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaStringAppDef_oaWaferFeature|cref-oaString,cptr-oaAppObjectDef,cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaStringAppDef class string extension with the specified name for the specified object extension.\n"
"    name\n"
"    The name of the string extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    defValue\n"
"    An optional default value\n"
"    persist\n"
"    Saves the oaStringAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaStringAppDef_oaWaferFeature_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaStringAppDef_oaWaferFeaturep result= (oaStringAppDef_oaWaferFeature::get(p1.Data()));
            return PyoaStringAppDef_oaWaferFeature_FromoaStringAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            oaStringAppDef_oaWaferFeaturep result= (oaStringAppDef_oaWaferFeature::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaWaferFeature_FromoaStringAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaStringAppDef_oaWaferFeaturep result= (oaStringAppDef_oaWaferFeature::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaWaferFeature_FromoaStringAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaWaferFeaturep result= (oaStringAppDef_oaWaferFeature::get(p1.Data(),p2.Data()));
            return PyoaStringAppDef_oaWaferFeature_FromoaStringAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaWaferFeaturep result= (oaStringAppDef_oaWaferFeature::get(p1.Data(),p2.Data(),p3.Data()));
            return PyoaStringAppDef_oaWaferFeature_FromoaStringAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaString p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaStringAppDef_oaWaferFeaturep result= (oaStringAppDef_oaWaferFeature::get(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaStringAppDef_oaWaferFeature_FromoaStringAppDef_oaWaferFeature(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaStringAppDef_oaWaferFeature, function: get, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaString,oaBoolean)\n"
        "    (oaString,oaAppObjectDef)\n"
        "    (oaString,oaAppObjectDef,oaString)\n"
        "    (oaString,oaAppObjectDef,oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringAppDef_oaWaferFeature_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaStringAppDef_oaWaferFeature_static_find,METH_VARARGS,oaStringAppDef_oaWaferFeature_static_find_doc},
    {"static_get",(PyCFunction)oaStringAppDef_oaWaferFeature_static_get,METH_VARARGS,oaStringAppDef_oaWaferFeature_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringAppDef_oaWaferFeature_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringAppDef_oaWaferFeature_Type)<0) {
      printf("** PyType_Ready failed for: oaStringAppDef_oaWaferFeature\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringAppDef_oaWaferFeature",
           (PyObject*)(&PyoaStringAppDef_oaWaferFeature_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringAppDef_oaWaferFeature\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringAppDef_oaWaferFeature_Type.tp_dict;
    for(method=oaStringAppDef_oaWaferFeature_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaStringProp
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaStringProp_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaStringProp_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaStringPropObject* self = (PyoaStringPropObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaStringProp)
    {
        PyParamoaStringProp p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaStringProp_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaStringProp, Choices are:\n"
        "    (oaStringProp)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaStringProp_tp_dealloc(PyoaStringPropObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaStringProp_tp_repr(PyObject *ob)
{
    PyParamoaStringProp value;
    int convert_status=PyoaStringProp_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaStringProp::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaString sresult;
        value.DataCall()->getName(sresult);
    
        char addr[34];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaStringProp::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaStringProp_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaStringProp v1;
    PyParamoaStringProp v2;
    int convert_status1=PyoaStringProp_Convert(ob1,&v1);
    int convert_status2=PyoaStringProp_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaStringProp_Convert(PyObject* ob,PyParamoaStringProp* result)
{
    if (ob == NULL) return 1;
    if (PyoaStringProp_Check(ob)) {
        result->SetData( (oaStringProp**) ((PyoaStringPropObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaStringProp Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaStringProp_FromoaStringProp(oaStringProp** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaStringProp* data=*value;
        PyObject* bself = PyoaStringProp_Type.tp_alloc(&PyoaStringProp_Type,0);
        if (bself == NULL) return bself;
        PyoaStringPropObject* self = (PyoaStringPropObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaStringProp_FromoaStringProp(oaStringProp* data)
{
    if (data) {
       PyObject* bself = PyoaStringProp_Type.tp_alloc(&PyoaStringProp_Type,0);
       if (bself == NULL) return bself;
       PyoaStringPropObject* self = (PyoaStringPropObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringProp_getValue_doc[] = 
"Class: oaStringProp, Function: getValue\n"
"  Paramegers: (oaString)\n"
"    Calls: void getValue(oaString& value) const\n"
"    Signature: getValue|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function returns the value of this property.\n"
;

static PyObject*
oaStringProp_getValue(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringProp data;
    int convert_status=PyoaStringProp_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringPropObject* self=(PyoaStringPropObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getValue(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringProp_setValue_doc[] = 
"Class: oaStringProp, Function: setValue\n"
"  Paramegers: (oaString)\n"
"    Calls: void setValue(const oaString& value)\n"
"    Signature: setValue|void-void|cref-oaString,\n"
"    This function sets this property to the specified value.\n"
;

static PyObject*
oaStringProp_setValue(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaStringProp data;
    int convert_status=PyoaStringProp_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaStringPropObject* self=(PyoaStringPropObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->setValue(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaStringProp_isNull_doc[] =
"Class: oaStringProp, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaStringProp_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaStringProp data;
    int convert_status=PyoaStringProp_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaStringProp_assign_doc[] = 
"Class: oaStringProp, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaStringProp_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaStringProp data;
  int convert_status=PyoaStringProp_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaStringProp p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaStringProp_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaStringProp_methodlist[] = {
    {"getValue",(PyCFunction)oaStringProp_getValue,METH_VARARGS,oaStringProp_getValue_doc},
    {"setValue",(PyCFunction)oaStringProp_setValue,METH_VARARGS,oaStringProp_setValue_doc},
    {"isNull",(PyCFunction)oaStringProp_tp_isNull,METH_VARARGS,oaStringProp_isNull_doc},
    {"assign",(PyCFunction)oaStringProp_tp_assign,METH_VARARGS,oaStringProp_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringProp_doc[] = 
"Class: oaStringProp\n"
"  The oaStringProp is a property that has a string-type value.\n"
"  Properties are application-defined values that can be added to any managed object in oaDesign , oaTech , and oaWafer databases except for the following paged objects: oaDevice , oaNode , oaParasiticNetwork , and oaSubNetwork .\n"
"  To create properties on DM Objects, create the corresponding oaDMData object (using oaLibDMData::open , oaCellDMData::open , oaViewDMData::open , or oaCellViewDMData::open ), then create properties on that oaDMData object.\n"
"  See oaProp for a general discussion of properties.\n"
"Constructors:\n"
"  Paramegers: (oaStringProp)\n"
"    Calls: (const oaStringProp&)\n"
"    Signature: oaStringProp||cref-oaStringProp,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaStringProp_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaStringProp",
    sizeof(PyoaStringPropObject),
    0,
    (destructor)oaStringProp_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaStringProp_tp_compare,	/* tp_compare */
    (reprfunc)oaStringProp_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaStringProp_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaStringProp_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaProp_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaStringProp_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaStringProp_static_create_doc[] = 
"Class: oaStringProp, Function: create\n"
"  Paramegers: (oaObject,oaString,oaString)\n"
"    Calls: oaStringProp* create(oaObject* object,const oaString& name,const oaString& value)\n"
"    Signature: create|ptr-oaStringProp|ptr-oaObject,cref-oaString,cref-oaString,\n"
"    This function creates a string property with the specified attributes. The specified name is checked to verify it is unique for properties on the specified object .\n"
"    object\n"
"    The object to which to attach the property\n"
"    name\n"
"    The property name\n"
"    value\n"
"    The property value\n"
"    A pointer to the oaStringProp\n"
"    oacInvalidObjForProp\n"
"    oacPropNameUsed\n"
;

static PyObject*
oaStringProp_static_create(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObject p1;
    PyParamoaString p2;
    PyParamoaString p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaObject_Convert,&p1,
          &PyoaString_Convert,&p2,
          &PyoaString_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaStringPropp result= (oaStringProp::create(p1.Data(),p2.Data(),p3.Data()));
        return PyoaStringProp_FromoaStringProp(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaStringProp_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaStringProp_static_create,METH_VARARGS,oaStringProp_static_create_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaStringProp_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaStringProp_Type)<0) {
      printf("** PyType_Ready failed for: oaStringProp\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaStringProp",
           (PyObject*)(&PyoaStringProp_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaStringProp\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaStringProp_Type.tp_dict;
    for(method=oaStringProp_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaSubNetwork
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaSubNetwork_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaSubNetwork_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaSubNetworkObject* self = (PyoaSubNetworkObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaSubNetwork)
    {
        PyParamoaSubNetwork p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaSubNetwork_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaSubNetwork, Choices are:\n"
        "    (oaSubNetwork)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaSubNetwork_tp_dealloc(PyoaSubNetworkObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaSubNetwork_tp_repr(PyObject *ob)
{
    PyParamoaSubNetwork value;
    int convert_status=PyoaSubNetwork_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[34];
    sprintf(buffer,"<oaSubNetwork::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaSubNetwork_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaSubNetwork v1;
    PyParamoaSubNetwork v2;
    int convert_status1=PyoaSubNetwork_Convert(ob1,&v1);
    int convert_status2=PyoaSubNetwork_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaSubNetwork_Convert(PyObject* ob,PyParamoaSubNetwork* result)
{
    if (ob == NULL) return 1;
    if (PyoaSubNetwork_Check(ob)) {
        result->SetData( (oaSubNetwork**) ((PyoaSubNetworkObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaSubNetwork Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaSubNetwork_FromoaSubNetwork(oaSubNetwork** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaSubNetwork* data=*value;
        PyObject* bself = PyoaSubNetwork_Type.tp_alloc(&PyoaSubNetwork_Type,0);
        if (bself == NULL) return bself;
        PyoaSubNetworkObject* self = (PyoaSubNetworkObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaSubNetwork_FromoaSubNetwork(oaSubNetwork* data)
{
    if (data) {
       PyObject* bself = PyoaSubNetwork_Type.tp_alloc(&PyoaSubNetwork_Type,0);
       if (bself == NULL) return bself;
       PyoaSubNetworkObject* self = (PyoaSubNetworkObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaSubNetwork_destroy_doc[] = 
"Class: oaSubNetwork, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function destroys this subNetwork. The nodes and devices to which the subNetwork refers are not affected.\n"
;

static PyObject*
oaSubNetwork_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaSubNetwork data;
    int convert_status=PyoaSubNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaSubNetworkObject* self=(PyoaSubNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaSubNetwork_getDevices_doc[] = 
"Class: oaSubNetwork, Function: getDevices\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaDevice_oaSubNetwork getDevices() const\n"
"    Signature: getDevices|simple-oaCollection_oaDevice_oaSubNetwork|\n"
"    BrowseData: 1\n"
"    This function returns a collection containing the devices to which this subNetwork refers.\n"
;

static PyObject*
oaSubNetwork_getDevices(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaSubNetwork data;
    int convert_status=PyoaSubNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaSubNetworkObject* self=(PyoaSubNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaDevice_oaSubNetwork* result= new oaCollection_oaDevice_oaSubNetwork(data.DataCall()->getDevices());
        return PyoaCollection_oaDevice_oaSubNetwork_FromoaCollection_oaDevice_oaSubNetwork(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaSubNetwork_getDevicesIter_doc[] = 
"Class: oaSubNetwork, Function: getDevicesIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaDevice getDevicesIter() const\n"
"    Signature: getDevicesIter|simple-oaIter_oaDevice|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection containing the devices to which this subNetwork refers.\n"
;

static PyObject*
oaSubNetwork_getDevicesIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaSubNetwork data;
    int convert_status=PyoaSubNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaSubNetworkObject* self=(PyoaSubNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaDevice* result= new oaIter_oaDevice(data.DataCall()->getDevices());
        return PyoaIter_oaDevice_FromoaIter_oaDevice(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaSubNetwork_getFig_doc[] = 
"Class: oaSubNetwork, Function: getFig\n"
"  Paramegers: ()\n"
"    Calls: oaFig* getFig() const\n"
"    Signature: getFig|ptr-oaFig|\n"
"    BrowseData: 1\n"
"    This function returns the fig associated with this subNetwork. If this subNetwork is not associated with a fig, NULL is returned.\n"
;

static PyObject*
oaSubNetwork_getFig(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaSubNetwork data;
    int convert_status=PyoaSubNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaSubNetworkObject* self=(PyoaSubNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaFigp result= (data.DataCall()->getFig());
        return PyoaFig_FromoaFig(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaSubNetwork_getName_doc[] = 
"Class: oaSubNetwork, Function: getName\n"
"  Paramegers: (oaString)\n"
"    Calls: void getName(oaString& name) const\n"
"    Signature: getName|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function returns the name of this subNetwork.\n"
;

static PyObject*
oaSubNetwork_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaSubNetwork data;
    int convert_status=PyoaSubNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaSubNetworkObject* self=(PyoaSubNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaSubNetwork_getNodes_doc[] = 
"Class: oaSubNetwork, Function: getNodes\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaNode_oaSubNetwork getNodes() const\n"
"    Signature: getNodes|simple-oaCollection_oaNode_oaSubNetwork|\n"
"    BrowseData: 1\n"
"    This function returns a collection containing the nodes to which this subNetwork refers.\n"
;

static PyObject*
oaSubNetwork_getNodes(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaSubNetwork data;
    int convert_status=PyoaSubNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaSubNetworkObject* self=(PyoaSubNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaNode_oaSubNetwork* result= new oaCollection_oaNode_oaSubNetwork(data.DataCall()->getNodes());
        return PyoaCollection_oaNode_oaSubNetwork_FromoaCollection_oaNode_oaSubNetwork(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaSubNetwork_getNodesIter_doc[] = 
"Class: oaSubNetwork, Function: getNodesIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaNode getNodesIter() const\n"
"    Signature: getNodesIter|simple-oaIter_oaNode|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection containing the nodes to which this subNetwork refers.\n"
;

static PyObject*
oaSubNetwork_getNodesIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaSubNetwork data;
    int convert_status=PyoaSubNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaSubNetworkObject* self=(PyoaSubNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaNode* result= new oaIter_oaNode(data.DataCall()->getNodes());
        return PyoaIter_oaNode_FromoaIter_oaNode(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaSubNetwork_getParasiticNetwork_doc[] = 
"Class: oaSubNetwork, Function: getParasiticNetwork\n"
"  Paramegers: ()\n"
"    Calls: oaParasiticNetwork* getParasiticNetwork() const\n"
"    Signature: getParasiticNetwork|ptr-oaParasiticNetwork|\n"
"    BrowseData: 1\n"
"    This function returns the parasiticNetwork to which this subNetwork belongs.\n"
;

static PyObject*
oaSubNetwork_getParasiticNetwork(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaSubNetwork data;
    int convert_status=PyoaSubNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaSubNetworkObject* self=(PyoaSubNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaParasiticNetworkp result= (data.DataCall()->getParasiticNetwork());
        return PyoaParasiticNetwork_FromoaParasiticNetwork(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaSubNetwork_setFig_doc[] = 
"Class: oaSubNetwork, Function: setFig\n"
"  Paramegers: (oaFig)\n"
"    Calls: void setFig(oaFig* fig)\n"
"    Signature: setFig|void-void|ptr-oaFig,\n"
"    This function sets the fig that this subNetwork represents, which must be a shape or a via.\n"
"    fig\n"
"    The figure to associate with this subNetwork\n"
"    oacObjectNetworkNotInSameDomain\n"
"    oacSubNetworkNotShapeOrVia\n"
;

static PyObject*
oaSubNetwork_setFig(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaSubNetwork data;
    int convert_status=PyoaSubNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaSubNetworkObject* self=(PyoaSubNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaFig p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaFig_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->setFig(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaSubNetwork_setName_doc[] = 
"Class: oaSubNetwork, Function: setName\n"
"  Paramegers: (oaString)\n"
"    Calls: void setName(const oaString& name)\n"
"    Signature: setName|void-void|cref-oaString,\n"
"    This function sets the name of this subNetwork.\n"
"    oacSubNetworkNameExists\n"
;

static PyObject*
oaSubNetwork_setName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaSubNetwork data;
    int convert_status=PyoaSubNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaSubNetworkObject* self=(PyoaSubNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->setName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaSubNetwork_isNull_doc[] =
"Class: oaSubNetwork, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaSubNetwork_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaSubNetwork data;
    int convert_status=PyoaSubNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaSubNetwork_assign_doc[] = 
"Class: oaSubNetwork, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaSubNetwork_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaSubNetwork data;
  int convert_status=PyoaSubNetwork_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaSubNetwork p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaSubNetwork_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaSubNetwork_methodlist[] = {
    {"destroy",(PyCFunction)oaSubNetwork_destroy,METH_VARARGS,oaSubNetwork_destroy_doc},
    {"getDevices",(PyCFunction)oaSubNetwork_getDevices,METH_VARARGS,oaSubNetwork_getDevices_doc},
    {"getDevicesIter",(PyCFunction)oaSubNetwork_getDevicesIter,METH_VARARGS,oaSubNetwork_getDevicesIter_doc},
    {"getFig",(PyCFunction)oaSubNetwork_getFig,METH_VARARGS,oaSubNetwork_getFig_doc},
    {"getName",(PyCFunction)oaSubNetwork_getName,METH_VARARGS,oaSubNetwork_getName_doc},
    {"getNodes",(PyCFunction)oaSubNetwork_getNodes,METH_VARARGS,oaSubNetwork_getNodes_doc},
    {"getNodesIter",(PyCFunction)oaSubNetwork_getNodesIter,METH_VARARGS,oaSubNetwork_getNodesIter_doc},
    {"getParasiticNetwork",(PyCFunction)oaSubNetwork_getParasiticNetwork,METH_VARARGS,oaSubNetwork_getParasiticNetwork_doc},
    {"setFig",(PyCFunction)oaSubNetwork_setFig,METH_VARARGS,oaSubNetwork_setFig_doc},
    {"setName",(PyCFunction)oaSubNetwork_setName,METH_VARARGS,oaSubNetwork_setName_doc},
    {"isNull",(PyCFunction)oaSubNetwork_tp_isNull,METH_VARARGS,oaSubNetwork_isNull_doc},
    {"assign",(PyCFunction)oaSubNetwork_tp_assign,METH_VARARGS,oaSubNetwork_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaSubNetwork_doc[] = 
"Class: oaSubNetwork\n"
"  The oaSubNetwork class identifies a subset of the nodes and devices within a full oaParasiticNetwork .\n"
"  The oaSubNetwork class can be used to represent the relationship between a set of nodes and devices and the corresponding route element or shape. Nodes can appear in multiple subNetworks for such cases as a wire connecting to a via or several wires connecting at an oaSteiner point. Although it is possible for a device to appear in multiple subNetworks, this is generally undesirable because it is not possible to determine what portion of the device's value lies within each subNetwork.\n"
"  When a subNetwork contains multiple nodes and devices, their positions within the corresponding route element or shape can be specified using oaNode::setLocation() .\n"
"  Undo, properties, and groups are not supported for oaSubNetwork. Extensions on oaSubNetwork (and interPointer extensions that refer to an oaSubNetwork) are accessible only while the oaSubNetwork is loaded.\n"
"  The oaSubNetwork class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaSubNetwork)\n"
"    Calls: (const oaSubNetwork&)\n"
"    Signature: oaSubNetwork||cref-oaSubNetwork,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaSubNetwork_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaSubNetwork",
    sizeof(PyoaSubNetworkObject),
    0,
    (destructor)oaSubNetwork_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaSubNetwork_tp_compare,	/* tp_compare */
    (reprfunc)oaSubNetwork_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaSubNetwork_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaSubNetwork_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaDesignObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaSubNetwork_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaSubNetwork_static_create_doc[] = 
"Class: oaSubNetwork, Function: create\n"
"  Paramegers: (oaParasiticNetwork,oaString)\n"
"    Calls: oaSubNetwork* create(oaParasiticNetwork* network,const oaString& name)\n"
"    Signature: create|ptr-oaSubNetwork|ptr-oaParasiticNetwork,cref-oaString,\n"
"    This function creates a subNetwork with the specified name within the specified network . If network is a partition, the subNetwork can only refer to nodes and devices in network or its ancestors.\n"
"    oacSubNetworkNameExists\n"
;

static PyObject*
oaSubNetwork_static_create(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaParasiticNetwork_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaSubNetworkp result= (oaSubNetwork::create(p1.Data(),p2.Data()));
        return PyoaSubNetwork_FromoaSubNetwork(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaSubNetwork_static_find_doc[] = 
"Class: oaSubNetwork, Function: find\n"
"  Paramegers: (oaParasiticNetwork,oaString)\n"
"    Calls: oaSubNetwork* find(const oaParasiticNetwork* network,const oaString& name)\n"
"    Signature: find|ptr-oaSubNetwork|cptr-oaParasiticNetwork,cref-oaString,\n"
"    This function finds and returns the subNetwork with the specified name .\n"
;

static PyObject*
oaSubNetwork_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaParasiticNetwork_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaSubNetworkp result= (oaSubNetwork::find(p1.Data(),p2.Data()));
        return PyoaSubNetwork_FromoaSubNetwork(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaSubNetwork_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaSubNetwork_static_create,METH_VARARGS,oaSubNetwork_static_create_doc},
    {"static_find",(PyCFunction)oaSubNetwork_static_find,METH_VARARGS,oaSubNetwork_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaSubNetwork_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaSubNetwork_Type)<0) {
      printf("** PyType_Ready failed for: oaSubNetwork\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaSubNetwork",
           (PyObject*)(&PyoaSubNetwork_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaSubNetwork\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaSubNetwork_Type.tp_dict;
    for(method=oaSubNetwork_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaSubNetworkModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaSubNetworkModTypeEnum_Convert(PyObject* ob,PyParamoaSubNetworkModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacSetNameSubNetworkModType")==0) { result->SetData(oacSetNameSubNetworkModType); return 1;}
        if (strcasecmp(str,"oacSetFigSubNetworkModType")==0) { result->SetData(oacSetFigSubNetworkModType); return 1;}
        if (strcasecmp(str,"oacAddNodeSubNetworkModType")==0) { result->SetData(oacAddNodeSubNetworkModType); return 1;}
        if (strcasecmp(str,"oacRemoveNodeSubNetworkModType")==0) { result->SetData(oacRemoveNodeSubNetworkModType); return 1;}
        if (strcasecmp(str,"oacAddDeviceSubNetworkModType")==0) { result->SetData(oacAddDeviceSubNetworkModType); return 1;}
        if (strcasecmp(str,"oacRemoveDeviceSubNetworkModType")==0) { result->SetData(oacRemoveDeviceSubNetworkModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaSubNetworkModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaSubNetworkModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaSubNetworkModTypeEnum_FromoaSubNetworkModTypeEnum(oaSubNetworkModTypeEnum ob)
{
    if (ob==oacSetNameSubNetworkModType) return PyString_FromString("oacSetNameSubNetworkModType");
    if (ob==oacSetFigSubNetworkModType) return PyString_FromString("oacSetFigSubNetworkModType");
    if (ob==oacAddNodeSubNetworkModType) return PyString_FromString("oacAddNodeSubNetworkModType");
    if (ob==oacRemoveNodeSubNetworkModType) return PyString_FromString("oacRemoveNodeSubNetworkModType");
    if (ob==oacAddDeviceSubNetworkModType) return PyString_FromString("oacAddDeviceSubNetworkModType");
    if (ob==oacRemoveDeviceSubNetworkModType) return PyString_FromString("oacRemoveDeviceSubNetworkModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaSubNetworkModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaSubNetworkModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaSubNetworkModTypeEnum_FromoaSubNetworkModTypeEnum(oaSubNetworkModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaSubNetworkModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaSubNetworkModTypeEnum_doc[] =
"Type convert function for enum: oaSubNetworkModTypeEnum";
                               
static PyMethodDef PyoaSubNetworkModTypeEnum_method =
  {"oaSubNetworkModTypeEnum",(PyCFunction)PyoaSubNetworkModTypeEnum_TypeFunction,METH_VARARGS,oaSubNetworkModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaSubNetworkModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacSetNameSubNetworkModType");
    PyDict_SetItemString(mod_dict,"oacSetNameSubNetworkModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetFigSubNetworkModType");
    PyDict_SetItemString(mod_dict,"oacSetFigSubNetworkModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAddNodeSubNetworkModType");
    PyDict_SetItemString(mod_dict,"oacAddNodeSubNetworkModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacRemoveNodeSubNetworkModType");
    PyDict_SetItemString(mod_dict,"oacRemoveNodeSubNetworkModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAddDeviceSubNetworkModType");
    PyDict_SetItemString(mod_dict,"oacAddDeviceSubNetworkModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacRemoveDeviceSubNetworkModType");
    PyDict_SetItemString(mod_dict,"oacRemoveDeviceSubNetworkModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaSubNetworkModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaSubNetworkModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaSubNetworkModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaSubset_oaDBType
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaSubset_oaDBType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaSubset_oaDBType_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaSubset_oaDBTypeObject* self = (PyoaSubset_oaDBTypeObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaArrayBase_oaDBType*)  new oaSubset_oaDBType();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaSubset_oaDBType)
    {
        PyParamoaSubset_oaDBType p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaSubset_oaDBType_Convert,&p1)) {
            self->value=(oaArrayBase_oaDBType*)  new oaSubset_oaDBType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaSubset_oaDBType, Choices are:\n"
        "    ()\n"
        "    (oaSubset_oaDBType)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaSubset_oaDBType_tp_dealloc(PyoaSubset_oaDBTypeObject* self)
{
    if (!self->borrow) {
        delete (oaSubset_oaDBType*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaSubset_oaDBType_tp_repr(PyObject *ob)
{
    PyParamoaSubset_oaDBType value;
    int convert_status=PyoaSubset_oaDBType_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[39];
    sprintf(buffer,"<oaSubset_oaDBType::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaSubset_oaDBType_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaSubset_oaDBType v1;
    PyParamoaSubset_oaDBType v2;
    int convert_status1=PyoaSubset_oaDBType_Convert(ob1,&v1);
    int convert_status2=PyoaSubset_oaDBType_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaSubset_oaDBType_Convert(PyObject* ob,PyParamoaSubset_oaDBType* result)
{
    if (ob == NULL) return 1;
    if (PyoaSubset_oaDBType_Check(ob)) {
        result->SetData( (oaSubset_oaDBType*) ((PyoaSubset_oaDBTypeObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaSubset_oaDBType Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaSubset_oaDBType_FromoaSubset_oaDBType(oaSubset_oaDBType* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaSubset_oaDBType_Type.tp_alloc(&PyoaSubset_oaDBType_Type,0);
        if (bself == NULL) return bself;
        PyoaSubset_oaDBTypeObject* self = (PyoaSubset_oaDBTypeObject*)bself;
        self->value = (oaArrayBase_oaDBType*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaSubset_oaDBType_add_doc[] = 
"Class: oaSubset_oaDBType, Function: add\n"
"  Paramegers: (oaDBType)\n"
"    Calls: void add(oaDBType type)\n"
"    Signature: add|void-void|simple-oaDBType,\n"
"    This function adds a type to the subset.\n"
"    type\n"
"    The type of object to add to the subset\n"
;

static PyObject*
oaSubset_oaDBType_add(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaSubset_oaDBType data;
    int convert_status=PyoaSubset_oaDBType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaSubset_oaDBTypeObject* self=(PyoaSubset_oaDBTypeObject*)ob;

    PyParamoaDBType p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaDBType_Convert,&p1)) {
        data.DataCall()->add(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaSubset_oaDBType_includes_doc[] = 
"Class: oaSubset_oaDBType, Function: includes\n"
"  Paramegers: (oaDBType)\n"
"    Calls: oaBoolean includes(oaDBType type) const\n"
"    Signature: includes|simple-oaBoolean|simple-oaDBType,\n"
"    This function returns a boolean indicating whether or not the subset includes an object of the specified type.\n"
"    type\n"
"    The type of object to search for\n"
;

static PyObject*
oaSubset_oaDBType_includes(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaSubset_oaDBType data;
    int convert_status=PyoaSubset_oaDBType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaSubset_oaDBTypeObject* self=(PyoaSubset_oaDBTypeObject*)ob;

    PyParamoaDBType p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaDBType_Convert,&p1)) {
        oaBoolean result= (data.DataCall()->includes(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaSubset_oaDBType_assign_doc[] = 
"Class: oaSubset_oaDBType, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaSubset_oaDBType_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaSubset_oaDBType data;
  int convert_status=PyoaSubset_oaDBType_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaSubset_oaDBType p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaSubset_oaDBType_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaSubset_oaDBType_methodlist[] = {
    {"add",(PyCFunction)oaSubset_oaDBType_add,METH_VARARGS,oaSubset_oaDBType_add_doc},
    {"includes",(PyCFunction)oaSubset_oaDBType_includes,METH_VARARGS,oaSubset_oaDBType_includes_doc},
    {"assign",(PyCFunction)oaSubset_oaDBType_tp_assign,METH_VARARGS,oaSubset_oaDBType_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaSubset_oaDBType_doc[] = 
"Class: oaSubset_oaDBType\n"
"  This class is a form of array that is stored in a sorted order to allow fast lookup of its elements. It is used to hold a set of oaType values that can be supplied to an oaConstraintDef to specify the legal classes that the constraint can work with -- see oaLayerConstraintDef::oaLayerConstraintDef for an example of its usage.\n"
"  The classes used in an oaSubset must be legal for comparison with the built-in C++ comparison operators such as '<'.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaSubset_oaDBType()\n"
"    Signature: oaSubset_oaDBType||\n"
"    This function creates an empty subset object.\n"
"  Paramegers: (oaSubset_oaDBType)\n"
"    Calls: (const oaSubset_oaDBType&)\n"
"    Signature: oaSubset_oaDBType||cref-oaSubset_oaDBType,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaSubset_oaDBType_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaSubset_oaDBType",
    sizeof(PyoaSubset_oaDBTypeObject),
    0,
    (destructor)oaSubset_oaDBType_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaSubset_oaDBType_tp_compare,	/* tp_compare */
    (reprfunc)oaSubset_oaDBType_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaSubset_oaDBType_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaSubset_oaDBType_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaArray_oaDBType_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaSubset_oaDBType_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaSubset_oaDBType_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaSubset_oaDBType_Type)<0) {
      printf("** PyType_Ready failed for: oaSubset_oaDBType\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaSubset_oaDBType",
           (PyObject*)(&PyoaSubset_oaDBType_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaSubset_oaDBType\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaSubset_oaType
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaSubset_oaType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaSubset_oaType_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaSubset_oaTypeObject* self = (PyoaSubset_oaTypeObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaArrayBase_oaType*)  new oaSubset_oaType();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaSubset_oaType)
    {
        PyParamoaSubset_oaType p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaSubset_oaType_Convert,&p1)) {
            self->value=(oaArrayBase_oaType*)  new oaSubset_oaType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaSubset_oaType, Choices are:\n"
        "    ()\n"
        "    (oaSubset_oaType)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaSubset_oaType_tp_dealloc(PyoaSubset_oaTypeObject* self)
{
    if (!self->borrow) {
        delete (oaSubset_oaType*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaSubset_oaType_tp_repr(PyObject *ob)
{
    PyParamoaSubset_oaType value;
    int convert_status=PyoaSubset_oaType_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[37];
    sprintf(buffer,"<oaSubset_oaType::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaSubset_oaType_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaSubset_oaType v1;
    PyParamoaSubset_oaType v2;
    int convert_status1=PyoaSubset_oaType_Convert(ob1,&v1);
    int convert_status2=PyoaSubset_oaType_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaSubset_oaType_Convert(PyObject* ob,PyParamoaSubset_oaType* result)
{
    if (ob == NULL) return 1;
    if (PyoaSubset_oaType_Check(ob)) {
        result->SetData( (oaSubset_oaType*) ((PyoaSubset_oaTypeObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaSubset_oaType Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaSubset_oaType_FromoaSubset_oaType(oaSubset_oaType* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaSubset_oaType_Type.tp_alloc(&PyoaSubset_oaType_Type,0);
        if (bself == NULL) return bself;
        PyoaSubset_oaTypeObject* self = (PyoaSubset_oaTypeObject*)bself;
        self->value = (oaArrayBase_oaType*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaSubset_oaType_add_doc[] = 
"Class: oaSubset_oaType, Function: add\n"
"  Paramegers: (oaType)\n"
"    Calls: void add(oaType type)\n"
"    Signature: add|void-void|simple-oaType,\n"
"    This function adds a type to the subset.\n"
"    type\n"
"    The type of object to add to the subset\n"
;

static PyObject*
oaSubset_oaType_add(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaSubset_oaType data;
    int convert_status=PyoaSubset_oaType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaSubset_oaTypeObject* self=(PyoaSubset_oaTypeObject*)ob;

    PyParamoaType p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaType_Convert,&p1)) {
        data.DataCall()->add(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaSubset_oaType_includes_doc[] = 
"Class: oaSubset_oaType, Function: includes\n"
"  Paramegers: (oaType)\n"
"    Calls: oaBoolean includes(oaType type) const\n"
"    Signature: includes|simple-oaBoolean|simple-oaType,\n"
"    This function returns a boolean indicating whether or not the subset includes an object of the specified type.\n"
"    type\n"
"    The type of object to search for\n"
;

static PyObject*
oaSubset_oaType_includes(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaSubset_oaType data;
    int convert_status=PyoaSubset_oaType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaSubset_oaTypeObject* self=(PyoaSubset_oaTypeObject*)ob;

    PyParamoaType p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaType_Convert,&p1)) {
        oaBoolean result= (data.DataCall()->includes(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaSubset_oaType_assign_doc[] = 
"Class: oaSubset_oaType, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaSubset_oaType_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaSubset_oaType data;
  int convert_status=PyoaSubset_oaType_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaSubset_oaType p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaSubset_oaType_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaSubset_oaType_methodlist[] = {
    {"add",(PyCFunction)oaSubset_oaType_add,METH_VARARGS,oaSubset_oaType_add_doc},
    {"includes",(PyCFunction)oaSubset_oaType_includes,METH_VARARGS,oaSubset_oaType_includes_doc},
    {"assign",(PyCFunction)oaSubset_oaType_tp_assign,METH_VARARGS,oaSubset_oaType_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaSubset_oaType_doc[] = 
"Class: oaSubset_oaType\n"
"  This class is a form of array that is stored in a sorted order to allow fast lookup of its elements. It is used to hold a set of oaType values that can be supplied to an oaConstraintDef to specify the legal classes that the constraint can work with -- see oaLayerConstraintDef::oaLayerConstraintDef for an example of its usage.\n"
"  The classes used in an oaSubset must be legal for comparison with the built-in C++ comparison operators such as '<'.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaSubset_oaType()\n"
"    Signature: oaSubset_oaType||\n"
"    This function creates an empty subset object.\n"
"  Paramegers: (oaSubset_oaType)\n"
"    Calls: (const oaSubset_oaType&)\n"
"    Signature: oaSubset_oaType||cref-oaSubset_oaType,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaSubset_oaType_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaSubset_oaType",
    sizeof(PyoaSubset_oaTypeObject),
    0,
    (destructor)oaSubset_oaType_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaSubset_oaType_tp_compare,	/* tp_compare */
    (reprfunc)oaSubset_oaType_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaSubset_oaType_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaSubset_oaType_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaArray_oaType_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaSubset_oaType_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaSubset_oaType_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaSubset_oaType_Type)<0) {
      printf("** PyType_Ready failed for: oaSubset_oaType\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaSubset_oaType",
           (PyObject*)(&PyoaSubset_oaType_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaSubset_oaType\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaSymmetry
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaSymmetry_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaSymmetry_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaSymmetryObject* self = (PyoaSymmetryObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaSymmetryEnum)
    {
        PyParamoaSymmetryEnum p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSymmetryEnum_Convert,&p1)) {
            self->value =  new oaSymmetry(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            self->value =  new oaSymmetry(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaSymmetry)
    {
        PyParamoaSymmetry p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaSymmetry_Convert,&p1)) {
            self->value= new oaSymmetry(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaSymmetry, Choices are:\n"
        "    (oaSymmetryEnum)\n"
        "    (oaString)\n"
        "    (oaSymmetry)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaSymmetry_tp_dealloc(PyoaSymmetryObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaSymmetry_tp_repr(PyObject *ob)
{
    PyParamoaSymmetry value;
    int convert_status=PyoaSymmetry_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    oaString sresult(value.DataCall()->getName());

    char addr[32];
    sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
    oaString buffer;
    buffer+=oaString("<oaSymmetry::");
    buffer+=oaString(addr);
    buffer+=oaString("::");
    buffer+=oaString(sresult);
    buffer+=oaString(">");
    result=PyString_FromString((char*)(const char*)buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaSymmetry_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaSymmetry v1;
    PyParamoaSymmetry v2;
    int convert_status1=PyoaSymmetry_Convert(ob1,&v1);
    int convert_status2=PyoaSymmetry_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaSymmetry_Convert(PyObject* ob,PyParamoaSymmetry* result)
{
    if (ob == NULL) return 1;
    if (PyoaSymmetry_Check(ob)) {
        result->SetData(  ((PyoaSymmetryObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaSymmetry Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaSymmetry_FromoaSymmetry(oaSymmetry* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaSymmetry_Type.tp_alloc(&PyoaSymmetry_Type,0);
        if (bself == NULL) return bself;
        PyoaSymmetryObject* self = (PyoaSymmetryObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaSymmetry_getName_doc[] = 
"Class: oaSymmetry, Function: getName\n"
"  Paramegers: ()\n"
"    Calls: const oaString& getName() const\n"
"    Signature: getName|cref-oaString|\n"
"    BrowseData: 1\n"
"    This function returns the name string associated with the encapsulated #oaSymmetryEnum object.\n"
;

static PyObject*
oaSymmetry_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaSymmetry data;
    int convert_status=PyoaSymmetry_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaSymmetryObject* self=(PyoaSymmetryObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaString result= (data.DataCall()->getName());
        return PyoaString_FromoaString(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaSymmetry_oaSymmetryEnum_doc[] = 
"Class: oaSymmetry, Function: oaSymmetryEnum\n"
"  Paramegers: ()\n"
"    Calls: oaSymmetryEnum oaSymmetryEnum() const\n"
"    Signature: operator oaSymmetryEnum|simple-oaSymmetryEnum|\n"
"    BrowseData: 1\n"
"    This operator casts this oaSymmetry object into the corresponding #oaSymmetryEnum value.\n"
;

static PyObject*
oaSymmetry_oaSymmetryEnum(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaSymmetry data;
    int convert_status=PyoaSymmetry_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaSymmetryObject* self=(PyoaSymmetryObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaSymmetryEnum result= (data.DataCall()->operator oaSymmetryEnum());
        return PyoaSymmetryEnum_FromoaSymmetryEnum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaSymmetry_assign_doc[] = 
"Class: oaSymmetry, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaSymmetry_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaSymmetry data;
  int convert_status=PyoaSymmetry_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaSymmetry p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaSymmetry_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaSymmetry_methodlist[] = {
    {"getName",(PyCFunction)oaSymmetry_getName,METH_VARARGS,oaSymmetry_getName_doc},
    {"oaSymmetryEnum",(PyCFunction)oaSymmetry_oaSymmetryEnum,METH_VARARGS,oaSymmetry_oaSymmetryEnum_doc},
    {"assign",(PyCFunction)oaSymmetry_tp_assign,METH_VARARGS,oaSymmetry_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaSymmetry_doc[] = 
"Class: oaSymmetry\n"
"  The oaSymmetry class encapsulates the enumerated values that describe the different symmetries of an oaDesign object.\n"
"  oaSymmetryEnum\n"
"Constructors:\n"
"  Paramegers: (oaSymmetryEnum)\n"
"    Calls: oaSymmetry(oaSymmetryEnum valueIn)\n"
"    Signature: oaSymmetry||simple-oaSymmetryEnum,\n"
"    This function constructs an instance of an oaSymmetry class using the specified enum value. The enum values are defined in #oaSymmetryEnum.\n"
"  Paramegers: (oaString)\n"
"    Calls: oaSymmetry(const oaString& name)\n"
"    Signature: oaSymmetry||cref-oaString,\n"
"    This function constructs an instance of an oaSymmetry class using the #oaSymmetryEnum associated with the specified string name . This name must be defined in the legal set of names associated with #oaSymmetryEnum.\n"
"    oacInvalidSymmetryName\n"
"  Paramegers: (oaSymmetry)\n"
"    Calls: (const oaSymmetry&)\n"
"    Signature: oaSymmetry||cref-oaSymmetry,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaSymmetry_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaSymmetry",
    sizeof(PyoaSymmetryObject),
    0,
    (destructor)oaSymmetry_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaSymmetry_tp_compare,	/* tp_compare */
    (reprfunc)oaSymmetry_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaSymmetry_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaSymmetry_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaSymmetry_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaSymmetry_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaSymmetry_Type)<0) {
      printf("** PyType_Ready failed for: oaSymmetry\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaSymmetry",
           (PyObject*)(&PyoaSymmetry_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaSymmetry\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaSymmetryEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaSymmetryEnum_Convert(PyObject* ob,PyParamoaSymmetryEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacNoSymmetry")==0) { result->SetData(oacNoSymmetry); return 1;}
        if (strcasecmp(str,"oacXSymmetry")==0) { result->SetData(oacXSymmetry); return 1;}
        if (strcasecmp(str,"oacYSymmetry")==0) { result->SetData(oacYSymmetry); return 1;}
        if (strcasecmp(str,"oacXYSymmetry")==0) { result->SetData(oacXYSymmetry); return 1;}
        if (strcasecmp(str,"oacAnySymmetry")==0) { result->SetData(oacAnySymmetry); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaSymmetryEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaSymmetryEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaSymmetryEnum_FromoaSymmetryEnum(oaSymmetryEnum ob)
{
    if (ob==oacNoSymmetry) return PyString_FromString("oacNoSymmetry");
    if (ob==oacXSymmetry) return PyString_FromString("oacXSymmetry");
    if (ob==oacYSymmetry) return PyString_FromString("oacYSymmetry");
    if (ob==oacXYSymmetry) return PyString_FromString("oacXYSymmetry");
    if (ob==oacAnySymmetry) return PyString_FromString("oacAnySymmetry");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaSymmetryEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaSymmetryEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaSymmetryEnum_FromoaSymmetryEnum(oaSymmetryEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaSymmetryEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaSymmetryEnum_doc[] =
"Type convert function for enum: oaSymmetryEnum";
                               
static PyMethodDef PyoaSymmetryEnum_method =
  {"oaSymmetryEnum",(PyCFunction)PyoaSymmetryEnum_TypeFunction,METH_VARARGS,oaSymmetryEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaSymmetryEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacNoSymmetry");
    PyDict_SetItemString(mod_dict,"oacNoSymmetry",value);
    Py_DECREF(value);
    value=PyString_FromString("oacXSymmetry");
    PyDict_SetItemString(mod_dict,"oacXSymmetry",value);
    Py_DECREF(value);
    value=PyString_FromString("oacYSymmetry");
    PyDict_SetItemString(mod_dict,"oacYSymmetry",value);
    Py_DECREF(value);
    value=PyString_FromString("oacXYSymmetry");
    PyDict_SetItemString(mod_dict,"oacXYSymmetry",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAnySymmetry");
    PyDict_SetItemString(mod_dict,"oacAnySymmetry",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaSymmetryEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaSymmetryEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaSymmetryEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaSystemTime
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaSystemTime_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaSystemTime_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaSystemTimeObject* self = (PyoaSystemTimeObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaSystemTime();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaSystemTime)
    {
        PyParamoaSystemTime p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaSystemTime_Convert,&p1)) {
            self->value= new oaSystemTime(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaSystemTime, Choices are:\n"
        "    ()\n"
        "    (oaSystemTime)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaSystemTime_tp_dealloc(PyoaSystemTimeObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaSystemTime_tp_repr(PyObject *ob)
{
    PyParamoaSystemTime value;
    int convert_status=PyoaSystemTime_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[34];
    sprintf(buffer,"<oaSystemTime::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaSystemTime_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaSystemTime v1;
    PyParamoaSystemTime v2;
    int convert_status1=PyoaSystemTime_Convert(ob1,&v1);
    int convert_status2=PyoaSystemTime_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaSystemTime_Convert(PyObject* ob,PyParamoaSystemTime* result)
{
    if (ob == NULL) return 1;
    if (PyoaSystemTime_Check(ob)) {
        result->SetData(  ((PyoaSystemTimeObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaSystemTime Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaSystemTime_FromoaSystemTime(oaSystemTime* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaSystemTime_Type.tp_alloc(&PyoaSystemTime_Type,0);
        if (bself == NULL) return bself;
        PyoaSystemTimeObject* self = (PyoaSystemTimeObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaSystemTime_getCurrentTime_doc[] = 
"Class: oaSystemTime, Function: getCurrentTime\n"
"  Paramegers: ()\n"
"    Calls: void getCurrentTime()\n"
"    Signature: getCurrentTime|void-void|\n"
"    BrowseData: 0\n"
"    This function loads the systemTime object with the current time.\n"
;

static PyObject*
oaSystemTime_getCurrentTime(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaSystemTime data;
    int convert_status=PyoaSystemTime_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaSystemTimeObject* self=(PyoaSystemTimeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->getCurrentTime();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaSystemTime_getDay_doc[] = 
"Class: oaSystemTime, Function: getDay\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getDay() const\n"
"    Signature: getDay|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the day-of-month portion of the current time as a value between 1 and 31.\n"
;

static PyObject*
oaSystemTime_getDay(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaSystemTime data;
    int convert_status=PyoaSystemTime_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaSystemTimeObject* self=(PyoaSystemTimeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getDay());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaSystemTime_getHour_doc[] = 
"Class: oaSystemTime, Function: getHour\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getHour() const\n"
"    Signature: getHour|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the hour-of-day portion of the current time as a value between 0 and 23, specified as the number of hours past midnight.\n"
;

static PyObject*
oaSystemTime_getHour(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaSystemTime data;
    int convert_status=PyoaSystemTime_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaSystemTimeObject* self=(PyoaSystemTimeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getHour());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaSystemTime_getMinute_doc[] = 
"Class: oaSystemTime, Function: getMinute\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getMinute() const\n"
"    Signature: getMinute|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the minute-of-hour portion of the current time as a value between 0 and 59.\n"
;

static PyObject*
oaSystemTime_getMinute(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaSystemTime data;
    int convert_status=PyoaSystemTime_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaSystemTimeObject* self=(PyoaSystemTimeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getMinute());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaSystemTime_getMonth_doc[] = 
"Class: oaSystemTime, Function: getMonth\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getMonth() const\n"
"    Signature: getMonth|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the month-of-year portion of the current time as a value between 1 and 12.\n"
;

static PyObject*
oaSystemTime_getMonth(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaSystemTime data;
    int convert_status=PyoaSystemTime_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaSystemTimeObject* self=(PyoaSystemTimeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getMonth());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaSystemTime_getSecond_doc[] = 
"Class: oaSystemTime, Function: getSecond\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSecond() const\n"
"    Signature: getSecond|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the seconds-of-minute portion of the current time normally as a value between 0 and 59 but allowing for 60 and 61 when leap seconds are present.\n"
;

static PyObject*
oaSystemTime_getSecond(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaSystemTime data;
    int convert_status=PyoaSystemTime_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaSystemTimeObject* self=(PyoaSystemTimeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSecond());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaSystemTime_getYear_doc[] = 
"Class: oaSystemTime, Function: getYear\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getYear() const\n"
"    Signature: getYear|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the year portion of the current time. The year is supplied AD (thus 1900 AD is returned as 1900 and not as 0).\n"
;

static PyObject*
oaSystemTime_getYear(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaSystemTime data;
    int convert_status=PyoaSystemTime_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaSystemTimeObject* self=(PyoaSystemTimeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getYear());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaSystemTime_assign_doc[] = 
"Class: oaSystemTime, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaSystemTime_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaSystemTime data;
  int convert_status=PyoaSystemTime_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaSystemTime p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaSystemTime_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaSystemTime_methodlist[] = {
    {"getCurrentTime",(PyCFunction)oaSystemTime_getCurrentTime,METH_VARARGS,oaSystemTime_getCurrentTime_doc},
    {"getDay",(PyCFunction)oaSystemTime_getDay,METH_VARARGS,oaSystemTime_getDay_doc},
    {"getHour",(PyCFunction)oaSystemTime_getHour,METH_VARARGS,oaSystemTime_getHour_doc},
    {"getMinute",(PyCFunction)oaSystemTime_getMinute,METH_VARARGS,oaSystemTime_getMinute_doc},
    {"getMonth",(PyCFunction)oaSystemTime_getMonth,METH_VARARGS,oaSystemTime_getMonth_doc},
    {"getSecond",(PyCFunction)oaSystemTime_getSecond,METH_VARARGS,oaSystemTime_getSecond_doc},
    {"getYear",(PyCFunction)oaSystemTime_getYear,METH_VARARGS,oaSystemTime_getYear_doc},
    {"assign",(PyCFunction)oaSystemTime_tp_assign,METH_VARARGS,oaSystemTime_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaSystemTime_doc[] = 
"Class: oaSystemTime\n"
"  oaSystemTime is a utility class that implements a systemTime object. systemTime is stored by year, month, day, hour, minute, and second.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaSystemTime()\n"
"    Signature: oaSystemTime||\n"
"    This is the constructor for the oaSystemTime object. All time values are set to 0.\n"
"  Paramegers: (oaSystemTime)\n"
"    Calls: (const oaSystemTime&)\n"
"    Signature: oaSystemTime||cref-oaSystemTime,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaSystemTime_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaSystemTime",
    sizeof(PyoaSystemTimeObject),
    0,
    (destructor)oaSystemTime_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaSystemTime_tp_compare,	/* tp_compare */
    (reprfunc)oaSystemTime_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaSystemTime_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaSystemTime_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaSystemTime_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaSystemTime_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaSystemTime_Type)<0) {
      printf("** PyType_Ready failed for: oaSystemTime\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaSystemTime",
           (PyObject*)(&PyoaSystemTime_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaSystemTime\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaTech
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaTech_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaTech_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaTechObject* self = (PyoaTechObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaTech)
    {
        PyParamoaTech p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaTech_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaTech, Choices are:\n"
        "    (oaTech)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaTech_tp_dealloc(PyoaTechObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaTech_tp_repr(PyObject *ob)
{
    PyParamoaTech value;
    int convert_status=PyoaTech_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaTech::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaString sresult;
        oaString sep=" ";
        sep[(oaUInt4)0]=oacInternalHierDelimiter;
        oaScalarName name;
        oaString str;
        value.DataCall()->getLibName(name);
        name.get(str);
        sresult+=oaString(str);
    
        char addr[28];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaTech::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaTech_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaTech v1;
    PyParamoaTech v2;
    int convert_status1=PyoaTech_Convert(ob1,&v1);
    int convert_status2=PyoaTech_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaTech_Convert(PyObject* ob,PyParamoaTech* result)
{
    if (ob == NULL) return 1;
    if (PyoaTech_Check(ob)) {
        result->SetData( (oaTech**) ((PyoaTechObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaTech Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaTech_FromoaTech(oaTech** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaTech* data=*value;
        PyObject* bself = PyoaTech_Type.tp_alloc(&PyoaTech_Type,0);
        if (bself == NULL) return bself;
        PyoaTechObject* self = (PyoaTechObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaTech_FromoaTech(oaTech* data)
{
    if (data) {
       PyObject* bself = PyoaTech_Type.tp_alloc(&PyoaTech_Type,0);
       if (bself == NULL) return bself;
       PyoaTechObject* self = (PyoaTechObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaTech_calcVMSize_doc[] = 
"Class: oaTech, Function: calcVMSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt8 calcVMSize() const\n"
"    Signature: calcVMSize|simple-oaUInt8|\n"
"    BrowseData: 1\n"
"    This function calculates and returns the amount of virtual memory this tech database is currently using.\n"
;

static PyObject*
oaTech_calcVMSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt8 result= (data.DataCall()->calcVMSize());
        return PyoaUInt8_FromoaUInt8(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_close_doc[] = 
"Class: oaTech, Function: close\n"
"  Paramegers: ()\n"
"    Calls: void close()\n"
"    Signature: close|void-void|\n"
"    BrowseData: 0\n"
"    This function decrements the reference count of this tech database by one. If the count reaches zero, this tech database is purged from memory.\n"
;

static PyObject*
oaTech_close(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->close();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_dbuToUU_doc[] = 
"Class: oaTech, Function: dbuToUU\n"
"  Paramegers: (oaViewType,oaInt4)\n"
"    Calls: oaDouble dbuToUU(const oaViewType* viewType,oaInt4 value)\n"
"    Signature: dbuToUU|simple-oaDouble|cptr-oaViewType,simple-oaInt4,\n"
"    This function converts the database units into user units for the specified viewType .\n"
"    Note: Although users can construct their own oaViewTypes, valid viewTypes for this function are restricted to the set of reserved viewTypes, namely, an oaReservedViewType object constructed with one of the following reserved view type enumerated constants: oacMaskLayout , oacSchematic , oacSchematicSymbol , oacNetlist , or oacHierDesign .\n"
"    The developer can call oaViewType::get(oaReservedViewType) to construct and return a pointer to an a oaViewType object using one of the valid reserved viewType enumerated constants (for example, oaViewType::get(oacMaskLayout) or oaViewType::get (oaReservedViewType(oacMaskLayout)) .\n"
"    viewType\n"
"    A pointer to an oaViewType that corresponds to the specified type oaReservedViewType . It needs to be one of the reserved design viewTypes: maskLayout, schematic, schematicSymbol, netlist, or oaHierDesign.\n"
"    value\n"
"    The value in database units to convert to user units\n"
;

static PyObject*
oaTech_dbuToUU(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViewType p1;
    PyParamoaInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViewType_Convert,&p1,
          &PyoaInt4_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaDouble result= (data.DataCall()->dbuToUU(p1.Data(),p2.Data()));
        return PyoaDouble_FromoaDouble(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_dbuToUUArea_doc[] = 
"Class: oaTech, Function: dbuToUUArea\n"
"  Paramegers: (oaViewType,oaUInt8)\n"
"    Calls: oaDouble dbuToUUArea(const oaViewType* viewType,oaUInt8 value)\n"
"    Signature: dbuToUUArea|simple-oaDouble|cptr-oaViewType,simple-oaUInt8,\n"
"    This function converts the database unit area to user unit area for the specified viewType .\n"
"    Note: Although users can construct their own oaViewTypes, valid viewTypes for this function are restricted to the set of reserved viewTypes, namely, an oaReservedViewType object constructed with one of the following reserved view type enumerated constants: oacMaskLayout , oacSchematic , oacSchematicSymbol , oacNetlist , or oacHierDesign .\n"
"    The developer can call oaViewType::get(oaReservedViewType) to construct and return a pointer to an a oaViewType object using one of the valid reserved viewType enumerated constants (for example, oaViewType::get(oacMaskLayout) or oaViewType::get (oaReservedViewType(oacMaskLayout)) .\n"
"    viewType\n"
"    A pointer to an oaViewType that corresponds to the specified type oaReservedViewType . It needs to be one of the reserved design viewTypes: maskLayout, schematic, schematicSymbol, netlist, or oaHierDesign.\n"
"    value\n"
"    The area in database units to convert to user units\n"
;

static PyObject*
oaTech_dbuToUUArea(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViewType p1;
    PyParamoaUInt8 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViewType_Convert,&p1,
          &PyoaUInt8_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaDouble result= (data.DataCall()->dbuToUUArea(p1.Data(),p2.Data()));
        return PyoaDouble_FromoaDouble(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_dbuToUUDistance_doc[] = 
"Class: oaTech, Function: dbuToUUDistance\n"
"  Paramegers: (oaViewType,oaUInt4)\n"
"    Calls: oaDouble dbuToUUDistance(const oaViewType* viewType,oaUInt4 value)\n"
"    Signature: dbuToUUDistance|simple-oaDouble|cptr-oaViewType,simple-oaUInt4,\n"
"    This function converts the database unit distance to user unit distance for the specified viewType.\n"
"    Note: Although users can construct their own oaViewTypes, valid viewTypes for this function are restricted to the set of reserved viewTypes, namely, an oaReservedViewType object constructed with one of the following reserved view type enumerated constants: oacMaskLayout , oacSchematic , oacSchematicSymbol , oacNetlist , or oacHierDesign .\n"
"    The developer can call oaViewType::get(oaReservedViewType) to construct and return a pointer to an a oaViewType object using one of the valid reserved viewType enumerated constants (for example, oaViewType::get(oacMaskLayout) or oaViewType::get (oaReservedViewType(oacMaskLayout)) .\n"
"    viewType\n"
"    A pointer to an oaViewType that corresponds to the specified type oaReservedViewType . It needs to be one of the reserved design viewTypes: maskLayout, schematic, schematicSymbol, netlist, or oaHierDesign.\n"
"    value\n"
"    The distance in database units to convert to user units\n"
;

static PyObject*
oaTech_dbuToUUDistance(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViewType p1;
    PyParamoaUInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViewType_Convert,&p1,
          &PyoaUInt4_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaDouble result= (data.DataCall()->dbuToUUDistance(p1.Data(),p2.Data()));
        return PyoaDouble_FromoaDouble(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_enableTimeStamps_doc[] = 
"Class: oaTech, Function: enableTimeStamps\n"
"  Paramegers: ()\n"
"    Calls: void enableTimeStamps()\n"
"    Signature: enableTimeStamps|void-void|simple-oaBoolean,\n"
"    BrowseData: 0\n"
"    This function enables or disables the update of timeStamps on this oaTech database. TimeStamps are enabled by default.\n"
"    value\n"
"    If true, enable timeStamps; if false, disable timeStamps\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: void enableTimeStamps(oaBoolean value)\n"
"    Signature: enableTimeStamps|void-void|simple-oaBoolean,\n"
"    This function enables or disables the update of timeStamps on this oaTech database. TimeStamps are enabled by default.\n"
"    value\n"
"    If true, enable timeStamps; if false, disable timeStamps\n"
;

static PyObject*
oaTech_enableTimeStamps(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            data.DataCall()->enableTimeStamps();
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            data.DataCall()->enableTimeStamps(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: enableTimeStamps, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getAnalysisLibs_doc[] = 
"Class: oaTech, Function: getAnalysisLibs\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaAnalysisLib_oaTech getAnalysisLibs() const\n"
"    Signature: getAnalysisLibs|simple-oaCollection_oaAnalysisLib_oaTech|\n"
"    BrowseData: 1\n"
"    This function returns a collection of analysis libraries contained in the graph of tech databases rooted at this oaTech.\n"
"    To return a collection of analysis libraries in the current tech only, refer to the getAnalysisLibs function that takes the filterFlags argument.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaAnalysisLib_oaTech getAnalysisLibs(oaUInt4 filterFlags) const\n"
"    Signature: getAnalysisLibs|simple-oaCollection_oaAnalysisLib_oaTech|simple-oaUInt4,\n"
"    oaTech::getAnalysisLibs2\n"
"    This function returns a collection of analysis libraries. The filterFlags value defines the extent of the collection.\n"
"    filterFlags\n"
"    Determines the extent of the returned collection of analysis libraries:\n"
"    oacAnalysisLibIterAll -- The collection contains all analysis libraries defined in this and all referenced tech databases\n"
"    oacAnalysisLibIterLocal -- The collection contains the analysis libraries defined locally in this tech database\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
;

static PyObject*
oaTech_getAnalysisLibs(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaAnalysisLib_oaTech* result= new oaCollection_oaAnalysisLib_oaTech(data.DataCall()->getAnalysisLibs());
            return PyoaCollection_oaAnalysisLib_oaTech_FromoaCollection_oaAnalysisLib_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaAnalysisLib_oaTech* result= new oaCollection_oaAnalysisLib_oaTech(data.DataCall()->getAnalysisLibs(p1.Data()));
            return PyoaCollection_oaAnalysisLib_oaTech_FromoaCollection_oaAnalysisLib_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getAnalysisLibs, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getAnalysisLibsIter_doc[] = 
"Class: oaTech, Function: getAnalysisLibsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaAnalysisLib getAnalysisLibsIter() const\n"
"    Signature: getAnalysisLibsIter|simple-oaIter_oaAnalysisLib|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of analysis libraries contained in the graph of tech databases rooted at this oaTech.\n"
"    To return a collection of analysis libraries in the current tech only, refer to the getAnalysisLibs function that takes the filterFlags argument.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaAnalysisLib getAnalysisLibsIter(oaUInt4 filterFlags) const\n"
"    Signature: getAnalysisLibsIter|simple-oaIter_oaAnalysisLib|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: oaTech::getAnalysisLibs2\n"
"    This function returns a collection of analysis libraries. The filterFlags value defines the extent of the collection.\n"
"    filterFlags\n"
"    Determines the extent of the returned collection of analysis libraries:\n"
"    oacAnalysisLibIterAll -- The collection contains all analysis libraries defined in this and all referenced tech databases\n"
"    oacAnalysisLibIterLocal -- The collection contains the analysis libraries defined locally in this tech database\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
;

static PyObject*
oaTech_getAnalysisLibsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaAnalysisLib* result= new oaIter_oaAnalysisLib(data.DataCall()->getAnalysisLibs());
            return PyoaIter_oaAnalysisLib_FromoaIter_oaAnalysisLib(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaAnalysisLib* result= new oaIter_oaAnalysisLib(data.DataCall()->getAnalysisLibs(p1.Data()));
            return PyoaIter_oaAnalysisLib_FromoaIter_oaAnalysisLib(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getAnalysisLibsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getAppDefsByDataType_doc[] = 
"Class: oaTech, Function: getAppDefsByDataType\n"
"  Paramegers: (oaTechDataType)\n"
"    Calls: oaCollection_oaAppDef_oaTech getAppDefsByDataType(oaTechDataType dataType) const\n"
"    Signature: getAppDefsByDataType|simple-oaCollection_oaAppDef_oaTech|simple-oaTechDataType,\n"
"    This function returns a collection of appDefs of the specified data type used in this tech database.\n"
"    dataType\n"
"    The type code for the specified data table\n"
;

static PyObject*
oaTech_getAppDefsByDataType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechDataType p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTechDataType_Convert,&p1)) {
        oaCollection_oaAppDef_oaTech* result= new oaCollection_oaAppDef_oaTech(data.DataCall()->getAppDefsByDataType(p1.Data()));
        return PyoaCollection_oaAppDef_oaTech_FromoaCollection_oaAppDef_oaTech(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getAppDefsByDataTypeIter_doc[] = 
"Class: oaTech, Function: getAppDefsByDataTypeIter\n"
"  Paramegers: (oaTechDataType)\n"
"    Calls: oaIter_oaAppDef getAppDefsByDataTypeIter(oaTechDataType dataType) const\n"
"    Signature: getAppDefsByDataTypeIter|simple-oaIter_oaAppDef|simple-oaTechDataType,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of appDefs of the specified data type used in this tech database.\n"
"    dataType\n"
"    The type code for the specified data table\n"
;

extern PyObject* oaTech_getAppDefsByDataTypeIter(PyObject *self, PyObject *args);

// ------------------------------------------------------------------
static char oaTech_getAppObjectDefs_doc[] = 
"Class: oaTech, Function: getAppObjectDefs\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaAppObjectDef_oaTech getAppObjectDefs() const\n"
"    Signature: getAppObjectDefs|simple-oaCollection_oaAppObjectDef_oaTech|\n"
"    BrowseData: 1\n"
"    This function returns a collection of appObjectDefs used in this tech database.\n"
;

static PyObject*
oaTech_getAppObjectDefs(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaAppObjectDef_oaTech* result= new oaCollection_oaAppObjectDef_oaTech(data.DataCall()->getAppObjectDefs());
        return PyoaCollection_oaAppObjectDef_oaTech_FromoaCollection_oaAppObjectDef_oaTech(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getAppObjectDefsIter_doc[] = 
"Class: oaTech, Function: getAppObjectDefsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaAppObjectDef getAppObjectDefsIter() const\n"
"    Signature: getAppObjectDefsIter|simple-oaIter_oaAppObjectDef|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of appObjectDefs used in this tech database.\n"
;

static PyObject*
oaTech_getAppObjectDefsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaAppObjectDef* result= new oaIter_oaAppObjectDef(data.DataCall()->getAppObjectDefs());
        return PyoaIter_oaAppObjectDef_FromoaIter_oaAppObjectDef(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getAppObjects_doc[] = 
"Class: oaTech, Function: getAppObjects\n"
"  Paramegers: (oaAppObjectDef)\n"
"    Calls: oaCollection_oaAppObject_oaTech getAppObjects(const oaAppObjectDef* def) const\n"
"    Signature: getAppObjects|simple-oaCollection_oaAppObject_oaTech|cptr-oaAppObjectDef,\n"
"    This function returns a collection of any oaAppObject with the specified extension that exists in this tech database.\n"
"    def\n"
"    The extension to include in the oaAppObject collection\n"
;

static PyObject*
oaTech_getAppObjects(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaAppObjectDef p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaAppObjectDef_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaCollection_oaAppObject_oaTech* result= new oaCollection_oaAppObject_oaTech(data.DataCall()->getAppObjects(p1.Data()));
        return PyoaCollection_oaAppObject_oaTech_FromoaCollection_oaAppObject_oaTech(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getAppObjectsIter_doc[] = 
"Class: oaTech, Function: getAppObjectsIter\n"
"  Paramegers: (oaAppObjectDef)\n"
"    Calls: oaIter_oaAppObject getAppObjectsIter(const oaAppObjectDef* def) const\n"
"    Signature: getAppObjectsIter|simple-oaIter_oaAppObject|cptr-oaAppObjectDef,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of any oaAppObject with the specified extension that exists in this tech database.\n"
"    def\n"
"    The extension to include in the oaAppObject collection\n"
;

static PyObject*
oaTech_getAppObjectsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaAppObjectDef p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaAppObjectDef_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaIter_oaAppObject* result= new oaIter_oaAppObject(data.DataCall()->getAppObjects(p1.Data()));
        return PyoaIter_oaAppObject_FromoaIter_oaAppObject(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getClearanceMeasure_doc[] = 
"Class: oaTech, Function: getClearanceMeasure\n"
"  Paramegers: ()\n"
"    Calls: oaClearanceMeasure getClearanceMeasure() const\n"
"    Signature: getClearanceMeasure|simple-oaClearanceMeasure|\n"
"    BrowseData: 1\n"
"    This function returns the clearance measurement enum value used for this technology database and all of its referenced technology databases.\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: oaClearanceMeasure getClearanceMeasure(oaBoolean local) const\n"
"    Signature: getClearanceMeasure|simple-oaClearanceMeasure|simple-oaBoolean,\n"
"    This function returns the clearance measure enum value in use. The local argument specifies whether, if true, to look only in this technology database or, if false, to search this technology database and all of its referenced technology databases for the effective clearance measure.\n"
"    local\n"
"    If true, look only in this technology database; if false, search this technology database and all its referenced technology databases.\n"
;

static PyObject*
oaTech_getClearanceMeasure(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaClearanceMeasure* result= new oaClearanceMeasure(data.DataCall()->getClearanceMeasure());
            return PyoaClearanceMeasure_FromoaClearanceMeasure(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            oaClearanceMeasure* result= new oaClearanceMeasure(data.DataCall()->getClearanceMeasure(p1.Data()));
            return PyoaClearanceMeasure_FromoaClearanceMeasure(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getClearanceMeasure, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getConstraintGroupHeaders_doc[] = 
"Class: oaTech, Function: getConstraintGroupHeaders\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaConstraintGroupHeader_oaTech getConstraintGroupHeaders() const\n"
"    Signature: getConstraintGroupHeaders|simple-oaCollection_oaConstraintGroupHeader_oaTech|\n"
"    BrowseData: 1\n"
"    This function returns a collection of constraint group headers used by this tech database. Note that the collection can include oaConstraintGroupHeaders with the same name (for default or foundry constraint groups).\n"
"    Todo\n"
"    Check description of member function.\n"
;

static PyObject*
oaTech_getConstraintGroupHeaders(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaConstraintGroupHeader_oaTech* result= new oaCollection_oaConstraintGroupHeader_oaTech(data.DataCall()->getConstraintGroupHeaders());
        return PyoaCollection_oaConstraintGroupHeader_oaTech_FromoaCollection_oaConstraintGroupHeader_oaTech(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getConstraintGroupHeadersIter_doc[] = 
"Class: oaTech, Function: getConstraintGroupHeadersIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaConstraintGroupHeader getConstraintGroupHeadersIter() const\n"
"    Signature: getConstraintGroupHeadersIter|simple-oaIter_oaConstraintGroupHeader|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of constraint group headers used by this tech database. Note that the collection can include oaConstraintGroupHeaders with the same name (for default or foundry constraint groups).\n"
"    Todo\n"
"    Check description of member function.\n"
;

static PyObject*
oaTech_getConstraintGroupHeadersIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaConstraintGroupHeader* result= new oaIter_oaConstraintGroupHeader(data.DataCall()->getConstraintGroupHeaders());
        return PyoaIter_oaConstraintGroupHeader_FromoaIter_oaConstraintGroupHeader(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getConstraintGroups_doc[] = 
"Class: oaTech, Function: getConstraintGroups\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaConstraintGroup_oaTech getConstraintGroups() const\n"
"    Signature: getConstraintGroups|simple-oaCollection_oaConstraintGroup_oaTech|\n"
"    BrowseData: 1\n"
"    This function returns a collection of constraint groups in this and all referenced tech databases.\n"
"    To return a collection of constraint groups in the current tech only, refer to the getConstraintGroups function that takes the filterFlags argument.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaConstraintGroup_oaTech getConstraintGroups(oaUInt4 filterFlags) const\n"
"    Signature: getConstraintGroups|simple-oaCollection_oaConstraintGroup_oaTech|simple-oaUInt4,\n"
"    oaTech::getConstraintGroups2\n"
"    This function returns a collection of constraint groups. The filterFlags value defines the extent of the collection.\n"
"    filterFlags\n"
"    Determines the extent of the returned collection of constraint groups:\n"
"    oacTechConstraintGroupIterAll -- The collection contains all constraint groups defined in this and all referenced tech databases\n"
"    oacTechConstraintGroupIterLocal -- The collection contains the constraint groups defined locally in this tech database\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
;

static PyObject*
oaTech_getConstraintGroups(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaConstraintGroup_oaTech* result= new oaCollection_oaConstraintGroup_oaTech(data.DataCall()->getConstraintGroups());
            return PyoaCollection_oaConstraintGroup_oaTech_FromoaCollection_oaConstraintGroup_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaConstraintGroup_oaTech* result= new oaCollection_oaConstraintGroup_oaTech(data.DataCall()->getConstraintGroups(p1.Data()));
            return PyoaCollection_oaConstraintGroup_oaTech_FromoaCollection_oaConstraintGroup_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getConstraintGroups, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getConstraintGroupsIter_doc[] = 
"Class: oaTech, Function: getConstraintGroupsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaConstraintGroup getConstraintGroupsIter() const\n"
"    Signature: getConstraintGroupsIter|simple-oaIter_oaConstraintGroup|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of constraint groups in this and all referenced tech databases.\n"
"    To return a collection of constraint groups in the current tech only, refer to the getConstraintGroups function that takes the filterFlags argument.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaConstraintGroup getConstraintGroupsIter(oaUInt4 filterFlags) const\n"
"    Signature: getConstraintGroupsIter|simple-oaIter_oaConstraintGroup|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: oaTech::getConstraintGroups2\n"
"    This function returns a collection of constraint groups. The filterFlags value defines the extent of the collection.\n"
"    filterFlags\n"
"    Determines the extent of the returned collection of constraint groups:\n"
"    oacTechConstraintGroupIterAll -- The collection contains all constraint groups defined in this and all referenced tech databases\n"
"    oacTechConstraintGroupIterLocal -- The collection contains the constraint groups defined locally in this tech database\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
;

static PyObject*
oaTech_getConstraintGroupsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaConstraintGroup* result= new oaIter_oaConstraintGroup(data.DataCall()->getConstraintGroups());
            return PyoaIter_oaConstraintGroup_FromoaIter_oaConstraintGroup(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaConstraintGroup* result= new oaIter_oaConstraintGroup(data.DataCall()->getConstraintGroups(p1.Data()));
            return PyoaIter_oaConstraintGroup_FromoaIter_oaConstraintGroup(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getConstraintGroupsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getConstraintParams_doc[] = 
"Class: oaTech, Function: getConstraintParams\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaConstraintParam_oaTech getConstraintParams() const\n"
"    Signature: getConstraintParams|simple-oaCollection_oaConstraintParam_oaTech|\n"
"    BrowseData: 1\n"
"    This function returns a collection of constraint parameters in this and all referenced tech databases.\n"
"    To return a collection of constraint parameters in the current tech only, refer to the getConstraintParams function that takes the filterFlags argument.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaConstraintParam_oaTech getConstraintParams(oaUInt4 filterFlags) const\n"
"    Signature: getConstraintParams|simple-oaCollection_oaConstraintParam_oaTech|simple-oaUInt4,\n"
"    oaTech::getConstraintParams2\n"
"    This function returns a collection of constraint parameters. The filterFlags value defines the extent of the collection.\n"
"    filterFlags\n"
"    Determines the extent of the returned collection of constraint parameters:\n"
"    oacTechConstraintParamIterAll -- The collection contains all constraint parameters defined in this and all referenced tech databases\n"
"    oacTechConstraintParamIterLocal -- The collection contains the constraint parameters defined locally in this tech database.\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
;

static PyObject*
oaTech_getConstraintParams(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaConstraintParam_oaTech* result= new oaCollection_oaConstraintParam_oaTech(data.DataCall()->getConstraintParams());
            return PyoaCollection_oaConstraintParam_oaTech_FromoaCollection_oaConstraintParam_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaConstraintParam_oaTech* result= new oaCollection_oaConstraintParam_oaTech(data.DataCall()->getConstraintParams(p1.Data()));
            return PyoaCollection_oaConstraintParam_oaTech_FromoaCollection_oaConstraintParam_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getConstraintParams, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getConstraintParamsIter_doc[] = 
"Class: oaTech, Function: getConstraintParamsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaConstraintParam getConstraintParamsIter() const\n"
"    Signature: getConstraintParamsIter|simple-oaIter_oaConstraintParam|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of constraint parameters in this and all referenced tech databases.\n"
"    To return a collection of constraint parameters in the current tech only, refer to the getConstraintParams function that takes the filterFlags argument.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaConstraintParam getConstraintParamsIter(oaUInt4 filterFlags) const\n"
"    Signature: getConstraintParamsIter|simple-oaIter_oaConstraintParam|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: oaTech::getConstraintParams2\n"
"    This function returns a collection of constraint parameters. The filterFlags value defines the extent of the collection.\n"
"    filterFlags\n"
"    Determines the extent of the returned collection of constraint parameters:\n"
"    oacTechConstraintParamIterAll -- The collection contains all constraint parameters defined in this and all referenced tech databases\n"
"    oacTechConstraintParamIterLocal -- The collection contains the constraint parameters defined locally in this tech database.\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
;

static PyObject*
oaTech_getConstraintParamsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaConstraintParam* result= new oaIter_oaConstraintParam(data.DataCall()->getConstraintParams());
            return PyoaIter_oaConstraintParam_FromoaIter_oaConstraintParam(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaConstraintParam* result= new oaIter_oaConstraintParam(data.DataCall()->getConstraintParams(p1.Data()));
            return PyoaIter_oaConstraintParam_FromoaIter_oaConstraintParam(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getConstraintParamsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getConstraints_doc[] = 
"Class: oaTech, Function: getConstraints\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaConstraint_oaTech getConstraints() const\n"
"    Signature: getConstraints|simple-oaCollection_oaConstraint_oaTech|cptr-oaConstraintDef,\n"
"    BrowseData: 1\n"
"    This function returns a collection of constraints with the specified definition in this and any referenced tech databases.\n"
"    If no definition is specified, all the constraints are returned.\n"
"    To return a collection of constraints in the current tech only, refer to the getConstraints function that takes the filterFlags argument.\n"
"    def\n"
"    Optional constraint definition to search for\n"
"  Paramegers: (oaConstraintDef)\n"
"    Calls: oaCollection_oaConstraint_oaTech getConstraints(const oaConstraintDef* def) const\n"
"    Signature: getConstraints|simple-oaCollection_oaConstraint_oaTech|cptr-oaConstraintDef,\n"
"    This function returns a collection of constraints with the specified definition in this and any referenced tech databases.\n"
"    If no definition is specified, all the constraints are returned.\n"
"    To return a collection of constraints in the current tech only, refer to the getConstraints function that takes the filterFlags argument.\n"
"    def\n"
"    Optional constraint definition to search for\n"
"  Paramegers: (oaConstraintDef,oaUInt4)\n"
"    Calls: oaCollection_oaConstraint_oaTech getConstraints(const oaConstraintDef* def,oaUInt4 filterFlags) const\n"
"    Signature: getConstraints|simple-oaCollection_oaConstraint_oaTech|cptr-oaConstraintDef,simple-oaUInt4,\n"
"    oaTech::getConstraints2\n"
"    This function returns a collection of constraints that match the given constraint definition. The filterFlags value defines the extent of the collection.\n"
"    def\n"
"    Constraint definition to match. When NULL is specified, the collection contains all constraints.\n"
"    filterFlags\n"
"    Determines the extent of the returned collection of constraints:\n"
"    oacConstraintIterAll -- The collection contains all constraints defined in this and all referenced tech databases\n"
"    oacConstraintIterLocal -- The collection contains the constraints defined locally in this tech database\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
;

static PyObject*
oaTech_getConstraints(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaConstraint_oaTech* result= new oaCollection_oaConstraint_oaTech(data.DataCall()->getConstraints());
            return PyoaCollection_oaConstraint_oaTech_FromoaCollection_oaConstraint_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaConstraintDef)
    {
        PyParamoaConstraintDef p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaConstraintDef_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaCollection_oaConstraint_oaTech* result= new oaCollection_oaConstraint_oaTech(data.DataCall()->getConstraints(p1.Data()));
            return PyoaCollection_oaConstraint_oaTech_FromoaCollection_oaConstraint_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaConstraintDef,oaUInt4)
    {
        PyParamoaConstraintDef p1;
        PyParamoaUInt4 p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaConstraintDef_Convert,&p1,
              &PyoaUInt4_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaCollection_oaConstraint_oaTech* result= new oaCollection_oaConstraint_oaTech(data.DataCall()->getConstraints(p1.Data(),p2.Data()));
            return PyoaCollection_oaConstraint_oaTech_FromoaCollection_oaConstraint_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getConstraints, Choices are:\n"
        "    ()\n"
        "    (oaConstraintDef)\n"
        "    (oaConstraintDef,oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getConstraintsIter_doc[] = 
"Class: oaTech, Function: getConstraintsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaConstraint getConstraintsIter() const\n"
"    Signature: getConstraintsIter|simple-oaIter_oaConstraint|cptr-oaConstraintDef,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of constraints with the specified definition in this and any referenced tech databases.\n"
"    If no definition is specified, all the constraints are returned.\n"
"    To return a collection of constraints in the current tech only, refer to the getConstraints function that takes the filterFlags argument.\n"
"    def\n"
"    Optional constraint definition to search for\n"
"  Paramegers: (oaConstraintDef)\n"
"    Calls: oaIter_oaConstraint getConstraintsIter(const oaConstraintDef* def) const\n"
"    Signature: getConstraintsIter|simple-oaIter_oaConstraint|cptr-oaConstraintDef,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of constraints with the specified definition in this and any referenced tech databases.\n"
"    If no definition is specified, all the constraints are returned.\n"
"    To return a collection of constraints in the current tech only, refer to the getConstraints function that takes the filterFlags argument.\n"
"    def\n"
"    Optional constraint definition to search for\n"
"  Paramegers: (oaConstraintDef,oaUInt4)\n"
"    Calls: oaIter_oaConstraint getConstraintsIter(const oaConstraintDef* def,oaUInt4 filterFlags) const\n"
"    Signature: getConstraintsIter|simple-oaIter_oaConstraint|cptr-oaConstraintDef,simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: oaTech::getConstraints2\n"
"    This function returns a collection of constraints that match the given constraint definition. The filterFlags value defines the extent of the collection.\n"
"    def\n"
"    Constraint definition to match. When NULL is specified, the collection contains all constraints.\n"
"    filterFlags\n"
"    Determines the extent of the returned collection of constraints:\n"
"    oacConstraintIterAll -- The collection contains all constraints defined in this and all referenced tech databases\n"
"    oacConstraintIterLocal -- The collection contains the constraints defined locally in this tech database\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
;

static PyObject*
oaTech_getConstraintsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaConstraint* result= new oaIter_oaConstraint(data.DataCall()->getConstraints());
            return PyoaIter_oaConstraint_FromoaIter_oaConstraint(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaConstraintDef)
    {
        PyParamoaConstraintDef p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaConstraintDef_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaIter_oaConstraint* result= new oaIter_oaConstraint(data.DataCall()->getConstraints(p1.Data()));
            return PyoaIter_oaConstraint_FromoaIter_oaConstraint(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaConstraintDef,oaUInt4)
    {
        PyParamoaConstraintDef p1;
        PyParamoaUInt4 p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaConstraintDef_Convert,&p1,
              &PyoaUInt4_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaIter_oaConstraint* result= new oaIter_oaConstraint(data.DataCall()->getConstraints(p1.Data(),p2.Data()));
            return PyoaIter_oaConstraint_FromoaIter_oaConstraint(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getConstraintsIter, Choices are:\n"
        "    ()\n"
        "    (oaConstraintDef)\n"
        "    (oaConstraintDef,oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getCreateTime_doc[] = 
"Class: oaTech, Function: getCreateTime\n"
"  Paramegers: ()\n"
"    Calls: oaTime getCreateTime() const\n"
"    Signature: getCreateTime|simple-oaTime|\n"
"    BrowseData: 1\n"
"    This function returns the time at which this tech database was created.\n"
;

static PyObject*
oaTech_getCreateTime(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaTime result= (data.DataCall()->getCreateTime());
        return PyoaTime_FromoaTime(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getDBUPerUU_doc[] = 
"Class: oaTech, Function: getDBUPerUU\n"
"  Paramegers: (oaViewType)\n"
"    Calls: oaUInt4 getDBUPerUU(const oaViewType* viewType) const\n"
"    Signature: getDBUPerUU|simple-oaUInt4|cptr-oaViewType,\n"
"    oaTech::getDBUPerUU\n"
"    This function returns the database-units per user-unit for the specified viewType used for this technology database and all of its referenced technology databases. Both this value and the user-units type must be used to calculate the real distance meant by lengths and coordinates stored in an OpenAccess database.\n"
"    The viewTypes allowed in this call are the subset of oaReservedViewType values that are used as viewTypes for an oaDesign . These are: oacMaskLayout , oacSchematic , oacSchematicSymbol , oacNetlist , or oacHierDesign .\n"
"    The caller can construct the viewType inline with this function call as in: tech->getDBUPerUU(oaViewType::get(oacMaskLayout))\n"
"    viewType\n"
"    A pointer to an oaViewType that corresponds to the specified type oaReservedViewType . It needs to be one of the reserved design viewTypes: maskLayout, schematic, schematicSymbol, netlist, or oaHierDesign.\n"
"  Paramegers: (oaViewType,oaBoolean)\n"
"    Calls: oaUInt4 getDBUPerUU(const oaViewType* viewType,oaBoolean local) const\n"
"    Signature: getDBUPerUU|simple-oaUInt4|cptr-oaViewType,simple-oaBoolean,\n"
"    This function returns the database-units per user-unit for the specified view type. The local argument specifies whether, if true, to look only in this technology database or, if false, to search this technology database and all its referenced technology databases for the effective database-units per user-unit.\n"
"    viewType\n"
"    A pointer to an oaViewType that corresponds to the specified type oaReservedViewType . It needs to be one of the reserved design viewTypes: maskLayout, schematic, schematicSymbol, netlist, or oaHierDesign.\n"
"    local\n"
"    If true, look only in this technology database; if false, search this technology database and all its referenced technology databases.\n"
;

static PyObject*
oaTech_getDBUPerUU(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaViewType)
    {
        PyParamoaViewType p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaViewType_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaUInt4 result= (data.DataCall()->getDBUPerUU(p1.Data()));
            return PyoaUInt4_FromoaUInt4(result);
        }
    }
    PyErr_Clear();
    // Case: (oaViewType,oaBoolean)
    {
        PyParamoaViewType p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaViewType_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaUInt4 result= (data.DataCall()->getDBUPerUU(p1.Data(),p2.Data()));
            return PyoaUInt4_FromoaUInt4(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getDBUPerUU, Choices are:\n"
        "    (oaViewType)\n"
        "    (oaViewType,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getDefaultConstraintGroup_doc[] = 
"Class: oaTech, Function: getDefaultConstraintGroup\n"
"  Paramegers: ()\n"
"    Calls: oaConstraintGroup* getDefaultConstraintGroup() const\n"
"    Signature: getDefaultConstraintGroup|ptr-oaConstraintGroup|\n"
"    BrowseData: 1\n"
"    This function returns the default constraint group for this technology. If no constraints have been set on the default constraint group, a new constraint group is created and returned.\n"
;

static PyObject*
oaTech_getDefaultConstraintGroup(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaConstraintGroupp result= (data.DataCall()->getDefaultConstraintGroup());
        return PyoaConstraintGroup_FromoaConstraintGroup(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getDefaultManufacturingGrid_doc[] = 
"Class: oaTech, Function: getDefaultManufacturingGrid\n"
"  Paramegers: ()\n"
"    Calls: oaDist getDefaultManufacturingGrid() const\n"
"    Signature: getDefaultManufacturingGrid|simple-oaDist|\n"
"    BrowseData: 1\n"
"    This function returns the manufacturing grid that applies to all physical layers unless it has been overridden at the physical layer level.\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: oaDist getDefaultManufacturingGrid(oaBoolean local) const\n"
"    Signature: getDefaultManufacturingGrid|simple-oaDist|simple-oaBoolean,\n"
"    This function returns the manufacturing grid that applies to all physical layers unless it has been overridden at the physical layer level. The local argument specifies whether, if true, to look only in this technology database or, if false, to search this technology database and all of its referenced technology databases for the effective manufacturing grid.\n"
"    local\n"
"    If true, look only in this technology database; if false, search this technology database and all its referenced technology databases.\n"
"    An oaDist, which is an oaUInt4 that represents the non-negative distance, along one axis, between two oaCoord values.\n"
;

static PyObject*
oaTech_getDefaultManufacturingGrid(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaDist result= (data.DataCall()->getDefaultManufacturingGrid());
            return PyoaDist_FromoaDist(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            oaDist result= (data.DataCall()->getDefaultManufacturingGrid(p1.Data()));
            return PyoaDist_FromoaDist(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getDefaultManufacturingGrid, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getDerivedLayerParams_doc[] = 
"Class: oaTech, Function: getDerivedLayerParams\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaDerivedLayerParam_oaTech getDerivedLayerParams() const\n"
"    Signature: getDerivedLayerParams|simple-oaCollection_oaDerivedLayerParam_oaTech|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns a collection of derivedLayer parameters. The following filterFlag values define what the collection contains:\n"
"    oacTechDerivedLayerParmIterAll The collection contains all derivedLayer parameters defined in this and all referenced tech databases.\n"
"    oacTechDerivedLayerParamIterLocal The collection contains the derivedLayer parameters defined locally in this tech database.\n"
"    filterFlags\n"
"    Todo\n"
"    Check description of member function. Add description of each parameter.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaDerivedLayerParam_oaTech getDerivedLayerParams(oaUInt4 filterFlags) const\n"
"    Signature: getDerivedLayerParams|simple-oaCollection_oaDerivedLayerParam_oaTech|simple-oaUInt4,\n"
"    This function returns a collection of derivedLayer parameters. The following filterFlag values define what the collection contains:\n"
"    oacTechDerivedLayerParmIterAll The collection contains all derivedLayer parameters defined in this and all referenced tech databases.\n"
"    oacTechDerivedLayerParamIterLocal The collection contains the derivedLayer parameters defined locally in this tech database.\n"
"    filterFlags\n"
"    Todo\n"
"    Check description of member function. Add description of each parameter.\n"
;

static PyObject*
oaTech_getDerivedLayerParams(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaDerivedLayerParam_oaTech* result= new oaCollection_oaDerivedLayerParam_oaTech(data.DataCall()->getDerivedLayerParams());
            return PyoaCollection_oaDerivedLayerParam_oaTech_FromoaCollection_oaDerivedLayerParam_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaDerivedLayerParam_oaTech* result= new oaCollection_oaDerivedLayerParam_oaTech(data.DataCall()->getDerivedLayerParams(p1.Data()));
            return PyoaCollection_oaDerivedLayerParam_oaTech_FromoaCollection_oaDerivedLayerParam_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getDerivedLayerParams, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getDerivedLayerParamsIter_doc[] = 
"Class: oaTech, Function: getDerivedLayerParamsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaDerivedLayerParam getDerivedLayerParamsIter() const\n"
"    Signature: getDerivedLayerParamsIter|simple-oaIter_oaDerivedLayerParam|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of derivedLayer parameters. The following filterFlag values define what the collection contains:\n"
"    oacTechDerivedLayerParmIterAll The collection contains all derivedLayer parameters defined in this and all referenced tech databases.\n"
"    oacTechDerivedLayerParamIterLocal The collection contains the derivedLayer parameters defined locally in this tech database.\n"
"    filterFlags\n"
"    Todo\n"
"    Check description of member function. Add description of each parameter.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaDerivedLayerParam getDerivedLayerParamsIter(oaUInt4 filterFlags) const\n"
"    Signature: getDerivedLayerParamsIter|simple-oaIter_oaDerivedLayerParam|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of derivedLayer parameters. The following filterFlag values define what the collection contains:\n"
"    oacTechDerivedLayerParmIterAll The collection contains all derivedLayer parameters defined in this and all referenced tech databases.\n"
"    oacTechDerivedLayerParamIterLocal The collection contains the derivedLayer parameters defined locally in this tech database.\n"
"    filterFlags\n"
"    Todo\n"
"    Check description of member function. Add description of each parameter.\n"
;

static PyObject*
oaTech_getDerivedLayerParamsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaDerivedLayerParam* result= new oaIter_oaDerivedLayerParam(data.DataCall()->getDerivedLayerParams());
            return PyoaIter_oaDerivedLayerParam_FromoaIter_oaDerivedLayerParam(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaDerivedLayerParam* result= new oaIter_oaDerivedLayerParam(data.DataCall()->getDerivedLayerParams(p1.Data()));
            return PyoaIter_oaDerivedLayerParam_FromoaIter_oaDerivedLayerParam(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getDerivedLayerParamsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getFoundryRules_doc[] = 
"Class: oaTech, Function: getFoundryRules\n"
"  Paramegers: ()\n"
"    Calls: oaConstraintGroup* getFoundryRules() const\n"
"    Signature: getFoundryRules|ptr-oaConstraintGroup|\n"
"    BrowseData: 1\n"
"    This function returns the constraint group that represents the foundry rules for this technology.\n"
;

static PyObject*
oaTech_getFoundryRules(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaConstraintGroupp result= (data.DataCall()->getFoundryRules());
        return PyoaConstraintGroup_FromoaConstraintGroup(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getGroups_doc[] = 
"Class: oaTech, Function: getGroups\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaGroup_oaTech getGroups() const\n"
"    Signature: getGroups|simple-oaCollection_oaGroup_oaTech|\n"
"    BrowseData: 1\n"
"    This function returns the complete set of groups in this tech database.\n"
;

static PyObject*
oaTech_getGroups(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaGroup_oaTech* result= new oaCollection_oaGroup_oaTech(data.DataCall()->getGroups());
        return PyoaCollection_oaGroup_oaTech_FromoaCollection_oaGroup_oaTech(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getGroupsByName_doc[] = 
"Class: oaTech, Function: getGroupsByName\n"
"  Paramegers: (oaString)\n"
"    Calls: oaCollection_oaGroup_oaTech getGroupsByName(const oaString& name) const\n"
"    Signature: getGroupsByName|simple-oaCollection_oaGroup_oaTech|cref-oaString,\n"
"    This function returns a collection of group names for the specified extension in this tech database.\n"
"    name\n"
"    The extension to include in the collection\n"
;

static PyObject*
oaTech_getGroupsByName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        oaCollection_oaGroup_oaTech* result= new oaCollection_oaGroup_oaTech(data.DataCall()->getGroupsByName(p1.Data()));
        return PyoaCollection_oaGroup_oaTech_FromoaCollection_oaGroup_oaTech(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getGroupsByNameIter_doc[] = 
"Class: oaTech, Function: getGroupsByNameIter\n"
"  Paramegers: (oaString)\n"
"    Calls: oaIter_oaGroup getGroupsByNameIter(const oaString& name) const\n"
"    Signature: getGroupsByNameIter|simple-oaIter_oaGroup|cref-oaString,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of group names for the specified extension in this tech database.\n"
"    name\n"
"    The extension to include in the collection\n"
;

static PyObject*
oaTech_getGroupsByNameIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        oaIter_oaGroup* result= new oaIter_oaGroup(data.DataCall()->getGroupsByName(p1.Data()));
        return PyoaIter_oaGroup_FromoaIter_oaGroup(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getGroupsIter_doc[] = 
"Class: oaTech, Function: getGroupsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaGroup getGroupsIter() const\n"
"    Signature: getGroupsIter|simple-oaIter_oaGroup|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns the complete set of groups in this tech database.\n"
;

static PyObject*
oaTech_getGroupsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaGroup* result= new oaIter_oaGroup(data.DataCall()->getGroups());
        return PyoaIter_oaGroup_FromoaIter_oaGroup(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getLastSavedTime_doc[] = 
"Class: oaTech, Function: getLastSavedTime\n"
"  Paramegers: ()\n"
"    Calls: oaTime getLastSavedTime() const\n"
"    Signature: getLastSavedTime|simple-oaTime|\n"
"    BrowseData: 1\n"
"    This function returns the time at which this tech database was last modified.\n"
;

static PyObject*
oaTech_getLastSavedTime(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaTime result= (data.DataCall()->getLastSavedTime());
        return PyoaTime_FromoaTime(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getLayerHeaders_doc[] = 
"Class: oaTech, Function: getLayerHeaders\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaTechLayerHeader_oaTech getLayerHeaders() const\n"
"    Signature: getLayerHeaders|simple-oaCollection_oaTechLayerHeader_oaTech|\n"
"    BrowseData: 1\n"
"    This function returns a collection of layerHeaders in this tech database.\n"
;

static PyObject*
oaTech_getLayerHeaders(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaTechLayerHeader_oaTech* result= new oaCollection_oaTechLayerHeader_oaTech(data.DataCall()->getLayerHeaders());
        return PyoaCollection_oaTechLayerHeader_oaTech_FromoaCollection_oaTechLayerHeader_oaTech(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getLayerHeadersIter_doc[] = 
"Class: oaTech, Function: getLayerHeadersIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaTechLayerHeader getLayerHeadersIter() const\n"
"    Signature: getLayerHeadersIter|simple-oaIter_oaTechLayerHeader|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of layerHeaders in this tech database.\n"
;

static PyObject*
oaTech_getLayerHeadersIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaTechLayerHeader* result= new oaIter_oaTechLayerHeader(data.DataCall()->getLayerHeaders());
        return PyoaIter_oaTechLayerHeader_FromoaIter_oaTechLayerHeader(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getLayers_doc[] = 
"Class: oaTech, Function: getLayers\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaLayer_oaTech getLayers() const\n"
"    Signature: getLayers|simple-oaCollection_oaLayer_oaTech|\n"
"    BrowseData: 1\n"
"    This function returns a collection of layers this and all referenced tech databases.\n"
"    To return a collection of layers in the current tech only, refer to the getLayers function that takes the filterFlags argument.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaLayer_oaTech getLayers(oaUInt4 filterFlags) const\n"
"    Signature: getLayers|simple-oaCollection_oaLayer_oaTech|simple-oaUInt4,\n"
"    oaTech::getLayers2\n"
"    This function returns a collection of layers. The filterFlags value defines the extent of the collection.\n"
"    filterFlags\n"
"    Defines the extent of the returned collection of layers:\n"
"    oacLayerIterAll -- The collection contains all layers defined in this and all referenced tech databases\n"
"    oacLayerIterLocal -- The collection contains the layers defined locally in this tech database\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
;

static PyObject*
oaTech_getLayers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaLayer_oaTech* result= new oaCollection_oaLayer_oaTech(data.DataCall()->getLayers());
            return PyoaCollection_oaLayer_oaTech_FromoaCollection_oaLayer_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaLayer_oaTech* result= new oaCollection_oaLayer_oaTech(data.DataCall()->getLayers(p1.Data()));
            return PyoaCollection_oaLayer_oaTech_FromoaCollection_oaLayer_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getLayers, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getLayersIter_doc[] = 
"Class: oaTech, Function: getLayersIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaLayer getLayersIter() const\n"
"    Signature: getLayersIter|simple-oaIter_oaLayer|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of layers this and all referenced tech databases.\n"
"    To return a collection of layers in the current tech only, refer to the getLayers function that takes the filterFlags argument.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaLayer getLayersIter(oaUInt4 filterFlags) const\n"
"    Signature: getLayersIter|simple-oaIter_oaLayer|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: oaTech::getLayers2\n"
"    This function returns a collection of layers. The filterFlags value defines the extent of the collection.\n"
"    filterFlags\n"
"    Defines the extent of the returned collection of layers:\n"
"    oacLayerIterAll -- The collection contains all layers defined in this and all referenced tech databases\n"
"    oacLayerIterLocal -- The collection contains the layers defined locally in this tech database\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
;

static PyObject*
oaTech_getLayersIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaLayer* result= new oaIter_oaLayer(data.DataCall()->getLayers());
            return PyoaIter_oaLayer_FromoaIter_oaLayer(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaLayer* result= new oaIter_oaLayer(data.DataCall()->getLayers(p1.Data()));
            return PyoaIter_oaLayer_FromoaIter_oaLayer(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getLayersIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getLib_doc[] = 
"Class: oaTech, Function: getLib\n"
"  Paramegers: ()\n"
"    Calls: oaLib* getLib() const\n"
"    Signature: getLib|ptr-oaLib|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the library object containing this tech database.\n"
;

static PyObject*
oaTech_getLib(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaLibp result= (data.DataCall()->getLib());
        return PyoaLib_FromoaLib(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getLibName_doc[] = 
"Class: oaTech, Function: getLibName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getLibName(oaScalarName& libName) const\n"
"    Signature: getLibName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the name of the library associated with this tech database.\n"
"    libName\n"
"    Name of the library associated with this tech\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getLibName(const oaNameSpace& ns,oaString& out) const\n"
"    Signature: getLibName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the name of the library associated with this tech database.\n"
"    ns\n"
"    The name space to check for the library name\n"
"    out\n"
"    The name of the library used by this tech database\n"
;

static PyObject*
oaTech_getLibName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getLibName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getLibName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getLibName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getMode_doc[] = 
"Class: oaTech, Function: getMode\n"
"  Paramegers: ()\n"
"    Calls: oaChar getMode() const\n"
"    Signature: getMode|simple-oaChar|\n"
"    BrowseData: 1\n"
"    This function returns the mode of the currently open tech database.\n"
;

static PyObject*
oaTech_getMode(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaChar result= (data.DataCall()->getMode());
        return PyoaChar_FromoaChar(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getOpPoints_doc[] = 
"Class: oaTech, Function: getOpPoints\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaOpPoint_oaTech getOpPoints() const\n"
"    Signature: getOpPoints|simple-oaCollection_oaOpPoint_oaTech|\n"
"    BrowseData: 1\n"
"    This function returns a collection of operating points in this and all referenced tech databases.\n"
"    To return a collection of operating points in the current tech only, refer to the getOpPoints function that takes the filterFlags argument.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaOpPoint_oaTech getOpPoints(oaUInt4 filterFlags) const\n"
"    Signature: getOpPoints|simple-oaCollection_oaOpPoint_oaTech|simple-oaUInt4,\n"
"    oaTech::getOpPoints2\n"
"    This function returns a collection of operating points. The filterFlags value defines the extent of the collection.\n"
"    filterFlags\n"
"    Determines the extent of the returned collection of operating points:\n"
"    oacOpPointIterAll -- The collection contains all operating points defined in this and all referenced tech databases\n"
"    oacOpPointIterLocal -- The collection contains the operating points defined locally in this tech database\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
;

static PyObject*
oaTech_getOpPoints(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaOpPoint_oaTech* result= new oaCollection_oaOpPoint_oaTech(data.DataCall()->getOpPoints());
            return PyoaCollection_oaOpPoint_oaTech_FromoaCollection_oaOpPoint_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaOpPoint_oaTech* result= new oaCollection_oaOpPoint_oaTech(data.DataCall()->getOpPoints(p1.Data()));
            return PyoaCollection_oaOpPoint_oaTech_FromoaCollection_oaOpPoint_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getOpPoints, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getOpPointsIter_doc[] = 
"Class: oaTech, Function: getOpPointsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaOpPoint getOpPointsIter() const\n"
"    Signature: getOpPointsIter|simple-oaIter_oaOpPoint|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of operating points in this and all referenced tech databases.\n"
"    To return a collection of operating points in the current tech only, refer to the getOpPoints function that takes the filterFlags argument.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaOpPoint getOpPointsIter(oaUInt4 filterFlags) const\n"
"    Signature: getOpPointsIter|simple-oaIter_oaOpPoint|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: oaTech::getOpPoints2\n"
"    This function returns a collection of operating points. The filterFlags value defines the extent of the collection.\n"
"    filterFlags\n"
"    Determines the extent of the returned collection of operating points:\n"
"    oacOpPointIterAll -- The collection contains all operating points defined in this and all referenced tech databases\n"
"    oacOpPointIterLocal -- The collection contains the operating points defined locally in this tech database\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
;

static PyObject*
oaTech_getOpPointsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaOpPoint* result= new oaIter_oaOpPoint(data.DataCall()->getOpPoints());
            return PyoaIter_oaOpPoint_FromoaIter_oaOpPoint(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaOpPoint* result= new oaIter_oaOpPoint(data.DataCall()->getOpPoints(p1.Data()));
            return PyoaIter_oaOpPoint_FromoaIter_oaOpPoint(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getOpPointsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getPurposes_doc[] = 
"Class: oaTech, Function: getPurposes\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaPurpose_oaTech getPurposes() const\n"
"    Signature: getPurposes|simple-oaCollection_oaPurpose_oaTech|\n"
"    BrowseData: 1\n"
"    This function returns a collection of purposes in this and all referenced tech databases.\n"
"    To return a collection of purposes in the current tech only, refer to the getPurposes function that takes the filterFlags argument.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaPurpose_oaTech getPurposes(oaUInt4 filterFlags) const\n"
"    Signature: getPurposes|simple-oaCollection_oaPurpose_oaTech|simple-oaUInt4,\n"
"    oaTech::getPurposes2\n"
"    This function returns a collection of purposes. The filterFlags value defines the extent of the collection.\n"
"    filterFlags\n"
"    Determines the extent of the returned collection of purposes:\n"
"    oacPurposeIterAll -- The collection contains all purposes defined in this and all referenced tech databases\n"
"    oacPurposeIterLocal -- The collection contains the purposes defined locally in this tech database\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
;

static PyObject*
oaTech_getPurposes(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaPurpose_oaTech* result= new oaCollection_oaPurpose_oaTech(data.DataCall()->getPurposes());
            return PyoaCollection_oaPurpose_oaTech_FromoaCollection_oaPurpose_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaPurpose_oaTech* result= new oaCollection_oaPurpose_oaTech(data.DataCall()->getPurposes(p1.Data()));
            return PyoaCollection_oaPurpose_oaTech_FromoaCollection_oaPurpose_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getPurposes, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getPurposesIter_doc[] = 
"Class: oaTech, Function: getPurposesIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaPurpose getPurposesIter() const\n"
"    Signature: getPurposesIter|simple-oaIter_oaPurpose|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of purposes in this and all referenced tech databases.\n"
"    To return a collection of purposes in the current tech only, refer to the getPurposes function that takes the filterFlags argument.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaPurpose getPurposesIter(oaUInt4 filterFlags) const\n"
"    Signature: getPurposesIter|simple-oaIter_oaPurpose|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: oaTech::getPurposes2\n"
"    This function returns a collection of purposes. The filterFlags value defines the extent of the collection.\n"
"    filterFlags\n"
"    Determines the extent of the returned collection of purposes:\n"
"    oacPurposeIterAll -- The collection contains all purposes defined in this and all referenced tech databases\n"
"    oacPurposeIterLocal -- The collection contains the purposes defined locally in this tech database\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
;

static PyObject*
oaTech_getPurposesIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaPurpose* result= new oaIter_oaPurpose(data.DataCall()->getPurposes());
            return PyoaIter_oaPurpose_FromoaIter_oaPurpose(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaPurpose* result= new oaIter_oaPurpose(data.DataCall()->getPurposes(p1.Data()));
            return PyoaIter_oaPurpose_FromoaIter_oaPurpose(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getPurposesIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getReadInTime_doc[] = 
"Class: oaTech, Function: getReadInTime\n"
"  Paramegers: ()\n"
"    Calls: oaTime getReadInTime() const\n"
"    Signature: getReadInTime|simple-oaTime|\n"
"    BrowseData: 1\n"
"    This function returns the time this tech database was read.\n"
;

static PyObject*
oaTech_getReadInTime(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaTime result= (data.DataCall()->getReadInTime());
        return PyoaTime_FromoaTime(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getRefCount_doc[] = 
"Class: oaTech, Function: getRefCount\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getRefCount() const\n"
"    Signature: getRefCount|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of times this tech database was opened without closing. This number includes both internal and external openings.\n"
;

static PyObject*
oaTech_getRefCount(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getRefCount());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getSiteDefs_doc[] = 
"Class: oaTech, Function: getSiteDefs\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaSiteDef_oaTech getSiteDefs() const\n"
"    Signature: getSiteDefs|simple-oaCollection_oaSiteDef_oaTech|\n"
"    BrowseData: 1\n"
"    This function returns a collection of siteDefs in this and all referenced tech databases.\n"
"    To return a collection of siteDefs in the current tech only, refer to the getSiteDefs function that takes the filterFlags argument.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaSiteDef_oaTech getSiteDefs(oaUInt4 filterFlags) const\n"
"    Signature: getSiteDefs|simple-oaCollection_oaSiteDef_oaTech|simple-oaUInt4,\n"
"    oaTech::getSiteDefs2\n"
"    This function returns a collection of siteDefs. The filterFlags value defines the extent of the collection.\n"
"    filterFlags\n"
"    Determines the extent of the returned collection of siteDefs:\n"
"    oacSiteDefIterAll -- The collection contains all siteDefs defined in this and all referenced tech databases\n"
"    oacSiteDefIterLocal -- The collection contains the siteDefs defined locally in this tech database\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
;

static PyObject*
oaTech_getSiteDefs(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaSiteDef_oaTech* result= new oaCollection_oaSiteDef_oaTech(data.DataCall()->getSiteDefs());
            return PyoaCollection_oaSiteDef_oaTech_FromoaCollection_oaSiteDef_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaSiteDef_oaTech* result= new oaCollection_oaSiteDef_oaTech(data.DataCall()->getSiteDefs(p1.Data()));
            return PyoaCollection_oaSiteDef_oaTech_FromoaCollection_oaSiteDef_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getSiteDefs, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getSiteDefsIter_doc[] = 
"Class: oaTech, Function: getSiteDefsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaSiteDef getSiteDefsIter() const\n"
"    Signature: getSiteDefsIter|simple-oaIter_oaSiteDef|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of siteDefs in this and all referenced tech databases.\n"
"    To return a collection of siteDefs in the current tech only, refer to the getSiteDefs function that takes the filterFlags argument.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaSiteDef getSiteDefsIter(oaUInt4 filterFlags) const\n"
"    Signature: getSiteDefsIter|simple-oaIter_oaSiteDef|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: oaTech::getSiteDefs2\n"
"    This function returns a collection of siteDefs. The filterFlags value defines the extent of the collection.\n"
"    filterFlags\n"
"    Determines the extent of the returned collection of siteDefs:\n"
"    oacSiteDefIterAll -- The collection contains all siteDefs defined in this and all referenced tech databases\n"
"    oacSiteDefIterLocal -- The collection contains the siteDefs defined locally in this tech database\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
;

static PyObject*
oaTech_getSiteDefsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaSiteDef* result= new oaIter_oaSiteDef(data.DataCall()->getSiteDefs());
            return PyoaIter_oaSiteDef_FromoaIter_oaSiteDef(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaSiteDef* result= new oaIter_oaSiteDef(data.DataCall()->getSiteDefs(p1.Data()));
            return PyoaIter_oaSiteDef_FromoaIter_oaSiteDef(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getSiteDefsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getTechHeaders_doc[] = 
"Class: oaTech, Function: getTechHeaders\n"
"  Paramegers: (oaTechHeaderArray)\n"
"    Calls: void getTechHeaders(oaTechHeaderArray& refHeaders) const\n"
"    Signature: getTechHeaders|void-void|ref-oaTechHeaderArray,simple-oaBoolean,\n"
"    BrowseData: 0,oaTechHeaderArray\n"
"    This function returns an ordered list of tech database headers that are referenced by this tech database. If there are no references, an empty array is returned. Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    refHeaders\n"
"    Array containing the set of tech database headers.\n"
"    local\n"
"    Specifies the extent of the search for referenced tech databases. If local is true, the tech headers referenced directly from this tech in the order in which the references were set are returned. If local is false, the complete graph of tech databases rooted at this tech is returned in the refHeaders array. The order of the tech headers reflects a depth-first traversal of the tech graph. Note that this graph may not be complete if there are missing tech databases in the list.\n"
"    Todo\n"
"    Delete not-supported throw and add any real throws when implemented.\n"
"  Paramegers: (oaTechHeaderArray,oaBoolean)\n"
"    Calls: void getTechHeaders(oaTechHeaderArray& refHeaders,oaBoolean local) const\n"
"    Signature: getTechHeaders|void-void|ref-oaTechHeaderArray,simple-oaBoolean,\n"
"    This function returns an ordered list of tech database headers that are referenced by this tech database. If there are no references, an empty array is returned. Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    refHeaders\n"
"    Array containing the set of tech database headers.\n"
"    local\n"
"    Specifies the extent of the search for referenced tech databases. If local is true, the tech headers referenced directly from this tech in the order in which the references were set are returned. If local is false, the complete graph of tech databases rooted at this tech is returned in the refHeaders array. The order of the tech headers reflects a depth-first traversal of the tech graph. Note that this graph may not be complete if there are missing tech databases in the list.\n"
"    Todo\n"
"    Delete not-supported throw and add any real throws when implemented.\n"
;

static PyObject*
oaTech_getTechHeaders(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaTechHeaderArray)
    {
        PyParamoaTechHeaderArray p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaTechHeaderArray_Convert,&p1)) {
            data.DataCall()->getTechHeaders(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaTechHeaderArray,oaBoolean)
    {
        PyParamoaTechHeaderArray p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaTechHeaderArray_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->getTechHeaders(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getTechHeaders, Choices are:\n"
        "    (oaTechHeaderArray)\n"
        "    (oaTechHeaderArray,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getTimeStamp_doc[] = 
"Class: oaTech, Function: getTimeStamp\n"
"  Paramegers: (oaTechDataType)\n"
"    Calls: oaTimeStamp getTimeStamp(oaTechDataType type) const\n"
"    Signature: getTimeStamp|simple-oaTimeStamp|simple-oaTechDataType,\n"
"    This function returns the timeStamp value for the specified technology datatype.\n"
"    type\n"
"    The technology datatype to check\n"
"  Paramegers: (oaAppObjectDef)\n"
"    Calls: oaTimeStamp getTimeStamp(oaAppObjectDef* def) const\n"
"    Signature: getTimeStamp|simple-oaTimeStamp|ptr-oaAppObjectDef,\n"
"    This function returns the timeStamp value for the specified application object.\n"
"    def\n"
"    The application object to check\n"
;

static PyObject*
oaTech_getTimeStamp(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaTechDataType)
    {
        PyParamoaTechDataType p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaTechDataType_Convert,&p1)) {
            oaTimeStamp* result= new oaTimeStamp(data.DataCall()->getTimeStamp(p1.Data()));
            return PyoaTimeStamp_FromoaTimeStamp(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaAppObjectDef)
    {
        PyParamoaAppObjectDef p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaAppObjectDef_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaTimeStamp* result= new oaTimeStamp(data.DataCall()->getTimeStamp(p1.Data()));
            return PyoaTimeStamp_FromoaTimeStamp(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getTimeStamp, Choices are:\n"
        "    (oaTechDataType)\n"
        "    (oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getUsedIn_doc[] = 
"Class: oaTech, Function: getUsedIn\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaTechHeader_oaTech getUsedIn() const\n"
"    Signature: getUsedIn|simple-oaCollection_oaTechHeader_oaTech|\n"
"    BrowseData: 1\n"
"    This function returns a collection of techHeaders in other open tech databases that contain references to this tech database.\n"
;

static PyObject*
oaTech_getUsedIn(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaTechHeader_oaTech* result= new oaCollection_oaTechHeader_oaTech(data.DataCall()->getUsedIn());
        return PyoaCollection_oaTechHeader_oaTech_FromoaCollection_oaTechHeader_oaTech(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getUsedInIter_doc[] = 
"Class: oaTech, Function: getUsedInIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaTechHeader getUsedInIter() const\n"
"    Signature: getUsedInIter|simple-oaIter_oaTechHeader|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of techHeaders in other open tech databases that contain references to this tech database.\n"
;

static PyObject*
oaTech_getUsedInIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaTechHeader* result= new oaIter_oaTechHeader(data.DataCall()->getUsedIn());
        return PyoaIter_oaTechHeader_FromoaIter_oaTechHeader(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getUserUnits_doc[] = 
"Class: oaTech, Function: getUserUnits\n"
"  Paramegers: (oaViewType)\n"
"    Calls: oaUserUnitsType getUserUnits(const oaViewType* viewType) const\n"
"    Signature: getUserUnits|simple-oaUserUnitsType|cptr-oaViewType,\n"
"    oaTech::getUserUnits\n"
"    This function returns the user-unit information for the specified viewType used for this technology database and all of its referenced technology databases.\n"
"    Note: Although users can construct their own oaViewTypes, valid viewTypes for this function are restricted to the set of reserved viewTypes, namely, an oaReservedViewType object constructed with one of the following reserved view type enumerated constants: oacMaskLayout , oacSchematic , oacSchematicSymbol , oacNetlist , or oacHierDesign .\n"
"    The developer can call oaViewType::get(oaReservedViewType) to construct and return a pointer to an a oaViewType object using one of the valid reserved viewType enumerated constants (for example, oaViewType::get(oacMaskLayout) or oaViewType::get (oaReservedViewType(oacMaskLayout)) .\n"
"    viewType\n"
"    A pointer to an oaViewType that corresponds to the specified type oaReservedViewType . It needs to be one of the reserved design viewTypes: maskLayout, schematic, schematicSymbol, netlist, or oaHierDesign.\n"
"  Paramegers: (oaViewType,oaBoolean)\n"
"    Calls: oaUserUnitsType getUserUnits(const oaViewType* viewType,oaBoolean local) const\n"
"    Signature: getUserUnits|simple-oaUserUnitsType|cptr-oaViewType,simple-oaBoolean,\n"
"    This function returns the user-unit information for the specified viewType. The local argument specifies whether, if true, to look only in this technology database or, if false, to search this technology database and all of its referenced technology databases for the effective user-unit.\n"
"    viewType\n"
"    A pointer to an oaViewType that corresponds to the specified type oaReservedViewType . It needs to be one of the reserved design viewTypes: maskLayout, schematic, schematicSymbol, netlist, or oaHierDesign.\n"
"    local\n"
"    If true, look only in this technology database; if false, search this technology database and all its referenced technology databases.\n"
;

static PyObject*
oaTech_getUserUnits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaViewType)
    {
        PyParamoaViewType p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaViewType_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaUserUnitsType* result= new oaUserUnitsType(data.DataCall()->getUserUnits(p1.Data()));
            return PyoaUserUnitsType_FromoaUserUnitsType(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaViewType,oaBoolean)
    {
        PyParamoaViewType p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaViewType_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaUserUnitsType* result= new oaUserUnitsType(data.DataCall()->getUserUnits(p1.Data(),p2.Data()));
            return PyoaUserUnitsType_FromoaUserUnitsType(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getUserUnits, Choices are:\n"
        "    (oaViewType)\n"
        "    (oaViewType,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getValues_doc[] = 
"Class: oaTech, Function: getValues\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaValue_oaTech getValues() const\n"
"    Signature: getValues|simple-oaCollection_oaValue_oaTech|\n"
"    BrowseData: 1\n"
"    This function returns a collection of values in this and all referenced tech databases.\n"
"    To return a collection of values in the current tech only, refer to the getValues function that takes the filterFlags argument.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaValue_oaTech getValues(oaUInt4 filterFlags) const\n"
"    Signature: getValues|simple-oaCollection_oaValue_oaTech|simple-oaUInt4,\n"
"    oaTech::getValues2\n"
"    This function returns a collection of values. The filterFlags value defines the extent of the collection.\n"
"    filterFlags\n"
"    Determines the extent of the returned collection of values:\n"
"    oacTechValueIterAll -- The collection contains all values defined in this and all referenced tech databases\n"
"    oacTechValueIterLocal -- The collection contains the values defined locally in this tech database\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
;

static PyObject*
oaTech_getValues(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaValue_oaTech* result= new oaCollection_oaValue_oaTech(data.DataCall()->getValues());
            return PyoaCollection_oaValue_oaTech_FromoaCollection_oaValue_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaValue_oaTech* result= new oaCollection_oaValue_oaTech(data.DataCall()->getValues(p1.Data()));
            return PyoaCollection_oaValue_oaTech_FromoaCollection_oaValue_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getValues, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getValuesIter_doc[] = 
"Class: oaTech, Function: getValuesIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaValue getValuesIter() const\n"
"    Signature: getValuesIter|simple-oaIter_oaValue|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of values in this and all referenced tech databases.\n"
"    To return a collection of values in the current tech only, refer to the getValues function that takes the filterFlags argument.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaValue getValuesIter(oaUInt4 filterFlags) const\n"
"    Signature: getValuesIter|simple-oaIter_oaValue|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: oaTech::getValues2\n"
"    This function returns a collection of values. The filterFlags value defines the extent of the collection.\n"
"    filterFlags\n"
"    Determines the extent of the returned collection of values:\n"
"    oacTechValueIterAll -- The collection contains all values defined in this and all referenced tech databases\n"
"    oacTechValueIterLocal -- The collection contains the values defined locally in this tech database\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
;

static PyObject*
oaTech_getValuesIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaValue* result= new oaIter_oaValue(data.DataCall()->getValues());
            return PyoaIter_oaValue_FromoaIter_oaValue(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaValue* result= new oaIter_oaValue(data.DataCall()->getValues(p1.Data()));
            return PyoaIter_oaValue_FromoaIter_oaValue(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getValuesIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getViaDefHeaders_doc[] = 
"Class: oaTech, Function: getViaDefHeaders\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaTechViaDefHeader_oaTech getViaDefHeaders() const\n"
"    Signature: getViaDefHeaders|simple-oaCollection_oaTechViaDefHeader_oaTech|\n"
"    BrowseData: 1\n"
"    This function returns a collection of viaDefHeaders in this tech database.\n"
;

static PyObject*
oaTech_getViaDefHeaders(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaTechViaDefHeader_oaTech* result= new oaCollection_oaTechViaDefHeader_oaTech(data.DataCall()->getViaDefHeaders());
        return PyoaCollection_oaTechViaDefHeader_oaTech_FromoaCollection_oaTechViaDefHeader_oaTech(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getViaDefHeadersIter_doc[] = 
"Class: oaTech, Function: getViaDefHeadersIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaTechViaDefHeader getViaDefHeadersIter() const\n"
"    Signature: getViaDefHeadersIter|simple-oaIter_oaTechViaDefHeader|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of viaDefHeaders in this tech database.\n"
;

static PyObject*
oaTech_getViaDefHeadersIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaTechViaDefHeader* result= new oaIter_oaTechViaDefHeader(data.DataCall()->getViaDefHeaders());
        return PyoaIter_oaTechViaDefHeader_FromoaIter_oaTechViaDefHeader(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getViaDefs_doc[] = 
"Class: oaTech, Function: getViaDefs\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaViaDef_oaTech getViaDefs() const\n"
"    Signature: getViaDefs|simple-oaCollection_oaViaDef_oaTech|\n"
"    BrowseData: 1\n"
"    This function returns a collection of viaDefs in this and all referenced tech databases.\n"
"    To return a collection of viaDefs in the current tech only, refer to the getViaDefs function that takes the filterFlags argument.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaViaDef_oaTech getViaDefs(oaUInt4 filterFlags) const\n"
"    Signature: getViaDefs|simple-oaCollection_oaViaDef_oaTech|simple-oaUInt4,\n"
"    oaTech::getViaDefs2\n"
"    This function returns a collection of viaDefs. The filterFlags value defines the extent of the collection.\n"
"    filterFlags\n"
"    Determines the extent of the returned collection of viaDefs:\n"
"    oacViaDefIterAll -- The collection contains all viaDefs defined in this and all referenced tech databases\n"
"    oacViaDefIterLocal -- The collection contains the viaDefs defined locally in this tech database\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
;

static PyObject*
oaTech_getViaDefs(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaViaDef_oaTech* result= new oaCollection_oaViaDef_oaTech(data.DataCall()->getViaDefs());
            return PyoaCollection_oaViaDef_oaTech_FromoaCollection_oaViaDef_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaViaDef_oaTech* result= new oaCollection_oaViaDef_oaTech(data.DataCall()->getViaDefs(p1.Data()));
            return PyoaCollection_oaViaDef_oaTech_FromoaCollection_oaViaDef_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getViaDefs, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getViaDefsIter_doc[] = 
"Class: oaTech, Function: getViaDefsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaViaDef getViaDefsIter() const\n"
"    Signature: getViaDefsIter|simple-oaIter_oaViaDef|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of viaDefs in this and all referenced tech databases.\n"
"    To return a collection of viaDefs in the current tech only, refer to the getViaDefs function that takes the filterFlags argument.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaViaDef getViaDefsIter(oaUInt4 filterFlags) const\n"
"    Signature: getViaDefsIter|simple-oaIter_oaViaDef|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: oaTech::getViaDefs2\n"
"    This function returns a collection of viaDefs. The filterFlags value defines the extent of the collection.\n"
"    filterFlags\n"
"    Determines the extent of the returned collection of viaDefs:\n"
"    oacViaDefIterAll -- The collection contains all viaDefs defined in this and all referenced tech databases\n"
"    oacViaDefIterLocal -- The collection contains the viaDefs defined locally in this tech database\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
;

static PyObject*
oaTech_getViaDefsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaViaDef* result= new oaIter_oaViaDef(data.DataCall()->getViaDefs());
            return PyoaIter_oaViaDef_FromoaIter_oaViaDef(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaViaDef* result= new oaIter_oaViaDef(data.DataCall()->getViaDefs(p1.Data()));
            return PyoaIter_oaViaDef_FromoaIter_oaViaDef(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getViaDefsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getViaSpecs_doc[] = 
"Class: oaTech, Function: getViaSpecs\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaViaSpec_oaTech getViaSpecs() const\n"
"    Signature: getViaSpecs|simple-oaCollection_oaViaSpec_oaTech|\n"
"    BrowseData: 1\n"
"    This function returns a collection of via specs in this and all referenced tech databases.\n"
"    To return a collection of via specs in the current tech only, refer to the getViaSpecs function that takes the filterFlags argument.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaViaSpec_oaTech getViaSpecs(oaUInt4 filterFlags) const\n"
"    Signature: getViaSpecs|simple-oaCollection_oaViaSpec_oaTech|simple-oaUInt4,\n"
"    oaTech::getViaSpecs2\n"
"    This function returns a collection of viaSpecs. The filterFlags value defines the extent of the collection.\n"
"    filterFlags\n"
"    Determines the extent of the returned collection of viaSpecs:\n"
"    oacViaSpecIterAll -- The collection contains all viaSpecs defined in this and all referenced tech databases\n"
"    oacViaSpecIterLocal -- The collection contains the viaSpecs defined locally in this tech database\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
;

static PyObject*
oaTech_getViaSpecs(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaViaSpec_oaTech* result= new oaCollection_oaViaSpec_oaTech(data.DataCall()->getViaSpecs());
            return PyoaCollection_oaViaSpec_oaTech_FromoaCollection_oaViaSpec_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaViaSpec_oaTech* result= new oaCollection_oaViaSpec_oaTech(data.DataCall()->getViaSpecs(p1.Data()));
            return PyoaCollection_oaViaSpec_oaTech_FromoaCollection_oaViaSpec_oaTech(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getViaSpecs, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_getViaSpecsIter_doc[] = 
"Class: oaTech, Function: getViaSpecsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaViaSpec getViaSpecsIter() const\n"
"    Signature: getViaSpecsIter|simple-oaIter_oaViaSpec|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of via specs in this and all referenced tech databases.\n"
"    To return a collection of via specs in the current tech only, refer to the getViaSpecs function that takes the filterFlags argument.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaViaSpec getViaSpecsIter(oaUInt4 filterFlags) const\n"
"    Signature: getViaSpecsIter|simple-oaIter_oaViaSpec|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: oaTech::getViaSpecs2\n"
"    This function returns a collection of viaSpecs. The filterFlags value defines the extent of the collection.\n"
"    filterFlags\n"
"    Determines the extent of the returned collection of viaSpecs:\n"
"    oacViaSpecIterAll -- The collection contains all viaSpecs defined in this and all referenced tech databases\n"
"    oacViaSpecIterLocal -- The collection contains the viaSpecs defined locally in this tech database\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
;

static PyObject*
oaTech_getViaSpecsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaViaSpec* result= new oaIter_oaViaSpec(data.DataCall()->getViaSpecs());
            return PyoaIter_oaViaSpec_FromoaIter_oaViaSpec(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaViaSpec* result= new oaIter_oaViaSpec(data.DataCall()->getViaSpecs(p1.Data()));
            return PyoaIter_oaViaSpec_FromoaIter_oaViaSpec(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: getViaSpecsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_hasDefaultConstraintGroup_doc[] = 
"Class: oaTech, Function: hasDefaultConstraintGroup\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean hasDefaultConstraintGroup() const\n"
"    Signature: hasDefaultConstraintGroup|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether or not there is a default constraint group for this tech database.\n"
;

static PyObject*
oaTech_hasDefaultConstraintGroup(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->hasDefaultConstraintGroup());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_hasUnboundRefs_doc[] = 
"Class: oaTech, Function: hasUnboundRefs\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean hasUnboundRefs() const\n"
"    Signature: hasUnboundRefs|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns true if this database has unbound tech database references (or if it has no tech database references). Otherwise, false is returned.\n"
"    The existence of an unbound tech database reference affects the search order when looking up technology objects in incremental tech databases. For more information about the search order, refer to Referencing Technology Databases in the Programmers Guide.\n"
;

static PyObject*
oaTech_hasUnboundRefs(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->hasUnboundRefs());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_isClearanceMeasureSet_doc[] = 
"Class: oaTech, Function: isClearanceMeasureSet\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isClearanceMeasureSet() const\n"
"    Signature: isClearanceMeasureSet|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns true if the clearance measure attribute is explicitly set in the technology database; false is returned otherwise.\n"
;

static PyObject*
oaTech_isClearanceMeasureSet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isClearanceMeasureSet());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_isDBUPerUUSet_doc[] = 
"Class: oaTech, Function: isDBUPerUUSet\n"
"  Paramegers: (oaViewType)\n"
"    Calls: oaBoolean isDBUPerUUSet(const oaViewType* viewType) const\n"
"    Signature: isDBUPerUUSet|simple-oaBoolean|cptr-oaViewType,\n"
"    This function returns true if the DBUPerUU attribute for the specified viewType is explicitly set in the technology database; false is returned otherwise.\n"
"    viewType\n"
"    A pointer to an oaViewType that corresponds to the specified type oaReservedViewType . It needs to be one of the reserved design viewTypes: maskLayout, schematic, schematicSymbol, netlist, or oaHierDesign.\n"
;

static PyObject*
oaTech_isDBUPerUUSet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViewType p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaViewType_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->isDBUPerUUSet(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_isDefaultManufacturingGridSet_doc[] = 
"Class: oaTech, Function: isDefaultManufacturingGridSet\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isDefaultManufacturingGridSet() const\n"
"    Signature: isDefaultManufacturingGridSet|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns true if the default manufacturing grid attribute is explicitly set in the technology database; false is returned otherwise.\n"
;

static PyObject*
oaTech_isDefaultManufacturingGridSet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isDefaultManufacturingGridSet());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_isGateGrounded_doc[] = 
"Class: oaTech, Function: isGateGrounded\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isGateGrounded() const\n"
"    Signature: isGateGrounded|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value indicating whether or not the gates are considered grounded in this tech database.\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: oaBoolean isGateGrounded(oaBoolean local) const\n"
"    Signature: isGateGrounded|simple-oaBoolean|simple-oaBoolean,\n"
"    This function returns a boolean indicating whether or not the gates are considered grounded. The local argument specifies whether, if true, to look only in this technology database or, if false, to search this technology database and all of its referenced technology databases for the effective boolean value.\n"
"    local\n"
"    If true, look only in this technology database; if false, search this technology database and all its referenced technology databases.\n"
;

static PyObject*
oaTech_isGateGrounded(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaBoolean result= (data.DataCall()->isGateGrounded());
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            oaBoolean result= (data.DataCall()->isGateGrounded(p1.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: isGateGrounded, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_isGateGroundedSet_doc[] = 
"Class: oaTech, Function: isGateGroundedSet\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isGateGroundedSet() const\n"
"    Signature: isGateGroundedSet|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns true if the gates-are-considered-grounded attribute is explicitly set in the technology database; false is returned otherwise.\n"
;

static PyObject*
oaTech_isGateGroundedSet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isGateGroundedSet());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_isModified_doc[] = 
"Class: oaTech, Function: isModified\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isModified() const\n"
"    Signature: isModified|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value that indicates if this tech database has been modified but not saved.\n"
;

static PyObject*
oaTech_isModified(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isModified());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_isUserUnitsSet_doc[] = 
"Class: oaTech, Function: isUserUnitsSet\n"
"  Paramegers: (oaViewType)\n"
"    Calls: oaBoolean isUserUnitsSet(const oaViewType* viewType) const\n"
"    Signature: isUserUnitsSet|simple-oaBoolean|cptr-oaViewType,\n"
"    This function returns true if the user-unit attribute for the specified viewType is explicitly set in the technology database; false is returned otherwise.\n"
"    viewType\n"
"    The viewType to check.\n"
;

static PyObject*
oaTech_isUserUnitsSet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViewType p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaViewType_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->isUserUnitsSet(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_minimizeVM_doc[] = 
"Class: oaTech, Function: minimizeVM\n"
"  Paramegers: ()\n"
"    Calls: void minimizeVM()\n"
"    Signature: minimizeVM|void-void|\n"
"    BrowseData: 0\n"
"    This function minimizes the amount of virtual memory this tech is currently using. It releases dynamically allocated data structures that can be rebuilt as needed.\n"
"    Applications can call this function after creating a tech or making significant edits to an existing tech, before starting a phase of processing that interacts with the tech in different ways.\n"
"    This function should be called sparingly, as it can have a substantial impact on the performance of subsequent operations.\n"
;

static PyObject*
oaTech_minimizeVM(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->minimizeVM();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_purge_doc[] = 
"Class: oaTech, Function: purge\n"
"  Paramegers: ()\n"
"    Calls: void purge()\n"
"    Signature: purge|void-void|\n"
"    BrowseData: 0\n"
"    This function closes this tech database, removing it from memory regardless of its reference count.\n"
;

static PyObject*
oaTech_purge(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->purge();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_reopen_doc[] = 
"Class: oaTech, Function: reopen\n"
"  Paramegers: (oaChar)\n"
"    Calls: void reopen(oaChar mode)\n"
"    Signature: reopen|void-void|simple-oaChar,\n"
"    This function reopens this tech database using the specified access mode . You can reset or truncate the contents of the tech database depending on the new access mode. This function does not affect the reference count of the tech database.\n"
"    mode\n"
"    The mode in which to open the design\n"
"    'r' for read\n"
"    'w' for write (truncate by deleting existing data)\n"
"    'a' for append\n"
"    'A' for append in override mode, which is not typically used. Refer to Compatibility for OpenAccess Applications and Data in the Programmers Guide for more information.\n"
"    oacOpenOnTechBeingPurged\n"
"    oacDataNotCompatibleOnOpenInAppendMode\n"
"    The design contains new features that are not understood by this version of OpenAccess and cannot be opened in append mode\n"
"    oacDataNotCompatibleOnOpenInEditableMode\n"
"    The design contains new features that are not understood by this version of OpenAccess and cannot be opened in 'a'ppend or 'A'ppend mode\n"
"    oacCannotDowngradeDatabase\n"
"    The database was opened in  A  mode and cannot be reopened in 'a' mode\n"
;

static PyObject*
oaTech_reopen(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaChar p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaChar_Convert,&p1)) {
        data.DataCall()->reopen(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_revert_doc[] = 
"Class: oaTech, Function: revert\n"
"  Paramegers: ()\n"
"    Calls: void revert()\n"
"    Signature: revert|void-void|\n"
"    BrowseData: 0\n"
"    This function reloads the contents of this tech database from disk. If the tech database is open in write mode, it is simply truncated. This function does not affect the access mode of the tech database.\n"
;

static PyObject*
oaTech_revert(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->revert();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_save_doc[] = 
"Class: oaTech, Function: save\n"
"  Paramegers: ()\n"
"    Calls: void save()\n"
"    Signature: save|void-void|\n"
"    BrowseData: 0\n"
"    This function saves the tech database to disk. The tech remains open and all of its in-memory data remains valid.\n"
"    oacSaveReadOnlyTech\n"
"    oacDataNotCompatibleOnSave\n"
"    Design contains incompatible data and cannot be saved\n"
;

static PyObject*
oaTech_save(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->save();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_saveAs_doc[] = 
"Class: oaTech, Function: saveAs\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void saveAs(const oaScalarName& libName)\n"
"    Signature: saveAs|void-void|cref-oaScalarName,\n"
"    This function saves the tech database to the disk in the tech file associated with the specified library name. The tech remains open and all of its in-memory data remains valid.\n"
"    libName\n"
"    The name of the library in which to save the tech database\n"
"    oacTechLibNotFound\n"
"    oacDataNotCompatibleOnSave\n"
"    Design contains incompatible data and cannot be saved\n"
;

static PyObject*
oaTech_saveAs(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScalarName p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaScalarName_Convert,&p1)) {
        data.DataCall()->saveAs(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_setClearanceMeasure_doc[] = 
"Class: oaTech, Function: setClearanceMeasure\n"
"  Paramegers: (oaClearanceMeasure)\n"
"    Calls: void setClearanceMeasure(oaClearanceMeasure measure)\n"
"    Signature: setClearanceMeasure|void-void|simple-oaClearanceMeasure,\n"
"    This function sets the clearance measurement value for this technology database.\n"
"    measure\n"
"    The clearance measurement value\n"
"    oacConflictingClearanceMeasureInTech\n"
"    The ClearanceMeasure tech attribute cannot be set as indicated because it would introduce conflicts in the specified tech graph\n"
;

static PyObject*
oaTech_setClearanceMeasure(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaClearanceMeasure p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaClearanceMeasure_Convert,&p1)) {
        data.DataCall()->setClearanceMeasure(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_setDBUPerUU_doc[] = 
"Class: oaTech, Function: setDBUPerUU\n"
"  Paramegers: (oaViewType,oaUInt4)\n"
"    Calls: void setDBUPerUU(const oaViewType* viewType,oaUInt4 value)\n"
"    Signature: setDBUPerUU|void-void|cptr-oaViewType,simple-oaUInt4,\n"
"    oaTech::setDBUPerUU\n"
"    This function sets the database-units per user-unit information in the technology database for the specified viewType .\n"
"    The viewTypes allowed in this call are the subset of oaReservedViewType values that are used as viewTypes for an oaDesign . These are: oacMaskLayout , oacSchematic , oacSchematicSymbol , oacNetlist , or oacHierDesign .\n"
"    The caller can construct the viewType inline with this function call as in: tech->setDBUPerUU(oaViewType::get(oacMaskLayout), 2000)\n"
"    Note: Significant flow issues result when you combine layouts that use different DBUPerUU settings in a project resulting in a single mask. To avoid any issues, use a single DBUPerUU setting that is a function of the manufacturing grid for the given technology, as outlined in the following table.\n"
"    Manufacturing Grid\n"
"    Typically Used at\n"
"    DBperUUs that Work (mathematically)\n"
"    Recommended\n"
"    0.1 micron (100 nm)\n"
"    1 micron and above\n"
"    100, 200, 1000, or 2000\n"
"    1000\n"
"    0.05 micron (50 nm)\n"
"    0.5 micron and above\n"
"    200, 1000, or 2000\n"
"    1000\n"
"    0.01 micron (10 nm)\n"
"    250 nm and above\n"
"    200, 1000, or 2000\n"
"    1000\n"
"    0.005 micron (5 nm)\n"
"    90 nm and above\n"
"    2000\n"
"    2000\n"
"    0.0025 micron (2.5 nm)\n"
"    Experimental\n"
"    800,1600,4000\n"
"    2000*\n"
"    0.002 micron (2 nm)\n"
"    Experimental\n"
"    1000,2000\n"
"    2000\n"
"    0.001 micron (1 nm)\n"
"    Not yet needed\n"
"    2000\n"
"    2000\n"
"    viewType\n"
"    Pointer to an oaViewType for the type of design to set the value for\n"
"    value\n"
"    The number of database-units that represent a distance of 1 user-unit\n"
"    oacInvalidDBUPerUU\n"
"    oacConflictingDBUPerUUInTech\n"
;

static PyObject*
oaTech_setDBUPerUU(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViewType p1;
    PyParamoaUInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViewType_Convert,&p1,
          &PyoaUInt4_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->setDBUPerUU(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_setDefaultManufacturingGrid_doc[] = 
"Class: oaTech, Function: setDefaultManufacturingGrid\n"
"  Paramegers: (oaDist)\n"
"    Calls: void setDefaultManufacturingGrid(oaDist grid)\n"
"    Signature: setDefaultManufacturingGrid|void-void|simple-oaDist,\n"
"    This function sets the manufacturing grid that applies to all physical layers unless it has been overridden at the physical layer level.\n"
"    grid\n"
"    The new value for the default manufacturing grid. An oaDist is an oaUInt4 that represents the non-negative distance, along one axis, between two oaCoord values.\n"
"    oacConflictingDefaultManufacturingGridInTech\n"
;

static PyObject*
oaTech_setDefaultManufacturingGrid(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDist p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaDist_Convert,&p1)) {
        data.DataCall()->setDefaultManufacturingGrid(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_setGateGrounded_doc[] = 
"Class: oaTech, Function: setGateGrounded\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: void setGateGrounded(oaBoolean gateGrounded)\n"
"    Signature: setGateGrounded|void-void|simple-oaBoolean,\n"
"    This function sets the gateGrounded attribute in this technology database.\n"
"    gateGrounded\n"
"    Boolean that specifies whether or not the gates are considered grounded\n"
"    oacConflictingGateGroundedInTech\n"
"    The GateGrounded tech attribute cannot be set as indicated because it would introduce conflicts in the specified tech graph\n"
;

static PyObject*
oaTech_setGateGrounded(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBoolean p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBoolean_Convert,&p1)) {
        data.DataCall()->setGateGrounded(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_setRefs_doc[] = 
"Class: oaTech, Function: setRefs\n"
"  Paramegers: (oaTechArray)\n"
"    Calls: void setRefs(const oaTechArray& refs)\n"
"    Signature: setRefs|void-void|cref-oaTechArray,\n"
"    This function sets the tech database references for this tech. A reference is a mechanism that allows this tech database to inherit information from other techs. The set of referenced tech databases is known as the graph of techs. This function removes any previously existing references (as a result, some oaTechLayerHeaders and oaTechViaDefHeaders may become and remain unbound).\n"
"    An oacTechSetRefsConflicts exception is thrown if this function:\n"
"    Introduces a technology object with the same name (or other key attribute) as another technology object in the graph.\n"
"    Introduces a technology attribute with the same name as another technology attribute in the graph that has a different value for the attribute.\n"
"    Introduces a constraint group with the same name as another constraint group in the graph.\n"
"    An oacTechCannotSetDuplicateRefs exception is thrown if this function attempts to set duplicate tech database references on a tech database.\n"
"    An oacTechSetRefsCircularReference exception is thrown if an attempt is made to set a reference on this database so that its graph chain refers back to this tech db (if techA->techB->techC and this function attempts to set techC->techA).\n"
"    OpenAccess issues onConflict observer notifications and issues exceptions for the above errors.\n"
"    When setRefs() is used, pre and post-modify observers are called from oaObserver<oaTech> using the oacSetRefsTechModType.\n"
"    For more information about setting references, refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide.\n"
"    refs\n"
"    An array of oaTech pointers to reference\n"
"    oacTechSetRefsConflicts\n"
"    This exception is thrown if any conflict is discovered in the graph of tech databases.\n"
"    oacTechCannotSetDuplicateRefs\n"
"    This exception is throw if there is a duplicate database reference in the refs array. For example, if the ref array contains (techB, techB).\n"
"    oacTechSetRefsCircularReference\n"
"    This exception is thrown if an attempt is made to set a reference on this database so that its graph chain refers back to this tech db (if techA->techB->techC and this function attempts to set techC->techA).\n"
"    oacTechSetRefsCannotOpenAllRefGraphs\n"
"    This exception is thrown if all technology databases in the graph are not open and setRefs fails to open any of them. All technology databases in the graph must be open for setRefs to proceed.\n"
;

static PyObject*
oaTech_setRefs(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTechArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTechArray_Convert,&p1)) {
        data.DataCall()->setRefs(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_setUserUnits_doc[] = 
"Class: oaTech, Function: setUserUnits\n"
"  Paramegers: (oaViewType,oaUserUnitsType)\n"
"    Calls: void setUserUnits(const oaViewType* viewType,oaUserUnitsType value)\n"
"    Signature: setUserUnits|void-void|cptr-oaViewType,simple-oaUserUnitsType,\n"
"    This function sets the user-unit information in the technology database for the specified viewType .\n"
"    Note: Although users can construct their own oaViewTypes, valid viewTypes for this function are restricted to the set of reserved viewTypes, namely, an oaReservedViewType object constructed with one of the following reserved view type enumerated constants: oacMaskLayout , oacSchematic , oacSchematicSymbol , oacNetlist , or oacHierDesign .\n"
"    The developer can call oaViewType::get(oaReservedViewType) to construct and return a pointer to an a oaViewType object using one of the valid reserved viewType enumerated constants (for example, oaViewType::get(oacMaskLayout) or oaViewType::get (oaReservedViewType(oacMaskLayout)) .\n"
"    viewType\n"
"    A pointer to an oaViewType that corresponds to the specified type oaReservedViewType . It needs to be one of the reserved design viewTypes: maskLayout, schematic, schematicSymbol, netlist, or oaHierDesign.\n"
"    value\n"
"    The user-unit value to set\n"
"    oacConflictingUserUnitsInTech\n"
;

static PyObject*
oaTech_setUserUnits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViewType p1;
    PyParamoaUserUnitsType p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViewType_Convert,&p1,
          &PyoaUserUnitsType_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->setUserUnits(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_unsetClearanceMeasure_doc[] = 
"Class: oaTech, Function: unsetClearanceMeasure\n"
"  Paramegers: ()\n"
"    Calls: void unsetClearanceMeasure()\n"
"    Signature: unsetClearanceMeasure|void-void|\n"
"    BrowseData: 0\n"
"    This function reverts the clearance measure attribute back to its unset state in the technology database.\n"
"    oacUnsetClearanceMeasureNotSet\n"
;

static PyObject*
oaTech_unsetClearanceMeasure(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->unsetClearanceMeasure();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_unsetDBUPerUU_doc[] = 
"Class: oaTech, Function: unsetDBUPerUU\n"
"  Paramegers: (oaViewType)\n"
"    Calls: void unsetDBUPerUU(const oaViewType* viewType)\n"
"    Signature: unsetDBUPerUU|void-void|cptr-oaViewType,\n"
"    This function reverts the database-units per user-unit attribute for the specified viewType back to its unset state in the technology database.\n"
"    viewType\n"
"    A pointer to an oaViewType that corresponds to the specified type oaReservedViewType . It needs to be one of the reserved design viewTypes: maskLayout, schematic, schematicSymbol, netlist, or oaHierDesign.\n"
"    oacUnsetDBUPerUUNotSet\n"
;

static PyObject*
oaTech_unsetDBUPerUU(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViewType p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaViewType_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->unsetDBUPerUU(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_unsetDefaultManufacturingGrid_doc[] = 
"Class: oaTech, Function: unsetDefaultManufacturingGrid\n"
"  Paramegers: ()\n"
"    Calls: void unsetDefaultManufacturingGrid()\n"
"    Signature: unsetDefaultManufacturingGrid|void-void|\n"
"    BrowseData: 0\n"
"    This function reverts the default manufacturing grid attribute back to its unset state in the technology database.\n"
"    oacUnsetDefaultManufacturingGridNotSet\n"
;

static PyObject*
oaTech_unsetDefaultManufacturingGrid(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->unsetDefaultManufacturingGrid();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_unsetGateGrounded_doc[] = 
"Class: oaTech, Function: unsetGateGrounded\n"
"  Paramegers: ()\n"
"    Calls: void unsetGateGrounded()\n"
"    Signature: unsetGateGrounded|void-void|\n"
"    BrowseData: 0\n"
"    This function reverts the gates-are-considered-grounded attribute back to its unset state in the technology database.\n"
"    oacUnsetGateGroundedNotSet\n"
;

static PyObject*
oaTech_unsetGateGrounded(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->unsetGateGrounded();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_unsetRefs_doc[] = 
"Class: oaTech, Function: unsetRefs\n"
"  Paramegers: ()\n"
"    Calls: void unsetRefs()\n"
"    Signature: unsetRefs|void-void|\n"
"    BrowseData: 0\n"
"    This function removes all references to other tech databases. No operation is performed if this tech database has no references. For more information about tech database references, refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide.\n"
"    Removing existing oaTech database references might cause some oaTechLayerHeaders and oaTechViaDefHeaders to become unbound and remain that way.\n"
;

static PyObject*
oaTech_unsetRefs(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->unsetRefs();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_unsetUserUnits_doc[] = 
"Class: oaTech, Function: unsetUserUnits\n"
"  Paramegers: (oaViewType)\n"
"    Calls: void unsetUserUnits(const oaViewType* viewType)\n"
"    Signature: unsetUserUnits|void-void|cptr-oaViewType,\n"
"    This function reverts the user-unit attribute for the specified viewType back to its unset state in the technology database.\n"
"    viewType\n"
"    A pointer to an oaViewType that corresponds to the specified type oaReservedViewType . It needs to be one of the reserved design viewTypes: maskLayout, schematic, schematicSymbol, netlist, or oaHierDesign.\n"
"    oacUnsetUserUnitsNotSet\n"
;

static PyObject*
oaTech_unsetUserUnits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViewType p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaViewType_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->unsetUserUnits(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_uuToDBU_doc[] = 
"Class: oaTech, Function: uuToDBU\n"
"  Paramegers: (oaViewType,oaDouble)\n"
"    Calls: oaInt4 uuToDBU(const oaViewType* viewType,oaDouble value)\n"
"    Signature: uuToDBU|simple-oaInt4|cptr-oaViewType,simple-oaDouble,\n"
"    This function converts the user units into database units for the specified viewType .\n"
"    The viewTypes allowed in this call are the subset of oaReservedViewType values that are used as viewTypes for an oaDesign . These are: oacMaskLayout , oacSchematic , oacSchematicSymbol , oacNetlist , or oacHierDesign .\n"
"    The caller can construct the viewType inline with this function call as in: tech->uuToDBU(oaViewType::get(oacMaskLayout), 22.6)\n"
"    viewType\n"
"    A pointer to an oaViewType that corresponds to the specified type oaReservedViewType . It needs to be one of the reserved design viewTypes: maskLayout, schematic, schematicSymbol, netlist, or oaHierDesign.\n"
"    value\n"
"    The value in user units to convert to database units\n"
;

static PyObject*
oaTech_uuToDBU(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViewType p1;
    PyParamoaDouble p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViewType_Convert,&p1,
          &PyoaDouble_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaInt4 result= (data.DataCall()->uuToDBU(p1.Data(),p2.Data()));
        return PyoaInt4_FromoaInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_uuToDBUArea_doc[] = 
"Class: oaTech, Function: uuToDBUArea\n"
"  Paramegers: (oaViewType,oaDouble)\n"
"    Calls: oaUInt8 uuToDBUArea(const oaViewType* viewType,oaDouble value)\n"
"    Signature: uuToDBUArea|simple-oaUInt8|cptr-oaViewType,simple-oaDouble,\n"
"    This function converts the area in square user units to an area in square database units for the specified viewType .\n"
"    The viewTypes allowed in this call are the subset of oaReservedViewType values that are used as viewTypes for an oaDesign . These are: oacMaskLayout , oacSchematic , oacSchematicSymbol , oacNetlist , or oacHierDesign .\n"
"    The caller can construct the viewType inline with this function call as in: tech->uuToDBUArea(oaViewType::get(oacMaskLayout), 184.0)\n"
"    viewType\n"
"    A pointer to an oaViewType that corresponds to the specified type oaReservedViewType . It needs to be one of the reserved design viewTypes: maskLayout, schematic, schematicSymbol, netlist, or oaHierDesign.\n"
"    value\n"
"    The area in user units to convert to database units\n"
;

static PyObject*
oaTech_uuToDBUArea(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViewType p1;
    PyParamoaDouble p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViewType_Convert,&p1,
          &PyoaDouble_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt8 result= (data.DataCall()->uuToDBUArea(p1.Data(),p2.Data()));
        return PyoaUInt8_FromoaUInt8(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_uuToDBUDistance_doc[] = 
"Class: oaTech, Function: uuToDBUDistance\n"
"  Paramegers: (oaViewType,oaDouble)\n"
"    Calls: oaUInt4 uuToDBUDistance(const oaViewType* viewType,oaDouble value)\n"
"    Signature: uuToDBUDistance|simple-oaUInt4|cptr-oaViewType,simple-oaDouble,\n"
"    This function converts the user-unit distance to database-unit distance for the specified viewType .\n"
"    The viewTypes allowed in this call are the subset of oaReservedViewType values that are used as viewTypes for an oaDesign . These are: oacMaskLayout , oacSchematic , oacSchematicSymbol , oacNetlist , or oacHierDesign .\n"
"    The caller can construct the viewType inline with this function call as in: tech->uuToDBU(oaViewType::get(oacMaskLayout), 22.6)\n"
"    viewType\n"
"    A pointer to an oaViewType that corresponds to the specified type oaReservedViewType . It needs to be one of the reserved design viewTypes: maskLayout, schematic, schematicSymbol, netlist, or oaHierDesign.\n"
"    value\n"
"    The distance in user units to convert to database units\n"
;

static PyObject*
oaTech_uuToDBUDistance(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaViewType p1;
    PyParamoaDouble p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaViewType_Convert,&p1,
          &PyoaDouble_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (data.DataCall()->uuToDBUDistance(p1.Data(),p2.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_validate_doc[] = 
"Class: oaTech, Function: validate\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean validate() const\n"
"    Signature: validate|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns false if there are multiple objects with the same attributes or conflicting parameter values in the technology database graph rooted at this tech database. It returns true otherwise. OpenAccess issues onConflict observer notifications for the conflicts.\n"
"    For more information, refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide.\n"
;

static PyObject*
oaTech_validate(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechObject* self=(PyoaTechObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->validate());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_isNull_doc[] =
"Class: oaTech, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaTech_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaTech data;
    int convert_status=PyoaTech_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaTech_assign_doc[] = 
"Class: oaTech, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaTech_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaTech data;
  int convert_status=PyoaTech_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaTech p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaTech_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaTech_methodlist[] = {
    {"calcVMSize",(PyCFunction)oaTech_calcVMSize,METH_VARARGS,oaTech_calcVMSize_doc},
    {"close",(PyCFunction)oaTech_close,METH_VARARGS,oaTech_close_doc},
    {"dbuToUU",(PyCFunction)oaTech_dbuToUU,METH_VARARGS,oaTech_dbuToUU_doc},
    {"dbuToUUArea",(PyCFunction)oaTech_dbuToUUArea,METH_VARARGS,oaTech_dbuToUUArea_doc},
    {"dbuToUUDistance",(PyCFunction)oaTech_dbuToUUDistance,METH_VARARGS,oaTech_dbuToUUDistance_doc},
    {"enableTimeStamps",(PyCFunction)oaTech_enableTimeStamps,METH_VARARGS,oaTech_enableTimeStamps_doc},
    {"getAnalysisLibs",(PyCFunction)oaTech_getAnalysisLibs,METH_VARARGS,oaTech_getAnalysisLibs_doc},
    {"getAnalysisLibsIter",(PyCFunction)oaTech_getAnalysisLibsIter,METH_VARARGS,oaTech_getAnalysisLibsIter_doc},
    {"getAppDefsByDataType",(PyCFunction)oaTech_getAppDefsByDataType,METH_VARARGS,oaTech_getAppDefsByDataType_doc},
    {"getAppDefsByDataTypeIter",(PyCFunction)oaTech_getAppDefsByDataTypeIter,METH_VARARGS,oaTech_getAppDefsByDataTypeIter_doc},
    {"getAppObjectDefs",(PyCFunction)oaTech_getAppObjectDefs,METH_VARARGS,oaTech_getAppObjectDefs_doc},
    {"getAppObjectDefsIter",(PyCFunction)oaTech_getAppObjectDefsIter,METH_VARARGS,oaTech_getAppObjectDefsIter_doc},
    {"getAppObjects",(PyCFunction)oaTech_getAppObjects,METH_VARARGS,oaTech_getAppObjects_doc},
    {"getAppObjectsIter",(PyCFunction)oaTech_getAppObjectsIter,METH_VARARGS,oaTech_getAppObjectsIter_doc},
    {"getClearanceMeasure",(PyCFunction)oaTech_getClearanceMeasure,METH_VARARGS,oaTech_getClearanceMeasure_doc},
    {"getConstraintGroupHeaders",(PyCFunction)oaTech_getConstraintGroupHeaders,METH_VARARGS,oaTech_getConstraintGroupHeaders_doc},
    {"getConstraintGroupHeadersIter",(PyCFunction)oaTech_getConstraintGroupHeadersIter,METH_VARARGS,oaTech_getConstraintGroupHeadersIter_doc},
    {"getConstraintGroups",(PyCFunction)oaTech_getConstraintGroups,METH_VARARGS,oaTech_getConstraintGroups_doc},
    {"getConstraintGroupsIter",(PyCFunction)oaTech_getConstraintGroupsIter,METH_VARARGS,oaTech_getConstraintGroupsIter_doc},
    {"getConstraintParams",(PyCFunction)oaTech_getConstraintParams,METH_VARARGS,oaTech_getConstraintParams_doc},
    {"getConstraintParamsIter",(PyCFunction)oaTech_getConstraintParamsIter,METH_VARARGS,oaTech_getConstraintParamsIter_doc},
    {"getConstraints",(PyCFunction)oaTech_getConstraints,METH_VARARGS,oaTech_getConstraints_doc},
    {"getConstraintsIter",(PyCFunction)oaTech_getConstraintsIter,METH_VARARGS,oaTech_getConstraintsIter_doc},
    {"getCreateTime",(PyCFunction)oaTech_getCreateTime,METH_VARARGS,oaTech_getCreateTime_doc},
    {"getDBUPerUU",(PyCFunction)oaTech_getDBUPerUU,METH_VARARGS,oaTech_getDBUPerUU_doc},
    {"getDefaultConstraintGroup",(PyCFunction)oaTech_getDefaultConstraintGroup,METH_VARARGS,oaTech_getDefaultConstraintGroup_doc},
    {"getDefaultManufacturingGrid",(PyCFunction)oaTech_getDefaultManufacturingGrid,METH_VARARGS,oaTech_getDefaultManufacturingGrid_doc},
    {"getDerivedLayerParams",(PyCFunction)oaTech_getDerivedLayerParams,METH_VARARGS,oaTech_getDerivedLayerParams_doc},
    {"getDerivedLayerParamsIter",(PyCFunction)oaTech_getDerivedLayerParamsIter,METH_VARARGS,oaTech_getDerivedLayerParamsIter_doc},
    {"getFoundryRules",(PyCFunction)oaTech_getFoundryRules,METH_VARARGS,oaTech_getFoundryRules_doc},
    {"getGroups",(PyCFunction)oaTech_getGroups,METH_VARARGS,oaTech_getGroups_doc},
    {"getGroupsByName",(PyCFunction)oaTech_getGroupsByName,METH_VARARGS,oaTech_getGroupsByName_doc},
    {"getGroupsByNameIter",(PyCFunction)oaTech_getGroupsByNameIter,METH_VARARGS,oaTech_getGroupsByNameIter_doc},
    {"getGroupsIter",(PyCFunction)oaTech_getGroupsIter,METH_VARARGS,oaTech_getGroupsIter_doc},
    {"getLastSavedTime",(PyCFunction)oaTech_getLastSavedTime,METH_VARARGS,oaTech_getLastSavedTime_doc},
    {"getLayerHeaders",(PyCFunction)oaTech_getLayerHeaders,METH_VARARGS,oaTech_getLayerHeaders_doc},
    {"getLayerHeadersIter",(PyCFunction)oaTech_getLayerHeadersIter,METH_VARARGS,oaTech_getLayerHeadersIter_doc},
    {"getLayers",(PyCFunction)oaTech_getLayers,METH_VARARGS,oaTech_getLayers_doc},
    {"getLayersIter",(PyCFunction)oaTech_getLayersIter,METH_VARARGS,oaTech_getLayersIter_doc},
    {"getLib",(PyCFunction)oaTech_getLib,METH_VARARGS,oaTech_getLib_doc},
    {"getLibName",(PyCFunction)oaTech_getLibName,METH_VARARGS,oaTech_getLibName_doc},
    {"getMode",(PyCFunction)oaTech_getMode,METH_VARARGS,oaTech_getMode_doc},
    {"getOpPoints",(PyCFunction)oaTech_getOpPoints,METH_VARARGS,oaTech_getOpPoints_doc},
    {"getOpPointsIter",(PyCFunction)oaTech_getOpPointsIter,METH_VARARGS,oaTech_getOpPointsIter_doc},
    {"getPurposes",(PyCFunction)oaTech_getPurposes,METH_VARARGS,oaTech_getPurposes_doc},
    {"getPurposesIter",(PyCFunction)oaTech_getPurposesIter,METH_VARARGS,oaTech_getPurposesIter_doc},
    {"getReadInTime",(PyCFunction)oaTech_getReadInTime,METH_VARARGS,oaTech_getReadInTime_doc},
    {"getRefCount",(PyCFunction)oaTech_getRefCount,METH_VARARGS,oaTech_getRefCount_doc},
    {"getSiteDefs",(PyCFunction)oaTech_getSiteDefs,METH_VARARGS,oaTech_getSiteDefs_doc},
    {"getSiteDefsIter",(PyCFunction)oaTech_getSiteDefsIter,METH_VARARGS,oaTech_getSiteDefsIter_doc},
    {"getTechHeaders",(PyCFunction)oaTech_getTechHeaders,METH_VARARGS,oaTech_getTechHeaders_doc},
    {"getTimeStamp",(PyCFunction)oaTech_getTimeStamp,METH_VARARGS,oaTech_getTimeStamp_doc},
    {"getUsedIn",(PyCFunction)oaTech_getUsedIn,METH_VARARGS,oaTech_getUsedIn_doc},
    {"getUsedInIter",(PyCFunction)oaTech_getUsedInIter,METH_VARARGS,oaTech_getUsedInIter_doc},
    {"getUserUnits",(PyCFunction)oaTech_getUserUnits,METH_VARARGS,oaTech_getUserUnits_doc},
    {"getValues",(PyCFunction)oaTech_getValues,METH_VARARGS,oaTech_getValues_doc},
    {"getValuesIter",(PyCFunction)oaTech_getValuesIter,METH_VARARGS,oaTech_getValuesIter_doc},
    {"getViaDefHeaders",(PyCFunction)oaTech_getViaDefHeaders,METH_VARARGS,oaTech_getViaDefHeaders_doc},
    {"getViaDefHeadersIter",(PyCFunction)oaTech_getViaDefHeadersIter,METH_VARARGS,oaTech_getViaDefHeadersIter_doc},
    {"getViaDefs",(PyCFunction)oaTech_getViaDefs,METH_VARARGS,oaTech_getViaDefs_doc},
    {"getViaDefsIter",(PyCFunction)oaTech_getViaDefsIter,METH_VARARGS,oaTech_getViaDefsIter_doc},
    {"getViaSpecs",(PyCFunction)oaTech_getViaSpecs,METH_VARARGS,oaTech_getViaSpecs_doc},
    {"getViaSpecsIter",(PyCFunction)oaTech_getViaSpecsIter,METH_VARARGS,oaTech_getViaSpecsIter_doc},
    {"hasDefaultConstraintGroup",(PyCFunction)oaTech_hasDefaultConstraintGroup,METH_VARARGS,oaTech_hasDefaultConstraintGroup_doc},
    {"hasUnboundRefs",(PyCFunction)oaTech_hasUnboundRefs,METH_VARARGS,oaTech_hasUnboundRefs_doc},
    {"isClearanceMeasureSet",(PyCFunction)oaTech_isClearanceMeasureSet,METH_VARARGS,oaTech_isClearanceMeasureSet_doc},
    {"isDBUPerUUSet",(PyCFunction)oaTech_isDBUPerUUSet,METH_VARARGS,oaTech_isDBUPerUUSet_doc},
    {"isDefaultManufacturingGridSet",(PyCFunction)oaTech_isDefaultManufacturingGridSet,METH_VARARGS,oaTech_isDefaultManufacturingGridSet_doc},
    {"isGateGrounded",(PyCFunction)oaTech_isGateGrounded,METH_VARARGS,oaTech_isGateGrounded_doc},
    {"isGateGroundedSet",(PyCFunction)oaTech_isGateGroundedSet,METH_VARARGS,oaTech_isGateGroundedSet_doc},
    {"isModified",(PyCFunction)oaTech_isModified,METH_VARARGS,oaTech_isModified_doc},
    {"isUserUnitsSet",(PyCFunction)oaTech_isUserUnitsSet,METH_VARARGS,oaTech_isUserUnitsSet_doc},
    {"minimizeVM",(PyCFunction)oaTech_minimizeVM,METH_VARARGS,oaTech_minimizeVM_doc},
    {"purge",(PyCFunction)oaTech_purge,METH_VARARGS,oaTech_purge_doc},
    {"reopen",(PyCFunction)oaTech_reopen,METH_VARARGS,oaTech_reopen_doc},
    {"revert",(PyCFunction)oaTech_revert,METH_VARARGS,oaTech_revert_doc},
    {"save",(PyCFunction)oaTech_save,METH_VARARGS,oaTech_save_doc},
    {"saveAs",(PyCFunction)oaTech_saveAs,METH_VARARGS,oaTech_saveAs_doc},
    {"setClearanceMeasure",(PyCFunction)oaTech_setClearanceMeasure,METH_VARARGS,oaTech_setClearanceMeasure_doc},
    {"setDBUPerUU",(PyCFunction)oaTech_setDBUPerUU,METH_VARARGS,oaTech_setDBUPerUU_doc},
    {"setDefaultManufacturingGrid",(PyCFunction)oaTech_setDefaultManufacturingGrid,METH_VARARGS,oaTech_setDefaultManufacturingGrid_doc},
    {"setGateGrounded",(PyCFunction)oaTech_setGateGrounded,METH_VARARGS,oaTech_setGateGrounded_doc},
    {"setRefs",(PyCFunction)oaTech_setRefs,METH_VARARGS,oaTech_setRefs_doc},
    {"setUserUnits",(PyCFunction)oaTech_setUserUnits,METH_VARARGS,oaTech_setUserUnits_doc},
    {"unsetClearanceMeasure",(PyCFunction)oaTech_unsetClearanceMeasure,METH_VARARGS,oaTech_unsetClearanceMeasure_doc},
    {"unsetDBUPerUU",(PyCFunction)oaTech_unsetDBUPerUU,METH_VARARGS,oaTech_unsetDBUPerUU_doc},
    {"unsetDefaultManufacturingGrid",(PyCFunction)oaTech_unsetDefaultManufacturingGrid,METH_VARARGS,oaTech_unsetDefaultManufacturingGrid_doc},
    {"unsetGateGrounded",(PyCFunction)oaTech_unsetGateGrounded,METH_VARARGS,oaTech_unsetGateGrounded_doc},
    {"unsetRefs",(PyCFunction)oaTech_unsetRefs,METH_VARARGS,oaTech_unsetRefs_doc},
    {"unsetUserUnits",(PyCFunction)oaTech_unsetUserUnits,METH_VARARGS,oaTech_unsetUserUnits_doc},
    {"uuToDBU",(PyCFunction)oaTech_uuToDBU,METH_VARARGS,oaTech_uuToDBU_doc},
    {"uuToDBUArea",(PyCFunction)oaTech_uuToDBUArea,METH_VARARGS,oaTech_uuToDBUArea_doc},
    {"uuToDBUDistance",(PyCFunction)oaTech_uuToDBUDistance,METH_VARARGS,oaTech_uuToDBUDistance_doc},
    {"validate",(PyCFunction)oaTech_validate,METH_VARARGS,oaTech_validate_doc},
    {"isNull",(PyCFunction)oaTech_tp_isNull,METH_VARARGS,oaTech_isNull_doc},
    {"assign",(PyCFunction)oaTech_tp_assign,METH_VARARGS,oaTech_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaTech_doc[] = 
"Class: oaTech\n"
"  The oaTech class implements a technology database (oaTech), which contains process information.\n"
"  A library ( oaLib ) typically contains a single technology database, and all the designs in the library use that technology database. Alternatively, a user can define an attachment from one library to the technology database in another library. In this case, all the designs in the library use the attached technology database. Whether in the same library or in a different library, the main technology database associated with a design is known as its primary technology database.\n"
"  Any technology database can contain references to other technology databases. A reference is a mechanism that allows a technology database to inherit information from one or more technology databases. This approach is known as using incremental technology databases .\n"
"  A referenced technology database can itself reference other technology databases to form a chain, known as a graph of technology databases. All the technology information in a graph is available to the design library. When a design is opened, the primary technology database is opened, and if there are any references, the graph of technology databases is opened as well. For more information, refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide.\n"
"  When a technology database contained within a library is opened, it is associated with the library and remains the technology database for that library until the database is purged or the library is closed. When a technology database is associated with a library through attachment, an application can remove the association ( oaTech::detach ) and re-associate the library to another technology database in a different library ( oaTech::attach ).\n"
"  The class can be observed by deriving from oaObserver<oaTech> .\n"
"  Attached oaTech Databases\n"
"  A user can use oaTech::attach to associate a library with a technology database in a different library. In addition, the associations can be made through any number of libraries (using multiple applications of oaTech::attach ) as long as the intermediate libraries do not contain technology databases themselves and the final target library does contain a technology database.\n"
"  Note: To support backward data compatibility, the previous mechanism for attaching technology libraries is still supported. Namely, a string property called techLibName in a library s oaLibDMData database still specifies the name of the target library. The oaTech::attach function creates the techLibName property when it is called. In order to construct the name of the library, the techLibName string is interpreted in the oaNativeNS namespace.\n"
"Constructors:\n"
"  Paramegers: (oaTech)\n"
"    Calls: (const oaTech&)\n"
"    Signature: oaTech||cref-oaTech,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaTech_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaTech",
    sizeof(PyoaTechObject),
    0,
    (destructor)oaTech_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaTech_tp_compare,	/* tp_compare */
    (reprfunc)oaTech_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaTech_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaTech_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaTechObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaTech_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaTech_static_attach_doc[] = 
"Class: oaTech, Function: attach\n"
"  Paramegers: (oaLib,oaScalarName)\n"
"    Calls: void attach(oaLib* lib,const oaScalarName& attachLibName)\n"
"    Signature: attach|void-void|ptr-oaLib,cref-oaScalarName,\n"
"    This function creates a technology attachment between the specified library lib and the library with the name attachLibName . If there is an existing attachment, it is first removed.\n"
"    The oacAttachLibraryHasLocalTech error is thrown if a technology database exists locally in the library lib . The oacDMDataCannotGetWriteAccess error is thrown if the library dmData database in the library lib cannot be opened for editing. Note that the library dmData database is needed because this function creates a string property called techLibName in the dmData that specifies the name of the associated technology library.\n"
"    lib\n"
"    Pointer to the technology library to attach.\n"
"    attachLibName\n"
"    Name of the library to attach to.\n"
"    oacAttachLibraryHasLocalTech\n"
"    oacDMDataCannotGetWriteAccess\n"
;

static PyObject*
oaTech_static_attach(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaLib p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaLib_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaTech::attach(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_static_create_doc[] = 
"Class: oaTech, Function: create\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: oaTech* create(const oaScalarName& libName)\n"
"    Signature: create|ptr-oaTech|cref-oaScalarName,\n"
"    This function creates the tech database for the specified library. An exception is thrown if the tech database already exists or if the specified library uses an attached tech database in another library.\n"
"    libName\n"
"    The name of the library for which to create the tech database\n"
"    A pointer to the new tech database\n"
"    oacLibNotFound\n"
"    oacTechAlreadyExists\n"
"    oacTechLibNotFound\n"
"    oacCannotFindInheritedTechLib\n"
"    oacTechAttachedTechLibDetected\n"
"  Paramegers: (oaLib)\n"
"    Calls: oaTech* create(oaLib* lib)\n"
"    Signature: create|ptr-oaTech|ptr-oaLib,\n"
"    This function creates the tech database for the specified library. An exception is thrown if the tech database already exists or if the specified library uses an attached tech database in another library.\n"
"    lib\n"
"    The library for which to create the tech database\n"
"    A pointer to the new oaTech database\n"
"    oacTechAlreadyExists\n"
"    oacTechLibNotFound\n"
"    oacCannotFindInheritedTechLib\n"
"    oacTechAttachedTechLibDetected\n"
;

static PyObject*
oaTech_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            oaTechp result= (oaTech::create(p1.Data()));
            return PyoaTech_FromoaTech(result);
        }
    }
    PyErr_Clear();
    // Case: (oaLib)
    {
        PyParamoaLib p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaLib_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaTechp result= (oaTech::create(p1.Data()));
            return PyoaTech_FromoaTech(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: create, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaLib)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_static_destroy_doc[] = 
"Class: oaTech, Function: destroy\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void destroy(const oaScalarName& libName)\n"
"    Signature: destroy|void-void|cref-oaScalarName,\n"
"    This function attempts to remove the tech database associated with the library specified by libName .\n"
"    The tech database for the library will be removed from disk. If no tech database exists, but the library uses an attached tech database specified with the \"techLibName\" property, then the attachment property will be removed. It is not an error to remove the oaTech database even if other libraries use this tech database as an attached tech. An exception is thrown if the tech database is open.\n"
"    See the oaTech class description for more information about attached tech databases.\n"
"    libName\n"
"    The library containing the tech database to destroy\n"
"    oacTechLibNotFound\n"
"    oacDestroyTechOpen\n"
"    oacDestroyWithAttachProperty\n"
"  Paramegers: (oaLib)\n"
"    Calls: void destroy(oaLib* lib)\n"
"    Signature: destroy|void-void|ptr-oaLib,\n"
"    This function attempts to remove the tech database associated with the library specified by lib .\n"
"    The tech database for the library will be removed from disk. If no tech database exists, but the library uses an attached tech database specified with the \"techLibName\" property, then the attachment property will be removed. It is not an error to remove the tech database even if other libraries use this tech as an attached tech. An exception is thrown if the tech database is open.\n"
"    See the oaTech class description for more information about attached tech databases.\n"
"    lib\n"
"    A pointer to the library containing the tech database to destroy\n"
"    oacDestroyTechOpen\n"
;

static PyObject*
oaTech_static_destroy(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            oaTech::destroy(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaLib)
    {
        PyParamoaLib p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaLib_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaTech::destroy(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: destroy, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaLib)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_static_detach_doc[] = 
"Class: oaTech, Function: detach\n"
"  Paramegers: (oaLib)\n"
"    Calls: void detach(oaLib* lib)\n"
"    Signature: detach|void-void|ptr-oaLib,\n"
"    oaTech::detach\n"
"    This function removes the technology attachment from the specified library lib .\n"
"    The oacDetachNoAttachment error is thrown if the library does not have a technology attachment to another library. The oacDMDataCannotGetWriteAccess error is thrown if the library dmData database cannot be opened for edit. Note that the library dmData database is needed because the technology attachment information is stored there.\n"
"    lib\n"
"    Pointer to the technology library to detach.\n"
"    oacDetachNoAttachment\n"
"    oacDMDataCannotGetWriteAccess\n"
;

static PyObject*
oaTech_static_detach(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaLib p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaLib_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaTech::detach(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_static_exists_doc[] = 
"Class: oaTech, Function: exists\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: oaBoolean exists(const oaScalarName& libName)\n"
"    Signature: exists|simple-oaBoolean|cref-oaScalarName,simple-oaBoolean,\n"
"    This function returns true if the tech database is open for the specified library or if a non-zero size tech database for the specified library exists on disk. It returns false otherwise.\n"
"    If the tech is not currently open and if inherited is true (default), this function uses the library's \"techLibName\" string property to resolve the target library (see the oaTech class description for further information). If inherited is false, the property is ignored and the lookup is done using the specified library only.\n"
"    An oacCannotFindInheritedTechLib exception is thrown if inherited is true and a \"techLibName\" string property in the target library resolution chain specifies the name of a non-existent library.\n"
"    libName\n"
"    The name of the library to check\n"
"    inherited\n"
"    If true, look at the library's \"techLibName\" property string value (interpreted in the oaNativeNS ) to resolve the target library.\n"
"    oacCannotFindInheritedTechLib\n"
"  Paramegers: (oaScalarName,oaBoolean)\n"
"    Calls: oaBoolean exists(const oaScalarName& libName,oaBoolean inherited)\n"
"    Signature: exists|simple-oaBoolean|cref-oaScalarName,simple-oaBoolean,\n"
"    This function returns true if the tech database is open for the specified library or if a non-zero size tech database for the specified library exists on disk. It returns false otherwise.\n"
"    If the tech is not currently open and if inherited is true (default), this function uses the library's \"techLibName\" string property to resolve the target library (see the oaTech class description for further information). If inherited is false, the property is ignored and the lookup is done using the specified library only.\n"
"    An oacCannotFindInheritedTechLib exception is thrown if inherited is true and a \"techLibName\" string property in the target library resolution chain specifies the name of a non-existent library.\n"
"    libName\n"
"    The name of the library to check\n"
"    inherited\n"
"    If true, look at the library's \"techLibName\" property string value (interpreted in the oaNativeNS ) to resolve the target library.\n"
"    oacCannotFindInheritedTechLib\n"
"  Paramegers: (oaLib)\n"
"    Calls: oaBoolean exists(oaLib* lib)\n"
"    Signature: exists|simple-oaBoolean|ptr-oaLib,simple-oaBoolean,\n"
"    This function returns true if the tech database is open for the specified library or if a non-zero size tech database for the specified library exists on disk. It returns false otherwise.\n"
"    If the tech is not currently open and if inherited is true (default), this function uses the library's \"techLibName\" string property to resolve the target library (see the oaTech class description for further information). If inherited is false, the property is ignored and the lookup is done using the specified library only.\n"
"    An oacCannotFindInheritedTechLib exception is thrown if inherited is true and a \"techLibName\" string property in the target library resolution chain specifies the name of a non-existent library.\n"
"    lib\n"
"    A pointer to the library to check\n"
"    inherited\n"
"    If true, look at the \"techLibName\" property string value (interpreted in the oaNativeNS ) to resolve the target library.\n"
"    oacCannotFindInheritedTechLib\n"
"  Paramegers: (oaLib,oaBoolean)\n"
"    Calls: oaBoolean exists(oaLib* lib,oaBoolean inherited)\n"
"    Signature: exists|simple-oaBoolean|ptr-oaLib,simple-oaBoolean,\n"
"    This function returns true if the tech database is open for the specified library or if a non-zero size tech database for the specified library exists on disk. It returns false otherwise.\n"
"    If the tech is not currently open and if inherited is true (default), this function uses the library's \"techLibName\" string property to resolve the target library (see the oaTech class description for further information). If inherited is false, the property is ignored and the lookup is done using the specified library only.\n"
"    An oacCannotFindInheritedTechLib exception is thrown if inherited is true and a \"techLibName\" string property in the target library resolution chain specifies the name of a non-existent library.\n"
"    lib\n"
"    A pointer to the library to check\n"
"    inherited\n"
"    If true, look at the \"techLibName\" property string value (interpreted in the oaNativeNS ) to resolve the target library.\n"
"    oacCannotFindInheritedTechLib\n"
;

static PyObject*
oaTech_static_exists(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            oaBoolean result= (oaTech::exists(p1.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaScalarName,oaBoolean)
    {
        PyParamoaScalarName p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaScalarName_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaBoolean result= (oaTech::exists(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaLib)
    {
        PyParamoaLib p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaLib_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBoolean result= (oaTech::exists(p1.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaLib,oaBoolean)
    {
        PyParamoaLib p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaLib_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaBoolean result= (oaTech::exists(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: exists, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaScalarName,oaBoolean)\n"
        "    (oaLib)\n"
        "    (oaLib,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_static_find_doc[] = 
"Class: oaTech, Function: find\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: oaTech* find(const oaScalarName& libName)\n"
"    Signature: find|ptr-oaTech|cref-oaScalarName,\n"
"    This function attempts to find an open tech database for the specified library name.\n"
"    If the library contains a tech database, and that database is not open, the function will return NULL.\n"
"    If there is no local tech database, if the library uses an attached tech database specified with the \"techLibName\" property, this function will recursively attempt to resolve the target library and find the open tech database for the resolved target library (see the oaTech class description for further information).\n"
"    If successful, the function returns a pointer to the tech database. Otherwise, NULL is returned.\n"
"    An oacCannotFindInheritedTechLib exception is thrown if a \"techLibName\" string property in the target library resolution chain specifies the name of a non-existent library.\n"
"    libName\n"
"    Name of the library whose tech database is to be found\n"
"    oacCannotFindInheritedTechLib\n"
"  Paramegers: (oaLib)\n"
"    Calls: oaTech* find(const oaLib* lib)\n"
"    Signature: find|ptr-oaTech|cptr-oaLib,\n"
"    This function attempts to find an open tech database for the specified library.\n"
"    If the library contains a tech database, and that database is not open, the function returns NULL.\n"
"    If there is no local tech database, and the library uses an attached tech database specified with the \"techLibName\" property instead, this function recursively attempts to resolve the target library and find the open tech database for the resolved target library. (see the oaTech class description for further information).\n"
"    If successful, the function returns a pointer to the tech database. Otherwise, NULL is returned.\n"
"    An oacCannotFindInheritedTechLib exception is thrown if a \"techLibName\" string property in the target library resolution chain specifies the name of a non-existent library.\n"
"    lib\n"
"    A pointer to the library whose tech database is to be found\n"
"    oacCannotFindInheritedTechLib\n"
;

static PyObject*
oaTech_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            oaTechp result= (oaTech::find(p1.Data()));
            return PyoaTech_FromoaTech(result);
        }
    }
    PyErr_Clear();
    // Case: (oaLib)
    {
        PyParamoaLib p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaLib_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaTechp result= (oaTech::find(p1.Data()));
            return PyoaTech_FromoaTech(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: find, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaLib)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_static_getAttachment_doc[] = 
"Class: oaTech, Function: getAttachment\n"
"  Paramegers: (oaLib,oaScalarName)\n"
"    Calls: void getAttachment(const oaLib* lib,oaScalarName& attachLibName)\n"
"    Signature: getAttachment|void-void|cptr-oaLib,ref-oaScalarName,\n"
"    This function gets the name of the library that the specified library lib has a technology attachment to and returns it in attachLibName . It is an error if lib does not have a technology attachment to another library.\n"
"    lib\n"
"    Pointer to the technology library.\n"
"    attachLibName\n"
"    Retrieved library name.\n"
"    oacGetAttachmentNoAttachment\n"
;

static PyObject*
oaTech_static_getAttachment(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaLib p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaLib_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaTech::getAttachment(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_static_getDefaultClearanceMeasure_doc[] = 
"Class: oaTech, Function: getDefaultClearanceMeasure\n"
"  Paramegers: ()\n"
"    Calls: oaClearanceMeasure getDefaultClearanceMeasure()\n"
"    Signature: getDefaultClearanceMeasure|simple-oaClearanceMeasure|\n"
"    BrowseData: 1\n"
"    This function returns the default clearance measure enum value.\n"
;

static PyObject*
oaTech_static_getDefaultClearanceMeasure(PyObject* ob, PyObject *args)
{
  try {
    if (PyArg_ParseTuple(args,"")) {
        oaClearanceMeasure* result= new oaClearanceMeasure(oaTech::getDefaultClearanceMeasure());
        return PyoaClearanceMeasure_FromoaClearanceMeasure(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_static_getDefaultDBUPerUU_doc[] = 
"Class: oaTech, Function: getDefaultDBUPerUU\n"
"  Paramegers: (oaViewType)\n"
"    Calls: oaUInt4 getDefaultDBUPerUU(const oaViewType* viewType)\n"
"    Signature: getDefaultDBUPerUU|simple-oaUInt4|cptr-oaViewType,\n"
"    This function returns the default database-units per user-unit for the specified viewType . These are the static values that will be returned by getDBUPerUU() when no call to setDBUPerUU has been made for a given viewType.\n"
"    The viewTypes allowed in this call are the subset of oaReservedViewType values that are used as viewTypes for an oaDesign . These are: oacMaskLayout , oacSchematic , oacSchematicSymbol , oacNetlist , or oacHierDesign .\n"
"    The caller can construct the viewType inline with this function call as in: tech->getDefaultDBUPerUU(oaViewType::get(oacMaskLayout))\n"
"    viewType\n"
"    A pointer to an oaViewType that corresponds to the specified type oaReservedViewType . It needs to be one of the reserved design viewTypes: maskLayout, schematic, schematicSymbol, netlist, or oaHierDesign.\n"
;

static PyObject*
oaTech_static_getDefaultDBUPerUU(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViewType p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaViewType_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (oaTech::getDefaultDBUPerUU(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_static_getDefaultDefaultManufacturingGrid_doc[] = 
"Class: oaTech, Function: getDefaultDefaultManufacturingGrid\n"
"  Paramegers: ()\n"
"    Calls: oaDist getDefaultDefaultManufacturingGrid()\n"
"    Signature: getDefaultDefaultManufacturingGrid|simple-oaDist|\n"
"    BrowseData: 1\n"
"    This function returns the default value for the default manufacturing grid.\n"
"    An oaDist, which is an oaUInt4 that represents the non-negative distance, along one axis, between two oaCoord values.\n"
;

static PyObject*
oaTech_static_getDefaultDefaultManufacturingGrid(PyObject* ob, PyObject *args)
{
  try {
    if (PyArg_ParseTuple(args,"")) {
        oaDist result= (oaTech::getDefaultDefaultManufacturingGrid());
        return PyoaDist_FromoaDist(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_static_getDefaultIsGateGrounded_doc[] = 
"Class: oaTech, Function: getDefaultIsGateGrounded\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean getDefaultIsGateGrounded()\n"
"    Signature: getDefaultIsGateGrounded|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns the default boolean value indicating whether or not the gates are considered grounded.\n"
;

static PyObject*
oaTech_static_getDefaultIsGateGrounded(PyObject* ob, PyObject *args)
{
  try {
    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (oaTech::getDefaultIsGateGrounded());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_static_getDefaultUserUnits_doc[] = 
"Class: oaTech, Function: getDefaultUserUnits\n"
"  Paramegers: (oaViewType)\n"
"    Calls: oaUserUnitsType getDefaultUserUnits(const oaViewType* viewType)\n"
"    Signature: getDefaultUserUnits|simple-oaUserUnitsType|cptr-oaViewType,\n"
"    This function returns the requested user-unit information from the tech database for the specified viewType .\n"
"    Note: Although users can construct their own oaViewTypes, valid viewTypes for this function are restricted to the set of reserved viewTypes, namely, an oaReservedViewType object constructed with one of the following reserved view type enumerated constants: oacMaskLayout , oacSchematic , oacSchematicSymbol , oacNetlist , or oacHierDesign .\n"
"    The developer can call oaViewType::get(oaReservedViewType) to construct and return a pointer to an a oaViewType object using one of the valid reserved viewType enumerated constants (for example, oaViewType::get(oacMaskLayout) or oaViewType::get (oaReservedViewType(oacMaskLayout)) .\n"
"    viewType\n"
"    A pointer to an oaViewType that corresponds to the specified type oaReservedViewType . It needs to be one of the reserved design viewTypes: maskLayout, schematic, schematicSymbol, netlist, or oaHierDesign.\n"
;

static PyObject*
oaTech_static_getDefaultUserUnits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaViewType p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaViewType_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUserUnitsType* result= new oaUserUnitsType(oaTech::getDefaultUserUnits(p1.Data()));
        return PyoaUserUnitsType_FromoaUserUnitsType(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_static_getOpenTechs_doc[] = 
"Class: oaTech, Function: getOpenTechs\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaTech_oaTech getOpenTechs()\n"
"    Signature: getOpenTechs|simple-oaCollection_oaTech_oaTech|\n"
"    BrowseData: 1\n"
"    This function returns a collection of currently open tech databases.\n"
;

static PyObject*
oaTech_static_getOpenTechs(PyObject* ob, PyObject *args)
{
  try {
    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaTech_oaTech* result= new oaCollection_oaTech_oaTech(oaTech::getOpenTechs());
        return PyoaCollection_oaTech_oaTech_FromoaCollection_oaTech_oaTech(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_static_getOpenTechsIter_doc[] = 
"Class: oaTech, Function: getOpenTechsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaTech getOpenTechsIter()\n"
"    Signature: getOpenTechsIter|simple-oaIter_oaTech|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of currently open tech databases.\n"
;

static PyObject*
oaTech_static_getOpenTechsIter(PyObject* ob, PyObject *args)
{
  try {
    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaTech* result= new oaIter_oaTech(oaTech::getOpenTechs());
        return PyoaIter_oaTech_FromoaIter_oaTech(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_static_getRevNumber_doc[] = 
"Class: oaTech, Function: getRevNumber\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getRevNumber()\n"
"    Signature: getRevNumber|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the revision number for the tech database.\n"
;

static PyObject*
oaTech_static_getRevNumber(PyObject* ob, PyObject *args)
{
  try {
    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (oaTech::getRevNumber());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_static_hasAttachment_doc[] = 
"Class: oaTech, Function: hasAttachment\n"
"  Paramegers: (oaLib)\n"
"    Calls: oaBoolean hasAttachment(const oaLib* lib)\n"
"    Signature: hasAttachment|simple-oaBoolean|cptr-oaLib,\n"
"    This function returns true if the technology library lib has a technology attachment to another library.\n"
"    lib\n"
"    Pointer to the technology library.\n"
;

static PyObject*
oaTech_static_hasAttachment(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaLib p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaLib_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (oaTech::hasAttachment(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTech_static_open_doc[] = 
"Class: oaTech, Function: open\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: oaTech* open(const oaScalarName& libName)\n"
"    Signature: open|ptr-oaTech|cref-oaScalarName,simple-oaChar,\n"
"    This function opens the tech database for the specified library with the specified access mode. Note that the open functions do not create tech databases, they simply open them.\n"
"    The tech to be opened might reference other techs in a graph. If so, OpenAccess attempts to open the referenced techs as well. Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information.\n"
"    If one of the referenced techs was edited out of context, conflicting technology objects might be encountered when opening the tech. It is an error if opening a tech:\n"
"    Introduces a technology object with the same name as another technology object in the graph.\n"
"    Introduces a technology attribute with the same name as another technology attribute in the graph that has a different value for the attribute.\n"
"    Introduces a constraint group with the same name as another constraint group in the graph.\n"
"    OpenAccess issues observer notifications and exceptions for the above errors. Refer to Working with Technology Objects, Technology Attributes, and Constraints in the Using Technology Databases section of the Programmers Guide for more information.\n"
"    libName\n"
"    The name of the library whose tech database is to be opened\n"
"    mode\n"
"    The mode in which to open the design\n"
"    'r' for read\n"
"    'w' for write (truncate by deleting existing data)\n"
"    'a' for append\n"
"    'A' for append in override mode, which is not typically used. Refer to Compatibility for OpenAccess Applications and Data in the Programmers Guide for more information.\n"
"    If there is no local tech database in the library, and the library uses an attached tech database specified with the \"techLibName\" property (as explained in the oaTech class description), this function will recursively attempt to resolve the target library and open the tech database for the resolved target library. An oacCannotFindInheritedTechLib exception is thrown if a \"techLibName\" string property in the target library resolution chain specifies the name of a non-existent library.\n"
"    A pointer to the opened tech database\n"
"    oacTechLibNotFound\n"
"    oacOpenOnTechBeingPurged\n"
"    oacCannotFindLibraryTech\n"
"    oacTechFileDoesNotExist\n"
"    oacCannotFindInheritedTechLib\n"
"    oacDataNotCompatibleOnOpen\n"
"    The design contains new features that are not understood by this version of OpenAccess and cannot be opened\n"
"    oacDataNotCompatibleOnOpenInAppendMode\n"
"    The design contains new features that are not understood by this version of OpenAccess and cannot be opened in append mode\n"
"    oacCannotRepairCorruptedAppData\n"
"  Paramegers: (oaScalarName,oaChar)\n"
"    Calls: oaTech* open(const oaScalarName& libName,oaChar mode)\n"
"    Signature: open|ptr-oaTech|cref-oaScalarName,simple-oaChar,\n"
"    This function opens the tech database for the specified library with the specified access mode. Note that the open functions do not create tech databases, they simply open them.\n"
"    The tech to be opened might reference other techs in a graph. If so, OpenAccess attempts to open the referenced techs as well. Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information.\n"
"    If one of the referenced techs was edited out of context, conflicting technology objects might be encountered when opening the tech. It is an error if opening a tech:\n"
"    Introduces a technology object with the same name as another technology object in the graph.\n"
"    Introduces a technology attribute with the same name as another technology attribute in the graph that has a different value for the attribute.\n"
"    Introduces a constraint group with the same name as another constraint group in the graph.\n"
"    OpenAccess issues observer notifications and exceptions for the above errors. Refer to Working with Technology Objects, Technology Attributes, and Constraints in the Using Technology Databases section of the Programmers Guide for more information.\n"
"    libName\n"
"    The name of the library whose tech database is to be opened\n"
"    mode\n"
"    The mode in which to open the design\n"
"    'r' for read\n"
"    'w' for write (truncate by deleting existing data)\n"
"    'a' for append\n"
"    'A' for append in override mode, which is not typically used. Refer to Compatibility for OpenAccess Applications and Data in the Programmers Guide for more information.\n"
"    If there is no local tech database in the library, and the library uses an attached tech database specified with the \"techLibName\" property (as explained in the oaTech class description), this function will recursively attempt to resolve the target library and open the tech database for the resolved target library. An oacCannotFindInheritedTechLib exception is thrown if a \"techLibName\" string property in the target library resolution chain specifies the name of a non-existent library.\n"
"    A pointer to the opened tech database\n"
"    oacTechLibNotFound\n"
"    oacOpenOnTechBeingPurged\n"
"    oacCannotFindLibraryTech\n"
"    oacTechFileDoesNotExist\n"
"    oacCannotFindInheritedTechLib\n"
"    oacDataNotCompatibleOnOpen\n"
"    The design contains new features that are not understood by this version of OpenAccess and cannot be opened\n"
"    oacDataNotCompatibleOnOpenInAppendMode\n"
"    The design contains new features that are not understood by this version of OpenAccess and cannot be opened in append mode\n"
"    oacCannotRepairCorruptedAppData\n"
"  Paramegers: (oaLib)\n"
"    Calls: oaTech* open(oaLib* lib)\n"
"    Signature: open|ptr-oaTech|ptr-oaLib,simple-oaChar,\n"
"    This function opens the tech database for the specified library with the specified access mode. Note that the open functions do not create tech databases, they simply open them.\n"
"    The tech to be opened might reference other techs in a graph. If so, OpenAccess attempts to open the referenced techs as well. If one of the referenced techs was edited out of context, conflicting technology objects might be encountered. It is an error if opening a tech:\n"
"    Introduces a technology object with the same name as another technology object in the graph.\n"
"    Introduces a technology attribute with the same name as another technology attribute in the graph that has a different value for the attribute.\n"
"    Introduces a constraint group with the same name as another constraint group in the graph.\n"
"    OpenAccess issues onConflict observer notifications and issues exceptions for the above errors.\n"
"    For more information about referenced tech databases, refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide.\n"
"    lib\n"
"    A pointer to the library whose tech database is to be opened\n"
"    mode\n"
"    The mode in which to open the database\n"
"    'r' for read\n"
"    'w' for write (truncate by deleting existing data)\n"
"    'a' for append\n"
"    'A' for append in override mode, which is not typically used. Refer to Compatibility for OpenAccess Applications and Data in the Programmers Guide for more information.\n"
"    If there is no local tech database in the library, and the library uses an attached tech database specified with the \"techLibName\" property (as explained in the class description), this function will recursively attempt to resolve the target library and open the tech database for the resolved target library. An oacCannotFindInheritedTechLib exception is thrown if a \"techLibName\" string property in the target library resolution chain specifies the name of a non-existent library.\n"
"    A pointer to the opened tech database\n"
"    oacOpenOnTechBeingPurged\n"
"    Attempt to open a technology database that is being purged\n"
"    oacCannotFindLibraryTech\n"
"    Tech database for the specified library is not found\n"
"    oacTechFileDoesNotExist\n"
"    oacCannotFindInheritedTechLib\n"
"    oacDataNotCompatibleOnOpen\n"
"    The design contains new features that are not understood by this version of OpenAccess and cannot be opened\n"
"    oacDataNotCompatibleOnOpenInAppendMode\n"
"    The design contains new features that are not understood by this version of OpenAccess and cannot be opened in append mode\n"
"    oacCannotRepairCorruptedAppData\n"
"  Paramegers: (oaLib,oaChar)\n"
"    Calls: oaTech* open(oaLib* lib,oaChar mode)\n"
"    Signature: open|ptr-oaTech|ptr-oaLib,simple-oaChar,\n"
"    This function opens the tech database for the specified library with the specified access mode. Note that the open functions do not create tech databases, they simply open them.\n"
"    The tech to be opened might reference other techs in a graph. If so, OpenAccess attempts to open the referenced techs as well. If one of the referenced techs was edited out of context, conflicting technology objects might be encountered. It is an error if opening a tech:\n"
"    Introduces a technology object with the same name as another technology object in the graph.\n"
"    Introduces a technology attribute with the same name as another technology attribute in the graph that has a different value for the attribute.\n"
"    Introduces a constraint group with the same name as another constraint group in the graph.\n"
"    OpenAccess issues onConflict observer notifications and issues exceptions for the above errors.\n"
"    For more information about referenced tech databases, refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide.\n"
"    lib\n"
"    A pointer to the library whose tech database is to be opened\n"
"    mode\n"
"    The mode in which to open the database\n"
"    'r' for read\n"
"    'w' for write (truncate by deleting existing data)\n"
"    'a' for append\n"
"    'A' for append in override mode, which is not typically used. Refer to Compatibility for OpenAccess Applications and Data in the Programmers Guide for more information.\n"
"    If there is no local tech database in the library, and the library uses an attached tech database specified with the \"techLibName\" property (as explained in the class description), this function will recursively attempt to resolve the target library and open the tech database for the resolved target library. An oacCannotFindInheritedTechLib exception is thrown if a \"techLibName\" string property in the target library resolution chain specifies the name of a non-existent library.\n"
"    A pointer to the opened tech database\n"
"    oacOpenOnTechBeingPurged\n"
"    Attempt to open a technology database that is being purged\n"
"    oacCannotFindLibraryTech\n"
"    Tech database for the specified library is not found\n"
"    oacTechFileDoesNotExist\n"
"    oacCannotFindInheritedTechLib\n"
"    oacDataNotCompatibleOnOpen\n"
"    The design contains new features that are not understood by this version of OpenAccess and cannot be opened\n"
"    oacDataNotCompatibleOnOpenInAppendMode\n"
"    The design contains new features that are not understood by this version of OpenAccess and cannot be opened in append mode\n"
"    oacCannotRepairCorruptedAppData\n"
;

static PyObject*
oaTech_static_open(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            oaTechp result= (oaTech::open(p1.Data()));
            return PyoaTech_FromoaTech(result);
        }
    }
    PyErr_Clear();
    // Case: (oaScalarName,oaChar)
    {
        PyParamoaScalarName p1;
        PyParamoaChar p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaScalarName_Convert,&p1,
              &PyoaChar_Convert,&p2)) {
            oaTechp result= (oaTech::open(p1.Data(),p2.Data()));
            return PyoaTech_FromoaTech(result);
        }
    }
    PyErr_Clear();
    // Case: (oaLib)
    {
        PyParamoaLib p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaLib_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaTechp result= (oaTech::open(p1.Data()));
            return PyoaTech_FromoaTech(result);
        }
    }
    PyErr_Clear();
    // Case: (oaLib,oaChar)
    {
        PyParamoaLib p1;
        PyParamoaChar p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaLib_Convert,&p1,
              &PyoaChar_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaTechp result= (oaTech::open(p1.Data(),p2.Data()));
            return PyoaTech_FromoaTech(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTech, function: open, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaScalarName,oaChar)\n"
        "    (oaLib)\n"
        "    (oaLib,oaChar)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaTech_staticmethodlist[] = {
    {"static_attach",(PyCFunction)oaTech_static_attach,METH_VARARGS,oaTech_static_attach_doc},
    {"static_create",(PyCFunction)oaTech_static_create,METH_VARARGS,oaTech_static_create_doc},
    {"static_destroy",(PyCFunction)oaTech_static_destroy,METH_VARARGS,oaTech_static_destroy_doc},
    {"static_detach",(PyCFunction)oaTech_static_detach,METH_VARARGS,oaTech_static_detach_doc},
    {"static_exists",(PyCFunction)oaTech_static_exists,METH_VARARGS,oaTech_static_exists_doc},
    {"static_find",(PyCFunction)oaTech_static_find,METH_VARARGS,oaTech_static_find_doc},
    {"static_getAttachment",(PyCFunction)oaTech_static_getAttachment,METH_VARARGS,oaTech_static_getAttachment_doc},
    {"static_getDefaultClearanceMeasure",(PyCFunction)oaTech_static_getDefaultClearanceMeasure,METH_VARARGS,oaTech_static_getDefaultClearanceMeasure_doc},
    {"static_getDefaultDBUPerUU",(PyCFunction)oaTech_static_getDefaultDBUPerUU,METH_VARARGS,oaTech_static_getDefaultDBUPerUU_doc},
    {"static_getDefaultDefaultManufacturingGrid",(PyCFunction)oaTech_static_getDefaultDefaultManufacturingGrid,METH_VARARGS,oaTech_static_getDefaultDefaultManufacturingGrid_doc},
    {"static_getDefaultIsGateGrounded",(PyCFunction)oaTech_static_getDefaultIsGateGrounded,METH_VARARGS,oaTech_static_getDefaultIsGateGrounded_doc},
    {"static_getDefaultUserUnits",(PyCFunction)oaTech_static_getDefaultUserUnits,METH_VARARGS,oaTech_static_getDefaultUserUnits_doc},
    {"static_getOpenTechs",(PyCFunction)oaTech_static_getOpenTechs,METH_VARARGS,oaTech_static_getOpenTechs_doc},
    {"static_getOpenTechsIter",(PyCFunction)oaTech_static_getOpenTechsIter,METH_VARARGS,oaTech_static_getOpenTechsIter_doc},
    {"static_getRevNumber",(PyCFunction)oaTech_static_getRevNumber,METH_VARARGS,oaTech_static_getRevNumber_doc},
    {"static_hasAttachment",(PyCFunction)oaTech_static_hasAttachment,METH_VARARGS,oaTech_static_hasAttachment_doc},
    {"static_open",(PyCFunction)oaTech_static_open,METH_VARARGS,oaTech_static_open_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaTech_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaTech_Type)<0) {
      printf("** PyType_Ready failed for: oaTech\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaTech",
           (PyObject*)(&PyoaTech_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaTech\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaTech_Type.tp_dict;
    for(method=oaTech_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


// ==================================================================
// Array for class: oaTech
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaTech_Array_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaTech_Array_Type);
    PyObject* gself = type->tp_alloc(type,0);
    if (gself == NULL) return gself;
    PyoaTech_ArrayObject* self = (PyoaTech_ArrayObject*)gself;
    self->borrow = 0;
    self->locks=NULL;
    static char *kwlist [] = { NULL } ;
    /* Case: () */ 
    {
        if (PyArg_ParseTuple(args,"")) {
            return gself;
        }
    }
    PyErr_Clear();
    /* Case: (int) */
    {
        int p1;
        if (PyArg_ParseTuple(args,(char*)"i",&p1)) {
            self->data.SetLen(p1);
            return gself;
        }
    }
    PyErr_Clear();
    /* Case: (oaTech_Array) */
    {
        PyParamoaTech_Array p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaTech_Array_Convert,&p1)) {
            self->data.TakeAway(p1);
            return gself;
        }
    }
    /* Error */
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaTech_Array, Choices are:\n"
        "    ()\n"
        "    (int)\n"
        "    (oaTech_Array)\n"
    );
    Py_DECREF(gself);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaTech_Array_dealloc(PyObject* gself)
{
    PyoaTech_ArrayObject* self = (PyoaTech_ArrayObject*)gself;
    Py_XDECREF(self->locks);
    self->ob_type->tp_free(gself);
}

// ------------------------------------------------------------------
static PyObject*
oaTech_Array_str(PyObject *ob)
{
    PyParamoaTech_Array value;
    int convert_status=PyoaTech_Array_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* lst=PyoaTech_Array_CreateList(value);
    PyObject* result=PyObject_Str(lst);
    Py_DECREF(lst);
    return result;
}

// ------------------------------------------------------------------
static PyObject*
oaTech_Array_repr(PyObject *ob)
{
    PyParamoaTech_Array value;
    int convert_status=PyoaTech_Array_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* lst=PyoaTech_Array_CreateList(value);
    PyObject* result=PyObject_Repr(lst);
    Py_DECREF(lst);
    return result;
}

// ------------------------------------------------------------------
static int
oaTech_Array_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaTech_Array p1;
    PyParamoaTech_Array p2;
    int s1=PyoaTech_Array_Convert(ob1,&p1);
    int s2=PyoaTech_Array_Convert(ob2,&p2);
    assert(s1!=0);
    assert(s2!=0);
    PyObject* l1=PyoaTech_Array_CreateList(p1);
    PyObject* l2=PyoaTech_Array_CreateList(p2);
    int result=PyObject_Compare(l1,l2);
    Py_DECREF(l1);
    Py_DECREF(l2);
    return result;
}

// ------------------------------------------------------------------
int
PyoaTech_Array_Convert(PyObject* ob,PyParamoaTech_Array* result)
{
  Pyoa_ssize_t len,i;
  if (PyoaTech_Array_Check(ob)) {
    PyoaTech_ArrayObject* self = (PyoaTech_ArrayObject*)ob;
    result->Borrow(self->data);
  }
  else if (PyList_Check(ob)) {
    len=PyList_Size(ob);
    result->SetLen(len);
    PyParamoaTech data;
    for(i=0;i<len;i++) {
      PyObject* a=PyList_GetItem(ob,i);
      if (!PyoaTech_Convert(a,&data)) return 0;
      result->SetItem(i,data.Data());
    }
  }
  else if (PyTuple_Check(ob)) {
    len=PyTuple_Size(ob);
    result->SetLen(len);
    PyParamoaTech data;
    for(i=0;i<len;i++) {
      PyObject* a=PyTuple_GetItem(ob,i);
      if (!PyoaTech_Convert(a,&data)) return 0;
      result->SetItem(i,data.Data());
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError,
      "Convertion of parameter to class: oaTech_Array Failed");
    return 0;
  }
  return 1;
}

// ------------------------------------------------------------------
PyObject* PyoaTech_Array_FromoaTech_Array(const oaTech_Array& value)
{
  PyObject* gself = PyoaTech_Array_Type.tp_alloc(&PyoaTech_Array_Type,0);
  if (gself == NULL) return gself;
  PyoaTech_ArrayObject* self = (PyoaTech_ArrayObject*)gself;
  self->data = value;
  self->borrow = 0;
  self->locks=NULL;
  return gself;
}

// ------------------------------------------------------------------
PyObject* PyoaTech_Array_FromoaTech_Array(PyTypeoaTech* data,Pyoa_ssize_t len,PyObject* lock)
{
  PyObject* gself = PyoaTech_Array_Type.tp_alloc(&PyoaTech_Array_Type,0);
  if (gself == NULL) return gself;
  PyoaTech_ArrayObject* self = (PyoaTech_ArrayObject*)gself;
  self->data.Borrow(data,len);
  self->borrow = 1;
  self->locks=NULL;
  if (lock) PyoaLockObject(self->locks,lock);
  return gself;
}

// ------------------------------------------------------------------
PyObject* PyoaTech_Array_CreateList(PyParamoaTech_Array& value)
{
  Pyoa_ssize_t i;
  PyObject* lst=PyList_New(value.Len());
  for(i=0;i<value.Len();i++) {
    PyObject* ob=PyoaTech_FromoaTech(value.Data()[i]);
    PyList_SetItem(lst,i,ob);
  }
  return lst;
}

// ------------------------------------------------------------------
// Methods
// ------------------------------------------------------------------
static char oaTech_Array_assign_doc[] = 
"Class: oaTech_Array, Function: assign\n"
"  Paramegers: (oaTech_Array)\n"
"    This function assigns the current value.\n"
;

static PyObject*
oaTech_Array_assign(PyObject* ob, PyObject *args)
{
  PyoaTech_ArrayObject* self=(PyoaTech_ArrayObject*)ob;
  try {
    PyParamoaTech_Array p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaTech_Array_Convert,&p1)) {
        self->data=p1;
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}
// ------------------------------------------------------------------
static char oaTech_Array_list_doc[] = 
"Class: oaTech_Array, Function: list\n"
"  Paramegers: ()\n"
"    This function returns the current value as a list.\n"
;

static PyObject*
oaTech_Array_list(PyObject* ob, PyObject *args)
{
  PyoaTech_ArrayObject* self=(PyoaTech_ArrayObject*)ob;
  try {
    if (PyArg_ParseTuple(args,(char*)"")) {
      return PyoaTech_Array_CreateList(self->data);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}
// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------
static PyMethodDef oaTech_Array_methodlist[] = {
    {"assign",(PyCFunction)oaTech_Array_assign,METH_VARARGS,oaTech_Array_assign_doc},
    {"list",(PyCFunction)oaTech_Array_list,METH_VARARGS,oaTech_Array_list_doc},
   {NULL,NULL,0,NULL}
};

// ------------------------------------------------------------------
static PyObject*
oaTech_Array_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaTech_ArrayObject* self=(PyoaTech_ArrayObject*)ob;
  try {
    PyParamoaTech_Array data;
    int convert_status=PyoaTech_Array_Convert(ob,&data);
    assert(convert_status!=0);
    if (index<0 || index>=data.Len()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    return PyoaTech_FromoaTech(data.GetItemPtr(index),1,self->locks);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static Pyoa_ssize_t
oaTech_Array_index_get_length(PyObject* ob)
{
    PyParamoaTech_Array data;
    int convert_status=PyoaTech_Array_Convert(ob,&data);
    assert(convert_status!=0);
    return data.Len();
}

// ------------------------------------------------------------------
static int
oaTech_Array_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaTech_Array data;
    PyParamoaTech dataitem;
    int convert_status=PyoaTech_Array_Convert(ob,&data);
    assert(convert_status!=0);
    if (index<0 || index>=data.Len()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    if (PyoaTech_Convert(value,&dataitem)==0) return -1;
    data.SetItem(index,dataitem.Data());
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return 0;
  }
}

// ------------------------------------------------------------------
static char oaTech_Array_doc[] =
"Class: oaTech_Array\n"
"  The oaTech_Array utility class provides an array of oaTech.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaTech_Array()\n"
"    Signature: oaTech_Array||\n"
"    This is the default constructor for the oaTech_Array class. This constructor creates an empty oaTech_Array.\n"
"  Paramegers: (oaTech_Array)\n"
"    Calls: (const oaTech_Array&)\n"
"    Signature: oaTech_Array||cref-oaTech_Array,\n"
;

// ------------------------------------------------------------------
static PySequenceMethods oaTech_Array_as_sequence = {
    (Pyoa_inquiry)oaTech_Array_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,              /* sq_concat */
    (Pyoa_intargfunc)0,              /* sq_repeat */
    (Pyoa_intargfunc)oaTech_Array_index_get, /* sq_item */
    (Pyoa_intintargfunc)0,           /* sq_slice */
    (Pyoa_intobjargproc)oaTech_Array_index_set,      /* sq_ass_item */
};

// ------------------------------------------------------------------
PyTypeObject PyoaTech_Array_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaTech_Array",
    sizeof(PyoaTech_ArrayObject),
    0,
    oaTech_Array_dealloc, /* tp_dealloc */
    0,  /* tp_print */
    0,                                  /* tp_getattr */
    0,                                  /* tp_setattr */
    oaTech_Array_compare,    /* tp_compare */
    oaTech_Array_repr,      /* tp_repr */
    0,                                  /* tp_as_number */
    &oaTech_Array_as_sequence,  /* tp_as_sequence */
    0,                                  /* tp_as_mapping */
    0,                                  /* tp_as_hash */
    0,                                  /* tp_as_call */
    oaTech_Array_str,               /* tp_str */
    0,                                  /* tp_getattro */
    0,                                  /* tp_setattro */
    0,                                  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaTech_Array_doc, /* tp_doc */
    0,                                  /* tp_traverse */
    0,                                  /* tp_clear */
    0,                                  /* tp_richcompre */
    0,                                  /* tp_weaklistoffset */
    0,                                  /* tp_iter */
    0,                                  /* tp_iternext */
    oaTech_Array_methodlist, /* tp_methods */
    0,                                  /* tp_members */
    0,                                  /* tp_getset */
    0,                                  /* tp_base */
    0,                                  /* tp_dict */
    0,                                  /* tp_descr_get */
    0,                                  /* tp_descr_set */
    0,                                  /* tp_dictoffset */
    0,                                  /* tp_init */
    PyType_GenericAlloc,        /* tp_alloc */
    oaTech_Array_new, /* tp_new */
    _PyObject_Del,      /* tp_free */
};


// ------------------------------------------------------------------
int
PyoaTech_Array_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaTech_Array_Type)<0) {
      printf("** PyType_Ready failed for: oaTech_Array\n");
      return -1;
    }
    if (PyDict_SetItemString(mod_dict,"oaTech_Array",
           (PyObject*)(&PyoaTech_Array_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaTech_Array\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaTechArray
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaTechArray_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaTechArray_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaTechArrayObject* self = (PyoaTechArrayObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaArrayBase_oaTech*)  new oaTechArray();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value = (oaArrayBase_oaTech*)  new oaTechArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaTechArray)
    {
        PyParamoaTechArray p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaTechArray_Convert,&p1)) {
            self->value=(oaArrayBase_oaTech*)  new oaTechArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaTechArray, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaTechArray)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaTechArray_tp_dealloc(PyoaTechArrayObject* self)
{
    if (!self->borrow) {
        delete (oaTechArray*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaTechArray_tp_repr(PyObject *ob)
{
    PyParamoaTechArray value;
    int convert_status=PyoaTechArray_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[33];
    sprintf(buffer,"<oaTechArray::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaTechArray_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaTechArray v1;
    PyParamoaTechArray v2;
    int convert_status1=PyoaTechArray_Convert(ob1,&v1);
    int convert_status2=PyoaTechArray_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaTechArray_Convert(PyObject* ob,PyParamoaTechArray* result)
{
    if (ob == NULL) return 1;
    if (PyoaTechArray_Check(ob)) {
        result->SetData( (oaTechArray*) ((PyoaTechArrayObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaTechArray Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaTechArray_FromoaTechArray(oaTechArray* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaTechArray_Type.tp_alloc(&PyoaTechArray_Type,0);
        if (bself == NULL) return bself;
        PyoaTechArrayObject* self = (PyoaTechArrayObject*)bself;
        self->value = (oaArrayBase_oaTech*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaTechArray_doc[] = 
"Class: oaTechArray\n"
"  The oaTechArray class implements an array of tech pointers used in establishing incremental technology databases. An oaTechArray is passed to the oaTech::setRefs function to create references from the specified tech database to other techs.\n"
"  For more information, refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaTechArray()\n"
"    Signature: oaTechArray||simple-oaUInt4,\n"
"    This is the constructor for the oaTechArray class. It constructs an array of tech pointers of the specified size.\n"
"    sizeIn\n"
"    The initial size of the array\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaTechArray(oaUInt4 sizeIn)\n"
"    Signature: oaTechArray||simple-oaUInt4,\n"
"    This is the constructor for the oaTechArray class. It constructs an array of tech pointers of the specified size.\n"
"    sizeIn\n"
"    The initial size of the array\n"
"  Paramegers: (oaTechArray)\n"
"    Calls: (const oaTechArray&)\n"
"    Signature: oaTechArray||cref-oaTechArray,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaTechArray_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaTechArray",
    sizeof(PyoaTechArrayObject),
    0,
    (destructor)oaTechArray_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaTechArray_tp_compare,	/* tp_compare */
    (reprfunc)oaTechArray_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaTechArray_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaArray_oaTech_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaTechArray_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaTechArray_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaTechArray_Type)<0) {
      printf("** PyType_Ready failed for: oaTechArray\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaTechArray",
           (PyObject*)(&PyoaTechArray_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaTechArray\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaTechConflictTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaTechConflictTypeEnum_Convert(PyObject* ob,PyParamoaTechConflictTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacLayerNameTechConflictType")==0) { result->SetData(oacLayerNameTechConflictType); return 1;}
        if (strcasecmp(str,"oacLayerNumTechConflictType")==0) { result->SetData(oacLayerNumTechConflictType); return 1;}
        if (strcasecmp(str,"oacDerivedLayerTechConflictType")==0) { result->SetData(oacDerivedLayerTechConflictType); return 1;}
        if (strcasecmp(str,"oacPurposeNameTechConflictType")==0) { result->SetData(oacPurposeNameTechConflictType); return 1;}
        if (strcasecmp(str,"oacPurposeNumTechConflictType")==0) { result->SetData(oacPurposeNumTechConflictType); return 1;}
        if (strcasecmp(str,"oacSiteDefNameTechConflictType")==0) { result->SetData(oacSiteDefNameTechConflictType); return 1;}
        if (strcasecmp(str,"oacViaDefNameTechConflictType")==0) { result->SetData(oacViaDefNameTechConflictType); return 1;}
        if (strcasecmp(str,"oacViaSpecTechConflictType")==0) { result->SetData(oacViaSpecTechConflictType); return 1;}
        if (strcasecmp(str,"oacAnalysisLibNameTechConflictType")==0) { result->SetData(oacAnalysisLibNameTechConflictType); return 1;}
        if (strcasecmp(str,"oacConstraintNameTechConflictType")==0) { result->SetData(oacConstraintNameTechConflictType); return 1;}
        if (strcasecmp(str,"oacConstraintGroupNameTechConflictType")==0) { result->SetData(oacConstraintGroupNameTechConflictType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaTechConflictTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaTechConflictTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaTechConflictTypeEnum_FromoaTechConflictTypeEnum(oaTechConflictTypeEnum ob)
{
    if (ob==oacLayerNameTechConflictType) return PyString_FromString("oacLayerNameTechConflictType");
    if (ob==oacLayerNumTechConflictType) return PyString_FromString("oacLayerNumTechConflictType");
    if (ob==oacDerivedLayerTechConflictType) return PyString_FromString("oacDerivedLayerTechConflictType");
    if (ob==oacPurposeNameTechConflictType) return PyString_FromString("oacPurposeNameTechConflictType");
    if (ob==oacPurposeNumTechConflictType) return PyString_FromString("oacPurposeNumTechConflictType");
    if (ob==oacSiteDefNameTechConflictType) return PyString_FromString("oacSiteDefNameTechConflictType");
    if (ob==oacViaDefNameTechConflictType) return PyString_FromString("oacViaDefNameTechConflictType");
    if (ob==oacViaSpecTechConflictType) return PyString_FromString("oacViaSpecTechConflictType");
    if (ob==oacAnalysisLibNameTechConflictType) return PyString_FromString("oacAnalysisLibNameTechConflictType");
    if (ob==oacConstraintNameTechConflictType) return PyString_FromString("oacConstraintNameTechConflictType");
    if (ob==oacConstraintGroupNameTechConflictType) return PyString_FromString("oacConstraintGroupNameTechConflictType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaTechConflictTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaTechConflictTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaTechConflictTypeEnum_FromoaTechConflictTypeEnum(oaTechConflictTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaTechConflictTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaTechConflictTypeEnum_doc[] =
"Type convert function for enum: oaTechConflictTypeEnum";
                               
static PyMethodDef PyoaTechConflictTypeEnum_method =
  {"oaTechConflictTypeEnum",(PyCFunction)PyoaTechConflictTypeEnum_TypeFunction,METH_VARARGS,oaTechConflictTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaTechConflictTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacLayerNameTechConflictType");
    PyDict_SetItemString(mod_dict,"oacLayerNameTechConflictType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLayerNumTechConflictType");
    PyDict_SetItemString(mod_dict,"oacLayerNumTechConflictType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDerivedLayerTechConflictType");
    PyDict_SetItemString(mod_dict,"oacDerivedLayerTechConflictType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPurposeNameTechConflictType");
    PyDict_SetItemString(mod_dict,"oacPurposeNameTechConflictType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPurposeNumTechConflictType");
    PyDict_SetItemString(mod_dict,"oacPurposeNumTechConflictType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSiteDefNameTechConflictType");
    PyDict_SetItemString(mod_dict,"oacSiteDefNameTechConflictType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacViaDefNameTechConflictType");
    PyDict_SetItemString(mod_dict,"oacViaDefNameTechConflictType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacViaSpecTechConflictType");
    PyDict_SetItemString(mod_dict,"oacViaSpecTechConflictType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAnalysisLibNameTechConflictType");
    PyDict_SetItemString(mod_dict,"oacAnalysisLibNameTechConflictType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConstraintNameTechConflictType");
    PyDict_SetItemString(mod_dict,"oacConstraintNameTechConflictType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConstraintGroupNameTechConflictType");
    PyDict_SetItemString(mod_dict,"oacConstraintGroupNameTechConflictType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaTechConflictTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaTechConflictTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaTechConflictTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaTechDataType
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaTechDataType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaTechDataType_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaTechDataTypeObject* self = (PyoaTechDataTypeObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaTechDataTypeEnum)
    {
        PyParamoaTechDataTypeEnum p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaTechDataTypeEnum_Convert,&p1)) {
            self->value =  new oaTechDataType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            self->value =  new oaTechDataType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaTechDataType)
    {
        PyParamoaTechDataType p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaTechDataType_Convert,&p1)) {
            self->value= new oaTechDataType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaTechDataType, Choices are:\n"
        "    (oaTechDataTypeEnum)\n"
        "    (oaString)\n"
        "    (oaTechDataType)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaTechDataType_tp_dealloc(PyoaTechDataTypeObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaTechDataType_tp_repr(PyObject *ob)
{
    PyParamoaTechDataType value;
    int convert_status=PyoaTechDataType_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    oaString sresult(value.DataCall()->getName());

    char addr[36];
    sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
    oaString buffer;
    buffer+=oaString("<oaTechDataType::");
    buffer+=oaString(addr);
    buffer+=oaString("::");
    buffer+=oaString(sresult);
    buffer+=oaString(">");
    result=PyString_FromString((char*)(const char*)buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaTechDataType_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaTechDataType v1;
    PyParamoaTechDataType v2;
    int convert_status1=PyoaTechDataType_Convert(ob1,&v1);
    int convert_status2=PyoaTechDataType_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaTechDataType_Convert(PyObject* ob,PyParamoaTechDataType* result)
{
    if (ob == NULL) return 1;
    if (PyoaTechDataType_Check(ob)) {
        result->SetData(  ((PyoaTechDataTypeObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaTechDataType Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaTechDataType_FromoaTechDataType(oaTechDataType* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaTechDataType_Type.tp_alloc(&PyoaTechDataType_Type,0);
        if (bself == NULL) return bself;
        PyoaTechDataTypeObject* self = (PyoaTechDataTypeObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaTechDataType_getName_doc[] = 
"Class: oaTechDataType, Function: getName\n"
"  Paramegers: ()\n"
"    Calls: const oaString& getName() const\n"
"    Signature: getName|cref-oaString|\n"
"    BrowseData: 1\n"
"    This function returns the name string associated with the encapsulated #oaTechDataTypeEnum object.\n"
;

static PyObject*
oaTechDataType_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTechDataType data;
    int convert_status=PyoaTechDataType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechDataTypeObject* self=(PyoaTechDataTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaString result= (data.DataCall()->getName());
        return PyoaString_FromoaString(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTechDataType_oaTechDataTypeEnum_doc[] = 
"Class: oaTechDataType, Function: oaTechDataTypeEnum\n"
"  Paramegers: ()\n"
"    Calls: oaTechDataTypeEnum oaTechDataTypeEnum() const\n"
"    Signature: operator oaTechDataTypeEnum|simple-oaTechDataTypeEnum|\n"
"    BrowseData: 1\n"
"    This operator casts this oaTechDataType object into the corresponding #oaTechDataTypeEnum value.\n"
;

static PyObject*
oaTechDataType_oaTechDataTypeEnum(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTechDataType data;
    int convert_status=PyoaTechDataType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechDataTypeObject* self=(PyoaTechDataTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaTechDataTypeEnum result= (data.DataCall()->operator oaTechDataTypeEnum());
        return PyoaTechDataTypeEnum_FromoaTechDataTypeEnum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaTechDataType_assign_doc[] = 
"Class: oaTechDataType, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaTechDataType_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaTechDataType data;
  int convert_status=PyoaTechDataType_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaTechDataType p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaTechDataType_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaTechDataType_methodlist[] = {
    {"getName",(PyCFunction)oaTechDataType_getName,METH_VARARGS,oaTechDataType_getName_doc},
    {"oaTechDataTypeEnum",(PyCFunction)oaTechDataType_oaTechDataTypeEnum,METH_VARARGS,oaTechDataType_oaTechDataTypeEnum_doc},
    {"assign",(PyCFunction)oaTechDataType_tp_assign,METH_VARARGS,oaTechDataType_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaTechDataType_doc[] = 
"Class: oaTechDataType\n"
"  The oaTechDataType class encapsulates the enumerated values that describe the different uses of a technology database object.\n"
"  oaTechDataTypeEnum\n"
"Constructors:\n"
"  Paramegers: (oaTechDataTypeEnum)\n"
"    Calls: oaTechDataType(oaTechDataTypeEnum valueIn)\n"
"    Signature: oaTechDataType||simple-oaTechDataTypeEnum,\n"
"    This function constructs an instance of an oaTechDataType class using the specified #oaTechDataTypeEnum value.\n"
"  Paramegers: (oaString)\n"
"    Calls: oaTechDataType(const oaString& name)\n"
"    Signature: oaTechDataType||cref-oaString,\n"
"    This function constructs an instance of an oaTechDataType class using the #oaTechDataTypeEnum associated with the specified string name . This name must be defined in the legal set of names associated with #oaTechDataTypeEnum.\n"
"    oacInvalidTechDataTypeName\n"
"  Paramegers: (oaTechDataType)\n"
"    Calls: (const oaTechDataType&)\n"
"    Signature: oaTechDataType||cref-oaTechDataType,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaTechDataType_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaTechDataType",
    sizeof(PyoaTechDataTypeObject),
    0,
    (destructor)oaTechDataType_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaTechDataType_tp_compare,	/* tp_compare */
    (reprfunc)oaTechDataType_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaTechDataType_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaTechDataType_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaTechDataType_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaTechDataType_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaTechDataType_Type)<0) {
      printf("** PyType_Ready failed for: oaTechDataType\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaTechDataType",
           (PyObject*)(&PyoaTechDataType_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaTechDataType\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaTechDataTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaTechDataTypeEnum_Convert(PyObject* ob,PyParamoaTechDataTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacTechDataType")==0) { result->SetData(oacTechDataType); return 1;}
        if (strcasecmp(str,"oacTechAppObjectDataType")==0) { result->SetData(oacTechAppObjectDataType); return 1;}
        if (strcasecmp(str,"oacTechPropDataType")==0) { result->SetData(oacTechPropDataType); return 1;}
        if (strcasecmp(str,"oacTechGroupDataType")==0) { result->SetData(oacTechGroupDataType); return 1;}
        if (strcasecmp(str,"oacTechGroupMemDataType")==0) { result->SetData(oacTechGroupMemDataType); return 1;}
        if (strcasecmp(str,"oacTechAvatarDataType")==0) { result->SetData(oacTechAvatarDataType); return 1;}
        if (strcasecmp(str,"oacTechValueDataType")==0) { result->SetData(oacTechValueDataType); return 1;}
        if (strcasecmp(str,"oacTechConstraintParamDefDataType")==0) { result->SetData(oacTechConstraintParamDefDataType); return 1;}
        if (strcasecmp(str,"oacTechConstraintParamDataType")==0) { result->SetData(oacTechConstraintParamDataType); return 1;}
        if (strcasecmp(str,"oacTechConstraintDefDataType")==0) { result->SetData(oacTechConstraintDefDataType); return 1;}
        if (strcasecmp(str,"oacTechConstraintDataType")==0) { result->SetData(oacTechConstraintDataType); return 1;}
        if (strcasecmp(str,"oacTechConstraintGroupDataType")==0) { result->SetData(oacTechConstraintGroupDataType); return 1;}
        if (strcasecmp(str,"oacTechConstraintGroupMemDataType")==0) { result->SetData(oacTechConstraintGroupMemDataType); return 1;}
        if (strcasecmp(str,"oacTechConstraintGroupHeaderDataType")==0) { result->SetData(oacTechConstraintGroupHeaderDataType); return 1;}
        if (strcasecmp(str,"oacLayerDataType")==0) { result->SetData(oacLayerDataType); return 1;}
        if (strcasecmp(str,"oacPurposeDataType")==0) { result->SetData(oacPurposeDataType); return 1;}
        if (strcasecmp(str,"oacSiteDefDataType")==0) { result->SetData(oacSiteDefDataType); return 1;}
        if (strcasecmp(str,"oacViaDefDataType")==0) { result->SetData(oacViaDefDataType); return 1;}
        if (strcasecmp(str,"oacOpPointDataType")==0) { result->SetData(oacOpPointDataType); return 1;}
        if (strcasecmp(str,"oacAnalysisLibDataType")==0) { result->SetData(oacAnalysisLibDataType); return 1;}
        if (strcasecmp(str,"oacViaSpecDataType")==0) { result->SetData(oacViaSpecDataType); return 1;}
        if (strcasecmp(str,"oacTechFeatureDataType")==0) { result->SetData(oacTechFeatureDataType); return 1;}
        if (strcasecmp(str,"oacTechFeaturePolicyDataType")==0) { result->SetData(oacTechFeaturePolicyDataType); return 1;}
        if (strcasecmp(str,"oacTechHeaderDataType")==0) { result->SetData(oacTechHeaderDataType); return 1;}
        if (strcasecmp(str,"oacTechLayerHeaderDataType")==0) { result->SetData(oacTechLayerHeaderDataType); return 1;}
        if (strcasecmp(str,"oacTechViaDefHeaderDataType")==0) { result->SetData(oacTechViaDefHeaderDataType); return 1;}
        if (strcasecmp(str,"oacTechDerivedLayerParamDefDataType")==0) { result->SetData(oacTechDerivedLayerParamDefDataType); return 1;}
        if (strcasecmp(str,"oacTechDerivedLayerParamDataType")==0) { result->SetData(oacTechDerivedLayerParamDataType); return 1;}
        if (strcasecmp(str,"oacTechDerivedLayerDefDataType")==0) { result->SetData(oacTechDerivedLayerDefDataType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaTechDataTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaTechDataTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaTechDataTypeEnum_FromoaTechDataTypeEnum(oaTechDataTypeEnum ob)
{
    if (ob==oacTechDataType) return PyString_FromString("oacTechDataType");
    if (ob==oacTechAppObjectDataType) return PyString_FromString("oacTechAppObjectDataType");
    if (ob==oacTechPropDataType) return PyString_FromString("oacTechPropDataType");
    if (ob==oacTechGroupDataType) return PyString_FromString("oacTechGroupDataType");
    if (ob==oacTechGroupMemDataType) return PyString_FromString("oacTechGroupMemDataType");
    if (ob==oacTechAvatarDataType) return PyString_FromString("oacTechAvatarDataType");
    if (ob==oacTechValueDataType) return PyString_FromString("oacTechValueDataType");
    if (ob==oacTechConstraintParamDefDataType) return PyString_FromString("oacTechConstraintParamDefDataType");
    if (ob==oacTechConstraintParamDataType) return PyString_FromString("oacTechConstraintParamDataType");
    if (ob==oacTechConstraintDefDataType) return PyString_FromString("oacTechConstraintDefDataType");
    if (ob==oacTechConstraintDataType) return PyString_FromString("oacTechConstraintDataType");
    if (ob==oacTechConstraintGroupDataType) return PyString_FromString("oacTechConstraintGroupDataType");
    if (ob==oacTechConstraintGroupMemDataType) return PyString_FromString("oacTechConstraintGroupMemDataType");
    if (ob==oacTechConstraintGroupHeaderDataType) return PyString_FromString("oacTechConstraintGroupHeaderDataType");
    if (ob==oacLayerDataType) return PyString_FromString("oacLayerDataType");
    if (ob==oacPurposeDataType) return PyString_FromString("oacPurposeDataType");
    if (ob==oacSiteDefDataType) return PyString_FromString("oacSiteDefDataType");
    if (ob==oacViaDefDataType) return PyString_FromString("oacViaDefDataType");
    if (ob==oacOpPointDataType) return PyString_FromString("oacOpPointDataType");
    if (ob==oacAnalysisLibDataType) return PyString_FromString("oacAnalysisLibDataType");
    if (ob==oacViaSpecDataType) return PyString_FromString("oacViaSpecDataType");
    if (ob==oacTechFeatureDataType) return PyString_FromString("oacTechFeatureDataType");
    if (ob==oacTechFeaturePolicyDataType) return PyString_FromString("oacTechFeaturePolicyDataType");
    if (ob==oacTechHeaderDataType) return PyString_FromString("oacTechHeaderDataType");
    if (ob==oacTechLayerHeaderDataType) return PyString_FromString("oacTechLayerHeaderDataType");
    if (ob==oacTechViaDefHeaderDataType) return PyString_FromString("oacTechViaDefHeaderDataType");
    if (ob==oacTechDerivedLayerParamDefDataType) return PyString_FromString("oacTechDerivedLayerParamDefDataType");
    if (ob==oacTechDerivedLayerParamDataType) return PyString_FromString("oacTechDerivedLayerParamDataType");
    if (ob==oacTechDerivedLayerDefDataType) return PyString_FromString("oacTechDerivedLayerDefDataType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaTechDataTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaTechDataTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaTechDataTypeEnum_FromoaTechDataTypeEnum(oaTechDataTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaTechDataTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaTechDataTypeEnum_doc[] =
"Type convert function for enum: oaTechDataTypeEnum";
                               
static PyMethodDef PyoaTechDataTypeEnum_method =
  {"oaTechDataTypeEnum",(PyCFunction)PyoaTechDataTypeEnum_TypeFunction,METH_VARARGS,oaTechDataTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaTechDataTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacTechDataType");
    PyDict_SetItemString(mod_dict,"oacTechDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechAppObjectDataType");
    PyDict_SetItemString(mod_dict,"oacTechAppObjectDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechPropDataType");
    PyDict_SetItemString(mod_dict,"oacTechPropDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechGroupDataType");
    PyDict_SetItemString(mod_dict,"oacTechGroupDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechGroupMemDataType");
    PyDict_SetItemString(mod_dict,"oacTechGroupMemDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechAvatarDataType");
    PyDict_SetItemString(mod_dict,"oacTechAvatarDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechValueDataType");
    PyDict_SetItemString(mod_dict,"oacTechValueDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechConstraintParamDefDataType");
    PyDict_SetItemString(mod_dict,"oacTechConstraintParamDefDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechConstraintParamDataType");
    PyDict_SetItemString(mod_dict,"oacTechConstraintParamDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechConstraintDefDataType");
    PyDict_SetItemString(mod_dict,"oacTechConstraintDefDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechConstraintDataType");
    PyDict_SetItemString(mod_dict,"oacTechConstraintDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechConstraintGroupDataType");
    PyDict_SetItemString(mod_dict,"oacTechConstraintGroupDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechConstraintGroupMemDataType");
    PyDict_SetItemString(mod_dict,"oacTechConstraintGroupMemDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechConstraintGroupHeaderDataType");
    PyDict_SetItemString(mod_dict,"oacTechConstraintGroupHeaderDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLayerDataType");
    PyDict_SetItemString(mod_dict,"oacLayerDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPurposeDataType");
    PyDict_SetItemString(mod_dict,"oacPurposeDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSiteDefDataType");
    PyDict_SetItemString(mod_dict,"oacSiteDefDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacViaDefDataType");
    PyDict_SetItemString(mod_dict,"oacViaDefDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOpPointDataType");
    PyDict_SetItemString(mod_dict,"oacOpPointDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAnalysisLibDataType");
    PyDict_SetItemString(mod_dict,"oacAnalysisLibDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacViaSpecDataType");
    PyDict_SetItemString(mod_dict,"oacViaSpecDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechFeatureDataType");
    PyDict_SetItemString(mod_dict,"oacTechFeatureDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechFeaturePolicyDataType");
    PyDict_SetItemString(mod_dict,"oacTechFeaturePolicyDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechHeaderDataType");
    PyDict_SetItemString(mod_dict,"oacTechHeaderDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechLayerHeaderDataType");
    PyDict_SetItemString(mod_dict,"oacTechLayerHeaderDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechViaDefHeaderDataType");
    PyDict_SetItemString(mod_dict,"oacTechViaDefHeaderDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechDerivedLayerParamDefDataType");
    PyDict_SetItemString(mod_dict,"oacTechDerivedLayerParamDefDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechDerivedLayerParamDataType");
    PyDict_SetItemString(mod_dict,"oacTechDerivedLayerParamDataType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechDerivedLayerDefDataType");
    PyDict_SetItemString(mod_dict,"oacTechDerivedLayerDefDataType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaTechDataTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaTechDataTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaTechDataTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaTechHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaTechHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaTechHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaTechHeaderObject* self = (PyoaTechHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaTechHeader)
    {
        PyParamoaTechHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaTechHeader_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaTechHeader, Choices are:\n"
        "    (oaTechHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaTechHeader_tp_dealloc(PyoaTechHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaTechHeader_tp_repr(PyObject *ob)
{
    PyParamoaTechHeader value;
    int convert_status=PyoaTechHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[34];
    sprintf(buffer,"<oaTechHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaTechHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaTechHeader v1;
    PyParamoaTechHeader v2;
    int convert_status1=PyoaTechHeader_Convert(ob1,&v1);
    int convert_status2=PyoaTechHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaTechHeader_Convert(PyObject* ob,PyParamoaTechHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaTechHeader_Check(ob)) {
        result->SetData( (oaTechHeader**) ((PyoaTechHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaTechHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaTechHeader_FromoaTechHeader(oaTechHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaTechHeader* data=*value;
        PyObject* bself = PyoaTechHeader_Type.tp_alloc(&PyoaTechHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaTechHeaderObject* self = (PyoaTechHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaTechHeader_FromoaTechHeader(oaTechHeader* data)
{
    if (data) {
       PyObject* bself = PyoaTechHeader_Type.tp_alloc(&PyoaTechHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaTechHeaderObject* self = (PyoaTechHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaTechHeader_getRefLibName_doc[] = 
"Class: oaTechHeader, Function: getRefLibName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getRefLibName(oaScalarName& refLibName) const\n"
"    Signature: getRefLibName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function retrieves the name of the library that contains the technology database that this techHeader references.\n"
"    refLibName\n"
"    Retrieved library name\n"
"    Todo\n"
"    Check parameter descriptions.\n"
;

static PyObject*
oaTechHeader_getRefLibName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTechHeader data;
    int convert_status=PyoaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechHeaderObject* self=(PyoaTechHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScalarName p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaScalarName_Convert,&p1)) {
        data.DataCall()->getRefLibName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTechHeader_getRefTech_doc[] = 
"Class: oaTechHeader, Function: getRefTech\n"
"  Paramegers: ()\n"
"    Calls: oaTech* getRefTech() const\n"
"    Signature: getRefTech|ptr-oaTech|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the technology database that this techHeader references. NULL is returned if the technology database is not bound.\n"
;

static PyObject*
oaTechHeader_getRefTech(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTechHeader data;
    int convert_status=PyoaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechHeaderObject* self=(PyoaTechHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaTechp result= (data.DataCall()->getRefTech());
        return PyoaTech_FromoaTech(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTechHeader_isBound_doc[] = 
"Class: oaTechHeader, Function: isBound\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isBound() const\n"
"    Signature: isBound|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether this techHeader is bound or not.\n"
;

static PyObject*
oaTechHeader_isBound(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTechHeader data;
    int convert_status=PyoaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechHeaderObject* self=(PyoaTechHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isBound());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTechHeader_isNull_doc[] =
"Class: oaTechHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaTechHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaTechHeader data;
    int convert_status=PyoaTechHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaTechHeader_assign_doc[] = 
"Class: oaTechHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaTechHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaTechHeader data;
  int convert_status=PyoaTechHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaTechHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaTechHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaTechHeader_methodlist[] = {
    {"getRefLibName",(PyCFunction)oaTechHeader_getRefLibName,METH_VARARGS,oaTechHeader_getRefLibName_doc},
    {"getRefTech",(PyCFunction)oaTechHeader_getRefTech,METH_VARARGS,oaTechHeader_getRefTech_doc},
    {"isBound",(PyCFunction)oaTechHeader_isBound,METH_VARARGS,oaTechHeader_isBound_doc},
    {"isNull",(PyCFunction)oaTechHeader_tp_isNull,METH_VARARGS,oaTechHeader_isNull_doc},
    {"assign",(PyCFunction)oaTechHeader_tp_assign,METH_VARARGS,oaTechHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaTechHeader_doc[] = 
"Class: oaTechHeader\n"
"  The oaTechHeader class implements an object that contains information about a referenced oaTech database in a given parent oaTech database. The oaTechHeader manages the binding and unbinding of the oaTech references.\n"
"  An oaTechHeader is an automatic object that is created and destroyed by the database. An oaTechHeader is automatically created when an object references another object that is in another oaTech database in the graph of referenced oaTech databases. The oaTechHeader is automatically destroyed when the last object making the reference is destroyed.\n"
"  Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"Constructors:\n"
"  Paramegers: (oaTechHeader)\n"
"    Calls: (const oaTechHeader&)\n"
"    Signature: oaTechHeader||cref-oaTechHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaTechHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaTechHeader",
    sizeof(PyoaTechHeaderObject),
    0,
    (destructor)oaTechHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaTechHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaTechHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaTechHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaTechHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaTechObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaTechHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaTechHeader_static_find_doc[] = 
"Class: oaTechHeader, Function: find\n"
"  Paramegers: (oaTech,oaScalarName)\n"
"    Calls: oaTechHeader* find(const oaTech* tech,const oaScalarName& refLibName)\n"
"    Signature: find|ptr-oaTechHeader|cptr-oaTech,cref-oaScalarName,\n"
"    This function searches the specified technology database for a techHeader that references a tech in the library with the specified name.\n"
"    tech\n"
"    Tech database to search\n"
"    refLibName\n"
"    Name of library in which to find the tech reference\n"
"    Todo\n"
"    Check parameter descriptions.\n"
"  Paramegers: (oaTech,oaTech)\n"
"    Calls: oaTechHeader* find(const oaTech* tech,const oaTech* refTech)\n"
"    Signature: find|ptr-oaTechHeader|cptr-oaTech,cptr-oaTech,\n"
"    This function searches the specified tech database ( tech ) for a techHeader that references the specified tech database ( refTech ).\n"
"    tech\n"
"    Tech database to search\n"
"    refTech\n"
"    Tech database that is referenced\n"
"    Todo\n"
"    Check parameter descriptions.\n"
;

static PyObject*
oaTechHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaTech,oaScalarName)
    {
        PyParamoaTech p1;
        PyParamoaScalarName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaScalarName_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaTechHeaderp result= (oaTechHeader::find(p1.Data(),p2.Data()));
            return PyoaTechHeader_FromoaTechHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTech,oaTech)
    {
        PyParamoaTech p1;
        PyParamoaTech p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaTech_Convert,&p1,
              &PyoaTech_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaTechHeaderp result= (oaTechHeader::find(p1.Data(),p2.Data()));
            return PyoaTechHeader_FromoaTechHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaTechHeader, function: find, Choices are:\n"
        "    (oaTech,oaScalarName)\n"
        "    (oaTech,oaTech)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaTechHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaTechHeader_static_find,METH_VARARGS,oaTechHeader_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaTechHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaTechHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaTechHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaTechHeader",
           (PyObject*)(&PyoaTechHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaTechHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaTechHeader_Type.tp_dict;
    for(method=oaTechHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


// ==================================================================
// Array for class: oaTechHeader
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaTechHeader_Array_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaTechHeader_Array_Type);
    PyObject* gself = type->tp_alloc(type,0);
    if (gself == NULL) return gself;
    PyoaTechHeader_ArrayObject* self = (PyoaTechHeader_ArrayObject*)gself;
    self->borrow = 0;
    self->locks=NULL;
    static char *kwlist [] = { NULL } ;
    /* Case: () */ 
    {
        if (PyArg_ParseTuple(args,"")) {
            return gself;
        }
    }
    PyErr_Clear();
    /* Case: (int) */
    {
        int p1;
        if (PyArg_ParseTuple(args,(char*)"i",&p1)) {
            self->data.SetLen(p1);
            return gself;
        }
    }
    PyErr_Clear();
    /* Case: (oaTechHeader_Array) */
    {
        PyParamoaTechHeader_Array p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaTechHeader_Array_Convert,&p1)) {
            self->data.TakeAway(p1);
            return gself;
        }
    }
    /* Error */
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaTechHeader_Array, Choices are:\n"
        "    ()\n"
        "    (int)\n"
        "    (oaTechHeader_Array)\n"
    );
    Py_DECREF(gself);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaTechHeader_Array_dealloc(PyObject* gself)
{
    PyoaTechHeader_ArrayObject* self = (PyoaTechHeader_ArrayObject*)gself;
    Py_XDECREF(self->locks);
    self->ob_type->tp_free(gself);
}

// ------------------------------------------------------------------
static PyObject*
oaTechHeader_Array_str(PyObject *ob)
{
    PyParamoaTechHeader_Array value;
    int convert_status=PyoaTechHeader_Array_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* lst=PyoaTechHeader_Array_CreateList(value);
    PyObject* result=PyObject_Str(lst);
    Py_DECREF(lst);
    return result;
}

// ------------------------------------------------------------------
static PyObject*
oaTechHeader_Array_repr(PyObject *ob)
{
    PyParamoaTechHeader_Array value;
    int convert_status=PyoaTechHeader_Array_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* lst=PyoaTechHeader_Array_CreateList(value);
    PyObject* result=PyObject_Repr(lst);
    Py_DECREF(lst);
    return result;
}

// ------------------------------------------------------------------
static int
oaTechHeader_Array_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaTechHeader_Array p1;
    PyParamoaTechHeader_Array p2;
    int s1=PyoaTechHeader_Array_Convert(ob1,&p1);
    int s2=PyoaTechHeader_Array_Convert(ob2,&p2);
    assert(s1!=0);
    assert(s2!=0);
    PyObject* l1=PyoaTechHeader_Array_CreateList(p1);
    PyObject* l2=PyoaTechHeader_Array_CreateList(p2);
    int result=PyObject_Compare(l1,l2);
    Py_DECREF(l1);
    Py_DECREF(l2);
    return result;
}

// ------------------------------------------------------------------
int
PyoaTechHeader_Array_Convert(PyObject* ob,PyParamoaTechHeader_Array* result)
{
  Pyoa_ssize_t len,i;
  if (PyoaTechHeader_Array_Check(ob)) {
    PyoaTechHeader_ArrayObject* self = (PyoaTechHeader_ArrayObject*)ob;
    result->Borrow(self->data);
  }
  else if (PyList_Check(ob)) {
    len=PyList_Size(ob);
    result->SetLen(len);
    PyParamoaTechHeader data;
    for(i=0;i<len;i++) {
      PyObject* a=PyList_GetItem(ob,i);
      if (!PyoaTechHeader_Convert(a,&data)) return 0;
      result->SetItem(i,data.Data());
    }
  }
  else if (PyTuple_Check(ob)) {
    len=PyTuple_Size(ob);
    result->SetLen(len);
    PyParamoaTechHeader data;
    for(i=0;i<len;i++) {
      PyObject* a=PyTuple_GetItem(ob,i);
      if (!PyoaTechHeader_Convert(a,&data)) return 0;
      result->SetItem(i,data.Data());
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError,
      "Convertion of parameter to class: oaTechHeader_Array Failed");
    return 0;
  }
  return 1;
}

// ------------------------------------------------------------------
PyObject* PyoaTechHeader_Array_FromoaTechHeader_Array(const oaTechHeader_Array& value)
{
  PyObject* gself = PyoaTechHeader_Array_Type.tp_alloc(&PyoaTechHeader_Array_Type,0);
  if (gself == NULL) return gself;
  PyoaTechHeader_ArrayObject* self = (PyoaTechHeader_ArrayObject*)gself;
  self->data = value;
  self->borrow = 0;
  self->locks=NULL;
  return gself;
}

// ------------------------------------------------------------------
PyObject* PyoaTechHeader_Array_FromoaTechHeader_Array(PyTypeoaTechHeader* data,Pyoa_ssize_t len,PyObject* lock)
{
  PyObject* gself = PyoaTechHeader_Array_Type.tp_alloc(&PyoaTechHeader_Array_Type,0);
  if (gself == NULL) return gself;
  PyoaTechHeader_ArrayObject* self = (PyoaTechHeader_ArrayObject*)gself;
  self->data.Borrow(data,len);
  self->borrow = 1;
  self->locks=NULL;
  if (lock) PyoaLockObject(self->locks,lock);
  return gself;
}

// ------------------------------------------------------------------
PyObject* PyoaTechHeader_Array_CreateList(PyParamoaTechHeader_Array& value)
{
  Pyoa_ssize_t i;
  PyObject* lst=PyList_New(value.Len());
  for(i=0;i<value.Len();i++) {
    PyObject* ob=PyoaTechHeader_FromoaTechHeader(value.Data()[i]);
    PyList_SetItem(lst,i,ob);
  }
  return lst;
}

// ------------------------------------------------------------------
// Methods
// ------------------------------------------------------------------
static char oaTechHeader_Array_assign_doc[] = 
"Class: oaTechHeader_Array, Function: assign\n"
"  Paramegers: (oaTechHeader_Array)\n"
"    This function assigns the current value.\n"
;

static PyObject*
oaTechHeader_Array_assign(PyObject* ob, PyObject *args)
{
  PyoaTechHeader_ArrayObject* self=(PyoaTechHeader_ArrayObject*)ob;
  try {
    PyParamoaTechHeader_Array p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaTechHeader_Array_Convert,&p1)) {
        self->data=p1;
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}
// ------------------------------------------------------------------
static char oaTechHeader_Array_list_doc[] = 
"Class: oaTechHeader_Array, Function: list\n"
"  Paramegers: ()\n"
"    This function returns the current value as a list.\n"
;

static PyObject*
oaTechHeader_Array_list(PyObject* ob, PyObject *args)
{
  PyoaTechHeader_ArrayObject* self=(PyoaTechHeader_ArrayObject*)ob;
  try {
    if (PyArg_ParseTuple(args,(char*)"")) {
      return PyoaTechHeader_Array_CreateList(self->data);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}
// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------
static PyMethodDef oaTechHeader_Array_methodlist[] = {
    {"assign",(PyCFunction)oaTechHeader_Array_assign,METH_VARARGS,oaTechHeader_Array_assign_doc},
    {"list",(PyCFunction)oaTechHeader_Array_list,METH_VARARGS,oaTechHeader_Array_list_doc},
   {NULL,NULL,0,NULL}
};

// ------------------------------------------------------------------
static PyObject*
oaTechHeader_Array_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaTechHeader_ArrayObject* self=(PyoaTechHeader_ArrayObject*)ob;
  try {
    PyParamoaTechHeader_Array data;
    int convert_status=PyoaTechHeader_Array_Convert(ob,&data);
    assert(convert_status!=0);
    if (index<0 || index>=data.Len()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    return PyoaTechHeader_FromoaTechHeader(data.GetItemPtr(index),1,self->locks);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static Pyoa_ssize_t
oaTechHeader_Array_index_get_length(PyObject* ob)
{
    PyParamoaTechHeader_Array data;
    int convert_status=PyoaTechHeader_Array_Convert(ob,&data);
    assert(convert_status!=0);
    return data.Len();
}

// ------------------------------------------------------------------
static int
oaTechHeader_Array_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaTechHeader_Array data;
    PyParamoaTechHeader dataitem;
    int convert_status=PyoaTechHeader_Array_Convert(ob,&data);
    assert(convert_status!=0);
    if (index<0 || index>=data.Len()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    if (PyoaTechHeader_Convert(value,&dataitem)==0) return -1;
    data.SetItem(index,dataitem.Data());
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return 0;
  }
}

// ------------------------------------------------------------------
static char oaTechHeader_Array_doc[] =
"Class: oaTechHeader_Array\n"
"  The oaTechHeader_Array utility class provides an array of oaTechHeader.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaTechHeader_Array()\n"
"    Signature: oaTechHeader_Array||\n"
"    This is the default constructor for the oaTechHeader_Array class. This constructor creates an empty oaTechHeader_Array.\n"
"  Paramegers: (oaTechHeader_Array)\n"
"    Calls: (const oaTechHeader_Array&)\n"
"    Signature: oaTechHeader_Array||cref-oaTechHeader_Array,\n"
;

// ------------------------------------------------------------------
static PySequenceMethods oaTechHeader_Array_as_sequence = {
    (Pyoa_inquiry)oaTechHeader_Array_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,              /* sq_concat */
    (Pyoa_intargfunc)0,              /* sq_repeat */
    (Pyoa_intargfunc)oaTechHeader_Array_index_get, /* sq_item */
    (Pyoa_intintargfunc)0,           /* sq_slice */
    (Pyoa_intobjargproc)oaTechHeader_Array_index_set,      /* sq_ass_item */
};

// ------------------------------------------------------------------
PyTypeObject PyoaTechHeader_Array_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaTechHeader_Array",
    sizeof(PyoaTechHeader_ArrayObject),
    0,
    oaTechHeader_Array_dealloc, /* tp_dealloc */
    0,  /* tp_print */
    0,                                  /* tp_getattr */
    0,                                  /* tp_setattr */
    oaTechHeader_Array_compare,    /* tp_compare */
    oaTechHeader_Array_repr,      /* tp_repr */
    0,                                  /* tp_as_number */
    &oaTechHeader_Array_as_sequence,  /* tp_as_sequence */
    0,                                  /* tp_as_mapping */
    0,                                  /* tp_as_hash */
    0,                                  /* tp_as_call */
    oaTechHeader_Array_str,               /* tp_str */
    0,                                  /* tp_getattro */
    0,                                  /* tp_setattro */
    0,                                  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaTechHeader_Array_doc, /* tp_doc */
    0,                                  /* tp_traverse */
    0,                                  /* tp_clear */
    0,                                  /* tp_richcompre */
    0,                                  /* tp_weaklistoffset */
    0,                                  /* tp_iter */
    0,                                  /* tp_iternext */
    oaTechHeader_Array_methodlist, /* tp_methods */
    0,                                  /* tp_members */
    0,                                  /* tp_getset */
    0,                                  /* tp_base */
    0,                                  /* tp_dict */
    0,                                  /* tp_descr_get */
    0,                                  /* tp_descr_set */
    0,                                  /* tp_dictoffset */
    0,                                  /* tp_init */
    PyType_GenericAlloc,        /* tp_alloc */
    oaTechHeader_Array_new, /* tp_new */
    _PyObject_Del,      /* tp_free */
};


// ------------------------------------------------------------------
int
PyoaTechHeader_Array_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaTechHeader_Array_Type)<0) {
      printf("** PyType_Ready failed for: oaTechHeader_Array\n");
      return -1;
    }
    if (PyDict_SetItemString(mod_dict,"oaTechHeader_Array",
           (PyObject*)(&PyoaTechHeader_Array_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaTechHeader_Array\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaTechHeaderArray
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaTechHeaderArray_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaTechHeaderArray_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaTechHeaderArrayObject* self = (PyoaTechHeaderArrayObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaArrayBase_oaTechHeader*)  new oaTechHeaderArray();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value = (oaArrayBase_oaTechHeader*)  new oaTechHeaderArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaTechHeaderArray)
    {
        PyParamoaTechHeaderArray p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaTechHeaderArray_Convert,&p1)) {
            self->value=(oaArrayBase_oaTechHeader*)  new oaTechHeaderArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaTechHeaderArray, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaTechHeaderArray)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaTechHeaderArray_tp_dealloc(PyoaTechHeaderArrayObject* self)
{
    if (!self->borrow) {
        delete (oaTechHeaderArray*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaTechHeaderArray_tp_repr(PyObject *ob)
{
    PyParamoaTechHeaderArray value;
    int convert_status=PyoaTechHeaderArray_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[39];
    sprintf(buffer,"<oaTechHeaderArray::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaTechHeaderArray_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaTechHeaderArray v1;
    PyParamoaTechHeaderArray v2;
    int convert_status1=PyoaTechHeaderArray_Convert(ob1,&v1);
    int convert_status2=PyoaTechHeaderArray_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaTechHeaderArray_Convert(PyObject* ob,PyParamoaTechHeaderArray* result)
{
    if (ob == NULL) return 1;
    if (PyoaTechHeaderArray_Check(ob)) {
        result->SetData( (oaTechHeaderArray*) ((PyoaTechHeaderArrayObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaTechHeaderArray Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaTechHeaderArray_FromoaTechHeaderArray(oaTechHeaderArray* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaTechHeaderArray_Type.tp_alloc(&PyoaTechHeaderArray_Type,0);
        if (bself == NULL) return bself;
        PyoaTechHeaderArrayObject* self = (PyoaTechHeaderArrayObject*)bself;
        self->value = (oaArrayBase_oaTechHeader*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaTechHeaderArray_doc[] = 
"Class: oaTechHeaderArray\n"
"  The oaTechHeaderArray class implements an array of oaTechHeader pointers used for retrieving the collection of techHeaders in a technology database.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaTechHeaderArray()\n"
"    Signature: oaTechHeaderArray||simple-oaUInt4,\n"
"    This oaTechHeaderArray constructor creates an array of oaTechHeader pointers of the specified size.\n"
"    sizeIn\n"
"    Size of array to construct.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaTechHeaderArray(oaUInt4 sizeIn)\n"
"    Signature: oaTechHeaderArray||simple-oaUInt4,\n"
"    This oaTechHeaderArray constructor creates an array of oaTechHeader pointers of the specified size.\n"
"    sizeIn\n"
"    Size of array to construct.\n"
"  Paramegers: (oaTechHeaderArray)\n"
"    Calls: (const oaTechHeaderArray&)\n"
"    Signature: oaTechHeaderArray||cref-oaTechHeaderArray,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaTechHeaderArray_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaTechHeaderArray",
    sizeof(PyoaTechHeaderArrayObject),
    0,
    (destructor)oaTechHeaderArray_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaTechHeaderArray_tp_compare,	/* tp_compare */
    (reprfunc)oaTechHeaderArray_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaTechHeaderArray_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaArray_oaTechHeader_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaTechHeaderArray_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaTechHeaderArray_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaTechHeaderArray_Type)<0) {
      printf("** PyType_Ready failed for: oaTechHeaderArray\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaTechHeaderArray",
           (PyObject*)(&PyoaTechHeaderArray_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaTechHeaderArray\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaTechHeaderModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaTechHeaderModTypeEnum_Convert(PyObject* ob,PyParamoaTechHeaderModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacBindTechHeaderModType")==0) { result->SetData(oacBindTechHeaderModType); return 1;}
        if (strcasecmp(str,"oacUnbindTechHeaderModType")==0) { result->SetData(oacUnbindTechHeaderModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaTechHeaderModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaTechHeaderModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaTechHeaderModTypeEnum_FromoaTechHeaderModTypeEnum(oaTechHeaderModTypeEnum ob)
{
    if (ob==oacBindTechHeaderModType) return PyString_FromString("oacBindTechHeaderModType");
    if (ob==oacUnbindTechHeaderModType) return PyString_FromString("oacUnbindTechHeaderModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaTechHeaderModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaTechHeaderModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaTechHeaderModTypeEnum_FromoaTechHeaderModTypeEnum(oaTechHeaderModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaTechHeaderModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaTechHeaderModTypeEnum_doc[] =
"Type convert function for enum: oaTechHeaderModTypeEnum";
                               
static PyMethodDef PyoaTechHeaderModTypeEnum_method =
  {"oaTechHeaderModTypeEnum",(PyCFunction)PyoaTechHeaderModTypeEnum_TypeFunction,METH_VARARGS,oaTechHeaderModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaTechHeaderModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacBindTechHeaderModType");
    PyDict_SetItemString(mod_dict,"oacBindTechHeaderModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacUnbindTechHeaderModType");
    PyDict_SetItemString(mod_dict,"oacUnbindTechHeaderModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaTechHeaderModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaTechHeaderModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaTechHeaderModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaTechLayerHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaTechLayerHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaTechLayerHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaTechLayerHeaderObject* self = (PyoaTechLayerHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaTechLayerHeader)
    {
        PyParamoaTechLayerHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaTechLayerHeader_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaTechLayerHeader, Choices are:\n"
        "    (oaTechLayerHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaTechLayerHeader_tp_dealloc(PyoaTechLayerHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaTechLayerHeader_tp_repr(PyObject *ob)
{
    PyParamoaTechLayerHeader value;
    int convert_status=PyoaTechLayerHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[39];
    sprintf(buffer,"<oaTechLayerHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaTechLayerHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaTechLayerHeader v1;
    PyParamoaTechLayerHeader v2;
    int convert_status1=PyoaTechLayerHeader_Convert(ob1,&v1);
    int convert_status2=PyoaTechLayerHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaTechLayerHeader_Convert(PyObject* ob,PyParamoaTechLayerHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaTechLayerHeader_Check(ob)) {
        result->SetData( (oaTechLayerHeader**) ((PyoaTechLayerHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaTechLayerHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaTechLayerHeader_FromoaTechLayerHeader(oaTechLayerHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaTechLayerHeader* data=*value;
        PyObject* bself = PyoaTechLayerHeader_Type.tp_alloc(&PyoaTechLayerHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaTechLayerHeaderObject* self = (PyoaTechLayerHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaTechLayerHeader_FromoaTechLayerHeader(oaTechLayerHeader* data)
{
    if (data) {
       PyObject* bself = PyoaTechLayerHeader_Type.tp_alloc(&PyoaTechLayerHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaTechLayerHeaderObject* self = (PyoaTechLayerHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaTechLayerHeader_getLayer_doc[] = 
"Class: oaTechLayerHeader, Function: getLayer\n"
"  Paramegers: ()\n"
"    Calls: oaLayer* getLayer() const\n"
"    Signature: getLayer|ptr-oaLayer|\n"
"    BrowseData: 1\n"
"    This function returns the layer that this techLayerHeader represents. NULL is returned if the layer is unavailable; this may occur if the corresponding technology database is not open.\n"
;

static PyObject*
oaTechLayerHeader_getLayer(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTechLayerHeader data;
    int convert_status=PyoaTechLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechLayerHeaderObject* self=(PyoaTechLayerHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaLayerp result= (data.DataCall()->getLayer());
        return PyoaLayer_FromoaLayer(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTechLayerHeader_getLayerNum_doc[] = 
"Class: oaTechLayerHeader, Function: getLayerNum\n"
"  Paramegers: ()\n"
"    Calls: oaLayerNum getLayerNum() const\n"
"    Signature: getLayerNum|simple-oaLayerNum|\n"
"    BrowseData: 1\n"
"    This function returns the layer number that this techLayerHeader represents.\n"
;

static PyObject*
oaTechLayerHeader_getLayerNum(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTechLayerHeader data;
    int convert_status=PyoaTechLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechLayerHeaderObject* self=(PyoaTechLayerHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaLayerNum result= (data.DataCall()->getLayerNum());
        return PyoaLayerNum_FromoaLayerNum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTechLayerHeader_isBound_doc[] = 
"Class: oaTechLayerHeader, Function: isBound\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isBound() const\n"
"    Signature: isBound|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether this techLayerHeader is bound or not. This techLayerHeader will not be bound if it is a header for a layer in a referenced technology database that currently is not available.\n"
;

static PyObject*
oaTechLayerHeader_isBound(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTechLayerHeader data;
    int convert_status=PyoaTechLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaTechLayerHeaderObject* self=(PyoaTechLayerHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isBound());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaTechLayerHeader_isNull_doc[] =
"Class: oaTechLayerHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaTechLayerHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaTechLayerHeader data;
    int convert_status=PyoaTechLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaTechLayerHeader_assign_doc[] = 
"Class: oaTechLayerHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaTechLayerHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaTechLayerHeader data;
  int convert_status=PyoaTechLayerHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaTechLayerHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaTechLayerHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaTechLayerHeader_methodlist[] = {
    {"getLayer",(PyCFunction)oaTechLayerHeader_getLayer,METH_VARARGS,oaTechLayerHeader_getLayer_doc},
    {"getLayerNum",(PyCFunction)oaTechLayerHeader_getLayerNum,METH_VARARGS,oaTechLayerHeader_getLayerNum_doc},
    {"isBound",(PyCFunction)oaTechLayerHeader_isBound,METH_VARARGS,oaTechLayerHeader_isBound_doc},
    {"isNull",(PyCFunction)oaTechLayerHeader_tp_isNull,METH_VARARGS,oaTechLayerHeader_isNull_doc},
    {"assign",(PyCFunction)oaTechLayerHeader_tp_assign,METH_VARARGS,oaTechLayerHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaTechLayerHeader_doc[] = 
"Class: oaTechLayerHeader\n"
"  The oaTechLayerHeader manages the binding to a specific layer, whether that layer exists in the same or in a referenced technology database.\n"
"Constructors:\n"
"  Paramegers: (oaTechLayerHeader)\n"
"    Calls: (const oaTechLayerHeader&)\n"
"    Signature: oaTechLayerHeader||cref-oaTechLayerHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaTechLayerHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaTechLayerHeader",
    sizeof(PyoaTechLayerHeaderObject),
    0,
    (destructor)oaTechLayerHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaTechLayerHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaTechLayerHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaTechLayerHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaTechLayerHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaTechObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaTechLayerHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaTechLayerHeader_static_find_doc[] = 
"Class: oaTechLayerHeader, Function: find\n"
"  Paramegers: (oaTech,oaLayerNum)\n"
"    Calls: oaTechLayerHeader* find(const oaTech* tech,oaLayerNum layerNum)\n"
"    Signature: find|ptr-oaTechLayerHeader|cptr-oaTech,simple-oaLayerNum,\n"
"    This function searches the specified technology database for a techLayerHeader that is associated with the given layerNum .\n"
"    tech\n"
"    Tech database to search\n"
"    layerNum\n"
"    Layer number for which to find the associated techLayerHeader is to be found\n"
;

static PyObject*
oaTechLayerHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech p1;
    PyParamoaLayerNum p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTech_Convert,&p1,
          &PyoaLayerNum_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaTechLayerHeaderp result= (oaTechLayerHeader::find(p1.Data(),p2.Data()));
        return PyoaTechLayerHeader_FromoaTechLayerHeader(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaTechLayerHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaTechLayerHeader_static_find,METH_VARARGS,oaTechLayerHeader_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaTechLayerHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaTechLayerHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaTechLayerHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaTechLayerHeader",
           (PyObject*)(&PyoaTechLayerHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaTechLayerHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaTechLayerHeader_Type.tp_dict;
    for(method=oaTechLayerHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaTechLayerHeaderModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaTechLayerHeaderModTypeEnum_Convert(PyObject* ob,PyParamoaTechLayerHeaderModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacBindTechLayerHeaderModType")==0) { result->SetData(oacBindTechLayerHeaderModType); return 1;}
        if (strcasecmp(str,"oacUnbindTechLayerHeaderModType")==0) { result->SetData(oacUnbindTechLayerHeaderModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaTechLayerHeaderModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaTechLayerHeaderModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaTechLayerHeaderModTypeEnum_FromoaTechLayerHeaderModTypeEnum(oaTechLayerHeaderModTypeEnum ob)
{
    if (ob==oacBindTechLayerHeaderModType) return PyString_FromString("oacBindTechLayerHeaderModType");
    if (ob==oacUnbindTechLayerHeaderModType) return PyString_FromString("oacUnbindTechLayerHeaderModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaTechLayerHeaderModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaTechLayerHeaderModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaTechLayerHeaderModTypeEnum_FromoaTechLayerHeaderModTypeEnum(oaTechLayerHeaderModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaTechLayerHeaderModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaTechLayerHeaderModTypeEnum_doc[] =
"Type convert function for enum: oaTechLayerHeaderModTypeEnum";
                               
static PyMethodDef PyoaTechLayerHeaderModTypeEnum_method =
  {"oaTechLayerHeaderModTypeEnum",(PyCFunction)PyoaTechLayerHeaderModTypeEnum_TypeFunction,METH_VARARGS,oaTechLayerHeaderModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaTechLayerHeaderModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacBindTechLayerHeaderModType");
    PyDict_SetItemString(mod_dict,"oacBindTechLayerHeaderModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacUnbindTechLayerHeaderModType");
    PyDict_SetItemString(mod_dict,"oacUnbindTechLayerHeaderModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaTechLayerHeaderModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaTechLayerHeaderModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaTechLayerHeaderModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaTechModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaTechModTypeEnum_Convert(PyObject* ob,PyParamoaTechModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacSetDBUPerUUTechModType")==0) { result->SetData(oacSetDBUPerUUTechModType); return 1;}
        if (strcasecmp(str,"oacSetUserUnitsTechModType")==0) { result->SetData(oacSetUserUnitsTechModType); return 1;}
        if (strcasecmp(str,"oacSetClearanceMeasureTechModType")==0) { result->SetData(oacSetClearanceMeasureTechModType); return 1;}
        if (strcasecmp(str,"oacSetDefaultManufacturingGridTechModType")==0) { result->SetData(oacSetDefaultManufacturingGridTechModType); return 1;}
        if (strcasecmp(str,"oacSetDefaultConstraintGroupTechModType")==0) { result->SetData(oacSetDefaultConstraintGroupTechModType); return 1;}
        if (strcasecmp(str,"oacSetFoundryConstraintGroupTechModType")==0) { result->SetData(oacSetFoundryConstraintGroupTechModType); return 1;}
        if (strcasecmp(str,"oacSetRefsTechModType")==0) { result->SetData(oacSetRefsTechModType); return 1;}
        if (strcasecmp(str,"oacSetGateGroundedTechModType")==0) { result->SetData(oacSetGateGroundedTechModType); return 1;}
        if (strcasecmp(str,"oacUnsetDBUPerUUTechModType")==0) { result->SetData(oacUnsetDBUPerUUTechModType); return 1;}
        if (strcasecmp(str,"oacUnsetUserUnitsTechModType")==0) { result->SetData(oacUnsetUserUnitsTechModType); return 1;}
        if (strcasecmp(str,"oacUnsetClearanceMeasureTechModType")==0) { result->SetData(oacUnsetClearanceMeasureTechModType); return 1;}
        if (strcasecmp(str,"oacUnsetDefaultManufacturingGridTechModType")==0) { result->SetData(oacUnsetDefaultManufacturingGridTechModType); return 1;}
        if (strcasecmp(str,"oacUnsetGateGroundedTechModType")==0) { result->SetData(oacUnsetGateGroundedTechModType); return 1;}
        if (strcasecmp(str,"oacUnsetRefsTechModType")==0) { result->SetData(oacUnsetRefsTechModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaTechModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaTechModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaTechModTypeEnum_FromoaTechModTypeEnum(oaTechModTypeEnum ob)
{
    if (ob==oacSetDBUPerUUTechModType) return PyString_FromString("oacSetDBUPerUUTechModType");
    if (ob==oacSetUserUnitsTechModType) return PyString_FromString("oacSetUserUnitsTechModType");
    if (ob==oacSetClearanceMeasureTechModType) return PyString_FromString("oacSetClearanceMeasureTechModType");
    if (ob==oacSetDefaultManufacturingGridTechModType) return PyString_FromString("oacSetDefaultManufacturingGridTechModType");
    if (ob==oacSetDefaultConstraintGroupTechModType) return PyString_FromString("oacSetDefaultConstraintGroupTechModType");
    if (ob==oacSetFoundryConstraintGroupTechModType) return PyString_FromString("oacSetFoundryConstraintGroupTechModType");
    if (ob==oacSetRefsTechModType) return PyString_FromString("oacSetRefsTechModType");
    if (ob==oacSetGateGroundedTechModType) return PyString_FromString("oacSetGateGroundedTechModType");
    if (ob==oacUnsetDBUPerUUTechModType) return PyString_FromString("oacUnsetDBUPerUUTechModType");
    if (ob==oacUnsetUserUnitsTechModType) return PyString_FromString("oacUnsetUserUnitsTechModType");
    if (ob==oacUnsetClearanceMeasureTechModType) return PyString_FromString("oacUnsetClearanceMeasureTechModType");
    if (ob==oacUnsetDefaultManufacturingGridTechModType) return PyString_FromString("oacUnsetDefaultManufacturingGridTechModType");
    if (ob==oacUnsetGateGroundedTechModType) return PyString_FromString("oacUnsetGateGroundedTechModType");
    if (ob==oacUnsetRefsTechModType) return PyString_FromString("oacUnsetRefsTechModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaTechModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaTechModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaTechModTypeEnum_FromoaTechModTypeEnum(oaTechModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaTechModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaTechModTypeEnum_doc[] =
"Type convert function for enum: oaTechModTypeEnum";
                               
static PyMethodDef PyoaTechModTypeEnum_method =
  {"oaTechModTypeEnum",(PyCFunction)PyoaTechModTypeEnum_TypeFunction,METH_VARARGS,oaTechModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaTechModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacSetDBUPerUUTechModType");
    PyDict_SetItemString(mod_dict,"oacSetDBUPerUUTechModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetUserUnitsTechModType");
    PyDict_SetItemString(mod_dict,"oacSetUserUnitsTechModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetClearanceMeasureTechModType");
    PyDict_SetItemString(mod_dict,"oacSetClearanceMeasureTechModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetDefaultManufacturingGridTechModType");
    PyDict_SetItemString(mod_dict,"oacSetDefaultManufacturingGridTechModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetDefaultConstraintGroupTechModType");
    PyDict_SetItemString(mod_dict,"oacSetDefaultConstraintGroupTechModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetFoundryConstraintGroupTechModType");
    PyDict_SetItemString(mod_dict,"oacSetFoundryConstraintGroupTechModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetRefsTechModType");
    PyDict_SetItemString(mod_dict,"oacSetRefsTechModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetGateGroundedTechModType");
    PyDict_SetItemString(mod_dict,"oacSetGateGroundedTechModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacUnsetDBUPerUUTechModType");
    PyDict_SetItemString(mod_dict,"oacUnsetDBUPerUUTechModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacUnsetUserUnitsTechModType");
    PyDict_SetItemString(mod_dict,"oacUnsetUserUnitsTechModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacUnsetClearanceMeasureTechModType");
    PyDict_SetItemString(mod_dict,"oacUnsetClearanceMeasureTechModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacUnsetDefaultManufacturingGridTechModType");
    PyDict_SetItemString(mod_dict,"oacUnsetDefaultManufacturingGridTechModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacUnsetGateGroundedTechModType");
    PyDict_SetItemString(mod_dict,"oacUnsetGateGroundedTechModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacUnsetRefsTechModType");
    PyDict_SetItemString(mod_dict,"oacUnsetRefsTechModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaTechModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaTechModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaTechModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaTechMsgIds
// ==================================================================

// ------------------------------------------------------------------

int
PyoaTechMsgIds_Convert(PyObject* ob,PyParamoaTechMsgIds* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacInvalidTech")==0) { result->SetData(oacInvalidTech); return 1;}
        if (strcasecmp(str,"oacNotATech")==0) { result->SetData(oacNotATech); return 1;}
        if (strcasecmp(str,"oacTechLibNotFound")==0) { result->SetData(oacTechLibNotFound); return 1;}
        if (strcasecmp(str,"oacSaveReadOnlyTech")==0) { result->SetData(oacSaveReadOnlyTech); return 1;}
        if (strcasecmp(str,"oacTechAlreadyExists")==0) { result->SetData(oacTechAlreadyExists); return 1;}
        if (strcasecmp(str,"oacOpenOnTechBeingPurged")==0) { result->SetData(oacOpenOnTechBeingPurged); return 1;}
        if (strcasecmp(str,"oacCannotFindLibraryTech")==0) { result->SetData(oacCannotFindLibraryTech); return 1;}
        if (strcasecmp(str,"oacInvalidUserUnitsTypeName")==0) { result->SetData(oacInvalidUserUnitsTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidClearanceMeasureTypeName")==0) { result->SetData(oacInvalidClearanceMeasureTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidDBUPerUU")==0) { result->SetData(oacInvalidDBUPerUU); return 1;}
        if (strcasecmp(str,"oacInvalidTechViewType")==0) { result->SetData(oacInvalidTechViewType); return 1;}
        if (strcasecmp(str,"oacCannotLockTech")==0) { result->SetData(oacCannotLockTech); return 1;}
        if (strcasecmp(str,"oacInvalidLayer")==0) { result->SetData(oacInvalidLayer); return 1;}
        if (strcasecmp(str,"oacLayerNumberExists")==0) { result->SetData(oacLayerNumberExists); return 1;}
        if (strcasecmp(str,"oacLayerNameExists")==0) { result->SetData(oacLayerNameExists); return 1;}
        if (strcasecmp(str,"oacLayerDerivationExists")==0) { result->SetData(oacLayerDerivationExists); return 1;}
        if (strcasecmp(str,"oacLayer1Layer2NotInSameTech")==0) { result->SetData(oacLayer1Layer2NotInSameTech); return 1;}
        if (strcasecmp(str,"oacInvalidMaterialName")==0) { result->SetData(oacInvalidMaterialName); return 1;}
        if (strcasecmp(str,"oacInvalidPrefRoutingDirName")==0) { result->SetData(oacInvalidPrefRoutingDirName); return 1;}
        if (strcasecmp(str,"oacInvalidLayerOpName")==0) { result->SetData(oacInvalidLayerOpName); return 1;}
        if (strcasecmp(str,"oacInvalidSizeOpName")==0) { result->SetData(oacInvalidSizeOpName); return 1;}
        if (strcasecmp(str,"oacSizedLayerExists")==0) { result->SetData(oacSizedLayerExists); return 1;}
        if (strcasecmp(str,"oacInvalidPurpose")==0) { result->SetData(oacInvalidPurpose); return 1;}
        if (strcasecmp(str,"oacPurposeNumberExists")==0) { result->SetData(oacPurposeNumberExists); return 1;}
        if (strcasecmp(str,"oacPurposeNameExists")==0) { result->SetData(oacPurposeNameExists); return 1;}
        if (strcasecmp(str,"oacInvalidPurposeTypeName")==0) { result->SetData(oacInvalidPurposeTypeName); return 1;}
        if (strcasecmp(str,"oacCannotChangeReservedPurpose")==0) { result->SetData(oacCannotChangeReservedPurpose); return 1;}
        if (strcasecmp(str,"oacCannotDestroyReservedPurpose")==0) { result->SetData(oacCannotDestroyReservedPurpose); return 1;}
        if (strcasecmp(str,"oacInvalidViaSpec")==0) { result->SetData(oacInvalidViaSpec); return 1;}
        if (strcasecmp(str,"oacViaSpecExists")==0) { result->SetData(oacViaSpecExists); return 1;}
        if (strcasecmp(str,"oacViaSpecAndViaDefNotInSameTech")==0) { result->SetData(oacViaSpecAndViaDefNotInSameTech); return 1;}
        if (strcasecmp(str,"oacInvalidViaDef")==0) { result->SetData(oacInvalidViaDef); return 1;}
        if (strcasecmp(str,"oacViaDefExists")==0) { result->SetData(oacViaDefExists); return 1;}
        if (strcasecmp(str,"oacInvalidSiteDef")==0) { result->SetData(oacInvalidSiteDef); return 1;}
        if (strcasecmp(str,"oacSiteDefExists")==0) { result->SetData(oacSiteDefExists); return 1;}
        if (strcasecmp(str,"oacSiteDefNotFound")==0) { result->SetData(oacSiteDefNotFound); return 1;}
        if (strcasecmp(str,"oacInvalidSiteDefTypeName")==0) { result->SetData(oacInvalidSiteDefTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidOpPoint")==0) { result->SetData(oacInvalidOpPoint); return 1;}
        if (strcasecmp(str,"oacOpPointNameExists")==0) { result->SetData(oacOpPointNameExists); return 1;}
        if (strcasecmp(str,"oacInvalidAnalysisLib")==0) { result->SetData(oacInvalidAnalysisLib); return 1;}
        if (strcasecmp(str,"oacAnalysisLibNameExists")==0) { result->SetData(oacAnalysisLibNameExists); return 1;}
        if (strcasecmp(str,"oacInvalidTechDataTypeName")==0) { result->SetData(oacInvalidTechDataTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidViaParamRowNumber")==0) { result->SetData(oacInvalidViaParamRowNumber); return 1;}
        if (strcasecmp(str,"oacInvalidViaParamColumnNumber")==0) { result->SetData(oacInvalidViaParamColumnNumber); return 1;}
        if (strcasecmp(str,"oacZeroColumnsSpecifiedForViaParam")==0) { result->SetData(oacZeroColumnsSpecifiedForViaParam); return 1;}
        if (strcasecmp(str,"oacZeroRowsSpecifiedForViaParam")==0) { result->SetData(oacZeroRowsSpecifiedForViaParam); return 1;}
        if (strcasecmp(str,"oacInvalidAntennaModelName")==0) { result->SetData(oacInvalidAntennaModelName); return 1;}
        if (strcasecmp(str,"oacAntennaRatioValueNotInSameTech")==0) { result->SetData(oacAntennaRatioValueNotInSameTech); return 1;}
        if (strcasecmp(str,"oacInvalidACCurrentDensityValue")==0) { result->SetData(oacInvalidACCurrentDensityValue); return 1;}
        if (strcasecmp(str,"oacInvalidDCCurrentDensityValue")==0) { result->SetData(oacInvalidDCCurrentDensityValue); return 1;}
        if (strcasecmp(str,"oacViaDef2DTblViaDefNotInSameTech")==0) { result->SetData(oacViaDef2DTblViaDefNotInSameTech); return 1;}
        if (strcasecmp(str,"oacTechCannotObtainReadAccess")==0) { result->SetData(oacTechCannotObtainReadAccess); return 1;}
        if (strcasecmp(str,"oacTechCannotObtainWriteAccess")==0) { result->SetData(oacTechCannotObtainWriteAccess); return 1;}
        if (strcasecmp(str,"oacTechHasReadNeedWriteAccess")==0) { result->SetData(oacTechHasReadNeedWriteAccess); return 1;}
        if (strcasecmp(str,"oacInvalidTechObject")==0) { result->SetData(oacInvalidTechObject); return 1;}
        if (strcasecmp(str,"oacTechAttachedTechLibDetected")==0) { result->SetData(oacTechAttachedTechLibDetected); return 1;}
        if (strcasecmp(str,"oacCannotFindInheritedTechLib")==0) { result->SetData(oacCannotFindInheritedTechLib); return 1;}
        if (strcasecmp(str,"oacTechFileDoesNotExist")==0) { result->SetData(oacTechFileDoesNotExist); return 1;}
        if (strcasecmp(str,"oacInvalidViaParamTypeName")==0) { result->SetData(oacInvalidViaParamTypeName); return 1;}
        if (strcasecmp(str,"oacDestroyTechOpen")==0) { result->SetData(oacDestroyTechOpen); return 1;}
        if (strcasecmp(str,"oacZeroViaCutDimensions")==0) { result->SetData(oacZeroViaCutDimensions); return 1;}
        if (strcasecmp(str,"oacInvalidViaCutLayerNum")==0) { result->SetData(oacInvalidViaCutLayerNum); return 1;}
        if (strcasecmp(str,"oacViaParamCutColsNumNotSet")==0) { result->SetData(oacViaParamCutColsNumNotSet); return 1;}
        if (strcasecmp(str,"oacViaParamCutRowsNumNotSet")==0) { result->SetData(oacViaParamCutRowsNumNotSet); return 1;}
        if (strcasecmp(str,"oacObsoleteTechMsg2064")==0) { result->SetData(oacObsoleteTechMsg2064); return 1;}
        if (strcasecmp(str,"oacTechCannotSetDuplicateRefs")==0) { result->SetData(oacTechCannotSetDuplicateRefs); return 1;}
        if (strcasecmp(str,"oacTechSetRefsConflicts")==0) { result->SetData(oacTechSetRefsConflicts); return 1;}
        if (strcasecmp(str,"oacTechSetRefsCannotOpenAllRefGraphs")==0) { result->SetData(oacTechSetRefsCannotOpenAllRefGraphs); return 1;}
        if (strcasecmp(str,"oacInvalidDerivedLayerParamTypeName")==0) { result->SetData(oacInvalidDerivedLayerParamTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidDerivedLayerConnectivityTypeName")==0) { result->SetData(oacInvalidDerivedLayerConnectivityTypeName); return 1;}
        if (strcasecmp(str,"oacReservedTechConstraintGroupName")==0) { result->SetData(oacReservedTechConstraintGroupName); return 1;}
        if (strcasecmp(str,"oacConstraintGroupNotInRefTech")==0) { result->SetData(oacConstraintGroupNotInRefTech); return 1;}
        if (strcasecmp(str,"oacConstraintGroupNotTechConstraintGroup")==0) { result->SetData(oacConstraintGroupNotTechConstraintGroup); return 1;}
        if (strcasecmp(str,"oacInvalidBuiltInTechConstraintGroupInTech")==0) { result->SetData(oacInvalidBuiltInTechConstraintGroupInTech); return 1;}
        if (strcasecmp(str,"oacInvalidTechHeader")==0) { result->SetData(oacInvalidTechHeader); return 1;}
        if (strcasecmp(str,"oacInvalidDerivedLayerParam")==0) { result->SetData(oacInvalidDerivedLayerParam); return 1;}
        if (strcasecmp(str,"oacDerivedLayerParamAlreadyOwned")==0) { result->SetData(oacDerivedLayerParamAlreadyOwned); return 1;}
        if (strcasecmp(str,"oacCantDestroyOwnedDerivedLayerParam")==0) { result->SetData(oacCantDestroyOwnedDerivedLayerParam); return 1;}
        if (strcasecmp(str,"oacInvalidObjForDerivedLayerParam")==0) { result->SetData(oacInvalidObjForDerivedLayerParam); return 1;}
        if (strcasecmp(str,"oacDerivedLayerParamNotInSameDB")==0) { result->SetData(oacDerivedLayerParamNotInSameDB); return 1;}
        if (strcasecmp(str,"oacInvalidDerivedLayerParamDef")==0) { result->SetData(oacInvalidDerivedLayerParamDef); return 1;}
        if (strcasecmp(str,"oacDerivedLayerParamDefExists")==0) { result->SetData(oacDerivedLayerParamDefExists); return 1;}
        if (strcasecmp(str,"oacDerivedLayerParamDefHasReference")==0) { result->SetData(oacDerivedLayerParamDefHasReference); return 1;}
        if (strcasecmp(str,"oacValueInvalidForDerivedLayerParamDef")==0) { result->SetData(oacValueInvalidForDerivedLayerParamDef); return 1;}
        if (strcasecmp(str,"oacInvalidDerivedLayerDef")==0) { result->SetData(oacInvalidDerivedLayerDef); return 1;}
        if (strcasecmp(str,"oacDerivedLayerDefExists")==0) { result->SetData(oacDerivedLayerDefExists); return 1;}
        if (strcasecmp(str,"oacDerivedLayerDefHasReference")==0) { result->SetData(oacDerivedLayerDefHasReference); return 1;}
        if (strcasecmp(str,"oacInvalidNumLayersForDerivedLayerDef")==0) { result->SetData(oacInvalidNumLayersForDerivedLayerDef); return 1;}
        if (strcasecmp(str,"oacInvalidValueForDerivedLayerDef")==0) { result->SetData(oacInvalidValueForDerivedLayerDef); return 1;}
        if (strcasecmp(str,"oacInvalidDBForDerivedLayerDef")==0) { result->SetData(oacInvalidDBForDerivedLayerDef); return 1;}
        if (strcasecmp(str,"oacLayerNotInReferencedTech")==0) { result->SetData(oacLayerNotInReferencedTech); return 1;}
        if (strcasecmp(str,"oacViaDefNotInReferencedTech")==0) { result->SetData(oacViaDefNotInReferencedTech); return 1;}
        if (strcasecmp(str,"oacInvalidTechLayerHeader")==0) { result->SetData(oacInvalidTechLayerHeader); return 1;}
        if (strcasecmp(str,"oacInvalidTechViaDefHeader")==0) { result->SetData(oacInvalidTechViaDefHeader); return 1;}
        if (strcasecmp(str,"oacCloseOnTechBeingPurged")==0) { result->SetData(oacCloseOnTechBeingPurged); return 1;}
        if (strcasecmp(str,"oacPurgeOnTechBeingPurged")==0) { result->SetData(oacPurgeOnTechBeingPurged); return 1;}
        if (strcasecmp(str,"oacConflictingLayerNamesInTech")==0) { result->SetData(oacConflictingLayerNamesInTech); return 1;}
        if (strcasecmp(str,"oacConflictingLayerNumbersInTech")==0) { result->SetData(oacConflictingLayerNumbersInTech); return 1;}
        if (strcasecmp(str,"oacConflictingViaDefNamesInTech")==0) { result->SetData(oacConflictingViaDefNamesInTech); return 1;}
        if (strcasecmp(str,"oacConflictingClearanceMeasureInTech")==0) { result->SetData(oacConflictingClearanceMeasureInTech); return 1;}
        if (strcasecmp(str,"oacConflictingDefaultManufacturingGridInTech")==0) { result->SetData(oacConflictingDefaultManufacturingGridInTech); return 1;}
        if (strcasecmp(str,"oacConflictingGateGroundedInTech")==0) { result->SetData(oacConflictingGateGroundedInTech); return 1;}
        if (strcasecmp(str,"oacConflictingDBUPerUUInTech")==0) { result->SetData(oacConflictingDBUPerUUInTech); return 1;}
        if (strcasecmp(str,"oacConflictingUserUnitsInTech")==0) { result->SetData(oacConflictingUserUnitsInTech); return 1;}
        if (strcasecmp(str,"oacAttachLibraryHasLocalTech")==0) { result->SetData(oacAttachLibraryHasLocalTech); return 1;}
        if (strcasecmp(str,"oacDetachNoAttachment")==0) { result->SetData(oacDetachNoAttachment); return 1;}
        if (strcasecmp(str,"oacGetAttachmentNoAttachment")==0) { result->SetData(oacGetAttachmentNoAttachment); return 1;}
        if (strcasecmp(str,"oacUnsetClearanceMeasureNotSet")==0) { result->SetData(oacUnsetClearanceMeasureNotSet); return 1;}
        if (strcasecmp(str,"oacUnsetDefaultManufacturingGridNotSet")==0) { result->SetData(oacUnsetDefaultManufacturingGridNotSet); return 1;}
        if (strcasecmp(str,"oacUnsetGateGroundedNotSet")==0) { result->SetData(oacUnsetGateGroundedNotSet); return 1;}
        if (strcasecmp(str,"oacUnsetDBUPerUUNotSet")==0) { result->SetData(oacUnsetDBUPerUUNotSet); return 1;}
        if (strcasecmp(str,"oacUnsetUserUnitsNotSet")==0) { result->SetData(oacUnsetUserUnitsNotSet); return 1;}
        if (strcasecmp(str,"oacDestroyWithAttachProperty")==0) { result->SetData(oacDestroyWithAttachProperty); return 1;}
        if (strcasecmp(str,"oacTechSetRefsCircularReference")==0) { result->SetData(oacTechSetRefsCircularReference); return 1;}
        if (strcasecmp(str,"oacStdViaDefDoesNotHaveImplant1")==0) { result->SetData(oacStdViaDefDoesNotHaveImplant1); return 1;}
        if (strcasecmp(str,"oacStdViaDefDoesNotHaveImplant2")==0) { result->SetData(oacStdViaDefDoesNotHaveImplant2); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaTechMsgIds)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaTechMsgIds Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaTechMsgIds_FromoaTechMsgIds(oaTechMsgIds ob)
{
    if (ob==oacInvalidTech) return PyString_FromString("oacInvalidTech");
    if (ob==oacNotATech) return PyString_FromString("oacNotATech");
    if (ob==oacTechLibNotFound) return PyString_FromString("oacTechLibNotFound");
    if (ob==oacSaveReadOnlyTech) return PyString_FromString("oacSaveReadOnlyTech");
    if (ob==oacTechAlreadyExists) return PyString_FromString("oacTechAlreadyExists");
    if (ob==oacOpenOnTechBeingPurged) return PyString_FromString("oacOpenOnTechBeingPurged");
    if (ob==oacCannotFindLibraryTech) return PyString_FromString("oacCannotFindLibraryTech");
    if (ob==oacInvalidUserUnitsTypeName) return PyString_FromString("oacInvalidUserUnitsTypeName");
    if (ob==oacInvalidClearanceMeasureTypeName) return PyString_FromString("oacInvalidClearanceMeasureTypeName");
    if (ob==oacInvalidDBUPerUU) return PyString_FromString("oacInvalidDBUPerUU");
    if (ob==oacInvalidTechViewType) return PyString_FromString("oacInvalidTechViewType");
    if (ob==oacCannotLockTech) return PyString_FromString("oacCannotLockTech");
    if (ob==oacInvalidLayer) return PyString_FromString("oacInvalidLayer");
    if (ob==oacLayerNumberExists) return PyString_FromString("oacLayerNumberExists");
    if (ob==oacLayerNameExists) return PyString_FromString("oacLayerNameExists");
    if (ob==oacLayerDerivationExists) return PyString_FromString("oacLayerDerivationExists");
    if (ob==oacLayer1Layer2NotInSameTech) return PyString_FromString("oacLayer1Layer2NotInSameTech");
    if (ob==oacInvalidMaterialName) return PyString_FromString("oacInvalidMaterialName");
    if (ob==oacInvalidPrefRoutingDirName) return PyString_FromString("oacInvalidPrefRoutingDirName");
    if (ob==oacInvalidLayerOpName) return PyString_FromString("oacInvalidLayerOpName");
    if (ob==oacInvalidSizeOpName) return PyString_FromString("oacInvalidSizeOpName");
    if (ob==oacSizedLayerExists) return PyString_FromString("oacSizedLayerExists");
    if (ob==oacInvalidPurpose) return PyString_FromString("oacInvalidPurpose");
    if (ob==oacPurposeNumberExists) return PyString_FromString("oacPurposeNumberExists");
    if (ob==oacPurposeNameExists) return PyString_FromString("oacPurposeNameExists");
    if (ob==oacInvalidPurposeTypeName) return PyString_FromString("oacInvalidPurposeTypeName");
    if (ob==oacCannotChangeReservedPurpose) return PyString_FromString("oacCannotChangeReservedPurpose");
    if (ob==oacCannotDestroyReservedPurpose) return PyString_FromString("oacCannotDestroyReservedPurpose");
    if (ob==oacInvalidViaSpec) return PyString_FromString("oacInvalidViaSpec");
    if (ob==oacViaSpecExists) return PyString_FromString("oacViaSpecExists");
    if (ob==oacViaSpecAndViaDefNotInSameTech) return PyString_FromString("oacViaSpecAndViaDefNotInSameTech");
    if (ob==oacInvalidViaDef) return PyString_FromString("oacInvalidViaDef");
    if (ob==oacViaDefExists) return PyString_FromString("oacViaDefExists");
    if (ob==oacInvalidSiteDef) return PyString_FromString("oacInvalidSiteDef");
    if (ob==oacSiteDefExists) return PyString_FromString("oacSiteDefExists");
    if (ob==oacSiteDefNotFound) return PyString_FromString("oacSiteDefNotFound");
    if (ob==oacInvalidSiteDefTypeName) return PyString_FromString("oacInvalidSiteDefTypeName");
    if (ob==oacInvalidOpPoint) return PyString_FromString("oacInvalidOpPoint");
    if (ob==oacOpPointNameExists) return PyString_FromString("oacOpPointNameExists");
    if (ob==oacInvalidAnalysisLib) return PyString_FromString("oacInvalidAnalysisLib");
    if (ob==oacAnalysisLibNameExists) return PyString_FromString("oacAnalysisLibNameExists");
    if (ob==oacInvalidTechDataTypeName) return PyString_FromString("oacInvalidTechDataTypeName");
    if (ob==oacInvalidViaParamRowNumber) return PyString_FromString("oacInvalidViaParamRowNumber");
    if (ob==oacInvalidViaParamColumnNumber) return PyString_FromString("oacInvalidViaParamColumnNumber");
    if (ob==oacZeroColumnsSpecifiedForViaParam) return PyString_FromString("oacZeroColumnsSpecifiedForViaParam");
    if (ob==oacZeroRowsSpecifiedForViaParam) return PyString_FromString("oacZeroRowsSpecifiedForViaParam");
    if (ob==oacInvalidAntennaModelName) return PyString_FromString("oacInvalidAntennaModelName");
    if (ob==oacAntennaRatioValueNotInSameTech) return PyString_FromString("oacAntennaRatioValueNotInSameTech");
    if (ob==oacInvalidACCurrentDensityValue) return PyString_FromString("oacInvalidACCurrentDensityValue");
    if (ob==oacInvalidDCCurrentDensityValue) return PyString_FromString("oacInvalidDCCurrentDensityValue");
    if (ob==oacViaDef2DTblViaDefNotInSameTech) return PyString_FromString("oacViaDef2DTblViaDefNotInSameTech");
    if (ob==oacTechCannotObtainReadAccess) return PyString_FromString("oacTechCannotObtainReadAccess");
    if (ob==oacTechCannotObtainWriteAccess) return PyString_FromString("oacTechCannotObtainWriteAccess");
    if (ob==oacTechHasReadNeedWriteAccess) return PyString_FromString("oacTechHasReadNeedWriteAccess");
    if (ob==oacInvalidTechObject) return PyString_FromString("oacInvalidTechObject");
    if (ob==oacTechAttachedTechLibDetected) return PyString_FromString("oacTechAttachedTechLibDetected");
    if (ob==oacCannotFindInheritedTechLib) return PyString_FromString("oacCannotFindInheritedTechLib");
    if (ob==oacTechFileDoesNotExist) return PyString_FromString("oacTechFileDoesNotExist");
    if (ob==oacInvalidViaParamTypeName) return PyString_FromString("oacInvalidViaParamTypeName");
    if (ob==oacDestroyTechOpen) return PyString_FromString("oacDestroyTechOpen");
    if (ob==oacZeroViaCutDimensions) return PyString_FromString("oacZeroViaCutDimensions");
    if (ob==oacInvalidViaCutLayerNum) return PyString_FromString("oacInvalidViaCutLayerNum");
    if (ob==oacViaParamCutColsNumNotSet) return PyString_FromString("oacViaParamCutColsNumNotSet");
    if (ob==oacViaParamCutRowsNumNotSet) return PyString_FromString("oacViaParamCutRowsNumNotSet");
    if (ob==oacObsoleteTechMsg2064) return PyString_FromString("oacObsoleteTechMsg2064");
    if (ob==oacTechCannotSetDuplicateRefs) return PyString_FromString("oacTechCannotSetDuplicateRefs");
    if (ob==oacTechSetRefsConflicts) return PyString_FromString("oacTechSetRefsConflicts");
    if (ob==oacTechSetRefsCannotOpenAllRefGraphs) return PyString_FromString("oacTechSetRefsCannotOpenAllRefGraphs");
    if (ob==oacInvalidDerivedLayerParamTypeName) return PyString_FromString("oacInvalidDerivedLayerParamTypeName");
    if (ob==oacInvalidDerivedLayerConnectivityTypeName) return PyString_FromString("oacInvalidDerivedLayerConnectivityTypeName");
    if (ob==oacReservedTechConstraintGroupName) return PyString_FromString("oacReservedTechConstraintGroupName");
    if (ob==oacConstraintGroupNotInRefTech) return PyString_FromString("oacConstraintGroupNotInRefTech");
    if (ob==oacConstraintGroupNotTechConstraintGroup) return PyString_FromString("oacConstraintGroupNotTechConstraintGroup");
    if (ob==oacInvalidBuiltInTechConstraintGroupInTech) return PyString_FromString("oacInvalidBuiltInTechConstraintGroupInTech");
    if (ob==oacInvalidTechHeader) return PyString_FromString("oacInvalidTechHeader");
    if (ob==oacInvalidDerivedLayerParam) return PyString_FromString("oacInvalidDerivedLayerParam");
    if (ob==oacDerivedLayerParamAlreadyOwned) return PyString_FromString("oacDerivedLayerParamAlreadyOwned");
    if (ob==oacCantDestroyOwnedDerivedLayerParam) return PyString_FromString("oacCantDestroyOwnedDerivedLayerParam");
    if (ob==oacInvalidObjForDerivedLayerParam) return PyString_FromString("oacInvalidObjForDerivedLayerParam");
    if (ob==oacDerivedLayerParamNotInSameDB) return PyString_FromString("oacDerivedLayerParamNotInSameDB");
    if (ob==oacInvalidDerivedLayerParamDef) return PyString_FromString("oacInvalidDerivedLayerParamDef");
    if (ob==oacDerivedLayerParamDefExists) return PyString_FromString("oacDerivedLayerParamDefExists");
    if (ob==oacDerivedLayerParamDefHasReference) return PyString_FromString("oacDerivedLayerParamDefHasReference");
    if (ob==oacValueInvalidForDerivedLayerParamDef) return PyString_FromString("oacValueInvalidForDerivedLayerParamDef");
    if (ob==oacInvalidDerivedLayerDef) return PyString_FromString("oacInvalidDerivedLayerDef");
    if (ob==oacDerivedLayerDefExists) return PyString_FromString("oacDerivedLayerDefExists");
    if (ob==oacDerivedLayerDefHasReference) return PyString_FromString("oacDerivedLayerDefHasReference");
    if (ob==oacInvalidNumLayersForDerivedLayerDef) return PyString_FromString("oacInvalidNumLayersForDerivedLayerDef");
    if (ob==oacInvalidValueForDerivedLayerDef) return PyString_FromString("oacInvalidValueForDerivedLayerDef");
    if (ob==oacInvalidDBForDerivedLayerDef) return PyString_FromString("oacInvalidDBForDerivedLayerDef");
    if (ob==oacLayerNotInReferencedTech) return PyString_FromString("oacLayerNotInReferencedTech");
    if (ob==oacViaDefNotInReferencedTech) return PyString_FromString("oacViaDefNotInReferencedTech");
    if (ob==oacInvalidTechLayerHeader) return PyString_FromString("oacInvalidTechLayerHeader");
    if (ob==oacInvalidTechViaDefHeader) return PyString_FromString("oacInvalidTechViaDefHeader");
    if (ob==oacCloseOnTechBeingPurged) return PyString_FromString("oacCloseOnTechBeingPurged");
    if (ob==oacPurgeOnTechBeingPurged) return PyString_FromString("oacPurgeOnTechBeingPurged");
    if (ob==oacConflictingLayerNamesInTech) return PyString_FromString("oacConflictingLayerNamesInTech");
    if (ob==oacConflictingLayerNumbersInTech) return PyString_FromString("oacConflictingLayerNumbersInTech");
    if (ob==oacConflictingViaDefNamesInTech) return PyString_FromString("oacConflictingViaDefNamesInTech");
    if (ob==oacConflictingClearanceMeasureInTech) return PyString_FromString("oacConflictingClearanceMeasureInTech");
    if (ob==oacConflictingDefaultManufacturingGridInTech) return PyString_FromString("oacConflictingDefaultManufacturingGridInTech");
    if (ob==oacConflictingGateGroundedInTech) return PyString_FromString("oacConflictingGateGroundedInTech");
    if (ob==oacConflictingDBUPerUUInTech) return PyString_FromString("oacConflictingDBUPerUUInTech");
    if (ob==oacConflictingUserUnitsInTech) return PyString_FromString("oacConflictingUserUnitsInTech");
    if (ob==oacAttachLibraryHasLocalTech) return PyString_FromString("oacAttachLibraryHasLocalTech");
    if (ob==oacDetachNoAttachment) return PyString_FromString("oacDetachNoAttachment");
    if (ob==oacGetAttachmentNoAttachment) return PyString_FromString("oacGetAttachmentNoAttachment");
    if (ob==oacUnsetClearanceMeasureNotSet) return PyString_FromString("oacUnsetClearanceMeasureNotSet");
    if (ob==oacUnsetDefaultManufacturingGridNotSet) return PyString_FromString("oacUnsetDefaultManufacturingGridNotSet");
    if (ob==oacUnsetGateGroundedNotSet) return PyString_FromString("oacUnsetGateGroundedNotSet");
    if (ob==oacUnsetDBUPerUUNotSet) return PyString_FromString("oacUnsetDBUPerUUNotSet");
    if (ob==oacUnsetUserUnitsNotSet) return PyString_FromString("oacUnsetUserUnitsNotSet");
    if (ob==oacDestroyWithAttachProperty) return PyString_FromString("oacDestroyWithAttachProperty");
    if (ob==oacTechSetRefsCircularReference) return PyString_FromString("oacTechSetRefsCircularReference");
    if (ob==oacStdViaDefDoesNotHaveImplant1) return PyString_FromString("oacStdViaDefDoesNotHaveImplant1");
    if (ob==oacStdViaDefDoesNotHaveImplant2) return PyString_FromString("oacStdViaDefDoesNotHaveImplant2");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaTechMsgIds_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaTechMsgIds e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaTechMsgIds_FromoaTechMsgIds(oaTechMsgIds(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaTechMsgIds_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaTechMsgIds_doc[] =
"Type convert function for enum: oaTechMsgIds";
                               
static PyMethodDef PyoaTechMsgIds_method =
  {"oaTechMsgIds",(PyCFunction)PyoaTechMsgIds_TypeFunction,METH_VARARGS,oaTechMsgIds_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaTechMsgIds_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacInvalidTech");
    PyDict_SetItemString(mod_dict,"oacInvalidTech",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNotATech");
    PyDict_SetItemString(mod_dict,"oacNotATech",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechLibNotFound");
    PyDict_SetItemString(mod_dict,"oacTechLibNotFound",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSaveReadOnlyTech");
    PyDict_SetItemString(mod_dict,"oacSaveReadOnlyTech",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechAlreadyExists");
    PyDict_SetItemString(mod_dict,"oacTechAlreadyExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOpenOnTechBeingPurged");
    PyDict_SetItemString(mod_dict,"oacOpenOnTechBeingPurged",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotFindLibraryTech");
    PyDict_SetItemString(mod_dict,"oacCannotFindLibraryTech",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidUserUnitsTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidUserUnitsTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidClearanceMeasureTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidClearanceMeasureTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDBUPerUU");
    PyDict_SetItemString(mod_dict,"oacInvalidDBUPerUU",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidTechViewType");
    PyDict_SetItemString(mod_dict,"oacInvalidTechViewType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotLockTech");
    PyDict_SetItemString(mod_dict,"oacCannotLockTech",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidLayer");
    PyDict_SetItemString(mod_dict,"oacInvalidLayer",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLayerNumberExists");
    PyDict_SetItemString(mod_dict,"oacLayerNumberExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLayerNameExists");
    PyDict_SetItemString(mod_dict,"oacLayerNameExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLayerDerivationExists");
    PyDict_SetItemString(mod_dict,"oacLayerDerivationExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLayer1Layer2NotInSameTech");
    PyDict_SetItemString(mod_dict,"oacLayer1Layer2NotInSameTech",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidMaterialName");
    PyDict_SetItemString(mod_dict,"oacInvalidMaterialName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidPrefRoutingDirName");
    PyDict_SetItemString(mod_dict,"oacInvalidPrefRoutingDirName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidLayerOpName");
    PyDict_SetItemString(mod_dict,"oacInvalidLayerOpName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidSizeOpName");
    PyDict_SetItemString(mod_dict,"oacInvalidSizeOpName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSizedLayerExists");
    PyDict_SetItemString(mod_dict,"oacSizedLayerExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidPurpose");
    PyDict_SetItemString(mod_dict,"oacInvalidPurpose",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPurposeNumberExists");
    PyDict_SetItemString(mod_dict,"oacPurposeNumberExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPurposeNameExists");
    PyDict_SetItemString(mod_dict,"oacPurposeNameExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidPurposeTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidPurposeTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotChangeReservedPurpose");
    PyDict_SetItemString(mod_dict,"oacCannotChangeReservedPurpose",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotDestroyReservedPurpose");
    PyDict_SetItemString(mod_dict,"oacCannotDestroyReservedPurpose",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidViaSpec");
    PyDict_SetItemString(mod_dict,"oacInvalidViaSpec",value);
    Py_DECREF(value);
    value=PyString_FromString("oacViaSpecExists");
    PyDict_SetItemString(mod_dict,"oacViaSpecExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacViaSpecAndViaDefNotInSameTech");
    PyDict_SetItemString(mod_dict,"oacViaSpecAndViaDefNotInSameTech",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidViaDef");
    PyDict_SetItemString(mod_dict,"oacInvalidViaDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacViaDefExists");
    PyDict_SetItemString(mod_dict,"oacViaDefExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidSiteDef");
    PyDict_SetItemString(mod_dict,"oacInvalidSiteDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSiteDefExists");
    PyDict_SetItemString(mod_dict,"oacSiteDefExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSiteDefNotFound");
    PyDict_SetItemString(mod_dict,"oacSiteDefNotFound",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidSiteDefTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidSiteDefTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidOpPoint");
    PyDict_SetItemString(mod_dict,"oacInvalidOpPoint",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOpPointNameExists");
    PyDict_SetItemString(mod_dict,"oacOpPointNameExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidAnalysisLib");
    PyDict_SetItemString(mod_dict,"oacInvalidAnalysisLib",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAnalysisLibNameExists");
    PyDict_SetItemString(mod_dict,"oacAnalysisLibNameExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidTechDataTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidTechDataTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidViaParamRowNumber");
    PyDict_SetItemString(mod_dict,"oacInvalidViaParamRowNumber",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidViaParamColumnNumber");
    PyDict_SetItemString(mod_dict,"oacInvalidViaParamColumnNumber",value);
    Py_DECREF(value);
    value=PyString_FromString("oacZeroColumnsSpecifiedForViaParam");
    PyDict_SetItemString(mod_dict,"oacZeroColumnsSpecifiedForViaParam",value);
    Py_DECREF(value);
    value=PyString_FromString("oacZeroRowsSpecifiedForViaParam");
    PyDict_SetItemString(mod_dict,"oacZeroRowsSpecifiedForViaParam",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidAntennaModelName");
    PyDict_SetItemString(mod_dict,"oacInvalidAntennaModelName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAntennaRatioValueNotInSameTech");
    PyDict_SetItemString(mod_dict,"oacAntennaRatioValueNotInSameTech",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidACCurrentDensityValue");
    PyDict_SetItemString(mod_dict,"oacInvalidACCurrentDensityValue",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDCCurrentDensityValue");
    PyDict_SetItemString(mod_dict,"oacInvalidDCCurrentDensityValue",value);
    Py_DECREF(value);
    value=PyString_FromString("oacViaDef2DTblViaDefNotInSameTech");
    PyDict_SetItemString(mod_dict,"oacViaDef2DTblViaDefNotInSameTech",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechCannotObtainReadAccess");
    PyDict_SetItemString(mod_dict,"oacTechCannotObtainReadAccess",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechCannotObtainWriteAccess");
    PyDict_SetItemString(mod_dict,"oacTechCannotObtainWriteAccess",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechHasReadNeedWriteAccess");
    PyDict_SetItemString(mod_dict,"oacTechHasReadNeedWriteAccess",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidTechObject");
    PyDict_SetItemString(mod_dict,"oacInvalidTechObject",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechAttachedTechLibDetected");
    PyDict_SetItemString(mod_dict,"oacTechAttachedTechLibDetected",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotFindInheritedTechLib");
    PyDict_SetItemString(mod_dict,"oacCannotFindInheritedTechLib",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechFileDoesNotExist");
    PyDict_SetItemString(mod_dict,"oacTechFileDoesNotExist",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidViaParamTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidViaParamTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDestroyTechOpen");
    PyDict_SetItemString(mod_dict,"oacDestroyTechOpen",value);
    Py_DECREF(value);
    value=PyString_FromString("oacZeroViaCutDimensions");
    PyDict_SetItemString(mod_dict,"oacZeroViaCutDimensions",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidViaCutLayerNum");
    PyDict_SetItemString(mod_dict,"oacInvalidViaCutLayerNum",value);
    Py_DECREF(value);
    value=PyString_FromString("oacViaParamCutColsNumNotSet");
    PyDict_SetItemString(mod_dict,"oacViaParamCutColsNumNotSet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacViaParamCutRowsNumNotSet");
    PyDict_SetItemString(mod_dict,"oacViaParamCutRowsNumNotSet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacObsoleteTechMsg2064");
    PyDict_SetItemString(mod_dict,"oacObsoleteTechMsg2064",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechCannotSetDuplicateRefs");
    PyDict_SetItemString(mod_dict,"oacTechCannotSetDuplicateRefs",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechSetRefsConflicts");
    PyDict_SetItemString(mod_dict,"oacTechSetRefsConflicts",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechSetRefsCannotOpenAllRefGraphs");
    PyDict_SetItemString(mod_dict,"oacTechSetRefsCannotOpenAllRefGraphs",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDerivedLayerParamTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidDerivedLayerParamTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDerivedLayerConnectivityTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidDerivedLayerConnectivityTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacReservedTechConstraintGroupName");
    PyDict_SetItemString(mod_dict,"oacReservedTechConstraintGroupName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConstraintGroupNotInRefTech");
    PyDict_SetItemString(mod_dict,"oacConstraintGroupNotInRefTech",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConstraintGroupNotTechConstraintGroup");
    PyDict_SetItemString(mod_dict,"oacConstraintGroupNotTechConstraintGroup",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidBuiltInTechConstraintGroupInTech");
    PyDict_SetItemString(mod_dict,"oacInvalidBuiltInTechConstraintGroupInTech",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidTechHeader");
    PyDict_SetItemString(mod_dict,"oacInvalidTechHeader",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDerivedLayerParam");
    PyDict_SetItemString(mod_dict,"oacInvalidDerivedLayerParam",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDerivedLayerParamAlreadyOwned");
    PyDict_SetItemString(mod_dict,"oacDerivedLayerParamAlreadyOwned",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCantDestroyOwnedDerivedLayerParam");
    PyDict_SetItemString(mod_dict,"oacCantDestroyOwnedDerivedLayerParam",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidObjForDerivedLayerParam");
    PyDict_SetItemString(mod_dict,"oacInvalidObjForDerivedLayerParam",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDerivedLayerParamNotInSameDB");
    PyDict_SetItemString(mod_dict,"oacDerivedLayerParamNotInSameDB",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDerivedLayerParamDef");
    PyDict_SetItemString(mod_dict,"oacInvalidDerivedLayerParamDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDerivedLayerParamDefExists");
    PyDict_SetItemString(mod_dict,"oacDerivedLayerParamDefExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDerivedLayerParamDefHasReference");
    PyDict_SetItemString(mod_dict,"oacDerivedLayerParamDefHasReference",value);
    Py_DECREF(value);
    value=PyString_FromString("oacValueInvalidForDerivedLayerParamDef");
    PyDict_SetItemString(mod_dict,"oacValueInvalidForDerivedLayerParamDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDerivedLayerDef");
    PyDict_SetItemString(mod_dict,"oacInvalidDerivedLayerDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDerivedLayerDefExists");
    PyDict_SetItemString(mod_dict,"oacDerivedLayerDefExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDerivedLayerDefHasReference");
    PyDict_SetItemString(mod_dict,"oacDerivedLayerDefHasReference",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidNumLayersForDerivedLayerDef");
    PyDict_SetItemString(mod_dict,"oacInvalidNumLayersForDerivedLayerDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidValueForDerivedLayerDef");
    PyDict_SetItemString(mod_dict,"oacInvalidValueForDerivedLayerDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDBForDerivedLayerDef");
    PyDict_SetItemString(mod_dict,"oacInvalidDBForDerivedLayerDef",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLayerNotInReferencedTech");
    PyDict_SetItemString(mod_dict,"oacLayerNotInReferencedTech",value);
    Py_DECREF(value);
    value=PyString_FromString("oacViaDefNotInReferencedTech");
    PyDict_SetItemString(mod_dict,"oacViaDefNotInReferencedTech",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidTechLayerHeader");
    PyDict_SetItemString(mod_dict,"oacInvalidTechLayerHeader",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidTechViaDefHeader");
    PyDict_SetItemString(mod_dict,"oacInvalidTechViaDefHeader",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCloseOnTechBeingPurged");
    PyDict_SetItemString(mod_dict,"oacCloseOnTechBeingPurged",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPurgeOnTechBeingPurged");
    PyDict_SetItemString(mod_dict,"oacPurgeOnTechBeingPurged",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConflictingLayerNamesInTech");
    PyDict_SetItemString(mod_dict,"oacConflictingLayerNamesInTech",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConflictingLayerNumbersInTech");
    PyDict_SetItemString(mod_dict,"oacConflictingLayerNumbersInTech",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConflictingViaDefNamesInTech");
    PyDict_SetItemString(mod_dict,"oacConflictingViaDefNamesInTech",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConflictingClearanceMeasureInTech");
    PyDict_SetItemString(mod_dict,"oacConflictingClearanceMeasureInTech",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConflictingDefaultManufacturingGridInTech");
    PyDict_SetItemString(mod_dict,"oacConflictingDefaultManufacturingGridInTech",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConflictingGateGroundedInTech");
    PyDict_SetItemString(mod_dict,"oacConflictingGateGroundedInTech",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConflictingDBUPerUUInTech");
    PyDict_SetItemString(mod_dict,"oacConflictingDBUPerUUInTech",value);
    Py_DECREF(value);
    value=PyString_FromString("oacConflictingUserUnitsInTech");
    PyDict_SetItemString(mod_dict,"oacConflictingUserUnitsInTech",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAttachLibraryHasLocalTech");
    PyDict_SetItemString(mod_dict,"oacAttachLibraryHasLocalTech",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDetachNoAttachment");
    PyDict_SetItemString(mod_dict,"oacDetachNoAttachment",value);
    Py_DECREF(value);
    value=PyString_FromString("oacGetAttachmentNoAttachment");
    PyDict_SetItemString(mod_dict,"oacGetAttachmentNoAttachment",value);
    Py_DECREF(value);
    value=PyString_FromString("oacUnsetClearanceMeasureNotSet");
    PyDict_SetItemString(mod_dict,"oacUnsetClearanceMeasureNotSet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacUnsetDefaultManufacturingGridNotSet");
    PyDict_SetItemString(mod_dict,"oacUnsetDefaultManufacturingGridNotSet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacUnsetGateGroundedNotSet");
    PyDict_SetItemString(mod_dict,"oacUnsetGateGroundedNotSet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacUnsetDBUPerUUNotSet");
    PyDict_SetItemString(mod_dict,"oacUnsetDBUPerUUNotSet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacUnsetUserUnitsNotSet");
    PyDict_SetItemString(mod_dict,"oacUnsetUserUnitsNotSet",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDestroyWithAttachProperty");
    PyDict_SetItemString(mod_dict,"oacDestroyWithAttachProperty",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTechSetRefsCircularReference");
    PyDict_SetItemString(mod_dict,"oacTechSetRefsCircularReference",value);
    Py_DECREF(value);
    value=PyString_FromString("oacStdViaDefDoesNotHaveImplant1");
    PyDict_SetItemString(mod_dict,"oacStdViaDefDoesNotHaveImplant1",value);
    Py_DECREF(value);
    value=PyString_FromString("oacStdViaDefDoesNotHaveImplant2");
    PyDict_SetItemString(mod_dict,"oacStdViaDefDoesNotHaveImplant2",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaTechMsgIds_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaTechMsgIds",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaTechMsgIds\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}
