
/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccInstHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccInstHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccInstHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccInstHeaderObject* self = (PyoaOccInstHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccInstHeader)
    {
        PyParamoaOccInstHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccInstHeader_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccInstHeader, Choices are:\n"
        "    (oaOccInstHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccInstHeader_tp_dealloc(PyoaOccInstHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccInstHeader_tp_repr(PyObject *ob)
{
    PyParamoaOccInstHeader value;
    int convert_status=PyoaOccInstHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaOccInstHeader::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaString sresult;
        oaString sep=" ";
        sep[(oaUInt4)0]=oacInternalHierDelimiter;
        oaScalarName name;
        oaString str;
        value.DataCall()->getLibName(name);
        name.get(str);
        sresult+=oaString(str);
        sresult+=sep;
        value.DataCall()->getCellName(name);
        name.get(str);
        sresult+=oaString(str);
        sresult+=sep;
        value.DataCall()->getViewName(name);
        name.get(str);
        sresult+=oaString(str);
    
        char addr[37];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaOccInstHeader::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccInstHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccInstHeader v1;
    PyParamoaOccInstHeader v2;
    int convert_status1=PyoaOccInstHeader_Convert(ob1,&v1);
    int convert_status2=PyoaOccInstHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccInstHeader_Convert(PyObject* ob,PyParamoaOccInstHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccInstHeader_Check(ob)) {
        result->SetData( (oaOccInstHeader**) ((PyoaOccInstHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccInstHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccInstHeader_FromoaOccInstHeader(oaOccInstHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccInstHeader* data=*value;
        PyObject* bself = PyoaOccInstHeader_Type.tp_alloc(&PyoaOccInstHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaOccInstHeaderObject* self = (PyoaOccInstHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccInstHeader_FromoaOccInstHeader(oaOccInstHeader* data)
{
    if (data) {
       PyObject* bself = PyoaOccInstHeader_Type.tp_alloc(&PyoaOccInstHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaOccInstHeaderObject* self = (PyoaOccInstHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccInstHeader_getAllParams_doc[] = 
"Class: oaOccInstHeader, Function: getAllParams\n"
"  Paramegers: (oaParamArray)\n"
"    Calls: void getAllParams(oaParamArray& params) const\n"
"    Signature: getAllParams|void-void|ref-oaParamArray,\n"
"    BrowseData: 0,oaParamArray\n"
"    This function fills out params with the parameters associated with this instHeader and the parameters associated with the superMaster. If this instHeader is not associated with parameters, params will have a numParams value of zero.\n"
;

static PyObject*
oaOccInstHeader_getAllParams(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstHeader data;
    int convert_status=PyoaOccInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstHeaderObject* self=(PyoaOccInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaParamArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaParamArray_Convert,&p1)) {
        data.DataCall()->getAllParams(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstHeader_getCellName_doc[] = 
"Class: oaOccInstHeader, Function: getCellName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getCellName(oaScalarName& cellName) const\n"
"    Signature: getCellName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the cell name of the master oaDesign referenced by this occInstHeader.\n"
"    cellName\n"
"    The returned cell name.\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getCellName(const oaNameSpace& ns,oaString& cellName) const\n"
"    Signature: getCellName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the cell name of the master oaDesign referenced by this occInstHeader.\n"
"    ns\n"
"    The namespace in which to return the cell name.\n"
"    cellName\n"
"    The returned cell name.\n"
;

static PyObject*
oaOccInstHeader_getCellName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstHeader data;
    int convert_status=PyoaOccInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstHeaderObject* self=(PyoaOccInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getCellName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getCellName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccInstHeader, function: getCellName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstHeader_getInstHeader_doc[] = 
"Class: oaOccInstHeader, Function: getInstHeader\n"
"  Paramegers: ()\n"
"    Calls: oaInstHeader* getInstHeader() const\n"
"    Signature: getInstHeader|ptr-oaInstHeader|\n"
"    BrowseData: 1\n"
"    This function returns the block domain object referenced by this occurrence instHeader.\n"
;

static PyObject*
oaOccInstHeader_getInstHeader(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstHeader data;
    int convert_status=PyoaOccInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstHeaderObject* self=(PyoaOccInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaInstHeaderp result= (data.DataCall()->getInstHeader());
        return PyoaInstHeader_FromoaInstHeader(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstHeader_getInsts_doc[] = 
"Class: oaOccInstHeader, Function: getInsts\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaOccDesignInst_oaOccInstHeader getInsts() const\n"
"    Signature: getInsts|simple-oaCollection_oaOccDesignInst_oaOccInstHeader|simple-oaUInt4,ptr-oaOccurrence,\n"
"    BrowseData: 1\n"
"    This function returns a collection of instances associated with this instHeader. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection. If the optional occurrence is specified, the collection contains only the occInsts which directly belong to that occurrence as parent.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
"    occ\n"
"    Specifies that the collection should only contain those instances where the occurrence is the parent\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaOccDesignInst_oaOccInstHeader getInsts(oaUInt4 filterFlags) const\n"
"    Signature: getInsts|simple-oaCollection_oaOccDesignInst_oaOccInstHeader|simple-oaUInt4,ptr-oaOccurrence,\n"
"    This function returns a collection of instances associated with this instHeader. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection. If the optional occurrence is specified, the collection contains only the occInsts which directly belong to that occurrence as parent.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
"    occ\n"
"    Specifies that the collection should only contain those instances where the occurrence is the parent\n"
"  Paramegers: (oaUInt4,oaOccurrence)\n"
"    Calls: oaCollection_oaOccDesignInst_oaOccInstHeader getInsts(oaUInt4 filterFlags,oaOccurrence* parentOcc) const\n"
"    Signature: getInsts|simple-oaCollection_oaOccDesignInst_oaOccInstHeader|simple-oaUInt4,ptr-oaOccurrence,\n"
"    This function returns a collection of instances associated with this instHeader. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection. If the optional occurrence is specified, the collection contains only the occInsts which directly belong to that occurrence as parent.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
"    occ\n"
"    Specifies that the collection should only contain those instances where the occurrence is the parent\n"
;

static PyObject*
oaOccInstHeader_getInsts(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstHeader data;
    int convert_status=PyoaOccInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstHeaderObject* self=(PyoaOccInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaOccDesignInst_oaOccInstHeader* result= new oaCollection_oaOccDesignInst_oaOccInstHeader(data.DataCall()->getInsts());
            return PyoaCollection_oaOccDesignInst_oaOccInstHeader_FromoaCollection_oaOccDesignInst_oaOccInstHeader(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaOccDesignInst_oaOccInstHeader* result= new oaCollection_oaOccDesignInst_oaOccInstHeader(data.DataCall()->getInsts(p1.Data()));
            return PyoaCollection_oaOccDesignInst_oaOccInstHeader_FromoaCollection_oaOccDesignInst_oaOccInstHeader(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaOccurrence)
    {
        PyParamoaUInt4 p1;
        PyParamoaOccurrence p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaOccurrence_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaCollection_oaOccDesignInst_oaOccInstHeader* result= new oaCollection_oaOccDesignInst_oaOccInstHeader(data.DataCall()->getInsts(p1.Data(),p2.Data()));
            return PyoaCollection_oaOccDesignInst_oaOccInstHeader_FromoaCollection_oaOccDesignInst_oaOccInstHeader(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccInstHeader, function: getInsts, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaOccurrence)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstHeader_getInstsIter_doc[] = 
"Class: oaOccInstHeader, Function: getInstsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaOccDesignInst getInstsIter() const\n"
"    Signature: getInstsIter|simple-oaIter_oaOccDesignInst|simple-oaUInt4,ptr-oaOccurrence,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of instances associated with this instHeader. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection. If the optional occurrence is specified, the collection contains only the occInsts which directly belong to that occurrence as parent.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
"    occ\n"
"    Specifies that the collection should only contain those instances where the occurrence is the parent\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaOccDesignInst getInstsIter(oaUInt4 filterFlags) const\n"
"    Signature: getInstsIter|simple-oaIter_oaOccDesignInst|simple-oaUInt4,ptr-oaOccurrence,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of instances associated with this instHeader. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection. If the optional occurrence is specified, the collection contains only the occInsts which directly belong to that occurrence as parent.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
"    occ\n"
"    Specifies that the collection should only contain those instances where the occurrence is the parent\n"
"  Paramegers: (oaUInt4,oaOccurrence)\n"
"    Calls: oaIter_oaOccDesignInst getInstsIter(oaUInt4 filterFlags,oaOccurrence* parentOcc) const\n"
"    Signature: getInstsIter|simple-oaIter_oaOccDesignInst|simple-oaUInt4,ptr-oaOccurrence,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of instances associated with this instHeader. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection. If the optional occurrence is specified, the collection contains only the occInsts which directly belong to that occurrence as parent.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
"    occ\n"
"    Specifies that the collection should only contain those instances where the occurrence is the parent\n"
;

static PyObject*
oaOccInstHeader_getInstsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstHeader data;
    int convert_status=PyoaOccInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstHeaderObject* self=(PyoaOccInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaOccDesignInst* result= new oaIter_oaOccDesignInst(data.DataCall()->getInsts());
            return PyoaIter_oaOccDesignInst_FromoaIter_oaOccDesignInst(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaOccDesignInst* result= new oaIter_oaOccDesignInst(data.DataCall()->getInsts(p1.Data()));
            return PyoaIter_oaOccDesignInst_FromoaIter_oaOccDesignInst(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaOccurrence)
    {
        PyParamoaUInt4 p1;
        PyParamoaOccurrence p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaOccurrence_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaIter_oaOccDesignInst* result= new oaIter_oaOccDesignInst(data.DataCall()->getInsts(p1.Data(),p2.Data()));
            return PyoaIter_oaOccDesignInst_FromoaIter_oaOccDesignInst(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccInstHeader, function: getInstsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaOccurrence)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstHeader_getLibName_doc[] = 
"Class: oaOccInstHeader, Function: getLibName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getLibName(oaScalarName& libName) const\n"
"    Signature: getLibName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the library name of the master oaDesign referenced by this occInstHeader.\n"
"    libName\n"
"    The returned library name.\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getLibName(const oaNameSpace& ns,oaString& libName) const\n"
"    Signature: getLibName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the library name of the master oaDesign referenced by this occInstHeader.\n"
"    ns\n"
"    The namespace in which to return the library name.\n"
"    libName\n"
"    The returned library name.\n"
;

static PyObject*
oaOccInstHeader_getLibName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstHeader data;
    int convert_status=PyoaOccInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstHeaderObject* self=(PyoaOccInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getLibName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getLibName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccInstHeader, function: getLibName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstHeader_getMaster_doc[] = 
"Class: oaOccInstHeader, Function: getMaster\n"
"  Paramegers: ()\n"
"    Calls: oaDesign* getMaster() const\n"
"    Signature: getMaster|ptr-oaDesign|\n"
"    BrowseData: 1\n"
"    This function attempts to return the master associated with this design. If the instHeader is bound, the master is returned. Otherwise, NULL is returned.\n"
;

static PyObject*
oaOccInstHeader_getMaster(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstHeader data;
    int convert_status=PyoaOccInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstHeaderObject* self=(PyoaOccInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaDesignp result= (data.DataCall()->getMaster());
        return PyoaDesign_FromoaDesign(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstHeader_getModInstHeader_doc[] = 
"Class: oaOccInstHeader, Function: getModInstHeader\n"
"  Paramegers: ()\n"
"    Calls: oaModInstHeader* getModInstHeader() const\n"
"    Signature: getModInstHeader|ptr-oaModInstHeader|\n"
"    BrowseData: 1\n"
"    This function returns the module domain object referenced by this occurrence instHeader.\n"
;

static PyObject*
oaOccInstHeader_getModInstHeader(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstHeader data;
    int convert_status=PyoaOccInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstHeaderObject* self=(PyoaOccInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModInstHeaderp result= (data.DataCall()->getModInstHeader());
        return PyoaModInstHeader_FromoaModInstHeader(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstHeader_getParams_doc[] = 
"Class: oaOccInstHeader, Function: getParams\n"
"  Paramegers: (oaParamArray)\n"
"    Calls: void getParams(oaParamArray& params) const\n"
"    Signature: getParams|void-void|ref-oaParamArray,\n"
"    BrowseData: 0,oaParamArray\n"
"    This function fills out params with the parameters associated with this instHeader. This call only returns the non-default parameters that were specified during creation or through calls to setParams() on the instances. If this instHeader is not associated with a Pcell master or uses all default parameters, params will have a numParams of zero.\n"
;

static PyObject*
oaOccInstHeader_getParams(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstHeader data;
    int convert_status=PyoaOccInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstHeaderObject* self=(PyoaOccInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaParamArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaParamArray_Convert,&p1)) {
        data.DataCall()->getParams(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstHeader_getSubHeaders_doc[] = 
"Class: oaOccInstHeader, Function: getSubHeaders\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaOccInstHeader_oaOccInstHeader getSubHeaders() const\n"
"    Signature: getSubHeaders|simple-oaCollection_oaOccInstHeader_oaOccInstHeader|\n"
"    BrowseData: 1\n"
"    This function returns a collection of subHeaders in this superHeader.\n"
;

static PyObject*
oaOccInstHeader_getSubHeaders(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstHeader data;
    int convert_status=PyoaOccInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstHeaderObject* self=(PyoaOccInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaOccInstHeader_oaOccInstHeader* result= new oaCollection_oaOccInstHeader_oaOccInstHeader(data.DataCall()->getSubHeaders());
        return PyoaCollection_oaOccInstHeader_oaOccInstHeader_FromoaCollection_oaOccInstHeader_oaOccInstHeader(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstHeader_getSubHeadersIter_doc[] = 
"Class: oaOccInstHeader, Function: getSubHeadersIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaOccInstHeader getSubHeadersIter() const\n"
"    Signature: getSubHeadersIter|simple-oaIter_oaOccInstHeader|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of subHeaders in this superHeader.\n"
;

static PyObject*
oaOccInstHeader_getSubHeadersIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstHeader data;
    int convert_status=PyoaOccInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstHeaderObject* self=(PyoaOccInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaOccInstHeader* result= new oaIter_oaOccInstHeader(data.DataCall()->getSubHeaders());
        return PyoaIter_oaOccInstHeader_FromoaIter_oaOccInstHeader(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstHeader_getSuperHeader_doc[] = 
"Class: oaOccInstHeader, Function: getSuperHeader\n"
"  Paramegers: ()\n"
"    Calls: oaOccInstHeader* getSuperHeader() const\n"
"    Signature: getSuperHeader|ptr-oaOccInstHeader|\n"
"    BrowseData: 1\n"
"    This function returns the superHeader of this instHeader. The function returns NULL if it is not a subHeader.\n"
;

static PyObject*
oaOccInstHeader_getSuperHeader(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstHeader data;
    int convert_status=PyoaOccInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstHeaderObject* self=(PyoaOccInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaOccInstHeaderp result= (data.DataCall()->getSuperHeader());
        return PyoaOccInstHeader_FromoaOccInstHeader(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstHeader_getViewName_doc[] = 
"Class: oaOccInstHeader, Function: getViewName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getViewName(oaScalarName& viewName) const\n"
"    Signature: getViewName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the view name of the master oaDesign referenced by this occInstHeader.\n"
"    viewName\n"
"    The returned view name.\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getViewName(const oaNameSpace& ns,oaString& viewName) const\n"
"    Signature: getViewName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the view name of the master oaDesign referenced by this occInstHeader.\n"
"    ns\n"
"    The namespace in which to return the view name.\n"
"    viewName\n"
"    The returned view name.\n"
;

static PyObject*
oaOccInstHeader_getViewName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstHeader data;
    int convert_status=PyoaOccInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstHeaderObject* self=(PyoaOccInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getViewName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getViewName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccInstHeader, function: getViewName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstHeader_isBound_doc[] = 
"Class: oaOccInstHeader, Function: isBound\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isBound() const\n"
"    Signature: isBound|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value that indicates if this instHeader is bound to its master design. A bound master means the master is read in and the linkage from the instHeader is established by traversing from an instance to that master.\n"
"    Since there is only one occInstHeader for each distinct master design, shared by all occInsts within an instantiating design (regardless of which occurrence each occInst is in), this function does not indicate that there is a bound oaOccurrence for the master design. To check whether there is a bound occurrence for a given occInst, use oaOccInst::isBound() .\n"
;

static PyObject*
oaOccInstHeader_isBound(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstHeader data;
    int convert_status=PyoaOccInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstHeaderObject* self=(PyoaOccInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isBound());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstHeader_isSubHeader_doc[] = 
"Class: oaOccInstHeader, Function: isSubHeader\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isSubHeader() const\n"
"    Signature: isSubHeader|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value that indicates if this instHeader is a subHeader.\n"
;

static PyObject*
oaOccInstHeader_isSubHeader(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstHeader data;
    int convert_status=PyoaOccInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstHeaderObject* self=(PyoaOccInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isSubHeader());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstHeader_isSuperHeader_doc[] = 
"Class: oaOccInstHeader, Function: isSuperHeader\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isSuperHeader() const\n"
"    Signature: isSuperHeader|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value that indicates if this instHeader is a superHeader.\n"
;

static PyObject*
oaOccInstHeader_isSuperHeader(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstHeader data;
    int convert_status=PyoaOccInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstHeaderObject* self=(PyoaOccInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isSuperHeader());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstHeader_isNull_doc[] =
"Class: oaOccInstHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccInstHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccInstHeader data;
    int convert_status=PyoaOccInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccInstHeader_assign_doc[] = 
"Class: oaOccInstHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccInstHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccInstHeader data;
  int convert_status=PyoaOccInstHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccInstHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccInstHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccInstHeader_methodlist[] = {
    {"getAllParams",(PyCFunction)oaOccInstHeader_getAllParams,METH_VARARGS,oaOccInstHeader_getAllParams_doc},
    {"getCellName",(PyCFunction)oaOccInstHeader_getCellName,METH_VARARGS,oaOccInstHeader_getCellName_doc},
    {"getInstHeader",(PyCFunction)oaOccInstHeader_getInstHeader,METH_VARARGS,oaOccInstHeader_getInstHeader_doc},
    {"getInsts",(PyCFunction)oaOccInstHeader_getInsts,METH_VARARGS,oaOccInstHeader_getInsts_doc},
    {"getInstsIter",(PyCFunction)oaOccInstHeader_getInstsIter,METH_VARARGS,oaOccInstHeader_getInstsIter_doc},
    {"getLibName",(PyCFunction)oaOccInstHeader_getLibName,METH_VARARGS,oaOccInstHeader_getLibName_doc},
    {"getMaster",(PyCFunction)oaOccInstHeader_getMaster,METH_VARARGS,oaOccInstHeader_getMaster_doc},
    {"getModInstHeader",(PyCFunction)oaOccInstHeader_getModInstHeader,METH_VARARGS,oaOccInstHeader_getModInstHeader_doc},
    {"getParams",(PyCFunction)oaOccInstHeader_getParams,METH_VARARGS,oaOccInstHeader_getParams_doc},
    {"getSubHeaders",(PyCFunction)oaOccInstHeader_getSubHeaders,METH_VARARGS,oaOccInstHeader_getSubHeaders_doc},
    {"getSubHeadersIter",(PyCFunction)oaOccInstHeader_getSubHeadersIter,METH_VARARGS,oaOccInstHeader_getSubHeadersIter_doc},
    {"getSuperHeader",(PyCFunction)oaOccInstHeader_getSuperHeader,METH_VARARGS,oaOccInstHeader_getSuperHeader_doc},
    {"getViewName",(PyCFunction)oaOccInstHeader_getViewName,METH_VARARGS,oaOccInstHeader_getViewName_doc},
    {"isBound",(PyCFunction)oaOccInstHeader_isBound,METH_VARARGS,oaOccInstHeader_isBound_doc},
    {"isSubHeader",(PyCFunction)oaOccInstHeader_isSubHeader,METH_VARARGS,oaOccInstHeader_isSubHeader_doc},
    {"isSuperHeader",(PyCFunction)oaOccInstHeader_isSuperHeader,METH_VARARGS,oaOccInstHeader_isSuperHeader_doc},
    {"isNull",(PyCFunction)oaOccInstHeader_tp_isNull,METH_VARARGS,oaOccInstHeader_isNull_doc},
    {"assign",(PyCFunction)oaOccInstHeader_tp_assign,METH_VARARGS,oaOccInstHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccInstHeader_doc[] = 
"Class: oaOccInstHeader\n"
"  The oaOccInstHeader class implements an object that contains information common to all the instances of a particular master design in a given parent occurrence. For instances of Pcells, there are two kinds of instHeaders:\n"
"  SuperHeaders represent all of the instances of a Pcell master, regardless of parameter settings\n"
"  SubHeaders represent all of the instances that have one specific set of parameter values\n"
"  Every instance of a Pcell has exactly one subHeader, which, in turn, has exactly one superHeader. InstHeaders for instances that are not Pcells are neither subheaders nor superheaders.\n"
"  The oaOccInstHeader class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaOccInstHeader)\n"
"    Calls: (const oaOccInstHeader&)\n"
"    Signature: oaOccInstHeader||cref-oaOccInstHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccInstHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccInstHeader",
    sizeof(PyoaOccInstHeaderObject),
    0,
    (destructor)oaOccInstHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccInstHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaOccInstHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccInstHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccInstHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccInstHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccInstHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccInstHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaOccInstHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccInstHeader",
           (PyObject*)(&PyoaOccInstHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccInstHeader\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccInstPropDisplay
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccInstPropDisplay_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccInstPropDisplay_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccInstPropDisplayObject* self = (PyoaOccInstPropDisplayObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccInstPropDisplay)
    {
        PyParamoaOccInstPropDisplay p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccInstPropDisplay_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccInstPropDisplay, Choices are:\n"
        "    (oaOccInstPropDisplay)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccInstPropDisplay_tp_dealloc(PyoaOccInstPropDisplayObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccInstPropDisplay_tp_repr(PyObject *ob)
{
    PyParamoaOccInstPropDisplay value;
    int convert_status=PyoaOccInstPropDisplay_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaOccInstPropDisplay::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccInstPropDisplay_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccInstPropDisplay v1;
    PyParamoaOccInstPropDisplay v2;
    int convert_status1=PyoaOccInstPropDisplay_Convert(ob1,&v1);
    int convert_status2=PyoaOccInstPropDisplay_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccInstPropDisplay_Convert(PyObject* ob,PyParamoaOccInstPropDisplay* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccInstPropDisplay_Check(ob)) {
        result->SetData( (oaOccInstPropDisplay**) ((PyoaOccInstPropDisplayObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccInstPropDisplay Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccInstPropDisplay_FromoaOccInstPropDisplay(oaOccInstPropDisplay** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccInstPropDisplay* data=*value;
        PyObject* bself = PyoaOccInstPropDisplay_Type.tp_alloc(&PyoaOccInstPropDisplay_Type,0);
        if (bself == NULL) return bself;
        PyoaOccInstPropDisplayObject* self = (PyoaOccInstPropDisplayObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccInstPropDisplay_FromoaOccInstPropDisplay(oaOccInstPropDisplay* data)
{
    if (data) {
       PyObject* bself = PyoaOccInstPropDisplay_Type.tp_alloc(&PyoaOccInstPropDisplay_Type,0);
       if (bself == NULL) return bself;
       PyoaOccInstPropDisplayObject* self = (PyoaOccInstPropDisplayObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccInstPropDisplay_getInst_doc[] = 
"Class: oaOccInstPropDisplay, Function: getInst\n"
"  Paramegers: ()\n"
"    Calls: oaInst* getInst() const\n"
"    Signature: getInst|ptr-oaInst|\n"
"    BrowseData: 1\n"
"    This function returns the instance associated with this instPropDisplay object.\n"
;

static PyObject*
oaOccInstPropDisplay_getInst(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstPropDisplay data;
    int convert_status=PyoaOccInstPropDisplay_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstPropDisplayObject* self=(PyoaOccInstPropDisplayObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaInstp result= (data.DataCall()->getInst());
        return PyoaInst_FromoaInst(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstPropDisplay_getMasterProp_doc[] = 
"Class: oaOccInstPropDisplay, Function: getMasterProp\n"
"  Paramegers: ()\n"
"    Calls: oaProp* getMasterProp() const\n"
"    Signature: getMasterProp|ptr-oaProp|\n"
"    BrowseData: 1\n"
"    This function returns the property associated with this instPropDisplay object. NULL will be returned if the instance master is not bound.\n"
;

static PyObject*
oaOccInstPropDisplay_getMasterProp(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstPropDisplay data;
    int convert_status=PyoaOccInstPropDisplay_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstPropDisplayObject* self=(PyoaOccInstPropDisplayObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaPropp result= (data.DataCall()->getMasterProp());
        return PyoaProp_FromoaProp(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstPropDisplay_isBound_doc[] = 
"Class: oaOccInstPropDisplay, Function: isBound\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isBound() const\n"
"    Signature: isBound|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean which indicates whether this text display is currently bound.\n"
;

static PyObject*
oaOccInstPropDisplay_isBound(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstPropDisplay data;
    int convert_status=PyoaOccInstPropDisplay_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstPropDisplayObject* self=(PyoaOccInstPropDisplayObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isBound());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstPropDisplay_isNull_doc[] =
"Class: oaOccInstPropDisplay, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccInstPropDisplay_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccInstPropDisplay data;
    int convert_status=PyoaOccInstPropDisplay_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccInstPropDisplay_assign_doc[] = 
"Class: oaOccInstPropDisplay, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccInstPropDisplay_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccInstPropDisplay data;
  int convert_status=PyoaOccInstPropDisplay_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccInstPropDisplay p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccInstPropDisplay_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccInstPropDisplay_methodlist[] = {
    {"getInst",(PyCFunction)oaOccInstPropDisplay_getInst,METH_VARARGS,oaOccInstPropDisplay_getInst_doc},
    {"getMasterProp",(PyCFunction)oaOccInstPropDisplay_getMasterProp,METH_VARARGS,oaOccInstPropDisplay_getMasterProp_doc},
    {"isBound",(PyCFunction)oaOccInstPropDisplay_isBound,METH_VARARGS,oaOccInstPropDisplay_isBound_doc},
    {"isNull",(PyCFunction)oaOccInstPropDisplay_tp_isNull,METH_VARARGS,oaOccInstPropDisplay_isNull_doc},
    {"assign",(PyCFunction)oaOccInstPropDisplay_tp_assign,METH_VARARGS,oaOccInstPropDisplay_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccInstPropDisplay_doc[] = 
"Class: oaOccInstPropDisplay\n"
"  The oaOccInstPropDisplay class implements an unique occurrence of an oaInstPropDisplay object in a design hierarchy.\n"
"Constructors:\n"
"  Paramegers: (oaOccInstPropDisplay)\n"
"    Calls: (const oaOccInstPropDisplay&)\n"
"    Signature: oaOccInstPropDisplay||cref-oaOccInstPropDisplay,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccInstPropDisplay_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccInstPropDisplay",
    sizeof(PyoaOccInstPropDisplayObject),
    0,
    (destructor)oaOccInstPropDisplay_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccInstPropDisplay_tp_compare,	/* tp_compare */
    (reprfunc)oaOccInstPropDisplay_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccInstPropDisplay_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccInstPropDisplay_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccTextDisplay_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccInstPropDisplay_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccInstPropDisplay_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccInstPropDisplay_Type)<0) {
      printf("** PyType_Ready failed for: oaOccInstPropDisplay\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccInstPropDisplay",
           (PyObject*)(&PyoaOccInstPropDisplay_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccInstPropDisplay\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccInstTerm
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccInstTerm_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccInstTerm_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccInstTermObject* self = (PyoaOccInstTermObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccInstTerm)
    {
        PyParamoaOccInstTerm p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccInstTerm_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccInstTerm, Choices are:\n"
        "    (oaOccInstTerm)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccInstTerm_tp_dealloc(PyoaOccInstTermObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccInstTerm_tp_repr(PyObject *ob)
{
    PyParamoaOccInstTerm value;
    int convert_status=PyoaOccInstTerm_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaOccInstTerm::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaString sresult;
        oaString sep=" ";
        sep[(oaUInt4)0]=oacInternalHierDelimiter;
        oaSimpleName sname;
        oaName name;
        oaString str;
        if (value.DataCall()->getInst()->isValid()) {
          value.DataCall()->getInst()->getName(sname);
          sname.get(str);
        }
        else {
          str="-";
        }
        sname.get(str);
        sresult+=oaString(str);
        sresult+=sep;
        value.DataCall()->getTermName(name);
        name.get(str);
        sresult+=oaString(str);
    
        char addr[35];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaOccInstTerm::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccInstTerm_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccInstTerm v1;
    PyParamoaOccInstTerm v2;
    int convert_status1=PyoaOccInstTerm_Convert(ob1,&v1);
    int convert_status2=PyoaOccInstTerm_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccInstTerm_Convert(PyObject* ob,PyParamoaOccInstTerm* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccInstTerm_Check(ob)) {
        result->SetData( (oaOccInstTerm**) ((PyoaOccInstTermObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccInstTerm Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccInstTerm_FromoaOccInstTerm(oaOccInstTerm** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccInstTerm* data=*value;
        PyObject* bself = PyoaOccInstTerm_Type.tp_alloc(&PyoaOccInstTerm_Type,0);
        if (bself == NULL) return bself;
        PyoaOccInstTermObject* self = (PyoaOccInstTermObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccInstTerm_FromoaOccInstTerm(oaOccInstTerm* data)
{
    if (data) {
       PyObject* bself = PyoaOccInstTerm_Type.tp_alloc(&PyoaOccInstTerm_Type,0);
       if (bself == NULL) return bself;
       PyoaOccInstTermObject* self = (PyoaOccInstTermObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccInstTerm_getAssignedNet_doc[] = 
"Class: oaOccInstTerm, Function: getAssignedNet\n"
"  Paramegers: ()\n"
"    Calls: oaOccNet* getAssignedNet() const\n"
"    Signature: getAssignedNet|ptr-oaOccNet|simple-oaBoolean,\n"
"    BrowseData: 1\n"
"    This function returns the occurrence net assigned to this instTerm as per the inherited connections specification.\n"
"    NULL will be returned in the following cases:\n"
"    There is no effective connectDef associated with this instTerm\n"
"    There is an effective connectDef but no matching assignment, and 'ignoreDefault' is true.\n"
"    Exceptions are thrown for cases when an assignment is found but a net with that name does not exist or if the default net name needs to be used, 'ignoreDefault' is false, but there is no net that matches the default net name specified.\n"
"    ignoreDefault\n"
"    Indicates if the default net name in the specification should be ignored\n"
"    oacCannotFindSpecAssignedDefOccNet\n"
"    oacCannotFindSpecAssignedOccNet\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: oaOccNet* getAssignedNet(oaBoolean ignoreDefault) const\n"
"    Signature: getAssignedNet|ptr-oaOccNet|simple-oaBoolean,\n"
"    This function returns the occurrence net assigned to this instTerm as per the inherited connections specification.\n"
"    NULL will be returned in the following cases:\n"
"    There is no effective connectDef associated with this instTerm\n"
"    There is an effective connectDef but no matching assignment, and 'ignoreDefault' is true.\n"
"    Exceptions are thrown for cases when an assignment is found but a net with that name does not exist or if the default net name needs to be used, 'ignoreDefault' is false, but there is no net that matches the default net name specified.\n"
"    ignoreDefault\n"
"    Indicates if the default net name in the specification should be ignored\n"
"    oacCannotFindSpecAssignedDefOccNet\n"
"    oacCannotFindSpecAssignedOccNet\n"
"  Paramegers: (oaAssignedNetSpec)\n"
"    Calls: oaOccNet* getAssignedNet(oaAssignedNetSpec& spec) const\n"
"    Signature: getAssignedNet|ptr-oaOccNet|ref-oaAssignedNetSpec,simple-oaBoolean,\n"
"    BrowseData: 1,oaAssignedNetSpec\n"
"    This function returns the occurrence net assigned to this instTerm as per the inherited connections specification.\n"
"    NULL will be returned in the following cases:\n"
"    There is no effective connectDef associated with this instTerm\n"
"    There is an effective connectDef but no matching assignment, and 'ignoreDefault' is true.\n"
"    Exceptions are thrown for cases when an assignment is found but a net with that name does not exist or if the default net name needs to be used, 'ignoreDefault' is false, but there is no net that matches the default net name specified.\n"
"    This version is for diagnostic use and returns the set of connectDefs and/or assignments that were looked at in the hierarchy for resolving the assigned net via the 'spec' parameter. Clients can inspect the array which will consist of pointers to either connectDef or assignment objects in the module or occurrence domains.\n"
"    spec\n"
"    An array that gets populated with pointers to design objects that indicate the assigned net specification\n"
"    ignoreDefault\n"
"    Indicates if the default net name in the specification should be ignored\n"
"    oacCannotFindSpecAssignedDefOccNet\n"
"    oacCannotFindSpecAssignedOccNet\n"
"  Paramegers: (oaAssignedNetSpec,oaBoolean)\n"
"    Calls: oaOccNet* getAssignedNet(oaAssignedNetSpec& spec,oaBoolean ignoreDefault) const\n"
"    Signature: getAssignedNet|ptr-oaOccNet|ref-oaAssignedNetSpec,simple-oaBoolean,\n"
"    This function returns the occurrence net assigned to this instTerm as per the inherited connections specification.\n"
"    NULL will be returned in the following cases:\n"
"    There is no effective connectDef associated with this instTerm\n"
"    There is an effective connectDef but no matching assignment, and 'ignoreDefault' is true.\n"
"    Exceptions are thrown for cases when an assignment is found but a net with that name does not exist or if the default net name needs to be used, 'ignoreDefault' is false, but there is no net that matches the default net name specified.\n"
"    This version is for diagnostic use and returns the set of connectDefs and/or assignments that were looked at in the hierarchy for resolving the assigned net via the 'spec' parameter. Clients can inspect the array which will consist of pointers to either connectDef or assignment objects in the module or occurrence domains.\n"
"    spec\n"
"    An array that gets populated with pointers to design objects that indicate the assigned net specification\n"
"    ignoreDefault\n"
"    Indicates if the default net name in the specification should be ignored\n"
"    oacCannotFindSpecAssignedDefOccNet\n"
"    oacCannotFindSpecAssignedOccNet\n"
;

static PyObject*
oaOccInstTerm_getAssignedNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstTerm data;
    int convert_status=PyoaOccInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstTermObject* self=(PyoaOccInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaOccNetp result= (data.DataCall()->getAssignedNet());
            return PyoaOccNet_FromoaOccNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            oaOccNetp result= (data.DataCall()->getAssignedNet(p1.Data()));
            return PyoaOccNet_FromoaOccNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaAssignedNetSpec)
    {
        PyParamoaAssignedNetSpec p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaAssignedNetSpec_Convert,&p1)) {
            oaOccNetp result= (data.DataCall()->getAssignedNet(p1.Data()));
            return PyoaOccNet_FromoaOccNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaAssignedNetSpec,oaBoolean)
    {
        PyParamoaAssignedNetSpec p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaAssignedNetSpec_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaOccNetp result= (data.DataCall()->getAssignedNet(p1.Data(),p2.Data()));
            return PyoaOccNet_FromoaOccNet(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccInstTerm, function: getAssignedNet, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
        "    (oaAssignedNetSpec)\n"
        "    (oaAssignedNetSpec,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstTerm_getBit_doc[] = 
"Class: oaOccInstTerm, Function: getBit\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaOccInstTerm* getBit(oaUInt4 bitIndex) const\n"
"    Signature: getBit|ptr-oaOccInstTerm|simple-oaUInt4,\n"
"    This function returns a pointer to the occInstTerm that corresponds to the specified bitIndex bit of this occInstTerm. For single-bit instTerms, this function returns this occInstTerm if the bitIndex value is zero.\n"
"    oacInvalidInstTermBitIndex\n"
;

static PyObject*
oaOccInstTerm_getBit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstTerm data;
    int convert_status=PyoaOccInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstTermObject* self=(PyoaOccInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaOccInstTermp result= (data.DataCall()->getBit(p1.Data()));
        return PyoaOccInstTerm_FromoaOccInstTerm(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstTerm_getInst_doc[] = 
"Class: oaOccInstTerm, Function: getInst\n"
"  Paramegers: ()\n"
"    Calls: oaOccInst* getInst() const\n"
"    Signature: getInst|ptr-oaOccInst|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the occurrence instance that this instTerm is associated with.\n"
;

static PyObject*
oaOccInstTerm_getInst(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstTerm data;
    int convert_status=PyoaOccInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstTermObject* self=(PyoaOccInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaOccInstp result= (data.DataCall()->getInst());
        return PyoaOccInst_FromoaOccInst(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstTerm_getInstTerm_doc[] = 
"Class: oaOccInstTerm, Function: getInstTerm\n"
"  Paramegers: ()\n"
"    Calls: oaInstTerm* getInstTerm() const\n"
"    Signature: getInstTerm|ptr-oaInstTerm|\n"
"    BrowseData: 1\n"
"    This function gets the oaInstTerm in the block domain that this occInstTerm corresponds to. If this occInstTerm is derived from an oaModInstTerm that is not visible to the block domain, then it will not have an oaInstTerm and this function will return NULL.\n"
;

static PyObject*
oaOccInstTerm_getInstTerm(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstTerm data;
    int convert_status=PyoaOccInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstTermObject* self=(PyoaOccInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaInstTermp result= (data.DataCall()->getInstTerm());
        return PyoaInstTerm_FromoaInstTerm(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstTerm_getModInstTerm_doc[] = 
"Class: oaOccInstTerm, Function: getModInstTerm\n"
"  Paramegers: ()\n"
"    Calls: oaModInstTerm* getModInstTerm() const\n"
"    Signature: getModInstTerm|ptr-oaModInstTerm|\n"
"    BrowseData: 1\n"
"    This function gets the oaModInstTerm in the module domain that this occInstTerm corresponds to. If this occInstTerm is on an oaOccModuleInst then it will always have a corresponding oaModInstTerm . If it is derived from an oaInstTerm that is not visible to the module domain, then it will not have an oaModInstTerm and this function will return NULL.\n"
;

static PyObject*
oaOccInstTerm_getModInstTerm(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstTerm data;
    int convert_status=PyoaOccInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstTermObject* self=(PyoaOccInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModInstTermp result= (data.DataCall()->getModInstTerm());
        return PyoaModInstTerm_FromoaModInstTerm(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstTerm_getNet_doc[] = 
"Class: oaOccInstTerm, Function: getNet\n"
"  Paramegers: ()\n"
"    Calls: oaOccNet* getNet() const\n"
"    Signature: getNet|ptr-oaOccNet|simple-oaBoolean,\n"
"    BrowseData: 1\n"
"    oaOccInstTerm::getNet\n"
"    This function returns the occurrence net associated with this occInstTerm. NULL is returned if the instTerm was created with a NULL net or if the instTerm has been disconnected from the net. If preferred is true , the preferred equivalent net associated with the net will be returned instead.\n"
"    preferred\n"
"    indicates whether to return the preferred equivalent\n"
"    A pointer to an oaOccNet\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: oaOccNet* getNet(oaBoolean preferred) const\n"
"    Signature: getNet|ptr-oaOccNet|simple-oaBoolean,\n"
"    oaOccInstTerm::getNet\n"
"    This function returns the occurrence net associated with this occInstTerm. NULL is returned if the instTerm was created with a NULL net or if the instTerm has been disconnected from the net. If preferred is true , the preferred equivalent net associated with the net will be returned instead.\n"
"    preferred\n"
"    indicates whether to return the preferred equivalent\n"
"    A pointer to an oaOccNet\n"
;

static PyObject*
oaOccInstTerm_getNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstTerm data;
    int convert_status=PyoaOccInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstTermObject* self=(PyoaOccInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaOccNetp result= (data.DataCall()->getNet());
            return PyoaOccNet_FromoaOccNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            oaOccNetp result= (data.DataCall()->getNet(p1.Data()));
            return PyoaOccNet_FromoaOccNet(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccInstTerm, function: getNet, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstTerm_getNumBits_doc[] = 
"Class: oaOccInstTerm, Function: getNumBits\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumBits() const\n"
"    Signature: getNumBits|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of bits for this instTerm. This value is equal to the number of bits in the associated net. If the instTerm has no net, the value is calculated from the number of bits in the corresponding terminal multiplied by the number of bits in the corresponding instance. If the terminal is not bound, the number of bits for the terminal is derived from the terminal name. If the terminal is not bound and the instTerm connects by position, the number of bits cannot be determined if there is no net, and a value of zero is returned.\n"
;

static PyObject*
oaOccInstTerm_getNumBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstTerm data;
    int convert_status=PyoaOccInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstTermObject* self=(PyoaOccInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumBits());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstTerm_getTerm_doc[] = 
"Class: oaOccInstTerm, Function: getTerm\n"
"  Paramegers: ()\n"
"    Calls: oaOccTerm* getTerm() const\n"
"    Signature: getTerm|ptr-oaOccTerm|simple-oaBoolean,\n"
"    BrowseData: 1\n"
"    This function returns the occurrence terminal associated with this instTerm. If expand is true, and the instTerm is currently unbound, this function attempts to bind the master. NULL is returned if the instance cannot be bound or the terminal is not found in the master. An exception is thrown if the instance is a vectorInst or an implicit vectorInstBit because there is no occurrence hierarchy beneath these types of instances.\n"
"    Use caution when setting the expand argument to true. Expanding the occurrence hierarchy into all the leaf instances of many designs requires large amounts of memory to hold all the referenced occurrence objects. At the leaf level, information should be referenced in the block or the module instead. For example, to get the terminal and its oaTermType for any oaOccInstTerm pointed to by a variable occITerm , you could might use code such as: oaModInstTerm *modITerm occITerm-> getModInstTerm() ; oaModTerm *modTerm = modITerm-> getTerm() ;\n"
"    if (modTerm) { oaTermType termType = modTerm->getTermType(); }\n"
"    Or oaInstTerm *blkITerm = occITerm-> getInstTerm() ; oaTerm *blkTerm = blkITerm-> getTerm() ;\n"
"    if (blkTerm) { oaTermType termType = blkTerm->getTermType(); }\n"
"    expand\n"
"    Specifies whether to expand the occurrence hierarchy to include the master occurrence for this occInstTerm, if it has not yet been expanded in the current session.\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: oaOccTerm* getTerm(oaBoolean expand) const\n"
"    Signature: getTerm|ptr-oaOccTerm|simple-oaBoolean,\n"
"    This function returns the occurrence terminal associated with this instTerm. If expand is true, and the instTerm is currently unbound, this function attempts to bind the master. NULL is returned if the instance cannot be bound or the terminal is not found in the master. An exception is thrown if the instance is a vectorInst or an implicit vectorInstBit because there is no occurrence hierarchy beneath these types of instances.\n"
"    Use caution when setting the expand argument to true. Expanding the occurrence hierarchy into all the leaf instances of many designs requires large amounts of memory to hold all the referenced occurrence objects. At the leaf level, information should be referenced in the block or the module instead. For example, to get the terminal and its oaTermType for any oaOccInstTerm pointed to by a variable occITerm , you could might use code such as: oaModInstTerm *modITerm occITerm-> getModInstTerm() ; oaModTerm *modTerm = modITerm-> getTerm() ;\n"
"    if (modTerm) { oaTermType termType = modTerm->getTermType(); }\n"
"    Or oaInstTerm *blkITerm = occITerm-> getInstTerm() ; oaTerm *blkTerm = blkITerm-> getTerm() ;\n"
"    if (blkTerm) { oaTermType termType = blkTerm->getTermType(); }\n"
"    expand\n"
"    Specifies whether to expand the occurrence hierarchy to include the master occurrence for this occInstTerm, if it has not yet been expanded in the current session.\n"
;

static PyObject*
oaOccInstTerm_getTerm(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstTerm data;
    int convert_status=PyoaOccInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstTermObject* self=(PyoaOccInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaOccTermp result= (data.DataCall()->getTerm());
            return PyoaOccTerm_FromoaOccTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            oaOccTermp result= (data.DataCall()->getTerm(p1.Data()));
            return PyoaOccTerm_FromoaOccTerm(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccInstTerm, function: getTerm, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstTerm_getTermName_doc[] = 
"Class: oaOccInstTerm, Function: getTermName\n"
"  Paramegers: (oaName)\n"
"    Calls: void getTermName(oaName& name) const\n"
"    Signature: getTermName|void-void|ref-oaName,\n"
"    BrowseData: 0,oaName\n"
"    This function returns the name of the terminal associated with this instTerm in the given name argument. A name is returned even if the instTerm is not bound. The existence of a terminal name does not guarantee that the terminal exists in the corresponding instance master.\n"
"    name\n"
"    The name object to return the terminal name in\n"
"    oacInstTermConnectsByPosition\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getTermName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getTermName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the name of the terminal associated with this instTerm in the nameSpace specified. A name is returned even if the instTerm is not bound. The existence of a terminal name does not necessarily guarantee that the corresponding terminal exists in the instance master.\n"
"    ns\n"
"    The nameSpace for processing the name\n"
"    name\n"
"    The string that the terminal name is returned in\n"
"    oacInstTermConnectsByPosition\n"
;

static PyObject*
oaOccInstTerm_getTermName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstTerm data;
    int convert_status=PyoaOccInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstTermObject* self=(PyoaOccInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaName)
    {
        PyParamoaName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaName_Convert,&p1)) {
            data.DataCall()->getTermName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getTermName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccInstTerm, function: getTermName, Choices are:\n"
        "    (oaName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstTerm_getTermPosition_doc[] = 
"Class: oaOccInstTerm, Function: getTermPosition\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getTermPosition() const\n"
"    Signature: getTermPosition|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the terminal position that this instTerm connects to. If this instTerm is not bound by position, the value oacNullIndex is returned.\n"
"    oacInstTermConnectsByName\n"
;

static PyObject*
oaOccInstTerm_getTermPosition(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstTerm data;
    int convert_status=PyoaOccInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstTermObject* self=(PyoaOccInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getTermPosition());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstTerm_isBound_doc[] = 
"Class: oaOccInstTerm, Function: isBound\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isBound() const\n"
"    Signature: isBound|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value that indicates if the instance associated with this instTerm is bound and if the associated terminal exists in the instance master.\n"
;

static PyObject*
oaOccInstTerm_isBound(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstTerm data;
    int convert_status=PyoaOccInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstTermObject* self=(PyoaOccInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isBound());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstTerm_isImplicit_doc[] = 
"Class: oaOccInstTerm, Function: isImplicit\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isImplicit() const\n"
"    Signature: isImplicit|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value indicating whether this instTerm is implicit, having been created as a result of the creation of a multi-bit instTerm.\n"
;

static PyObject*
oaOccInstTerm_isImplicit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstTerm data;
    int convert_status=PyoaOccInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstTermObject* self=(PyoaOccInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isImplicit());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstTerm_usesTermPosition_doc[] = 
"Class: oaOccInstTerm, Function: usesTermPosition\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean usesTermPosition() const\n"
"    Signature: usesTermPosition|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether this instTerm was created to connect to a terminal position. This function returns 'true' if this instTerm binds to a particular terminal position. It returns 'false' if this instTerm binds to a terminal by name.\n"
;

static PyObject*
oaOccInstTerm_usesTermPosition(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccInstTerm data;
    int convert_status=PyoaOccInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccInstTermObject* self=(PyoaOccInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->usesTermPosition());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccInstTerm_isNull_doc[] =
"Class: oaOccInstTerm, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccInstTerm_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccInstTerm data;
    int convert_status=PyoaOccInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccInstTerm_assign_doc[] = 
"Class: oaOccInstTerm, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccInstTerm_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccInstTerm data;
  int convert_status=PyoaOccInstTerm_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccInstTerm p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccInstTerm_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccInstTerm_methodlist[] = {
    {"getAssignedNet",(PyCFunction)oaOccInstTerm_getAssignedNet,METH_VARARGS,oaOccInstTerm_getAssignedNet_doc},
    {"getBit",(PyCFunction)oaOccInstTerm_getBit,METH_VARARGS,oaOccInstTerm_getBit_doc},
    {"getInst",(PyCFunction)oaOccInstTerm_getInst,METH_VARARGS,oaOccInstTerm_getInst_doc},
    {"getInstTerm",(PyCFunction)oaOccInstTerm_getInstTerm,METH_VARARGS,oaOccInstTerm_getInstTerm_doc},
    {"getModInstTerm",(PyCFunction)oaOccInstTerm_getModInstTerm,METH_VARARGS,oaOccInstTerm_getModInstTerm_doc},
    {"getNet",(PyCFunction)oaOccInstTerm_getNet,METH_VARARGS,oaOccInstTerm_getNet_doc},
    {"getNumBits",(PyCFunction)oaOccInstTerm_getNumBits,METH_VARARGS,oaOccInstTerm_getNumBits_doc},
    {"getTerm",(PyCFunction)oaOccInstTerm_getTerm,METH_VARARGS,oaOccInstTerm_getTerm_doc},
    {"getTermName",(PyCFunction)oaOccInstTerm_getTermName,METH_VARARGS,oaOccInstTerm_getTermName_doc},
    {"getTermPosition",(PyCFunction)oaOccInstTerm_getTermPosition,METH_VARARGS,oaOccInstTerm_getTermPosition_doc},
    {"isBound",(PyCFunction)oaOccInstTerm_isBound,METH_VARARGS,oaOccInstTerm_isBound_doc},
    {"isImplicit",(PyCFunction)oaOccInstTerm_isImplicit,METH_VARARGS,oaOccInstTerm_isImplicit_doc},
    {"usesTermPosition",(PyCFunction)oaOccInstTerm_usesTermPosition,METH_VARARGS,oaOccInstTerm_usesTermPosition_doc},
    {"isNull",(PyCFunction)oaOccInstTerm_tp_isNull,METH_VARARGS,oaOccInstTerm_isNull_doc},
    {"assign",(PyCFunction)oaOccInstTerm_tp_assign,METH_VARARGS,oaOccInstTerm_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccInstTerm_doc[] = 
"Class: oaOccInstTerm\n"
"  The oaOccInstTerm class is an abstract base class for all types of connections between a net and a terminal in the master of an instance in the occurrence domain. The connection is proper if the number of bits in the net is equal to the number of bits implied by the instTerm's terminal name. In the case of oaOccVectorInsts, the net width must be multiplied by the number of bits represented by the instance name.\n"
"  When oaInstTerm objects are created in the block domain and oaModInstTerm objects are created in the module domain, corresponding oaOccInstTerm objects are automatically created in the occurrence domain. Each oaOccInstTerm can correspond to one oaModInstTerm , or one oaInstTerm , or one of each.\n"
"  oaOccInstTerms may exist that do not have a proper corresponding terminal in the master of its oaOccInst . This allows instTerms to be created when the instance master is not read in, and it allows changes to instTerms that happen before the master is updated. The traversal from an instTerm to its corresponding terminal will not succeed unless a terminal with an exactly matching name is present in the master.\n"
"  oaModInstTerm , oaOccInstTerm, and oaInstTerm each represent instances of terminals in different hierarchy domains, where in each case the instance master represents a level of hierarchy in the design.\n"
"  For oaOccInstTerm, its instance's master is an oaOccurrence , and each oaOccInst of an oaOccurrence will have a set of zero or more occInstTerms. For oaModInstTerm , the instance master is an oaModule . For oaInstTerm , the master is an oaBlock .\n"
"  When an instTerm is created by specifying a terminal or terminal name, the instTerm is said to connect by name. Binding is done to the named terminal if it exists in the instance master. The width of the connection must match the width of the associated net. When an instTerm is created by specifying a terminal position, the instTerm is said to connect by position. Binding is to the terminal in the master that is assigned to the position and if the resulting connection width matches the width of the corresponding net. To avoid confusion, the instTerms associated with a particular instance must either all be connected by name or all by connected by position.\n"
"  The oaOccInstTerm class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaOccInstTerm)\n"
"    Calls: (const oaOccInstTerm&)\n"
"    Signature: oaOccInstTerm||cref-oaOccInstTerm,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccInstTerm_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccInstTerm",
    sizeof(PyoaOccInstTermObject),
    0,
    (destructor)oaOccInstTerm_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccInstTerm_tp_compare,	/* tp_compare */
    (reprfunc)oaOccInstTerm_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccInstTerm_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccInstTerm_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccInstTerm_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccInstTerm_static_find_doc[] = 
"Class: oaOccInstTerm, Function: find\n"
"  Paramegers: (oaOccInst,oaOccTerm)\n"
"    Calls: oaOccInstTerm* find(const oaOccInst* inst,const oaOccTerm* term)\n"
"    Signature: find|ptr-oaOccInstTerm|cptr-oaOccInst,cptr-oaOccTerm,\n"
"    This function searches all of the instTerms associated with the specified instance and returns the one that is associated with the specified terminal. NULL is returned if no such terminal exists on the instance.\n"
"    inst\n"
"    The instance whose instTerms are searched\n"
"    term\n"
"    The terminal to use in the search\n"
"    oacTermNotInInstMasterForInstTerm\n"
"    oacInstTermInstUsesTermPosition\n"
"  Paramegers: (oaOccInst,oaModTerm)\n"
"    Calls: oaOccInstTerm* find(const oaOccInst* inst,const oaModTerm* term)\n"
"    Signature: find|ptr-oaOccInstTerm|cptr-oaOccInst,cptr-oaModTerm,\n"
"    This function returns the occInstTerm that is associated with the given oaOccInst and oaModTerm . It returns NULL if no such occInstTerm exists on the instance.\n"
"    inst\n"
"    The instance whose instTerms are searched.\n"
"    term\n"
"    The terminal to use in the search.\n"
"    oacInstTermInstUsesTermPosition\n"
"    oacTermNotInInstMasterForInstTerm\n"
"  Paramegers: (oaOccInst,oaTerm)\n"
"    Calls: oaOccInstTerm* find(const oaOccInst* inst,const oaTerm* term)\n"
"    Signature: find|ptr-oaOccInstTerm|cptr-oaOccInst,cptr-oaTerm,\n"
"    This function returns the occInstTerm that is associated with the given oaOccInst and oaTerm . It returns NULL if no such occInstTerm exists on the instance.\n"
"    inst\n"
"    The instance whose instTerms are searched.\n"
"    term\n"
"    The terminal to use in the search.\n"
"    oacInstTermInstUsesTermPosition\n"
"    oacTermNotInInstMasterForInstTerm\n"
"  Paramegers: (oaOccInst,oaName)\n"
"    Calls: oaOccInstTerm* find(const oaOccInst* inst,const oaName& termName)\n"
"    Signature: find|ptr-oaOccInstTerm|cptr-oaOccInst,cref-oaName,\n"
"    This function searches all of the instTerms associated with the specified instance and returns the one that is associated with the specified terminal name. NULL is returned if no such terminal exists on the instance.\n"
"    If the termName is hierarchical, then this function searches through the hierarchy path for the specified instTerm. If the termName is a bundle name, and any of its members has hierarchy, all of its members must have the same level of hierarchy or an exception is thrown.\n"
"    inst\n"
"    The instance whose instTerms are searched\n"
"    termName\n"
"    The terminal name to use in the search\n"
"    oacInstTermInstUsesTermPosition\n"
"  Paramegers: (oaOccInst,oaUInt4)\n"
"    Calls: oaOccInstTerm* find(const oaOccInst* inst,oaUInt4 termPosition)\n"
"    Signature: find|ptr-oaOccInstTerm|cptr-oaOccInst,simple-oaUInt4,\n"
"    This function searches all of the instTerms associated with the specified instance and returns the one that makes a connection to the specified terminal position. NULL is returned if no terminal exists in the instance master at the specified position.\n"
"    inst\n"
"    The instance whose instTerms are searched\n"
"    termPosition\n"
"    The terminal position used in the search\n"
"    oacInstTermInstUsesTermName\n"
;

static PyObject*
oaOccInstTerm_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaOccInst,oaOccTerm)
    {
        PyParamoaOccInst p1;
        PyParamoaOccTerm p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaOccInst_Convert,&p1,
              &PyoaOccTerm_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaOccInstTermp result= (oaOccInstTerm::find(p1.Data(),p2.Data()));
            return PyoaOccInstTerm_FromoaOccInstTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaOccInst,oaModTerm)
    {
        PyParamoaOccInst p1;
        PyParamoaModTerm p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaOccInst_Convert,&p1,
              &PyoaModTerm_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaOccInstTermp result= (oaOccInstTerm::find(p1.Data(),p2.Data()));
            return PyoaOccInstTerm_FromoaOccInstTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaOccInst,oaTerm)
    {
        PyParamoaOccInst p1;
        PyParamoaTerm p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaOccInst_Convert,&p1,
              &PyoaTerm_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaOccInstTermp result= (oaOccInstTerm::find(p1.Data(),p2.Data()));
            return PyoaOccInstTerm_FromoaOccInstTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaOccInst,oaName)
    {
        PyParamoaOccInst p1;
        PyParamoaName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaOccInst_Convert,&p1,
              &PyoaName_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaOccInstTermp result= (oaOccInstTerm::find(p1.Data(),p2.Data()));
            return PyoaOccInstTerm_FromoaOccInstTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaOccInst,oaUInt4)
    {
        PyParamoaOccInst p1;
        PyParamoaUInt4 p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaOccInst_Convert,&p1,
              &PyoaUInt4_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaOccInstTermp result= (oaOccInstTerm::find(p1.Data(),p2.Data()));
            return PyoaOccInstTerm_FromoaOccInstTerm(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccInstTerm, function: find, Choices are:\n"
        "    (oaOccInst,oaOccTerm)\n"
        "    (oaOccInst,oaModTerm)\n"
        "    (oaOccInst,oaTerm)\n"
        "    (oaOccInst,oaName)\n"
        "    (oaOccInst,oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaOccInstTerm_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaOccInstTerm_static_find,METH_VARARGS,oaOccInstTerm_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccInstTerm_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccInstTerm_Type)<0) {
      printf("** PyType_Ready failed for: oaOccInstTerm\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccInstTerm",
           (PyObject*)(&PyoaOccInstTerm_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccInstTerm\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaOccInstTerm_Type.tp_dict;
    for(method=oaOccInstTerm_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccLine
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccLine_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccLine_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccLineObject* self = (PyoaOccLineObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccLine)
    {
        PyParamoaOccLine p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccLine_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccLine, Choices are:\n"
        "    (oaOccLine)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccLine_tp_dealloc(PyoaOccLineObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccLine_tp_repr(PyObject *ob)
{
    PyParamoaOccLine value;
    int convert_status=PyoaOccLine_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[31];
    sprintf(buffer,"<oaOccLine::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccLine_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccLine v1;
    PyParamoaOccLine v2;
    int convert_status1=PyoaOccLine_Convert(ob1,&v1);
    int convert_status2=PyoaOccLine_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccLine_Convert(PyObject* ob,PyParamoaOccLine* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccLine_Check(ob)) {
        result->SetData( (oaOccLine**) ((PyoaOccLineObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccLine Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccLine_FromoaOccLine(oaOccLine** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccLine* data=*value;
        PyObject* bself = PyoaOccLine_Type.tp_alloc(&PyoaOccLine_Type,0);
        if (bself == NULL) return bself;
        PyoaOccLineObject* self = (PyoaOccLineObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccLine_FromoaOccLine(oaOccLine* data)
{
    if (data) {
       PyObject* bself = PyoaOccLine_Type.tp_alloc(&PyoaOccLine_Type,0);
       if (bself == NULL) return bself;
       PyoaOccLineObject* self = (PyoaOccLineObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccLine_getNumPoints_doc[] = 
"Class: oaOccLine, Function: getNumPoints\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumPoints() const\n"
"    Signature: getNumPoints|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of points in this line.\n"
;

static PyObject*
oaOccLine_getNumPoints(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccLine data;
    int convert_status=PyoaOccLine_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccLineObject* self=(PyoaOccLineObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumPoints());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccLine_getPoints_doc[] = 
"Class: oaOccLine, Function: getPoints\n"
"  Paramegers: (oaPointArray)\n"
"    Calls: void getPoints(oaPointArray& points) const\n"
"    Signature: getPoints|void-void|ref-oaPointArray,\n"
"    BrowseData: 0,oaPointArray\n"
"    This function fills out 'points' with the points of this line.\n"
"    points\n"
"    The point array to be filled.\n"
;

static PyObject*
oaOccLine_getPoints(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccLine data;
    int convert_status=PyoaOccLine_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccLineObject* self=(PyoaOccLineObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaPointArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaPointArray_Convert,&p1)) {
        data.DataCall()->getPoints(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccLine_isNull_doc[] =
"Class: oaOccLine, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccLine_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccLine data;
    int convert_status=PyoaOccLine_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccLine_assign_doc[] = 
"Class: oaOccLine, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccLine_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccLine data;
  int convert_status=PyoaOccLine_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccLine p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccLine_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccLine_methodlist[] = {
    {"getNumPoints",(PyCFunction)oaOccLine_getNumPoints,METH_VARARGS,oaOccLine_getNumPoints_doc},
    {"getPoints",(PyCFunction)oaOccLine_getPoints,METH_VARARGS,oaOccLine_getPoints_doc},
    {"isNull",(PyCFunction)oaOccLine_tp_isNull,METH_VARARGS,oaOccLine_isNull_doc},
    {"assign",(PyCFunction)oaOccLine_tp_assign,METH_VARARGS,oaOccLine_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccLine_doc[] = 
"Class: oaOccLine\n"
"  The oaOccLine class implements an unique occurrence of an oaLine object in a design hierarchy.\n"
"Constructors:\n"
"  Paramegers: (oaOccLine)\n"
"    Calls: (const oaOccLine&)\n"
"    Signature: oaOccLine||cref-oaOccLine,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccLine_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccLine",
    sizeof(PyoaOccLineObject),
    0,
    (destructor)oaOccLine_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccLine_tp_compare,	/* tp_compare */
    (reprfunc)oaOccLine_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccLine_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccLine_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccShape_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccLine_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccLine_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccLine_Type)<0) {
      printf("** PyType_Ready failed for: oaOccLine\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccLine",
           (PyObject*)(&PyoaOccLine_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccLine\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccMemNetCollection
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccMemNetCollection_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccMemNetCollection_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccMemNetCollectionObject* self = (PyoaOccMemNetCollectionObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccMemNetCollection, Choices are:\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccMemNetCollection_tp_dealloc(PyoaOccMemNetCollectionObject* self)
{
    if (!self->borrow) {
        delete (oaOccMemNetCollection*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccMemNetCollection_tp_repr(PyObject *ob)
{
    PyParamoaOccMemNetCollection value;
    int convert_status=PyoaOccMemNetCollection_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaOccMemNetCollection::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccMemNetCollection_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccMemNetCollection v1;
    PyParamoaOccMemNetCollection v2;
    int convert_status1=PyoaOccMemNetCollection_Convert(ob1,&v1);
    int convert_status2=PyoaOccMemNetCollection_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccMemNetCollection_Convert(PyObject* ob,PyParamoaOccMemNetCollection* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccMemNetCollection_Check(ob)) {
        result->SetData( (oaOccMemNetCollection*) ((PyoaOccMemNetCollectionObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccMemNetCollection Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccMemNetCollection_FromoaOccMemNetCollection(oaOccMemNetCollection* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaOccMemNetCollection_Type.tp_alloc(&PyoaOccMemNetCollection_Type,0);
        if (bself == NULL) return bself;
        PyoaOccMemNetCollectionObject* self = (PyoaOccMemNetCollectionObject*)bself;
        self->value = (oaBaseMemNetCollection*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccMemNetCollection_includes_doc[] = 
"Class: oaOccMemNetCollection, Function: includes\n"
"  Paramegers: (oaOccNet)\n"
"    Calls: oaBoolean includes(const oaOccNet* object)\n"
"    Signature: includes|simple-oaBoolean|cptr-oaOccNet,\n"
"    This functions determines if the specified occurrence net is a member of the collection.\n"
;

static PyObject*
oaOccMemNetCollection_includes(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccMemNetCollection data;
    int convert_status=PyoaOccMemNetCollection_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccMemNetCollectionObject* self=(PyoaOccMemNetCollectionObject*)ob;

    PyParamoaOccNet p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccNet_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->includes(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaOccMemNetCollection_assign_doc[] = 
"Class: oaOccMemNetCollection, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccMemNetCollection_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccMemNetCollection data;
  int convert_status=PyoaOccMemNetCollection_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccMemNetCollection p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccMemNetCollection_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccMemNetCollection_methodlist[] = {
    {"includes",(PyCFunction)oaOccMemNetCollection_includes,METH_VARARGS,oaOccMemNetCollection_includes_doc},
    {"assign",(PyCFunction)oaOccMemNetCollection_tp_assign,METH_VARARGS,oaOccMemNetCollection_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccMemNetCollection_doc[] = 
"Class: oaOccMemNetCollection\n"
"  The member net collection class represents a collection of nets that the starting net is a member of. The oaOccMemNetCollection is such a collection of oaOccNet objects in the occuttence domain. Examples are that a[1] is a member of a[4:0] . All explicit nets are members of themselves and so have a non-empty member net collection. See oaNet::getMemberNets() for a complete description of which nets are members of which other nets.\n"
"  The oaOccMemNetCollection class is a specialized collection class because the oaOccMemNetIter used to iterate over it does not have the standard getNext signature use by the template collection classes.\n"
"  The most common way to use an oaOccMemNetCollection is to use it inline in the construction of an oaOccMemNetIter , so the oaOccMemNetCollection is never explicitly declared. In the following example, occnet->getMemberNets() returns an oaOccMemNetCollection.\n"
"  oaOccMemNetIter nIter(occnet->getMemberNets()); while ( oaOccNet *onet = nIter.getNext()) { ... }\n"
"Constructors:\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccMemNetCollection_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccMemNetCollection",
    sizeof(PyoaOccMemNetCollectionObject),
    0,
    (destructor)oaOccMemNetCollection_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccMemNetCollection_tp_compare,	/* tp_compare */
    (reprfunc)oaOccMemNetCollection_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccMemNetCollection_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccMemNetCollection_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaBaseMemNetCollection_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccMemNetCollection_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccMemNetCollection_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccMemNetCollection_Type)<0) {
      printf("** PyType_Ready failed for: oaOccMemNetCollection\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccMemNetCollection",
           (PyObject*)(&PyoaOccMemNetCollection_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccMemNetCollection\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccMemNetIter
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccMemNetIter_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccMemNetIter_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccMemNetIterObject* self = (PyoaOccMemNetIterObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccMemNetCollection)
    {
        PyParamoaOccMemNetCollection p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaOccMemNetCollection_Convert,&p1)) {
            self->value = (oaBaseMemNetIter*)  new oaOccMemNetIter(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaOccMemNetIter)
    {
        PyParamoaOccMemNetIter p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaOccMemNetIter_Convert,&p1)) {
            self->value = (oaBaseMemNetIter*)  new oaOccMemNetIter(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccMemNetIter, Choices are:\n"
        "    (oaOccMemNetCollection)\n"
        "    (oaOccMemNetIter)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccMemNetIter_tp_dealloc(PyoaOccMemNetIterObject* self)
{
    if (!self->borrow) {
        delete (oaOccMemNetIter*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccMemNetIter_tp_repr(PyObject *ob)
{
    PyParamoaOccMemNetIter value;
    int convert_status=PyoaOccMemNetIter_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[37];
    sprintf(buffer,"<oaOccMemNetIter::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccMemNetIter_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccMemNetIter v1;
    PyParamoaOccMemNetIter v2;
    int convert_status1=PyoaOccMemNetIter_Convert(ob1,&v1);
    int convert_status2=PyoaOccMemNetIter_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
static PyObject*
oaOccMemNetIter_getiter(PyObject *self)
{
    Py_INCREF(self);
    return self;
}

// ------------------------------------------------------------------
PyObject* oaOccMemNetIter_iternext(PyObject *self);

// ------------------------------------------------------------------
int
PyoaOccMemNetIter_Convert(PyObject* ob,PyParamoaOccMemNetIter* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccMemNetIter_Check(ob)) {
        result->SetData( (oaOccMemNetIter*) ((PyoaOccMemNetIterObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccMemNetIter Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccMemNetIter_FromoaOccMemNetIter(oaOccMemNetIter* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaOccMemNetIter_Type.tp_alloc(&PyoaOccMemNetIter_Type,0);
        if (bself == NULL) return bself;
        PyoaOccMemNetIterObject* self = (PyoaOccMemNetIterObject*)bself;
        self->value = (oaBaseMemNetIter*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccMemNetIter_getNext_doc[] = 
"Class: oaOccMemNetIter, Function: getNext\n"
"  Paramegers: ()\n"
"    Calls: oaOccNet* getNext()\n"
"    Signature: getNext|ptr-oaOccNet|ref-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the next object in the collection that is being iterated. NULL is returned when there are no more objects to return.\n"
"    arg\n"
"    The member index of the current net in the returned net\n"
;

extern PyObject* oaOccMemNetIter_getNext(PyObject *self, PyObject *args);

// ------------------------------------------------------------------
static char oaOccMemNetIter_next_doc[] = 
"Class: oaOccMemNetIter, Function: next\n"
"  Paramegers: ()\n"
"    Calls: oaOccNet* next()\n"
"    Signature: next|ptr-oaOccNet|,\n"
"    BrowseData: 1\n"
"    get next value or raise StopIteration\n"
;

extern PyObject* oaOccMemNetIter_next(PyObject *self, PyObject *args);

static char oaOccMemNetIter_assign_doc[] = 
"Class: oaOccMemNetIter, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccMemNetIter_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccMemNetIter data;
  int convert_status=PyoaOccMemNetIter_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccMemNetIter p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccMemNetIter_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccMemNetIter_methodlist[] = {
    {"getNext",(PyCFunction)oaOccMemNetIter_getNext,METH_VARARGS,oaOccMemNetIter_getNext_doc},
    {"next",(PyCFunction)oaOccMemNetIter_next,METH_VARARGS,oaOccMemNetIter_next_doc},
    {"assign",(PyCFunction)oaOccMemNetIter_tp_assign,METH_VARARGS,oaOccMemNetIter_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccMemNetIter_doc[] = 
"Class: oaOccMemNetIter\n"
"  The oaOccMemNetIter class implements a special case iterator. This class returns member oaNets of an oaOccMemNetCollection . A collection of member nets is all those nets of whom the current net is a member. Because all nets are members of themselves, this iterator will always return at least one net.\n"
"  For example, a collection of member nets for net a would contain all of the following nets:\n"
"  a\n"
"  x,y,a\n"
"  a*4\n"
"  The member net index is returned in the getNext() function. This index indicates the member position of the specified net in the collection. For the example above, the iterator would return the following values:\n"
"  a 0\n"
"  x,y,a 2\n"
"  a*4 0\n"
"  a*4 1\n"
"  a*4 2\n"
"  a*4 3\n"
"  This particular collection and iterator are primarily for those applications that want to traverse single-bit connectivity.\n"
"Constructors:\n"
"  Paramegers: (oaOccMemNetCollection)\n"
"    Calls: oaOccMemNetIter(const oaOccMemNetCollection& cl)\n"
"    Signature: oaOccMemNetIter||cref-oaOccMemNetCollection,\n"
"    This function constructs a new oaOccMemNetIter object according to the specified memNet collection cl .\n"
"    cl\n"
"    The specified oaOccMemNetCollection object\n"
"  Paramegers: (oaOccMemNetIter)\n"
"    Calls: oaOccMemNetIter(const oaOccMemNetIter& iterIn)\n"
"    Signature: oaOccMemNetIter||cref-oaOccMemNetIter,\n"
"    This function constructs a new oaOccMemNetIter class and iterates over the same set of objects as the specified oaOccMemNetIter iterator. The new iterator starts at the beginning of the collection.\n"
"    iterIn\n"
"    The iterator value to use\n"
"  Paramegers: (oaOccMemNetIter)\n"
"    Calls: (const oaOccMemNetIter&)\n"
"    Signature: oaOccMemNetIter||cref-oaOccMemNetIter,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccMemNetIter_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccMemNetIter",
    sizeof(PyoaOccMemNetIterObject),
    0,
    (destructor)oaOccMemNetIter_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccMemNetIter_tp_compare,	/* tp_compare */
    (reprfunc)oaOccMemNetIter_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccMemNetIter_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    (getiterfunc)oaOccMemNetIter_getiter,	/* tp_iter */
    (iternextfunc)oaOccMemNetIter_iternext,	/* tp_iternext */
    oaOccMemNetIter_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaBaseMemNetIter_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccMemNetIter_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccMemNetIter_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccMemNetIter_Type)<0) {
      printf("** PyType_Ready failed for: oaOccMemNetIter\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccMemNetIter",
           (PyObject*)(&PyoaOccMemNetIter_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccMemNetIter\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccModuleBitInst
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccModuleBitInst_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccModuleBitInst_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccModuleBitInstObject* self = (PyoaOccModuleBitInstObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccModuleBitInst)
    {
        PyParamoaOccModuleBitInst p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccModuleBitInst_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccModuleBitInst, Choices are:\n"
        "    (oaOccModuleBitInst)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccModuleBitInst_tp_dealloc(PyoaOccModuleBitInstObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccModuleBitInst_tp_repr(PyObject *ob)
{
    PyParamoaOccModuleBitInst value;
    int convert_status=PyoaOccModuleBitInst_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaOccModuleBitInst::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaSimpleName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[40];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaOccModuleBitInst::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccModuleBitInst_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccModuleBitInst v1;
    PyParamoaOccModuleBitInst v2;
    int convert_status1=PyoaOccModuleBitInst_Convert(ob1,&v1);
    int convert_status2=PyoaOccModuleBitInst_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccModuleBitInst_Convert(PyObject* ob,PyParamoaOccModuleBitInst* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccModuleBitInst_Check(ob)) {
        result->SetData( (oaOccModuleBitInst**) ((PyoaOccModuleBitInstObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccModuleBitInst Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccModuleBitInst_FromoaOccModuleBitInst(oaOccModuleBitInst** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccModuleBitInst* data=*value;
        if (data->getType()==oacOccModuleVectorInstBitType) return PyoaOccModuleVectorInstBit_FromoaOccModuleVectorInstBit((oaOccModuleVectorInstBit**)value,borrow,lock);
        if (data->getType()==oacOccModuleScalarInstType) return PyoaOccModuleScalarInst_FromoaOccModuleScalarInst((oaOccModuleScalarInst**)value,borrow,lock);
        PyObject* bself = PyoaOccModuleBitInst_Type.tp_alloc(&PyoaOccModuleBitInst_Type,0);
        if (bself == NULL) return bself;
        PyoaOccModuleBitInstObject* self = (PyoaOccModuleBitInstObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccModuleBitInst_FromoaOccModuleBitInst(oaOccModuleBitInst* data)
{
    if (data) {
        if (data->getType()==oacOccModuleVectorInstBitType) return PyoaOccModuleVectorInstBit_FromoaOccModuleVectorInstBit((oaOccModuleVectorInstBit*)data);
        if (data->getType()==oacOccModuleScalarInstType) return PyoaOccModuleScalarInst_FromoaOccModuleScalarInst((oaOccModuleScalarInst*)data);
       PyObject* bself = PyoaOccModuleBitInst_Type.tp_alloc(&PyoaOccModuleBitInst_Type,0);
       if (bself == NULL) return bself;
       PyoaOccModuleBitInstObject* self = (PyoaOccModuleBitInstObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccModuleBitInst_doc[] = 
"Class: oaOccModuleBitInst\n"
"  The oaOccModuleBitInst class is the base of all scalar instances of a master module. oaOccModuleBitInst objects refer to a master module and are always in the occurrence domain.\n"
"Constructors:\n"
"  Paramegers: (oaOccModuleBitInst)\n"
"    Calls: (const oaOccModuleBitInst&)\n"
"    Signature: oaOccModuleBitInst||cref-oaOccModuleBitInst,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccModuleBitInst_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccModuleBitInst",
    sizeof(PyoaOccModuleBitInstObject),
    0,
    (destructor)oaOccModuleBitInst_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccModuleBitInst_tp_compare,	/* tp_compare */
    (reprfunc)oaOccModuleBitInst_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccModuleBitInst_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccModuleInst_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccModuleBitInst_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccModuleBitInst_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccModuleBitInst_Type)<0) {
      printf("** PyType_Ready failed for: oaOccModuleBitInst\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccModuleBitInst",
           (PyObject*)(&PyoaOccModuleBitInst_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccModuleBitInst\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccModuleInst
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccModuleInst_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccModuleInst_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccModuleInstObject* self = (PyoaOccModuleInstObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccModuleInst)
    {
        PyParamoaOccModuleInst p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccModuleInst_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccModuleInst, Choices are:\n"
        "    (oaOccModuleInst)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccModuleInst_tp_dealloc(PyoaOccModuleInstObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccModuleInst_tp_repr(PyObject *ob)
{
    PyParamoaOccModuleInst value;
    int convert_status=PyoaOccModuleInst_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaOccModuleInst::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaSimpleName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[37];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaOccModuleInst::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccModuleInst_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccModuleInst v1;
    PyParamoaOccModuleInst v2;
    int convert_status1=PyoaOccModuleInst_Convert(ob1,&v1);
    int convert_status2=PyoaOccModuleInst_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccModuleInst_Convert(PyObject* ob,PyParamoaOccModuleInst* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccModuleInst_Check(ob)) {
        result->SetData( (oaOccModuleInst**) ((PyoaOccModuleInstObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccModuleInst Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccModuleInst_FromoaOccModuleInst(oaOccModuleInst** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccModuleInst* data=*value;
        if (data->getType()==oacOccModuleVectorInstBitType) return PyoaOccModuleVectorInstBit_FromoaOccModuleVectorInstBit((oaOccModuleVectorInstBit**)value,borrow,lock);
        if (data->getType()==oacOccModuleScalarInstType) return PyoaOccModuleScalarInst_FromoaOccModuleScalarInst((oaOccModuleScalarInst**)value,borrow,lock);
        if (data->getType()==oacOccModuleVectorInstType) return PyoaOccModuleVectorInst_FromoaOccModuleVectorInst((oaOccModuleVectorInst**)value,borrow,lock);
        PyObject* bself = PyoaOccModuleInst_Type.tp_alloc(&PyoaOccModuleInst_Type,0);
        if (bself == NULL) return bself;
        PyoaOccModuleInstObject* self = (PyoaOccModuleInstObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccModuleInst_FromoaOccModuleInst(oaOccModuleInst* data)
{
    if (data) {
        if (data->getType()==oacOccModuleVectorInstBitType) return PyoaOccModuleVectorInstBit_FromoaOccModuleVectorInstBit((oaOccModuleVectorInstBit*)data);
        if (data->getType()==oacOccModuleScalarInstType) return PyoaOccModuleScalarInst_FromoaOccModuleScalarInst((oaOccModuleScalarInst*)data);
        if (data->getType()==oacOccModuleVectorInstType) return PyoaOccModuleVectorInst_FromoaOccModuleVectorInst((oaOccModuleVectorInst*)data);
       PyObject* bself = PyoaOccModuleInst_Type.tp_alloc(&PyoaOccModuleInst_Type,0);
       if (bself == NULL) return bself;
       PyoaOccModuleInstObject* self = (PyoaOccModuleInstObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccModuleInst_getHeader_doc[] = 
"Class: oaOccModuleInst, Function: getHeader\n"
"  Paramegers: ()\n"
"    Calls: oaOccModuleInstHeader* getHeader() const\n"
"    Signature: getHeader|ptr-oaOccModuleInstHeader|\n"
"    BrowseData: 1\n"
"    This function returns the instHeader associated with this instance. The module instHeader is a collection of the attributes that are common to all instances of a particular module master.\n"
"    The pointer to the instance header\n"
;

static PyObject*
oaOccModuleInst_getHeader(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleInst data;
    int convert_status=PyoaOccModuleInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleInstObject* self=(PyoaOccModuleInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaOccModuleInstHeaderp result= (data.DataCall()->getHeader());
        return PyoaOccModuleInstHeader_FromoaOccModuleInstHeader(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleInst_getMaster_doc[] = 
"Class: oaOccModuleInst, Function: getMaster\n"
"  Paramegers: ()\n"
"    Calls: oaModule* getMaster() const\n"
"    Signature: getMaster|ptr-oaModule|\n"
"    BrowseData: 1\n"
"    This function attempts to return the master module associated with this instance. If the instance is not previously bound, it attempts to open the master and bind this instance. If the instance cannot be bound, NULL is returned.\n"
;

static PyObject*
oaOccModuleInst_getMaster(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleInst data;
    int convert_status=PyoaOccModuleInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleInstObject* self=(PyoaOccModuleInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModulep result= (data.DataCall()->getMaster());
        return PyoaModule_FromoaModule(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleInst_getModInst_doc[] = 
"Class: oaOccModuleInst, Function: getModInst\n"
"  Paramegers: ()\n"
"    Calls: oaModModuleInst* getModInst() const\n"
"    Signature: getModInst|ptr-oaModModuleInst|\n"
"    BrowseData: 1\n"
"    This function returns the corresponding module instance in the module domain.\n"
"    The oaModModuleInst pointer\n"
;

static PyObject*
oaOccModuleInst_getModInst(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleInst data;
    int convert_status=PyoaOccModuleInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleInstObject* self=(PyoaOccModuleInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModModuleInstp result= (data.DataCall()->getModInst());
        return PyoaModModuleInst_FromoaModModuleInst(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleInst_isNull_doc[] =
"Class: oaOccModuleInst, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccModuleInst_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccModuleInst data;
    int convert_status=PyoaOccModuleInst_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccModuleInst_assign_doc[] = 
"Class: oaOccModuleInst, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccModuleInst_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccModuleInst data;
  int convert_status=PyoaOccModuleInst_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccModuleInst p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccModuleInst_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccModuleInst_methodlist[] = {
    {"getHeader",(PyCFunction)oaOccModuleInst_getHeader,METH_VARARGS,oaOccModuleInst_getHeader_doc},
    {"getMaster",(PyCFunction)oaOccModuleInst_getMaster,METH_VARARGS,oaOccModuleInst_getMaster_doc},
    {"getModInst",(PyCFunction)oaOccModuleInst_getModInst,METH_VARARGS,oaOccModuleInst_getModInst_doc},
    {"isNull",(PyCFunction)oaOccModuleInst_tp_isNull,METH_VARARGS,oaOccModuleInst_isNull_doc},
    {"assign",(PyCFunction)oaOccModuleInst_tp_assign,METH_VARARGS,oaOccModuleInst_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccModuleInst_doc[] = 
"Class: oaOccModuleInst\n"
"  The oaOccModuleInst class implements a occurence of an instance of a master module. oaOccModuleInst objects refer to a master module and are always in the occurrence domain.\n"
"Constructors:\n"
"  Paramegers: (oaOccModuleInst)\n"
"    Calls: (const oaOccModuleInst&)\n"
"    Signature: oaOccModuleInst||cref-oaOccModuleInst,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccModuleInst_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccModuleInst",
    sizeof(PyoaOccModuleInstObject),
    0,
    (destructor)oaOccModuleInst_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccModuleInst_tp_compare,	/* tp_compare */
    (reprfunc)oaOccModuleInst_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccModuleInst_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccModuleInst_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccInst_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccModuleInst_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccModuleInst_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccModuleInst_Type)<0) {
      printf("** PyType_Ready failed for: oaOccModuleInst\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccModuleInst",
           (PyObject*)(&PyoaOccModuleInst_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccModuleInst\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccModuleInstHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccModuleInstHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccModuleInstHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccModuleInstHeaderObject* self = (PyoaOccModuleInstHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccModuleInstHeader)
    {
        PyParamoaOccModuleInstHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccModuleInstHeader_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccModuleInstHeader, Choices are:\n"
        "    (oaOccModuleInstHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccModuleInstHeader_tp_dealloc(PyoaOccModuleInstHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccModuleInstHeader_tp_repr(PyObject *ob)
{
    PyParamoaOccModuleInstHeader value;
    int convert_status=PyoaOccModuleInstHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaOccModuleInstHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccModuleInstHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccModuleInstHeader v1;
    PyParamoaOccModuleInstHeader v2;
    int convert_status1=PyoaOccModuleInstHeader_Convert(ob1,&v1);
    int convert_status2=PyoaOccModuleInstHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccModuleInstHeader_Convert(PyObject* ob,PyParamoaOccModuleInstHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccModuleInstHeader_Check(ob)) {
        result->SetData( (oaOccModuleInstHeader**) ((PyoaOccModuleInstHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccModuleInstHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccModuleInstHeader_FromoaOccModuleInstHeader(oaOccModuleInstHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccModuleInstHeader* data=*value;
        PyObject* bself = PyoaOccModuleInstHeader_Type.tp_alloc(&PyoaOccModuleInstHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaOccModuleInstHeaderObject* self = (PyoaOccModuleInstHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccModuleInstHeader_FromoaOccModuleInstHeader(oaOccModuleInstHeader* data)
{
    if (data) {
       PyObject* bself = PyoaOccModuleInstHeader_Type.tp_alloc(&PyoaOccModuleInstHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaOccModuleInstHeaderObject* self = (PyoaOccModuleInstHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccModuleInstHeader_getInsts_doc[] = 
"Class: oaOccModuleInstHeader, Function: getInsts\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaOccModuleInst_oaOccModuleInstHeader getInsts() const\n"
"    Signature: getInsts|simple-oaCollection_oaOccModuleInst_oaOccModuleInstHeader|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns a collection of instances associated with this instHeader. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaOccModuleInst_oaOccModuleInstHeader getInsts(oaUInt4 filterFlags) const\n"
"    Signature: getInsts|simple-oaCollection_oaOccModuleInst_oaOccModuleInstHeader|simple-oaUInt4,\n"
"    This function returns a collection of instances associated with this instHeader. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
;

static PyObject*
oaOccModuleInstHeader_getInsts(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleInstHeader data;
    int convert_status=PyoaOccModuleInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleInstHeaderObject* self=(PyoaOccModuleInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaOccModuleInst_oaOccModuleInstHeader* result= new oaCollection_oaOccModuleInst_oaOccModuleInstHeader(data.DataCall()->getInsts());
            return PyoaCollection_oaOccModuleInst_oaOccModuleInstHeader_FromoaCollection_oaOccModuleInst_oaOccModuleInstHeader(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaOccModuleInst_oaOccModuleInstHeader* result= new oaCollection_oaOccModuleInst_oaOccModuleInstHeader(data.DataCall()->getInsts(p1.Data()));
            return PyoaCollection_oaOccModuleInst_oaOccModuleInstHeader_FromoaCollection_oaOccModuleInst_oaOccModuleInstHeader(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccModuleInstHeader, function: getInsts, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleInstHeader_getInstsIter_doc[] = 
"Class: oaOccModuleInstHeader, Function: getInstsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaOccModuleInst getInstsIter() const\n"
"    Signature: getInstsIter|simple-oaIter_oaOccModuleInst|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of instances associated with this instHeader. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaOccModuleInst getInstsIter(oaUInt4 filterFlags) const\n"
"    Signature: getInstsIter|simple-oaIter_oaOccModuleInst|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of instances associated with this instHeader. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
;

static PyObject*
oaOccModuleInstHeader_getInstsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleInstHeader data;
    int convert_status=PyoaOccModuleInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleInstHeaderObject* self=(PyoaOccModuleInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaOccModuleInst* result= new oaIter_oaOccModuleInst(data.DataCall()->getInsts());
            return PyoaIter_oaOccModuleInst_FromoaIter_oaOccModuleInst(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaOccModuleInst* result= new oaIter_oaOccModuleInst(data.DataCall()->getInsts(p1.Data()));
            return PyoaIter_oaOccModuleInst_FromoaIter_oaOccModuleInst(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccModuleInstHeader, function: getInstsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleInstHeader_getMaster_doc[] = 
"Class: oaOccModuleInstHeader, Function: getMaster\n"
"  Paramegers: ()\n"
"    Calls: oaModule* getMaster() const\n"
"    Signature: getMaster|ptr-oaModule|\n"
"    BrowseData: 1\n"
"    This function attempts to return the master module associated with this module instHeader. If the instHeader is bound, the master module is returned. Otherwise, NULL is returned.\n"
;

static PyObject*
oaOccModuleInstHeader_getMaster(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleInstHeader data;
    int convert_status=PyoaOccModuleInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleInstHeaderObject* self=(PyoaOccModuleInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModulep result= (data.DataCall()->getMaster());
        return PyoaModule_FromoaModule(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleInstHeader_getMasterOccurrence_doc[] = 
"Class: oaOccModuleInstHeader, Function: getMasterOccurrence\n"
"  Paramegers: ()\n"
"    Calls: oaOccurrence* getMasterOccurrence() const\n"
"    Signature: getMasterOccurrence|ptr-oaOccurrence|simple-oaBoolean,\n"
"    BrowseData: 1\n"
"    This function attempts to return the occurrence master associated with this module instHeader. If expand is true and the instHeader cannot be bound, NULL is returned.\n"
"    expand\n"
"    Specifies whether to expand the occurrence hierarchy to include the master occurrence for this instHeader, if it has not yet been expanded in the current session.\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: oaOccurrence* getMasterOccurrence(oaBoolean expand) const\n"
"    Signature: getMasterOccurrence|ptr-oaOccurrence|simple-oaBoolean,\n"
"    This function attempts to return the occurrence master associated with this module instHeader. If expand is true and the instHeader cannot be bound, NULL is returned.\n"
"    expand\n"
"    Specifies whether to expand the occurrence hierarchy to include the master occurrence for this instHeader, if it has not yet been expanded in the current session.\n"
;

static PyObject*
oaOccModuleInstHeader_getMasterOccurrence(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleInstHeader data;
    int convert_status=PyoaOccModuleInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleInstHeaderObject* self=(PyoaOccModuleInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaOccurrencep result= (data.DataCall()->getMasterOccurrence());
            return PyoaOccurrence_FromoaOccurrence(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            oaOccurrencep result= (data.DataCall()->getMasterOccurrence(p1.Data()));
            return PyoaOccurrence_FromoaOccurrence(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccModuleInstHeader, function: getMasterOccurrence, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleInstHeader_getModModuleInstHeader_doc[] = 
"Class: oaOccModuleInstHeader, Function: getModModuleInstHeader\n"
"  Paramegers: ()\n"
"    Calls: oaModModuleInstHeader* getModModuleInstHeader() const\n"
"    Signature: getModModuleInstHeader|ptr-oaModModuleInstHeader|\n"
"    BrowseData: 1\n"
"    This function returns the module domain object referenced by this occurrence instHeader.\n"
;

static PyObject*
oaOccModuleInstHeader_getModModuleInstHeader(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleInstHeader data;
    int convert_status=PyoaOccModuleInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleInstHeaderObject* self=(PyoaOccModuleInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModModuleInstHeaderp result= (data.DataCall()->getModModuleInstHeader());
        return PyoaModModuleInstHeader_FromoaModModuleInstHeader(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleInstHeader_getName_doc[] = 
"Class: oaOccModuleInstHeader, Function: getName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getName(oaScalarName& name) const\n"
"    Signature: getName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the module name referenced by this instHeader in the specified name argument.\n"
"    name\n"
"    The returned name as an oaScalarName\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the module name referenced by this instHeader in the specified nameSpace in the specified name string.\n"
"    ns\n"
"    The namespace used to map the name\n"
"    name\n"
"    The returned name string\n"
;

static PyObject*
oaOccModuleInstHeader_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleInstHeader data;
    int convert_status=PyoaOccModuleInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleInstHeaderObject* self=(PyoaOccModuleInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccModuleInstHeader, function: getName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleInstHeader_isBound_doc[] = 
"Class: oaOccModuleInstHeader, Function: isBound\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isBound() const\n"
"    Signature: isBound|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value that indicates if this instHeader is bound to its master module. A bound master means the master is read in and the linkage from the instHeader is established by traversing from an instance to that master.\n"
;

static PyObject*
oaOccModuleInstHeader_isBound(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleInstHeader data;
    int convert_status=PyoaOccModuleInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleInstHeaderObject* self=(PyoaOccModuleInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isBound());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleInstHeader_isNull_doc[] =
"Class: oaOccModuleInstHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccModuleInstHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccModuleInstHeader data;
    int convert_status=PyoaOccModuleInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccModuleInstHeader_assign_doc[] = 
"Class: oaOccModuleInstHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccModuleInstHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccModuleInstHeader data;
  int convert_status=PyoaOccModuleInstHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccModuleInstHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccModuleInstHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccModuleInstHeader_methodlist[] = {
    {"getInsts",(PyCFunction)oaOccModuleInstHeader_getInsts,METH_VARARGS,oaOccModuleInstHeader_getInsts_doc},
    {"getInstsIter",(PyCFunction)oaOccModuleInstHeader_getInstsIter,METH_VARARGS,oaOccModuleInstHeader_getInstsIter_doc},
    {"getMaster",(PyCFunction)oaOccModuleInstHeader_getMaster,METH_VARARGS,oaOccModuleInstHeader_getMaster_doc},
    {"getMasterOccurrence",(PyCFunction)oaOccModuleInstHeader_getMasterOccurrence,METH_VARARGS,oaOccModuleInstHeader_getMasterOccurrence_doc},
    {"getModModuleInstHeader",(PyCFunction)oaOccModuleInstHeader_getModModuleInstHeader,METH_VARARGS,oaOccModuleInstHeader_getModModuleInstHeader_doc},
    {"getName",(PyCFunction)oaOccModuleInstHeader_getName,METH_VARARGS,oaOccModuleInstHeader_getName_doc},
    {"isBound",(PyCFunction)oaOccModuleInstHeader_isBound,METH_VARARGS,oaOccModuleInstHeader_isBound_doc},
    {"isNull",(PyCFunction)oaOccModuleInstHeader_tp_isNull,METH_VARARGS,oaOccModuleInstHeader_isNull_doc},
    {"assign",(PyCFunction)oaOccModuleInstHeader_tp_assign,METH_VARARGS,oaOccModuleInstHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccModuleInstHeader_doc[] = 
"Class: oaOccModuleInstHeader\n"
"  The oaOccModuleInstHeader class implements an object that contains information common to all the logical instances of a particular master module in a given parent occurrence. oaOccModuleInstHeader objects is in occurrence domain and is scoped within the owner occurrence.\n"
"  The oaOccModuleInstHeader class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaOccModuleInstHeader)\n"
"    Calls: (const oaOccModuleInstHeader&)\n"
"    Signature: oaOccModuleInstHeader||cref-oaOccModuleInstHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccModuleInstHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccModuleInstHeader",
    sizeof(PyoaOccModuleInstHeaderObject),
    0,
    (destructor)oaOccModuleInstHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccModuleInstHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaOccModuleInstHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccModuleInstHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccModuleInstHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccModuleInstHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccModuleInstHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccModuleInstHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaOccModuleInstHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccModuleInstHeader",
           (PyObject*)(&PyoaOccModuleInstHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccModuleInstHeader\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccModuleScalarInst
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccModuleScalarInst_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccModuleScalarInst_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccModuleScalarInstObject* self = (PyoaOccModuleScalarInstObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccModuleScalarInst)
    {
        PyParamoaOccModuleScalarInst p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccModuleScalarInst_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccModuleScalarInst, Choices are:\n"
        "    (oaOccModuleScalarInst)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccModuleScalarInst_tp_dealloc(PyoaOccModuleScalarInstObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccModuleScalarInst_tp_repr(PyObject *ob)
{
    PyParamoaOccModuleScalarInst value;
    int convert_status=PyoaOccModuleScalarInst_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaOccModuleScalarInst::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaSimpleName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[43];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaOccModuleScalarInst::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccModuleScalarInst_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccModuleScalarInst v1;
    PyParamoaOccModuleScalarInst v2;
    int convert_status1=PyoaOccModuleScalarInst_Convert(ob1,&v1);
    int convert_status2=PyoaOccModuleScalarInst_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccModuleScalarInst_Convert(PyObject* ob,PyParamoaOccModuleScalarInst* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccModuleScalarInst_Check(ob)) {
        result->SetData( (oaOccModuleScalarInst**) ((PyoaOccModuleScalarInstObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccModuleScalarInst Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccModuleScalarInst_FromoaOccModuleScalarInst(oaOccModuleScalarInst** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccModuleScalarInst* data=*value;
        PyObject* bself = PyoaOccModuleScalarInst_Type.tp_alloc(&PyoaOccModuleScalarInst_Type,0);
        if (bself == NULL) return bself;
        PyoaOccModuleScalarInstObject* self = (PyoaOccModuleScalarInstObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccModuleScalarInst_FromoaOccModuleScalarInst(oaOccModuleScalarInst* data)
{
    if (data) {
       PyObject* bself = PyoaOccModuleScalarInst_Type.tp_alloc(&PyoaOccModuleScalarInst_Type,0);
       if (bself == NULL) return bself;
       PyoaOccModuleScalarInstObject* self = (PyoaOccModuleScalarInstObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccModuleScalarInst_getModInst_doc[] = 
"Class: oaOccModuleScalarInst, Function: getModInst\n"
"  Paramegers: ()\n"
"    Calls: oaModModuleScalarInst* getModInst() const\n"
"    Signature: getModInst|ptr-oaModModuleScalarInst|\n"
"    BrowseData: 1\n"
"    This function returns the corresponding module instance in the module domain.\n"
"    The oaModModuleScalarInst pointer\n"
;

static PyObject*
oaOccModuleScalarInst_getModInst(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleScalarInst data;
    int convert_status=PyoaOccModuleScalarInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleScalarInstObject* self=(PyoaOccModuleScalarInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModModuleScalarInstp result= (data.DataCall()->getModInst());
        return PyoaModModuleScalarInst_FromoaModModuleScalarInst(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleScalarInst_getName_doc[] = 
"Class: oaOccModuleScalarInst, Function: getName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getName(oaScalarName& name) const\n"
"    Signature: getName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the local name of this scalarInst in the specified name string. The name is relative to the parent occurrence of this scalarInst.\n"
"    name\n"
"    The returned instance name\n"
"  Paramegers: (oaSimpleName)\n"
"    Calls: void getName(oaSimpleName& name) const\n"
"    Signature: getName|void-void|ref-oaSimpleName,\n"
"    BrowseData: 0,oaSimpleName\n"
"    This function fills out name with the name of this instance.\n"
"    name\n"
"    The returned instance name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function fills out name with the name of this instance. The name is mapped according to the specified nameSpace.\n"
"    ns\n"
"    The nameSpace used to map the name\n"
"    name\n"
"    The returned instance name\n"
;

static PyObject*
oaOccModuleScalarInst_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleScalarInst data;
    int convert_status=PyoaOccModuleScalarInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleScalarInstObject* self=(PyoaOccModuleScalarInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName)
    {
        PyParamoaSimpleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSimpleName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccModuleScalarInst, function: getName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaSimpleName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleScalarInst_getPathName_doc[] = 
"Class: oaOccModuleScalarInst, Function: getPathName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getPathName(oaScalarName& pathName) const\n"
"    Signature: getPathName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the full path name of this scalarInst, relative to the top occurrence in the occurrence hierarchy containing this scalarInst.\n"
"    pathName\n"
"    The returned path name\n"
"  Paramegers: (oaSimpleName)\n"
"    Calls: void getPathName(oaSimpleName& pathName) const\n"
"    Signature: getPathName|void-void|ref-oaSimpleName,\n"
"    BrowseData: 0,oaSimpleName\n"
"    This function fills out pathName with the full path name of this instance, relative to the top occurrence in the occurrence hierarchy containing this instance.\n"
"    pathName\n"
"    The path name of the instance\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getPathName(const oaNameSpace& ns,oaString& pathName) const\n"
"    Signature: getPathName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the full path name of this instance in the specified nameSpace in the specified pathName string. The pathName is relative to the top occurrence in the occurrence hierarchy containing this instance.\n"
"    ns\n"
"    The nameSpace in which to return the name\n"
"    pathName\n"
"    The path name of the instance\n"
;

static PyObject*
oaOccModuleScalarInst_getPathName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleScalarInst data;
    int convert_status=PyoaOccModuleScalarInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleScalarInstObject* self=(PyoaOccModuleScalarInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getPathName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName)
    {
        PyParamoaSimpleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSimpleName_Convert,&p1)) {
            data.DataCall()->getPathName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getPathName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccModuleScalarInst, function: getPathName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaSimpleName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleScalarInst_isNull_doc[] =
"Class: oaOccModuleScalarInst, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccModuleScalarInst_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccModuleScalarInst data;
    int convert_status=PyoaOccModuleScalarInst_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccModuleScalarInst_assign_doc[] = 
"Class: oaOccModuleScalarInst, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccModuleScalarInst_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccModuleScalarInst data;
  int convert_status=PyoaOccModuleScalarInst_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccModuleScalarInst p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccModuleScalarInst_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccModuleScalarInst_methodlist[] = {
    {"getModInst",(PyCFunction)oaOccModuleScalarInst_getModInst,METH_VARARGS,oaOccModuleScalarInst_getModInst_doc},
    {"getName",(PyCFunction)oaOccModuleScalarInst_getName,METH_VARARGS,oaOccModuleScalarInst_getName_doc},
    {"getPathName",(PyCFunction)oaOccModuleScalarInst_getPathName,METH_VARARGS,oaOccModuleScalarInst_getPathName_doc},
    {"isNull",(PyCFunction)oaOccModuleScalarInst_tp_isNull,METH_VARARGS,oaOccModuleScalarInst_isNull_doc},
    {"assign",(PyCFunction)oaOccModuleScalarInst_tp_assign,METH_VARARGS,oaOccModuleScalarInst_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccModuleScalarInst_doc[] = 
"Class: oaOccModuleScalarInst\n"
"  The oaOccModuleScalarInst class implements a occurence scalar (single-bit) instance. oaOccScalarInst objects refer to master module and are always in the occurrence domain.\n"
"Constructors:\n"
"  Paramegers: (oaOccModuleScalarInst)\n"
"    Calls: (const oaOccModuleScalarInst&)\n"
"    Signature: oaOccModuleScalarInst||cref-oaOccModuleScalarInst,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccModuleScalarInst_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccModuleScalarInst",
    sizeof(PyoaOccModuleScalarInstObject),
    0,
    (destructor)oaOccModuleScalarInst_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccModuleScalarInst_tp_compare,	/* tp_compare */
    (reprfunc)oaOccModuleScalarInst_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccModuleScalarInst_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccModuleScalarInst_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccModuleBitInst_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccModuleScalarInst_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccModuleScalarInst_static_find_doc[] = 
"Class: oaOccModuleScalarInst, Function: find\n"
"  Paramegers: (oaOccurrence,oaScalarName)\n"
"    Calls: oaOccModuleScalarInst* find(const oaOccurrence* occurrence,const oaScalarName& name)\n"
"    Signature: find|ptr-oaOccModuleScalarInst|cptr-oaOccurrence,cref-oaScalarName,\n"
"    This function searches the specified occurrence looking for a module instance with the specified name . If name is hierarchical, this function will descend into lower levels of occurrence hierarchy, expanding the hierarchy and binding the master designs as needed. The module instance is returned if found, otherwise NULL is returned.\n"
"    A pointer to an oaOccModuleScalarInst\n"
;

static PyObject*
oaOccModuleScalarInst_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaOccurrence_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaOccModuleScalarInstp result= (oaOccModuleScalarInst::find(p1.Data(),p2.Data()));
        return PyoaOccModuleScalarInst_FromoaOccModuleScalarInst(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaOccModuleScalarInst_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaOccModuleScalarInst_static_find,METH_VARARGS,oaOccModuleScalarInst_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccModuleScalarInst_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccModuleScalarInst_Type)<0) {
      printf("** PyType_Ready failed for: oaOccModuleScalarInst\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccModuleScalarInst",
           (PyObject*)(&PyoaOccModuleScalarInst_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccModuleScalarInst\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaOccModuleScalarInst_Type.tp_dict;
    for(method=oaOccModuleScalarInst_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccModuleVectorInst
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccModuleVectorInst_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccModuleVectorInst_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccModuleVectorInstObject* self = (PyoaOccModuleVectorInstObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccModuleVectorInst)
    {
        PyParamoaOccModuleVectorInst p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccModuleVectorInst_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccModuleVectorInst, Choices are:\n"
        "    (oaOccModuleVectorInst)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccModuleVectorInst_tp_dealloc(PyoaOccModuleVectorInstObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccModuleVectorInst_tp_repr(PyObject *ob)
{
    PyParamoaOccModuleVectorInst value;
    int convert_status=PyoaOccModuleVectorInst_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaOccModuleVectorInst::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaSimpleName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[43];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaOccModuleVectorInst::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccModuleVectorInst_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccModuleVectorInst v1;
    PyParamoaOccModuleVectorInst v2;
    int convert_status1=PyoaOccModuleVectorInst_Convert(ob1,&v1);
    int convert_status2=PyoaOccModuleVectorInst_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccModuleVectorInst_Convert(PyObject* ob,PyParamoaOccModuleVectorInst* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccModuleVectorInst_Check(ob)) {
        result->SetData( (oaOccModuleVectorInst**) ((PyoaOccModuleVectorInstObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccModuleVectorInst Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccModuleVectorInst_FromoaOccModuleVectorInst(oaOccModuleVectorInst** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccModuleVectorInst* data=*value;
        PyObject* bself = PyoaOccModuleVectorInst_Type.tp_alloc(&PyoaOccModuleVectorInst_Type,0);
        if (bself == NULL) return bself;
        PyoaOccModuleVectorInstObject* self = (PyoaOccModuleVectorInstObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccModuleVectorInst_FromoaOccModuleVectorInst(oaOccModuleVectorInst* data)
{
    if (data) {
       PyObject* bself = PyoaOccModuleVectorInst_Type.tp_alloc(&PyoaOccModuleVectorInst_Type,0);
       if (bself == NULL) return bself;
       PyoaOccModuleVectorInstObject* self = (PyoaOccModuleVectorInstObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccModuleVectorInst_getBit_doc[] = 
"Class: oaOccModuleVectorInst, Function: getBit\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaOccModuleVectorInstBit* getBit(oaUInt4 bitIndex) const\n"
"    Signature: getBit|ptr-oaOccModuleVectorInstBit|simple-oaUInt4,\n"
"    This function returns a pointer to the vectorInstBit that corresponds to the specified bitIndex bit of this vectorInst. For example, if this is a vectorInst \"i[7:0]\" and bitIndex is zero, this function will return the vectorInstBit corresponding to \"i[7]\".\n"
"    bitIndex\n"
"    Specifies which bit of the instance to return\n"
"    A pointer to an oaOccModuleVectorInstBit\n"
"    oacInvalidBitIndexIntoInst\n"
;

static PyObject*
oaOccModuleVectorInst_getBit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleVectorInst data;
    int convert_status=PyoaOccModuleVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleVectorInstObject* self=(PyoaOccModuleVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaOccModuleVectorInstBitp result= (data.DataCall()->getBit(p1.Data()));
        return PyoaOccModuleVectorInstBit_FromoaOccModuleVectorInstBit(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleVectorInst_getDef_doc[] = 
"Class: oaOccModuleVectorInst, Function: getDef\n"
"  Paramegers: ()\n"
"    Calls: oaOccVectorInstDef* getDef() const\n"
"    Signature: getDef|ptr-oaOccVectorInstDef|\n"
"    BrowseData: 1\n"
"    This function returns the occurrence vectorInstDef for this occurrence vectorInst. The occurrence vectorInstDef is used to access all occurrence vectorInts with the same baseName.\n"
;

static PyObject*
oaOccModuleVectorInst_getDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleVectorInst data;
    int convert_status=PyoaOccModuleVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleVectorInstObject* self=(PyoaOccModuleVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaOccVectorInstDefp result= (data.DataCall()->getDef());
        return PyoaOccVectorInstDef_FromoaOccVectorInstDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleVectorInst_getModInst_doc[] = 
"Class: oaOccModuleVectorInst, Function: getModInst\n"
"  Paramegers: ()\n"
"    Calls: oaModModuleVectorInst* getModInst() const\n"
"    Signature: getModInst|ptr-oaModModuleVectorInst|\n"
"    BrowseData: 1\n"
"    This function returns the corresponding module instance in the module domain.\n"
"    The oaModModuleVectorInst pointer\n"
;

static PyObject*
oaOccModuleVectorInst_getModInst(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleVectorInst data;
    int convert_status=PyoaOccModuleVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleVectorInstObject* self=(PyoaOccModuleVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModModuleVectorInstp result= (data.DataCall()->getModInst());
        return PyoaModModuleVectorInst_FromoaModModuleVectorInst(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleVectorInst_getName_doc[] = 
"Class: oaOccModuleVectorInst, Function: getName\n"
"  Paramegers: (oaVectorName)\n"
"    Calls: void getName(oaVectorName& name) const\n"
"    Signature: getName|void-void|ref-oaVectorName,\n"
"    BrowseData: 0,oaVectorName\n"
"    This function returns the name of this occModuleVectorInst.\n"
"    name\n"
"    The name of the occModuleVectorInst to return\n"
"  Paramegers: (oaSimpleName)\n"
"    Calls: void getName(oaSimpleName& name) const\n"
"    Signature: getName|void-void|ref-oaSimpleName,\n"
"    BrowseData: 0,oaSimpleName\n"
"    This function fills out name with the name of this instance.\n"
"    name\n"
"    The returned instance name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function fills out name with the name of this instance. The name is mapped according to the specified nameSpace.\n"
"    ns\n"
"    The nameSpace used to map the name\n"
"    name\n"
"    The returned instance name\n"
;

static PyObject*
oaOccModuleVectorInst_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleVectorInst data;
    int convert_status=PyoaOccModuleVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleVectorInstObject* self=(PyoaOccModuleVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaVectorName)
    {
        PyParamoaVectorName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName)
    {
        PyParamoaSimpleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSimpleName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccModuleVectorInst, function: getName, Choices are:\n"
        "    (oaVectorName)\n"
        "    (oaSimpleName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleVectorInst_getPathName_doc[] = 
"Class: oaOccModuleVectorInst, Function: getPathName\n"
"  Paramegers: (oaVectorName)\n"
"    Calls: void getPathName(oaVectorName& name) const\n"
"    Signature: getPathName|void-void|ref-oaVectorName,\n"
"    BrowseData: 0,oaVectorName\n"
"    This function returns the full path name of this instance, relative to the top occurrence in the occurrence hierarchy containing this instance.\n"
"    name\n"
"    The pathName of the occModuleVectorInst to return\n"
"  Paramegers: (oaSimpleName)\n"
"    Calls: void getPathName(oaSimpleName& pathName) const\n"
"    Signature: getPathName|void-void|ref-oaSimpleName,\n"
"    BrowseData: 0,oaSimpleName\n"
"    This function fills out pathName with the full path name of this instance, relative to the top occurrence in the occurrence hierarchy containing this instance.\n"
"    pathName\n"
"    The path name of the instance\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getPathName(const oaNameSpace& ns,oaString& pathName) const\n"
"    Signature: getPathName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the full path name of this instance in the specified nameSpace in the specified pathName string. The pathName is relative to the top occurrence in the occurrence hierarchy containing this instance.\n"
"    ns\n"
"    The nameSpace in which to return the name\n"
"    pathName\n"
"    The path name of the instance\n"
;

static PyObject*
oaOccModuleVectorInst_getPathName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleVectorInst data;
    int convert_status=PyoaOccModuleVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleVectorInstObject* self=(PyoaOccModuleVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaVectorName)
    {
        PyParamoaVectorName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorName_Convert,&p1)) {
            data.DataCall()->getPathName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName)
    {
        PyParamoaSimpleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSimpleName_Convert,&p1)) {
            data.DataCall()->getPathName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getPathName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccModuleVectorInst, function: getPathName, Choices are:\n"
        "    (oaVectorName)\n"
        "    (oaSimpleName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleVectorInst_getStart_doc[] = 
"Class: oaOccModuleVectorInst, Function: getStart\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getStart() const\n"
"    Signature: getStart|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the start index of this vectorInst.\n"
;

static PyObject*
oaOccModuleVectorInst_getStart(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleVectorInst data;
    int convert_status=PyoaOccModuleVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleVectorInstObject* self=(PyoaOccModuleVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getStart());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleVectorInst_getStop_doc[] = 
"Class: oaOccModuleVectorInst, Function: getStop\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getStop() const\n"
"    Signature: getStop|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the stop index of this vectorInst.\n"
;

static PyObject*
oaOccModuleVectorInst_getStop(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleVectorInst data;
    int convert_status=PyoaOccModuleVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleVectorInstObject* self=(PyoaOccModuleVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getStop());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleVectorInst_isNull_doc[] =
"Class: oaOccModuleVectorInst, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccModuleVectorInst_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccModuleVectorInst data;
    int convert_status=PyoaOccModuleVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccModuleVectorInst_assign_doc[] = 
"Class: oaOccModuleVectorInst, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccModuleVectorInst_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccModuleVectorInst data;
  int convert_status=PyoaOccModuleVectorInst_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccModuleVectorInst p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccModuleVectorInst_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccModuleVectorInst_methodlist[] = {
    {"getBit",(PyCFunction)oaOccModuleVectorInst_getBit,METH_VARARGS,oaOccModuleVectorInst_getBit_doc},
    {"getDef",(PyCFunction)oaOccModuleVectorInst_getDef,METH_VARARGS,oaOccModuleVectorInst_getDef_doc},
    {"getModInst",(PyCFunction)oaOccModuleVectorInst_getModInst,METH_VARARGS,oaOccModuleVectorInst_getModInst_doc},
    {"getName",(PyCFunction)oaOccModuleVectorInst_getName,METH_VARARGS,oaOccModuleVectorInst_getName_doc},
    {"getPathName",(PyCFunction)oaOccModuleVectorInst_getPathName,METH_VARARGS,oaOccModuleVectorInst_getPathName_doc},
    {"getStart",(PyCFunction)oaOccModuleVectorInst_getStart,METH_VARARGS,oaOccModuleVectorInst_getStart_doc},
    {"getStop",(PyCFunction)oaOccModuleVectorInst_getStop,METH_VARARGS,oaOccModuleVectorInst_getStop_doc},
    {"isNull",(PyCFunction)oaOccModuleVectorInst_tp_isNull,METH_VARARGS,oaOccModuleVectorInst_isNull_doc},
    {"assign",(PyCFunction)oaOccModuleVectorInst_tp_assign,METH_VARARGS,oaOccModuleVectorInst_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccModuleVectorInst_doc[] = 
"Class: oaOccModuleVectorInst\n"
"  The oaOccModuleVectorInst class implements an occurrence vector instance in an occurrence hierarchy.\n"
"  oaOccModuleVectorInst objects refer to master module and are always in the occurrence domain.\n"
"Constructors:\n"
"  Paramegers: (oaOccModuleVectorInst)\n"
"    Calls: (const oaOccModuleVectorInst&)\n"
"    Signature: oaOccModuleVectorInst||cref-oaOccModuleVectorInst,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccModuleVectorInst_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccModuleVectorInst",
    sizeof(PyoaOccModuleVectorInstObject),
    0,
    (destructor)oaOccModuleVectorInst_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccModuleVectorInst_tp_compare,	/* tp_compare */
    (reprfunc)oaOccModuleVectorInst_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccModuleVectorInst_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccModuleVectorInst_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccModuleInst_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccModuleVectorInst_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccModuleVectorInst_static_find_doc[] = 
"Class: oaOccModuleVectorInst, Function: find\n"
"  Paramegers: (oaOccurrence,oaScalarName,oaUInt4,oaUInt4)\n"
"    Calls: oaOccModuleVectorInst* find(const oaOccurrence* occurrence,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop)\n"
"    Signature: find|ptr-oaOccModuleVectorInst|cptr-oaOccurrence,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,\n"
"    This function searches the specified occurrence looking for a vectorInst with the specified name . If name is hierarchical, this function will descend into lower levels of occurrence hierarchy, expanding the hierarchy and binding the master designs as needed. The vectorInst is returned if found, otherwise NULL is returned.\n"
"    occurrence\n"
"    The occurrence to search in\n"
"    baseName\n"
"    The base name of the instance to find\n"
"    start\n"
"    The start bit index of the instance to find\n"
"    stop\n"
"    The stop bit index of the instance to find\n"
"    A pointer to an oaOccModuleVectorInst\n"
;

static PyObject*
oaOccModuleVectorInst_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence p1;
    PyParamoaScalarName p2;
    PyParamoaUInt4 p3;
    PyParamoaUInt4 p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaOccurrence_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaUInt4_Convert,&p3,
          &PyoaUInt4_Convert,&p4)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaOccModuleVectorInstp result= (oaOccModuleVectorInst::find(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
        return PyoaOccModuleVectorInst_FromoaOccModuleVectorInst(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaOccModuleVectorInst_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaOccModuleVectorInst_static_find,METH_VARARGS,oaOccModuleVectorInst_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccModuleVectorInst_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccModuleVectorInst_Type)<0) {
      printf("** PyType_Ready failed for: oaOccModuleVectorInst\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccModuleVectorInst",
           (PyObject*)(&PyoaOccModuleVectorInst_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccModuleVectorInst\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaOccModuleVectorInst_Type.tp_dict;
    for(method=oaOccModuleVectorInst_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccModuleVectorInstBit
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccModuleVectorInstBit_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccModuleVectorInstBit_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccModuleVectorInstBitObject* self = (PyoaOccModuleVectorInstBitObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccModuleVectorInstBit)
    {
        PyParamoaOccModuleVectorInstBit p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccModuleVectorInstBit_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccModuleVectorInstBit, Choices are:\n"
        "    (oaOccModuleVectorInstBit)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccModuleVectorInstBit_tp_dealloc(PyoaOccModuleVectorInstBitObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccModuleVectorInstBit_tp_repr(PyObject *ob)
{
    PyParamoaOccModuleVectorInstBit value;
    int convert_status=PyoaOccModuleVectorInstBit_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaOccModuleVectorInstBit::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaSimpleName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[46];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaOccModuleVectorInstBit::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccModuleVectorInstBit_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccModuleVectorInstBit v1;
    PyParamoaOccModuleVectorInstBit v2;
    int convert_status1=PyoaOccModuleVectorInstBit_Convert(ob1,&v1);
    int convert_status2=PyoaOccModuleVectorInstBit_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccModuleVectorInstBit_Convert(PyObject* ob,PyParamoaOccModuleVectorInstBit* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccModuleVectorInstBit_Check(ob)) {
        result->SetData( (oaOccModuleVectorInstBit**) ((PyoaOccModuleVectorInstBitObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccModuleVectorInstBit Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccModuleVectorInstBit_FromoaOccModuleVectorInstBit(oaOccModuleVectorInstBit** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccModuleVectorInstBit* data=*value;
        PyObject* bself = PyoaOccModuleVectorInstBit_Type.tp_alloc(&PyoaOccModuleVectorInstBit_Type,0);
        if (bself == NULL) return bself;
        PyoaOccModuleVectorInstBitObject* self = (PyoaOccModuleVectorInstBitObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccModuleVectorInstBit_FromoaOccModuleVectorInstBit(oaOccModuleVectorInstBit* data)
{
    if (data) {
       PyObject* bself = PyoaOccModuleVectorInstBit_Type.tp_alloc(&PyoaOccModuleVectorInstBit_Type,0);
       if (bself == NULL) return bself;
       PyoaOccModuleVectorInstBitObject* self = (PyoaOccModuleVectorInstBitObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccModuleVectorInstBit_getBitIndex_doc[] = 
"Class: oaOccModuleVectorInstBit, Function: getBitIndex\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getBitIndex() const\n"
"    Signature: getBitIndex|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the bitIndex for this vectorInstBit.\n"
;

static PyObject*
oaOccModuleVectorInstBit_getBitIndex(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleVectorInstBit data;
    int convert_status=PyoaOccModuleVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleVectorInstBitObject* self=(PyoaOccModuleVectorInstBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getBitIndex());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleVectorInstBit_getDef_doc[] = 
"Class: oaOccModuleVectorInstBit, Function: getDef\n"
"  Paramegers: ()\n"
"    Calls: oaOccVectorInstDef* getDef() const\n"
"    Signature: getDef|ptr-oaOccVectorInstDef|\n"
"    BrowseData: 1\n"
"    This function returns the vectorInstDef for this vectorInstBit.\n"
;

static PyObject*
oaOccModuleVectorInstBit_getDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleVectorInstBit data;
    int convert_status=PyoaOccModuleVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleVectorInstBitObject* self=(PyoaOccModuleVectorInstBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaOccVectorInstDefp result= (data.DataCall()->getDef());
        return PyoaOccVectorInstDef_FromoaOccVectorInstDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleVectorInstBit_getModInst_doc[] = 
"Class: oaOccModuleVectorInstBit, Function: getModInst\n"
"  Paramegers: ()\n"
"    Calls: oaModModuleVectorInstBit* getModInst() const\n"
"    Signature: getModInst|ptr-oaModModuleVectorInstBit|\n"
"    BrowseData: 1\n"
"    This function returns the corresponding instance in the module domain.\n"
"    A pointer to an oaModModuleVectorInstBit\n"
;

static PyObject*
oaOccModuleVectorInstBit_getModInst(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleVectorInstBit data;
    int convert_status=PyoaOccModuleVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleVectorInstBitObject* self=(PyoaOccModuleVectorInstBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModModuleVectorInstBitp result= (data.DataCall()->getModInst());
        return PyoaModModuleVectorInstBit_FromoaModModuleVectorInstBit(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleVectorInstBit_getName_doc[] = 
"Class: oaOccModuleVectorInstBit, Function: getName\n"
"  Paramegers: (oaVectorBitName)\n"
"    Calls: void getName(oaVectorBitName& name) const\n"
"    Signature: getName|void-void|ref-oaVectorBitName,\n"
"    BrowseData: 0,oaVectorBitName\n"
"    This function returns the name of this occModuleVectorInstBit.\n"
"    name\n"
"    The name of the occModuleVectorInstBit to return\n"
"  Paramegers: (oaSimpleName)\n"
"    Calls: void getName(oaSimpleName& name) const\n"
"    Signature: getName|void-void|ref-oaSimpleName,\n"
"    BrowseData: 0,oaSimpleName\n"
"    This function fills out name with the name of this instance.\n"
"    name\n"
"    The returned instance name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function fills out name with the name of this instance. The name is mapped according to the specified nameSpace.\n"
"    ns\n"
"    The nameSpace used to map the name\n"
"    name\n"
"    The returned instance name\n"
;

static PyObject*
oaOccModuleVectorInstBit_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleVectorInstBit data;
    int convert_status=PyoaOccModuleVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleVectorInstBitObject* self=(PyoaOccModuleVectorInstBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaVectorBitName)
    {
        PyParamoaVectorBitName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorBitName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName)
    {
        PyParamoaSimpleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSimpleName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccModuleVectorInstBit, function: getName, Choices are:\n"
        "    (oaVectorBitName)\n"
        "    (oaSimpleName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleVectorInstBit_getPathName_doc[] = 
"Class: oaOccModuleVectorInstBit, Function: getPathName\n"
"  Paramegers: (oaVectorBitName)\n"
"    Calls: void getPathName(oaVectorBitName& name) const\n"
"    Signature: getPathName|void-void|ref-oaVectorBitName,\n"
"    BrowseData: 0,oaVectorBitName\n"
"    This function returns the full path name of this instance, relative to the top occurrence in the occurrence hierarchy containing this instance.\n"
"    name\n"
"    The pathName of the occModuleVectorInstBit to return\n"
"  Paramegers: (oaSimpleName)\n"
"    Calls: void getPathName(oaSimpleName& pathName) const\n"
"    Signature: getPathName|void-void|ref-oaSimpleName,\n"
"    BrowseData: 0,oaSimpleName\n"
"    This function fills out pathName with the full path name of this instance, relative to the top occurrence in the occurrence hierarchy containing this instance.\n"
"    pathName\n"
"    The path name of the instance\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getPathName(const oaNameSpace& ns,oaString& pathName) const\n"
"    Signature: getPathName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the full path name of this instance in the specified nameSpace in the specified pathName string. The pathName is relative to the top occurrence in the occurrence hierarchy containing this instance.\n"
"    ns\n"
"    The nameSpace in which to return the name\n"
"    pathName\n"
"    The path name of the instance\n"
;

static PyObject*
oaOccModuleVectorInstBit_getPathName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccModuleVectorInstBit data;
    int convert_status=PyoaOccModuleVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccModuleVectorInstBitObject* self=(PyoaOccModuleVectorInstBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaVectorBitName)
    {
        PyParamoaVectorBitName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorBitName_Convert,&p1)) {
            data.DataCall()->getPathName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName)
    {
        PyParamoaSimpleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSimpleName_Convert,&p1)) {
            data.DataCall()->getPathName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getPathName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccModuleVectorInstBit, function: getPathName, Choices are:\n"
        "    (oaVectorBitName)\n"
        "    (oaSimpleName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccModuleVectorInstBit_isNull_doc[] =
"Class: oaOccModuleVectorInstBit, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccModuleVectorInstBit_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccModuleVectorInstBit data;
    int convert_status=PyoaOccModuleVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccModuleVectorInstBit_assign_doc[] = 
"Class: oaOccModuleVectorInstBit, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccModuleVectorInstBit_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccModuleVectorInstBit data;
  int convert_status=PyoaOccModuleVectorInstBit_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccModuleVectorInstBit p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccModuleVectorInstBit_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccModuleVectorInstBit_methodlist[] = {
    {"getBitIndex",(PyCFunction)oaOccModuleVectorInstBit_getBitIndex,METH_VARARGS,oaOccModuleVectorInstBit_getBitIndex_doc},
    {"getDef",(PyCFunction)oaOccModuleVectorInstBit_getDef,METH_VARARGS,oaOccModuleVectorInstBit_getDef_doc},
    {"getModInst",(PyCFunction)oaOccModuleVectorInstBit_getModInst,METH_VARARGS,oaOccModuleVectorInstBit_getModInst_doc},
    {"getName",(PyCFunction)oaOccModuleVectorInstBit_getName,METH_VARARGS,oaOccModuleVectorInstBit_getName_doc},
    {"getPathName",(PyCFunction)oaOccModuleVectorInstBit_getPathName,METH_VARARGS,oaOccModuleVectorInstBit_getPathName_doc},
    {"isNull",(PyCFunction)oaOccModuleVectorInstBit_tp_isNull,METH_VARARGS,oaOccModuleVectorInstBit_isNull_doc},
    {"assign",(PyCFunction)oaOccModuleVectorInstBit_tp_assign,METH_VARARGS,oaOccModuleVectorInstBit_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccModuleVectorInstBit_doc[] = 
"Class: oaOccModuleVectorInstBit\n"
"  The oaOccModuleVectorInstBit class implements a single bit of an occurrence of a module vectorInst.\n"
"Constructors:\n"
"  Paramegers: (oaOccModuleVectorInstBit)\n"
"    Calls: (const oaOccModuleVectorInstBit&)\n"
"    Signature: oaOccModuleVectorInstBit||cref-oaOccModuleVectorInstBit,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccModuleVectorInstBit_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccModuleVectorInstBit",
    sizeof(PyoaOccModuleVectorInstBitObject),
    0,
    (destructor)oaOccModuleVectorInstBit_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccModuleVectorInstBit_tp_compare,	/* tp_compare */
    (reprfunc)oaOccModuleVectorInstBit_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccModuleVectorInstBit_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccModuleVectorInstBit_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccModuleBitInst_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccModuleVectorInstBit_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccModuleVectorInstBit_static_find_doc[] = 
"Class: oaOccModuleVectorInstBit, Function: find\n"
"  Paramegers: (oaOccurrence,oaScalarName,oaUInt4)\n"
"    Calls: oaOccModuleVectorInstBit* find(const oaOccurrence* occurrence,const oaScalarName& baseName,oaUInt4 bitIndex)\n"
"    Signature: find|ptr-oaOccModuleVectorInstBit|cptr-oaOccurrence,cref-oaScalarName,simple-oaUInt4,\n"
"    This function searches the specified occurrence looking for a vectorInstBit with the specified baseName and bitIndex . If baseName is hierarchical, this function will descend into lower levels of occurrence hierarchy, expanding the hierarchy and binding the master designs as needed. The vectorInstBit is returned if found, otherwise NULL is returned.\n"
"    occurrence\n"
"    The occurrence to search in\n"
"    baseName\n"
"    The base name of the instance to find\n"
"    bitIndex\n"
"    The bit index of the instance to find\n"
"    A pointer to an oaOccVectorInstBit\n"
;

static PyObject*
oaOccModuleVectorInstBit_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence p1;
    PyParamoaScalarName p2;
    PyParamoaUInt4 p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaOccurrence_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaUInt4_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaOccModuleVectorInstBitp result= (oaOccModuleVectorInstBit::find(p1.Data(),p2.Data(),p3.Data()));
        return PyoaOccModuleVectorInstBit_FromoaOccModuleVectorInstBit(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaOccModuleVectorInstBit_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaOccModuleVectorInstBit_static_find,METH_VARARGS,oaOccModuleVectorInstBit_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccModuleVectorInstBit_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccModuleVectorInstBit_Type)<0) {
      printf("** PyType_Ready failed for: oaOccModuleVectorInstBit\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccModuleVectorInstBit",
           (PyObject*)(&PyoaOccModuleVectorInstBit_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccModuleVectorInstBit\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaOccModuleVectorInstBit_Type.tp_dict;
    for(method=oaOccModuleVectorInstBit_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccNet
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccNet_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccNet_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccNetObject* self = (PyoaOccNetObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccNet)
    {
        PyParamoaOccNet p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccNet_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccNet, Choices are:\n"
        "    (oaOccNet)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccNet_tp_dealloc(PyoaOccNetObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccNet_tp_repr(PyObject *ob)
{
    PyParamoaOccNet value;
    int convert_status=PyoaOccNet_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaOccNet::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[30];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaOccNet::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccNet_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccNet v1;
    PyParamoaOccNet v2;
    int convert_status1=PyoaOccNet_Convert(ob1,&v1);
    int convert_status2=PyoaOccNet_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccNet_Convert(PyObject* ob,PyParamoaOccNet* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccNet_Check(ob)) {
        result->SetData( (oaOccNet**) ((PyoaOccNetObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccNet Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccNet_FromoaOccNet(oaOccNet** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccNet* data=*value;
        if (data->getType()==oacOccBundleNetType) return PyoaOccBundleNet_FromoaOccBundleNet((oaOccBundleNet**)value,borrow,lock);
        if (data->isOccBitNet()) return PyoaOccBitNet_FromoaOccBitNet((oaOccBitNet**)value,borrow,lock);
        if (data->getType()==oacOccBusNetType) return PyoaOccBusNet_FromoaOccBusNet((oaOccBusNet**)value,borrow,lock);
        PyObject* bself = PyoaOccNet_Type.tp_alloc(&PyoaOccNet_Type,0);
        if (bself == NULL) return bself;
        PyoaOccNetObject* self = (PyoaOccNetObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccNet_FromoaOccNet(oaOccNet* data)
{
    if (data) {
        if (data->getType()==oacOccBundleNetType) return PyoaOccBundleNet_FromoaOccBundleNet((oaOccBundleNet*)data);
        if (data->isOccBitNet()) return PyoaOccBitNet_FromoaOccBitNet((oaOccBitNet*)data);
        if (data->getType()==oacOccBusNetType) return PyoaOccBusNet_FromoaOccBusNet((oaOccBusNet*)data);
       PyObject* bself = PyoaOccNet_Type.tp_alloc(&PyoaOccNet_Type,0);
       if (bself == NULL) return bself;
       PyoaOccNetObject* self = (PyoaOccNetObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccNet_getAssignedNet_doc[] = 
"Class: oaOccNet, Function: getAssignedNet\n"
"  Paramegers: ()\n"
"    Calls: oaOccNet* getAssignedNet() const\n"
"    Signature: getAssignedNet|ptr-oaOccNet|simple-oaBoolean,\n"
"    BrowseData: 1\n"
"    This function returns the occurence net assigned to this net as per the inherited connections specification.\n"
"    NULL will be returned in the following cases:\n"
"    There is no effective connectDef associated with this net\n"
"    There is an effective connectDef but no matching assignment, and 'ignoreDefault' is true.\n"
"    Exceptions are thrown for cases when an assignment is found but a net with that name does not exist or if the default net name needs to be used, 'ignoreDefault' is false, but there is no net that matches the default net name specified.\n"
"    ignoreDefault\n"
"    Indicates if the default net name in the specification should be ignored\n"
"    oacCannotFindSpecAssignedDefOccNet\n"
"    oacCannotFindSpecAssignedOccNet\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: oaOccNet* getAssignedNet(oaBoolean ignoreDefault) const\n"
"    Signature: getAssignedNet|ptr-oaOccNet|simple-oaBoolean,\n"
"    This function returns the occurence net assigned to this net as per the inherited connections specification.\n"
"    NULL will be returned in the following cases:\n"
"    There is no effective connectDef associated with this net\n"
"    There is an effective connectDef but no matching assignment, and 'ignoreDefault' is true.\n"
"    Exceptions are thrown for cases when an assignment is found but a net with that name does not exist or if the default net name needs to be used, 'ignoreDefault' is false, but there is no net that matches the default net name specified.\n"
"    ignoreDefault\n"
"    Indicates if the default net name in the specification should be ignored\n"
"    oacCannotFindSpecAssignedDefOccNet\n"
"    oacCannotFindSpecAssignedOccNet\n"
"  Paramegers: (oaAssignedNetSpec)\n"
"    Calls: oaOccNet* getAssignedNet(oaAssignedNetSpec& spec) const\n"
"    Signature: getAssignedNet|ptr-oaOccNet|ref-oaAssignedNetSpec,simple-oaBoolean,\n"
"    BrowseData: 1,oaAssignedNetSpec\n"
"    This function returns the occurence net assigned to this net as per the inherited connections specification.\n"
"    NULL will be returned in the following cases:\n"
"    There is no effective connectDef associated with this net\n"
"    There is an effective connectDef but no matching assignment, and 'ignoreDefault' is true.\n"
"    Exceptions are thrown for cases when an assignment is found but a net with that name does not exist or if the default net name needs to be used, 'ignoreDefault' is false, but there is no net that matches the default net name specified.\n"
"    This version is for diagnostic use and returns the set of connectDefs and/or assignments that were looked at in the hierarchy for resolving the assigned net via the 'spec' parameter. Clients can inspect the array which will consist of pointers to either connectDef or assignment objects in the occurrence domain.\n"
"    spec\n"
"    An array that gets populated with pointers to design objects that indicate the assigned net specification\n"
"    ignoreDefault\n"
"    Indicates if the default net name in the specification should be ignored\n"
"    oacCannotFindSpecAssignedDefOccNet\n"
"    oacCannotFindSpecAssignedOccNet\n"
"  Paramegers: (oaAssignedNetSpec,oaBoolean)\n"
"    Calls: oaOccNet* getAssignedNet(oaAssignedNetSpec& spec,oaBoolean ignoreDefault) const\n"
"    Signature: getAssignedNet|ptr-oaOccNet|ref-oaAssignedNetSpec,simple-oaBoolean,\n"
"    This function returns the occurence net assigned to this net as per the inherited connections specification.\n"
"    NULL will be returned in the following cases:\n"
"    There is no effective connectDef associated with this net\n"
"    There is an effective connectDef but no matching assignment, and 'ignoreDefault' is true.\n"
"    Exceptions are thrown for cases when an assignment is found but a net with that name does not exist or if the default net name needs to be used, 'ignoreDefault' is false, but there is no net that matches the default net name specified.\n"
"    This version is for diagnostic use and returns the set of connectDefs and/or assignments that were looked at in the hierarchy for resolving the assigned net via the 'spec' parameter. Clients can inspect the array which will consist of pointers to either connectDef or assignment objects in the occurrence domain.\n"
"    spec\n"
"    An array that gets populated with pointers to design objects that indicate the assigned net specification\n"
"    ignoreDefault\n"
"    Indicates if the default net name in the specification should be ignored\n"
"    oacCannotFindSpecAssignedDefOccNet\n"
"    oacCannotFindSpecAssignedOccNet\n"
;

static PyObject*
oaOccNet_getAssignedNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccNet data;
    int convert_status=PyoaOccNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccNetObject* self=(PyoaOccNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaOccNetp result= (data.DataCall()->getAssignedNet());
            return PyoaOccNet_FromoaOccNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            oaOccNetp result= (data.DataCall()->getAssignedNet(p1.Data()));
            return PyoaOccNet_FromoaOccNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaAssignedNetSpec)
    {
        PyParamoaAssignedNetSpec p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaAssignedNetSpec_Convert,&p1)) {
            oaOccNetp result= (data.DataCall()->getAssignedNet(p1.Data()));
            return PyoaOccNet_FromoaOccNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaAssignedNetSpec,oaBoolean)
    {
        PyParamoaAssignedNetSpec p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaAssignedNetSpec_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaOccNetp result= (data.DataCall()->getAssignedNet(p1.Data(),p2.Data()));
            return PyoaOccNet_FromoaOccNet(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccNet, function: getAssignedNet, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
        "    (oaAssignedNetSpec)\n"
        "    (oaAssignedNetSpec,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccNet_getBit_doc[] = 
"Class: oaOccNet, Function: getBit\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaOccBitNet* getBit(oaUInt4 bitIndex) const\n"
"    Signature: getBit|ptr-oaOccBitNet|simple-oaUInt4,\n"
"    This function returns a pointer to the occNet that corresponds to the specified bitIndex bit of this net. For scalarNets, this function simply returns the net. For busNets, the busNetBit corresponding to the bitIndex position is returned. For example, if this net is a busNet \"a[7:0]\" and bitIndex is zero, this function will return the busNetBit corresponding to \"a[7]\". For bundleNets, a scalarNet or busNetBit is returned.\n"
"    bitIndex\n"
"    Specifies which bit of the net to return.\n"
"    A pointer to an oaOccBitNet\n"
"    oacInvalidBusNetBitIndex\n"
"    oacInvalidNetIndex\n"
;

static PyObject*
oaOccNet_getBit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccNet data;
    int convert_status=PyoaOccNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccNetObject* self=(PyoaOccNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaOccBitNetp result= (data.DataCall()->getBit(p1.Data()));
        return PyoaOccBitNet_FromoaOccBitNet(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccNet_getGlobalNets_doc[] = 
"Class: oaOccNet, Function: getGlobalNets\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaOccNet_oaOccNet getGlobalNets() const\n"
"    Signature: getGlobalNets|simple-oaCollection_oaOccNet_oaOccNet|\n"
"    BrowseData: 1\n"
"    oaOccNet::getGlobalNets\n"
"    This function returns an oaOccNet collection consisting of all global nets with the same local name as this global net.\n"
"    This function returns an oaOccNet collection consisting of all global nets with the same local name as this global net. An oacInvalidGlobalNet exception is thrown if this net is not a global net.\n"
"    oacInvalidGlobalNet\n"
;

static PyObject*
oaOccNet_getGlobalNets(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccNet data;
    int convert_status=PyoaOccNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccNetObject* self=(PyoaOccNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaOccNet_oaOccNet* result= new oaCollection_oaOccNet_oaOccNet(data.DataCall()->getGlobalNets());
        return PyoaCollection_oaOccNet_oaOccNet_FromoaCollection_oaOccNet_oaOccNet(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccNet_getGlobalNetsIter_doc[] = 
"Class: oaOccNet, Function: getGlobalNetsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaOccNet getGlobalNetsIter() const\n"
"    Signature: getGlobalNetsIter|simple-oaIter_oaOccNet|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: oaOccNet::getGlobalNets\n"
"    This function returns an oaOccNet collection consisting of all global nets with the same local name as this global net.\n"
"    This function returns an oaOccNet collection consisting of all global nets with the same local name as this global net. An oacInvalidGlobalNet exception is thrown if this net is not a global net.\n"
"    oacInvalidGlobalNet\n"
;

static PyObject*
oaOccNet_getGlobalNetsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccNet data;
    int convert_status=PyoaOccNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccNetObject* self=(PyoaOccNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaOccNet* result= new oaIter_oaOccNet(data.DataCall()->getGlobalNets());
        return PyoaIter_oaOccNet_FromoaIter_oaOccNet(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccNet_getInstTerms_doc[] = 
"Class: oaOccNet, Function: getInstTerms\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaOccInstTerm_oaOccNet getInstTerms() const\n"
"    Signature: getInstTerms|simple-oaCollection_oaOccInstTerm_oaOccNet|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    oaOccNet::getInstTerms\n"
"    This function returns a collection of instTerms in this net. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bits flags are defined as follows:\n"
"    oacInstTermIterNotImplicit: the collection will only contain instTerms that were explicitly created\n"
"    oacInstTermIterEquivNets: the collection will also contain the instTerms on the nets that are equivalent to this one\n"
"    oacInstTermIterFlagNotApplicableOnNets\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaOccInstTerm_oaOccNet getInstTerms(oaUInt4 filterFlags) const\n"
"    Signature: getInstTerms|simple-oaCollection_oaOccInstTerm_oaOccNet|simple-oaUInt4,\n"
"    oaOccNet::getInstTerms\n"
"    This function returns a collection of instTerms in this net. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bits flags are defined as follows:\n"
"    oacInstTermIterNotImplicit: the collection will only contain instTerms that were explicitly created\n"
"    oacInstTermIterEquivNets: the collection will also contain the instTerms on the nets that are equivalent to this one\n"
"    oacInstTermIterFlagNotApplicableOnNets\n"
;

static PyObject*
oaOccNet_getInstTerms(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccNet data;
    int convert_status=PyoaOccNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccNetObject* self=(PyoaOccNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaOccInstTerm_oaOccNet* result= new oaCollection_oaOccInstTerm_oaOccNet(data.DataCall()->getInstTerms());
            return PyoaCollection_oaOccInstTerm_oaOccNet_FromoaCollection_oaOccInstTerm_oaOccNet(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaOccInstTerm_oaOccNet* result= new oaCollection_oaOccInstTerm_oaOccNet(data.DataCall()->getInstTerms(p1.Data()));
            return PyoaCollection_oaOccInstTerm_oaOccNet_FromoaCollection_oaOccInstTerm_oaOccNet(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccNet, function: getInstTerms, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccNet_getInstTermsIter_doc[] = 
"Class: oaOccNet, Function: getInstTermsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaOccInstTerm getInstTermsIter() const\n"
"    Signature: getInstTermsIter|simple-oaIter_oaOccInstTerm|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: oaOccNet::getInstTerms\n"
"    This function returns a collection of instTerms in this net. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bits flags are defined as follows:\n"
"    oacInstTermIterNotImplicit: the collection will only contain instTerms that were explicitly created\n"
"    oacInstTermIterEquivNets: the collection will also contain the instTerms on the nets that are equivalent to this one\n"
"    oacInstTermIterFlagNotApplicableOnNets\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaOccInstTerm getInstTermsIter(oaUInt4 filterFlags) const\n"
"    Signature: getInstTermsIter|simple-oaIter_oaOccInstTerm|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: oaOccNet::getInstTerms\n"
"    This function returns a collection of instTerms in this net. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bits flags are defined as follows:\n"
"    oacInstTermIterNotImplicit: the collection will only contain instTerms that were explicitly created\n"
"    oacInstTermIterEquivNets: the collection will also contain the instTerms on the nets that are equivalent to this one\n"
"    oacInstTermIterFlagNotApplicableOnNets\n"
;

static PyObject*
oaOccNet_getInstTermsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccNet data;
    int convert_status=PyoaOccNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccNetObject* self=(PyoaOccNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaOccInstTerm* result= new oaIter_oaOccInstTerm(data.DataCall()->getInstTerms());
            return PyoaIter_oaOccInstTerm_FromoaIter_oaOccInstTerm(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaOccInstTerm* result= new oaIter_oaOccInstTerm(data.DataCall()->getInstTerms(p1.Data()));
            return PyoaIter_oaOccInstTerm_FromoaIter_oaOccInstTerm(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccNet, function: getInstTermsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccNet_getMemberNets_doc[] = 
"Class: oaOccNet, Function: getMemberNets\n"
"  Paramegers: ()\n"
"    Calls: oaOccMemNetCollection getMemberNets() const\n"
"    Signature: getMemberNets|simple-oaOccMemNetCollection|simple-oaBoolean,\n"
"    BrowseData: 1\n"
"    oaOccNet::getMemberNets\n"
"    This function returns a collection of occurrence nets of which this occurrence net is a member. For example, if an occurrence hierarchy contains both scalar net a and bundle net x,y,a this collection for net a contains both of those nets.\n"
"    The member net capability for occurrence nets exactly parallels the capability for oaNets in the block domain. See oaNet::getMemberNets for details on which nets are members of which other nets.\n"
"    unique\n"
"    Specifies that only the preferred equivalent nets are included in the collection\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: oaOccMemNetCollection getMemberNets(oaBoolean unique) const\n"
"    Signature: getMemberNets|simple-oaOccMemNetCollection|simple-oaBoolean,\n"
"    oaOccNet::getMemberNets\n"
"    This function returns a collection of occurrence nets of which this occurrence net is a member. For example, if an occurrence hierarchy contains both scalar net a and bundle net x,y,a this collection for net a contains both of those nets.\n"
"    The member net capability for occurrence nets exactly parallels the capability for oaNets in the block domain. See oaNet::getMemberNets for details on which nets are members of which other nets.\n"
"    unique\n"
"    Specifies that only the preferred equivalent nets are included in the collection\n"
;

static PyObject*
oaOccNet_getMemberNets(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccNet data;
    int convert_status=PyoaOccNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccNetObject* self=(PyoaOccNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaOccMemNetCollection* result= new oaOccMemNetCollection(data.DataCall()->getMemberNets());
            return PyoaOccMemNetCollection_FromoaOccMemNetCollection(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            oaOccMemNetCollection* result= new oaOccMemNetCollection(data.DataCall()->getMemberNets(p1.Data()));
            return PyoaOccMemNetCollection_FromoaOccMemNetCollection(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccNet, function: getMemberNets, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccNet_getMemberNetsIter_doc[] = 
"Class: oaOccNet, Function: getMemberNetsIter\n"
"  Paramegers: ()\n"
"    Calls: oaOccMemNetIter getMemberNetsIter() const\n"
"    Signature: getMemberNetsIter|simple-oaOccMemNetIter|simple-oaBoolean,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: oaOccNet::getMemberNets\n"
"    This function returns a collection of occurrence nets of which this occurrence net is a member. For example, if an occurrence hierarchy contains both scalar net a and bundle net x,y,a this collection for net a contains both of those nets.\n"
"    The member net capability for occurrence nets exactly parallels the capability for oaNets in the block domain. See oaNet::getMemberNets for details on which nets are members of which other nets.\n"
"    unique\n"
"    Specifies that only the preferred equivalent nets are included in the collection\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: oaOccMemNetIter getMemberNetsIter(oaBoolean unique) const\n"
"    Signature: getMemberNetsIter|simple-oaOccMemNetIter|simple-oaBoolean,\n"
"    This function returns an Iterator over the following collection: oaOccNet::getMemberNets\n"
"    This function returns a collection of occurrence nets of which this occurrence net is a member. For example, if an occurrence hierarchy contains both scalar net a and bundle net x,y,a this collection for net a contains both of those nets.\n"
"    The member net capability for occurrence nets exactly parallels the capability for oaNets in the block domain. See oaNet::getMemberNets for details on which nets are members of which other nets.\n"
"    unique\n"
"    Specifies that only the preferred equivalent nets are included in the collection\n"
;

static PyObject*
oaOccNet_getMemberNetsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccNet data;
    int convert_status=PyoaOccNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccNetObject* self=(PyoaOccNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaOccMemNetIter* result= new oaOccMemNetIter(data.DataCall()->getMemberNets());
            return PyoaOccMemNetIter_FromoaOccMemNetIter(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            oaOccMemNetIter* result= new oaOccMemNetIter(data.DataCall()->getMemberNets(p1.Data()));
            return PyoaOccMemNetIter_FromoaOccMemNetIter(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccNet, function: getMemberNetsIter, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccNet_getModNet_doc[] = 
"Class: oaOccNet, Function: getModNet\n"
"  Paramegers: ()\n"
"    Calls: oaModNet* getModNet() const\n"
"    Signature: getModNet|ptr-oaModNet|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the corresponding net in the module domain. NULL will be returned if this net is an occurrence of a physical-only net.\n"
"    A pointer to an oaModNet\n"
;

static PyObject*
oaOccNet_getModNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccNet data;
    int convert_status=PyoaOccNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccNetObject* self=(PyoaOccNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModNetp result= (data.DataCall()->getModNet());
        return PyoaModNet_FromoaModNet(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccNet_getName_doc[] = 
"Class: oaOccNet, Function: getName\n"
"  Paramegers: (oaName)\n"
"    Calls: void getName(oaName& name) const\n"
"    Signature: getName|void-void|ref-oaName,\n"
"    BrowseData: 0,oaName\n"
"    This function returns the local name of this net within its parent occurrence.\n"
"    name\n"
"    The returned net name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the local name of this net in the specified nameSpace in the specified name string. The name is relative to the parent occurrence of this net.\n"
"    ns\n"
"    The nameSpace used to map the name\n"
"    name\n"
"    The returned net name\n"
;

static PyObject*
oaOccNet_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccNet data;
    int convert_status=PyoaOccNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccNetObject* self=(PyoaOccNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaName)
    {
        PyParamoaName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccNet, function: getName, Choices are:\n"
        "    (oaName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccNet_getNet_doc[] = 
"Class: oaOccNet, Function: getNet\n"
"  Paramegers: ()\n"
"    Calls: oaNet* getNet() const\n"
"    Signature: getNet|ptr-oaNet|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the corresponding net in the block domain. NULL is returned if this occurrence net is not visible to the block domain.\n"
"    A pointer to an oaNet\n"
;

static PyObject*
oaOccNet_getNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccNet data;
    int convert_status=PyoaOccNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccNetObject* self=(PyoaOccNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaNetp result= (data.DataCall()->getNet());
        return PyoaNet_FromoaNet(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccNet_getNumBits_doc[] = 
"Class: oaOccNet, Function: getNumBits\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumBits() const\n"
"    Signature: getNumBits|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of bits in this net.\n"
;

static PyObject*
oaOccNet_getNumBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccNet data;
    int convert_status=PyoaOccNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccNetObject* self=(PyoaOccNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumBits());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccNet_getPathName_doc[] = 
"Class: oaOccNet, Function: getPathName\n"
"  Paramegers: (oaName)\n"
"    Calls: void getPathName(oaName& pathName) const\n"
"    Signature: getPathName|void-void|ref-oaName,\n"
"    BrowseData: 0,oaName\n"
"    This function returns the full path name of this net, relative to the top occurrence in the occurrence hierarchy containing this net.\n"
"    pathName\n"
"    The returned path name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getPathName(const oaNameSpace& ns,oaString& pathName) const\n"
"    Signature: getPathName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the full path name of this net in the specified nameSpace in the specified pathName string. The pathName is relative to the top occurrence in the occurrence hierarchy containing this net.\n"
"    ns\n"
"    The nameSpace used to map the name\n"
"    pathName\n"
"    The returned path name\n"
;

static PyObject*
oaOccNet_getPathName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccNet data;
    int convert_status=PyoaOccNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccNetObject* self=(PyoaOccNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaName)
    {
        PyParamoaName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaName_Convert,&p1)) {
            data.DataCall()->getPathName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getPathName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccNet, function: getPathName, Choices are:\n"
        "    (oaName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccNet_getSigType_doc[] = 
"Class: oaOccNet, Function: getSigType\n"
"  Paramegers: ()\n"
"    Calls: oaSigType getSigType() const\n"
"    Signature: getSigType|simple-oaSigType|\n"
"    BrowseData: 1\n"
"    This function returns the signal type of this net.\n"
;

static PyObject*
oaOccNet_getSigType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccNet data;
    int convert_status=PyoaOccNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccNetObject* self=(PyoaOccNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaSigType* result= new oaSigType(data.DataCall()->getSigType());
        return PyoaSigType_FromoaSigType(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccNet_getSingleBitMembers_doc[] = 
"Class: oaOccNet, Function: getSingleBitMembers\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaOccBitNet_oaOccNet getSingleBitMembers() const\n"
"    Signature: getSingleBitMembers|simple-oaCollection_oaOccBitNet_oaOccNet|\n"
"    BrowseData: 1\n"
"    This function returns a collection of single-bit member nets that are in this net. If this net is a single-bit net, the collection contains itself. If this net is a busNet, the collection contains all of the corresponding busNetBits.\n"
;

static PyObject*
oaOccNet_getSingleBitMembers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccNet data;
    int convert_status=PyoaOccNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccNetObject* self=(PyoaOccNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaOccBitNet_oaOccNet* result= new oaCollection_oaOccBitNet_oaOccNet(data.DataCall()->getSingleBitMembers());
        return PyoaCollection_oaOccBitNet_oaOccNet_FromoaCollection_oaOccBitNet_oaOccNet(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccNet_getSingleBitMembersIter_doc[] = 
"Class: oaOccNet, Function: getSingleBitMembersIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaOccBitNet getSingleBitMembersIter() const\n"
"    Signature: getSingleBitMembersIter|simple-oaIter_oaOccBitNet|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of single-bit member nets that are in this net. If this net is a single-bit net, the collection contains itself. If this net is a busNet, the collection contains all of the corresponding busNetBits.\n"
;

static PyObject*
oaOccNet_getSingleBitMembersIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccNet data;
    int convert_status=PyoaOccNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccNetObject* self=(PyoaOccNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaOccBitNet* result= new oaIter_oaOccBitNet(data.DataCall()->getSingleBitMembers());
        return PyoaIter_oaOccBitNet_FromoaIter_oaOccBitNet(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccNet_getSpan_doc[] = 
"Class: oaOccNet, Function: getSpan\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaOccNet_oaOccNet getSpan() const\n"
"    Signature: getSpan|simple-oaCollection_oaOccNet_oaOccNet|\n"
"    BrowseData: 1\n"
"    This function returns a collection of all occNets in the same span as this net. The span is defined as the set of nets connected across the module hierarchy. The span of nets does not cross the design hierarchy. The span of a net will change as the connectivity through occTerms and occInstTerms changes.\n"
;

static PyObject*
oaOccNet_getSpan(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccNet data;
    int convert_status=PyoaOccNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccNetObject* self=(PyoaOccNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaOccNet_oaOccNet* result= new oaCollection_oaOccNet_oaOccNet(data.DataCall()->getSpan());
        return PyoaCollection_oaOccNet_oaOccNet_FromoaCollection_oaOccNet_oaOccNet(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccNet_getSpanIter_doc[] = 
"Class: oaOccNet, Function: getSpanIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaOccNet getSpanIter() const\n"
"    Signature: getSpanIter|simple-oaIter_oaOccNet|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of all occNets in the same span as this net. The span is defined as the set of nets connected across the module hierarchy. The span of nets does not cross the design hierarchy. The span of a net will change as the connectivity through occTerms and occInstTerms changes.\n"
;

static PyObject*
oaOccNet_getSpanIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccNet data;
    int convert_status=PyoaOccNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccNetObject* self=(PyoaOccNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaOccNet* result= new oaIter_oaOccNet(data.DataCall()->getSpan());
        return PyoaIter_oaOccNet_FromoaIter_oaOccNet(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccNet_getTerms_doc[] = 
"Class: oaOccNet, Function: getTerms\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaOccTerm_oaOccNet getTerms() const\n"
"    Signature: getTerms|simple-oaCollection_oaOccTerm_oaOccNet|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    oaOccNet::getTerms\n"
"    This function returns a collection of terminals in this modNet. By default, the collection only contains explicit terminals associated with this net.\n"
"    When oacTermIterAll is included in filterFlags , the collection will contain all terminals associated with this net, including implicit terminals.\n"
"    When oacTermIterEquivNets is included in filterFlags , the collection will contain all terminals in the set of nets that are equivalent to this net.\n"
"    filterFlags\n"
"    Specifies which types of terminals to include in the collection\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaOccTerm_oaOccNet getTerms(oaUInt4 filterFlags) const\n"
"    Signature: getTerms|simple-oaCollection_oaOccTerm_oaOccNet|simple-oaUInt4,\n"
"    oaOccNet::getTerms\n"
"    This function returns a collection of terminals in this modNet. By default, the collection only contains explicit terminals associated with this net.\n"
"    When oacTermIterAll is included in filterFlags , the collection will contain all terminals associated with this net, including implicit terminals.\n"
"    When oacTermIterEquivNets is included in filterFlags , the collection will contain all terminals in the set of nets that are equivalent to this net.\n"
"    filterFlags\n"
"    Specifies which types of terminals to include in the collection\n"
;

static PyObject*
oaOccNet_getTerms(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccNet data;
    int convert_status=PyoaOccNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccNetObject* self=(PyoaOccNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaOccTerm_oaOccNet* result= new oaCollection_oaOccTerm_oaOccNet(data.DataCall()->getTerms());
            return PyoaCollection_oaOccTerm_oaOccNet_FromoaCollection_oaOccTerm_oaOccNet(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaOccTerm_oaOccNet* result= new oaCollection_oaOccTerm_oaOccNet(data.DataCall()->getTerms(p1.Data()));
            return PyoaCollection_oaOccTerm_oaOccNet_FromoaCollection_oaOccTerm_oaOccNet(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccNet, function: getTerms, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccNet_getTermsIter_doc[] = 
"Class: oaOccNet, Function: getTermsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaOccTerm getTermsIter() const\n"
"    Signature: getTermsIter|simple-oaIter_oaOccTerm|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: oaOccNet::getTerms\n"
"    This function returns a collection of terminals in this modNet. By default, the collection only contains explicit terminals associated with this net.\n"
"    When oacTermIterAll is included in filterFlags , the collection will contain all terminals associated with this net, including implicit terminals.\n"
"    When oacTermIterEquivNets is included in filterFlags , the collection will contain all terminals in the set of nets that are equivalent to this net.\n"
"    filterFlags\n"
"    Specifies which types of terminals to include in the collection\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaOccTerm getTermsIter(oaUInt4 filterFlags) const\n"
"    Signature: getTermsIter|simple-oaIter_oaOccTerm|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: oaOccNet::getTerms\n"
"    This function returns a collection of terminals in this modNet. By default, the collection only contains explicit terminals associated with this net.\n"
"    When oacTermIterAll is included in filterFlags , the collection will contain all terminals associated with this net, including implicit terminals.\n"
"    When oacTermIterEquivNets is included in filterFlags , the collection will contain all terminals in the set of nets that are equivalent to this net.\n"
"    filterFlags\n"
"    Specifies which types of terminals to include in the collection\n"
;

static PyObject*
oaOccNet_getTermsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccNet data;
    int convert_status=PyoaOccNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccNetObject* self=(PyoaOccNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaOccTerm* result= new oaIter_oaOccTerm(data.DataCall()->getTerms());
            return PyoaIter_oaOccTerm_FromoaIter_oaOccTerm(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaOccTerm* result= new oaIter_oaOccTerm(data.DataCall()->getTerms(p1.Data()));
            return PyoaIter_oaOccTerm_FromoaIter_oaOccTerm(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccNet, function: getTermsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccNet_isEmpty_doc[] = 
"Class: oaOccNet, Function: isEmpty\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isEmpty() const\n"
"    Signature: isEmpty|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value that indicates if this net has any objects attached to it or associated with it.\n"
;

static PyObject*
oaOccNet_isEmpty(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccNet data;
    int convert_status=PyoaOccNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccNetObject* self=(PyoaOccNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isEmpty());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccNet_isGlobal_doc[] = 
"Class: oaOccNet, Function: isGlobal\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isGlobal() const\n"
"    Signature: isGlobal|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value that indicates if this net is designated as a global net. Global nets connect implicitly to all global nets of the same name no matter what cellView in a hierarchy they appear in.\n"
;

static PyObject*
oaOccNet_isGlobal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccNet data;
    int convert_status=PyoaOccNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccNetObject* self=(PyoaOccNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isGlobal());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccNet_isImplicit_doc[] = 
"Class: oaOccNet, Function: isImplicit\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isImplicit() const\n"
"    Signature: isImplicit|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value that indicates if this occNet is an implicit net. Implicit nets only exist because they are components of an explicit busNet or bundleNet.\n"
;

static PyObject*
oaOccNet_isImplicit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccNet data;
    int convert_status=PyoaOccNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccNetObject* self=(PyoaOccNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isImplicit());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccNet_isNull_doc[] =
"Class: oaOccNet, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccNet_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccNet data;
    int convert_status=PyoaOccNet_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccNet_assign_doc[] = 
"Class: oaOccNet, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccNet_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccNet data;
  int convert_status=PyoaOccNet_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccNet p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccNet_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccNet_methodlist[] = {
    {"getAssignedNet",(PyCFunction)oaOccNet_getAssignedNet,METH_VARARGS,oaOccNet_getAssignedNet_doc},
    {"getBit",(PyCFunction)oaOccNet_getBit,METH_VARARGS,oaOccNet_getBit_doc},
    {"getGlobalNets",(PyCFunction)oaOccNet_getGlobalNets,METH_VARARGS,oaOccNet_getGlobalNets_doc},
    {"getGlobalNetsIter",(PyCFunction)oaOccNet_getGlobalNetsIter,METH_VARARGS,oaOccNet_getGlobalNetsIter_doc},
    {"getInstTerms",(PyCFunction)oaOccNet_getInstTerms,METH_VARARGS,oaOccNet_getInstTerms_doc},
    {"getInstTermsIter",(PyCFunction)oaOccNet_getInstTermsIter,METH_VARARGS,oaOccNet_getInstTermsIter_doc},
    {"getMemberNets",(PyCFunction)oaOccNet_getMemberNets,METH_VARARGS,oaOccNet_getMemberNets_doc},
    {"getMemberNetsIter",(PyCFunction)oaOccNet_getMemberNetsIter,METH_VARARGS,oaOccNet_getMemberNetsIter_doc},
    {"getModNet",(PyCFunction)oaOccNet_getModNet,METH_VARARGS,oaOccNet_getModNet_doc},
    {"getName",(PyCFunction)oaOccNet_getName,METH_VARARGS,oaOccNet_getName_doc},
    {"getNet",(PyCFunction)oaOccNet_getNet,METH_VARARGS,oaOccNet_getNet_doc},
    {"getNumBits",(PyCFunction)oaOccNet_getNumBits,METH_VARARGS,oaOccNet_getNumBits_doc},
    {"getPathName",(PyCFunction)oaOccNet_getPathName,METH_VARARGS,oaOccNet_getPathName_doc},
    {"getSigType",(PyCFunction)oaOccNet_getSigType,METH_VARARGS,oaOccNet_getSigType_doc},
    {"getSingleBitMembers",(PyCFunction)oaOccNet_getSingleBitMembers,METH_VARARGS,oaOccNet_getSingleBitMembers_doc},
    {"getSingleBitMembersIter",(PyCFunction)oaOccNet_getSingleBitMembersIter,METH_VARARGS,oaOccNet_getSingleBitMembersIter_doc},
    {"getSpan",(PyCFunction)oaOccNet_getSpan,METH_VARARGS,oaOccNet_getSpan_doc},
    {"getSpanIter",(PyCFunction)oaOccNet_getSpanIter,METH_VARARGS,oaOccNet_getSpanIter_doc},
    {"getTerms",(PyCFunction)oaOccNet_getTerms,METH_VARARGS,oaOccNet_getTerms_doc},
    {"getTermsIter",(PyCFunction)oaOccNet_getTermsIter,METH_VARARGS,oaOccNet_getTermsIter_doc},
    {"isEmpty",(PyCFunction)oaOccNet_isEmpty,METH_VARARGS,oaOccNet_isEmpty_doc},
    {"isGlobal",(PyCFunction)oaOccNet_isGlobal,METH_VARARGS,oaOccNet_isGlobal_doc},
    {"isImplicit",(PyCFunction)oaOccNet_isImplicit,METH_VARARGS,oaOccNet_isImplicit_doc},
    {"isNull",(PyCFunction)oaOccNet_tp_isNull,METH_VARARGS,oaOccNet_isNull_doc},
    {"assign",(PyCFunction)oaOccNet_tp_assign,METH_VARARGS,oaOccNet_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccNet_doc[] = 
"Class: oaOccNet\n"
"  The oaOccNet class is an abstract base class for scalar and multi-bit nets that are part of the design's occurrence description. Nets represent the logical connectivity within a occurrence of a design. Nets connect to terminals, which are the logical connection points on instances of the net's occurrence. Nets also connect to instTerms that represent connections to the lower-level instances in the net's occurrence.\n"
"  oaOccNet objects are always in the occurrence domain. Nets span the domains in a design. An oaOccNet may be an occurrence of an oaNet in the block hierarchy and may be an occurrence of an oaModNet in the module hierarchy.\n"
"  Multi-bit nets represent a collection of logical connections. Nets can include busNets having a single base name with an index range, or they can include bundleNets, which are a more complex grouping of nets. Multi-bit nets can have overlapping names. For example, busNets addr<7:0> and addr<3:0> .\n"
"  All occBusNets with the same root name are managed by an oaOccBusNetDef . The occBusNetDef tracks:\n"
"  lowest numbered bit of all of the associated occBusNets\n"
"  highest numbered bit of all of the associated occBusNets\n"
"  busNets with the same base name\n"
"  associated occBusNetBits\n"
"  The occBusNetBits are automatically created for each bit of a occBusNet, if they do not already exist. They are available for those applications performing scalarized connectivity traversal of the data.\n"
"  The bundleNets can contain scalarNets or buses. When a bundleNet is created, the constituent scalarNets and busNets are automatically created in addition to the bundleNet itself. All automatically created net objects are considered \"implicit.\" Implicit nets are more restricted in terms of the operations that are allowed to work with them.\n"
"  Names are normally associated with occNets. The various net objects take and return names through the general oaName object but also use the oaScalarName , oaVectorBitName , oaVectorName , and oaBundleName objects. These name objects manage the mapping of names from one nameSpace to another. For example, a net is created using the name in CDBA nameSpace; another application can retrieve the net's name in the Verilog nameSpace.\n"
"  You can have two or more occNets that are equivalent. Equivalent occNets are traversed separately or logically as the same net. You can only set single-bit nets equivalent to each other.\n"
"  The oaOccNet class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaOccNet)\n"
"    Calls: (const oaOccNet&)\n"
"    Signature: oaOccNet||cref-oaOccNet,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccNet_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccNet",
    sizeof(PyoaOccNetObject),
    0,
    (destructor)oaOccNet_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccNet_tp_compare,	/* tp_compare */
    (reprfunc)oaOccNet_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccNet_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccNet_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccNet_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccNet_static_find_doc[] = 
"Class: oaOccNet, Function: find\n"
"  Paramegers: (oaOccurrence,oaName)\n"
"    Calls: oaOccNet* find(const oaOccurrence* occurrence,const oaName& name)\n"
"    Signature: find|ptr-oaOccNet|cptr-oaOccurrence,cref-oaName,\n"
"    This function searches the specified occurrence for a occNet with the specified name . If name is hierarchical, then this function will descend into lower levels of occurrence hierarchy, expanding the hierarchy and binding the master designs as needed. If name is a bundle name, and any of its members is hierarchical, all of the members must have the same hierarchical path or an exception is thrown. If the net is found, the function returns the net. Otherwise, NULL is returned.\n"
"    occurrence\n"
"    The occurrence in which to search\n"
"    name\n"
"    The name of the net to find\n"
"    A pointer to the oaOccNet\n"
"    oacInvalidHierBundleNetName\n"
;

static PyObject*
oaOccNet_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence p1;
    PyParamoaName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaOccurrence_Convert,&p1,
          &PyoaName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaOccNetp result= (oaOccNet::find(p1.Data(),p2.Data()));
        return PyoaOccNet_FromoaOccNet(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaOccNet_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaOccNet_static_find,METH_VARARGS,oaOccNet_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccNet_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccNet_Type)<0) {
      printf("** PyType_Ready failed for: oaOccNet\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccNet",
           (PyObject*)(&PyoaOccNet_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccNet\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaOccNet_Type.tp_dict;
    for(method=oaOccNet_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccNetConnectDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccNetConnectDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccNetConnectDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccNetConnectDefObject* self = (PyoaOccNetConnectDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccNetConnectDef)
    {
        PyParamoaOccNetConnectDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccNetConnectDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccNetConnectDef, Choices are:\n"
        "    (oaOccNetConnectDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccNetConnectDef_tp_dealloc(PyoaOccNetConnectDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccNetConnectDef_tp_repr(PyObject *ob)
{
    PyParamoaOccNetConnectDef value;
    int convert_status=PyoaOccNetConnectDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[40];
    sprintf(buffer,"<oaOccNetConnectDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccNetConnectDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccNetConnectDef v1;
    PyParamoaOccNetConnectDef v2;
    int convert_status1=PyoaOccNetConnectDef_Convert(ob1,&v1);
    int convert_status2=PyoaOccNetConnectDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccNetConnectDef_Convert(PyObject* ob,PyParamoaOccNetConnectDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccNetConnectDef_Check(ob)) {
        result->SetData( (oaOccNetConnectDef**) ((PyoaOccNetConnectDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccNetConnectDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccNetConnectDef_FromoaOccNetConnectDef(oaOccNetConnectDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccNetConnectDef* data=*value;
        PyObject* bself = PyoaOccNetConnectDef_Type.tp_alloc(&PyoaOccNetConnectDef_Type,0);
        if (bself == NULL) return bself;
        PyoaOccNetConnectDefObject* self = (PyoaOccNetConnectDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccNetConnectDef_FromoaOccNetConnectDef(oaOccNetConnectDef* data)
{
    if (data) {
       PyObject* bself = PyoaOccNetConnectDef_Type.tp_alloc(&PyoaOccNetConnectDef_Type,0);
       if (bself == NULL) return bself;
       PyoaOccNetConnectDefObject* self = (PyoaOccNetConnectDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccNetConnectDef_getNet_doc[] = 
"Class: oaOccNetConnectDef, Function: getNet\n"
"  Paramegers: ()\n"
"    Calls: oaOccBitNet* getNet() const\n"
"    Signature: getNet|ptr-oaOccBitNet|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the net associated with this connectDef.\n"
;

static PyObject*
oaOccNetConnectDef_getNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccNetConnectDef data;
    int convert_status=PyoaOccNetConnectDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccNetConnectDefObject* self=(PyoaOccNetConnectDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaOccBitNetp result= (data.DataCall()->getNet());
        return PyoaOccBitNet_FromoaOccBitNet(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccNetConnectDef_isNull_doc[] =
"Class: oaOccNetConnectDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccNetConnectDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccNetConnectDef data;
    int convert_status=PyoaOccNetConnectDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccNetConnectDef_assign_doc[] = 
"Class: oaOccNetConnectDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccNetConnectDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccNetConnectDef data;
  int convert_status=PyoaOccNetConnectDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccNetConnectDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccNetConnectDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccNetConnectDef_methodlist[] = {
    {"getNet",(PyCFunction)oaOccNetConnectDef_getNet,METH_VARARGS,oaOccNetConnectDef_getNet_doc},
    {"isNull",(PyCFunction)oaOccNetConnectDef_tp_isNull,METH_VARARGS,oaOccNetConnectDef_isNull_doc},
    {"assign",(PyCFunction)oaOccNetConnectDef_tp_assign,METH_VARARGS,oaOccNetConnectDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccNetConnectDef_doc[] = 
"Class: oaOccNetConnectDef\n"
"  In the occurrence domain it is not possible directly create any connectDefs or assignments. The occurrence domain versions of these classes are automatically created by OpenAccess as a reflection of objects created in the block or module domain. For further information, see oaConnectDef (and its derived classes) and oaAssignmentDef in the block domain and oaModConnectDef (and its derived classes) and oaModAssignment in the module domain.\n"
"Constructors:\n"
"  Paramegers: (oaOccNetConnectDef)\n"
"    Calls: (const oaOccNetConnectDef&)\n"
"    Signature: oaOccNetConnectDef||cref-oaOccNetConnectDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccNetConnectDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccNetConnectDef",
    sizeof(PyoaOccNetConnectDefObject),
    0,
    (destructor)oaOccNetConnectDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccNetConnectDef_tp_compare,	/* tp_compare */
    (reprfunc)oaOccNetConnectDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccNetConnectDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccNetConnectDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccConnectDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccNetConnectDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccNetConnectDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccNetConnectDef_Type)<0) {
      printf("** PyType_Ready failed for: oaOccNetConnectDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccNetConnectDef",
           (PyObject*)(&PyoaOccNetConnectDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccNetConnectDef\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccObject
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccObject_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccObject_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccObjectObject* self = (PyoaOccObjectObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccObject)
    {
        PyParamoaOccObject p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccObject_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccObject, Choices are:\n"
        "    (oaOccObject)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccObject_tp_dealloc(PyoaOccObjectObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccObject_tp_repr(PyObject *ob)
{
    PyParamoaOccObject value;
    int convert_status=PyoaOccObject_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[33];
    sprintf(buffer,"<oaOccObject::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccObject_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccObject v1;
    PyParamoaOccObject v2;
    int convert_status1=PyoaOccObject_Convert(ob1,&v1);
    int convert_status2=PyoaOccObject_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccObject_Convert(PyObject* ob,PyParamoaOccObject* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccObject_Check(ob)) {
        result->SetData( (oaOccObject**) ((PyoaOccObjectObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccObject Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccObject_FromoaOccObject(oaOccObject** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccObject* data=*value;
        if (data->isOccAssignment()) return PyoaOccAssignment_FromoaOccAssignment((oaOccAssignment**)value,borrow,lock);
        if (data->isOccInst()) return PyoaOccInst_FromoaOccInst((oaOccInst**)value,borrow,lock);
        if (data->getType()==oacOccBusTermDefType) return PyoaOccBusTermDef_FromoaOccBusTermDef((oaOccBusTermDef**)value,borrow,lock);
        if (data->isOccNet()) return PyoaOccNet_FromoaOccNet((oaOccNet**)value,borrow,lock);
        if (data->getType()==oacOccurrenceType) return PyoaOccurrence_FromoaOccurrence((oaOccurrence**)value,borrow,lock);
        if (data->getType()==oacOccVectorInstDefType) return PyoaOccVectorInstDef_FromoaOccVectorInstDef((oaOccVectorInstDef**)value,borrow,lock);
        if (data->isOccTerm()) return PyoaOccTerm_FromoaOccTerm((oaOccTerm**)value,borrow,lock);
        if (data->getType()==oacOccInstTermType) return PyoaOccInstTerm_FromoaOccInstTerm((oaOccInstTerm**)value,borrow,lock);
        if (data->getType()==oacOccModuleInstHeaderType) return PyoaOccModuleInstHeader_FromoaOccModuleInstHeader((oaOccModuleInstHeader**)value,borrow,lock);
        if (data->isOccConnectDef()) return PyoaOccConnectDef_FromoaOccConnectDef((oaOccConnectDef**)value,borrow,lock);
        if (data->getType()==oacOccInstHeaderType) return PyoaOccInstHeader_FromoaOccInstHeader((oaOccInstHeader**)value,borrow,lock);
        if (data->getType()==oacOccBusNetDefType) return PyoaOccBusNetDef_FromoaOccBusNetDef((oaOccBusNetDef**)value,borrow,lock);
        PyObject* bself = PyoaOccObject_Type.tp_alloc(&PyoaOccObject_Type,0);
        if (bself == NULL) return bself;
        PyoaOccObjectObject* self = (PyoaOccObjectObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccObject_FromoaOccObject(oaOccObject* data)
{
    if (data) {
        if (data->isOccAssignment()) return PyoaOccAssignment_FromoaOccAssignment((oaOccAssignment*)data);
        if (data->isOccInst()) return PyoaOccInst_FromoaOccInst((oaOccInst*)data);
        if (data->getType()==oacOccBusTermDefType) return PyoaOccBusTermDef_FromoaOccBusTermDef((oaOccBusTermDef*)data);
        if (data->isOccNet()) return PyoaOccNet_FromoaOccNet((oaOccNet*)data);
        if (data->getType()==oacOccurrenceType) return PyoaOccurrence_FromoaOccurrence((oaOccurrence*)data);
        if (data->getType()==oacOccVectorInstDefType) return PyoaOccVectorInstDef_FromoaOccVectorInstDef((oaOccVectorInstDef*)data);
        if (data->isOccTerm()) return PyoaOccTerm_FromoaOccTerm((oaOccTerm*)data);
        if (data->getType()==oacOccInstTermType) return PyoaOccInstTerm_FromoaOccInstTerm((oaOccInstTerm*)data);
        if (data->getType()==oacOccModuleInstHeaderType) return PyoaOccModuleInstHeader_FromoaOccModuleInstHeader((oaOccModuleInstHeader*)data);
        if (data->isOccConnectDef()) return PyoaOccConnectDef_FromoaOccConnectDef((oaOccConnectDef*)data);
        if (data->getType()==oacOccInstHeaderType) return PyoaOccInstHeader_FromoaOccInstHeader((oaOccInstHeader*)data);
        if (data->getType()==oacOccBusNetDefType) return PyoaOccBusNetDef_FromoaOccBusNetDef((oaOccBusNetDef*)data);
       PyObject* bself = PyoaOccObject_Type.tp_alloc(&PyoaOccObject_Type,0);
       if (bself == NULL) return bself;
       PyoaOccObjectObject* self = (PyoaOccObjectObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccObject_getOccurrence_doc[] = 
"Class: oaOccObject, Function: getOccurrence\n"
"  Paramegers: ()\n"
"    Calls: oaOccurrence* getOccurrence() const\n"
"    Signature: getOccurrence|ptr-oaOccurrence|\n"
"    BrowseData: 1\n"
"    This function returns the oaOccurrence that contains this object.\n"
;

static PyObject*
oaOccObject_getOccurrence(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccObject data;
    int convert_status=PyoaOccObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccObjectObject* self=(PyoaOccObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaOccurrencep result= (data.DataCall()->getOccurrence());
        return PyoaOccurrence_FromoaOccurrence(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccObject_getTopOccurrence_doc[] = 
"Class: oaOccObject, Function: getTopOccurrence\n"
"  Paramegers: ()\n"
"    Calls: oaOccurrence* getTopOccurrence() const\n"
"    Signature: getTopOccurrence|ptr-oaOccurrence|\n"
"    BrowseData: 1\n"
"    This function returns the top oaOccurrence in the design that contains this object.\n"
;

static PyObject*
oaOccObject_getTopOccurrence(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccObject data;
    int convert_status=PyoaOccObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccObjectObject* self=(PyoaOccObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaOccurrencep result= (data.DataCall()->getTopOccurrence());
        return PyoaOccurrence_FromoaOccurrence(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccObject_isOccAssignment_doc[] = 
"Class: oaOccObject, Function: isOccAssignment\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isOccAssignment() const\n"
"    Signature: isOccAssignment|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object is an instance of one of the classes derived from the oaOccAssignment class. The function returns a boolean value of true if the oaOccObject is an oaOccAssignment object.\n"
;

static PyObject*
oaOccObject_isOccAssignment(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccObject data;
    int convert_status=PyoaOccObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccObjectObject* self=(PyoaOccObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isOccAssignment());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccObject_isOccBitInst_doc[] = 
"Class: oaOccObject, Function: isOccBitInst\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isOccBitInst() const\n"
"    Signature: isOccBitInst|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object is an instance of one of the classes derived from the oaOccBitInst class. The function returns a boolean value of true if the oaOccObject is an oaOccBitInst object.\n"
;

static PyObject*
oaOccObject_isOccBitInst(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccObject data;
    int convert_status=PyoaOccObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccObjectObject* self=(PyoaOccObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isOccBitInst());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccObject_isOccBitNet_doc[] = 
"Class: oaOccObject, Function: isOccBitNet\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isOccBitNet() const\n"
"    Signature: isOccBitNet|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object is an instance of one of the classes derived from the oaOccBitNet class. The function returns a boolean value of true if the oaOccObject is an oaOccBitNet object.\n"
;

static PyObject*
oaOccObject_isOccBitNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccObject data;
    int convert_status=PyoaOccObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccObjectObject* self=(PyoaOccObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isOccBitNet());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccObject_isOccBitTerm_doc[] = 
"Class: oaOccObject, Function: isOccBitTerm\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isOccBitTerm() const\n"
"    Signature: isOccBitTerm|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object is an instance of one of the classes derived from the oaOccBitTerm class. The function returns a boolean value of true if the oaOccObject is an oaOccBitTerm object.\n"
;

static PyObject*
oaOccObject_isOccBitTerm(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccObject data;
    int convert_status=PyoaOccObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccObjectObject* self=(PyoaOccObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isOccBitTerm());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccObject_isOccConnectDef_doc[] = 
"Class: oaOccObject, Function: isOccConnectDef\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isOccConnectDef() const\n"
"    Signature: isOccConnectDef|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object is an instance of one of the classes derived from the oaOccConnectDef class. The function returns a boolean value of true if the oaOccObject is an oaOccConnectDef .\n"
;

static PyObject*
oaOccObject_isOccConnectDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccObject data;
    int convert_status=PyoaOccObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccObjectObject* self=(PyoaOccObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isOccConnectDef());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccObject_isOccInst_doc[] = 
"Class: oaOccObject, Function: isOccInst\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isOccInst() const\n"
"    Signature: isOccInst|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object is an instance of one of the classes derived from the oaOccInst class. The function returns a boolean value of true if the oaOccObject is an oaOccInst .\n"
;

static PyObject*
oaOccObject_isOccInst(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccObject data;
    int convert_status=PyoaOccObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccObjectObject* self=(PyoaOccObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isOccInst());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccObject_isOccNet_doc[] = 
"Class: oaOccObject, Function: isOccNet\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isOccNet() const\n"
"    Signature: isOccNet|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object is an instance of one of the classes derived from the oaOccNet class. The function returns a boolean value of true if the oaOccObject is an oaOccNet .\n"
;

static PyObject*
oaOccObject_isOccNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccObject data;
    int convert_status=PyoaOccObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccObjectObject* self=(PyoaOccObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isOccNet());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccObject_isOccTerm_doc[] = 
"Class: oaOccObject, Function: isOccTerm\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isOccTerm() const\n"
"    Signature: isOccTerm|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object is an instance of one of the classes derived from the oaOccTerm class. The function returns a boolean value of true if the oaOccObject is an oaOccTerm .\n"
;

static PyObject*
oaOccObject_isOccTerm(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccObject data;
    int convert_status=PyoaOccObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccObjectObject* self=(PyoaOccObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isOccTerm());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccObject_isNull_doc[] =
"Class: oaOccObject, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccObject_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccObject data;
    int convert_status=PyoaOccObject_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccObject_assign_doc[] = 
"Class: oaOccObject, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccObject_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccObject data;
  int convert_status=PyoaOccObject_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccObject p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccObject_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccObject_methodlist[] = {
    {"getOccurrence",(PyCFunction)oaOccObject_getOccurrence,METH_VARARGS,oaOccObject_getOccurrence_doc},
    {"getTopOccurrence",(PyCFunction)oaOccObject_getTopOccurrence,METH_VARARGS,oaOccObject_getTopOccurrence_doc},
    {"isOccAssignment",(PyCFunction)oaOccObject_isOccAssignment,METH_VARARGS,oaOccObject_isOccAssignment_doc},
    {"isOccBitInst",(PyCFunction)oaOccObject_isOccBitInst,METH_VARARGS,oaOccObject_isOccBitInst_doc},
    {"isOccBitNet",(PyCFunction)oaOccObject_isOccBitNet,METH_VARARGS,oaOccObject_isOccBitNet_doc},
    {"isOccBitTerm",(PyCFunction)oaOccObject_isOccBitTerm,METH_VARARGS,oaOccObject_isOccBitTerm_doc},
    {"isOccConnectDef",(PyCFunction)oaOccObject_isOccConnectDef,METH_VARARGS,oaOccObject_isOccConnectDef_doc},
    {"isOccInst",(PyCFunction)oaOccObject_isOccInst,METH_VARARGS,oaOccObject_isOccInst_doc},
    {"isOccNet",(PyCFunction)oaOccObject_isOccNet,METH_VARARGS,oaOccObject_isOccNet_doc},
    {"isOccTerm",(PyCFunction)oaOccObject_isOccTerm,METH_VARARGS,oaOccObject_isOccTerm_doc},
    {"isNull",(PyCFunction)oaOccObject_tp_isNull,METH_VARARGS,oaOccObject_isNull_doc},
    {"assign",(PyCFunction)oaOccObject_tp_assign,METH_VARARGS,oaOccObject_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccObject_doc[] = 
"Class: oaOccObject\n"
"  This in an abstract base class for all occurrence objects in a design database. It implements functions which are common to all occurrence objects, as well as functions to determine the base types of objects.\n"
"Constructors:\n"
"  Paramegers: (oaOccObject)\n"
"    Calls: (const oaOccObject&)\n"
"    Signature: oaOccObject||cref-oaOccObject,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccObject_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccObject",
    sizeof(PyoaOccObjectObject),
    0,
    (destructor)oaOccObject_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccObject_tp_compare,	/* tp_compare */
    (reprfunc)oaOccObject_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccObject_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccObject_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaDesignObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccObject_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccObject_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccObject_Type)<0) {
      printf("** PyType_Ready failed for: oaOccObject\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccObject",
           (PyObject*)(&PyoaOccObject_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccObject\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccPath
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccPath_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccPath_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccPathObject* self = (PyoaOccPathObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccPath)
    {
        PyParamoaOccPath p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccPath_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccPath, Choices are:\n"
        "    (oaOccPath)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccPath_tp_dealloc(PyoaOccPathObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccPath_tp_repr(PyObject *ob)
{
    PyParamoaOccPath value;
    int convert_status=PyoaOccPath_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[31];
    sprintf(buffer,"<oaOccPath::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccPath_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccPath v1;
    PyParamoaOccPath v2;
    int convert_status1=PyoaOccPath_Convert(ob1,&v1);
    int convert_status2=PyoaOccPath_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccPath_Convert(PyObject* ob,PyParamoaOccPath* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccPath_Check(ob)) {
        result->SetData( (oaOccPath**) ((PyoaOccPathObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccPath Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccPath_FromoaOccPath(oaOccPath** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccPath* data=*value;
        PyObject* bself = PyoaOccPath_Type.tp_alloc(&PyoaOccPath_Type,0);
        if (bself == NULL) return bself;
        PyoaOccPathObject* self = (PyoaOccPathObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccPath_FromoaOccPath(oaOccPath* data)
{
    if (data) {
       PyObject* bself = PyoaOccPath_Type.tp_alloc(&PyoaOccPath_Type,0);
       if (bself == NULL) return bself;
       PyoaOccPathObject* self = (PyoaOccPathObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccPath_getBeginExt_doc[] = 
"Class: oaOccPath, Function: getBeginExt\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getBeginExt() const\n"
"    Signature: getBeginExt|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the beginning extension value for this occPath. By definition, the extension is zero if the style is anything other than variable.\n"
;

static PyObject*
oaOccPath_getBeginExt(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccPath data;
    int convert_status=PyoaOccPath_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccPathObject* self=(PyoaOccPathObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getBeginExt());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccPath_getBoundary_doc[] = 
"Class: oaOccPath, Function: getBoundary\n"
"  Paramegers: (oaPointArray)\n"
"    Calls: void getBoundary(oaPointArray& boundary) const\n"
"    Signature: getBoundary|void-void|ref-oaPointArray,\n"
"    BrowseData: 0,oaPointArray\n"
"    This function fills out 'boundary' with the boundary polygon of this occPath.\n"
"    boundary\n"
"    The point array to be filled with the boundary of this occPath\n"
;

static PyObject*
oaOccPath_getBoundary(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccPath data;
    int convert_status=PyoaOccPath_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccPathObject* self=(PyoaOccPathObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaPointArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaPointArray_Convert,&p1)) {
        data.DataCall()->getBoundary(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccPath_getEndExt_doc[] = 
"Class: oaOccPath, Function: getEndExt\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getEndExt() const\n"
"    Signature: getEndExt|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the ending extension value for this occPath. By definition, the extension is zero if the style is anything other than variable.\n"
;

static PyObject*
oaOccPath_getEndExt(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccPath data;
    int convert_status=PyoaOccPath_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccPathObject* self=(PyoaOccPathObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getEndExt());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccPath_getNumPoints_doc[] = 
"Class: oaOccPath, Function: getNumPoints\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumPoints() const\n"
"    Signature: getNumPoints|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of points in this occPath.\n"
;

static PyObject*
oaOccPath_getNumPoints(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccPath data;
    int convert_status=PyoaOccPath_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccPathObject* self=(PyoaOccPathObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumPoints());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccPath_getPoints_doc[] = 
"Class: oaOccPath, Function: getPoints\n"
"  Paramegers: (oaPointArray)\n"
"    Calls: void getPoints(oaPointArray& points) const\n"
"    Signature: getPoints|void-void|ref-oaPointArray,\n"
"    BrowseData: 0,oaPointArray\n"
"    This function fills out 'points' with the points of this occPath.\n"
"    points\n"
"    The point array to be filled with the points of this occPath\n"
;

static PyObject*
oaOccPath_getPoints(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccPath data;
    int convert_status=PyoaOccPath_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccPathObject* self=(PyoaOccPathObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaPointArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaPointArray_Convert,&p1)) {
        data.DataCall()->getPoints(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccPath_getStyle_doc[] = 
"Class: oaOccPath, Function: getStyle\n"
"  Paramegers: ()\n"
"    Calls: oaPathStyle getStyle() const\n"
"    Signature: getStyle|simple-oaPathStyle|\n"
"    BrowseData: 1\n"
"    This function returns the style of this occPath.\n"
;

static PyObject*
oaOccPath_getStyle(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccPath data;
    int convert_status=PyoaOccPath_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccPathObject* self=(PyoaOccPathObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaPathStyle* result= new oaPathStyle(data.DataCall()->getStyle());
        return PyoaPathStyle_FromoaPathStyle(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccPath_getWidth_doc[] = 
"Class: oaOccPath, Function: getWidth\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getWidth() const\n"
"    Signature: getWidth|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the width of this occPath.\n"
;

static PyObject*
oaOccPath_getWidth(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccPath data;
    int convert_status=PyoaOccPath_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccPathObject* self=(PyoaOccPathObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getWidth());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccPath_isOrthogonal_doc[] = 
"Class: oaOccPath, Function: isOrthogonal\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isOrthogonal() const\n"
"    Signature: isOrthogonal|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether or not this occPath's pointArray is orthogonal.\n"
;

static PyObject*
oaOccPath_isOrthogonal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccPath data;
    int convert_status=PyoaOccPath_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccPathObject* self=(PyoaOccPathObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isOrthogonal());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccPath_isNull_doc[] =
"Class: oaOccPath, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccPath_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccPath data;
    int convert_status=PyoaOccPath_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccPath_assign_doc[] = 
"Class: oaOccPath, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccPath_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccPath data;
  int convert_status=PyoaOccPath_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccPath p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccPath_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccPath_methodlist[] = {
    {"getBeginExt",(PyCFunction)oaOccPath_getBeginExt,METH_VARARGS,oaOccPath_getBeginExt_doc},
    {"getBoundary",(PyCFunction)oaOccPath_getBoundary,METH_VARARGS,oaOccPath_getBoundary_doc},
    {"getEndExt",(PyCFunction)oaOccPath_getEndExt,METH_VARARGS,oaOccPath_getEndExt_doc},
    {"getNumPoints",(PyCFunction)oaOccPath_getNumPoints,METH_VARARGS,oaOccPath_getNumPoints_doc},
    {"getPoints",(PyCFunction)oaOccPath_getPoints,METH_VARARGS,oaOccPath_getPoints_doc},
    {"getStyle",(PyCFunction)oaOccPath_getStyle,METH_VARARGS,oaOccPath_getStyle_doc},
    {"getWidth",(PyCFunction)oaOccPath_getWidth,METH_VARARGS,oaOccPath_getWidth_doc},
    {"isOrthogonal",(PyCFunction)oaOccPath_isOrthogonal,METH_VARARGS,oaOccPath_isOrthogonal_doc},
    {"isNull",(PyCFunction)oaOccPath_tp_isNull,METH_VARARGS,oaOccPath_isNull_doc},
    {"assign",(PyCFunction)oaOccPath_tp_assign,METH_VARARGS,oaOccPath_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccPath_doc[] = 
"Class: oaOccPath\n"
"  The oaOccPath class implements an unique occurrence of an oaPath object in a design hierarchy.\n"
"Constructors:\n"
"  Paramegers: (oaOccPath)\n"
"    Calls: (const oaOccPath&)\n"
"    Signature: oaOccPath||cref-oaOccPath,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccPath_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccPath",
    sizeof(PyoaOccPathObject),
    0,
    (destructor)oaOccPath_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccPath_tp_compare,	/* tp_compare */
    (reprfunc)oaOccPath_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccPath_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccPath_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccShape_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccPath_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccPath_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccPath_Type)<0) {
      printf("** PyType_Ready failed for: oaOccPath\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccPath",
           (PyObject*)(&PyoaOccPath_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccPath\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccPathSeg
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccPathSeg_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccPathSeg_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccPathSegObject* self = (PyoaOccPathSegObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccPathSeg)
    {
        PyParamoaOccPathSeg p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccPathSeg_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccPathSeg, Choices are:\n"
        "    (oaOccPathSeg)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccPathSeg_tp_dealloc(PyoaOccPathSegObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccPathSeg_tp_repr(PyObject *ob)
{
    PyParamoaOccPathSeg value;
    int convert_status=PyoaOccPathSeg_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[34];
    sprintf(buffer,"<oaOccPathSeg::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccPathSeg_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccPathSeg v1;
    PyParamoaOccPathSeg v2;
    int convert_status1=PyoaOccPathSeg_Convert(ob1,&v1);
    int convert_status2=PyoaOccPathSeg_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccPathSeg_Convert(PyObject* ob,PyParamoaOccPathSeg* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccPathSeg_Check(ob)) {
        result->SetData( (oaOccPathSeg**) ((PyoaOccPathSegObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccPathSeg Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccPathSeg_FromoaOccPathSeg(oaOccPathSeg** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccPathSeg* data=*value;
        PyObject* bself = PyoaOccPathSeg_Type.tp_alloc(&PyoaOccPathSeg_Type,0);
        if (bself == NULL) return bself;
        PyoaOccPathSegObject* self = (PyoaOccPathSegObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccPathSeg_FromoaOccPathSeg(oaOccPathSeg* data)
{
    if (data) {
       PyObject* bself = PyoaOccPathSeg_Type.tp_alloc(&PyoaOccPathSeg_Type,0);
       if (bself == NULL) return bself;
       PyoaOccPathSegObject* self = (PyoaOccPathSegObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccPathSeg_getBoundary_doc[] = 
"Class: oaOccPathSeg, Function: getBoundary\n"
"  Paramegers: (oaPointArray)\n"
"    Calls: void getBoundary(oaPointArray& boundary) const\n"
"    Signature: getBoundary|void-void|ref-oaPointArray,\n"
"    BrowseData: 0,oaPointArray\n"
"    This function fills out 'boundary' with the boundary polygon of this occPathSeg.\n"
"    boundary\n"
"    The point array to be filled with the boundary of this occPathSeg.\n"
;

static PyObject*
oaOccPathSeg_getBoundary(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccPathSeg data;
    int convert_status=PyoaOccPathSeg_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccPathSegObject* self=(PyoaOccPathSegObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaPointArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaPointArray_Convert,&p1)) {
        data.DataCall()->getBoundary(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccPathSeg_getPoints_doc[] = 
"Class: oaOccPathSeg, Function: getPoints\n"
"  Paramegers: (oaPoint,oaPoint)\n"
"    Calls: void getPoints(oaPoint& beginPoint,oaPoint& endPoint) const\n"
"    Signature: getPoints|void-void|ref-oaPoint,ref-oaPoint,\n"
"    BrowseData: 0,oaPoint,oaPoint\n"
"    This function returns the begin and end points of this occPathSeg in the specified 'beginPoint' and 'endPoint' arguments.\n"
"    beginPoint\n"
"    The beginning point\n"
"    endPoint\n"
"    The end point\n"
;

static PyObject*
oaOccPathSeg_getPoints(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccPathSeg data;
    int convert_status=PyoaOccPathSeg_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccPathSegObject* self=(PyoaOccPathSegObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaPoint p1;
    PyParamoaPoint p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaPoint_Convert,&p1,
          &PyoaPoint_Convert,&p2)) {
        data.DataCall()->getPoints(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccPathSeg_getStyle_doc[] = 
"Class: oaOccPathSeg, Function: getStyle\n"
"  Paramegers: (oaSegStyle)\n"
"    Calls: void getStyle(oaSegStyle& style) const\n"
"    Signature: getStyle|void-void|ref-oaSegStyle,\n"
"    BrowseData: 0,oaSegStyle\n"
"    This function returns the segStyle associated with this occPathSeg.\n"
"    style\n"
"    The pathSeg style\n"
;

static PyObject*
oaOccPathSeg_getStyle(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccPathSeg data;
    int convert_status=PyoaOccPathSeg_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccPathSegObject* self=(PyoaOccPathSegObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaSegStyle p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaSegStyle_Convert,&p1)) {
        data.DataCall()->getStyle(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccPathSeg_isOrthogonal_doc[] = 
"Class: oaOccPathSeg, Function: isOrthogonal\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isOrthogonal() const\n"
"    Signature: isOrthogonal|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether the points in this occPathSeg are orthogonal.\n"
;

static PyObject*
oaOccPathSeg_isOrthogonal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccPathSeg data;
    int convert_status=PyoaOccPathSeg_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccPathSegObject* self=(PyoaOccPathSegObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isOrthogonal());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccPathSeg_isNull_doc[] =
"Class: oaOccPathSeg, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccPathSeg_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccPathSeg data;
    int convert_status=PyoaOccPathSeg_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccPathSeg_assign_doc[] = 
"Class: oaOccPathSeg, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccPathSeg_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccPathSeg data;
  int convert_status=PyoaOccPathSeg_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccPathSeg p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccPathSeg_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccPathSeg_methodlist[] = {
    {"getBoundary",(PyCFunction)oaOccPathSeg_getBoundary,METH_VARARGS,oaOccPathSeg_getBoundary_doc},
    {"getPoints",(PyCFunction)oaOccPathSeg_getPoints,METH_VARARGS,oaOccPathSeg_getPoints_doc},
    {"getStyle",(PyCFunction)oaOccPathSeg_getStyle,METH_VARARGS,oaOccPathSeg_getStyle_doc},
    {"isOrthogonal",(PyCFunction)oaOccPathSeg_isOrthogonal,METH_VARARGS,oaOccPathSeg_isOrthogonal_doc},
    {"isNull",(PyCFunction)oaOccPathSeg_tp_isNull,METH_VARARGS,oaOccPathSeg_isNull_doc},
    {"assign",(PyCFunction)oaOccPathSeg_tp_assign,METH_VARARGS,oaOccPathSeg_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccPathSeg_doc[] = 
"Class: oaOccPathSeg\n"
"  The oaOccPathSeg class implements an unique occurrence of an oaPathSeg object in a design hierarchy.\n"
"Constructors:\n"
"  Paramegers: (oaOccPathSeg)\n"
"    Calls: (const oaOccPathSeg&)\n"
"    Signature: oaOccPathSeg||cref-oaOccPathSeg,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccPathSeg_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccPathSeg",
    sizeof(PyoaOccPathSegObject),
    0,
    (destructor)oaOccPathSeg_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccPathSeg_tp_compare,	/* tp_compare */
    (reprfunc)oaOccPathSeg_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccPathSeg_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccPathSeg_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccShape_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccPathSeg_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccPathSeg_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccPathSeg_Type)<0) {
      printf("** PyType_Ready failed for: oaOccPathSeg\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccPathSeg",
           (PyObject*)(&PyoaOccPathSeg_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccPathSeg\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccPolygon
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccPolygon_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccPolygon_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccPolygonObject* self = (PyoaOccPolygonObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccPolygon)
    {
        PyParamoaOccPolygon p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccPolygon_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccPolygon, Choices are:\n"
        "    (oaOccPolygon)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccPolygon_tp_dealloc(PyoaOccPolygonObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccPolygon_tp_repr(PyObject *ob)
{
    PyParamoaOccPolygon value;
    int convert_status=PyoaOccPolygon_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[34];
    sprintf(buffer,"<oaOccPolygon::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccPolygon_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccPolygon v1;
    PyParamoaOccPolygon v2;
    int convert_status1=PyoaOccPolygon_Convert(ob1,&v1);
    int convert_status2=PyoaOccPolygon_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccPolygon_Convert(PyObject* ob,PyParamoaOccPolygon* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccPolygon_Check(ob)) {
        result->SetData( (oaOccPolygon**) ((PyoaOccPolygonObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccPolygon Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccPolygon_FromoaOccPolygon(oaOccPolygon** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccPolygon* data=*value;
        PyObject* bself = PyoaOccPolygon_Type.tp_alloc(&PyoaOccPolygon_Type,0);
        if (bself == NULL) return bself;
        PyoaOccPolygonObject* self = (PyoaOccPolygonObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccPolygon_FromoaOccPolygon(oaOccPolygon* data)
{
    if (data) {
       PyObject* bself = PyoaOccPolygon_Type.tp_alloc(&PyoaOccPolygon_Type,0);
       if (bself == NULL) return bself;
       PyoaOccPolygonObject* self = (PyoaOccPolygonObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccPolygon_getNumPoints_doc[] = 
"Class: oaOccPolygon, Function: getNumPoints\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumPoints() const\n"
"    Signature: getNumPoints|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of points in this occPolygon.\n"
;

static PyObject*
oaOccPolygon_getNumPoints(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccPolygon data;
    int convert_status=PyoaOccPolygon_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccPolygonObject* self=(PyoaOccPolygonObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumPoints());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccPolygon_getPoints_doc[] = 
"Class: oaOccPolygon, Function: getPoints\n"
"  Paramegers: (oaPointArray)\n"
"    Calls: void getPoints(oaPointArray& points) const\n"
"    Signature: getPoints|void-void|ref-oaPointArray,\n"
"    BrowseData: 0,oaPointArray\n"
"    This function fills out 'points' with the points of this occPolygon.\n"
"    points\n"
"    The point array to be filled with the points of this occPolygon\n"
;

static PyObject*
oaOccPolygon_getPoints(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccPolygon data;
    int convert_status=PyoaOccPolygon_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccPolygonObject* self=(PyoaOccPolygonObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaPointArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaPointArray_Convert,&p1)) {
        data.DataCall()->getPoints(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccPolygon_isOrthogonal_doc[] = 
"Class: oaOccPolygon, Function: isOrthogonal\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isOrthogonal() const\n"
"    Signature: isOrthogonal|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether or not this occPolygon's pointArray is orthogonal.\n"
;

static PyObject*
oaOccPolygon_isOrthogonal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccPolygon data;
    int convert_status=PyoaOccPolygon_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccPolygonObject* self=(PyoaOccPolygonObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isOrthogonal());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccPolygon_isNull_doc[] =
"Class: oaOccPolygon, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccPolygon_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccPolygon data;
    int convert_status=PyoaOccPolygon_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccPolygon_assign_doc[] = 
"Class: oaOccPolygon, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccPolygon_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccPolygon data;
  int convert_status=PyoaOccPolygon_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccPolygon p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccPolygon_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccPolygon_methodlist[] = {
    {"getNumPoints",(PyCFunction)oaOccPolygon_getNumPoints,METH_VARARGS,oaOccPolygon_getNumPoints_doc},
    {"getPoints",(PyCFunction)oaOccPolygon_getPoints,METH_VARARGS,oaOccPolygon_getPoints_doc},
    {"isOrthogonal",(PyCFunction)oaOccPolygon_isOrthogonal,METH_VARARGS,oaOccPolygon_isOrthogonal_doc},
    {"isNull",(PyCFunction)oaOccPolygon_tp_isNull,METH_VARARGS,oaOccPolygon_isNull_doc},
    {"assign",(PyCFunction)oaOccPolygon_tp_assign,METH_VARARGS,oaOccPolygon_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccPolygon_doc[] = 
"Class: oaOccPolygon\n"
"  The oaOccPolygon class implements an unique occurrence of an oaPolygon object in a design hierarchy.\n"
"Constructors:\n"
"  Paramegers: (oaOccPolygon)\n"
"    Calls: (const oaOccPolygon&)\n"
"    Signature: oaOccPolygon||cref-oaOccPolygon,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccPolygon_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccPolygon",
    sizeof(PyoaOccPolygonObject),
    0,
    (destructor)oaOccPolygon_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccPolygon_tp_compare,	/* tp_compare */
    (reprfunc)oaOccPolygon_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccPolygon_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccPolygon_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccShape_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccPolygon_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccPolygon_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccPolygon_Type)<0) {
      printf("** PyType_Ready failed for: oaOccPolygon\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccPolygon",
           (PyObject*)(&PyoaOccPolygon_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccPolygon\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccPropDisplay
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccPropDisplay_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccPropDisplay_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccPropDisplayObject* self = (PyoaOccPropDisplayObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccPropDisplay)
    {
        PyParamoaOccPropDisplay p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccPropDisplay_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccPropDisplay, Choices are:\n"
        "    (oaOccPropDisplay)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccPropDisplay_tp_dealloc(PyoaOccPropDisplayObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccPropDisplay_tp_repr(PyObject *ob)
{
    PyParamoaOccPropDisplay value;
    int convert_status=PyoaOccPropDisplay_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[38];
    sprintf(buffer,"<oaOccPropDisplay::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccPropDisplay_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccPropDisplay v1;
    PyParamoaOccPropDisplay v2;
    int convert_status1=PyoaOccPropDisplay_Convert(ob1,&v1);
    int convert_status2=PyoaOccPropDisplay_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccPropDisplay_Convert(PyObject* ob,PyParamoaOccPropDisplay* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccPropDisplay_Check(ob)) {
        result->SetData( (oaOccPropDisplay**) ((PyoaOccPropDisplayObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccPropDisplay Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccPropDisplay_FromoaOccPropDisplay(oaOccPropDisplay** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccPropDisplay* data=*value;
        PyObject* bself = PyoaOccPropDisplay_Type.tp_alloc(&PyoaOccPropDisplay_Type,0);
        if (bself == NULL) return bself;
        PyoaOccPropDisplayObject* self = (PyoaOccPropDisplayObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccPropDisplay_FromoaOccPropDisplay(oaOccPropDisplay* data)
{
    if (data) {
       PyObject* bself = PyoaOccPropDisplay_Type.tp_alloc(&PyoaOccPropDisplay_Type,0);
       if (bself == NULL) return bself;
       PyoaOccPropDisplayObject* self = (PyoaOccPropDisplayObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccPropDisplay_getProp_doc[] = 
"Class: oaOccPropDisplay, Function: getProp\n"
"  Paramegers: ()\n"
"    Calls: oaProp* getProp() const\n"
"    Signature: getProp|ptr-oaProp|\n"
"    BrowseData: 1\n"
"    This function returns the property associated with the propDisplay object from which this occPropDisplay is generated.\n"
;

static PyObject*
oaOccPropDisplay_getProp(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccPropDisplay data;
    int convert_status=PyoaOccPropDisplay_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccPropDisplayObject* self=(PyoaOccPropDisplayObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaPropp result= (data.DataCall()->getProp());
        return PyoaProp_FromoaProp(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccPropDisplay_isNull_doc[] =
"Class: oaOccPropDisplay, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccPropDisplay_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccPropDisplay data;
    int convert_status=PyoaOccPropDisplay_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccPropDisplay_assign_doc[] = 
"Class: oaOccPropDisplay, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccPropDisplay_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccPropDisplay data;
  int convert_status=PyoaOccPropDisplay_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccPropDisplay p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccPropDisplay_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccPropDisplay_methodlist[] = {
    {"getProp",(PyCFunction)oaOccPropDisplay_getProp,METH_VARARGS,oaOccPropDisplay_getProp_doc},
    {"isNull",(PyCFunction)oaOccPropDisplay_tp_isNull,METH_VARARGS,oaOccPropDisplay_isNull_doc},
    {"assign",(PyCFunction)oaOccPropDisplay_tp_assign,METH_VARARGS,oaOccPropDisplay_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccPropDisplay_doc[] = 
"Class: oaOccPropDisplay\n"
"  The oaOccPropDisplay class implements an unique occurrence of an oaPropDisplay object in a design hierarchy.\n"
"Constructors:\n"
"  Paramegers: (oaOccPropDisplay)\n"
"    Calls: (const oaOccPropDisplay&)\n"
"    Signature: oaOccPropDisplay||cref-oaOccPropDisplay,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccPropDisplay_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccPropDisplay",
    sizeof(PyoaOccPropDisplayObject),
    0,
    (destructor)oaOccPropDisplay_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccPropDisplay_tp_compare,	/* tp_compare */
    (reprfunc)oaOccPropDisplay_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccPropDisplay_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccPropDisplay_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccTextDisplay_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccPropDisplay_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccPropDisplay_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccPropDisplay_Type)<0) {
      printf("** PyType_Ready failed for: oaOccPropDisplay\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccPropDisplay",
           (PyObject*)(&PyoaOccPropDisplay_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccPropDisplay\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccRect
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccRect_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccRect_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccRectObject* self = (PyoaOccRectObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccRect)
    {
        PyParamoaOccRect p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccRect_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccRect, Choices are:\n"
        "    (oaOccRect)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccRect_tp_dealloc(PyoaOccRectObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccRect_tp_repr(PyObject *ob)
{
    PyParamoaOccRect value;
    int convert_status=PyoaOccRect_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[31];
    sprintf(buffer,"<oaOccRect::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccRect_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccRect v1;
    PyParamoaOccRect v2;
    int convert_status1=PyoaOccRect_Convert(ob1,&v1);
    int convert_status2=PyoaOccRect_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccRect_Convert(PyObject* ob,PyParamoaOccRect* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccRect_Check(ob)) {
        result->SetData( (oaOccRect**) ((PyoaOccRectObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccRect Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccRect_FromoaOccRect(oaOccRect** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccRect* data=*value;
        PyObject* bself = PyoaOccRect_Type.tp_alloc(&PyoaOccRect_Type,0);
        if (bself == NULL) return bself;
        PyoaOccRectObject* self = (PyoaOccRectObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccRect_FromoaOccRect(oaOccRect* data)
{
    if (data) {
       PyObject* bself = PyoaOccRect_Type.tp_alloc(&PyoaOccRect_Type,0);
       if (bself == NULL) return bself;
       PyoaOccRectObject* self = (PyoaOccRectObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccRect_doc[] = 
"Class: oaOccRect\n"
"  The oaOccRect class implements an unique occurrence of an oaRect object in a design hierarchy.\n"
"Constructors:\n"
"  Paramegers: (oaOccRect)\n"
"    Calls: (const oaOccRect&)\n"
"    Signature: oaOccRect||cref-oaOccRect,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccRect_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccRect",
    sizeof(PyoaOccRectObject),
    0,
    (destructor)oaOccRect_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccRect_tp_compare,	/* tp_compare */
    (reprfunc)oaOccRect_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccRect_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccShape_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccRect_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccRect_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccRect_Type)<0) {
      printf("** PyType_Ready failed for: oaOccRect\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccRect",
           (PyObject*)(&PyoaOccRect_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccRect\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccScalarInst
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccScalarInst_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccScalarInst_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccScalarInstObject* self = (PyoaOccScalarInstObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccScalarInst)
    {
        PyParamoaOccScalarInst p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccScalarInst_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccScalarInst, Choices are:\n"
        "    (oaOccScalarInst)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccScalarInst_tp_dealloc(PyoaOccScalarInstObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccScalarInst_tp_repr(PyObject *ob)
{
    PyParamoaOccScalarInst value;
    int convert_status=PyoaOccScalarInst_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaOccScalarInst::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaSimpleName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[37];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaOccScalarInst::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccScalarInst_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccScalarInst v1;
    PyParamoaOccScalarInst v2;
    int convert_status1=PyoaOccScalarInst_Convert(ob1,&v1);
    int convert_status2=PyoaOccScalarInst_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccScalarInst_Convert(PyObject* ob,PyParamoaOccScalarInst* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccScalarInst_Check(ob)) {
        result->SetData( (oaOccScalarInst**) ((PyoaOccScalarInstObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccScalarInst Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccScalarInst_FromoaOccScalarInst(oaOccScalarInst** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccScalarInst* data=*value;
        PyObject* bself = PyoaOccScalarInst_Type.tp_alloc(&PyoaOccScalarInst_Type,0);
        if (bself == NULL) return bself;
        PyoaOccScalarInstObject* self = (PyoaOccScalarInstObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccScalarInst_FromoaOccScalarInst(oaOccScalarInst* data)
{
    if (data) {
       PyObject* bself = PyoaOccScalarInst_Type.tp_alloc(&PyoaOccScalarInst_Type,0);
       if (bself == NULL) return bself;
       PyoaOccScalarInstObject* self = (PyoaOccScalarInstObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccScalarInst_getInst_doc[] = 
"Class: oaOccScalarInst, Function: getInst\n"
"  Paramegers: ()\n"
"    Calls: oaScalarInst* getInst() const\n"
"    Signature: getInst|ptr-oaScalarInst|\n"
"    BrowseData: 1\n"
"    This function returns the corresponding instance in the block domain. NULL will be returned if the master design for this instance does not have a top block.\n"
"    A pointer to an oaOccScalarInst\n"
;

static PyObject*
oaOccScalarInst_getInst(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccScalarInst data;
    int convert_status=PyoaOccScalarInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccScalarInstObject* self=(PyoaOccScalarInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaScalarInstp result= (data.DataCall()->getInst());
        return PyoaScalarInst_FromoaScalarInst(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccScalarInst_getModInst_doc[] = 
"Class: oaOccScalarInst, Function: getModInst\n"
"  Paramegers: ()\n"
"    Calls: oaModScalarInst* getModInst() const\n"
"    Signature: getModInst|ptr-oaModScalarInst|\n"
"    BrowseData: 1\n"
"    This function returns the corresponding instance in the module domain. NULL will be returned if this instance is an occurrence of a physical-only instance.\n"
"    A pointer to an oaModScalarInst\n"
;

static PyObject*
oaOccScalarInst_getModInst(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccScalarInst data;
    int convert_status=PyoaOccScalarInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccScalarInstObject* self=(PyoaOccScalarInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModScalarInstp result= (data.DataCall()->getModInst());
        return PyoaModScalarInst_FromoaModScalarInst(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccScalarInst_getName_doc[] = 
"Class: oaOccScalarInst, Function: getName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getName(oaScalarName& name) const\n"
"    Signature: getName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the local name of this scalarInst in the specified name object. The name is relative to the parent occurrence of this scalarInst.\n"
"    name\n"
"    The returned instance name\n"
"  Paramegers: (oaSimpleName)\n"
"    Calls: void getName(oaSimpleName& name) const\n"
"    Signature: getName|void-void|ref-oaSimpleName,\n"
"    BrowseData: 0,oaSimpleName\n"
"    This function fills out name with the name of this instance.\n"
"    name\n"
"    The returned instance name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function fills out name with the name of this instance. The name is mapped according to the specified nameSpace.\n"
"    ns\n"
"    The nameSpace used to map the name\n"
"    name\n"
"    The returned instance name\n"
;

static PyObject*
oaOccScalarInst_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccScalarInst data;
    int convert_status=PyoaOccScalarInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccScalarInstObject* self=(PyoaOccScalarInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName)
    {
        PyParamoaSimpleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSimpleName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccScalarInst, function: getName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaSimpleName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccScalarInst_getPathName_doc[] = 
"Class: oaOccScalarInst, Function: getPathName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getPathName(oaScalarName& pathName) const\n"
"    Signature: getPathName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the full path name of this scalarInst, relative to the top occurrence in the occurrence hierarchy containing this scalarInst.\n"
"    pathName\n"
"    The returned path name\n"
"  Paramegers: (oaSimpleName)\n"
"    Calls: void getPathName(oaSimpleName& pathName) const\n"
"    Signature: getPathName|void-void|ref-oaSimpleName,\n"
"    BrowseData: 0,oaSimpleName\n"
"    This function fills out pathName with the full path name of this instance, relative to the top occurrence in the occurrence hierarchy containing this instance.\n"
"    pathName\n"
"    The path name of the instance\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getPathName(const oaNameSpace& ns,oaString& pathName) const\n"
"    Signature: getPathName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the full path name of this instance in the specified nameSpace in the specified pathName string. The pathName is relative to the top occurrence in the occurrence hierarchy containing this instance.\n"
"    ns\n"
"    The nameSpace in which to return the name\n"
"    pathName\n"
"    The path name of the instance\n"
;

static PyObject*
oaOccScalarInst_getPathName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccScalarInst data;
    int convert_status=PyoaOccScalarInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccScalarInstObject* self=(PyoaOccScalarInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getPathName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName)
    {
        PyParamoaSimpleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSimpleName_Convert,&p1)) {
            data.DataCall()->getPathName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getPathName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccScalarInst, function: getPathName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaSimpleName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccScalarInst_isNull_doc[] =
"Class: oaOccScalarInst, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccScalarInst_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccScalarInst data;
    int convert_status=PyoaOccScalarInst_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccScalarInst_assign_doc[] = 
"Class: oaOccScalarInst, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccScalarInst_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccScalarInst data;
  int convert_status=PyoaOccScalarInst_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccScalarInst p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccScalarInst_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccScalarInst_methodlist[] = {
    {"getInst",(PyCFunction)oaOccScalarInst_getInst,METH_VARARGS,oaOccScalarInst_getInst_doc},
    {"getModInst",(PyCFunction)oaOccScalarInst_getModInst,METH_VARARGS,oaOccScalarInst_getModInst_doc},
    {"getName",(PyCFunction)oaOccScalarInst_getName,METH_VARARGS,oaOccScalarInst_getName_doc},
    {"getPathName",(PyCFunction)oaOccScalarInst_getPathName,METH_VARARGS,oaOccScalarInst_getPathName_doc},
    {"isNull",(PyCFunction)oaOccScalarInst_tp_isNull,METH_VARARGS,oaOccScalarInst_isNull_doc},
    {"assign",(PyCFunction)oaOccScalarInst_tp_assign,METH_VARARGS,oaOccScalarInst_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccScalarInst_doc[] = 
"Class: oaOccScalarInst\n"
"  The oaOccScalarInst class implements a occurence scalar (single-bit) instance. This is the most common kind of instance. This class has a simple name with no index.\n"
"  oaOccScalarInst objects are always in the occurrence domain.\n"
"Constructors:\n"
"  Paramegers: (oaOccScalarInst)\n"
"    Calls: (const oaOccScalarInst&)\n"
"    Signature: oaOccScalarInst||cref-oaOccScalarInst,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccScalarInst_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccScalarInst",
    sizeof(PyoaOccScalarInstObject),
    0,
    (destructor)oaOccScalarInst_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccScalarInst_tp_compare,	/* tp_compare */
    (reprfunc)oaOccScalarInst_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccScalarInst_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccScalarInst_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccBitInst_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccScalarInst_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccScalarInst_static_find_doc[] = 
"Class: oaOccScalarInst, Function: find\n"
"  Paramegers: (oaOccurrence,oaScalarName)\n"
"    Calls: oaOccScalarInst* find(const oaOccurrence* occurrence,const oaScalarName& name)\n"
"    Signature: find|ptr-oaOccScalarInst|cptr-oaOccurrence,cref-oaScalarName,\n"
"    This function searches the specified occurrence looking for a scalarInst with the specified name . If name is hierarchical, this function will descend into lower levels of occurrence hierarchy, expanding the hierarchy and binding the master designs as needed. The scalarInst is returned if found, otherwise NULL is returned.\n"
"    occurrence\n"
"    The occurrence in which to search\n"
"    name\n"
"    The name of the net to find\n"
"    A pointer to the oaOccScalarInst\n"
;

static PyObject*
oaOccScalarInst_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaOccurrence_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaOccScalarInstp result= (oaOccScalarInst::find(p1.Data(),p2.Data()));
        return PyoaOccScalarInst_FromoaOccScalarInst(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaOccScalarInst_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaOccScalarInst_static_find,METH_VARARGS,oaOccScalarInst_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccScalarInst_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccScalarInst_Type)<0) {
      printf("** PyType_Ready failed for: oaOccScalarInst\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccScalarInst",
           (PyObject*)(&PyoaOccScalarInst_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccScalarInst\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaOccScalarInst_Type.tp_dict;
    for(method=oaOccScalarInst_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccScalarNet
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccScalarNet_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccScalarNet_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccScalarNetObject* self = (PyoaOccScalarNetObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccScalarNet)
    {
        PyParamoaOccScalarNet p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccScalarNet_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccScalarNet, Choices are:\n"
        "    (oaOccScalarNet)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccScalarNet_tp_dealloc(PyoaOccScalarNetObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccScalarNet_tp_repr(PyObject *ob)
{
    PyParamoaOccScalarNet value;
    int convert_status=PyoaOccScalarNet_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaOccScalarNet::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaScalarName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[36];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaOccScalarNet::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccScalarNet_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccScalarNet v1;
    PyParamoaOccScalarNet v2;
    int convert_status1=PyoaOccScalarNet_Convert(ob1,&v1);
    int convert_status2=PyoaOccScalarNet_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccScalarNet_Convert(PyObject* ob,PyParamoaOccScalarNet* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccScalarNet_Check(ob)) {
        result->SetData( (oaOccScalarNet**) ((PyoaOccScalarNetObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccScalarNet Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccScalarNet_FromoaOccScalarNet(oaOccScalarNet** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccScalarNet* data=*value;
        PyObject* bself = PyoaOccScalarNet_Type.tp_alloc(&PyoaOccScalarNet_Type,0);
        if (bself == NULL) return bself;
        PyoaOccScalarNetObject* self = (PyoaOccScalarNetObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccScalarNet_FromoaOccScalarNet(oaOccScalarNet* data)
{
    if (data) {
       PyObject* bself = PyoaOccScalarNet_Type.tp_alloc(&PyoaOccScalarNet_Type,0);
       if (bself == NULL) return bself;
       PyoaOccScalarNetObject* self = (PyoaOccScalarNetObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccScalarNet_getModNet_doc[] = 
"Class: oaOccScalarNet, Function: getModNet\n"
"  Paramegers: ()\n"
"    Calls: oaModScalarNet* getModNet() const\n"
"    Signature: getModNet|ptr-oaModScalarNet|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the corresponding net in the module domain. NULL will be returned if this net is an occurrence of a physical-only net.\n"
"    A pointer to an oaModNet\n"
;

static PyObject*
oaOccScalarNet_getModNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccScalarNet data;
    int convert_status=PyoaOccScalarNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccScalarNetObject* self=(PyoaOccScalarNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModScalarNetp result= (data.DataCall()->getModNet());
        return PyoaModScalarNet_FromoaModScalarNet(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccScalarNet_getName_doc[] = 
"Class: oaOccScalarNet, Function: getName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getName(oaScalarName& name) const\n"
"    Signature: getName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the local name of this scalarNet within its parent occurrence.\n"
"    name\n"
"    The returned net name\n"
"  Paramegers: (oaName)\n"
"    Calls: void getName(oaName& name) const\n"
"    Signature: getName|void-void|ref-oaName,\n"
"    BrowseData: 0,oaName\n"
"    This function returns the local name of this net within its parent occurrence.\n"
"    name\n"
"    The returned net name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the local name of this net in the specified nameSpace in the specified name string. The name is relative to the parent occurrence of this net.\n"
"    ns\n"
"    The nameSpace used to map the name\n"
"    name\n"
"    The returned net name\n"
;

static PyObject*
oaOccScalarNet_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccScalarNet data;
    int convert_status=PyoaOccScalarNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccScalarNetObject* self=(PyoaOccScalarNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaName)
    {
        PyParamoaName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccScalarNet, function: getName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccScalarNet_getNet_doc[] = 
"Class: oaOccScalarNet, Function: getNet\n"
"  Paramegers: ()\n"
"    Calls: oaScalarNet* getNet() const\n"
"    Signature: getNet|ptr-oaScalarNet|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the corresponding net in the block domain. NULL is returned if this occurrence net is not visible to the block domain.\n"
"    A pointer to an oaNet\n"
;

static PyObject*
oaOccScalarNet_getNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccScalarNet data;
    int convert_status=PyoaOccScalarNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccScalarNetObject* self=(PyoaOccScalarNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaScalarNetp result= (data.DataCall()->getNet());
        return PyoaScalarNet_FromoaScalarNet(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccScalarNet_getPathName_doc[] = 
"Class: oaOccScalarNet, Function: getPathName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getPathName(oaScalarName& pathName) const\n"
"    Signature: getPathName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the full path name of this scalarNet, relative to the top occurrence in the occurrence hierarchy containing this scalarNet.\n"
"    pathName\n"
"    The returned path name\n"
"  Paramegers: (oaName)\n"
"    Calls: void getPathName(oaName& pathName) const\n"
"    Signature: getPathName|void-void|ref-oaName,\n"
"    BrowseData: 0,oaName\n"
"    This function returns the full path name of this net, relative to the top occurrence in the occurrence hierarchy containing this net.\n"
"    pathName\n"
"    The returned path name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getPathName(const oaNameSpace& ns,oaString& pathName) const\n"
"    Signature: getPathName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the full path name of this net in the specified nameSpace in the specified pathName string. The pathName is relative to the top occurrence in the occurrence hierarchy containing this net.\n"
"    ns\n"
"    The nameSpace used to map the name\n"
"    pathName\n"
"    The returned path name\n"
;

static PyObject*
oaOccScalarNet_getPathName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccScalarNet data;
    int convert_status=PyoaOccScalarNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccScalarNetObject* self=(PyoaOccScalarNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getPathName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaName)
    {
        PyParamoaName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaName_Convert,&p1)) {
            data.DataCall()->getPathName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getPathName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccScalarNet, function: getPathName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccScalarNet_isNull_doc[] =
"Class: oaOccScalarNet, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccScalarNet_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccScalarNet data;
    int convert_status=PyoaOccScalarNet_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccScalarNet_assign_doc[] = 
"Class: oaOccScalarNet, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccScalarNet_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccScalarNet data;
  int convert_status=PyoaOccScalarNet_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccScalarNet p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccScalarNet_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccScalarNet_methodlist[] = {
    {"getModNet",(PyCFunction)oaOccScalarNet_getModNet,METH_VARARGS,oaOccScalarNet_getModNet_doc},
    {"getName",(PyCFunction)oaOccScalarNet_getName,METH_VARARGS,oaOccScalarNet_getName_doc},
    {"getNet",(PyCFunction)oaOccScalarNet_getNet,METH_VARARGS,oaOccScalarNet_getNet_doc},
    {"getPathName",(PyCFunction)oaOccScalarNet_getPathName,METH_VARARGS,oaOccScalarNet_getPathName_doc},
    {"isNull",(PyCFunction)oaOccScalarNet_tp_isNull,METH_VARARGS,oaOccScalarNet_isNull_doc},
    {"assign",(PyCFunction)oaOccScalarNet_tp_assign,METH_VARARGS,oaOccScalarNet_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccScalarNet_doc[] = 
"Class: oaOccScalarNet\n"
"  The oaOccScalarNet class implements a scalar (single-bit) net.\n"
"Constructors:\n"
"  Paramegers: (oaOccScalarNet)\n"
"    Calls: (const oaOccScalarNet&)\n"
"    Signature: oaOccScalarNet||cref-oaOccScalarNet,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccScalarNet_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccScalarNet",
    sizeof(PyoaOccScalarNetObject),
    0,
    (destructor)oaOccScalarNet_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccScalarNet_tp_compare,	/* tp_compare */
    (reprfunc)oaOccScalarNet_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccScalarNet_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccScalarNet_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccBitNet_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccScalarNet_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccScalarNet_static_find_doc[] = 
"Class: oaOccScalarNet, Function: find\n"
"  Paramegers: (oaOccurrence,oaScalarName)\n"
"    Calls: oaOccScalarNet* find(const oaOccurrence* occurrence,const oaScalarName& name)\n"
"    Signature: find|ptr-oaOccScalarNet|cptr-oaOccurrence,cref-oaScalarName,\n"
"    This function searches the specified occurrence looking for a scalarNet with the specified name . If name is hierarchical, this function will descend into lower levels of occurrence hierarchy, expanding the hierarchy and binding the master designs as needed. The scalarNet is returned if found, otherwise NULL is returned.\n"
"    occurrence\n"
"    The occurrence in which to search\n"
"    name\n"
"    The scalar net name to find\n"
"    A pointer to the oaOccScalarNet\n"
;

static PyObject*
oaOccScalarNet_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaOccurrence_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaOccScalarNetp result= (oaOccScalarNet::find(p1.Data(),p2.Data()));
        return PyoaOccScalarNet_FromoaOccScalarNet(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaOccScalarNet_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaOccScalarNet_static_find,METH_VARARGS,oaOccScalarNet_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccScalarNet_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccScalarNet_Type)<0) {
      printf("** PyType_Ready failed for: oaOccScalarNet\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccScalarNet",
           (PyObject*)(&PyoaOccScalarNet_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccScalarNet\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaOccScalarNet_Type.tp_dict;
    for(method=oaOccScalarNet_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccScalarTerm
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccScalarTerm_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccScalarTerm_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccScalarTermObject* self = (PyoaOccScalarTermObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccScalarTerm)
    {
        PyParamoaOccScalarTerm p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccScalarTerm_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccScalarTerm, Choices are:\n"
        "    (oaOccScalarTerm)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccScalarTerm_tp_dealloc(PyoaOccScalarTermObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccScalarTerm_tp_repr(PyObject *ob)
{
    PyParamoaOccScalarTerm value;
    int convert_status=PyoaOccScalarTerm_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaOccScalarTerm::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaScalarName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[37];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaOccScalarTerm::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccScalarTerm_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccScalarTerm v1;
    PyParamoaOccScalarTerm v2;
    int convert_status1=PyoaOccScalarTerm_Convert(ob1,&v1);
    int convert_status2=PyoaOccScalarTerm_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccScalarTerm_Convert(PyObject* ob,PyParamoaOccScalarTerm* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccScalarTerm_Check(ob)) {
        result->SetData( (oaOccScalarTerm**) ((PyoaOccScalarTermObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccScalarTerm Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccScalarTerm_FromoaOccScalarTerm(oaOccScalarTerm** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccScalarTerm* data=*value;
        PyObject* bself = PyoaOccScalarTerm_Type.tp_alloc(&PyoaOccScalarTerm_Type,0);
        if (bself == NULL) return bself;
        PyoaOccScalarTermObject* self = (PyoaOccScalarTermObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccScalarTerm_FromoaOccScalarTerm(oaOccScalarTerm* data)
{
    if (data) {
       PyObject* bself = PyoaOccScalarTerm_Type.tp_alloc(&PyoaOccScalarTerm_Type,0);
       if (bself == NULL) return bself;
       PyoaOccScalarTermObject* self = (PyoaOccScalarTermObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccScalarTerm_getModTerm_doc[] = 
"Class: oaOccScalarTerm, Function: getModTerm\n"
"  Paramegers: ()\n"
"    Calls: oaModScalarTerm* getModTerm() const\n"
"    Signature: getModTerm|ptr-oaModScalarTerm|\n"
"    BrowseData: 1\n"
"    This function returns the corresponding terminal in the module domain, or NULL if the terminal is not visible in the module domain.\n"
;

static PyObject*
oaOccScalarTerm_getModTerm(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccScalarTerm data;
    int convert_status=PyoaOccScalarTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccScalarTermObject* self=(PyoaOccScalarTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModScalarTermp result= (data.DataCall()->getModTerm());
        return PyoaModScalarTerm_FromoaModScalarTerm(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccScalarTerm_getName_doc[] = 
"Class: oaOccScalarTerm, Function: getName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getName(oaScalarName& name) const\n"
"    Signature: getName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the name of this terminal in the name argument.\n"
"    name\n"
"    The name of the scalar terminal to return\n"
"  Paramegers: (oaName)\n"
"    Calls: void getName(oaName& name) const\n"
"    Signature: getName|void-void|ref-oaName,\n"
"    BrowseData: 0,oaName\n"
"    This function fills out name with the name of this terminal.\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function fills in name with the name of this terminal mapped to the specified nameSpace.\n"
;

static PyObject*
oaOccScalarTerm_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccScalarTerm data;
    int convert_status=PyoaOccScalarTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccScalarTermObject* self=(PyoaOccScalarTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaName)
    {
        PyParamoaName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccScalarTerm, function: getName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccScalarTerm_getTerm_doc[] = 
"Class: oaOccScalarTerm, Function: getTerm\n"
"  Paramegers: ()\n"
"    Calls: oaScalarTerm* getTerm() const\n"
"    Signature: getTerm|ptr-oaScalarTerm|\n"
"    BrowseData: 1\n"
"    This function returns the corresponding terminal in the block domain, or NULL if the terminal is not visible in the block domain.\n"
;

static PyObject*
oaOccScalarTerm_getTerm(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccScalarTerm data;
    int convert_status=PyoaOccScalarTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccScalarTermObject* self=(PyoaOccScalarTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaScalarTermp result= (data.DataCall()->getTerm());
        return PyoaScalarTerm_FromoaScalarTerm(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccScalarTerm_isNull_doc[] =
"Class: oaOccScalarTerm, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccScalarTerm_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccScalarTerm data;
    int convert_status=PyoaOccScalarTerm_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccScalarTerm_assign_doc[] = 
"Class: oaOccScalarTerm, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccScalarTerm_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccScalarTerm data;
  int convert_status=PyoaOccScalarTerm_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccScalarTerm p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccScalarTerm_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccScalarTerm_methodlist[] = {
    {"getModTerm",(PyCFunction)oaOccScalarTerm_getModTerm,METH_VARARGS,oaOccScalarTerm_getModTerm_doc},
    {"getName",(PyCFunction)oaOccScalarTerm_getName,METH_VARARGS,oaOccScalarTerm_getName_doc},
    {"getTerm",(PyCFunction)oaOccScalarTerm_getTerm,METH_VARARGS,oaOccScalarTerm_getTerm_doc},
    {"isNull",(PyCFunction)oaOccScalarTerm_tp_isNull,METH_VARARGS,oaOccScalarTerm_isNull_doc},
    {"assign",(PyCFunction)oaOccScalarTerm_tp_assign,METH_VARARGS,oaOccScalarTerm_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccScalarTerm_doc[] = 
"Class: oaOccScalarTerm\n"
"  The oaOccScalarTerm class implements a scalar (single-bit) terminal in the occurrence domain.\n"
"  oaModScalarTerm , oaOccScalarTerm, and oaScalarTerm each represent scalar terminals on a different kind of master, where in each case the master represents a level of hierarchy in the design.\n"
"  For oaOccScalarTerm, the master is an oaOccurrence , which corresponds to a unique usage of a module or a block in a design. Each oaOccurrence in a design will have a set of zero or more occScalarTerms.\n"
"  For oaModScalarTerm , the master is an oaModule . For oaScalarTerm , the master is an oaBlock , and the top block for the design will have a set of zero or more oaScalarTerms. Typically, many of the oaScalarTerms on the top oaBlock have a corresponding oaModScalarTerm on the top oaModule . The top oaOccurrence will have a corresponding oaOccScalarTerm for each scalarTerm in the union of the terminals between the top oaModule and the top oaBlock .\n"
"  When oaScalarTerm objects are created in the block domain, the corresponding oaOccScalarTerm objects are automatically created on the top oaOccurrence .\n"
"Constructors:\n"
"  Paramegers: (oaOccScalarTerm)\n"
"    Calls: (const oaOccScalarTerm&)\n"
"    Signature: oaOccScalarTerm||cref-oaOccScalarTerm,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccScalarTerm_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccScalarTerm",
    sizeof(PyoaOccScalarTermObject),
    0,
    (destructor)oaOccScalarTerm_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccScalarTerm_tp_compare,	/* tp_compare */
    (reprfunc)oaOccScalarTerm_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccScalarTerm_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccScalarTerm_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccBitTerm_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccScalarTerm_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccScalarTerm_static_find_doc[] = 
"Class: oaOccScalarTerm, Function: find\n"
"  Paramegers: (oaOccurrence,oaScalarName)\n"
"    Calls: oaOccScalarTerm* find(const oaOccurrence* occurrence,const oaScalarName& name)\n"
"    Signature: find|ptr-oaOccScalarTerm|cptr-oaOccurrence,cref-oaScalarName,\n"
"    This function searches the specified occurrence for a scalarTerm with the specified name. The function returns a pointer to the oaOccScalarTerm if it is found. Otherwise, NULL is returned.\n"
"    occ\n"
"    The occurrence to search\n"
"    name\n"
"    The name of the scalar terminal to find\n"
"    A pointer to the scalar terminal, if found; otherwise, NULL is returned\n"
;

static PyObject*
oaOccScalarTerm_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaOccurrence_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaOccScalarTermp result= (oaOccScalarTerm::find(p1.Data(),p2.Data()));
        return PyoaOccScalarTerm_FromoaOccScalarTerm(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaOccScalarTerm_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaOccScalarTerm_static_find,METH_VARARGS,oaOccScalarTerm_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccScalarTerm_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccScalarTerm_Type)<0) {
      printf("** PyType_Ready failed for: oaOccScalarTerm\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccScalarTerm",
           (PyObject*)(&PyoaOccScalarTerm_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccScalarTerm\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaOccScalarTerm_Type.tp_dict;
    for(method=oaOccScalarTerm_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccShape
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccShape_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccShape_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccShapeObject* self = (PyoaOccShapeObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccShape)
    {
        PyParamoaOccShape p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccShape_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccShape, Choices are:\n"
        "    (oaOccShape)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccShape_tp_dealloc(PyoaOccShapeObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccShape_tp_repr(PyObject *ob)
{
    PyParamoaOccShape value;
    int convert_status=PyoaOccShape_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[32];
    sprintf(buffer,"<oaOccShape::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccShape_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccShape v1;
    PyParamoaOccShape v2;
    int convert_status1=PyoaOccShape_Convert(ob1,&v1);
    int convert_status2=PyoaOccShape_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccShape_Convert(PyObject* ob,PyParamoaOccShape* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccShape_Check(ob)) {
        result->SetData( (oaOccShape**) ((PyoaOccShapeObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccShape Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccShape_FromoaOccShape(oaOccShape** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccShape* data=*value;
        if (data->getType()==oacOccPathType) return PyoaOccPath_FromoaOccPath((oaOccPath**)value,borrow,lock);
        if (data->isOccTextDisplay()) return PyoaOccTextDisplay_FromoaOccTextDisplay((oaOccTextDisplay**)value,borrow,lock);
        if (data->getType()==oacOccArcType) return PyoaOccArc_FromoaOccArc((oaOccArc**)value,borrow,lock);
        if (data->getType()==oacOccLineType) return PyoaOccLine_FromoaOccLine((oaOccLine**)value,borrow,lock);
        if (data->getType()==oacOccPathSegType) return PyoaOccPathSeg_FromoaOccPathSeg((oaOccPathSeg**)value,borrow,lock);
        if (data->getType()==oacOccEvalTextType) return PyoaOccEvalText_FromoaOccEvalText((oaOccEvalText**)value,borrow,lock);
        if (data->getType()==oacOccRectType) return PyoaOccRect_FromoaOccRect((oaOccRect**)value,borrow,lock);
        if (data->getType()==oacOccDonutType) return PyoaOccDonut_FromoaOccDonut((oaOccDonut**)value,borrow,lock);
        if (data->getType()==oacOccDotType) return PyoaOccDot_FromoaOccDot((oaOccDot**)value,borrow,lock);
        if (data->getType()==oacOccPolygonType) return PyoaOccPolygon_FromoaOccPolygon((oaOccPolygon**)value,borrow,lock);
        if (data->getType()==oacOccEllipseType) return PyoaOccEllipse_FromoaOccEllipse((oaOccEllipse**)value,borrow,lock);
        PyObject* bself = PyoaOccShape_Type.tp_alloc(&PyoaOccShape_Type,0);
        if (bself == NULL) return bself;
        PyoaOccShapeObject* self = (PyoaOccShapeObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccShape_FromoaOccShape(oaOccShape* data)
{
    if (data) {
        if (data->getType()==oacOccPathType) return PyoaOccPath_FromoaOccPath((oaOccPath*)data);
        if (data->isOccTextDisplay()) return PyoaOccTextDisplay_FromoaOccTextDisplay((oaOccTextDisplay*)data);
        if (data->getType()==oacOccArcType) return PyoaOccArc_FromoaOccArc((oaOccArc*)data);
        if (data->getType()==oacOccLineType) return PyoaOccLine_FromoaOccLine((oaOccLine*)data);
        if (data->getType()==oacOccPathSegType) return PyoaOccPathSeg_FromoaOccPathSeg((oaOccPathSeg*)data);
        if (data->getType()==oacOccEvalTextType) return PyoaOccEvalText_FromoaOccEvalText((oaOccEvalText*)data);
        if (data->getType()==oacOccRectType) return PyoaOccRect_FromoaOccRect((oaOccRect*)data);
        if (data->getType()==oacOccDonutType) return PyoaOccDonut_FromoaOccDonut((oaOccDonut*)data);
        if (data->getType()==oacOccDotType) return PyoaOccDot_FromoaOccDot((oaOccDot*)data);
        if (data->getType()==oacOccPolygonType) return PyoaOccPolygon_FromoaOccPolygon((oaOccPolygon*)data);
        if (data->getType()==oacOccEllipseType) return PyoaOccEllipse_FromoaOccEllipse((oaOccEllipse*)data);
       PyObject* bself = PyoaOccShape_Type.tp_alloc(&PyoaOccShape_Type,0);
       if (bself == NULL) return bself;
       PyoaOccShapeObject* self = (PyoaOccShapeObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccShape_copy_doc[] = 
"Class: oaOccShape, Function: copy\n"
"  Paramegers: (oaTransform)\n"
"    Calls: oaShape* copy(const oaTransform& xform) const\n"
"    Signature: copy|ptr-oaShape|cref-oaTransform,\n"
"    This function copies the occShape into an oaShape object in the design containing the occShape. The new shape is moved from the location of the original by the specified transform. The new shape is returned. An exception is thrown if the occShape is an occTextDisplay and the shape from which the occShape is generated is not in the top level design.\n"
"    xform\n"
"    The transformation used to transform the occShape\n"
"    oacInvalidTextDisplayCopy\n"
"  Paramegers: (oaTransform,oaDesign)\n"
"    Calls: oaShape* copy(const oaTransform& xform,oaDesign* design) const\n"
"    Signature: copy|ptr-oaShape|cref-oaTransform,ptr-oaDesign,\n"
"    This function copies the occShape into an oaShape object in the specified design. The new shape is moved from the location of the original by the specified transform. The new shape is returned. An exception is thrown if the occShape is an occTextDisplay and the shape from which the occShape is generated is not in the specified design.\n"
"    xform\n"
"    The transformation used to transform the occShape\n"
"    design\n"
"    The target design\n"
"    oacInvalidTextDisplayCopy\n"
;

static PyObject*
oaOccShape_copy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccShape data;
    int convert_status=PyoaOccShape_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccShapeObject* self=(PyoaOccShapeObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaTransform)
    {
        PyParamoaTransform p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaTransform_Convert,&p1)) {
            oaShapep result= (data.DataCall()->copy(p1.Data()));
            return PyoaShape_FromoaShape(result);
        }
    }
    PyErr_Clear();
    // Case: (oaTransform,oaDesign)
    {
        PyParamoaTransform p1;
        PyParamoaDesign p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaTransform_Convert,&p1,
              &PyoaDesign_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaShapep result= (data.DataCall()->copy(p1.Data(),p2.Data()));
            return PyoaShape_FromoaShape(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccShape, function: copy, Choices are:\n"
        "    (oaTransform)\n"
        "    (oaTransform,oaDesign)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccShape_getBBox_doc[] = 
"Class: oaOccShape, Function: getBBox\n"
"  Paramegers: (oaBox)\n"
"    Calls: void getBBox(oaBox& bBox) const\n"
"    Signature: getBBox|void-void|ref-oaBox,\n"
"    BrowseData: 0,oaBox\n"
"    This function fills out 'bBox' with the bBox of the specified occShape.\n"
"    bBox\n"
"    The bounding box to be filled\n"
;

static PyObject*
oaOccShape_getBBox(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccShape data;
    int convert_status=PyoaOccShape_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccShapeObject* self=(PyoaOccShapeObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBox p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBox_Convert,&p1)) {
        data.DataCall()->getBBox(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccShape_getHeader_doc[] = 
"Class: oaOccShape, Function: getHeader\n"
"  Paramegers: ()\n"
"    Calls: oaLPPHeader* getHeader() const\n"
"    Signature: getHeader|ptr-oaLPPHeader|\n"
"    BrowseData: 1\n"
"    This function returns the lppHeader of the shape from which this occShape is generated.\n"
;

static PyObject*
oaOccShape_getHeader(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccShape data;
    int convert_status=PyoaOccShape_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccShapeObject* self=(PyoaOccShapeObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaLPPHeaderp result= (data.DataCall()->getHeader());
        return PyoaLPPHeader_FromoaLPPHeader(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccShape_getHierPath_doc[] = 
"Class: oaOccShape, Function: getHierPath\n"
"  Paramegers: (oaHierPath)\n"
"    Calls: void getHierPath(oaHierPath& hierPath) const\n"
"    Signature: getHierPath|void-void|ref-oaHierPath,\n"
"    BrowseData: 0,oaHierPath\n"
"    This function fills out the specified 'hierPath' with the hierPath associated with this occShape.\n"
"    hierPath\n"
"    The oaHierPath to be filled\n"
;

static PyObject*
oaOccShape_getHierPath(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccShape data;
    int convert_status=PyoaOccShape_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccShapeObject* self=(PyoaOccShapeObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaHierPath p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaHierPath_Convert,&p1)) {
        data.DataCall()->getHierPath(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccShape_getLayerNum_doc[] = 
"Class: oaOccShape, Function: getLayerNum\n"
"  Paramegers: ()\n"
"    Calls: oaLayerNum getLayerNum() const\n"
"    Signature: getLayerNum|simple-oaLayerNum|\n"
"    BrowseData: 1\n"
"    This function returns the layer number of the shape from which this occShape is generated.\n"
;

static PyObject*
oaOccShape_getLayerNum(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccShape data;
    int convert_status=PyoaOccShape_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccShapeObject* self=(PyoaOccShapeObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaLayerNum result= (data.DataCall()->getLayerNum());
        return PyoaLayerNum_FromoaLayerNum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccShape_getNet_doc[] = 
"Class: oaOccShape, Function: getNet\n"
"  Paramegers: ()\n"
"    Calls: oaNet* getNet() const\n"
"    Signature: getNet|ptr-oaNet|\n"
"    BrowseData: 1\n"
"    This function returns the highest net to which this occShape is attached.\n"
"    Note that this function will return a net if the shape is directly assigned to a net or if the shape is in a route that is assigned to a net. It will not return a net (it will return NULL) if the shape belongs to a pin.\n"
;

static PyObject*
oaOccShape_getNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccShape data;
    int convert_status=PyoaOccShape_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccShapeObject* self=(PyoaOccShapeObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaNetp result= (data.DataCall()->getNet());
        return PyoaNet_FromoaNet(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccShape_getPin_doc[] = 
"Class: oaOccShape, Function: getPin\n"
"  Paramegers: ()\n"
"    Calls: oaPin* getPin() const\n"
"    Signature: getPin|ptr-oaPin|\n"
"    BrowseData: 1\n"
"    This function returns the pin implemented by the shape from which this occShape is generated. If the shape does not implement a pin, NULL is returned.\n"
;

static PyObject*
oaOccShape_getPin(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccShape data;
    int convert_status=PyoaOccShape_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccShapeObject* self=(PyoaOccShapeObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaPinp result= (data.DataCall()->getPin());
        return PyoaPin_FromoaPin(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccShape_getPurposeNum_doc[] = 
"Class: oaOccShape, Function: getPurposeNum\n"
"  Paramegers: ()\n"
"    Calls: oaPurposeNum getPurposeNum() const\n"
"    Signature: getPurposeNum|simple-oaPurposeNum|\n"
"    BrowseData: 1\n"
"    This function returns the purpose number of the shape from which this occShape is generated.\n"
;

static PyObject*
oaOccShape_getPurposeNum(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccShape data;
    int convert_status=PyoaOccShape_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccShapeObject* self=(PyoaOccShapeObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaPurposeNum result= (data.DataCall()->getPurposeNum());
        return PyoaPurposeNum_FromoaPurposeNum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccShape_getRouteStatus_doc[] = 
"Class: oaOccShape, Function: getRouteStatus\n"
"  Paramegers: ()\n"
"    Calls: oaRouteStatus getRouteStatus() const\n"
"    Signature: getRouteStatus|simple-oaRouteStatus|\n"
"    BrowseData: 1\n"
"    This function returns the routeStatus of the shape from which this occShape is generated.\n"
;

static PyObject*
oaOccShape_getRouteStatus(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccShape data;
    int convert_status=PyoaOccShape_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccShapeObject* self=(PyoaOccShapeObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaRouteStatus* result= new oaRouteStatus(data.DataCall()->getRouteStatus());
        return PyoaRouteStatus_FromoaRouteStatus(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccShape_getShape_doc[] = 
"Class: oaOccShape, Function: getShape\n"
"  Paramegers: ()\n"
"    Calls: oaShape* getShape() const\n"
"    Signature: getShape|ptr-oaShape|\n"
"    BrowseData: 1\n"
"    This function returns the shape from which this occShape is generated.\n"
;

static PyObject*
oaOccShape_getShape(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccShape data;
    int convert_status=PyoaOccShape_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccShapeObject* self=(PyoaOccShapeObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaShapep result= (data.DataCall()->getShape());
        return PyoaShape_FromoaShape(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccShape_hasNet_doc[] = 
"Class: oaOccShape, Function: hasNet\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean hasNet() const\n"
"    Signature: hasNet|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether or not the shape from which this occShape is generated is attached to a net.\n"
;

static PyObject*
oaOccShape_hasNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccShape data;
    int convert_status=PyoaOccShape_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccShapeObject* self=(PyoaOccShapeObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->hasNet());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccShape_hasPin_doc[] = 
"Class: oaOccShape, Function: hasPin\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean hasPin() const\n"
"    Signature: hasPin|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether or not the shape from which this occShape is generated.\n"
;

static PyObject*
oaOccShape_hasPin(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccShape data;
    int convert_status=PyoaOccShape_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccShapeObject* self=(PyoaOccShapeObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->hasPin());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccShape_release_doc[] = 
"Class: oaOccShape, Function: release\n"
"  Paramegers: ()\n"
"    Calls: void release()\n"
"    Signature: release|void-void|\n"
"    BrowseData: 0\n"
"    This function decrements the refCount of this occShape. If the refCount goes to zero, this occShape will be destroyed.\n"
;

static PyObject*
oaOccShape_release(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccShape data;
    int convert_status=PyoaOccShape_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccShapeObject* self=(PyoaOccShapeObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->release();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccShape_isNull_doc[] =
"Class: oaOccShape, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccShape_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccShape data;
    int convert_status=PyoaOccShape_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccShape_assign_doc[] = 
"Class: oaOccShape, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccShape_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccShape data;
  int convert_status=PyoaOccShape_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccShape p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccShape_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccShape_methodlist[] = {
    {"copy",(PyCFunction)oaOccShape_copy,METH_VARARGS,oaOccShape_copy_doc},
    {"getBBox",(PyCFunction)oaOccShape_getBBox,METH_VARARGS,oaOccShape_getBBox_doc},
    {"getHeader",(PyCFunction)oaOccShape_getHeader,METH_VARARGS,oaOccShape_getHeader_doc},
    {"getHierPath",(PyCFunction)oaOccShape_getHierPath,METH_VARARGS,oaOccShape_getHierPath_doc},
    {"getLayerNum",(PyCFunction)oaOccShape_getLayerNum,METH_VARARGS,oaOccShape_getLayerNum_doc},
    {"getNet",(PyCFunction)oaOccShape_getNet,METH_VARARGS,oaOccShape_getNet_doc},
    {"getPin",(PyCFunction)oaOccShape_getPin,METH_VARARGS,oaOccShape_getPin_doc},
    {"getPurposeNum",(PyCFunction)oaOccShape_getPurposeNum,METH_VARARGS,oaOccShape_getPurposeNum_doc},
    {"getRouteStatus",(PyCFunction)oaOccShape_getRouteStatus,METH_VARARGS,oaOccShape_getRouteStatus_doc},
    {"getShape",(PyCFunction)oaOccShape_getShape,METH_VARARGS,oaOccShape_getShape_doc},
    {"hasNet",(PyCFunction)oaOccShape_hasNet,METH_VARARGS,oaOccShape_hasNet_doc},
    {"hasPin",(PyCFunction)oaOccShape_hasPin,METH_VARARGS,oaOccShape_hasPin_doc},
    {"release",(PyCFunction)oaOccShape_release,METH_VARARGS,oaOccShape_release_doc},
    {"isNull",(PyCFunction)oaOccShape_tp_isNull,METH_VARARGS,oaOccShape_isNull_doc},
    {"assign",(PyCFunction)oaOccShape_tp_assign,METH_VARARGS,oaOccShape_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccShape_doc[] = 
"Class: oaOccShape\n"
"  The oaOccShape class is an abstract base class for all types of occurrence shapes. An oaOccShape object represents an unique occurrence of an oaShape object in a design hierarchy. Each type of oaShape will have a corresponding oaOccShape class. These classes include:\n"
"  oaOccArc oaOccDonut oaOccDot oaOccEllipse oaOccLine oaOccPath oaOccPathSeg oaOccPolygon oaOccRect oaOccText oaOccEvalText oaOccTextDisplay oaOccPropDisplay oaOccAttrDisplay oaOccTextOverride oaOccInstPropDisplay oaOccInstAttrDisplay\n"
"  The oaOccShape class has a read-only interface, which means that oaOccShape objects cannot be saved persistently, cannot have properties attached to them, and cannot be assigned to groups.\n"
"  oaOccShapes are dynamically generated. Applications are responsible for notifying OpenAccess to free the resources associated with each oaOccShape object.\n"
"Constructors:\n"
"  Paramegers: (oaOccShape)\n"
"    Calls: (const oaOccShape&)\n"
"    Signature: oaOccShape||cref-oaOccShape,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccShape_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccShape",
    sizeof(PyoaOccShapeObject),
    0,
    (destructor)oaOccShape_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccShape_tp_compare,	/* tp_compare */
    (reprfunc)oaOccShape_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccShape_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccShape_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaBlockObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccShape_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccShape_static_get_doc[] = 
"Class: oaOccShape, Function: get\n"
"  Paramegers: (oaShape,oaDesign,oaHierPath)\n"
"    Calls: oaOccShape* get(oaShape* shape,oaDesign* topDesign,const oaHierPath& hierPath)\n"
"    Signature: get|ptr-oaOccShape|ptr-oaShape,ptr-oaDesign,cref-oaHierPath,\n"
"    This function returns the occShape associated with the given shape in the design associated with the given hierPath and topDesign. If the occShape does not exist, one will be generated and returned.\n"
"    shape\n"
"    The shape from which the occShape is generated\n"
"    topDesign\n"
"    Specifies the top level design of the design hierarchy associated with the given hierPath\n"
"    hierPath\n"
"    Specifies the hierarchical path from the top level to the design containing the given shape.\n"
"    oacInvalidHierPath\n"
;

static PyObject*
oaOccShape_static_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaShape p1;
    PyParamoaDesign p2;
    PyParamoaHierPath p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaShape_Convert,&p1,
          &PyoaDesign_Convert,&p2,
          &PyoaHierPath_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!PyValidateDbObject(p2.Data(),2)) return NULL;
        oaOccShapep result= (oaOccShape::get(p1.Data(),p2.Data(),p3.Data()));
        return PyoaOccShape_FromoaOccShape(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaOccShape_staticmethodlist[] = {
    {"static_get",(PyCFunction)oaOccShape_static_get,METH_VARARGS,oaOccShape_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccShape_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccShape_Type)<0) {
      printf("** PyType_Ready failed for: oaOccShape\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccShape",
           (PyObject*)(&PyoaOccShape_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccShape\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaOccShape_Type.tp_dict;
    for(method=oaOccShape_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccTerm
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccTerm_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccTerm_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccTermObject* self = (PyoaOccTermObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccTerm)
    {
        PyParamoaOccTerm p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccTerm_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccTerm, Choices are:\n"
        "    (oaOccTerm)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccTerm_tp_dealloc(PyoaOccTermObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccTerm_tp_repr(PyObject *ob)
{
    PyParamoaOccTerm value;
    int convert_status=PyoaOccTerm_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaOccTerm::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[31];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaOccTerm::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccTerm_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccTerm v1;
    PyParamoaOccTerm v2;
    int convert_status1=PyoaOccTerm_Convert(ob1,&v1);
    int convert_status2=PyoaOccTerm_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccTerm_Convert(PyObject* ob,PyParamoaOccTerm* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccTerm_Check(ob)) {
        result->SetData( (oaOccTerm**) ((PyoaOccTermObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccTerm Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccTerm_FromoaOccTerm(oaOccTerm** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccTerm* data=*value;
        if (data->getType()==oacOccBundleTermType) return PyoaOccBundleTerm_FromoaOccBundleTerm((oaOccBundleTerm**)value,borrow,lock);
        if (data->getType()==oacOccBusTermType) return PyoaOccBusTerm_FromoaOccBusTerm((oaOccBusTerm**)value,borrow,lock);
        if (data->isOccBitTerm()) return PyoaOccBitTerm_FromoaOccBitTerm((oaOccBitTerm**)value,borrow,lock);
        PyObject* bself = PyoaOccTerm_Type.tp_alloc(&PyoaOccTerm_Type,0);
        if (bself == NULL) return bself;
        PyoaOccTermObject* self = (PyoaOccTermObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccTerm_FromoaOccTerm(oaOccTerm* data)
{
    if (data) {
        if (data->getType()==oacOccBundleTermType) return PyoaOccBundleTerm_FromoaOccBundleTerm((oaOccBundleTerm*)data);
        if (data->getType()==oacOccBusTermType) return PyoaOccBusTerm_FromoaOccBusTerm((oaOccBusTerm*)data);
        if (data->isOccBitTerm()) return PyoaOccBitTerm_FromoaOccBitTerm((oaOccBitTerm*)data);
       PyObject* bself = PyoaOccTerm_Type.tp_alloc(&PyoaOccTerm_Type,0);
       if (bself == NULL) return bself;
       PyoaOccTermObject* self = (PyoaOccTermObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccTerm_getAssignedNet_doc[] = 
"Class: oaOccTerm, Function: getAssignedNet\n"
"  Paramegers: ()\n"
"    Calls: oaOccNet* getAssignedNet() const\n"
"    Signature: getAssignedNet|ptr-oaOccNet|simple-oaBoolean,\n"
"    BrowseData: 1\n"
"    This function returns the occurence net assigned to this terminal as per the inherited connections specification.\n"
"    NULL will be returned in the following cases:\n"
"    There is no effective connectDef associated with this terminal\n"
"    There is an effective connectDef but no matching assignment, and 'ignoreDefault' is true.\n"
"    Exceptions are thrown for cases when an assignment is found but a net with that name does not exist or if the default net name needs to be used, 'ignoreDefault' is false, but there is no net that matches the default net name specified.\n"
"    ignoreDefault\n"
"    Indicates if the default net name in the specification should be ignored\n"
"    oacCannotFindSpecAssignedDefOccNet\n"
"    oacCannotFindSpecAssignedOccNet\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: oaOccNet* getAssignedNet(oaBoolean ignoreDefault) const\n"
"    Signature: getAssignedNet|ptr-oaOccNet|simple-oaBoolean,\n"
"    This function returns the occurence net assigned to this terminal as per the inherited connections specification.\n"
"    NULL will be returned in the following cases:\n"
"    There is no effective connectDef associated with this terminal\n"
"    There is an effective connectDef but no matching assignment, and 'ignoreDefault' is true.\n"
"    Exceptions are thrown for cases when an assignment is found but a net with that name does not exist or if the default net name needs to be used, 'ignoreDefault' is false, but there is no net that matches the default net name specified.\n"
"    ignoreDefault\n"
"    Indicates if the default net name in the specification should be ignored\n"
"    oacCannotFindSpecAssignedDefOccNet\n"
"    oacCannotFindSpecAssignedOccNet\n"
"  Paramegers: (oaAssignedNetSpec)\n"
"    Calls: oaOccNet* getAssignedNet(oaAssignedNetSpec& spec) const\n"
"    Signature: getAssignedNet|ptr-oaOccNet|ref-oaAssignedNetSpec,simple-oaBoolean,\n"
"    BrowseData: 1,oaAssignedNetSpec\n"
"    This function returns the occurence net assigned to this terminal as per the inherited connections specification.\n"
"    NULL will be returned in the following cases:\n"
"    There is no effective connectDef associated with this terminal\n"
"    There is an effective connectDef but no matching assignment, and 'ignoreDefault' is true.\n"
"    Exceptions are thrown for cases when an assignment is found but a net with that name does not exist or if the default net name needs to be used, 'ignoreDefault' is false, but there is no net that matches the default net name specified.\n"
"    This version is for diagnostic use and returns the set of connectDefs and/or assignments that were looked at in the hierarchy for resolving the assigned net via the 'spec' parameter. Clients can inspect the array which will consist of pointers to either connectDef or assignment objects in the occurrence domain.\n"
"    spec\n"
"    An array that gets populated with pointers to design objects that indicate the assigned net specification\n"
"    ignoreDefault\n"
"    Indicates if the default net name in the specification should be ignored\n"
"    oacCannotFindSpecAssignedDefOccNet\n"
"    oacCannotFindSpecAssignedOccNet\n"
"  Paramegers: (oaAssignedNetSpec,oaBoolean)\n"
"    Calls: oaOccNet* getAssignedNet(oaAssignedNetSpec& spec,oaBoolean ignoreDefault) const\n"
"    Signature: getAssignedNet|ptr-oaOccNet|ref-oaAssignedNetSpec,simple-oaBoolean,\n"
"    This function returns the occurence net assigned to this terminal as per the inherited connections specification.\n"
"    NULL will be returned in the following cases:\n"
"    There is no effective connectDef associated with this terminal\n"
"    There is an effective connectDef but no matching assignment, and 'ignoreDefault' is true.\n"
"    Exceptions are thrown for cases when an assignment is found but a net with that name does not exist or if the default net name needs to be used, 'ignoreDefault' is false, but there is no net that matches the default net name specified.\n"
"    This version is for diagnostic use and returns the set of connectDefs and/or assignments that were looked at in the hierarchy for resolving the assigned net via the 'spec' parameter. Clients can inspect the array which will consist of pointers to either connectDef or assignment objects in the occurrence domain.\n"
"    spec\n"
"    An array that gets populated with pointers to design objects that indicate the assigned net specification\n"
"    ignoreDefault\n"
"    Indicates if the default net name in the specification should be ignored\n"
"    oacCannotFindSpecAssignedDefOccNet\n"
"    oacCannotFindSpecAssignedOccNet\n"
;

static PyObject*
oaOccTerm_getAssignedNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTerm data;
    int convert_status=PyoaOccTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTermObject* self=(PyoaOccTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaOccNetp result= (data.DataCall()->getAssignedNet());
            return PyoaOccNet_FromoaOccNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            oaOccNetp result= (data.DataCall()->getAssignedNet(p1.Data()));
            return PyoaOccNet_FromoaOccNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaAssignedNetSpec)
    {
        PyParamoaAssignedNetSpec p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaAssignedNetSpec_Convert,&p1)) {
            oaOccNetp result= (data.DataCall()->getAssignedNet(p1.Data()));
            return PyoaOccNet_FromoaOccNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaAssignedNetSpec,oaBoolean)
    {
        PyParamoaAssignedNetSpec p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaAssignedNetSpec_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            oaOccNetp result= (data.DataCall()->getAssignedNet(p1.Data(),p2.Data()));
            return PyoaOccNet_FromoaOccNet(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccTerm, function: getAssignedNet, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
        "    (oaAssignedNetSpec)\n"
        "    (oaAssignedNetSpec,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTerm_getBit_doc[] = 
"Class: oaOccTerm, Function: getBit\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaOccBitTerm* getBit(oaUInt4 bitIndex) const\n"
"    Signature: getBit|ptr-oaOccBitTerm|simple-oaUInt4,\n"
"    This function returns a pointer to the terminal that corresponds to the specified bitIndex bit of this terminal. For single-bit terminals, this function returns this terminal. For multi-bit terminals, a busTermBit is returned if this terminal is a busTerm, or a single-bit terminal is returned if this terminal is a bundleTerm.\n"
"    bitIndex\n"
"    Specifies which bit of the terminal to return\n"
"    oacInvalidTermIndex\n"
;

static PyObject*
oaOccTerm_getBit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTerm data;
    int convert_status=PyoaOccTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTermObject* self=(PyoaOccTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaOccBitTermp result= (data.DataCall()->getBit(p1.Data()));
        return PyoaOccBitTerm_FromoaOccBitTerm(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTerm_getModTerm_doc[] = 
"Class: oaOccTerm, Function: getModTerm\n"
"  Paramegers: ()\n"
"    Calls: oaModTerm* getModTerm() const\n"
"    Signature: getModTerm|ptr-oaModTerm|\n"
"    BrowseData: 1\n"
"    This function returns the module terminal corresponding to this occurrence terminal if there is one. There is always either a module terminal or a block terminal ( oaTerm ) or both. It returns NULL if there is no corresponding oaModTerm .\n"
;

static PyObject*
oaOccTerm_getModTerm(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTerm data;
    int convert_status=PyoaOccTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTermObject* self=(PyoaOccTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModTermp result= (data.DataCall()->getModTerm());
        return PyoaModTerm_FromoaModTerm(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTerm_getName_doc[] = 
"Class: oaOccTerm, Function: getName\n"
"  Paramegers: (oaName)\n"
"    Calls: void getName(oaName& name) const\n"
"    Signature: getName|void-void|ref-oaName,\n"
"    BrowseData: 0,oaName\n"
"    This function fills out name with the name of this terminal.\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function fills in name with the name of this terminal mapped to the specified nameSpace.\n"
;

static PyObject*
oaOccTerm_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTerm data;
    int convert_status=PyoaOccTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTermObject* self=(PyoaOccTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaName)
    {
        PyParamoaName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccTerm, function: getName, Choices are:\n"
        "    (oaName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTerm_getNet_doc[] = 
"Class: oaOccTerm, Function: getNet\n"
"  Paramegers: ()\n"
"    Calls: oaOccNet* getNet() const\n"
"    Signature: getNet|ptr-oaOccNet|simple-oaBoolean,\n"
"    BrowseData: 1\n"
"    oaOccTerm::getNet\n"
"    This function returns the net to which this terminal is attached. If preferred is true , the preferred equivalent net associated with the net will be returned instead.\n"
"    preferred\n"
"    indicates whether to return the preferred equivalent\n"
"    A pointer to an oaOccNet\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: oaOccNet* getNet(oaBoolean preferred) const\n"
"    Signature: getNet|ptr-oaOccNet|simple-oaBoolean,\n"
"    oaOccTerm::getNet\n"
"    This function returns the net to which this terminal is attached. If preferred is true , the preferred equivalent net associated with the net will be returned instead.\n"
"    preferred\n"
"    indicates whether to return the preferred equivalent\n"
"    A pointer to an oaOccNet\n"
;

static PyObject*
oaOccTerm_getNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTerm data;
    int convert_status=PyoaOccTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTermObject* self=(PyoaOccTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaOccNetp result= (data.DataCall()->getNet());
            return PyoaOccNet_FromoaOccNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            oaOccNetp result= (data.DataCall()->getNet(p1.Data()));
            return PyoaOccNet_FromoaOccNet(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccTerm, function: getNet, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTerm_getNumBits_doc[] = 
"Class: oaOccTerm, Function: getNumBits\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumBits() const\n"
"    Signature: getNumBits|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of bits in this terminal.\n"
;

static PyObject*
oaOccTerm_getNumBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTerm data;
    int convert_status=PyoaOccTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTermObject* self=(PyoaOccTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumBits());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTerm_getPosition_doc[] = 
"Class: oaOccTerm, Function: getPosition\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getPosition() const\n"
"    Signature: getPosition|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the position that this terminal is assigned to. The value oacNullIndex is returned if this terminal has not been assigned to a position.\n"
;

static PyObject*
oaOccTerm_getPosition(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTerm data;
    int convert_status=PyoaOccTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTermObject* self=(PyoaOccTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getPosition());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTerm_getTerm_doc[] = 
"Class: oaOccTerm, Function: getTerm\n"
"  Paramegers: ()\n"
"    Calls: oaTerm* getTerm() const\n"
"    Signature: getTerm|ptr-oaTerm|\n"
"    BrowseData: 1\n"
"    This function returns the terminal in the block domain that corresponds to this occurrence terminal if there is one. There is always either a module terminal ( oaModTerm ) or a block terminal or both. It returns NULL if there is no corresponding oaTerm .\n"
;

static PyObject*
oaOccTerm_getTerm(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTerm data;
    int convert_status=PyoaOccTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTermObject* self=(PyoaOccTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaTermp result= (data.DataCall()->getTerm());
        return PyoaTerm_FromoaTerm(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTerm_getTermType_doc[] = 
"Class: oaOccTerm, Function: getTermType\n"
"  Paramegers: ()\n"
"    Calls: oaTermType getTermType() const\n"
"    Signature: getTermType|simple-oaTermType|\n"
"    BrowseData: 1\n"
"    This function returns the terminal type of this terminal.\n"
;

static PyObject*
oaOccTerm_getTermType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTerm data;
    int convert_status=PyoaOccTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTermObject* self=(PyoaOccTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaTermType* result= new oaTermType(data.DataCall()->getTermType());
        return PyoaTermType_FromoaTermType(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTerm_isImplicit_doc[] = 
"Class: oaOccTerm, Function: isImplicit\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isImplicit() const\n"
"    Signature: isImplicit|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value that indicates if this terminal is implicit. An implicit terminal is automatically created by the database as part of the explicit creation of a multi-bit terminal.\n"
;

static PyObject*
oaOccTerm_isImplicit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTerm data;
    int convert_status=PyoaOccTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTermObject* self=(PyoaOccTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isImplicit());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTerm_isInterface_doc[] = 
"Class: oaOccTerm, Function: isInterface\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isInterface() const\n"
"    Signature: isInterface|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether this terminal is an interface terminal. An interface terminal is one that was explicitly created by an application calling one of the create functions on the objects derived from oaTerm . Explicitly created terminals define the interface to the block that contains them.\n"
"    Note that an interface terminal that is scalarized is still considered an interface terminal. Implementation data may be added to the resulting bitTerms after scalarization, but the interface terminal remains as a reference to how the interface was originally defined. Further edits to the block may delete the interface terminal, indicating that the interface to the block has indeed changed.\n"
;

static PyObject*
oaOccTerm_isInterface(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTerm data;
    int convert_status=PyoaOccTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTermObject* self=(PyoaOccTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isInterface());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTerm_isNull_doc[] =
"Class: oaOccTerm, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccTerm_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccTerm data;
    int convert_status=PyoaOccTerm_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccTerm_assign_doc[] = 
"Class: oaOccTerm, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccTerm_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccTerm data;
  int convert_status=PyoaOccTerm_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccTerm p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccTerm_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccTerm_methodlist[] = {
    {"getAssignedNet",(PyCFunction)oaOccTerm_getAssignedNet,METH_VARARGS,oaOccTerm_getAssignedNet_doc},
    {"getBit",(PyCFunction)oaOccTerm_getBit,METH_VARARGS,oaOccTerm_getBit_doc},
    {"getModTerm",(PyCFunction)oaOccTerm_getModTerm,METH_VARARGS,oaOccTerm_getModTerm_doc},
    {"getName",(PyCFunction)oaOccTerm_getName,METH_VARARGS,oaOccTerm_getName_doc},
    {"getNet",(PyCFunction)oaOccTerm_getNet,METH_VARARGS,oaOccTerm_getNet_doc},
    {"getNumBits",(PyCFunction)oaOccTerm_getNumBits,METH_VARARGS,oaOccTerm_getNumBits_doc},
    {"getPosition",(PyCFunction)oaOccTerm_getPosition,METH_VARARGS,oaOccTerm_getPosition_doc},
    {"getTerm",(PyCFunction)oaOccTerm_getTerm,METH_VARARGS,oaOccTerm_getTerm_doc},
    {"getTermType",(PyCFunction)oaOccTerm_getTermType,METH_VARARGS,oaOccTerm_getTermType_doc},
    {"isImplicit",(PyCFunction)oaOccTerm_isImplicit,METH_VARARGS,oaOccTerm_isImplicit_doc},
    {"isInterface",(PyCFunction)oaOccTerm_isInterface,METH_VARARGS,oaOccTerm_isInterface_doc},
    {"isNull",(PyCFunction)oaOccTerm_tp_isNull,METH_VARARGS,oaOccTerm_isNull_doc},
    {"assign",(PyCFunction)oaOccTerm_tp_assign,METH_VARARGS,oaOccTerm_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccTerm_doc[] = 
"Class: oaOccTerm\n"
"  The oaOccTerm class is an abstract base for all scalar and multi-bit terminals in the occurrence domain. Occurrence terminals represent the logical connection points for an oaOccurrence . The nets associated with the terminals are logically exported through the terminals to the next level of hierarchy in a design.\n"
"  oaModTerm , oaOccTerm, and oaTerm each represent bus terminals on a different kind of master, where in each case the master represents a level of hierarchy in the design.\n"
"  For oaOccTerm, the master is an oaOccurrence , which corresponds to a unique usage of a module or a block in a design. Each oaOccurrence in a design will have a set of zero or more occTerms.\n"
"  For oaModTerm , the master is an oaModule . For oaTerm , the master is an oaBlock , and the top block for the design will have a set of zero or more modTerms. Typically, many of the oaTerms on the top oaBlock have a corresponding oaModTerm on the top oaModule . The top oaOccurrence will have a corresponding oaOccTerm for each terminal in the union of the terminals between the top oaModule and the top oaBlock .\n"
"  When oaTerm objects are created in the block domain, the corresponding oaOccTerm objects are automatically created on the top oaOccurrence .\n"
"  Multi-bit terminals represent a group of logical connections to import or export from the module. The terminals can consist of busTerms having a single root name with an index range, or they can include bundleTerms that are a more complex grouping of terminals. Multi-bit terminals can have overlapping names. For example, you can have the busTerms \"addr<7:0>\" and \"addr<3:0>\" as long as the overlapping bits are connected to the same nets.\n"
"  All oaOccBusTerms with the same root name are managed by an oaOccBusTermDef . The oaOccBusTermDef tracks the least significant and most significant bits of all the associated oaOccBusTerms, all of the oaOccBusTerms with the same base name, and all of the associated oaOccBusTermBits.\n"
"  oaOccBusTermBits are automatically created for each bit of an oaOccBusTerm , if they do not already exist. oaOccBusTermBits are available for those applications performing scalarized connectivity traversal of the data.\n"
"  oaOccBundleTerms can contain oaOccScalarTerms or oaOccBusTerms. When an oaOccBundleTerm is created, the constituent scalarTerms and busTermBits are automatically created in addition to the bundleTerm itself. All automatically created terminal objects are considered implicit .\n"
"  Names are associated with terminals. The various terminal objects take and return names through the general oaName object but also use the oaScalarName , oaVectorBitName , oaVectorName , and oaBundleName objects. These name objects manage the mapping of names from one nameSpace to another. For example, you can create a terminal using a name in the CDBA nameSpace. Another application can retrieve the terminal name in the Verilog nameSpace directly from the database.\n"
"  The oaOccTerm class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaOccTerm)\n"
"    Calls: (const oaOccTerm&)\n"
"    Signature: oaOccTerm||cref-oaOccTerm,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccTerm_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccTerm",
    sizeof(PyoaOccTermObject),
    0,
    (destructor)oaOccTerm_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccTerm_tp_compare,	/* tp_compare */
    (reprfunc)oaOccTerm_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccTerm_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccTerm_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccTerm_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccTerm_static_find_doc[] = 
"Class: oaOccTerm, Function: find\n"
"  Paramegers: (oaOccurrence,oaName)\n"
"    Calls: oaOccTerm* find(const oaOccurrence* occurrence,const oaName& name)\n"
"    Signature: find|ptr-oaOccTerm|cptr-oaOccurrence,cref-oaName,\n"
"    This function searches the terminals in the specified occurrence for one with the specified name . The specified name cannot be hierarchical since a terminal is local to an instance. If the terminal is found, it is returned. Otherwise NULL is returned.\n"
"  Paramegers: (oaOccurrence,oaUInt4)\n"
"    Calls: oaOccTerm* find(const oaOccurrence* occurrence,oaUInt4 position)\n"
"    Signature: find|ptr-oaOccTerm|cptr-oaOccurrence,simple-oaUInt4,\n"
"    This function the specified occurrence for a terminal assigned to the specified position . The terminal is returned if found. Otherwise, NULL is returned.\n"
"    occurrence\n"
"    The occurrence to search for the terminal\n"
"    position\n"
"    The position of the terminal to match\n"
"    A pointer to an oaOccTerm\n"
;

static PyObject*
oaOccTerm_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaOccurrence,oaName)
    {
        PyParamoaOccurrence p1;
        PyParamoaName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaOccurrence_Convert,&p1,
              &PyoaName_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaOccTermp result= (oaOccTerm::find(p1.Data(),p2.Data()));
            return PyoaOccTerm_FromoaOccTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaOccurrence,oaUInt4)
    {
        PyParamoaOccurrence p1;
        PyParamoaUInt4 p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaOccurrence_Convert,&p1,
              &PyoaUInt4_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaOccTermp result= (oaOccTerm::find(p1.Data(),p2.Data()));
            return PyoaOccTerm_FromoaOccTerm(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccTerm, function: find, Choices are:\n"
        "    (oaOccurrence,oaName)\n"
        "    (oaOccurrence,oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTerm_static_getMaxPosition_doc[] = 
"Class: oaOccTerm, Function: getMaxPosition\n"
"  Paramegers: (oaOccurrence)\n"
"    Calls: oaUInt4 getMaxPosition(const oaOccurrence* occurrence)\n"
"    Signature: getMaxPosition|simple-oaUInt4|cptr-oaOccurrence,\n"
"    This function returns the highest position occupied by a terminal in the specified occurrence . If there are no terminals in the occurrence or no position has been assigned a terminal, the value oacNullIndex is returned.\n"
"    occurrence\n"
"    The occurrence to report the highest assigned terminal position from\n"
;

static PyObject*
oaOccTerm_static_getMaxPosition(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccurrence_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (oaOccTerm::getMaxPosition(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaOccTerm_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaOccTerm_static_find,METH_VARARGS,oaOccTerm_static_find_doc},
    {"static_getMaxPosition",(PyCFunction)oaOccTerm_static_getMaxPosition,METH_VARARGS,oaOccTerm_static_getMaxPosition_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccTerm_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccTerm_Type)<0) {
      printf("** PyType_Ready failed for: oaOccTerm\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccTerm",
           (PyObject*)(&PyoaOccTerm_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccTerm\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaOccTerm_Type.tp_dict;
    for(method=oaOccTerm_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


// ==================================================================
// Array for class: oaOccTerm
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccTerm_Array_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccTerm_Array_Type);
    PyObject* gself = type->tp_alloc(type,0);
    if (gself == NULL) return gself;
    PyoaOccTerm_ArrayObject* self = (PyoaOccTerm_ArrayObject*)gself;
    self->borrow = 0;
    self->locks=NULL;
    static char *kwlist [] = { NULL } ;
    /* Case: () */ 
    {
        if (PyArg_ParseTuple(args,"")) {
            return gself;
        }
    }
    PyErr_Clear();
    /* Case: (int) */
    {
        int p1;
        if (PyArg_ParseTuple(args,(char*)"i",&p1)) {
            self->data.SetLen(p1);
            return gself;
        }
    }
    PyErr_Clear();
    /* Case: (oaOccTerm_Array) */
    {
        PyParamoaOccTerm_Array p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccTerm_Array_Convert,&p1)) {
            self->data.TakeAway(p1);
            return gself;
        }
    }
    /* Error */
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccTerm_Array, Choices are:\n"
        "    ()\n"
        "    (int)\n"
        "    (oaOccTerm_Array)\n"
    );
    Py_DECREF(gself);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccTerm_Array_dealloc(PyObject* gself)
{
    PyoaOccTerm_ArrayObject* self = (PyoaOccTerm_ArrayObject*)gself;
    Py_XDECREF(self->locks);
    self->ob_type->tp_free(gself);
}

// ------------------------------------------------------------------
static PyObject*
oaOccTerm_Array_str(PyObject *ob)
{
    PyParamoaOccTerm_Array value;
    int convert_status=PyoaOccTerm_Array_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* lst=PyoaOccTerm_Array_CreateList(value);
    PyObject* result=PyObject_Str(lst);
    Py_DECREF(lst);
    return result;
}

// ------------------------------------------------------------------
static PyObject*
oaOccTerm_Array_repr(PyObject *ob)
{
    PyParamoaOccTerm_Array value;
    int convert_status=PyoaOccTerm_Array_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* lst=PyoaOccTerm_Array_CreateList(value);
    PyObject* result=PyObject_Repr(lst);
    Py_DECREF(lst);
    return result;
}

// ------------------------------------------------------------------
static int
oaOccTerm_Array_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccTerm_Array p1;
    PyParamoaOccTerm_Array p2;
    int s1=PyoaOccTerm_Array_Convert(ob1,&p1);
    int s2=PyoaOccTerm_Array_Convert(ob2,&p2);
    assert(s1!=0);
    assert(s2!=0);
    PyObject* l1=PyoaOccTerm_Array_CreateList(p1);
    PyObject* l2=PyoaOccTerm_Array_CreateList(p2);
    int result=PyObject_Compare(l1,l2);
    Py_DECREF(l1);
    Py_DECREF(l2);
    return result;
}

// ------------------------------------------------------------------
int
PyoaOccTerm_Array_Convert(PyObject* ob,PyParamoaOccTerm_Array* result)
{
  Pyoa_ssize_t len,i;
  if (PyoaOccTerm_Array_Check(ob)) {
    PyoaOccTerm_ArrayObject* self = (PyoaOccTerm_ArrayObject*)ob;
    result->Borrow(self->data);
  }
  else if (PyList_Check(ob)) {
    len=PyList_Size(ob);
    result->SetLen(len);
    PyParamoaOccTerm data;
    for(i=0;i<len;i++) {
      PyObject* a=PyList_GetItem(ob,i);
      if (!PyoaOccTerm_Convert(a,&data)) return 0;
      result->SetItem(i,data.Data());
    }
  }
  else if (PyTuple_Check(ob)) {
    len=PyTuple_Size(ob);
    result->SetLen(len);
    PyParamoaOccTerm data;
    for(i=0;i<len;i++) {
      PyObject* a=PyTuple_GetItem(ob,i);
      if (!PyoaOccTerm_Convert(a,&data)) return 0;
      result->SetItem(i,data.Data());
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError,
      "Convertion of parameter to class: oaOccTerm_Array Failed");
    return 0;
  }
  return 1;
}

// ------------------------------------------------------------------
PyObject* PyoaOccTerm_Array_FromoaOccTerm_Array(const oaOccTerm_Array& value)
{
  PyObject* gself = PyoaOccTerm_Array_Type.tp_alloc(&PyoaOccTerm_Array_Type,0);
  if (gself == NULL) return gself;
  PyoaOccTerm_ArrayObject* self = (PyoaOccTerm_ArrayObject*)gself;
  self->data = value;
  self->borrow = 0;
  self->locks=NULL;
  return gself;
}

// ------------------------------------------------------------------
PyObject* PyoaOccTerm_Array_FromoaOccTerm_Array(PyTypeoaOccTerm* data,Pyoa_ssize_t len,PyObject* lock)
{
  PyObject* gself = PyoaOccTerm_Array_Type.tp_alloc(&PyoaOccTerm_Array_Type,0);
  if (gself == NULL) return gself;
  PyoaOccTerm_ArrayObject* self = (PyoaOccTerm_ArrayObject*)gself;
  self->data.Borrow(data,len);
  self->borrow = 1;
  self->locks=NULL;
  if (lock) PyoaLockObject(self->locks,lock);
  return gself;
}

// ------------------------------------------------------------------
PyObject* PyoaOccTerm_Array_CreateList(PyParamoaOccTerm_Array& value)
{
  Pyoa_ssize_t i;
  PyObject* lst=PyList_New(value.Len());
  for(i=0;i<value.Len();i++) {
    PyObject* ob=PyoaOccTerm_FromoaOccTerm(value.Data()[i]);
    PyList_SetItem(lst,i,ob);
  }
  return lst;
}

// ------------------------------------------------------------------
// Methods
// ------------------------------------------------------------------
static char oaOccTerm_Array_assign_doc[] = 
"Class: oaOccTerm_Array, Function: assign\n"
"  Paramegers: (oaOccTerm_Array)\n"
"    This function assigns the current value.\n"
;

static PyObject*
oaOccTerm_Array_assign(PyObject* ob, PyObject *args)
{
  PyoaOccTerm_ArrayObject* self=(PyoaOccTerm_ArrayObject*)ob;
  try {
    PyParamoaOccTerm_Array p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccTerm_Array_Convert,&p1)) {
        self->data=p1;
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}
// ------------------------------------------------------------------
static char oaOccTerm_Array_list_doc[] = 
"Class: oaOccTerm_Array, Function: list\n"
"  Paramegers: ()\n"
"    This function returns the current value as a list.\n"
;

static PyObject*
oaOccTerm_Array_list(PyObject* ob, PyObject *args)
{
  PyoaOccTerm_ArrayObject* self=(PyoaOccTerm_ArrayObject*)ob;
  try {
    if (PyArg_ParseTuple(args,(char*)"")) {
      return PyoaOccTerm_Array_CreateList(self->data);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}
// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------
static PyMethodDef oaOccTerm_Array_methodlist[] = {
    {"assign",(PyCFunction)oaOccTerm_Array_assign,METH_VARARGS,oaOccTerm_Array_assign_doc},
    {"list",(PyCFunction)oaOccTerm_Array_list,METH_VARARGS,oaOccTerm_Array_list_doc},
   {NULL,NULL,0,NULL}
};

// ------------------------------------------------------------------
static PyObject*
oaOccTerm_Array_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaOccTerm_ArrayObject* self=(PyoaOccTerm_ArrayObject*)ob;
  try {
    PyParamoaOccTerm_Array data;
    int convert_status=PyoaOccTerm_Array_Convert(ob,&data);
    assert(convert_status!=0);
    if (index<0 || index>=data.Len()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    return PyoaOccTerm_FromoaOccTerm(data.GetItemPtr(index),1,self->locks);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static Pyoa_ssize_t
oaOccTerm_Array_index_get_length(PyObject* ob)
{
    PyParamoaOccTerm_Array data;
    int convert_status=PyoaOccTerm_Array_Convert(ob,&data);
    assert(convert_status!=0);
    return data.Len();
}

// ------------------------------------------------------------------
static int
oaOccTerm_Array_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaOccTerm_Array data;
    PyParamoaOccTerm dataitem;
    int convert_status=PyoaOccTerm_Array_Convert(ob,&data);
    assert(convert_status!=0);
    if (index<0 || index>=data.Len()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    if (PyoaOccTerm_Convert(value,&dataitem)==0) return -1;
    data.SetItem(index,dataitem.Data());
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return 0;
  }
}

// ------------------------------------------------------------------
static char oaOccTerm_Array_doc[] =
"Class: oaOccTerm_Array\n"
"  The oaOccTerm_Array utility class provides an array of oaOccTerm.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaOccTerm_Array()\n"
"    Signature: oaOccTerm_Array||\n"
"    This is the default constructor for the oaOccTerm_Array class. This constructor creates an empty oaOccTerm_Array.\n"
"  Paramegers: (oaOccTerm_Array)\n"
"    Calls: (const oaOccTerm_Array&)\n"
"    Signature: oaOccTerm_Array||cref-oaOccTerm_Array,\n"
;

// ------------------------------------------------------------------
static PySequenceMethods oaOccTerm_Array_as_sequence = {
    (Pyoa_inquiry)oaOccTerm_Array_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,              /* sq_concat */
    (Pyoa_intargfunc)0,              /* sq_repeat */
    (Pyoa_intargfunc)oaOccTerm_Array_index_get, /* sq_item */
    (Pyoa_intintargfunc)0,           /* sq_slice */
    (Pyoa_intobjargproc)oaOccTerm_Array_index_set,      /* sq_ass_item */
};

// ------------------------------------------------------------------
PyTypeObject PyoaOccTerm_Array_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccTerm_Array",
    sizeof(PyoaOccTerm_ArrayObject),
    0,
    oaOccTerm_Array_dealloc, /* tp_dealloc */
    0,  /* tp_print */
    0,                                  /* tp_getattr */
    0,                                  /* tp_setattr */
    oaOccTerm_Array_compare,    /* tp_compare */
    oaOccTerm_Array_repr,      /* tp_repr */
    0,                                  /* tp_as_number */
    &oaOccTerm_Array_as_sequence,  /* tp_as_sequence */
    0,                                  /* tp_as_mapping */
    0,                                  /* tp_as_hash */
    0,                                  /* tp_as_call */
    oaOccTerm_Array_str,               /* tp_str */
    0,                                  /* tp_getattro */
    0,                                  /* tp_setattro */
    0,                                  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccTerm_Array_doc, /* tp_doc */
    0,                                  /* tp_traverse */
    0,                                  /* tp_clear */
    0,                                  /* tp_richcompre */
    0,                                  /* tp_weaklistoffset */
    0,                                  /* tp_iter */
    0,                                  /* tp_iternext */
    oaOccTerm_Array_methodlist, /* tp_methods */
    0,                                  /* tp_members */
    0,                                  /* tp_getset */
    0,                                  /* tp_base */
    0,                                  /* tp_dict */
    0,                                  /* tp_descr_get */
    0,                                  /* tp_descr_set */
    0,                                  /* tp_dictoffset */
    0,                                  /* tp_init */
    PyType_GenericAlloc,        /* tp_alloc */
    oaOccTerm_Array_new, /* tp_new */
    _PyObject_Del,      /* tp_free */
};


// ------------------------------------------------------------------
int
PyoaOccTerm_Array_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccTerm_Array_Type)<0) {
      printf("** PyType_Ready failed for: oaOccTerm_Array\n");
      return -1;
    }
    if (PyDict_SetItemString(mod_dict,"oaOccTerm_Array",
           (PyObject*)(&PyoaOccTerm_Array_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccTerm_Array\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccTermArray
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccTermArray_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccTermArray_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccTermArrayObject* self = (PyoaOccTermArrayObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaArrayBase_oaOccTerm*)  new oaOccTermArray();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value = (oaArrayBase_oaOccTerm*)  new oaOccTermArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaOccTermArray)
    {
        PyParamoaOccTermArray p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccTermArray_Convert,&p1)) {
            self->value=(oaArrayBase_oaOccTerm*)  new oaOccTermArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccTermArray, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaOccTermArray)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccTermArray_tp_dealloc(PyoaOccTermArrayObject* self)
{
    if (!self->borrow) {
        delete (oaOccTermArray*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccTermArray_tp_repr(PyObject *ob)
{
    PyParamoaOccTermArray value;
    int convert_status=PyoaOccTermArray_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[36];
    sprintf(buffer,"<oaOccTermArray::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccTermArray_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccTermArray v1;
    PyParamoaOccTermArray v2;
    int convert_status1=PyoaOccTermArray_Convert(ob1,&v1);
    int convert_status2=PyoaOccTermArray_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccTermArray_Convert(PyObject* ob,PyParamoaOccTermArray* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccTermArray_Check(ob)) {
        result->SetData( (oaOccTermArray*) ((PyoaOccTermArrayObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccTermArray Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccTermArray_FromoaOccTermArray(oaOccTermArray* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaOccTermArray_Type.tp_alloc(&PyoaOccTermArray_Type,0);
        if (bself == NULL) return bself;
        PyoaOccTermArrayObject* self = (PyoaOccTermArrayObject*)bself;
        self->value = (oaArrayBase_oaOccTerm*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccTermArray_doc[] = 
"Class: oaOccTermArray\n"
"  The oaOccTermArray class is a utility class that implements an array of occurrence terminal pointers.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaOccTermArray()\n"
"    Signature: oaOccTermArray||simple-oaUInt4,\n"
"    This is the constructor for the oaOccTermArray class. It constructs an array of oaOccTerm pointers of the specified size.\n"
"    sizeIn\n"
"    The initial size to give the array\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaOccTermArray(oaUInt4 sizeIn)\n"
"    Signature: oaOccTermArray||simple-oaUInt4,\n"
"    This is the constructor for the oaOccTermArray class. It constructs an array of oaOccTerm pointers of the specified size.\n"
"    sizeIn\n"
"    The initial size to give the array\n"
"  Paramegers: (oaOccTermArray)\n"
"    Calls: (const oaOccTermArray&)\n"
"    Signature: oaOccTermArray||cref-oaOccTermArray,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccTermArray_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccTermArray",
    sizeof(PyoaOccTermArrayObject),
    0,
    (destructor)oaOccTermArray_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccTermArray_tp_compare,	/* tp_compare */
    (reprfunc)oaOccTermArray_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccTermArray_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaArray_oaOccTerm_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccTermArray_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccTermArray_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccTermArray_Type)<0) {
      printf("** PyType_Ready failed for: oaOccTermArray\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccTermArray",
           (PyObject*)(&PyoaOccTermArray_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccTermArray\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccTermConnectDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccTermConnectDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccTermConnectDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccTermConnectDefObject* self = (PyoaOccTermConnectDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccTermConnectDef)
    {
        PyParamoaOccTermConnectDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccTermConnectDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccTermConnectDef, Choices are:\n"
        "    (oaOccTermConnectDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccTermConnectDef_tp_dealloc(PyoaOccTermConnectDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccTermConnectDef_tp_repr(PyObject *ob)
{
    PyParamoaOccTermConnectDef value;
    int convert_status=PyoaOccTermConnectDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[41];
    sprintf(buffer,"<oaOccTermConnectDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccTermConnectDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccTermConnectDef v1;
    PyParamoaOccTermConnectDef v2;
    int convert_status1=PyoaOccTermConnectDef_Convert(ob1,&v1);
    int convert_status2=PyoaOccTermConnectDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccTermConnectDef_Convert(PyObject* ob,PyParamoaOccTermConnectDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccTermConnectDef_Check(ob)) {
        result->SetData( (oaOccTermConnectDef**) ((PyoaOccTermConnectDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccTermConnectDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccTermConnectDef_FromoaOccTermConnectDef(oaOccTermConnectDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccTermConnectDef* data=*value;
        PyObject* bself = PyoaOccTermConnectDef_Type.tp_alloc(&PyoaOccTermConnectDef_Type,0);
        if (bself == NULL) return bself;
        PyoaOccTermConnectDefObject* self = (PyoaOccTermConnectDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccTermConnectDef_FromoaOccTermConnectDef(oaOccTermConnectDef* data)
{
    if (data) {
       PyObject* bself = PyoaOccTermConnectDef_Type.tp_alloc(&PyoaOccTermConnectDef_Type,0);
       if (bself == NULL) return bself;
       PyoaOccTermConnectDefObject* self = (PyoaOccTermConnectDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccTermConnectDef_getTerm_doc[] = 
"Class: oaOccTermConnectDef, Function: getTerm\n"
"  Paramegers: ()\n"
"    Calls: oaOccBitTerm* getTerm() const\n"
"    Signature: getTerm|ptr-oaOccBitTerm|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the terminal associated with this connection definition.\n"
;

static PyObject*
oaOccTermConnectDef_getTerm(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTermConnectDef data;
    int convert_status=PyoaOccTermConnectDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTermConnectDefObject* self=(PyoaOccTermConnectDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaOccBitTermp result= (data.DataCall()->getTerm());
        return PyoaOccBitTerm_FromoaOccBitTerm(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTermConnectDef_isNull_doc[] =
"Class: oaOccTermConnectDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccTermConnectDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccTermConnectDef data;
    int convert_status=PyoaOccTermConnectDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccTermConnectDef_assign_doc[] = 
"Class: oaOccTermConnectDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccTermConnectDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccTermConnectDef data;
  int convert_status=PyoaOccTermConnectDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccTermConnectDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccTermConnectDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccTermConnectDef_methodlist[] = {
    {"getTerm",(PyCFunction)oaOccTermConnectDef_getTerm,METH_VARARGS,oaOccTermConnectDef_getTerm_doc},
    {"isNull",(PyCFunction)oaOccTermConnectDef_tp_isNull,METH_VARARGS,oaOccTermConnectDef_isNull_doc},
    {"assign",(PyCFunction)oaOccTermConnectDef_tp_assign,METH_VARARGS,oaOccTermConnectDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccTermConnectDef_doc[] = 
"Class: oaOccTermConnectDef\n"
"  In the occurrence domain it is not possible directly create any connectDefs or assignments. The occurrence domain versions of these classes are automatically created by OpenAccess as a reflection of objects created in the block or module domain. For further information, see oaConnectDef (and its derived classes) and oaAssignmentDef in the block domain and oaModConnectDef (and its derived classes) and oaModAssignment in the module domain.\n"
"Constructors:\n"
"  Paramegers: (oaOccTermConnectDef)\n"
"    Calls: (const oaOccTermConnectDef&)\n"
"    Signature: oaOccTermConnectDef||cref-oaOccTermConnectDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccTermConnectDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccTermConnectDef",
    sizeof(PyoaOccTermConnectDefObject),
    0,
    (destructor)oaOccTermConnectDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccTermConnectDef_tp_compare,	/* tp_compare */
    (reprfunc)oaOccTermConnectDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccTermConnectDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccTermConnectDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccConnectDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccTermConnectDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccTermConnectDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccTermConnectDef_Type)<0) {
      printf("** PyType_Ready failed for: oaOccTermConnectDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccTermConnectDef",
           (PyObject*)(&PyoaOccTermConnectDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccTermConnectDef\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccText
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccText_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccText_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccTextObject* self = (PyoaOccTextObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccText)
    {
        PyParamoaOccText p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccText_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccText, Choices are:\n"
        "    (oaOccText)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccText_tp_dealloc(PyoaOccTextObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccText_tp_repr(PyObject *ob)
{
    PyParamoaOccText value;
    int convert_status=PyoaOccText_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[31];
    sprintf(buffer,"<oaOccText::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccText_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccText v1;
    PyParamoaOccText v2;
    int convert_status1=PyoaOccText_Convert(ob1,&v1);
    int convert_status2=PyoaOccText_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccText_Convert(PyObject* ob,PyParamoaOccText* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccText_Check(ob)) {
        result->SetData( (oaOccText**) ((PyoaOccTextObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccText Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccText_FromoaOccText(oaOccText** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccText* data=*value;
        if (data->getType()==oacOccEvalTextType) return PyoaOccEvalText_FromoaOccEvalText((oaOccEvalText**)value,borrow,lock);
        PyObject* bself = PyoaOccText_Type.tp_alloc(&PyoaOccText_Type,0);
        if (bself == NULL) return bself;
        PyoaOccTextObject* self = (PyoaOccTextObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccText_FromoaOccText(oaOccText* data)
{
    if (data) {
        if (data->getType()==oacOccEvalTextType) return PyoaOccEvalText_FromoaOccEvalText((oaOccEvalText*)data);
       PyObject* bself = PyoaOccText_Type.tp_alloc(&PyoaOccText_Type,0);
       if (bself == NULL) return bself;
       PyoaOccTextObject* self = (PyoaOccTextObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccText_getAlignment_doc[] = 
"Class: oaOccText, Function: getAlignment\n"
"  Paramegers: ()\n"
"    Calls: oaTextAlign getAlignment() const\n"
"    Signature: getAlignment|simple-oaTextAlign|\n"
"    BrowseData: 1\n"
"    This function returns the alignment of this occText object.\n"
;

static PyObject*
oaOccText_getAlignment(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccText data;
    int convert_status=PyoaOccText_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTextObject* self=(PyoaOccTextObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaTextAlign* result= new oaTextAlign(data.DataCall()->getAlignment());
        return PyoaTextAlign_FromoaTextAlign(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccText_getFont_doc[] = 
"Class: oaOccText, Function: getFont\n"
"  Paramegers: ()\n"
"    Calls: oaFont getFont() const\n"
"    Signature: getFont|simple-oaFont|\n"
"    BrowseData: 1\n"
"    This function returns the font of this occText object.\n"
;

static PyObject*
oaOccText_getFont(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccText data;
    int convert_status=PyoaOccText_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTextObject* self=(PyoaOccTextObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaFont* result= new oaFont(data.DataCall()->getFont());
        return PyoaFont_FromoaFont(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccText_getHeight_doc[] = 
"Class: oaOccText, Function: getHeight\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getHeight() const\n"
"    Signature: getHeight|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the height of this occText object.\n"
;

static PyObject*
oaOccText_getHeight(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccText data;
    int convert_status=PyoaOccText_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTextObject* self=(PyoaOccTextObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getHeight());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccText_getOrient_doc[] = 
"Class: oaOccText, Function: getOrient\n"
"  Paramegers: ()\n"
"    Calls: oaOrient getOrient() const\n"
"    Signature: getOrient|simple-oaOrient|\n"
"    BrowseData: 1\n"
"    This function returns the orientation of this occText object.\n"
;

static PyObject*
oaOccText_getOrient(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccText data;
    int convert_status=PyoaOccText_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTextObject* self=(PyoaOccTextObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaOrient* result= new oaOrient(data.DataCall()->getOrient());
        return PyoaOrient_FromoaOrient(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccText_getOrigin_doc[] = 
"Class: oaOccText, Function: getOrigin\n"
"  Paramegers: (oaPoint)\n"
"    Calls: void getOrigin(oaPoint& origin) const\n"
"    Signature: getOrigin|void-void|ref-oaPoint,\n"
"    BrowseData: 0,oaPoint\n"
"    This function returns the origin of this occText object.\n"
"    origin\n"
"    The point to be filled with the origin of this occText\n"
;

static PyObject*
oaOccText_getOrigin(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccText data;
    int convert_status=PyoaOccText_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTextObject* self=(PyoaOccTextObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaPoint p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaPoint_Convert,&p1)) {
        data.DataCall()->getOrigin(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccText_getText_doc[] = 
"Class: oaOccText, Function: getText\n"
"  Paramegers: (oaString)\n"
"    Calls: void getText(oaString& text) const\n"
"    Signature: getText|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function returns the value of this occText object.\n"
"    text\n"
"    The text string to be filled\n"
;

static PyObject*
oaOccText_getText(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccText data;
    int convert_status=PyoaOccText_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTextObject* self=(PyoaOccTextObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getText(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccText_hasOverbar_doc[] = 
"Class: oaOccText, Function: hasOverbar\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean hasOverbar() const\n"
"    Signature: hasOverbar|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether or not this occText has an overbar on it.\n"
;

static PyObject*
oaOccText_hasOverbar(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccText data;
    int convert_status=PyoaOccText_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTextObject* self=(PyoaOccTextObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->hasOverbar());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccText_isDrafting_doc[] = 
"Class: oaOccText, Function: isDrafting\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isDrafting() const\n"
"    Signature: isDrafting|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether or not this occText is to be displayed in drafting style or not.\n"
;

static PyObject*
oaOccText_isDrafting(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccText data;
    int convert_status=PyoaOccText_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTextObject* self=(PyoaOccTextObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isDrafting());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccText_isVisible_doc[] = 
"Class: oaOccText, Function: isVisible\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isVisible() const\n"
"    Signature: isVisible|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether or not this occText is to be displayed.\n"
;

static PyObject*
oaOccText_isVisible(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccText data;
    int convert_status=PyoaOccText_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTextObject* self=(PyoaOccTextObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isVisible());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccText_isNull_doc[] =
"Class: oaOccText, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccText_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccText data;
    int convert_status=PyoaOccText_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccText_assign_doc[] = 
"Class: oaOccText, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccText_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccText data;
  int convert_status=PyoaOccText_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccText p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccText_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccText_methodlist[] = {
    {"getAlignment",(PyCFunction)oaOccText_getAlignment,METH_VARARGS,oaOccText_getAlignment_doc},
    {"getFont",(PyCFunction)oaOccText_getFont,METH_VARARGS,oaOccText_getFont_doc},
    {"getHeight",(PyCFunction)oaOccText_getHeight,METH_VARARGS,oaOccText_getHeight_doc},
    {"getOrient",(PyCFunction)oaOccText_getOrient,METH_VARARGS,oaOccText_getOrient_doc},
    {"getOrigin",(PyCFunction)oaOccText_getOrigin,METH_VARARGS,oaOccText_getOrigin_doc},
    {"getText",(PyCFunction)oaOccText_getText,METH_VARARGS,oaOccText_getText_doc},
    {"hasOverbar",(PyCFunction)oaOccText_hasOverbar,METH_VARARGS,oaOccText_hasOverbar_doc},
    {"isDrafting",(PyCFunction)oaOccText_isDrafting,METH_VARARGS,oaOccText_isDrafting_doc},
    {"isVisible",(PyCFunction)oaOccText_isVisible,METH_VARARGS,oaOccText_isVisible_doc},
    {"isNull",(PyCFunction)oaOccText_tp_isNull,METH_VARARGS,oaOccText_isNull_doc},
    {"assign",(PyCFunction)oaOccText_tp_assign,METH_VARARGS,oaOccText_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccText_doc[] = 
"Class: oaOccText\n"
"  The oaOccText class implements an unique occurrence of an oaText object in a design hierarchy.\n"
"Constructors:\n"
"  Paramegers: (oaOccText)\n"
"    Calls: (const oaOccText&)\n"
"    Signature: oaOccText||cref-oaOccText,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccText_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccText",
    sizeof(PyoaOccTextObject),
    0,
    (destructor)oaOccText_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccText_tp_compare,	/* tp_compare */
    (reprfunc)oaOccText_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccText_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccText_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccShape_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccText_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccText_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccText_Type)<0) {
      printf("** PyType_Ready failed for: oaOccText\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccText",
           (PyObject*)(&PyoaOccText_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccText\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccTextDisplay
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccTextDisplay_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccTextDisplay_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccTextDisplayObject* self = (PyoaOccTextDisplayObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccTextDisplay)
    {
        PyParamoaOccTextDisplay p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccTextDisplay_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccTextDisplay, Choices are:\n"
        "    (oaOccTextDisplay)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccTextDisplay_tp_dealloc(PyoaOccTextDisplayObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccTextDisplay_tp_repr(PyObject *ob)
{
    PyParamoaOccTextDisplay value;
    int convert_status=PyoaOccTextDisplay_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[38];
    sprintf(buffer,"<oaOccTextDisplay::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccTextDisplay_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccTextDisplay v1;
    PyParamoaOccTextDisplay v2;
    int convert_status1=PyoaOccTextDisplay_Convert(ob1,&v1);
    int convert_status2=PyoaOccTextDisplay_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccTextDisplay_Convert(PyObject* ob,PyParamoaOccTextDisplay* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccTextDisplay_Check(ob)) {
        result->SetData( (oaOccTextDisplay**) ((PyoaOccTextDisplayObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccTextDisplay Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccTextDisplay_FromoaOccTextDisplay(oaOccTextDisplay** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccTextDisplay* data=*value;
        if (data->getType()==oacOccPropDisplayType) return PyoaOccPropDisplay_FromoaOccPropDisplay((oaOccPropDisplay**)value,borrow,lock);
        if (data->getType()==oacOccTextOverrideType) return PyoaOccTextOverride_FromoaOccTextOverride((oaOccTextOverride**)value,borrow,lock);
        if (data->getType()==oacOccInstAttrDisplayType) return PyoaOccInstAttrDisplay_FromoaOccInstAttrDisplay((oaOccInstAttrDisplay**)value,borrow,lock);
        if (data->getType()==oacOccInstPropDisplayType) return PyoaOccInstPropDisplay_FromoaOccInstPropDisplay((oaOccInstPropDisplay**)value,borrow,lock);
        if (data->getType()==oacOccAttrDisplayType) return PyoaOccAttrDisplay_FromoaOccAttrDisplay((oaOccAttrDisplay**)value,borrow,lock);
        PyObject* bself = PyoaOccTextDisplay_Type.tp_alloc(&PyoaOccTextDisplay_Type,0);
        if (bself == NULL) return bself;
        PyoaOccTextDisplayObject* self = (PyoaOccTextDisplayObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccTextDisplay_FromoaOccTextDisplay(oaOccTextDisplay* data)
{
    if (data) {
        if (data->getType()==oacOccPropDisplayType) return PyoaOccPropDisplay_FromoaOccPropDisplay((oaOccPropDisplay*)data);
        if (data->getType()==oacOccTextOverrideType) return PyoaOccTextOverride_FromoaOccTextOverride((oaOccTextOverride*)data);
        if (data->getType()==oacOccInstAttrDisplayType) return PyoaOccInstAttrDisplay_FromoaOccInstAttrDisplay((oaOccInstAttrDisplay*)data);
        if (data->getType()==oacOccInstPropDisplayType) return PyoaOccInstPropDisplay_FromoaOccInstPropDisplay((oaOccInstPropDisplay*)data);
        if (data->getType()==oacOccAttrDisplayType) return PyoaOccAttrDisplay_FromoaOccAttrDisplay((oaOccAttrDisplay*)data);
       PyObject* bself = PyoaOccTextDisplay_Type.tp_alloc(&PyoaOccTextDisplay_Type,0);
       if (bself == NULL) return bself;
       PyoaOccTextDisplayObject* self = (PyoaOccTextDisplayObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccTextDisplay_getAlignment_doc[] = 
"Class: oaOccTextDisplay, Function: getAlignment\n"
"  Paramegers: ()\n"
"    Calls: oaTextAlign getAlignment() const\n"
"    Signature: getAlignment|simple-oaTextAlign|\n"
"    BrowseData: 1\n"
"    This function returns the alignment of this textDisplay object.\n"
;

static PyObject*
oaOccTextDisplay_getAlignment(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTextDisplay data;
    int convert_status=PyoaOccTextDisplay_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTextDisplayObject* self=(PyoaOccTextDisplayObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaTextAlign* result= new oaTextAlign(data.DataCall()->getAlignment());
        return PyoaTextAlign_FromoaTextAlign(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTextDisplay_getFont_doc[] = 
"Class: oaOccTextDisplay, Function: getFont\n"
"  Paramegers: ()\n"
"    Calls: oaFont getFont() const\n"
"    Signature: getFont|simple-oaFont|\n"
"    BrowseData: 1\n"
"    This function returns the font of this textDisplay object.\n"
;

static PyObject*
oaOccTextDisplay_getFont(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTextDisplay data;
    int convert_status=PyoaOccTextDisplay_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTextDisplayObject* self=(PyoaOccTextDisplayObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaFont* result= new oaFont(data.DataCall()->getFont());
        return PyoaFont_FromoaFont(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTextDisplay_getFormat_doc[] = 
"Class: oaOccTextDisplay, Function: getFormat\n"
"  Paramegers: ()\n"
"    Calls: oaTextDisplayFormat getFormat() const\n"
"    Signature: getFormat|simple-oaTextDisplayFormat|\n"
"    BrowseData: 1\n"
"    This function returns the format of this textDisplay object.\n"
;

static PyObject*
oaOccTextDisplay_getFormat(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTextDisplay data;
    int convert_status=PyoaOccTextDisplay_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTextDisplayObject* self=(PyoaOccTextDisplayObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaTextDisplayFormat* result= new oaTextDisplayFormat(data.DataCall()->getFormat());
        return PyoaTextDisplayFormat_FromoaTextDisplayFormat(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTextDisplay_getHeight_doc[] = 
"Class: oaOccTextDisplay, Function: getHeight\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getHeight() const\n"
"    Signature: getHeight|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the height of this textDisplay object.\n"
;

static PyObject*
oaOccTextDisplay_getHeight(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTextDisplay data;
    int convert_status=PyoaOccTextDisplay_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTextDisplayObject* self=(PyoaOccTextDisplayObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getHeight());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTextDisplay_getOrient_doc[] = 
"Class: oaOccTextDisplay, Function: getOrient\n"
"  Paramegers: ()\n"
"    Calls: oaOrient getOrient() const\n"
"    Signature: getOrient|simple-oaOrient|\n"
"    BrowseData: 1\n"
"    This function returns the orientation of this textDisplay object.\n"
;

static PyObject*
oaOccTextDisplay_getOrient(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTextDisplay data;
    int convert_status=PyoaOccTextDisplay_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTextDisplayObject* self=(PyoaOccTextDisplayObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaOrient* result= new oaOrient(data.DataCall()->getOrient());
        return PyoaOrient_FromoaOrient(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTextDisplay_getOrigin_doc[] = 
"Class: oaOccTextDisplay, Function: getOrigin\n"
"  Paramegers: (oaPoint)\n"
"    Calls: void getOrigin(oaPoint& origin) const\n"
"    Signature: getOrigin|void-void|ref-oaPoint,\n"
"    BrowseData: 0,oaPoint\n"
"    This function returns the origin of this textDisplay object.\n"
"    origin\n"
"    The point to be filled with the origin of this occTextDisplay\n"
;

static PyObject*
oaOccTextDisplay_getOrigin(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTextDisplay data;
    int convert_status=PyoaOccTextDisplay_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTextDisplayObject* self=(PyoaOccTextDisplayObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaPoint p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaPoint_Convert,&p1)) {
        data.DataCall()->getOrigin(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTextDisplay_getText_doc[] = 
"Class: oaOccTextDisplay, Function: getText\n"
"  Paramegers: (oaString)\n"
"    Calls: void getText(oaString& text) const\n"
"    Signature: getText|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function returns the value of this textDisplay object.\n"
"    text\n"
"    The text string to be filled\n"
;

static PyObject*
oaOccTextDisplay_getText(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTextDisplay data;
    int convert_status=PyoaOccTextDisplay_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTextDisplayObject* self=(PyoaOccTextDisplayObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getText(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTextDisplay_hasOverbar_doc[] = 
"Class: oaOccTextDisplay, Function: hasOverbar\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean hasOverbar() const\n"
"    Signature: hasOverbar|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether or not this textDisplay has an overbar on it.\n"
;

static PyObject*
oaOccTextDisplay_hasOverbar(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTextDisplay data;
    int convert_status=PyoaOccTextDisplay_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTextDisplayObject* self=(PyoaOccTextDisplayObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->hasOverbar());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTextDisplay_isDrafting_doc[] = 
"Class: oaOccTextDisplay, Function: isDrafting\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isDrafting() const\n"
"    Signature: isDrafting|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether or not this textDisplay is to be displayed in drafting style or not.\n"
;

static PyObject*
oaOccTextDisplay_isDrafting(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTextDisplay data;
    int convert_status=PyoaOccTextDisplay_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTextDisplayObject* self=(PyoaOccTextDisplayObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isDrafting());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTextDisplay_isVisible_doc[] = 
"Class: oaOccTextDisplay, Function: isVisible\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isVisible() const\n"
"    Signature: isVisible|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether or not this textDisplay is to be displayed.\n"
;

static PyObject*
oaOccTextDisplay_isVisible(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTextDisplay data;
    int convert_status=PyoaOccTextDisplay_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTextDisplayObject* self=(PyoaOccTextDisplayObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isVisible());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTextDisplay_isNull_doc[] =
"Class: oaOccTextDisplay, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccTextDisplay_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccTextDisplay data;
    int convert_status=PyoaOccTextDisplay_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccTextDisplay_assign_doc[] = 
"Class: oaOccTextDisplay, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccTextDisplay_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccTextDisplay data;
  int convert_status=PyoaOccTextDisplay_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccTextDisplay p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccTextDisplay_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccTextDisplay_methodlist[] = {
    {"getAlignment",(PyCFunction)oaOccTextDisplay_getAlignment,METH_VARARGS,oaOccTextDisplay_getAlignment_doc},
    {"getFont",(PyCFunction)oaOccTextDisplay_getFont,METH_VARARGS,oaOccTextDisplay_getFont_doc},
    {"getFormat",(PyCFunction)oaOccTextDisplay_getFormat,METH_VARARGS,oaOccTextDisplay_getFormat_doc},
    {"getHeight",(PyCFunction)oaOccTextDisplay_getHeight,METH_VARARGS,oaOccTextDisplay_getHeight_doc},
    {"getOrient",(PyCFunction)oaOccTextDisplay_getOrient,METH_VARARGS,oaOccTextDisplay_getOrient_doc},
    {"getOrigin",(PyCFunction)oaOccTextDisplay_getOrigin,METH_VARARGS,oaOccTextDisplay_getOrigin_doc},
    {"getText",(PyCFunction)oaOccTextDisplay_getText,METH_VARARGS,oaOccTextDisplay_getText_doc},
    {"hasOverbar",(PyCFunction)oaOccTextDisplay_hasOverbar,METH_VARARGS,oaOccTextDisplay_hasOverbar_doc},
    {"isDrafting",(PyCFunction)oaOccTextDisplay_isDrafting,METH_VARARGS,oaOccTextDisplay_isDrafting_doc},
    {"isVisible",(PyCFunction)oaOccTextDisplay_isVisible,METH_VARARGS,oaOccTextDisplay_isVisible_doc},
    {"isNull",(PyCFunction)oaOccTextDisplay_tp_isNull,METH_VARARGS,oaOccTextDisplay_isNull_doc},
    {"assign",(PyCFunction)oaOccTextDisplay_tp_assign,METH_VARARGS,oaOccTextDisplay_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccTextDisplay_doc[] = 
"Class: oaOccTextDisplay\n"
"  The oaOccTextDisplay class is the base class for all types of occTextDisplay shapes.\n"
"Constructors:\n"
"  Paramegers: (oaOccTextDisplay)\n"
"    Calls: (const oaOccTextDisplay&)\n"
"    Signature: oaOccTextDisplay||cref-oaOccTextDisplay,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccTextDisplay_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccTextDisplay",
    sizeof(PyoaOccTextDisplayObject),
    0,
    (destructor)oaOccTextDisplay_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccTextDisplay_tp_compare,	/* tp_compare */
    (reprfunc)oaOccTextDisplay_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccTextDisplay_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccTextDisplay_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccShape_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccTextDisplay_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccTextDisplay_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccTextDisplay_Type)<0) {
      printf("** PyType_Ready failed for: oaOccTextDisplay\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccTextDisplay",
           (PyObject*)(&PyoaOccTextDisplay_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccTextDisplay\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccTextOverride
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccTextOverride_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccTextOverride_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccTextOverrideObject* self = (PyoaOccTextOverrideObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccTextOverride)
    {
        PyParamoaOccTextOverride p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccTextOverride_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccTextOverride, Choices are:\n"
        "    (oaOccTextOverride)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccTextOverride_tp_dealloc(PyoaOccTextOverrideObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccTextOverride_tp_repr(PyObject *ob)
{
    PyParamoaOccTextOverride value;
    int convert_status=PyoaOccTextOverride_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[39];
    sprintf(buffer,"<oaOccTextOverride::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccTextOverride_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccTextOverride v1;
    PyParamoaOccTextOverride v2;
    int convert_status1=PyoaOccTextOverride_Convert(ob1,&v1);
    int convert_status2=PyoaOccTextOverride_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccTextOverride_Convert(PyObject* ob,PyParamoaOccTextOverride* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccTextOverride_Check(ob)) {
        result->SetData( (oaOccTextOverride**) ((PyoaOccTextOverrideObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccTextOverride Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccTextOverride_FromoaOccTextOverride(oaOccTextOverride** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccTextOverride* data=*value;
        PyObject* bself = PyoaOccTextOverride_Type.tp_alloc(&PyoaOccTextOverride_Type,0);
        if (bself == NULL) return bself;
        PyoaOccTextOverrideObject* self = (PyoaOccTextOverrideObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccTextOverride_FromoaOccTextOverride(oaOccTextOverride* data)
{
    if (data) {
       PyObject* bself = PyoaOccTextOverride_Type.tp_alloc(&PyoaOccTextOverride_Type,0);
       if (bself == NULL) return bself;
       PyoaOccTextOverrideObject* self = (PyoaOccTextOverrideObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccTextOverride_getInst_doc[] = 
"Class: oaOccTextOverride, Function: getInst\n"
"  Paramegers: ()\n"
"    Calls: oaInst* getInst() const\n"
"    Signature: getInst|ptr-oaInst|\n"
"    BrowseData: 1\n"
"    This function returns the instance associated with this textOverride object.\n"
;

static PyObject*
oaOccTextOverride_getInst(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTextOverride data;
    int convert_status=PyoaOccTextOverride_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTextOverrideObject* self=(PyoaOccTextOverrideObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaInstp result= (data.DataCall()->getInst());
        return PyoaInst_FromoaInst(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTextOverride_getMasterText_doc[] = 
"Class: oaOccTextOverride, Function: getMasterText\n"
"  Paramegers: ()\n"
"    Calls: oaText* getMasterText() const\n"
"    Signature: getMasterText|ptr-oaText|\n"
"    BrowseData: 1\n"
"    This function returns the text object associated with this textOverride object. Note that this function will return NULL if the associated instance is not bound, or the associated text is not bound.\n"
"    This function returns the master text associated with this textOverride object. This is the text which is used when attempting to bind to the masterText object.\n"
;

static PyObject*
oaOccTextOverride_getMasterText(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTextOverride data;
    int convert_status=PyoaOccTextOverride_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTextOverrideObject* self=(PyoaOccTextOverrideObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaTextp result= (data.DataCall()->getMasterText());
        return PyoaText_FromoaText(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTextOverride_getMasterTextText_doc[] = 
"Class: oaOccTextOverride, Function: getMasterTextText\n"
"  Paramegers: (oaString)\n"
"    Calls: void getMasterTextText(oaString& text) const\n"
"    Signature: getMasterTextText|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function returns the master text associated with this textOverride object. This is the text which is used when attempting to bind to the masterText object.\n"
"    text\n"
"    The text string to be filled with the master text\n"
;

static PyObject*
oaOccTextOverride_getMasterTextText(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTextOverride data;
    int convert_status=PyoaOccTextOverride_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTextOverrideObject* self=(PyoaOccTextOverrideObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getMasterTextText(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTextOverride_isBound_doc[] = 
"Class: oaOccTextOverride, Function: isBound\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isBound() const\n"
"    Signature: isBound|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean which indicates whether this text display is currently bound to the cross design master text object.\n"
;

static PyObject*
oaOccTextOverride_isBound(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTextOverride data;
    int convert_status=PyoaOccTextOverride_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTextOverrideObject* self=(PyoaOccTextOverrideObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isBound());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTextOverride_isNull_doc[] =
"Class: oaOccTextOverride, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccTextOverride_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccTextOverride data;
    int convert_status=PyoaOccTextOverride_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccTextOverride_assign_doc[] = 
"Class: oaOccTextOverride, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccTextOverride_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccTextOverride data;
  int convert_status=PyoaOccTextOverride_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccTextOverride p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccTextOverride_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccTextOverride_methodlist[] = {
    {"getInst",(PyCFunction)oaOccTextOverride_getInst,METH_VARARGS,oaOccTextOverride_getInst_doc},
    {"getMasterText",(PyCFunction)oaOccTextOverride_getMasterText,METH_VARARGS,oaOccTextOverride_getMasterText_doc},
    {"getMasterTextText",(PyCFunction)oaOccTextOverride_getMasterTextText,METH_VARARGS,oaOccTextOverride_getMasterTextText_doc},
    {"isBound",(PyCFunction)oaOccTextOverride_isBound,METH_VARARGS,oaOccTextOverride_isBound_doc},
    {"isNull",(PyCFunction)oaOccTextOverride_tp_isNull,METH_VARARGS,oaOccTextOverride_isNull_doc},
    {"assign",(PyCFunction)oaOccTextOverride_tp_assign,METH_VARARGS,oaOccTextOverride_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccTextOverride_doc[] = 
"Class: oaOccTextOverride\n"
"  The oaOccTextOverride class implements an unique occurrence of an oaTextOverride object in a design hierarchy.\n"
"Constructors:\n"
"  Paramegers: (oaOccTextOverride)\n"
"    Calls: (const oaOccTextOverride&)\n"
"    Signature: oaOccTextOverride||cref-oaOccTextOverride,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccTextOverride_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccTextOverride",
    sizeof(PyoaOccTextOverrideObject),
    0,
    (destructor)oaOccTextOverride_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccTextOverride_tp_compare,	/* tp_compare */
    (reprfunc)oaOccTextOverride_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccTextOverride_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccTextOverride_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccTextDisplay_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccTextOverride_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccTextOverride_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccTextOverride_Type)<0) {
      printf("** PyType_Ready failed for: oaOccTextOverride\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccTextOverride",
           (PyObject*)(&PyoaOccTextOverride_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccTextOverride\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccTraverser
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccTraverser_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccTraverser_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccTraverserObject* self = (PyoaOccTraverserObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccurrence)
    {
        PyParamoaOccurrence p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaOccurrence_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            self->value =  new oaOccTraverser(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccTraverser, Choices are:\n"
        "    (oaOccurrence)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccTraverser_tp_dealloc(PyoaOccTraverserObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccTraverser_tp_repr(PyObject *ob)
{
    PyParamoaOccTraverser value;
    int convert_status=PyoaOccTraverser_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[36];
    sprintf(buffer,"<oaOccTraverser::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccTraverser_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccTraverser v1;
    PyParamoaOccTraverser v2;
    int convert_status1=PyoaOccTraverser_Convert(ob1,&v1);
    int convert_status2=PyoaOccTraverser_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccTraverser_Convert(PyObject* ob,PyParamoaOccTraverser* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccTraverser_Check(ob)) {
        result->SetData(  ((PyoaOccTraverserObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccTraverser Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccTraverser_FromoaOccTraverser(oaOccTraverser* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaOccTraverser_Type.tp_alloc(&PyoaOccTraverser_Type,0);
        if (bself == NULL) return bself;
        PyoaOccTraverserObject* self = (PyoaOccTraverserObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccTraverser_abort_doc[] = 
"Class: oaOccTraverser, Function: abort\n"
"  Paramegers: ()\n"
"    Calls: void abort()\n"
"    Signature: abort|void-void|\n"
"    BrowseData: 0\n"
"    This function aborts the current traversal as soon as possible, returning control to the caller.\n"
;

static PyObject*
oaOccTraverser_abort(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTraverser data;
    int convert_status=PyoaOccTraverser_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTraverserObject* self=(PyoaOccTraverserObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->abort();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTraverser_endInst_doc[] = 
"Class: oaOccTraverser, Function: endInst\n"
"  Paramegers: (oaOccInst)\n"
"    Calls: void endInst(oaOccInst* inst)\n"
"    Signature: endInst|void-void|ptr-oaOccInst,\n"
"    This virtual function is called just after the contents of an instance in the hierarchy have been processed. This will not be called for the instances that are not processed. An instance will not be processed if the startRef function call for that instance returned false. The caller can override this function.\n"
"    inst\n"
"    The instance has been visited.\n"
;

static PyObject*
oaOccTraverser_endInst(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTraverser data;
    int convert_status=PyoaOccTraverser_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTraverserObject* self=(PyoaOccTraverserObject*)ob;

    PyParamoaOccInst p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccInst_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->endInst(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTraverser_flags_doc[] = 
"Class: oaOccTraverser, Function: flags\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4& flags()\n"
"    Signature: flags|ref-oaUInt4|\n"
"    BrowseData: 1\n"
"    oaOccTraverser::flags()\n"
"    This function gives read/write access to a set of flags that control the traversal.\n"
"    These flags are:\n"
"    oavOccTraversePostOrder use a postorder traversal rather than preorder\n"
"    oavOccTraverseDesigns descend into occurrences of other designs\n"
"    oavOccTraverseImplicit allows processing of implicit objects\n"
;

static PyObject*
oaOccTraverser_flags(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTraverser data;
    int convert_status=PyoaOccTraverser_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTraverserObject* self=(PyoaOccTraverserObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4* result=&(data.DataCall()->flags());
        return PyoaUInt4_FromoaUInt4(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTraverser_processAssignment_doc[] = 
"Class: oaOccTraverser, Function: processAssignment\n"
"  Paramegers: (oaOccAssignment)\n"
"    Calls: void processAssignment(oaOccAssignment* assign)\n"
"    Signature: processAssignment|void-void|ptr-oaOccAssignment,\n"
"    This is the callback function that will be triggered by this traverser when the specified object is visited. This function can be overloaded in order to process objects of a specific type.\n"
"    assign\n"
"    The occ assignment object being visited.\n"
;

static PyObject*
oaOccTraverser_processAssignment(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTraverser data;
    int convert_status=PyoaOccTraverser_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTraverserObject* self=(PyoaOccTraverserObject*)ob;

    PyParamoaOccAssignment p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccAssignment_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->processAssignment(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTraverser_processBusNetDef_doc[] = 
"Class: oaOccTraverser, Function: processBusNetDef\n"
"  Paramegers: (oaOccBusNetDef)\n"
"    Calls: void processBusNetDef(oaOccBusNetDef* def)\n"
"    Signature: processBusNetDef|void-void|ptr-oaOccBusNetDef,\n"
"    This is the callback function that will be triggered by this traverser when the specified object is visited. This function can be overloaded in order to process objects of a specific type.\n"
"    def\n"
"    The occ busNetDef object being visited.\n"
;

static PyObject*
oaOccTraverser_processBusNetDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTraverser data;
    int convert_status=PyoaOccTraverser_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTraverserObject* self=(PyoaOccTraverserObject*)ob;

    PyParamoaOccBusNetDef p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccBusNetDef_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->processBusNetDef(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTraverser_processBusTermDef_doc[] = 
"Class: oaOccTraverser, Function: processBusTermDef\n"
"  Paramegers: (oaOccBusTermDef)\n"
"    Calls: void processBusTermDef(oaOccBusTermDef* def)\n"
"    Signature: processBusTermDef|void-void|ptr-oaOccBusTermDef,\n"
"    This is the callback function which will be triggered by this traverser when the specified object is visited. This function can be overloaded in order to process objects of a specific type.\n"
"    def\n"
"    The occ busTermDef object being visited.\n"
;

static PyObject*
oaOccTraverser_processBusTermDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTraverser data;
    int convert_status=PyoaOccTraverser_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTraverserObject* self=(PyoaOccTraverserObject*)ob;

    PyParamoaOccBusTermDef p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccBusTermDef_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->processBusTermDef(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTraverser_processConnectDef_doc[] = 
"Class: oaOccTraverser, Function: processConnectDef\n"
"  Paramegers: (oaOccConnectDef)\n"
"    Calls: void processConnectDef(oaOccConnectDef* connectDef)\n"
"    Signature: processConnectDef|void-void|ptr-oaOccConnectDef,\n"
"    This is the callback function that will be triggered by this traverser when the specified object is visited. This function can be overloaded in order to process objects of a specific type.\n"
"    connectDef\n"
"    The occ connectDef object being visited.\n"
;

static PyObject*
oaOccTraverser_processConnectDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTraverser data;
    int convert_status=PyoaOccTraverser_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTraverserObject* self=(PyoaOccTraverserObject*)ob;

    PyParamoaOccConnectDef p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccConnectDef_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->processConnectDef(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTraverser_processInst_doc[] = 
"Class: oaOccTraverser, Function: processInst\n"
"  Paramegers: (oaOccInst)\n"
"    Calls: void processInst(oaOccInst* inst)\n"
"    Signature: processInst|void-void|ptr-oaOccInst,\n"
"    This is the callback function that will be triggered by this traverser when the specified object is visited. This function can be overloaded in order to process objects of a specific type.\n"
"    inst\n"
"    The occ instance object being visited.\n"
;

static PyObject*
oaOccTraverser_processInst(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTraverser data;
    int convert_status=PyoaOccTraverser_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTraverserObject* self=(PyoaOccTraverserObject*)ob;

    PyParamoaOccInst p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccInst_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->processInst(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTraverser_processInstHeader_doc[] = 
"Class: oaOccTraverser, Function: processInstHeader\n"
"  Paramegers: (oaOccInstHeader)\n"
"    Calls: void processInstHeader(oaOccInstHeader* ih)\n"
"    Signature: processInstHeader|void-void|ptr-oaOccInstHeader,\n"
"    This is the callback function that will be triggered by this traverser when the specified object is visited. This function can be overloaded in order to process objects of a specific type.\n"
"    ih\n"
"    The occ instHeader object being visited.\n"
;

static PyObject*
oaOccTraverser_processInstHeader(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTraverser data;
    int convert_status=PyoaOccTraverser_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTraverserObject* self=(PyoaOccTraverserObject*)ob;

    PyParamoaOccInstHeader p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccInstHeader_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->processInstHeader(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTraverser_processInstTerm_doc[] = 
"Class: oaOccTraverser, Function: processInstTerm\n"
"  Paramegers: (oaOccInstTerm)\n"
"    Calls: void processInstTerm(oaOccInstTerm* instTerm)\n"
"    Signature: processInstTerm|void-void|ptr-oaOccInstTerm,\n"
"    This is the callback function that will be triggered by this traverser when the specified object is visited. This function can be overloaded in order to process objects of a specific type.\n"
"    instTerm\n"
"    The occ instTerm object being visited.\n"
;

static PyObject*
oaOccTraverser_processInstTerm(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTraverser data;
    int convert_status=PyoaOccTraverser_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTraverserObject* self=(PyoaOccTraverserObject*)ob;

    PyParamoaOccInstTerm p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccInstTerm_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->processInstTerm(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTraverser_processModuleInstHeader_doc[] = 
"Class: oaOccTraverser, Function: processModuleInstHeader\n"
"  Paramegers: (oaOccModuleInstHeader)\n"
"    Calls: void processModuleInstHeader(oaOccModuleInstHeader* modIH)\n"
"    Signature: processModuleInstHeader|void-void|ptr-oaOccModuleInstHeader,\n"
"    This is the callback function that will be triggered by this traverser when the specified object is visited. This function can be overloaded in order to process objects of a specific type.\n"
"    modIH\n"
"    The occ moduleInstHeader object being visited.\n"
;

static PyObject*
oaOccTraverser_processModuleInstHeader(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTraverser data;
    int convert_status=PyoaOccTraverser_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTraverserObject* self=(PyoaOccTraverserObject*)ob;

    PyParamoaOccModuleInstHeader p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccModuleInstHeader_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->processModuleInstHeader(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTraverser_processNet_doc[] = 
"Class: oaOccTraverser, Function: processNet\n"
"  Paramegers: (oaOccNet)\n"
"    Calls: void processNet(oaOccNet* net)\n"
"    Signature: processNet|void-void|ptr-oaOccNet,\n"
"    This is the callback function that will be triggered by this traverser when the specified object is visited. This function can be overloaded in order to process objects of a specific type.\n"
"    net\n"
"    The occ net object being visited.\n"
;

static PyObject*
oaOccTraverser_processNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTraverser data;
    int convert_status=PyoaOccTraverser_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTraverserObject* self=(PyoaOccTraverserObject*)ob;

    PyParamoaOccNet p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccNet_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->processNet(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTraverser_processOccurrence_doc[] = 
"Class: oaOccTraverser, Function: processOccurrence\n"
"  Paramegers: (oaOccurrence)\n"
"    Calls: void processOccurrence(oaOccurrence* occ)\n"
"    Signature: processOccurrence|void-void|ptr-oaOccurrence,\n"
"    This is the callback function that will be triggered by this traverser when the specified object is visited. This function can be overloaded in order to process objects of a specific type.\n"
"    occ\n"
"    The occurrence object being visited.\n"
;

static PyObject*
oaOccTraverser_processOccurrence(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTraverser data;
    int convert_status=PyoaOccTraverser_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTraverserObject* self=(PyoaOccTraverserObject*)ob;

    PyParamoaOccurrence p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccurrence_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->processOccurrence(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTraverser_processTerm_doc[] = 
"Class: oaOccTraverser, Function: processTerm\n"
"  Paramegers: (oaOccTerm)\n"
"    Calls: void processTerm(oaOccTerm* term)\n"
"    Signature: processTerm|void-void|ptr-oaOccTerm,\n"
"    This is the callback function that will be triggered by this traverser when the specified object is visited. This function can be overloaded in order to process objects of a specific type.\n"
"    term\n"
"    The occ terminal object being visited.\n"
;

static PyObject*
oaOccTraverser_processTerm(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTraverser data;
    int convert_status=PyoaOccTraverser_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTraverserObject* self=(PyoaOccTraverserObject*)ob;

    PyParamoaOccTerm p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccTerm_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->processTerm(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTraverser_processVectorInstDef_doc[] = 
"Class: oaOccTraverser, Function: processVectorInstDef\n"
"  Paramegers: (oaOccVectorInstDef)\n"
"    Calls: void processVectorInstDef(oaOccVectorInstDef* def)\n"
"    Signature: processVectorInstDef|void-void|ptr-oaOccVectorInstDef,\n"
"    This is the callback function that will be triggered by this traverser when the specified object is visited. This function can be overloaded in order to process objects of a specific type.\n"
"    def\n"
"    The occ vectorInstDef object being visited.\n"
;

static PyObject*
oaOccTraverser_processVectorInstDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTraverser data;
    int convert_status=PyoaOccTraverser_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTraverserObject* self=(PyoaOccTraverserObject*)ob;

    PyParamoaOccVectorInstDef p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccVectorInstDef_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->processVectorInstDef(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTraverser_startInst_doc[] = 
"Class: oaOccTraverser, Function: startInst\n"
"  Paramegers: (oaOccInst)\n"
"    Calls: oaBoolean startInst(oaOccInst* inst)\n"
"    Signature: startInst|simple-oaBoolean|ptr-oaOccInst,\n"
"    oaOccTraverser::startInst\n"
"    This virtual function is called just before the contents of an instance in the hierarchy is produced. The caller can override this function and return a boolean indicating whether or not the traversal should descend into the instance's master. The default implementation returns true, which means the transversal should descend into the instance's master.\n"
"    inst\n"
"    The instance being visited.\n"
;

static PyObject*
oaOccTraverser_startInst(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTraverser data;
    int convert_status=PyoaOccTraverser_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTraverserObject* self=(PyoaOccTraverserObject*)ob;

    PyParamoaOccInst p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccInst_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->startInst(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccTraverser_traverse_doc[] = 
"Class: oaOccTraverser, Function: traverse\n"
"  Paramegers: ()\n"
"    Calls: void traverse()\n"
"    Signature: traverse|void-void|\n"
"    BrowseData: 0\n"
"    This function causes this traverser object to start generating connectivity objects in the specified occurrence hierarchy.\n"
;

static PyObject*
oaOccTraverser_traverse(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccTraverser data;
    int convert_status=PyoaOccTraverser_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccTraverserObject* self=(PyoaOccTraverserObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->traverse();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaOccTraverser_assign_doc[] = 
"Class: oaOccTraverser, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccTraverser_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccTraverser data;
  int convert_status=PyoaOccTraverser_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccTraverser p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccTraverser_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccTraverser_methodlist[] = {
    {"abort",(PyCFunction)oaOccTraverser_abort,METH_VARARGS,oaOccTraverser_abort_doc},
    {"endInst",(PyCFunction)oaOccTraverser_endInst,METH_VARARGS,oaOccTraverser_endInst_doc},
    {"flags",(PyCFunction)oaOccTraverser_flags,METH_VARARGS,oaOccTraverser_flags_doc},
    {"processAssignment",(PyCFunction)oaOccTraverser_processAssignment,METH_VARARGS,oaOccTraverser_processAssignment_doc},
    {"processBusNetDef",(PyCFunction)oaOccTraverser_processBusNetDef,METH_VARARGS,oaOccTraverser_processBusNetDef_doc},
    {"processBusTermDef",(PyCFunction)oaOccTraverser_processBusTermDef,METH_VARARGS,oaOccTraverser_processBusTermDef_doc},
    {"processConnectDef",(PyCFunction)oaOccTraverser_processConnectDef,METH_VARARGS,oaOccTraverser_processConnectDef_doc},
    {"processInst",(PyCFunction)oaOccTraverser_processInst,METH_VARARGS,oaOccTraverser_processInst_doc},
    {"processInstHeader",(PyCFunction)oaOccTraverser_processInstHeader,METH_VARARGS,oaOccTraverser_processInstHeader_doc},
    {"processInstTerm",(PyCFunction)oaOccTraverser_processInstTerm,METH_VARARGS,oaOccTraverser_processInstTerm_doc},
    {"processModuleInstHeader",(PyCFunction)oaOccTraverser_processModuleInstHeader,METH_VARARGS,oaOccTraverser_processModuleInstHeader_doc},
    {"processNet",(PyCFunction)oaOccTraverser_processNet,METH_VARARGS,oaOccTraverser_processNet_doc},
    {"processOccurrence",(PyCFunction)oaOccTraverser_processOccurrence,METH_VARARGS,oaOccTraverser_processOccurrence_doc},
    {"processTerm",(PyCFunction)oaOccTraverser_processTerm,METH_VARARGS,oaOccTraverser_processTerm_doc},
    {"processVectorInstDef",(PyCFunction)oaOccTraverser_processVectorInstDef,METH_VARARGS,oaOccTraverser_processVectorInstDef_doc},
    {"startInst",(PyCFunction)oaOccTraverser_startInst,METH_VARARGS,oaOccTraverser_startInst_doc},
    {"traverse",(PyCFunction)oaOccTraverser_traverse,METH_VARARGS,oaOccTraverser_traverse_doc},
    {"assign",(PyCFunction)oaOccTraverser_tp_assign,METH_VARARGS,oaOccTraverser_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccTraverser_doc[] = 
"Class: oaOccTraverser\n"
"  The oaOccTraverser class implements a hierarchical traversal for connectivity objects in the occurrence domain. oaOccTraverser is an abstract class, and applications must create their own derived class in order to perform specific actions on the objects being traversed.\n"
"  The traverse() function initiates the traversal, which can be controlled by a set of flags bits accessed by the flags() function. During the traversal, the virtual functions process*() are called for each kind of connectivity object.\n"
"  To control the expansion of the occurrence hierarchy, the application must override the virtual function startInst() , which is called just before the contents of an instance in the hierarchy are produced.\n"
"Constructors:\n"
"  Paramegers: (oaOccurrence)\n"
"    Calls: oaOccTraverser(oaOccurrence* topOcc)\n"
"    Signature: oaOccTraverser||ptr-oaOccurrence,\n"
"    This is the constructor for the oaOccTraverser class. It creates and initializes the private producer.\n"
"    topOcc\n"
"    The root of the occurrence subtree to be traversed.\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccTraverser_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccTraverser",
    sizeof(PyoaOccTraverserObject),
    0,
    (destructor)oaOccTraverser_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccTraverser_tp_compare,	/* tp_compare */
    (reprfunc)oaOccTraverser_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccTraverser_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccTraverser_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccTraverser_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccTraverser_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccTraverser_Type)<0) {
      printf("** PyType_Ready failed for: oaOccTraverser\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccTraverser",
           (PyObject*)(&PyoaOccTraverser_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccTraverser\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccVectorInst
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccVectorInst_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccVectorInst_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccVectorInstObject* self = (PyoaOccVectorInstObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccVectorInst)
    {
        PyParamoaOccVectorInst p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccVectorInst_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccVectorInst, Choices are:\n"
        "    (oaOccVectorInst)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccVectorInst_tp_dealloc(PyoaOccVectorInstObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccVectorInst_tp_repr(PyObject *ob)
{
    PyParamoaOccVectorInst value;
    int convert_status=PyoaOccVectorInst_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaOccVectorInst::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaSimpleName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[37];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaOccVectorInst::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccVectorInst_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccVectorInst v1;
    PyParamoaOccVectorInst v2;
    int convert_status1=PyoaOccVectorInst_Convert(ob1,&v1);
    int convert_status2=PyoaOccVectorInst_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccVectorInst_Convert(PyObject* ob,PyParamoaOccVectorInst* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccVectorInst_Check(ob)) {
        result->SetData( (oaOccVectorInst**) ((PyoaOccVectorInstObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccVectorInst Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccVectorInst_FromoaOccVectorInst(oaOccVectorInst** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccVectorInst* data=*value;
        PyObject* bself = PyoaOccVectorInst_Type.tp_alloc(&PyoaOccVectorInst_Type,0);
        if (bself == NULL) return bself;
        PyoaOccVectorInstObject* self = (PyoaOccVectorInstObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccVectorInst_FromoaOccVectorInst(oaOccVectorInst* data)
{
    if (data) {
       PyObject* bself = PyoaOccVectorInst_Type.tp_alloc(&PyoaOccVectorInst_Type,0);
       if (bself == NULL) return bself;
       PyoaOccVectorInstObject* self = (PyoaOccVectorInstObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccVectorInst_getBit_doc[] = 
"Class: oaOccVectorInst, Function: getBit\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaOccVectorInstBit* getBit(oaUInt4 bitIndex) const\n"
"    Signature: getBit|ptr-oaOccVectorInstBit|simple-oaUInt4,\n"
"    This function returns a pointer to the vectorInstBit that corresponds to the specified bitIndex bit of this vectorInst. For example, if this is a vectorInst \"i[7:0]\" and bitIndex is zero, this function will return the vectorInstBit corresponding to \"i[7]\".\n"
"    bitIndex\n"
"    Specifies which bit of the instance to return\n"
"    A pointer to an oaOccVectorInstBit\n"
"    oacInvalidBitIndexIntoInst\n"
;

static PyObject*
oaOccVectorInst_getBit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInst data;
    int convert_status=PyoaOccVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstObject* self=(PyoaOccVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaOccVectorInstBitp result= (data.DataCall()->getBit(p1.Data()));
        return PyoaOccVectorInstBit_FromoaOccVectorInstBit(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInst_getDef_doc[] = 
"Class: oaOccVectorInst, Function: getDef\n"
"  Paramegers: ()\n"
"    Calls: oaOccVectorInstDef* getDef() const\n"
"    Signature: getDef|ptr-oaOccVectorInstDef|\n"
"    BrowseData: 1\n"
"    This function returns the occurrence vectorInstDef for this occurrence vectorInst. The occurrence vectorInstDef is used to access all occurrence vectorInts with the same baseName.\n"
"    A pointer to an oaOccVectorInstDef\n"
;

static PyObject*
oaOccVectorInst_getDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInst data;
    int convert_status=PyoaOccVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstObject* self=(PyoaOccVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaOccVectorInstDefp result= (data.DataCall()->getDef());
        return PyoaOccVectorInstDef_FromoaOccVectorInstDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInst_getInst_doc[] = 
"Class: oaOccVectorInst, Function: getInst\n"
"  Paramegers: ()\n"
"    Calls: oaVectorInst* getInst() const\n"
"    Signature: getInst|ptr-oaVectorInst|\n"
"    BrowseData: 1\n"
"    This function returns the corresponding instance in the block domain. NULL will be returned if the master design for this instance does not have a top block.\n"
"    A pointer to an oaVectorInst\n"
;

static PyObject*
oaOccVectorInst_getInst(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInst data;
    int convert_status=PyoaOccVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstObject* self=(PyoaOccVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaVectorInstp result= (data.DataCall()->getInst());
        return PyoaVectorInst_FromoaVectorInst(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInst_getModInst_doc[] = 
"Class: oaOccVectorInst, Function: getModInst\n"
"  Paramegers: ()\n"
"    Calls: oaModVectorInst* getModInst() const\n"
"    Signature: getModInst|ptr-oaModVectorInst|\n"
"    BrowseData: 1\n"
"    This function returns the corresponding instance in the module domain. NULL will be returned if this instance is an occurrence of a physical-only instance.\n"
"    A pointer to an oaModVectorInst\n"
;

static PyObject*
oaOccVectorInst_getModInst(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInst data;
    int convert_status=PyoaOccVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstObject* self=(PyoaOccVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModVectorInstp result= (data.DataCall()->getModInst());
        return PyoaModVectorInst_FromoaModVectorInst(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInst_getName_doc[] = 
"Class: oaOccVectorInst, Function: getName\n"
"  Paramegers: (oaVectorName)\n"
"    Calls: void getName(oaVectorName& name) const\n"
"    Signature: getName|void-void|ref-oaVectorName,\n"
"    BrowseData: 0,oaVectorName\n"
"    This function returns the name of this occVectorInst.\n"
"    name\n"
"    The name of the occVectorInst to return\n"
"  Paramegers: (oaSimpleName)\n"
"    Calls: void getName(oaSimpleName& name) const\n"
"    Signature: getName|void-void|ref-oaSimpleName,\n"
"    BrowseData: 0,oaSimpleName\n"
"    This function fills out name with the name of this instance.\n"
"    name\n"
"    The returned instance name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function fills out name with the name of this instance. The name is mapped according to the specified nameSpace.\n"
"    ns\n"
"    The nameSpace used to map the name\n"
"    name\n"
"    The returned instance name\n"
;

static PyObject*
oaOccVectorInst_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInst data;
    int convert_status=PyoaOccVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstObject* self=(PyoaOccVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaVectorName)
    {
        PyParamoaVectorName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName)
    {
        PyParamoaSimpleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSimpleName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccVectorInst, function: getName, Choices are:\n"
        "    (oaVectorName)\n"
        "    (oaSimpleName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInst_getPathName_doc[] = 
"Class: oaOccVectorInst, Function: getPathName\n"
"  Paramegers: (oaVectorName)\n"
"    Calls: void getPathName(oaVectorName& name) const\n"
"    Signature: getPathName|void-void|ref-oaVectorName,\n"
"    BrowseData: 0,oaVectorName\n"
"    This function returns the full path name of this instance, relative to the top occurrence in the occurrence hierarchy containing this instance.\n"
"    name\n"
"    The pathName of the occVectorInst to return\n"
"  Paramegers: (oaSimpleName)\n"
"    Calls: void getPathName(oaSimpleName& pathName) const\n"
"    Signature: getPathName|void-void|ref-oaSimpleName,\n"
"    BrowseData: 0,oaSimpleName\n"
"    This function fills out pathName with the full path name of this instance, relative to the top occurrence in the occurrence hierarchy containing this instance.\n"
"    pathName\n"
"    The path name of the instance\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getPathName(const oaNameSpace& ns,oaString& pathName) const\n"
"    Signature: getPathName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the full path name of this instance in the specified nameSpace in the specified pathName string. The pathName is relative to the top occurrence in the occurrence hierarchy containing this instance.\n"
"    ns\n"
"    The nameSpace in which to return the name\n"
"    pathName\n"
"    The path name of the instance\n"
;

static PyObject*
oaOccVectorInst_getPathName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInst data;
    int convert_status=PyoaOccVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstObject* self=(PyoaOccVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaVectorName)
    {
        PyParamoaVectorName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorName_Convert,&p1)) {
            data.DataCall()->getPathName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName)
    {
        PyParamoaSimpleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSimpleName_Convert,&p1)) {
            data.DataCall()->getPathName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getPathName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccVectorInst, function: getPathName, Choices are:\n"
        "    (oaVectorName)\n"
        "    (oaSimpleName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInst_getStart_doc[] = 
"Class: oaOccVectorInst, Function: getStart\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getStart() const\n"
"    Signature: getStart|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the start index of this occurrence vectorInst.\n"
;

static PyObject*
oaOccVectorInst_getStart(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInst data;
    int convert_status=PyoaOccVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstObject* self=(PyoaOccVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getStart());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInst_getStop_doc[] = 
"Class: oaOccVectorInst, Function: getStop\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getStop() const\n"
"    Signature: getStop|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the stop index of this occurrence vectorInst.\n"
;

static PyObject*
oaOccVectorInst_getStop(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInst data;
    int convert_status=PyoaOccVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstObject* self=(PyoaOccVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getStop());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInst_isNull_doc[] =
"Class: oaOccVectorInst, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccVectorInst_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccVectorInst data;
    int convert_status=PyoaOccVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccVectorInst_assign_doc[] = 
"Class: oaOccVectorInst, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccVectorInst_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccVectorInst data;
  int convert_status=PyoaOccVectorInst_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccVectorInst p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccVectorInst_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccVectorInst_methodlist[] = {
    {"getBit",(PyCFunction)oaOccVectorInst_getBit,METH_VARARGS,oaOccVectorInst_getBit_doc},
    {"getDef",(PyCFunction)oaOccVectorInst_getDef,METH_VARARGS,oaOccVectorInst_getDef_doc},
    {"getInst",(PyCFunction)oaOccVectorInst_getInst,METH_VARARGS,oaOccVectorInst_getInst_doc},
    {"getModInst",(PyCFunction)oaOccVectorInst_getModInst,METH_VARARGS,oaOccVectorInst_getModInst_doc},
    {"getName",(PyCFunction)oaOccVectorInst_getName,METH_VARARGS,oaOccVectorInst_getName_doc},
    {"getPathName",(PyCFunction)oaOccVectorInst_getPathName,METH_VARARGS,oaOccVectorInst_getPathName_doc},
    {"getStart",(PyCFunction)oaOccVectorInst_getStart,METH_VARARGS,oaOccVectorInst_getStart_doc},
    {"getStop",(PyCFunction)oaOccVectorInst_getStop,METH_VARARGS,oaOccVectorInst_getStop_doc},
    {"isNull",(PyCFunction)oaOccVectorInst_tp_isNull,METH_VARARGS,oaOccVectorInst_isNull_doc},
    {"assign",(PyCFunction)oaOccVectorInst_tp_assign,METH_VARARGS,oaOccVectorInst_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccVectorInst_doc[] = 
"Class: oaOccVectorInst\n"
"  The oaOccVectorInst class implements a occurrence vector instance in a occurrence hierarchy. A vector instance represents several copies of the instance master with a range of index numbers to differentiate them.\n"
"  oaOccVectorInst objects are always in the occurrence domain.\n"
"Constructors:\n"
"  Paramegers: (oaOccVectorInst)\n"
"    Calls: (const oaOccVectorInst&)\n"
"    Signature: oaOccVectorInst||cref-oaOccVectorInst,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccVectorInst_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccVectorInst",
    sizeof(PyoaOccVectorInstObject),
    0,
    (destructor)oaOccVectorInst_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccVectorInst_tp_compare,	/* tp_compare */
    (reprfunc)oaOccVectorInst_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccVectorInst_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccVectorInst_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccDesignInst_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccVectorInst_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccVectorInst_static_find_doc[] = 
"Class: oaOccVectorInst, Function: find\n"
"  Paramegers: (oaOccurrence,oaScalarName,oaUInt4,oaUInt4)\n"
"    Calls: oaOccVectorInst* find(const oaOccurrence* occurrence,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop)\n"
"    Signature: find|ptr-oaOccVectorInst|cptr-oaOccurrence,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,\n"
"    This function searches the specified occurrence looking for a vectorInst with the specified baseName and range. If baseName is hierarchical, this function will descend into lower levels of occurrence hierarchy, expanding the hierarchy and binding the master designs as needed. The vectorInst is returned if found, otherwise NULL is returned.\n"
"    occurrence\n"
"    The occurrence in which to search\n"
"    baseName\n"
"    The base name of the instance to find\n"
"    start\n"
"    The start bit index of the instance to find\n"
"    stop\n"
"    The stop bit index of the instance to find\n"
"    A pointer to the oaOccVectorInst\n"
;

static PyObject*
oaOccVectorInst_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence p1;
    PyParamoaScalarName p2;
    PyParamoaUInt4 p3;
    PyParamoaUInt4 p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaOccurrence_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaUInt4_Convert,&p3,
          &PyoaUInt4_Convert,&p4)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaOccVectorInstp result= (oaOccVectorInst::find(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
        return PyoaOccVectorInst_FromoaOccVectorInst(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaOccVectorInst_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaOccVectorInst_static_find,METH_VARARGS,oaOccVectorInst_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccVectorInst_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccVectorInst_Type)<0) {
      printf("** PyType_Ready failed for: oaOccVectorInst\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccVectorInst",
           (PyObject*)(&PyoaOccVectorInst_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccVectorInst\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaOccVectorInst_Type.tp_dict;
    for(method=oaOccVectorInst_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccVectorInstBit
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccVectorInstBit_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccVectorInstBit_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccVectorInstBitObject* self = (PyoaOccVectorInstBitObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccVectorInstBit)
    {
        PyParamoaOccVectorInstBit p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccVectorInstBit_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccVectorInstBit, Choices are:\n"
        "    (oaOccVectorInstBit)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccVectorInstBit_tp_dealloc(PyoaOccVectorInstBitObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccVectorInstBit_tp_repr(PyObject *ob)
{
    PyParamoaOccVectorInstBit value;
    int convert_status=PyoaOccVectorInstBit_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaOccVectorInstBit::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaSimpleName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[40];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaOccVectorInstBit::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccVectorInstBit_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccVectorInstBit v1;
    PyParamoaOccVectorInstBit v2;
    int convert_status1=PyoaOccVectorInstBit_Convert(ob1,&v1);
    int convert_status2=PyoaOccVectorInstBit_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccVectorInstBit_Convert(PyObject* ob,PyParamoaOccVectorInstBit* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccVectorInstBit_Check(ob)) {
        result->SetData( (oaOccVectorInstBit**) ((PyoaOccVectorInstBitObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccVectorInstBit Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccVectorInstBit_FromoaOccVectorInstBit(oaOccVectorInstBit** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccVectorInstBit* data=*value;
        PyObject* bself = PyoaOccVectorInstBit_Type.tp_alloc(&PyoaOccVectorInstBit_Type,0);
        if (bself == NULL) return bself;
        PyoaOccVectorInstBitObject* self = (PyoaOccVectorInstBitObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccVectorInstBit_FromoaOccVectorInstBit(oaOccVectorInstBit* data)
{
    if (data) {
       PyObject* bself = PyoaOccVectorInstBit_Type.tp_alloc(&PyoaOccVectorInstBit_Type,0);
       if (bself == NULL) return bself;
       PyoaOccVectorInstBitObject* self = (PyoaOccVectorInstBitObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccVectorInstBit_getBitIndex_doc[] = 
"Class: oaOccVectorInstBit, Function: getBitIndex\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getBitIndex() const\n"
"    Signature: getBitIndex|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the bitIndex of this vectorInstBit.\n"
;

static PyObject*
oaOccVectorInstBit_getBitIndex(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInstBit data;
    int convert_status=PyoaOccVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstBitObject* self=(PyoaOccVectorInstBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getBitIndex());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInstBit_getDef_doc[] = 
"Class: oaOccVectorInstBit, Function: getDef\n"
"  Paramegers: ()\n"
"    Calls: oaOccVectorInstDef* getDef() const\n"
"    Signature: getDef|ptr-oaOccVectorInstDef|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the vectorInstDef for this vectorInstBit.\n"
;

static PyObject*
oaOccVectorInstBit_getDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInstBit data;
    int convert_status=PyoaOccVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstBitObject* self=(PyoaOccVectorInstBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaOccVectorInstDefp result= (data.DataCall()->getDef());
        return PyoaOccVectorInstDef_FromoaOccVectorInstDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInstBit_getInst_doc[] = 
"Class: oaOccVectorInstBit, Function: getInst\n"
"  Paramegers: ()\n"
"    Calls: oaVectorInstBit* getInst() const\n"
"    Signature: getInst|ptr-oaVectorInstBit|\n"
"    BrowseData: 1\n"
"    This function returns the corresponding instance in the block domain. NULL will be returned if the master design for this instance does not have a top block.\n"
"    A pointer to an oaOccVectorInstBit\n"
;

static PyObject*
oaOccVectorInstBit_getInst(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInstBit data;
    int convert_status=PyoaOccVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstBitObject* self=(PyoaOccVectorInstBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaVectorInstBitp result= (data.DataCall()->getInst());
        return PyoaVectorInstBit_FromoaVectorInstBit(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInstBit_getModInst_doc[] = 
"Class: oaOccVectorInstBit, Function: getModInst\n"
"  Paramegers: ()\n"
"    Calls: oaModVectorInstBit* getModInst() const\n"
"    Signature: getModInst|ptr-oaModVectorInstBit|\n"
"    BrowseData: 1\n"
"    This function returns the corresponding instance in the module domain. NULL will be returned if this instance is an occurrence of a physical-only instance.\n"
"    A pointer to an oaModVectorInstBit\n"
;

static PyObject*
oaOccVectorInstBit_getModInst(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInstBit data;
    int convert_status=PyoaOccVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstBitObject* self=(PyoaOccVectorInstBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModVectorInstBitp result= (data.DataCall()->getModInst());
        return PyoaModVectorInstBit_FromoaModVectorInstBit(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInstBit_getName_doc[] = 
"Class: oaOccVectorInstBit, Function: getName\n"
"  Paramegers: (oaVectorBitName)\n"
"    Calls: void getName(oaVectorBitName& name) const\n"
"    Signature: getName|void-void|ref-oaVectorBitName,\n"
"    BrowseData: 0,oaVectorBitName\n"
"    This function returns the name of this occVectorInstBit.\n"
"    name\n"
"    The name of the occVectorInstBit to return\n"
"  Paramegers: (oaSimpleName)\n"
"    Calls: void getName(oaSimpleName& name) const\n"
"    Signature: getName|void-void|ref-oaSimpleName,\n"
"    BrowseData: 0,oaSimpleName\n"
"    This function fills out name with the name of this instance.\n"
"    name\n"
"    The returned instance name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function fills out name with the name of this instance. The name is mapped according to the specified nameSpace.\n"
"    ns\n"
"    The nameSpace used to map the name\n"
"    name\n"
"    The returned instance name\n"
;

static PyObject*
oaOccVectorInstBit_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInstBit data;
    int convert_status=PyoaOccVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstBitObject* self=(PyoaOccVectorInstBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaVectorBitName)
    {
        PyParamoaVectorBitName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorBitName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName)
    {
        PyParamoaSimpleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSimpleName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccVectorInstBit, function: getName, Choices are:\n"
        "    (oaVectorBitName)\n"
        "    (oaSimpleName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInstBit_getPathName_doc[] = 
"Class: oaOccVectorInstBit, Function: getPathName\n"
"  Paramegers: (oaVectorBitName)\n"
"    Calls: void getPathName(oaVectorBitName& pathName) const\n"
"    Signature: getPathName|void-void|ref-oaVectorBitName,\n"
"    BrowseData: 0,oaVectorBitName\n"
"    This function returns the full path name of this instance, relative to the top occurrence in the occurrence hierarchy containing this instance.\n"
"    pathName\n"
"    The pathName of the occVectorInstBit to return\n"
"  Paramegers: (oaSimpleName)\n"
"    Calls: void getPathName(oaSimpleName& pathName) const\n"
"    Signature: getPathName|void-void|ref-oaSimpleName,\n"
"    BrowseData: 0,oaSimpleName\n"
"    This function fills out pathName with the full path name of this instance, relative to the top occurrence in the occurrence hierarchy containing this instance.\n"
"    pathName\n"
"    The path name of the instance\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getPathName(const oaNameSpace& ns,oaString& pathName) const\n"
"    Signature: getPathName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the full path name of this instance in the specified nameSpace in the specified pathName string. The pathName is relative to the top occurrence in the occurrence hierarchy containing this instance.\n"
"    ns\n"
"    The nameSpace in which to return the name\n"
"    pathName\n"
"    The path name of the instance\n"
;

static PyObject*
oaOccVectorInstBit_getPathName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInstBit data;
    int convert_status=PyoaOccVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstBitObject* self=(PyoaOccVectorInstBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaVectorBitName)
    {
        PyParamoaVectorBitName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorBitName_Convert,&p1)) {
            data.DataCall()->getPathName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName)
    {
        PyParamoaSimpleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSimpleName_Convert,&p1)) {
            data.DataCall()->getPathName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getPathName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccVectorInstBit, function: getPathName, Choices are:\n"
        "    (oaVectorBitName)\n"
        "    (oaSimpleName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInstBit_isNull_doc[] =
"Class: oaOccVectorInstBit, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccVectorInstBit_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccVectorInstBit data;
    int convert_status=PyoaOccVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccVectorInstBit_assign_doc[] = 
"Class: oaOccVectorInstBit, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccVectorInstBit_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccVectorInstBit data;
  int convert_status=PyoaOccVectorInstBit_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccVectorInstBit p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccVectorInstBit_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccVectorInstBit_methodlist[] = {
    {"getBitIndex",(PyCFunction)oaOccVectorInstBit_getBitIndex,METH_VARARGS,oaOccVectorInstBit_getBitIndex_doc},
    {"getDef",(PyCFunction)oaOccVectorInstBit_getDef,METH_VARARGS,oaOccVectorInstBit_getDef_doc},
    {"getInst",(PyCFunction)oaOccVectorInstBit_getInst,METH_VARARGS,oaOccVectorInstBit_getInst_doc},
    {"getModInst",(PyCFunction)oaOccVectorInstBit_getModInst,METH_VARARGS,oaOccVectorInstBit_getModInst_doc},
    {"getName",(PyCFunction)oaOccVectorInstBit_getName,METH_VARARGS,oaOccVectorInstBit_getName_doc},
    {"getPathName",(PyCFunction)oaOccVectorInstBit_getPathName,METH_VARARGS,oaOccVectorInstBit_getPathName_doc},
    {"isNull",(PyCFunction)oaOccVectorInstBit_tp_isNull,METH_VARARGS,oaOccVectorInstBit_isNull_doc},
    {"assign",(PyCFunction)oaOccVectorInstBit_tp_assign,METH_VARARGS,oaOccVectorInstBit_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccVectorInstBit_doc[] = 
"Class: oaOccVectorInstBit\n"
"  The oaOccVectorInstBit class implements a single bit of an occurrence vectorInst.\n"
"  oaOccVectorInstBit objects are always in the occurrence domain.\n"
"Constructors:\n"
"  Paramegers: (oaOccVectorInstBit)\n"
"    Calls: (const oaOccVectorInstBit&)\n"
"    Signature: oaOccVectorInstBit||cref-oaOccVectorInstBit,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccVectorInstBit_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccVectorInstBit",
    sizeof(PyoaOccVectorInstBitObject),
    0,
    (destructor)oaOccVectorInstBit_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccVectorInstBit_tp_compare,	/* tp_compare */
    (reprfunc)oaOccVectorInstBit_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccVectorInstBit_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccVectorInstBit_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccBitInst_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccVectorInstBit_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccVectorInstBit_static_find_doc[] = 
"Class: oaOccVectorInstBit, Function: find\n"
"  Paramegers: (oaOccurrence,oaScalarName,oaUInt4)\n"
"    Calls: oaOccVectorInstBit* find(const oaOccurrence* occurrence,const oaScalarName& baseName,oaUInt4 bitIndex)\n"
"    Signature: find|ptr-oaOccVectorInstBit|cptr-oaOccurrence,cref-oaScalarName,simple-oaUInt4,\n"
"    This function searches the specified occurrence looking for a vectorInstBit with the specified baseName and bitIndex . If baseName is hierarchical, this function will descend into lower levels of occurrence hierarchy, expanding the hierarchy and binding the master designs as needed. The vectorInstBit is returned if found, otherwise NULL is returned.\n"
"    occurrence\n"
"    The occurrence in which to search\n"
"    baseName\n"
"    The base name of the instance to find\n"
"    bitIndex\n"
"    The bit index of the instance to find\n"
"    A pointer to the oaOccVectorInstBit\n"
;

static PyObject*
oaOccVectorInstBit_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence p1;
    PyParamoaScalarName p2;
    PyParamoaUInt4 p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaOccurrence_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaUInt4_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaOccVectorInstBitp result= (oaOccVectorInstBit::find(p1.Data(),p2.Data(),p3.Data()));
        return PyoaOccVectorInstBit_FromoaOccVectorInstBit(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaOccVectorInstBit_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaOccVectorInstBit_static_find,METH_VARARGS,oaOccVectorInstBit_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccVectorInstBit_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccVectorInstBit_Type)<0) {
      printf("** PyType_Ready failed for: oaOccVectorInstBit\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccVectorInstBit",
           (PyObject*)(&PyoaOccVectorInstBit_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccVectorInstBit\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaOccVectorInstBit_Type.tp_dict;
    for(method=oaOccVectorInstBit_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccVectorInstDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccVectorInstDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccVectorInstDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccVectorInstDefObject* self = (PyoaOccVectorInstDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccVectorInstDef)
    {
        PyParamoaOccVectorInstDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccVectorInstDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccVectorInstDef, Choices are:\n"
        "    (oaOccVectorInstDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccVectorInstDef_tp_dealloc(PyoaOccVectorInstDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccVectorInstDef_tp_repr(PyObject *ob)
{
    PyParamoaOccVectorInstDef value;
    int convert_status=PyoaOccVectorInstDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaOccVectorInstDef::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaScalarName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[40];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaOccVectorInstDef::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccVectorInstDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccVectorInstDef v1;
    PyParamoaOccVectorInstDef v2;
    int convert_status1=PyoaOccVectorInstDef_Convert(ob1,&v1);
    int convert_status2=PyoaOccVectorInstDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccVectorInstDef_Convert(PyObject* ob,PyParamoaOccVectorInstDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccVectorInstDef_Check(ob)) {
        result->SetData( (oaOccVectorInstDef**) ((PyoaOccVectorInstDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccVectorInstDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccVectorInstDef_FromoaOccVectorInstDef(oaOccVectorInstDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccVectorInstDef* data=*value;
        PyObject* bself = PyoaOccVectorInstDef_Type.tp_alloc(&PyoaOccVectorInstDef_Type,0);
        if (bself == NULL) return bself;
        PyoaOccVectorInstDefObject* self = (PyoaOccVectorInstDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccVectorInstDef_FromoaOccVectorInstDef(oaOccVectorInstDef* data)
{
    if (data) {
       PyObject* bself = PyoaOccVectorInstDef_Type.tp_alloc(&PyoaOccVectorInstDef_Type,0);
       if (bself == NULL) return bself;
       PyoaOccVectorInstDefObject* self = (PyoaOccVectorInstDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccVectorInstDef_getBitOrder_doc[] = 
"Class: oaOccVectorInstDef, Function: getBitOrder\n"
"  Paramegers: ()\n"
"    Calls: oaBitOrder getBitOrder() const\n"
"    Signature: getBitOrder|simple-oaBitOrder|\n"
"    BrowseData: 1\n"
"    This function returns the bitOrder associated with this oaOccVectorInstDef object.\n"
;

static PyObject*
oaOccVectorInstDef_getBitOrder(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInstDef data;
    int convert_status=PyoaOccVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstDefObject* self=(PyoaOccVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBitOrder* result= new oaBitOrder(data.DataCall()->getBitOrder());
        return PyoaBitOrder_FromoaBitOrder(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInstDef_getMaxIndex_doc[] = 
"Class: oaOccVectorInstDef, Function: getMaxIndex\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getMaxIndex() const\n"
"    Signature: getMaxIndex|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the largest bit number in use for this oaOccVectorInstDef object. This is the largest index used across all vectorInsts associated with this oaOccVectorInstDef object.\n"
;

static PyObject*
oaOccVectorInstDef_getMaxIndex(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInstDef data;
    int convert_status=PyoaOccVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstDefObject* self=(PyoaOccVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getMaxIndex());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInstDef_getMinIndex_doc[] = 
"Class: oaOccVectorInstDef, Function: getMinIndex\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getMinIndex() const\n"
"    Signature: getMinIndex|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the smallest bit number in use for this oaOccVectorInstDef object. This is the smallest index used across all vectorInsts associated with this oaOccVectorInstDef object.\n"
;

static PyObject*
oaOccVectorInstDef_getMinIndex(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInstDef data;
    int convert_status=PyoaOccVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstDefObject* self=(PyoaOccVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getMinIndex());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInstDef_getName_doc[] = 
"Class: oaOccVectorInstDef, Function: getName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getName(oaScalarName& name) const\n"
"    Signature: getName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the local name of this vectorInstDef within its parent occurrence.\n"
"    name\n"
"    The returned vectorInstDef name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the local name of this vectorInstDef in the specified nameSpace in the specified name string. The name is relative to the parent occurrence of this vectorInstDef.\n"
"    ns\n"
"    The nameSpace used to map the name\n"
"    name\n"
"    The returned vectorInstDef name\n"
;

static PyObject*
oaOccVectorInstDef_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInstDef data;
    int convert_status=PyoaOccVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstDefObject* self=(PyoaOccVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccVectorInstDef, function: getName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInstDef_getNumBits_doc[] = 
"Class: oaOccVectorInstDef, Function: getNumBits\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumBits() const\n"
"    Signature: getNumBits|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of bits covered by the vectorInsts in this oaOccVectorInstDef. The number of bits is equal to abs(maxIndex - minIndex) + 1.\n"
;

static PyObject*
oaOccVectorInstDef_getNumBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInstDef data;
    int convert_status=PyoaOccVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstDefObject* self=(PyoaOccVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumBits());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInstDef_getPathName_doc[] = 
"Class: oaOccVectorInstDef, Function: getPathName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getPathName(oaScalarName& pathName) const\n"
"    Signature: getPathName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the full path name of this vectorInstDef, relative to the top occurrence in the occurrence hierarchy containing this vectorInstDef.\n"
"    pathName\n"
"    The returned path name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getPathName(const oaNameSpace& ns,oaString& pathName) const\n"
"    Signature: getPathName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the full path name of this vectorInstDef in the specified nameSpace in the specified pathName string. The pathName is relative to the top occurrence in the occurrence hierarchy containing this vectorInstDef.\n"
"    ns\n"
"    The nameSpace used to map the name\n"
"    pathName\n"
"    The returned path name\n"
;

static PyObject*
oaOccVectorInstDef_getPathName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInstDef data;
    int convert_status=PyoaOccVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstDefObject* self=(PyoaOccVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getPathName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getPathName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccVectorInstDef, function: getPathName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInstDef_getVectorInstBits_doc[] = 
"Class: oaOccVectorInstDef, Function: getVectorInstBits\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaOccInst_oaOccVectorInstDef getVectorInstBits() const\n"
"    Signature: getVectorInstBits|simple-oaCollection_oaOccInst_oaOccVectorInstDef|\n"
"    BrowseData: 1\n"
"    This function returns a collection of oaOccVectorInstBit and oaOccModuleVectorInstBit objects associated with this oaOccVectorInstDef object.\n"
;

static PyObject*
oaOccVectorInstDef_getVectorInstBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInstDef data;
    int convert_status=PyoaOccVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstDefObject* self=(PyoaOccVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaOccInst_oaOccVectorInstDef* result= new oaCollection_oaOccInst_oaOccVectorInstDef(data.DataCall()->getVectorInstBits());
        return PyoaCollection_oaOccInst_oaOccVectorInstDef_FromoaCollection_oaOccInst_oaOccVectorInstDef(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInstDef_getVectorInstBitsIter_doc[] = 
"Class: oaOccVectorInstDef, Function: getVectorInstBitsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaOccInst getVectorInstBitsIter() const\n"
"    Signature: getVectorInstBitsIter|simple-oaIter_oaOccInst|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of oaOccVectorInstBit and oaOccModuleVectorInstBit objects associated with this oaOccVectorInstDef object.\n"
;

static PyObject*
oaOccVectorInstDef_getVectorInstBitsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInstDef data;
    int convert_status=PyoaOccVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstDefObject* self=(PyoaOccVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaOccInst* result= new oaIter_oaOccInst(data.DataCall()->getVectorInstBits());
        return PyoaIter_oaOccInst_FromoaIter_oaOccInst(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInstDef_getVectorInsts_doc[] = 
"Class: oaOccVectorInstDef, Function: getVectorInsts\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaOccInst_oaOccVectorInstDef getVectorInsts() const\n"
"    Signature: getVectorInsts|simple-oaCollection_oaOccInst_oaOccVectorInstDef|\n"
"    BrowseData: 1\n"
"    This function returns a collection of oaOccVectorInst and oaOccModuleVectorInst objects associated with this oaOccVectorInstDef object.\n"
;

static PyObject*
oaOccVectorInstDef_getVectorInsts(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInstDef data;
    int convert_status=PyoaOccVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstDefObject* self=(PyoaOccVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaOccInst_oaOccVectorInstDef* result= new oaCollection_oaOccInst_oaOccVectorInstDef(data.DataCall()->getVectorInsts());
        return PyoaCollection_oaOccInst_oaOccVectorInstDef_FromoaCollection_oaOccInst_oaOccVectorInstDef(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInstDef_getVectorInstsIter_doc[] = 
"Class: oaOccVectorInstDef, Function: getVectorInstsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaOccInst getVectorInstsIter() const\n"
"    Signature: getVectorInstsIter|simple-oaIter_oaOccInst|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of oaOccVectorInst and oaOccModuleVectorInst objects associated with this oaOccVectorInstDef object.\n"
;

static PyObject*
oaOccVectorInstDef_getVectorInstsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInstDef data;
    int convert_status=PyoaOccVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstDefObject* self=(PyoaOccVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaOccInst* result= new oaIter_oaOccInst(data.DataCall()->getVectorInsts());
        return PyoaIter_oaOccInst_FromoaIter_oaOccInst(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInstDef_isImplicit_doc[] = 
"Class: oaOccVectorInstDef, Function: isImplicit\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isImplicit() const\n"
"    Signature: isImplicit|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether this oaOccVectorInstDef was implicitly created or not.\n"
;

static PyObject*
oaOccVectorInstDef_isImplicit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccVectorInstDef data;
    int convert_status=PyoaOccVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccVectorInstDefObject* self=(PyoaOccVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isImplicit());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccVectorInstDef_isNull_doc[] =
"Class: oaOccVectorInstDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccVectorInstDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccVectorInstDef data;
    int convert_status=PyoaOccVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccVectorInstDef_assign_doc[] = 
"Class: oaOccVectorInstDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccVectorInstDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccVectorInstDef data;
  int convert_status=PyoaOccVectorInstDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccVectorInstDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccVectorInstDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccVectorInstDef_methodlist[] = {
    {"getBitOrder",(PyCFunction)oaOccVectorInstDef_getBitOrder,METH_VARARGS,oaOccVectorInstDef_getBitOrder_doc},
    {"getMaxIndex",(PyCFunction)oaOccVectorInstDef_getMaxIndex,METH_VARARGS,oaOccVectorInstDef_getMaxIndex_doc},
    {"getMinIndex",(PyCFunction)oaOccVectorInstDef_getMinIndex,METH_VARARGS,oaOccVectorInstDef_getMinIndex_doc},
    {"getName",(PyCFunction)oaOccVectorInstDef_getName,METH_VARARGS,oaOccVectorInstDef_getName_doc},
    {"getNumBits",(PyCFunction)oaOccVectorInstDef_getNumBits,METH_VARARGS,oaOccVectorInstDef_getNumBits_doc},
    {"getPathName",(PyCFunction)oaOccVectorInstDef_getPathName,METH_VARARGS,oaOccVectorInstDef_getPathName_doc},
    {"getVectorInstBits",(PyCFunction)oaOccVectorInstDef_getVectorInstBits,METH_VARARGS,oaOccVectorInstDef_getVectorInstBits_doc},
    {"getVectorInstBitsIter",(PyCFunction)oaOccVectorInstDef_getVectorInstBitsIter,METH_VARARGS,oaOccVectorInstDef_getVectorInstBitsIter_doc},
    {"getVectorInsts",(PyCFunction)oaOccVectorInstDef_getVectorInsts,METH_VARARGS,oaOccVectorInstDef_getVectorInsts_doc},
    {"getVectorInstsIter",(PyCFunction)oaOccVectorInstDef_getVectorInstsIter,METH_VARARGS,oaOccVectorInstDef_getVectorInstsIter_doc},
    {"isImplicit",(PyCFunction)oaOccVectorInstDef_isImplicit,METH_VARARGS,oaOccVectorInstDef_isImplicit_doc},
    {"isNull",(PyCFunction)oaOccVectorInstDef_tp_isNull,METH_VARARGS,oaOccVectorInstDef_isNull_doc},
    {"assign",(PyCFunction)oaOccVectorInstDef_tp_assign,METH_VARARGS,oaOccVectorInstDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccVectorInstDef_doc[] = 
"Class: oaOccVectorInstDef\n"
"  The oaOccVectorInstDef class implements the definition of an occurrence vectorInst, including its base name and bit-range. All vectorInsts in an occurrence with the same base name are managed by the same vectorInst definition. The oaOccvectorInstDef class tracks the minimum and maximum indices referred to by all of its corresponding vectorInst objects.\n"
"  A vectorInstDef can be 'sparse' (have missing bits). Vectors do not have to start or end at zero. For example, a[22:25] is a legal vectorInst name. Vector indexes must be non-negative.\n"
"  The oaOccVectorInstDef class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaOccVectorInstDef)\n"
"    Calls: (const oaOccVectorInstDef&)\n"
"    Signature: oaOccVectorInstDef||cref-oaOccVectorInstDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccVectorInstDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccVectorInstDef",
    sizeof(PyoaOccVectorInstDefObject),
    0,
    (destructor)oaOccVectorInstDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccVectorInstDef_tp_compare,	/* tp_compare */
    (reprfunc)oaOccVectorInstDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccVectorInstDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccVectorInstDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccVectorInstDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccVectorInstDef_static_find_doc[] = 
"Class: oaOccVectorInstDef, Function: find\n"
"  Paramegers: (oaOccurrence,oaScalarName)\n"
"    Calls: oaOccVectorInstDef* find(const oaOccurrence* occurrence,const oaScalarName& name)\n"
"    Signature: find|ptr-oaOccVectorInstDef|cptr-oaOccurrence,cref-oaScalarName,\n"
"    This function searches the specified occurrence looking for a vectorInstDef with the specified baseName . If baseName is hierarchical, this function will descend into lower levels of occurrence hierarchy, expanding the hierarchy and binding the master designs as needed. The vectorInstDef is returned if found, otherwise NULL is returned.\n"
"    occurrence\n"
"    The occurrence in which to search\n"
"    baseName\n"
"    The base name of the vectorInstDef to find\n"
"    A pointer to the oaOccVectorInstDef\n"
;

static PyObject*
oaOccVectorInstDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaOccurrence_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaOccVectorInstDefp result= (oaOccVectorInstDef::find(p1.Data(),p2.Data()));
        return PyoaOccVectorInstDef_FromoaOccVectorInstDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaOccVectorInstDef_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaOccVectorInstDef_static_find,METH_VARARGS,oaOccVectorInstDef_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccVectorInstDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccVectorInstDef_Type)<0) {
      printf("** PyType_Ready failed for: oaOccVectorInstDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccVectorInstDef",
           (PyObject*)(&PyoaOccVectorInstDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccVectorInstDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaOccVectorInstDef_Type.tp_dict;
    for(method=oaOccVectorInstDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccurrence
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOccurrence_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOccurrence_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOccurrenceObject* self = (PyoaOccurrenceObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOccurrence)
    {
        PyParamoaOccurrence p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOccurrence_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOccurrence, Choices are:\n"
        "    (oaOccurrence)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOccurrence_tp_dealloc(PyoaOccurrenceObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOccurrence_tp_repr(PyObject *ob)
{
    PyParamoaOccurrence value;
    int convert_status=PyoaOccurrence_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[34];
    sprintf(buffer,"<oaOccurrence::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOccurrence_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOccurrence v1;
    PyParamoaOccurrence v2;
    int convert_status1=PyoaOccurrence_Convert(ob1,&v1);
    int convert_status2=PyoaOccurrence_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOccurrence_Convert(PyObject* ob,PyParamoaOccurrence* result)
{
    if (ob == NULL) return 1;
    if (PyoaOccurrence_Check(ob)) {
        result->SetData( (oaOccurrence**) ((PyoaOccurrenceObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccurrence Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOccurrence_FromoaOccurrence(oaOccurrence** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOccurrence* data=*value;
        PyObject* bself = PyoaOccurrence_Type.tp_alloc(&PyoaOccurrence_Type,0);
        if (bself == NULL) return bself;
        PyoaOccurrenceObject* self = (PyoaOccurrenceObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOccurrence_FromoaOccurrence(oaOccurrence* data)
{
    if (data) {
       PyObject* bself = PyoaOccurrence_Type.tp_alloc(&PyoaOccurrence_Type,0);
       if (bself == NULL) return bself;
       PyoaOccurrenceObject* self = (PyoaOccurrenceObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccurrence_destroy_doc[] = 
"Class: oaOccurrence, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    oaOccurrence::destroy\n"
"    This function destroys this occurrence and the occurrence hierarchy below it, removing them from the database.\n"
"    oacOccDestroyRequiresUndoToBeDisabled\n"
;

static PyObject*
oaOccurrence_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_getAssignments_doc[] = 
"Class: oaOccurrence, Function: getAssignments\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaOccAssignment_oaOccurrence getAssignments() const\n"
"    Signature: getAssignments|simple-oaCollection_oaOccAssignment_oaOccurrence|\n"
"    BrowseData: 1\n"
"    This function returns a collection of the assignments in this occurrence.\n"
;

static PyObject*
oaOccurrence_getAssignments(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaOccAssignment_oaOccurrence* result= new oaCollection_oaOccAssignment_oaOccurrence(data.DataCall()->getAssignments());
        return PyoaCollection_oaOccAssignment_oaOccurrence_FromoaCollection_oaOccAssignment_oaOccurrence(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_getAssignmentsIter_doc[] = 
"Class: oaOccurrence, Function: getAssignmentsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaOccAssignment getAssignmentsIter() const\n"
"    Signature: getAssignmentsIter|simple-oaIter_oaOccAssignment|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of the assignments in this occurrence.\n"
;

static PyObject*
oaOccurrence_getAssignmentsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaOccAssignment* result= new oaIter_oaOccAssignment(data.DataCall()->getAssignments());
        return PyoaIter_oaOccAssignment_FromoaIter_oaOccAssignment(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_getBlock_doc[] = 
"Class: oaOccurrence, Function: getBlock\n"
"  Paramegers: ()\n"
"    Calls: oaBlock* getBlock() const\n"
"    Signature: getBlock|ptr-oaBlock|\n"
"    BrowseData: 1\n"
"    This function returns the block that corresponds to (or contains) this occurrence. This will return NULL for an occurrence of a module that is not visible in the block domain.\n"
;

static PyObject*
oaOccurrence_getBlock(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBlockp result= (data.DataCall()->getBlock());
        return PyoaBlock_FromoaBlock(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_getBusNetDefs_doc[] = 
"Class: oaOccurrence, Function: getBusNetDefs\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaOccBusNetDef_oaOccurrence getBusNetDefs() const\n"
"    Signature: getBusNetDefs|simple-oaCollection_oaOccBusNetDef_oaOccurrence|\n"
"    BrowseData: 1\n"
"    This function returns a collection of the busNetDefs in this occurrence.\n"
;

static PyObject*
oaOccurrence_getBusNetDefs(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaOccBusNetDef_oaOccurrence* result= new oaCollection_oaOccBusNetDef_oaOccurrence(data.DataCall()->getBusNetDefs());
        return PyoaCollection_oaOccBusNetDef_oaOccurrence_FromoaCollection_oaOccBusNetDef_oaOccurrence(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_getBusNetDefsIter_doc[] = 
"Class: oaOccurrence, Function: getBusNetDefsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaOccBusNetDef getBusNetDefsIter() const\n"
"    Signature: getBusNetDefsIter|simple-oaIter_oaOccBusNetDef|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of the busNetDefs in this occurrence.\n"
;

static PyObject*
oaOccurrence_getBusNetDefsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaOccBusNetDef* result= new oaIter_oaOccBusNetDef(data.DataCall()->getBusNetDefs());
        return PyoaIter_oaOccBusNetDef_FromoaIter_oaOccBusNetDef(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_getBusTermDefs_doc[] = 
"Class: oaOccurrence, Function: getBusTermDefs\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaOccBusTermDef_oaOccurrence getBusTermDefs() const\n"
"    Signature: getBusTermDefs|simple-oaCollection_oaOccBusTermDef_oaOccurrence|\n"
"    BrowseData: 1\n"
"    This function returns a collection of the busTermDefs in this occurrence.\n"
;

static PyObject*
oaOccurrence_getBusTermDefs(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaOccBusTermDef_oaOccurrence* result= new oaCollection_oaOccBusTermDef_oaOccurrence(data.DataCall()->getBusTermDefs());
        return PyoaCollection_oaOccBusTermDef_oaOccurrence_FromoaCollection_oaOccBusTermDef_oaOccurrence(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_getBusTermDefsIter_doc[] = 
"Class: oaOccurrence, Function: getBusTermDefsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaOccBusTermDef getBusTermDefsIter() const\n"
"    Signature: getBusTermDefsIter|simple-oaIter_oaOccBusTermDef|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of the busTermDefs in this occurrence.\n"
;

static PyObject*
oaOccurrence_getBusTermDefsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaOccBusTermDef* result= new oaIter_oaOccBusTermDef(data.DataCall()->getBusTermDefs());
        return PyoaIter_oaOccBusTermDef_FromoaIter_oaOccBusTermDef(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_getConnectDefs_doc[] = 
"Class: oaOccurrence, Function: getConnectDefs\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaOccConnectDef_oaOccurrence getConnectDefs() const\n"
"    Signature: getConnectDefs|simple-oaCollection_oaOccConnectDef_oaOccurrence|\n"
"    BrowseData: 1\n"
"    This function returns a collection of the connectDefs in this occurrence.\n"
;

static PyObject*
oaOccurrence_getConnectDefs(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaOccConnectDef_oaOccurrence* result= new oaCollection_oaOccConnectDef_oaOccurrence(data.DataCall()->getConnectDefs());
        return PyoaCollection_oaOccConnectDef_oaOccurrence_FromoaCollection_oaOccConnectDef_oaOccurrence(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_getConnectDefsIter_doc[] = 
"Class: oaOccurrence, Function: getConnectDefsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaOccConnectDef getConnectDefsIter() const\n"
"    Signature: getConnectDefsIter|simple-oaIter_oaOccConnectDef|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of the connectDefs in this occurrence.\n"
;

static PyObject*
oaOccurrence_getConnectDefsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaOccConnectDef* result= new oaIter_oaOccConnectDef(data.DataCall()->getConnectDefs());
        return PyoaIter_oaOccConnectDef_FromoaIter_oaOccConnectDef(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_getInstTerms_doc[] = 
"Class: oaOccurrence, Function: getInstTerms\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaOccInstTerm_oaOccurrence getInstTerms() const\n"
"    Signature: getInstTerms|simple-oaCollection_oaOccInstTerm_oaOccurrence|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns a collection of the instTerms in this occurrence.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bits flags are defined as follows:\n"
"    oacInstTermIterNotImplicit: the collection will only contain instTerms that were explicitly created\n"
"    oacInstTermIterSingleBit: the collection will only contain instTerms that make a single-bit connection\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaOccInstTerm_oaOccurrence getInstTerms(oaUInt4 filterFlags) const\n"
"    Signature: getInstTerms|simple-oaCollection_oaOccInstTerm_oaOccurrence|simple-oaUInt4,\n"
"    This function returns a collection of the instTerms in this occurrence.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bits flags are defined as follows:\n"
"    oacInstTermIterNotImplicit: the collection will only contain instTerms that were explicitly created\n"
"    oacInstTermIterSingleBit: the collection will only contain instTerms that make a single-bit connection\n"
;

static PyObject*
oaOccurrence_getInstTerms(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaOccInstTerm_oaOccurrence* result= new oaCollection_oaOccInstTerm_oaOccurrence(data.DataCall()->getInstTerms());
            return PyoaCollection_oaOccInstTerm_oaOccurrence_FromoaCollection_oaOccInstTerm_oaOccurrence(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaOccInstTerm_oaOccurrence* result= new oaCollection_oaOccInstTerm_oaOccurrence(data.DataCall()->getInstTerms(p1.Data()));
            return PyoaCollection_oaOccInstTerm_oaOccurrence_FromoaCollection_oaOccInstTerm_oaOccurrence(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccurrence, function: getInstTerms, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_getInstTermsIter_doc[] = 
"Class: oaOccurrence, Function: getInstTermsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaOccInstTerm getInstTermsIter() const\n"
"    Signature: getInstTermsIter|simple-oaIter_oaOccInstTerm|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of the instTerms in this occurrence.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bits flags are defined as follows:\n"
"    oacInstTermIterNotImplicit: the collection will only contain instTerms that were explicitly created\n"
"    oacInstTermIterSingleBit: the collection will only contain instTerms that make a single-bit connection\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaOccInstTerm getInstTermsIter(oaUInt4 filterFlags) const\n"
"    Signature: getInstTermsIter|simple-oaIter_oaOccInstTerm|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of the instTerms in this occurrence.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bits flags are defined as follows:\n"
"    oacInstTermIterNotImplicit: the collection will only contain instTerms that were explicitly created\n"
"    oacInstTermIterSingleBit: the collection will only contain instTerms that make a single-bit connection\n"
;

static PyObject*
oaOccurrence_getInstTermsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaOccInstTerm* result= new oaIter_oaOccInstTerm(data.DataCall()->getInstTerms());
            return PyoaIter_oaOccInstTerm_FromoaIter_oaOccInstTerm(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaOccInstTerm* result= new oaIter_oaOccInstTerm(data.DataCall()->getInstTerms(p1.Data()));
            return PyoaIter_oaOccInstTerm_FromoaIter_oaOccInstTerm(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccurrence, function: getInstTermsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_getInsts_doc[] = 
"Class: oaOccurrence, Function: getInsts\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaOccInst_oaOccurrence getInsts() const\n"
"    Signature: getInsts|simple-oaCollection_oaOccInst_oaOccurrence|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns a collection of instances in this occurrence. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaOccInst_oaOccurrence getInsts(oaUInt4 filterFlags) const\n"
"    Signature: getInsts|simple-oaCollection_oaOccInst_oaOccurrence|simple-oaUInt4,\n"
"    This function returns a collection of instances in this occurrence. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
;

static PyObject*
oaOccurrence_getInsts(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaOccInst_oaOccurrence* result= new oaCollection_oaOccInst_oaOccurrence(data.DataCall()->getInsts());
            return PyoaCollection_oaOccInst_oaOccurrence_FromoaCollection_oaOccInst_oaOccurrence(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaOccInst_oaOccurrence* result= new oaCollection_oaOccInst_oaOccurrence(data.DataCall()->getInsts(p1.Data()));
            return PyoaCollection_oaOccInst_oaOccurrence_FromoaCollection_oaOccInst_oaOccurrence(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccurrence, function: getInsts, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_getInstsIter_doc[] = 
"Class: oaOccurrence, Function: getInstsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaOccInst getInstsIter() const\n"
"    Signature: getInstsIter|simple-oaIter_oaOccInst|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of instances in this occurrence. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaOccInst getInstsIter(oaUInt4 filterFlags) const\n"
"    Signature: getInstsIter|simple-oaIter_oaOccInst|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of instances in this occurrence. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
;

static PyObject*
oaOccurrence_getInstsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaOccInst* result= new oaIter_oaOccInst(data.DataCall()->getInsts());
            return PyoaIter_oaOccInst_FromoaIter_oaOccInst(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaOccInst* result= new oaIter_oaOccInst(data.DataCall()->getInsts(p1.Data()));
            return PyoaIter_oaOccInst_FromoaIter_oaOccInst(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccurrence, function: getInstsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_getModule_doc[] = 
"Class: oaOccurrence, Function: getModule\n"
"  Paramegers: ()\n"
"    Calls: oaModule* getModule() const\n"
"    Signature: getModule|ptr-oaModule|\n"
"    BrowseData: 1\n"
"    This function returns the module that corresponds to this occurrence. This will return NULL for an occurrence of a block that is not visible in the module domain.\n"
;

static PyObject*
oaOccurrence_getModule(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModulep result= (data.DataCall()->getModule());
        return PyoaModule_FromoaModule(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_getModuleInstHeaders_doc[] = 
"Class: oaOccurrence, Function: getModuleInstHeaders\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaOccModuleInstHeader_oaOccurrence getModuleInstHeaders() const\n"
"    Signature: getModuleInstHeaders|simple-oaCollection_oaOccModuleInstHeader_oaOccurrence|\n"
"    BrowseData: 1\n"
"    This function returns a collection of the moduleInstHeaders in this occurrence.\n"
;

static PyObject*
oaOccurrence_getModuleInstHeaders(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaOccModuleInstHeader_oaOccurrence* result= new oaCollection_oaOccModuleInstHeader_oaOccurrence(data.DataCall()->getModuleInstHeaders());
        return PyoaCollection_oaOccModuleInstHeader_oaOccurrence_FromoaCollection_oaOccModuleInstHeader_oaOccurrence(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_getModuleInstHeadersIter_doc[] = 
"Class: oaOccurrence, Function: getModuleInstHeadersIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaOccModuleInstHeader getModuleInstHeadersIter() const\n"
"    Signature: getModuleInstHeadersIter|simple-oaIter_oaOccModuleInstHeader|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of the moduleInstHeaders in this occurrence.\n"
;

static PyObject*
oaOccurrence_getModuleInstHeadersIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaOccModuleInstHeader* result= new oaIter_oaOccModuleInstHeader(data.DataCall()->getModuleInstHeaders());
        return PyoaIter_oaOccModuleInstHeader_FromoaIter_oaOccModuleInstHeader(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_getNets_doc[] = 
"Class: oaOccurrence, Function: getNets\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaOccNet_oaOccurrence getNets() const\n"
"    Signature: getNets|simple-oaCollection_oaOccNet_oaOccurrence|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    oaOccurrence::getNets\n"
"    This function returns a collection of nets in this occurrence. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    This specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacNetIterAll: the collection contains all nets\n"
"    oacNetIterSingleBit: the collection contains single-bit nets\n"
"    oacNetIterBundle: the collection contains all the bundleNets in the occurrence\n"
"    oacNetIterPreferred: the collection only contains the preferred nets; equivalent nets are omitted\n"
"    oacNetIterNotImplicit: the collection contains explicitly created nets\n"
"    oacNetIterGlobal: the collection contains a representative occNet for every global signal referenced anywhere in the occurrence hierarchy containing this occurrence\n"
"    oacInvalidOccurrenceNetIterFlags\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaOccNet_oaOccurrence getNets(oaUInt4 filterFlags) const\n"
"    Signature: getNets|simple-oaCollection_oaOccNet_oaOccurrence|simple-oaUInt4,\n"
"    oaOccurrence::getNets\n"
"    This function returns a collection of nets in this occurrence. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    This specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacNetIterAll: the collection contains all nets\n"
"    oacNetIterSingleBit: the collection contains single-bit nets\n"
"    oacNetIterBundle: the collection contains all the bundleNets in the occurrence\n"
"    oacNetIterPreferred: the collection only contains the preferred nets; equivalent nets are omitted\n"
"    oacNetIterNotImplicit: the collection contains explicitly created nets\n"
"    oacNetIterGlobal: the collection contains a representative occNet for every global signal referenced anywhere in the occurrence hierarchy containing this occurrence\n"
"    oacInvalidOccurrenceNetIterFlags\n"
;

static PyObject*
oaOccurrence_getNets(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaOccNet_oaOccurrence* result= new oaCollection_oaOccNet_oaOccurrence(data.DataCall()->getNets());
            return PyoaCollection_oaOccNet_oaOccurrence_FromoaCollection_oaOccNet_oaOccurrence(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaOccNet_oaOccurrence* result= new oaCollection_oaOccNet_oaOccurrence(data.DataCall()->getNets(p1.Data()));
            return PyoaCollection_oaOccNet_oaOccurrence_FromoaCollection_oaOccNet_oaOccurrence(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccurrence, function: getNets, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_getNetsIter_doc[] = 
"Class: oaOccurrence, Function: getNetsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaOccNet getNetsIter() const\n"
"    Signature: getNetsIter|simple-oaIter_oaOccNet|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: oaOccurrence::getNets\n"
"    This function returns a collection of nets in this occurrence. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    This specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacNetIterAll: the collection contains all nets\n"
"    oacNetIterSingleBit: the collection contains single-bit nets\n"
"    oacNetIterBundle: the collection contains all the bundleNets in the occurrence\n"
"    oacNetIterPreferred: the collection only contains the preferred nets; equivalent nets are omitted\n"
"    oacNetIterNotImplicit: the collection contains explicitly created nets\n"
"    oacNetIterGlobal: the collection contains a representative occNet for every global signal referenced anywhere in the occurrence hierarchy containing this occurrence\n"
"    oacInvalidOccurrenceNetIterFlags\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaOccNet getNetsIter(oaUInt4 filterFlags) const\n"
"    Signature: getNetsIter|simple-oaIter_oaOccNet|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: oaOccurrence::getNets\n"
"    This function returns a collection of nets in this occurrence. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    This specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacNetIterAll: the collection contains all nets\n"
"    oacNetIterSingleBit: the collection contains single-bit nets\n"
"    oacNetIterBundle: the collection contains all the bundleNets in the occurrence\n"
"    oacNetIterPreferred: the collection only contains the preferred nets; equivalent nets are omitted\n"
"    oacNetIterNotImplicit: the collection contains explicitly created nets\n"
"    oacNetIterGlobal: the collection contains a representative occNet for every global signal referenced anywhere in the occurrence hierarchy containing this occurrence\n"
"    oacInvalidOccurrenceNetIterFlags\n"
;

static PyObject*
oaOccurrence_getNetsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaOccNet* result= new oaIter_oaOccNet(data.DataCall()->getNets());
            return PyoaIter_oaOccNet_FromoaIter_oaOccNet(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaOccNet* result= new oaIter_oaOccNet(data.DataCall()->getNets(p1.Data()));
            return PyoaIter_oaOccNet_FromoaIter_oaOccNet(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccurrence, function: getNetsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_getOccInst_doc[] = 
"Class: oaOccurrence, Function: getOccInst\n"
"  Paramegers: ()\n"
"    Calls: oaOccInst* getOccInst() const\n"
"    Signature: getOccInst|ptr-oaOccInst|\n"
"    BrowseData: 1\n"
"    This function returns the parent instance of this occurrence. Every occurrence has exactly one parent occInst, except the top occurrence which has no occInst.\n"
;

static PyObject*
oaOccurrence_getOccInst(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaOccInstp result= (data.DataCall()->getOccInst());
        return PyoaOccInst_FromoaOccInst(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_getTerms_doc[] = 
"Class: oaOccurrence, Function: getTerms\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaOccTerm_oaOccurrence getTerms() const\n"
"    Signature: getTerms|simple-oaCollection_oaOccTerm_oaOccurrence|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns a collection of terms in this occurrence. The filter flag bits can be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacTermIterAll: the collection contains all terminals\n"
"    oacTermIterSingleBit: the collection contains single-bit terminals\n"
"    oacTermIterBundle: the collection contains all the bundleTerms in the occurrence\n"
"    oacTermIterNotImplicit: the collection contains explicitly created terminals\n"
"    oacInvalidOccurrenceTermIterFlags\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaOccTerm_oaOccurrence getTerms(oaUInt4 filterFlags) const\n"
"    Signature: getTerms|simple-oaCollection_oaOccTerm_oaOccurrence|simple-oaUInt4,\n"
"    This function returns a collection of terms in this occurrence. The filter flag bits can be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacTermIterAll: the collection contains all terminals\n"
"    oacTermIterSingleBit: the collection contains single-bit terminals\n"
"    oacTermIterBundle: the collection contains all the bundleTerms in the occurrence\n"
"    oacTermIterNotImplicit: the collection contains explicitly created terminals\n"
"    oacInvalidOccurrenceTermIterFlags\n"
;

static PyObject*
oaOccurrence_getTerms(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaOccTerm_oaOccurrence* result= new oaCollection_oaOccTerm_oaOccurrence(data.DataCall()->getTerms());
            return PyoaCollection_oaOccTerm_oaOccurrence_FromoaCollection_oaOccTerm_oaOccurrence(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaOccTerm_oaOccurrence* result= new oaCollection_oaOccTerm_oaOccurrence(data.DataCall()->getTerms(p1.Data()));
            return PyoaCollection_oaOccTerm_oaOccurrence_FromoaCollection_oaOccTerm_oaOccurrence(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccurrence, function: getTerms, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_getTermsByPosition_doc[] = 
"Class: oaOccurrence, Function: getTermsByPosition\n"
"  Paramegers: (oaOccTermArray)\n"
"    Calls: void getTermsByPosition(oaOccTermArray& array) const\n"
"    Signature: getTermsByPosition|void-void|ref-oaOccTermArray,\n"
"    BrowseData: 0,oaOccTermArray\n"
"    This function retrieves the terminals in this occurrence that have been assigned a position and returns them in the specified oaOccTermArray . A position in the array may be NULL to reflect that there is no terminal assigned to that position. The position of a terminal in the array reflects the position assigned to the terminal.\n"
;

static PyObject*
oaOccurrence_getTermsByPosition(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaOccTermArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccTermArray_Convert,&p1)) {
        data.DataCall()->getTermsByPosition(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_getTermsIter_doc[] = 
"Class: oaOccurrence, Function: getTermsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaOccTerm getTermsIter() const\n"
"    Signature: getTermsIter|simple-oaIter_oaOccTerm|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of terms in this occurrence. The filter flag bits can be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacTermIterAll: the collection contains all terminals\n"
"    oacTermIterSingleBit: the collection contains single-bit terminals\n"
"    oacTermIterBundle: the collection contains all the bundleTerms in the occurrence\n"
"    oacTermIterNotImplicit: the collection contains explicitly created terminals\n"
"    oacInvalidOccurrenceTermIterFlags\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaOccTerm getTermsIter(oaUInt4 filterFlags) const\n"
"    Signature: getTermsIter|simple-oaIter_oaOccTerm|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of terms in this occurrence. The filter flag bits can be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacTermIterAll: the collection contains all terminals\n"
"    oacTermIterSingleBit: the collection contains single-bit terminals\n"
"    oacTermIterBundle: the collection contains all the bundleTerms in the occurrence\n"
"    oacTermIterNotImplicit: the collection contains explicitly created terminals\n"
"    oacInvalidOccurrenceTermIterFlags\n"
;

static PyObject*
oaOccurrence_getTermsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaOccTerm* result= new oaIter_oaOccTerm(data.DataCall()->getTerms());
            return PyoaIter_oaOccTerm_FromoaIter_oaOccTerm(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaOccTerm* result= new oaIter_oaOccTerm(data.DataCall()->getTerms(p1.Data()));
            return PyoaIter_oaOccTerm_FromoaIter_oaOccTerm(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccurrence, function: getTermsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_getVectorInstDefs_doc[] = 
"Class: oaOccurrence, Function: getVectorInstDefs\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaOccVectorInstDef_oaOccurrence getVectorInstDefs() const\n"
"    Signature: getVectorInstDefs|simple-oaCollection_oaOccVectorInstDef_oaOccurrence|\n"
"    BrowseData: 1\n"
"    This function returns a collection of the vectorInstDefs in this occurrence.\n"
;

static PyObject*
oaOccurrence_getVectorInstDefs(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaOccVectorInstDef_oaOccurrence* result= new oaCollection_oaOccVectorInstDef_oaOccurrence(data.DataCall()->getVectorInstDefs());
        return PyoaCollection_oaOccVectorInstDef_oaOccurrence_FromoaCollection_oaOccVectorInstDef_oaOccurrence(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_getVectorInstDefsIter_doc[] = 
"Class: oaOccurrence, Function: getVectorInstDefsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaOccVectorInstDef getVectorInstDefsIter() const\n"
"    Signature: getVectorInstDefsIter|simple-oaIter_oaOccVectorInstDef|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of the vectorInstDefs in this occurrence.\n"
;

static PyObject*
oaOccurrence_getVectorInstDefsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaOccVectorInstDef* result= new oaIter_oaOccVectorInstDef(data.DataCall()->getVectorInstDefs());
        return PyoaIter_oaOccVectorInstDef_FromoaIter_oaOccVectorInstDef(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_uniquify_doc[] = 
"Class: oaOccurrence, Function: uniquify\n"
"  Paramegers: ()\n"
"    Calls: oaOccurrence* uniquify()\n"
"    Signature: uniquify|ptr-oaOccurrence|\n"
"    BrowseData: 1\n"
"    This function ensures that this is the only occurrence of this module, creating a new module variant if necessary. This operation is applied recursively up the hierarchy, stopping when an occurrence that is already unique is reached. This version creates the module with an automatically generated name.\n"
"    Public object pointers are invalidated for all the occurrences that are uniquified due to this operation. The uniquified occurrences will refer to new modules, but existing module domain pointers will not be affected by this function.\n"
"    oacModuleAndOccurrenceNotInSameDesign\n"
"    oacCannotUndoUniquify\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: oaOccurrence* uniquify(const oaScalarName& modName)\n"
"    Signature: uniquify|ptr-oaOccurrence|cref-oaScalarName,\n"
"    oaOccurrence::uniquify\n"
"    This function ensures that this is the only occurrence of this module, creating a new module variant if necessary. This operation is applied recursively up the hierarchy, stopping when an occurrence that is already unique is reached. This version uses an explicitly specified name for the module.\n"
"    Public object pointers are invalidated for all the occurrences that are uniquified due to this operation. The uniquified occurrences will refer to new modules, but existing module domain pointers will not be affected by this function.\n"
"    modName\n"
"    The name of the new module\n"
"    oacModuleExists\n"
"    oacModuleAndOccurrenceNotInSameDesign\n"
"    oacCannotUndoUniquify\n"
;

static PyObject*
oaOccurrence_uniquify(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOccurrenceObject* self=(PyoaOccurrenceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaOccurrencep result= (data.DataCall()->uniquify());
            return PyoaOccurrence_FromoaOccurrence(result);
        }
    }
    PyErr_Clear();
    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            oaOccurrencep result= (data.DataCall()->uniquify(p1.Data()));
            return PyoaOccurrence_FromoaOccurrence(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaOccurrence, function: uniquify, Choices are:\n"
        "    ()\n"
        "    (oaScalarName)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOccurrence_isNull_doc[] =
"Class: oaOccurrence, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOccurrence_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOccurrence data;
    int convert_status=PyoaOccurrence_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOccurrence_assign_doc[] = 
"Class: oaOccurrence, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOccurrence_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOccurrence data;
  int convert_status=PyoaOccurrence_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOccurrence p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOccurrence_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOccurrence_methodlist[] = {
    {"destroy",(PyCFunction)oaOccurrence_destroy,METH_VARARGS,oaOccurrence_destroy_doc},
    {"getAssignments",(PyCFunction)oaOccurrence_getAssignments,METH_VARARGS,oaOccurrence_getAssignments_doc},
    {"getAssignmentsIter",(PyCFunction)oaOccurrence_getAssignmentsIter,METH_VARARGS,oaOccurrence_getAssignmentsIter_doc},
    {"getBlock",(PyCFunction)oaOccurrence_getBlock,METH_VARARGS,oaOccurrence_getBlock_doc},
    {"getBusNetDefs",(PyCFunction)oaOccurrence_getBusNetDefs,METH_VARARGS,oaOccurrence_getBusNetDefs_doc},
    {"getBusNetDefsIter",(PyCFunction)oaOccurrence_getBusNetDefsIter,METH_VARARGS,oaOccurrence_getBusNetDefsIter_doc},
    {"getBusTermDefs",(PyCFunction)oaOccurrence_getBusTermDefs,METH_VARARGS,oaOccurrence_getBusTermDefs_doc},
    {"getBusTermDefsIter",(PyCFunction)oaOccurrence_getBusTermDefsIter,METH_VARARGS,oaOccurrence_getBusTermDefsIter_doc},
    {"getConnectDefs",(PyCFunction)oaOccurrence_getConnectDefs,METH_VARARGS,oaOccurrence_getConnectDefs_doc},
    {"getConnectDefsIter",(PyCFunction)oaOccurrence_getConnectDefsIter,METH_VARARGS,oaOccurrence_getConnectDefsIter_doc},
    {"getInstTerms",(PyCFunction)oaOccurrence_getInstTerms,METH_VARARGS,oaOccurrence_getInstTerms_doc},
    {"getInstTermsIter",(PyCFunction)oaOccurrence_getInstTermsIter,METH_VARARGS,oaOccurrence_getInstTermsIter_doc},
    {"getInsts",(PyCFunction)oaOccurrence_getInsts,METH_VARARGS,oaOccurrence_getInsts_doc},
    {"getInstsIter",(PyCFunction)oaOccurrence_getInstsIter,METH_VARARGS,oaOccurrence_getInstsIter_doc},
    {"getModule",(PyCFunction)oaOccurrence_getModule,METH_VARARGS,oaOccurrence_getModule_doc},
    {"getModuleInstHeaders",(PyCFunction)oaOccurrence_getModuleInstHeaders,METH_VARARGS,oaOccurrence_getModuleInstHeaders_doc},
    {"getModuleInstHeadersIter",(PyCFunction)oaOccurrence_getModuleInstHeadersIter,METH_VARARGS,oaOccurrence_getModuleInstHeadersIter_doc},
    {"getNets",(PyCFunction)oaOccurrence_getNets,METH_VARARGS,oaOccurrence_getNets_doc},
    {"getNetsIter",(PyCFunction)oaOccurrence_getNetsIter,METH_VARARGS,oaOccurrence_getNetsIter_doc},
    {"getOccInst",(PyCFunction)oaOccurrence_getOccInst,METH_VARARGS,oaOccurrence_getOccInst_doc},
    {"getTerms",(PyCFunction)oaOccurrence_getTerms,METH_VARARGS,oaOccurrence_getTerms_doc},
    {"getTermsByPosition",(PyCFunction)oaOccurrence_getTermsByPosition,METH_VARARGS,oaOccurrence_getTermsByPosition_doc},
    {"getTermsIter",(PyCFunction)oaOccurrence_getTermsIter,METH_VARARGS,oaOccurrence_getTermsIter_doc},
    {"getVectorInstDefs",(PyCFunction)oaOccurrence_getVectorInstDefs,METH_VARARGS,oaOccurrence_getVectorInstDefs_doc},
    {"getVectorInstDefsIter",(PyCFunction)oaOccurrence_getVectorInstDefsIter,METH_VARARGS,oaOccurrence_getVectorInstDefsIter_doc},
    {"uniquify",(PyCFunction)oaOccurrence_uniquify,METH_VARARGS,oaOccurrence_uniquify_doc},
    {"isNull",(PyCFunction)oaOccurrence_tp_isNull,METH_VARARGS,oaOccurrence_isNull_doc},
    {"assign",(PyCFunction)oaOccurrence_tp_assign,METH_VARARGS,oaOccurrence_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOccurrence_doc[] = 
"Class: oaOccurrence\n"
"  The occurrence domain is a fully unfolded hierarchy that contains a union of the connectivity objects in the block and the module domains. See Understanding EMH in the Programmer's Guide for more discussion.\n"
"  The oaOccurrence class represents an occurrence of an oaBlock and/or an oaModule in the occurrence hierarchy. An oaDesign may have zero or one top oaOccurrence. Except for a top occurrence, each oaOccurrence has a single oaOccInst that is its parent. An oaOccurrence also has zero or more occInsts that are its children.\n"
"  Occurrences will only exist where the occurrence hierarchy has been expanded in the current session by starting at the top occurrence and calling oaOccInst::getMasterOccurrence(true). Occurrence objects will appear in the hierarchy representing all module objects that are instantiated under the top module and all block connectivity objects.\n"
"  The oaOccurrence class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaOccurrence)\n"
"    Calls: (const oaOccurrence&)\n"
"    Signature: oaOccurrence||cref-oaOccurrence,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOccurrence_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOccurrence",
    sizeof(PyoaOccurrenceObject),
    0,
    (destructor)oaOccurrence_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOccurrence_tp_compare,	/* tp_compare */
    (reprfunc)oaOccurrence_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOccurrence_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOccurrence_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaOccObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOccurrence_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOccurrence_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOccurrence_Type)<0) {
      printf("** PyType_Ready failed for: oaOccurrence\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOccurrence",
           (PyObject*)(&PyoaOccurrence_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOccurrence\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOccurrenceModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaOccurrenceModTypeEnum_Convert(PyObject* ob,PyParamoaOccurrenceModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaOccurrenceModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOccurrenceModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaOccurrenceModTypeEnum_FromoaOccurrenceModTypeEnum(oaOccurrenceModTypeEnum ob)
{

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaOccurrenceModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaOccurrenceModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaOccurrenceModTypeEnum_FromoaOccurrenceModTypeEnum(oaOccurrenceModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaOccurrenceModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaOccurrenceModTypeEnum_doc[] =
"Type convert function for enum: oaOccurrenceModTypeEnum";
                               
static PyMethodDef PyoaOccurrenceModTypeEnum_method =
  {"oaOccurrenceModTypeEnum",(PyCFunction)PyoaOccurrenceModTypeEnum_TypeFunction,METH_VARARGS,oaOccurrenceModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaOccurrenceModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaOccurrenceModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaOccurrenceModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaOccurrenceModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOpPoint
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOpPoint_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOpPoint_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOpPointObject* self = (PyoaOpPointObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOpPoint)
    {
        PyParamoaOpPoint p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOpPoint_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOpPoint, Choices are:\n"
        "    (oaOpPoint)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOpPoint_tp_dealloc(PyoaOpPointObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOpPoint_tp_repr(PyObject *ob)
{
    PyParamoaOpPoint value;
    int convert_status=PyoaOpPoint_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[31];
    sprintf(buffer,"<oaOpPoint::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOpPoint_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOpPoint v1;
    PyParamoaOpPoint v2;
    int convert_status1=PyoaOpPoint_Convert(ob1,&v1);
    int convert_status2=PyoaOpPoint_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOpPoint_Convert(PyObject* ob,PyParamoaOpPoint* result)
{
    if (ob == NULL) return 1;
    if (PyoaOpPoint_Check(ob)) {
        result->SetData( (oaOpPoint**) ((PyoaOpPointObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOpPoint Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOpPoint_FromoaOpPoint(oaOpPoint** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOpPoint* data=*value;
        PyObject* bself = PyoaOpPoint_Type.tp_alloc(&PyoaOpPoint_Type,0);
        if (bself == NULL) return bself;
        PyoaOpPointObject* self = (PyoaOpPointObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOpPoint_FromoaOpPoint(oaOpPoint* data)
{
    if (data) {
       PyObject* bself = PyoaOpPoint_Type.tp_alloc(&PyoaOpPoint_Type,0);
       if (bself == NULL) return bself;
       PyoaOpPointObject* self = (PyoaOpPointObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOpPoint_destroy_doc[] = 
"Class: oaOpPoint, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function destroys this opPoint, removing it from the technology database.\n"
;

static PyObject*
oaOpPoint_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOpPoint data;
    int convert_status=PyoaOpPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOpPointObject* self=(PyoaOpPointObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOpPoint_getName_doc[] = 
"Class: oaOpPoint, Function: getName\n"
"  Paramegers: (oaString)\n"
"    Calls: void getName(oaString& name) const\n"
"    Signature: getName|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function gets the name of this opPoint.\n"
;

static PyObject*
oaOpPoint_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOpPoint data;
    int convert_status=PyoaOpPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOpPointObject* self=(PyoaOpPointObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOpPoint_getProcess_doc[] = 
"Class: oaOpPoint, Function: getProcess\n"
"  Paramegers: ()\n"
"    Calls: oaFloat getProcess() const\n"
"    Signature: getProcess|simple-oaFloat|\n"
"    BrowseData: 1\n"
"    This function gets the process value of this opPoint.\n"
"    Note: OpenAccess assumes PVT data is specified in terms of the following units:\n"
"    voltage: Volts\n"
"    temperature:  Celsius (Centigrade)\n"
"    Process is a dimensionless number that is undefined by OpenAccess.\n"
;

static PyObject*
oaOpPoint_getProcess(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOpPoint data;
    int convert_status=PyoaOpPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOpPointObject* self=(PyoaOpPointObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaFloat result= (data.DataCall()->getProcess());
        return PyoaFloat_FromoaFloat(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOpPoint_getTemperature_doc[] = 
"Class: oaOpPoint, Function: getTemperature\n"
"  Paramegers: ()\n"
"    Calls: oaFloat getTemperature() const\n"
"    Signature: getTemperature|simple-oaFloat|\n"
"    BrowseData: 1\n"
"    This function gets the temperature value of this opPoint.\n"
"    Note: OpenAccess assumes PVT data is specified in terms of the following units:\n"
"    voltage: Volts\n"
"    temperature:  Celsius (Centigrade)\n"
"    Process is a dimensionless number that is undefined by OpenAccess.\n"
;

static PyObject*
oaOpPoint_getTemperature(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOpPoint data;
    int convert_status=PyoaOpPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOpPointObject* self=(PyoaOpPointObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaFloat result= (data.DataCall()->getTemperature());
        return PyoaFloat_FromoaFloat(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOpPoint_getUsedIn_doc[] = 
"Class: oaOpPoint, Function: getUsedIn\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaOpPointHeader_oaOpPoint getUsedIn() const\n"
"    Signature: getUsedIn|simple-oaCollection_oaOpPointHeader_oaOpPoint|\n"
"    BrowseData: 1\n"
"    This function returns a collection of opPointHeaders in all designs that refer to this opPoint object.\n"
;

static PyObject*
oaOpPoint_getUsedIn(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOpPoint data;
    int convert_status=PyoaOpPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOpPointObject* self=(PyoaOpPointObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaOpPointHeader_oaOpPoint* result= new oaCollection_oaOpPointHeader_oaOpPoint(data.DataCall()->getUsedIn());
        return PyoaCollection_oaOpPointHeader_oaOpPoint_FromoaCollection_oaOpPointHeader_oaOpPoint(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOpPoint_getUsedInIter_doc[] = 
"Class: oaOpPoint, Function: getUsedInIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaOpPointHeader getUsedInIter() const\n"
"    Signature: getUsedInIter|simple-oaIter_oaOpPointHeader|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of opPointHeaders in all designs that refer to this opPoint object.\n"
;

static PyObject*
oaOpPoint_getUsedInIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOpPoint data;
    int convert_status=PyoaOpPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOpPointObject* self=(PyoaOpPointObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaOpPointHeader* result= new oaIter_oaOpPointHeader(data.DataCall()->getUsedIn());
        return PyoaIter_oaOpPointHeader_FromoaIter_oaOpPointHeader(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOpPoint_getVoltage_doc[] = 
"Class: oaOpPoint, Function: getVoltage\n"
"  Paramegers: ()\n"
"    Calls: oaFloat getVoltage() const\n"
"    Signature: getVoltage|simple-oaFloat|\n"
"    BrowseData: 1\n"
"    This function gets the voltage value of this opPoint.\n"
"    Note: OpenAccess assumes PVT data is specified in terms of the following units:\n"
"    voltage: Volts\n"
"    temperature:  Celsius (Centigrade)\n"
"    Process is a dimensionless number that is undefined by OpenAccess.\n"
;

static PyObject*
oaOpPoint_getVoltage(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOpPoint data;
    int convert_status=PyoaOpPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOpPointObject* self=(PyoaOpPointObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaFloat result= (data.DataCall()->getVoltage());
        return PyoaFloat_FromoaFloat(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOpPoint_setProcess_doc[] = 
"Class: oaOpPoint, Function: setProcess\n"
"  Paramegers: (oaFloat)\n"
"    Calls: void setProcess(oaFloat process)\n"
"    Signature: setProcess|void-void|simple-oaFloat,\n"
"    This function sets the process value of this opPoint to the specified value.\n"
"    Note: OpenAccess assumes PVT data is specified in terms of the following units:\n"
"    voltage: Volts\n"
"    temperature:  Celsius (Centigrade)\n"
"    Process is a dimensionless number that is undefined by OpenAccess.\n"
;

static PyObject*
oaOpPoint_setProcess(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOpPoint data;
    int convert_status=PyoaOpPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOpPointObject* self=(PyoaOpPointObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaFloat p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaFloat_Convert,&p1)) {
        data.DataCall()->setProcess(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOpPoint_setTemperature_doc[] = 
"Class: oaOpPoint, Function: setTemperature\n"
"  Paramegers: (oaFloat)\n"
"    Calls: void setTemperature(oaFloat temperature)\n"
"    Signature: setTemperature|void-void|simple-oaFloat,\n"
"    This function sets the temperature value of this opPoint to the specified value.\n"
"    Note: OpenAccess assumes PVT data is specified in terms of the following units:\n"
"    voltage: Volts\n"
"    temperature:  Celsius (Centigrade)\n"
"    Process is a dimensionless number that is undefined by OpenAccess.\n"
;

static PyObject*
oaOpPoint_setTemperature(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOpPoint data;
    int convert_status=PyoaOpPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOpPointObject* self=(PyoaOpPointObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaFloat p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaFloat_Convert,&p1)) {
        data.DataCall()->setTemperature(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOpPoint_setVoltage_doc[] = 
"Class: oaOpPoint, Function: setVoltage\n"
"  Paramegers: (oaFloat)\n"
"    Calls: void setVoltage(oaFloat voltage)\n"
"    Signature: setVoltage|void-void|simple-oaFloat,\n"
"    This function sets the voltage value of this opPoint to the specified value.\n"
"    Note: OpenAccess assumes PVT data is specified in terms of the following units:\n"
"    voltage: Volts\n"
"    temperature:  Celsius (Centigrade)\n"
"    Process is a dimensionless number that is undefined by OpenAccess.\n"
;

static PyObject*
oaOpPoint_setVoltage(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOpPoint data;
    int convert_status=PyoaOpPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOpPointObject* self=(PyoaOpPointObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaFloat p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaFloat_Convert,&p1)) {
        data.DataCall()->setVoltage(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOpPoint_isNull_doc[] =
"Class: oaOpPoint, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOpPoint_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOpPoint data;
    int convert_status=PyoaOpPoint_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOpPoint_assign_doc[] = 
"Class: oaOpPoint, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOpPoint_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOpPoint data;
  int convert_status=PyoaOpPoint_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOpPoint p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOpPoint_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOpPoint_methodlist[] = {
    {"destroy",(PyCFunction)oaOpPoint_destroy,METH_VARARGS,oaOpPoint_destroy_doc},
    {"getName",(PyCFunction)oaOpPoint_getName,METH_VARARGS,oaOpPoint_getName_doc},
    {"getProcess",(PyCFunction)oaOpPoint_getProcess,METH_VARARGS,oaOpPoint_getProcess_doc},
    {"getTemperature",(PyCFunction)oaOpPoint_getTemperature,METH_VARARGS,oaOpPoint_getTemperature_doc},
    {"getUsedIn",(PyCFunction)oaOpPoint_getUsedIn,METH_VARARGS,oaOpPoint_getUsedIn_doc},
    {"getUsedInIter",(PyCFunction)oaOpPoint_getUsedInIter,METH_VARARGS,oaOpPoint_getUsedInIter_doc},
    {"getVoltage",(PyCFunction)oaOpPoint_getVoltage,METH_VARARGS,oaOpPoint_getVoltage_doc},
    {"setProcess",(PyCFunction)oaOpPoint_setProcess,METH_VARARGS,oaOpPoint_setProcess_doc},
    {"setTemperature",(PyCFunction)oaOpPoint_setTemperature,METH_VARARGS,oaOpPoint_setTemperature_doc},
    {"setVoltage",(PyCFunction)oaOpPoint_setVoltage,METH_VARARGS,oaOpPoint_setVoltage_doc},
    {"isNull",(PyCFunction)oaOpPoint_tp_isNull,METH_VARARGS,oaOpPoint_isNull_doc},
    {"assign",(PyCFunction)oaOpPoint_tp_assign,METH_VARARGS,oaOpPoint_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOpPoint_doc[] = 
"Class: oaOpPoint\n"
"  The oaOpPoint class defines an operating point that represents a single triplet of process, voltage, and temperature (PVT) defined in a particular analysis library.\n"
"  Note: OpenAccess assumes PVT data is specified in terms of the following units:\n"
"  voltage: Volts\n"
"  temperature:  Celsius (Centigrade)\n"
"  Process is a dimensionless number that is undefined by OpenAccess.\n"
"  The oaOpPoint class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaOpPoint)\n"
"    Calls: (const oaOpPoint&)\n"
"    Signature: oaOpPoint||cref-oaOpPoint,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOpPoint_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOpPoint",
    sizeof(PyoaOpPointObject),
    0,
    (destructor)oaOpPoint_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOpPoint_tp_compare,	/* tp_compare */
    (reprfunc)oaOpPoint_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOpPoint_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOpPoint_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaTechObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOpPoint_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOpPoint_static_create_doc[] = 
"Class: oaOpPoint, Function: create\n"
"  Paramegers: (oaAnalysisLib,oaString,oaFloat,oaFloat,oaFloat)\n"
"    Calls: oaOpPoint* create(oaAnalysisLib* analysisLib,const oaString& name,oaFloat process,oaFloat voltage,oaFloat temperature)\n"
"    Signature: create|ptr-oaOpPoint|ptr-oaAnalysisLib,cref-oaString,simple-oaFloat,simple-oaFloat,simple-oaFloat,\n"
"    This function creates an operating point object with the specified name , process , voltage , and temperature values.\n"
"    Note: OpenAccess assumes PVT data is specified in terms of the following units:\n"
"    voltage: Volts\n"
"    temperature:  Celsius (Centigrade)\n"
"    Process is a dimensionless number that is undefined by OpenAccess.\n"
"    oacOpPointNameExists\n"
;

static PyObject*
oaOpPoint_static_create(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAnalysisLib p1;
    PyParamoaString p2;
    PyParamoaFloat p3;
    PyParamoaFloat p4;
    PyParamoaFloat p5;
    if (PyArg_ParseTuple(args,"O&O&O&O&O&",
          &PyoaAnalysisLib_Convert,&p1,
          &PyoaString_Convert,&p2,
          &PyoaFloat_Convert,&p3,
          &PyoaFloat_Convert,&p4,
          &PyoaFloat_Convert,&p5)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaOpPointp result= (oaOpPoint::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
        return PyoaOpPoint_FromoaOpPoint(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOpPoint_static_find_doc[] = 
"Class: oaOpPoint, Function: find\n"
"  Paramegers: (oaAnalysisLib,oaString)\n"
"    Calls: oaOpPoint* find(const oaAnalysisLib* analysisLib,const oaString& name)\n"
"    Signature: find|ptr-oaOpPoint|cptr-oaAnalysisLib,cref-oaString,\n"
"    This function searches the technology database for an opPoint with the specified name that is associated with the specified analysisLib in that technology database. If found, a pointer to the opPoint object is returned. Otherwise, NULL is returned.\n"
;

static PyObject*
oaOpPoint_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaAnalysisLib p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaAnalysisLib_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaOpPointp result= (oaOpPoint::find(p1.Data(),p2.Data()));
        return PyoaOpPoint_FromoaOpPoint(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaOpPoint_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaOpPoint_static_create,METH_VARARGS,oaOpPoint_static_create_doc},
    {"static_find",(PyCFunction)oaOpPoint_static_find,METH_VARARGS,oaOpPoint_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOpPoint_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOpPoint_Type)<0) {
      printf("** PyType_Ready failed for: oaOpPoint\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOpPoint",
           (PyObject*)(&PyoaOpPoint_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOpPoint\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaOpPoint_Type.tp_dict;
    for(method=oaOpPoint_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOpPointHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOpPointHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOpPointHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOpPointHeaderObject* self = (PyoaOpPointHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaOpPointHeader)
    {
        PyParamoaOpPointHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOpPointHeader_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOpPointHeader, Choices are:\n"
        "    (oaOpPointHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOpPointHeader_tp_dealloc(PyoaOpPointHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOpPointHeader_tp_repr(PyObject *ob)
{
    PyParamoaOpPointHeader value;
    int convert_status=PyoaOpPointHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[37];
    sprintf(buffer,"<oaOpPointHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOpPointHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOpPointHeader v1;
    PyParamoaOpPointHeader v2;
    int convert_status1=PyoaOpPointHeader_Convert(ob1,&v1);
    int convert_status2=PyoaOpPointHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOpPointHeader_Convert(PyObject* ob,PyParamoaOpPointHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaOpPointHeader_Check(ob)) {
        result->SetData( (oaOpPointHeader**) ((PyoaOpPointHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOpPointHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOpPointHeader_FromoaOpPointHeader(oaOpPointHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaOpPointHeader* data=*value;
        PyObject* bself = PyoaOpPointHeader_Type.tp_alloc(&PyoaOpPointHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaOpPointHeaderObject* self = (PyoaOpPointHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaOpPointHeader_FromoaOpPointHeader(oaOpPointHeader* data)
{
    if (data) {
       PyObject* bself = PyoaOpPointHeader_Type.tp_alloc(&PyoaOpPointHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaOpPointHeaderObject* self = (PyoaOpPointHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOpPointHeader_getAnalysisLibName_doc[] = 
"Class: oaOpPointHeader, Function: getAnalysisLibName\n"
"  Paramegers: (oaString)\n"
"    Calls: void getAnalysisLibName(oaString& name) const\n"
"    Signature: getAnalysisLibName|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function gets the name of the analysisLib.\n"
;

static PyObject*
oaOpPointHeader_getAnalysisLibName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOpPointHeader data;
    int convert_status=PyoaOpPointHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOpPointHeaderObject* self=(PyoaOpPointHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getAnalysisLibName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOpPointHeader_getAnalysisOpPoints_doc[] = 
"Class: oaOpPointHeader, Function: getAnalysisOpPoints\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaAnalysisOpPoint_oaOpPointHeader getAnalysisOpPoints() const\n"
"    Signature: getAnalysisOpPoints|simple-oaCollection_oaAnalysisOpPoint_oaOpPointHeader|\n"
"    BrowseData: 1\n"
"    This function returns a collection of analysisOpPoints in this opPointHeader.\n"
;

static PyObject*
oaOpPointHeader_getAnalysisOpPoints(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOpPointHeader data;
    int convert_status=PyoaOpPointHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOpPointHeaderObject* self=(PyoaOpPointHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaAnalysisOpPoint_oaOpPointHeader* result= new oaCollection_oaAnalysisOpPoint_oaOpPointHeader(data.DataCall()->getAnalysisOpPoints());
        return PyoaCollection_oaAnalysisOpPoint_oaOpPointHeader_FromoaCollection_oaAnalysisOpPoint_oaOpPointHeader(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOpPointHeader_getAnalysisOpPointsIter_doc[] = 
"Class: oaOpPointHeader, Function: getAnalysisOpPointsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaAnalysisOpPoint getAnalysisOpPointsIter() const\n"
"    Signature: getAnalysisOpPointsIter|simple-oaIter_oaAnalysisOpPoint|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of analysisOpPoints in this opPointHeader.\n"
;

static PyObject*
oaOpPointHeader_getAnalysisOpPointsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOpPointHeader data;
    int convert_status=PyoaOpPointHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOpPointHeaderObject* self=(PyoaOpPointHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaAnalysisOpPoint* result= new oaIter_oaAnalysisOpPoint(data.DataCall()->getAnalysisOpPoints());
        return PyoaIter_oaAnalysisOpPoint_FromoaIter_oaAnalysisOpPoint(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOpPointHeader_getOpPoint_doc[] = 
"Class: oaOpPointHeader, Function: getOpPoint\n"
"  Paramegers: ()\n"
"    Calls: oaOpPoint* getOpPoint() const\n"
"    Signature: getOpPoint|ptr-oaOpPoint|\n"
"    BrowseData: 1\n"
"    This function attempts to return the opPoint associated with this opPointHeader. If the opPointHeader is bound, a pointer to the opPoint is returned. Otherwise, NULL is returned.\n"
;

static PyObject*
oaOpPointHeader_getOpPoint(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOpPointHeader data;
    int convert_status=PyoaOpPointHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOpPointHeaderObject* self=(PyoaOpPointHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaOpPointp result= (data.DataCall()->getOpPoint());
        return PyoaOpPoint_FromoaOpPoint(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOpPointHeader_getOpPointName_doc[] = 
"Class: oaOpPointHeader, Function: getOpPointName\n"
"  Paramegers: (oaString)\n"
"    Calls: void getOpPointName(oaString& name) const\n"
"    Signature: getOpPointName|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function gets the name of the oaOpPoint that is bound to the design.\n"
;

static PyObject*
oaOpPointHeader_getOpPointName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOpPointHeader data;
    int convert_status=PyoaOpPointHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOpPointHeaderObject* self=(PyoaOpPointHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getOpPointName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOpPointHeader_isBound_doc[] = 
"Class: oaOpPointHeader, Function: isBound\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isBound() const\n"
"    Signature: isBound|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value that indicates if this opPointHeader is bound.\n"
;

static PyObject*
oaOpPointHeader_isBound(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOpPointHeader data;
    int convert_status=PyoaOpPointHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOpPointHeaderObject* self=(PyoaOpPointHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isBound());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOpPointHeader_isNull_doc[] =
"Class: oaOpPointHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaOpPointHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaOpPointHeader data;
    int convert_status=PyoaOpPointHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaOpPointHeader_assign_doc[] = 
"Class: oaOpPointHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOpPointHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOpPointHeader data;
  int convert_status=PyoaOpPointHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOpPointHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOpPointHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOpPointHeader_methodlist[] = {
    {"getAnalysisLibName",(PyCFunction)oaOpPointHeader_getAnalysisLibName,METH_VARARGS,oaOpPointHeader_getAnalysisLibName_doc},
    {"getAnalysisOpPoints",(PyCFunction)oaOpPointHeader_getAnalysisOpPoints,METH_VARARGS,oaOpPointHeader_getAnalysisOpPoints_doc},
    {"getAnalysisOpPointsIter",(PyCFunction)oaOpPointHeader_getAnalysisOpPointsIter,METH_VARARGS,oaOpPointHeader_getAnalysisOpPointsIter_doc},
    {"getOpPoint",(PyCFunction)oaOpPointHeader_getOpPoint,METH_VARARGS,oaOpPointHeader_getOpPoint_doc},
    {"getOpPointName",(PyCFunction)oaOpPointHeader_getOpPointName,METH_VARARGS,oaOpPointHeader_getOpPointName_doc},
    {"isBound",(PyCFunction)oaOpPointHeader_isBound,METH_VARARGS,oaOpPointHeader_isBound_doc},
    {"isNull",(PyCFunction)oaOpPointHeader_tp_isNull,METH_VARARGS,oaOpPointHeader_isNull_doc},
    {"assign",(PyCFunction)oaOpPointHeader_tp_assign,METH_VARARGS,oaOpPointHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOpPointHeader_doc[] = 
"Class: oaOpPointHeader\n"
"  The oaOpPointHeader class implements an object that contains information about a particular opPoint and all the analysisOpPoints that use it.\n"
"  The oaOpPointHeader class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaOpPointHeader)\n"
"    Calls: (const oaOpPointHeader&)\n"
"    Signature: oaOpPointHeader||cref-oaOpPointHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOpPointHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOpPointHeader",
    sizeof(PyoaOpPointHeaderObject),
    0,
    (destructor)oaOpPointHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOpPointHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaOpPointHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOpPointHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOpPointHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaDesignObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOpPointHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOpPointHeader_static_find_doc[] = 
"Class: oaOpPointHeader, Function: find\n"
"  Paramegers: (oaDesign,oaString,oaString)\n"
"    Calls: oaOpPointHeader* find(const oaDesign* design,const oaString& analysisLibName,const oaString& opPointName)\n"
"    Signature: find|ptr-oaOpPointHeader|cptr-oaDesign,cref-oaString,cref-oaString,\n"
"    This function searches the specified design for an opPointHeader with the specified analysisLibName and opPointName .\n"
;

static PyObject*
oaOpPointHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign p1;
    PyParamoaString p2;
    PyParamoaString p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaDesign_Convert,&p1,
          &PyoaString_Convert,&p2,
          &PyoaString_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaOpPointHeaderp result= (oaOpPointHeader::find(p1.Data(),p2.Data(),p3.Data()));
        return PyoaOpPointHeader_FromoaOpPointHeader(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaOpPointHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaOpPointHeader_static_find,METH_VARARGS,oaOpPointHeader_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOpPointHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOpPointHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaOpPointHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOpPointHeader",
           (PyObject*)(&PyoaOpPointHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOpPointHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaOpPointHeader_Type.tp_dict;
    for(method=oaOpPointHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOpPointHeaderModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaOpPointHeaderModTypeEnum_Convert(PyObject* ob,PyParamoaOpPointHeaderModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacBindOpPointHeaderModType")==0) { result->SetData(oacBindOpPointHeaderModType); return 1;}
        if (strcasecmp(str,"oacUnbindOpPointHeaderModType")==0) { result->SetData(oacUnbindOpPointHeaderModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaOpPointHeaderModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOpPointHeaderModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaOpPointHeaderModTypeEnum_FromoaOpPointHeaderModTypeEnum(oaOpPointHeaderModTypeEnum ob)
{
    if (ob==oacBindOpPointHeaderModType) return PyString_FromString("oacBindOpPointHeaderModType");
    if (ob==oacUnbindOpPointHeaderModType) return PyString_FromString("oacUnbindOpPointHeaderModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaOpPointHeaderModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaOpPointHeaderModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaOpPointHeaderModTypeEnum_FromoaOpPointHeaderModTypeEnum(oaOpPointHeaderModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaOpPointHeaderModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaOpPointHeaderModTypeEnum_doc[] =
"Type convert function for enum: oaOpPointHeaderModTypeEnum";
                               
static PyMethodDef PyoaOpPointHeaderModTypeEnum_method =
  {"oaOpPointHeaderModTypeEnum",(PyCFunction)PyoaOpPointHeaderModTypeEnum_TypeFunction,METH_VARARGS,oaOpPointHeaderModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaOpPointHeaderModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacBindOpPointHeaderModType");
    PyDict_SetItemString(mod_dict,"oacBindOpPointHeaderModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacUnbindOpPointHeaderModType");
    PyDict_SetItemString(mod_dict,"oacUnbindOpPointHeaderModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaOpPointHeaderModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaOpPointHeaderModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaOpPointHeaderModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOpPointModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaOpPointModTypeEnum_Convert(PyObject* ob,PyParamoaOpPointModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacSetProcessOpPointModType")==0) { result->SetData(oacSetProcessOpPointModType); return 1;}
        if (strcasecmp(str,"oacSetVoltageOpPointModType")==0) { result->SetData(oacSetVoltageOpPointModType); return 1;}
        if (strcasecmp(str,"oacSetTemperatureOpPointModType")==0) { result->SetData(oacSetTemperatureOpPointModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaOpPointModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOpPointModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaOpPointModTypeEnum_FromoaOpPointModTypeEnum(oaOpPointModTypeEnum ob)
{
    if (ob==oacSetProcessOpPointModType) return PyString_FromString("oacSetProcessOpPointModType");
    if (ob==oacSetVoltageOpPointModType) return PyString_FromString("oacSetVoltageOpPointModType");
    if (ob==oacSetTemperatureOpPointModType) return PyString_FromString("oacSetTemperatureOpPointModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaOpPointModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaOpPointModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaOpPointModTypeEnum_FromoaOpPointModTypeEnum(oaOpPointModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaOpPointModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaOpPointModTypeEnum_doc[] =
"Type convert function for enum: oaOpPointModTypeEnum";
                               
static PyMethodDef PyoaOpPointModTypeEnum_method =
  {"oaOpPointModTypeEnum",(PyCFunction)PyoaOpPointModTypeEnum_TypeFunction,METH_VARARGS,oaOpPointModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaOpPointModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacSetProcessOpPointModType");
    PyDict_SetItemString(mod_dict,"oacSetProcessOpPointModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetVoltageOpPointModType");
    PyDict_SetItemString(mod_dict,"oacSetVoltageOpPointModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetTemperatureOpPointModType");
    PyDict_SetItemString(mod_dict,"oacSetTemperatureOpPointModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaOpPointModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaOpPointModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaOpPointModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOrient
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaOrient_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaOrient_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaOrientObject* self = (PyoaOrientObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaOrient();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaOrientEnum)
    {
        PyParamoaOrientEnum p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaOrientEnum_Convert,&p1)) {
            self->value =  new oaOrient(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            self->value =  new oaOrient(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaOrient)
    {
        PyParamoaOrient p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaOrient_Convert,&p1)) {
            self->value= new oaOrient(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaOrient, Choices are:\n"
        "    ()\n"
        "    (oaOrientEnum)\n"
        "    (oaString)\n"
        "    (oaOrient)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaOrient_tp_dealloc(PyoaOrientObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaOrient_tp_repr(PyObject *ob)
{
    PyParamoaOrient value;
    int convert_status=PyoaOrient_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    oaString sresult(value.DataCall()->getName());

    char addr[30];
    sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
    oaString buffer;
    buffer+=oaString("<oaOrient::");
    buffer+=oaString(addr);
    buffer+=oaString("::");
    buffer+=oaString(sresult);
    buffer+=oaString(">");
    result=PyString_FromString((char*)(const char*)buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaOrient_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaOrient v1;
    PyParamoaOrient v2;
    int convert_status1=PyoaOrient_Convert(ob1,&v1);
    int convert_status2=PyoaOrient_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaOrient_Convert(PyObject* ob,PyParamoaOrient* result)
{
    if (ob == NULL) return 1;
    if (PyoaOrient_Check(ob)) {
        result->SetData(  ((PyoaOrientObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOrient Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaOrient_FromoaOrient(oaOrient* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaOrient_Type.tp_alloc(&PyoaOrient_Type,0);
        if (bself == NULL) return bself;
        PyoaOrientObject* self = (PyoaOrientObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOrient_concat_doc[] = 
"Class: oaOrient, Function: concat\n"
"  Paramegers: (oaOrient)\n"
"    Calls: oaOrient concat(const oaOrient& orient) const\n"
"    Signature: concat|simple-oaOrient|cref-oaOrient,\n"
"    This function concatenates this orientation with the specified orientation and returns the result.\n"
"    orient\n"
"    The orientation with which to concatenate this orientation\n"
;

static PyObject*
oaOrient_concat(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOrient data;
    int convert_status=PyoaOrient_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOrientObject* self=(PyoaOrientObject*)ob;

    PyParamoaOrient p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOrient_Convert,&p1)) {
        oaOrient* result= new oaOrient(data.DataCall()->concat(p1.Data()));
        return PyoaOrient_FromoaOrient(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOrient_getName_doc[] = 
"Class: oaOrient, Function: getName\n"
"  Paramegers: ()\n"
"    Calls: const oaString& getName() const\n"
"    Signature: getName|cref-oaString|\n"
"    BrowseData: 1\n"
"    This function returns the name string associated with the encapsulated #oaOrientEnum object.\n"
;

static PyObject*
oaOrient_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOrient data;
    int convert_status=PyoaOrient_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOrientObject* self=(PyoaOrientObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaString result= (data.DataCall()->getName());
        return PyoaString_FromoaString(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOrient_getRelativeOrient_doc[] = 
"Class: oaOrient, Function: getRelativeOrient\n"
"  Paramegers: (oaOrient)\n"
"    Calls: oaOrient getRelativeOrient(const oaOrient& orient) const\n"
"    Signature: getRelativeOrient|simple-oaOrient|cref-oaOrient,\n"
"    This function returns the relative orientation required to transform this orientation to the specified target orientation 'orient'.\n"
"    orient\n"
"    The target orientation\n"
;

static PyObject*
oaOrient_getRelativeOrient(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOrient data;
    int convert_status=PyoaOrient_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOrientObject* self=(PyoaOrientObject*)ob;

    PyParamoaOrient p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOrient_Convert,&p1)) {
        oaOrient* result= new oaOrient(data.DataCall()->getRelativeOrient(p1.Data()));
        return PyoaOrient_FromoaOrient(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaOrient_oaOrientEnum_doc[] = 
"Class: oaOrient, Function: oaOrientEnum\n"
"  Paramegers: ()\n"
"    Calls: oaOrientEnum oaOrientEnum() const\n"
"    Signature: operator oaOrientEnum|simple-oaOrientEnum|\n"
"    BrowseData: 1\n"
"    This operator casts this oaOrient object into the corresponding #oaOrientEnum value.\n"
;

static PyObject*
oaOrient_oaOrientEnum(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaOrient data;
    int convert_status=PyoaOrient_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaOrientObject* self=(PyoaOrientObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaOrientEnum result= (data.DataCall()->operator oaOrientEnum());
        return PyoaOrientEnum_FromoaOrientEnum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaOrient_assign_doc[] = 
"Class: oaOrient, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaOrient_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaOrient data;
  int convert_status=PyoaOrient_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaOrient p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaOrient_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaOrient_methodlist[] = {
    {"concat",(PyCFunction)oaOrient_concat,METH_VARARGS,oaOrient_concat_doc},
    {"getName",(PyCFunction)oaOrient_getName,METH_VARARGS,oaOrient_getName_doc},
    {"getRelativeOrient",(PyCFunction)oaOrient_getRelativeOrient,METH_VARARGS,oaOrient_getRelativeOrient_doc},
    {"oaOrientEnum",(PyCFunction)oaOrient_oaOrientEnum,METH_VARARGS,oaOrient_oaOrientEnum_doc},
    {"assign",(PyCFunction)oaOrient_tp_assign,METH_VARARGS,oaOrient_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaOrient_doc[] = 
"Class: oaOrient\n"
"  The oaOrient is an enum wrapper class that describes the various possible combinations of rotation and mirroring about the X or Y axes.\n"
"  The Using Transforms section in the Programmers Guide has an illustration of each orientation.\n"
"  See Enum Wrappers in the Programmers Guide for a discussion of enum wrappers.\n"
"  oaOrientEnum\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaOrient()\n"
"    Signature: oaOrient||simple-oaOrientEnum,\n"
"    This function constructs an instance of an oaOrient class using the specified enum value.\n"
"    Note: \"Mirror X\" orientation is about the X (horizontal) axis, and \"Mirror Y\" is about the Y (vertical) axis.\n"
"  Paramegers: (oaOrientEnum)\n"
"    Calls: oaOrient(oaOrientEnum valueIn)\n"
"    Signature: oaOrient||simple-oaOrientEnum,\n"
"    This function constructs an instance of an oaOrient class using the specified enum value.\n"
"    Note: \"Mirror X\" orientation is about the X (horizontal) axis, and \"Mirror Y\" is about the Y (vertical) axis.\n"
"  Paramegers: (oaString)\n"
"    Calls: oaOrient(const oaString& name)\n"
"    Signature: oaOrient||cref-oaString,\n"
"    This function constructs an instance of an oaOrient class using the #oaOrientEnum associated with the specified string name . This name must be defined in the legal set of names associated with #oaOrientEnum.\n"
"    oacInvalidOrientName\n"
"  Paramegers: (oaOrient)\n"
"    Calls: (const oaOrient&)\n"
"    Signature: oaOrient||cref-oaOrient,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaOrient_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaOrient",
    sizeof(PyoaOrientObject),
    0,
    (destructor)oaOrient_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaOrient_tp_compare,	/* tp_compare */
    (reprfunc)oaOrient_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaOrient_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaOrient_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaOrient_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaOrient_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaOrient_Type)<0) {
      printf("** PyType_Ready failed for: oaOrient\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaOrient",
           (PyObject*)(&PyoaOrient_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaOrient\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaOrientEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaOrientEnum_Convert(PyObject* ob,PyParamoaOrientEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacR0")==0) { result->SetData(oacR0); return 1;}
        if (strcasecmp(str,"oacR90")==0) { result->SetData(oacR90); return 1;}
        if (strcasecmp(str,"oacR180")==0) { result->SetData(oacR180); return 1;}
        if (strcasecmp(str,"oacR270")==0) { result->SetData(oacR270); return 1;}
        if (strcasecmp(str,"oacMY")==0) { result->SetData(oacMY); return 1;}
        if (strcasecmp(str,"oacMYR90")==0) { result->SetData(oacMYR90); return 1;}
        if (strcasecmp(str,"oacMX")==0) { result->SetData(oacMX); return 1;}
        if (strcasecmp(str,"oacMXR90")==0) { result->SetData(oacMXR90); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaOrientEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaOrientEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaOrientEnum_FromoaOrientEnum(oaOrientEnum ob)
{
    if (ob==oacR0) return PyString_FromString("oacR0");
    if (ob==oacR90) return PyString_FromString("oacR90");
    if (ob==oacR180) return PyString_FromString("oacR180");
    if (ob==oacR270) return PyString_FromString("oacR270");
    if (ob==oacMY) return PyString_FromString("oacMY");
    if (ob==oacMYR90) return PyString_FromString("oacMYR90");
    if (ob==oacMX) return PyString_FromString("oacMX");
    if (ob==oacMXR90) return PyString_FromString("oacMXR90");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaOrientEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaOrientEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaOrientEnum_FromoaOrientEnum(oaOrientEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaOrientEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaOrientEnum_doc[] =
"Type convert function for enum: oaOrientEnum";
                               
static PyMethodDef PyoaOrientEnum_method =
  {"oaOrientEnum",(PyCFunction)PyoaOrientEnum_TypeFunction,METH_VARARGS,oaOrientEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaOrientEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacR0");
    PyDict_SetItemString(mod_dict,"oacR0",value);
    Py_DECREF(value);
    value=PyString_FromString("oacR90");
    PyDict_SetItemString(mod_dict,"oacR90",value);
    Py_DECREF(value);
    value=PyString_FromString("oacR180");
    PyDict_SetItemString(mod_dict,"oacR180",value);
    Py_DECREF(value);
    value=PyString_FromString("oacR270");
    PyDict_SetItemString(mod_dict,"oacR270",value);
    Py_DECREF(value);
    value=PyString_FromString("oacMY");
    PyDict_SetItemString(mod_dict,"oacMY",value);
    Py_DECREF(value);
    value=PyString_FromString("oacMYR90");
    PyDict_SetItemString(mod_dict,"oacMYR90",value);
    Py_DECREF(value);
    value=PyString_FromString("oacMX");
    PyDict_SetItemString(mod_dict,"oacMX",value);
    Py_DECREF(value);
    value=PyString_FromString("oacMXR90");
    PyDict_SetItemString(mod_dict,"oacMXR90",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaOrientEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaOrientEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaOrientEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaPRBoundary
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaPRBoundary_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaPRBoundary_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaPRBoundaryObject* self = (PyoaPRBoundaryObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaPRBoundary)
    {
        PyParamoaPRBoundary p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaPRBoundary_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaPRBoundary, Choices are:\n"
        "    (oaPRBoundary)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaPRBoundary_tp_dealloc(PyoaPRBoundaryObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaPRBoundary_tp_repr(PyObject *ob)
{
    PyParamoaPRBoundary value;
    int convert_status=PyoaPRBoundary_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[34];
    sprintf(buffer,"<oaPRBoundary::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaPRBoundary_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaPRBoundary v1;
    PyParamoaPRBoundary v2;
    int convert_status1=PyoaPRBoundary_Convert(ob1,&v1);
    int convert_status2=PyoaPRBoundary_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaPRBoundary_Convert(PyObject* ob,PyParamoaPRBoundary* result)
{
    if (ob == NULL) return 1;
    if (PyoaPRBoundary_Check(ob)) {
        result->SetData( (oaPRBoundary**) ((PyoaPRBoundaryObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaPRBoundary Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaPRBoundary_FromoaPRBoundary(oaPRBoundary** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaPRBoundary* data=*value;
        PyObject* bself = PyoaPRBoundary_Type.tp_alloc(&PyoaPRBoundary_Type,0);
        if (bself == NULL) return bself;
        PyoaPRBoundaryObject* self = (PyoaPRBoundaryObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaPRBoundary_FromoaPRBoundary(oaPRBoundary* data)
{
    if (data) {
       PyObject* bself = PyoaPRBoundary_Type.tp_alloc(&PyoaPRBoundary_Type,0);
       if (bself == NULL) return bself;
       PyoaPRBoundaryObject* self = (PyoaPRBoundaryObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaPRBoundary_getBlockagesOwnedBy_doc[] = 
"Class: oaPRBoundary, Function: getBlockagesOwnedBy\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaBlockage_oaPRBoundary getBlockagesOwnedBy() const\n"
"    Signature: getBlockagesOwnedBy|simple-oaCollection_oaBlockage_oaPRBoundary|\n"
"    BrowseData: 1\n"
"    This function returns a collection of derived blockages owned by this boundary.\n"
;

static PyObject*
oaPRBoundary_getBlockagesOwnedBy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPRBoundary data;
    int convert_status=PyoaPRBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPRBoundaryObject* self=(PyoaPRBoundaryObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaBlockage_oaPRBoundary* result= new oaCollection_oaBlockage_oaPRBoundary(data.DataCall()->getBlockagesOwnedBy());
        return PyoaCollection_oaBlockage_oaPRBoundary_FromoaCollection_oaBlockage_oaPRBoundary(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPRBoundary_getBlockagesOwnedByIter_doc[] = 
"Class: oaPRBoundary, Function: getBlockagesOwnedByIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaBlockage getBlockagesOwnedByIter() const\n"
"    Signature: getBlockagesOwnedByIter|simple-oaIter_oaBlockage|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of derived blockages owned by this boundary.\n"
;

static PyObject*
oaPRBoundary_getBlockagesOwnedByIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPRBoundary data;
    int convert_status=PyoaPRBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPRBoundaryObject* self=(PyoaPRBoundaryObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaBlockage* result= new oaIter_oaBlockage(data.DataCall()->getBlockagesOwnedBy());
        return PyoaIter_oaBlockage_FromoaIter_oaBlockage(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPRBoundary_getCoreBoxSpec_doc[] = 
"Class: oaPRBoundary, Function: getCoreBoxSpec\n"
"  Paramegers: (oaCoreBoxSpec)\n"
"    Calls: void getCoreBoxSpec(oaCoreBoxSpec& spec) const\n"
"    Signature: getCoreBoxSpec|void-void|ref-oaCoreBoxSpec,\n"
"    BrowseData: 0,oaCoreBoxSpec\n"
"    This function fills in the specified CoreBoxSpec with the CoreBox attributes for this PRBoundary. These define a grid of sites for placing lower level cells. See oaCoreBoxSpec for details.\n"
"    spec\n"
"    the oaCoreBoxSpec object to be filled out.\n"
;

static PyObject*
oaPRBoundary_getCoreBoxSpec(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPRBoundary data;
    int convert_status=PyoaPRBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPRBoundaryObject* self=(PyoaPRBoundaryObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaCoreBoxSpec p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaCoreBoxSpec_Convert,&p1)) {
        data.DataCall()->getCoreBoxSpec(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPRBoundary_getIOBox_doc[] = 
"Class: oaPRBoundary, Function: getIOBox\n"
"  Paramegers: (oaBox)\n"
"    Calls: void getIOBox(oaBox& box) const\n"
"    Signature: getIOBox|void-void|ref-oaBox,\n"
"    BrowseData: 0,oaBox\n"
"    This function fills the given oaBox with the data for the IO box associated with this PRBoundary object.\n"
"    box\n"
"    the bbox to be filled out with the IO box coordinates\n"
;

static PyObject*
oaPRBoundary_getIOBox(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPRBoundary data;
    int convert_status=PyoaPRBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPRBoundaryObject* self=(PyoaPRBoundaryObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBox p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBox_Convert,&p1)) {
        data.DataCall()->getIOBox(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPRBoundary_hasCoreBoxSpec_doc[] = 
"Class: oaPRBoundary, Function: hasCoreBoxSpec\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean hasCoreBoxSpec() const\n"
"    Signature: hasCoreBoxSpec|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating if a CoreBoxSpec has been set on this PRBoundary. See oaCoreBoxSpec for details.\n"
;

static PyObject*
oaPRBoundary_hasCoreBoxSpec(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPRBoundary data;
    int convert_status=PyoaPRBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPRBoundaryObject* self=(PyoaPRBoundaryObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->hasCoreBoxSpec());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPRBoundary_hasIOBox_doc[] = 
"Class: oaPRBoundary, Function: hasIOBox\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean hasIOBox() const\n"
"    Signature: hasIOBox|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating if an ioBox has been set on this prBoundary. See the explication of IO box in the class description.\n"
;

static PyObject*
oaPRBoundary_hasIOBox(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPRBoundary data;
    int convert_status=PyoaPRBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPRBoundaryObject* self=(PyoaPRBoundaryObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->hasIOBox());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPRBoundary_removeCoreBoxSpec_doc[] = 
"Class: oaPRBoundary, Function: removeCoreBoxSpec\n"
"  Paramegers: ()\n"
"    Calls: void removeCoreBoxSpec()\n"
"    Signature: removeCoreBoxSpec|void-void|\n"
"    BrowseData: 0\n"
"    This function removes the coreBoxSpec from this prBoundary object. See oaCoreBoxSpec for details.\n"
;

static PyObject*
oaPRBoundary_removeCoreBoxSpec(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPRBoundary data;
    int convert_status=PyoaPRBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPRBoundaryObject* self=(PyoaPRBoundaryObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->removeCoreBoxSpec();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPRBoundary_removeIOBox_doc[] = 
"Class: oaPRBoundary, Function: removeIOBox\n"
"  Paramegers: ()\n"
"    Calls: void removeIOBox()\n"
"    Signature: removeIOBox|void-void|\n"
"    BrowseData: 0\n"
"    This function removes the IO box from this prBoundary object. See the class description for details of the IO box.\n"
;

static PyObject*
oaPRBoundary_removeIOBox(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPRBoundary data;
    int convert_status=PyoaPRBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPRBoundaryObject* self=(PyoaPRBoundaryObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->removeIOBox();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPRBoundary_setCoreBoxSpec_doc[] = 
"Class: oaPRBoundary, Function: setCoreBoxSpec\n"
"  Paramegers: (oaCoreBoxSpec)\n"
"    Calls: void setCoreBoxSpec(const oaCoreBoxSpec& spec)\n"
"    Signature: setCoreBoxSpec|void-void|cref-oaCoreBoxSpec,\n"
"    This function uses the specified CoreBoxSpec to set the CoreBox attributes for this PRBoundary. These define a grid of sites for placing lower level cells. See oaCoreBoxSpec for details.\n"
"    An exception is thrown if the siteDef in the coreBoxSpec is from a technology database that is not included in the referenced graph of technology databases for the technology database currently bound to the design containing the boundary.\n"
"    spec\n"
"    the coreBoxSpec to store on this PRBoundary.\n"
"    oacSiteDefNotInTechAssociatedWithDesign\n"
;

static PyObject*
oaPRBoundary_setCoreBoxSpec(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPRBoundary data;
    int convert_status=PyoaPRBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPRBoundaryObject* self=(PyoaPRBoundaryObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaCoreBoxSpec p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaCoreBoxSpec_Convert,&p1)) {
        data.DataCall()->setCoreBoxSpec(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPRBoundary_setIOBox_doc[] = 
"Class: oaPRBoundary, Function: setIOBox\n"
"  Paramegers: (oaBox)\n"
"    Calls: void setIOBox(const oaBox& box)\n"
"    Signature: setIOBox|void-void|cref-oaBox,\n"
"    This function stores the contents of the given IO box on the prBoundary object. See the class description for details of the IO box.\n"
"    box\n"
"    the bbox indicating the IO area on the chip\n"
;

static PyObject*
oaPRBoundary_setIOBox(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPRBoundary data;
    int convert_status=PyoaPRBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPRBoundaryObject* self=(PyoaPRBoundaryObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBox p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBox_Convert,&p1)) {
        data.DataCall()->setIOBox(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPRBoundary_isNull_doc[] =
"Class: oaPRBoundary, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaPRBoundary_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaPRBoundary data;
    int convert_status=PyoaPRBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaPRBoundary_assign_doc[] = 
"Class: oaPRBoundary, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaPRBoundary_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaPRBoundary data;
  int convert_status=PyoaPRBoundary_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaPRBoundary p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaPRBoundary_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaPRBoundary_methodlist[] = {
    {"getBlockagesOwnedBy",(PyCFunction)oaPRBoundary_getBlockagesOwnedBy,METH_VARARGS,oaPRBoundary_getBlockagesOwnedBy_doc},
    {"getBlockagesOwnedByIter",(PyCFunction)oaPRBoundary_getBlockagesOwnedByIter,METH_VARARGS,oaPRBoundary_getBlockagesOwnedByIter_doc},
    {"getCoreBoxSpec",(PyCFunction)oaPRBoundary_getCoreBoxSpec,METH_VARARGS,oaPRBoundary_getCoreBoxSpec_doc},
    {"getIOBox",(PyCFunction)oaPRBoundary_getIOBox,METH_VARARGS,oaPRBoundary_getIOBox_doc},
    {"hasCoreBoxSpec",(PyCFunction)oaPRBoundary_hasCoreBoxSpec,METH_VARARGS,oaPRBoundary_hasCoreBoxSpec_doc},
    {"hasIOBox",(PyCFunction)oaPRBoundary_hasIOBox,METH_VARARGS,oaPRBoundary_hasIOBox_doc},
    {"removeCoreBoxSpec",(PyCFunction)oaPRBoundary_removeCoreBoxSpec,METH_VARARGS,oaPRBoundary_removeCoreBoxSpec_doc},
    {"removeIOBox",(PyCFunction)oaPRBoundary_removeIOBox,METH_VARARGS,oaPRBoundary_removeIOBox_doc},
    {"setCoreBoxSpec",(PyCFunction)oaPRBoundary_setCoreBoxSpec,METH_VARARGS,oaPRBoundary_setCoreBoxSpec_doc},
    {"setIOBox",(PyCFunction)oaPRBoundary_setIOBox,METH_VARARGS,oaPRBoundary_setIOBox_doc},
    {"isNull",(PyCFunction)oaPRBoundary_tp_isNull,METH_VARARGS,oaPRBoundary_isNull_doc},
    {"assign",(PyCFunction)oaPRBoundary_tp_assign,METH_VARARGS,oaPRBoundary_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaPRBoundary_doc[] = 
"Class: oaPRBoundary\n"
"  The oaPRBoundary class is used as the boundary of a block for place-and-route applications. In a top-down design flow, it is commonly passed down to constrain the area in which the block's contents are placed. Any shape or instance created for the block should be enclosed within the PRBoundary. In a bottom-up design flow, a PRBoundary is used to indicate the primary extent of the block's contents.\n"
"  For cell placement that is directed by sites in oaRows, the PRBoundary determines the aspect of the cell that must align with the site. For placement near a PlacementBlockage, it is the PRBoundary that is excluded from the blockage.\n"
"  Some uses of the PRBoundary will be superseded by an oaSnapBoundary for non-rectangular PRBoundaries. The SnapBoundary will provide an unambiguous lower-left corner that will control the exact placement location.\n"
"  PRBoundaries for blocks and chips may have an associated oaCoreBoxSpec . This defines a rectangular grid of sites within the PRBoundary where cells may be placed. It can also have an IO box specified, which together with the outline of the core box indicates the area for the IO cells.\n"
"Constructors:\n"
"  Paramegers: (oaPRBoundary)\n"
"    Calls: (const oaPRBoundary&)\n"
"    Signature: oaPRBoundary||cref-oaPRBoundary,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaPRBoundary_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaPRBoundary",
    sizeof(PyoaPRBoundaryObject),
    0,
    (destructor)oaPRBoundary_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaPRBoundary_tp_compare,	/* tp_compare */
    (reprfunc)oaPRBoundary_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaPRBoundary_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaPRBoundary_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaBoundary_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaPRBoundary_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaPRBoundary_static_create_doc[] = 
"Class: oaPRBoundary, Function: create\n"
"  Paramegers: (oaBlock,oaPointArray)\n"
"    Calls: oaPRBoundary* create(oaBlock* block,const oaPointArray& points)\n"
"    Signature: create|ptr-oaPRBoundary|ptr-oaBlock,cref-oaPointArray,cptr-oaString,\n"
"    This function creates a new PR boundary object in the specified block with the specified attributes. The specified pointArray is checked to verify that there are at least three points and no collinear or coincident points. This function throws an exception if there is already a PR boundary exists in the specified block.\n"
"    Note: The order of the points actually set on the oaPRBoundary is not guaranteed to be the same as the order of points passed to the create() function. Consequently, the order of points returned by a subsequent oaPRBoundary::getPoints() may be different from the order of points specified in points .\n"
"    block\n"
"    The block in which to create the new oaPRBoundary object\n"
"    points\n"
"    The number of points in the new oaPRBoundary object\n"
"    edgeNames\n"
"    The boundary edge names; if omitted, the edges are automatically named, using the form EDGE_%d, where d starts at zero and increments by one\n"
"    A pointer to an oaPRBoundary object\n"
"    oacBoundaryHasExtraPoints\n"
"    oacBoundaryTooFewPoints\n"
"    oacPRBoundaryExists\n"
"  Paramegers: (oaBlock,oaPointArray,[oaString])\n"
"    Calls: oaPRBoundary* create(oaBlock* block,const oaPointArray& points,const oaString* edgeNames)\n"
"    Signature: create|ptr-oaPRBoundary|ptr-oaBlock,cref-oaPointArray,cptr-oaString,\n"
"    This function creates a new PR boundary object in the specified block with the specified attributes. The specified pointArray is checked to verify that there are at least three points and no collinear or coincident points. This function throws an exception if there is already a PR boundary exists in the specified block.\n"
"    Note: The order of the points actually set on the oaPRBoundary is not guaranteed to be the same as the order of points passed to the create() function. Consequently, the order of points returned by a subsequent oaPRBoundary::getPoints() may be different from the order of points specified in points .\n"
"    block\n"
"    The block in which to create the new oaPRBoundary object\n"
"    points\n"
"    The number of points in the new oaPRBoundary object\n"
"    edgeNames\n"
"    The boundary edge names; if omitted, the edges are automatically named, using the form EDGE_%d, where d starts at zero and increments by one\n"
"    A pointer to an oaPRBoundary object\n"
"    oacBoundaryHasExtraPoints\n"
"    oacBoundaryTooFewPoints\n"
"    oacPRBoundaryExists\n"
;

static PyObject*
oaPRBoundary_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaBlock,oaPointArray)
    {
        PyParamoaBlock p1;
        PyParamoaPointArray p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaPointArray_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaPRBoundaryp result= (oaPRBoundary::create(p1.Data(),p2.Data()));
            return PyoaPRBoundary_FromoaPRBoundary(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaPointArray,[oaString])
    {
        PyParamoaBlock p1;
        PyParamoaPointArray p2;
        PyParamoaString_Array p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaPointArray_Convert,&p2,
              &PyoaString_Array_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!(p2.Data().getNumElements()==p3.Len())) {
                PyErr_SetString(PyExc_TypeError,
                    "number of edges does not match number of points");
                return NULL;
            }
            oaPRBoundaryp result= (oaPRBoundary::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaPRBoundary_FromoaPRBoundary(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaPRBoundary, function: create, Choices are:\n"
        "    (oaBlock,oaPointArray)\n"
        "    (oaBlock,oaPointArray,[oaString])\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPRBoundary_static_find_doc[] = 
"Class: oaPRBoundary, Function: find\n"
"  Paramegers: (oaBlock)\n"
"    Calls: oaPRBoundary* find(const oaBlock* block)\n"
"    Signature: find|ptr-oaPRBoundary|cptr-oaBlock,\n"
"    This function searches the specified block looking for a PRBoundary. If found, the boundary is returned. Otherwise, NULL is returned.\n"
"    block\n"
"    the block to search in.\n"
;

static PyObject*
oaPRBoundary_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBlock_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaPRBoundaryp result= (oaPRBoundary::find(p1.Data()));
        return PyoaPRBoundary_FromoaPRBoundary(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaPRBoundary_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaPRBoundary_static_create,METH_VARARGS,oaPRBoundary_static_create_doc},
    {"static_find",(PyCFunction)oaPRBoundary_static_find,METH_VARARGS,oaPRBoundary_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaPRBoundary_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaPRBoundary_Type)<0) {
      printf("** PyType_Ready failed for: oaPRBoundary\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaPRBoundary",
           (PyObject*)(&PyoaPRBoundary_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaPRBoundary\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaPRBoundary_Type.tp_dict;
    for(method=oaPRBoundary_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaPackedData
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaPackedData_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaPackedData_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaPackedDataObject* self = (PyoaPackedDataObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaPackedData, Choices are:\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaPackedData_tp_dealloc(PyoaPackedDataObject* self)
{
    if (!self->borrow) {
        delete (oaPackedData*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaPackedData_tp_repr(PyObject *ob)
{
    PyParamoaPackedData value;
    int convert_status=PyoaPackedData_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[34];
    sprintf(buffer,"<oaPackedData::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaPackedData_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaPackedData v1;
    PyParamoaPackedData v2;
    int convert_status1=PyoaPackedData_Convert(ob1,&v1);
    int convert_status2=PyoaPackedData_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaPackedData_Convert(PyObject* ob,PyParamoaPackedData* result)
{
    if (ob == NULL) return 1;
    if (PyoaPackedData_Check(ob)) {
        result->SetData( (oaPackedData*) ((PyoaPackedDataObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaPackedData Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaPackedData_FromoaPackedData(oaPackedData* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaPackedData_Type.tp_alloc(&PyoaPackedData_Type,0);
        if (bself == NULL) return bself;
        PyoaPackedDataObject* self = (PyoaPackedDataObject*)bself;
        self->value = (oaBasePackedData*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaPackedData_getPackedBoxSize_doc[] = 
"Class: oaPackedData, Function: getPackedBoxSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaUInt4 getPackedBoxSize(oaUInt4 loc) const\n"
"    Signature: getPackedBoxSize|simple-oaUInt4|simple-oaUInt4,\n"
"    This function returns the number of bytes used to store a packed oaBox object at the specified location. It is assumed that this location actually contains the indicated object type.\n"
;

static PyObject*
oaPackedData_getPackedBoxSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaUInt4 result= (data.DataCall()->getPackedBoxSize(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_getPackedDoubleSize_doc[] = 
"Class: oaPackedData, Function: getPackedDoubleSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaUInt4 getPackedDoubleSize(oaUInt4 loc) const\n"
"    Signature: getPackedDoubleSize|simple-oaUInt4|simple-oaUInt4,\n"
"    This function returns the number of bytes used to store a packed oaDouble object at the specified location. It is assumed that this location actually contains the indicated object type.\n"
;

static PyObject*
oaPackedData_getPackedDoubleSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaUInt4 result= (data.DataCall()->getPackedDoubleSize(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_getPackedFloatSize_doc[] = 
"Class: oaPackedData, Function: getPackedFloatSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaUInt4 getPackedFloatSize(oaUInt4 loc) const\n"
"    Signature: getPackedFloatSize|simple-oaUInt4|simple-oaUInt4,\n"
"    This function returns the number of bytes used to store a packed oaFloat object at the specified location. It is assumed that this location actually contains the indicated object type.\n"
;

static PyObject*
oaPackedData_getPackedFloatSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaUInt4 result= (data.DataCall()->getPackedFloatSize(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_getPackedInt4Size_doc[] = 
"Class: oaPackedData, Function: getPackedInt4Size\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaUInt4 getPackedInt4Size(oaUInt4 loc) const\n"
"    Signature: getPackedInt4Size|simple-oaUInt4|simple-oaUInt4,\n"
"    This function returns the number of bytes used to store a packed 4-byte integer object at the specified location. It is assumed that this location actually contains the indicated object type.\n"
;

static PyObject*
oaPackedData_getPackedInt4Size(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaUInt4 result= (data.DataCall()->getPackedInt4Size(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_getPackedInt8Size_doc[] = 
"Class: oaPackedData, Function: getPackedInt8Size\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaUInt4 getPackedInt8Size(oaUInt4 loc) const\n"
"    Signature: getPackedInt8Size|simple-oaUInt4|simple-oaUInt4,\n"
"    This function returns the number of bytes used to store a packed 8-byte integer object at the specified location. It is assumed that this location actually contains the indicated object type.\n"
;

static PyObject*
oaPackedData_getPackedInt8Size(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaUInt4 result= (data.DataCall()->getPackedInt8Size(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_getPackedPointArraySize_doc[] = 
"Class: oaPackedData, Function: getPackedPointArraySize\n"
"  Paramegers: (oaUInt4,oaUInt4,oaBoolean)\n"
"    Calls: oaUInt4 getPackedPointArraySize(oaUInt4 loc,oaUInt4 numPoints,oaBoolean isOrtho) const\n"
"    Signature: getPackedPointArraySize|simple-oaUInt4|simple-oaUInt4,simple-oaUInt4,simple-oaBoolean,\n"
"    This function returns the number of bytes used to store a packed oaPoint array object at the specified location. It is assumed that this location actually contains the indicated object type.\n"
;

static PyObject*
oaPackedData_getPackedPointArraySize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    PyParamoaBoolean p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2,
          &PyoaBoolean_Convert,&p3)) {
        oaUInt4 result= (data.DataCall()->getPackedPointArraySize(p1.Data(),p2.Data(),p3.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_getPackedPointSize_doc[] = 
"Class: oaPackedData, Function: getPackedPointSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaUInt4 getPackedPointSize(oaUInt4 loc) const\n"
"    Signature: getPackedPointSize|simple-oaUInt4|simple-oaUInt4,\n"
"    This function returns the number of bytes used to store a packed oaPoint object at the specified location. It is assumed that this location actually contains the indicated object type.\n"
;

static PyObject*
oaPackedData_getPackedPointSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaUInt4 result= (data.DataCall()->getPackedPointSize(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_getPackedTimeSize_doc[] = 
"Class: oaPackedData, Function: getPackedTimeSize\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaUInt4 getPackedTimeSize(oaUInt4 loc) const\n"
"    Signature: getPackedTimeSize|simple-oaUInt4|simple-oaUInt4,\n"
"    This function returns the number of bytes used to store a packed oaTime object at the specified location. It is assumed that this location actually contains the indicated object type.\n"
;

static PyObject*
oaPackedData_getPackedTimeSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaUInt4 result= (data.DataCall()->getPackedTimeSize(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readBox_doc[] = 
"Class: oaPackedData, Function: readBox\n"
"  Paramegers: (oaUInt4,oaBox)\n"
"    Calls: void readBox(oaUInt4& loc,oaBox& val) const\n"
"    Signature: readBox|void-void|ref-oaUInt4,ref-oaBox,\n"
"    BrowseData: 0,oaUInt4,oaBox\n"
"    This function reads an oaBox value from the packed data at the specified location. The location index is then incremented past the data that is read. Byte-swapping is performed if the swap-flag is set.\n"
;

static PyObject*
oaPackedData_readBox(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaBox p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaBox_Convert,&p2)) {
        data.DataCall()->readBox(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readBoxArray_doc[] = 
"Class: oaPackedData, Function: readBoxArray\n"
"  Paramegers: (oaUInt4,[oaBox])\n"
"    Calls: void readBoxArray(oaUInt4& loc,oaBox* val) const\n"
"    Signature: readBoxArray|void-void|ref-oaUInt4,simple-oaUInt4,ptr-oaBox,\n"
"    This function reads an oaBox array from the packed data at the specified location. The location index is then incremented past the data that is read. Byte-swapping is performed if the swap-flag is set.\n"
;

static PyObject*
oaPackedData_readBoxArray(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaBox_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaBox_Array_Convert,&p2)) {
        data.DataCall()->readBoxArray(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readByte_doc[] = 
"Class: oaPackedData, Function: readByte\n"
"  Paramegers: (oaUInt4,oaByte)\n"
"    Calls: void readByte(oaUInt4& loc,oaByte& val) const\n"
"    Signature: readByte|void-void|ref-oaUInt4,ref-oaByte,\n"
"    BrowseData: 0,oaUInt4,oaByte\n"
"    This function reads a byte from the packed data at the specified location. The location index is then incremented past the data that is read.\n"
;

static PyObject*
oaPackedData_readByte(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaByte p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaByte_Convert,&p2)) {
        data.DataCall()->readByte(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readByteArray_doc[] = 
"Class: oaPackedData, Function: readByteArray\n"
"  Paramegers: (oaUInt4,[oaByte])\n"
"    Calls: void readByteArray(oaUInt4& loc,oaByte* val) const\n"
"    Signature: readByteArray|void-void|ref-oaUInt4,simple-oaUInt4,ptr-oaByte,\n"
"    This function reads a byte array from the packed data at the specified location. The location index is then incremented past the data that is read. This operation is 4-byte aligned.\n"
;

static PyObject*
oaPackedData_readByteArray(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        data.DataCall()->readByteArray(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readBytes_doc[] = 
"Class: oaPackedData, Function: readBytes\n"
"  Paramegers: (oaUInt4,[oaByte])\n"
"    Calls: void readBytes(oaUInt4& loc,oaByte* val) const\n"
"    Signature: readBytes|void-void|ref-oaUInt4,simple-oaUInt4,ptr-oaByte,\n"
"    This function reads a byte array from the packed data at the specified location. The location index is then incremented past the data that is read.\n"
;

static PyObject*
oaPackedData_readBytes(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        data.DataCall()->readBytes(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readDouble_doc[] = 
"Class: oaPackedData, Function: readDouble\n"
"  Paramegers: (oaUInt4,oaDouble)\n"
"    Calls: void readDouble(oaUInt4& loc,oaDouble& val) const\n"
"    Signature: readDouble|void-void|ref-oaUInt4,ref-oaDouble,\n"
"    BrowseData: 0,oaUInt4,oaDouble\n"
"    This function reads an oaDouble value from the packed data at the specified location. The location index is then incremented past the data that is read. Byte-swapping is performed if the swap-flag is set.\n"
;

static PyObject*
oaPackedData_readDouble(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaDouble p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaDouble_Convert,&p2)) {
        data.DataCall()->readDouble(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readDoubleArray_doc[] = 
"Class: oaPackedData, Function: readDoubleArray\n"
"  Paramegers: (oaUInt4,[oaDouble])\n"
"    Calls: void readDoubleArray(oaUInt4& loc,oaDouble* val) const\n"
"    Signature: readDoubleArray|void-void|ref-oaUInt4,simple-oaUInt4,ptr-oaDouble,\n"
"    This function reads an oaDouble array from the packed data at the specified location. The location index is then incremented past the data that is read. Byte-swapping is performed if the swap-flag is set.\n"
;

static PyObject*
oaPackedData_readDoubleArray(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaDouble_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaDouble_Array_Convert,&p2)) {
        data.DataCall()->readDoubleArray(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readFloat_doc[] = 
"Class: oaPackedData, Function: readFloat\n"
"  Paramegers: (oaUInt4,oaFloat)\n"
"    Calls: void readFloat(oaUInt4& loc,oaFloat& val) const\n"
"    Signature: readFloat|void-void|ref-oaUInt4,ref-oaFloat,\n"
"    BrowseData: 0,oaUInt4,oaFloat\n"
"    This function reads an oaFloat value from the packed data at the specified location. The location index is then incremented past the data that is read. Byte-swapping is performed if the swap-flag is set.\n"
;

static PyObject*
oaPackedData_readFloat(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaFloat p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaFloat_Convert,&p2)) {
        data.DataCall()->readFloat(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readFloatArray_doc[] = 
"Class: oaPackedData, Function: readFloatArray\n"
"  Paramegers: (oaUInt4,[oaFloat])\n"
"    Calls: void readFloatArray(oaUInt4& loc,oaFloat* val) const\n"
"    Signature: readFloatArray|void-void|ref-oaUInt4,simple-oaUInt4,ptr-oaFloat,\n"
"    This function reads an oaFloat array from the packed data at the specified location. The location index is then incremented past the data that is read. Byte-swapping is performed if the swap-flag is set.\n"
;

static PyObject*
oaPackedData_readFloatArray(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaFloat_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaFloat_Array_Convert,&p2)) {
        data.DataCall()->readFloatArray(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readInt2_doc[] = 
"Class: oaPackedData, Function: readInt2\n"
"  Paramegers: (oaUInt4,oaInt2)\n"
"    Calls: void readInt2(oaUInt4& loc,oaInt2& val) const\n"
"    Signature: readInt2|void-void|ref-oaUInt4,ref-oaInt2,\n"
"    BrowseData: 0,oaUInt4,oaInt2\n"
"    This function reads an oaInt2 value from the packed data at the specified location. The location index is then incremented past the data that is read. Byte-swapping is performed if the swap-flag is set.\n"
;

static PyObject*
oaPackedData_readInt2(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaInt2 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaInt2_Convert,&p2)) {
        data.DataCall()->readInt2(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readInt2Array_doc[] = 
"Class: oaPackedData, Function: readInt2Array\n"
"  Paramegers: (oaUInt4,[oaInt2])\n"
"    Calls: void readInt2Array(oaUInt4& loc,oaInt2* val) const\n"
"    Signature: readInt2Array|void-void|ref-oaUInt4,simple-oaUInt4,ptr-oaInt2,\n"
"    This function reads an oaInt2 array from the packed data at the specified location. The location index is then incremented past the data that is read. Byte-swapping is performed if the swap-flag is set. This operation is 4-byte aligned.\n"
;

static PyObject*
oaPackedData_readInt2Array(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaInt2_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaInt2_Array_Convert,&p2)) {
        data.DataCall()->readInt2Array(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readInt4_doc[] = 
"Class: oaPackedData, Function: readInt4\n"
"  Paramegers: (oaUInt4,oaInt4)\n"
"    Calls: void readInt4(oaUInt4& loc,oaInt4& val) const\n"
"    Signature: readInt4|void-void|ref-oaUInt4,ref-oaInt4,\n"
"    BrowseData: 0,oaUInt4,oaInt4\n"
"    This function reads an oaInt4 value from the packed data at the specified location. The location index is then incremented past the data that is read. Byte-swapping is performed if the swap-flag is set.\n"
;

static PyObject*
oaPackedData_readInt4(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaInt4_Convert,&p2)) {
        data.DataCall()->readInt4(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readInt4Array_doc[] = 
"Class: oaPackedData, Function: readInt4Array\n"
"  Paramegers: (oaUInt4,[oaInt4])\n"
"    Calls: void readInt4Array(oaUInt4& loc,oaInt4* val) const\n"
"    Signature: readInt4Array|void-void|ref-oaUInt4,simple-oaUInt4,ptr-oaInt4,\n"
"    This function reads an oaInt4 array from the packed data at the specified location. The location index is then incremented past the data that is read. Byte-swapping is performed if the swap-flag is set.\n"
;

static PyObject*
oaPackedData_readInt4Array(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaInt4_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaInt4_Array_Convert,&p2)) {
        data.DataCall()->readInt4Array(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readInt8_doc[] = 
"Class: oaPackedData, Function: readInt8\n"
"  Paramegers: (oaUInt4,oaInt8)\n"
"    Calls: void readInt8(oaUInt4& loc,oaInt8& val) const\n"
"    Signature: readInt8|void-void|ref-oaUInt4,ref-oaInt8,\n"
"    BrowseData: 0,oaUInt4,oaInt8\n"
"    This function reads an oaInt8 value from the packed data at the specified location. The location index is aligned and then incremented past the data that is read. Byte-swapping is performed if the swap-flag is set.\n"
;

static PyObject*
oaPackedData_readInt8(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaInt8 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaInt8_Convert,&p2)) {
        data.DataCall()->readInt8(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readInt8Array_doc[] = 
"Class: oaPackedData, Function: readInt8Array\n"
"  Paramegers: (oaUInt4,[oaInt8])\n"
"    Calls: void readInt8Array(oaUInt4& loc,oaInt8* val) const\n"
"    Signature: readInt8Array|void-void|ref-oaUInt4,simple-oaUInt4,ptr-oaInt8,\n"
"    This function reads an oaInt8 array from the packed data at the specified location. The location index is then incremented past the data that is read. Byte-swapping is performed if the swap-flag is set.\n"
;

static PyObject*
oaPackedData_readInt8Array(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaInt8_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaInt8_Array_Convert,&p2)) {
        data.DataCall()->readInt8Array(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readPackedBox_doc[] = 
"Class: oaPackedData, Function: readPackedBox\n"
"  Paramegers: (oaUInt4,oaBox)\n"
"    Calls: void readPackedBox(oaUInt4& loc,oaBox& box) const\n"
"    Signature: readPackedBox|void-void|ref-oaUInt4,ref-oaBox,\n"
"    BrowseData: 0,oaUInt4,oaBox\n"
"    This function unpacks and reads out an oaBox value at the specified location. The location index is then incremented past the data that is written.\n"
"    oacCorruptedDatabase\n"
;

static PyObject*
oaPackedData_readPackedBox(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaBox p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaBox_Convert,&p2)) {
        data.DataCall()->readPackedBox(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readPackedDouble_doc[] = 
"Class: oaPackedData, Function: readPackedDouble\n"
"  Paramegers: (oaUInt4,oaDouble)\n"
"    Calls: void readPackedDouble(oaUInt4& loc,oaDouble& val) const\n"
"    Signature: readPackedDouble|void-void|ref-oaUInt4,ref-oaDouble,\n"
"    BrowseData: 0,oaUInt4,oaDouble\n"
"    This function unpacks and reads out an oaDouble value at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_readPackedDouble(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaDouble p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaDouble_Convert,&p2)) {
        data.DataCall()->readPackedDouble(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readPackedFloat_doc[] = 
"Class: oaPackedData, Function: readPackedFloat\n"
"  Paramegers: (oaUInt4,oaFloat)\n"
"    Calls: void readPackedFloat(oaUInt4& loc,oaFloat& val) const\n"
"    Signature: readPackedFloat|void-void|ref-oaUInt4,ref-oaFloat,\n"
"    BrowseData: 0,oaUInt4,oaFloat\n"
"    This function unpacks and reads out an oaFloat value at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_readPackedFloat(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaFloat p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaFloat_Convert,&p2)) {
        data.DataCall()->readPackedFloat(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readPackedInt4_doc[] = 
"Class: oaPackedData, Function: readPackedInt4\n"
"  Paramegers: (oaUInt4,oaInt4)\n"
"    Calls: void readPackedInt4(oaUInt4& loc,oaInt4& val) const\n"
"    Signature: readPackedInt4|void-void|ref-oaUInt4,ref-oaInt4,\n"
"    BrowseData: 0,oaUInt4,oaInt4\n"
"    This function unpacks and reads out an oaInt4 value at the specified location. The location index is then incremented past the data that is written.\n"
"    oacCorruptedDatabase\n"
;

static PyObject*
oaPackedData_readPackedInt4(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaInt4_Convert,&p2)) {
        data.DataCall()->readPackedInt4(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readPackedInt8_doc[] = 
"Class: oaPackedData, Function: readPackedInt8\n"
"  Paramegers: (oaUInt4,oaInt8)\n"
"    Calls: void readPackedInt8(oaUInt4& loc,oaInt8& val) const\n"
"    Signature: readPackedInt8|void-void|ref-oaUInt4,ref-oaInt8,\n"
"    BrowseData: 0,oaUInt4,oaInt8\n"
"    This function unpacks and reads out an oaInt8 value at the specified location. The location index is then incremented past the data that is written.\n"
"    oacCorruptedDatabase\n"
;

static PyObject*
oaPackedData_readPackedInt8(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaInt8 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaInt8_Convert,&p2)) {
        data.DataCall()->readPackedInt8(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readPackedPoint_doc[] = 
"Class: oaPackedData, Function: readPackedPoint\n"
"  Paramegers: (oaUInt4,oaPoint)\n"
"    Calls: void readPackedPoint(oaUInt4& loc,oaPoint& point) const\n"
"    Signature: readPackedPoint|void-void|ref-oaUInt4,ref-oaPoint,\n"
"    BrowseData: 0,oaUInt4,oaPoint\n"
"    This function unpacks and reads out an oaPoint value at the specified location. The location index is then incremented past the data that is written.\n"
"    oacCorruptedDatabase\n"
;

static PyObject*
oaPackedData_readPackedPoint(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaPoint p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaPoint_Convert,&p2)) {
        data.DataCall()->readPackedPoint(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readPackedPointArray_doc[] = 
"Class: oaPackedData, Function: readPackedPointArray\n"
"  Paramegers: (oaUInt4,oaPointArray,oaUInt4,oaBoolean,oaBoolean)\n"
"    Calls: void readPackedPointArray(oaUInt4& loc,oaPointArray& points,oaUInt4 numPoints,oaBoolean isOrthogonal,oaBoolean isVertFirst) const\n"
"    Signature: readPackedPointArray|void-void|ref-oaUInt4,ref-oaPointArray,simple-oaUInt4,simple-oaBoolean,simple-oaBoolean,\n"
"    This function unpacks and reads out an oaPointArray at the specified location. The location index is then incremented past the data that is written.\n"
"    oacCorruptedDatabase\n"
;

static PyObject*
oaPackedData_readPackedPointArray(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaPointArray p2;
    PyParamoaUInt4 p3;
    PyParamoaBoolean p4;
    PyParamoaBoolean p5;
    if (PyArg_ParseTuple(args,"O&O&O&O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaPointArray_Convert,&p2,
          &PyoaUInt4_Convert,&p3,
          &PyoaBoolean_Convert,&p4,
          &PyoaBoolean_Convert,&p5)) {
        data.DataCall()->readPackedPointArray(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readPackedTime_doc[] = 
"Class: oaPackedData, Function: readPackedTime\n"
"  Paramegers: (oaUInt4,oaTime)\n"
"    Calls: void readPackedTime(oaUInt4& loc,oaTime& val) const\n"
"    Signature: readPackedTime|void-void|ref-oaUInt4,ref-oaTime,\n"
"    BrowseData: 0,oaUInt4,oaTime\n"
"    This function unpacks and reads out an oaTime value at the specified location. The location index is then incremented past the data that is written.\n"
"    oacCorruptedDatabase\n"
;

static PyObject*
oaPackedData_readPackedTime(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaTime p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaTime_Convert,&p2)) {
        data.DataCall()->readPackedTime(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readPackedUInt4_doc[] = 
"Class: oaPackedData, Function: readPackedUInt4\n"
"  Paramegers: (oaUInt4,oaUInt4)\n"
"    Calls: void readPackedUInt4(oaUInt4& loc,oaUInt4& val) const\n"
"    Signature: readPackedUInt4|void-void|ref-oaUInt4,ref-oaUInt4,\n"
"    BrowseData: 0,oaUInt4,oaUInt4\n"
"    This function unpacks and reads out an oaUInt4 value at the specified location. The location index is then incremented past the data that is written.\n"
"    oacCorruptedDatabase\n"
;

static PyObject*
oaPackedData_readPackedUInt4(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2)) {
        data.DataCall()->readPackedUInt4(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readPackedUInt8_doc[] = 
"Class: oaPackedData, Function: readPackedUInt8\n"
"  Paramegers: (oaUInt4,oaUInt8)\n"
"    Calls: void readPackedUInt8(oaUInt4& loc,oaUInt8& val) const\n"
"    Signature: readPackedUInt8|void-void|ref-oaUInt4,ref-oaUInt8,\n"
"    BrowseData: 0,oaUInt4,oaUInt8\n"
"    This function unpacks and reads out an oaUInt8 value at the specified location. The location index is then incremented past the data that is written.\n"
"    oacCorruptedDatabase\n"
;

static PyObject*
oaPackedData_readPackedUInt8(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaUInt8 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt8_Convert,&p2)) {
        data.DataCall()->readPackedUInt8(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readPoint_doc[] = 
"Class: oaPackedData, Function: readPoint\n"
"  Paramegers: (oaUInt4,oaPoint)\n"
"    Calls: void readPoint(oaUInt4& loc,oaPoint& val) const\n"
"    Signature: readPoint|void-void|ref-oaUInt4,ref-oaPoint,\n"
"    BrowseData: 0,oaUInt4,oaPoint\n"
"    This function reads an oaPoint value from the packed data at the specified location. The location index is then incremented past the data that is read. Byte-swapping is performed if the swap-flag is set.\n"
;

static PyObject*
oaPackedData_readPoint(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaPoint p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaPoint_Convert,&p2)) {
        data.DataCall()->readPoint(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readPointArray_doc[] = 
"Class: oaPackedData, Function: readPointArray\n"
"  Paramegers: (oaUInt4,[oaPoint])\n"
"    Calls: void readPointArray(oaUInt4& loc,oaPoint* val) const\n"
"    Signature: readPointArray|void-void|ref-oaUInt4,simple-oaUInt4,ptr-oaPoint,\n"
"    This function reads an oaPoint array from the packed data at the specified location. The location index is then incremented past the data that is read. Byte-swapping is performed if the swap-flag is set.\n"
;

static PyObject*
oaPackedData_readPointArray(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaPoint_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaPoint_Array_Convert,&p2)) {
        data.DataCall()->readPointArray(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readString_doc[] = 
"Class: oaPackedData, Function: readString\n"
"  Paramegers: (oaUInt4,oaString)\n"
"    Calls: void readString(oaUInt4& loc,oaString& val) const\n"
"    Signature: readString|void-void|ref-oaUInt4,ref-oaString,\n"
"    BrowseData: 0,oaUInt4,oaString\n"
"    This function reads a string from the packed data at the specified location. The location index is then incremented past the data that is read.\n"
;

static PyObject*
oaPackedData_readString(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        data.DataCall()->readString(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readTime_doc[] = 
"Class: oaPackedData, Function: readTime\n"
"  Paramegers: (oaUInt4,oaTime)\n"
"    Calls: void readTime(oaUInt4& loc,oaTime& val) const\n"
"    Signature: readTime|void-void|ref-oaUInt4,ref-oaTime,\n"
"    BrowseData: 0,oaUInt4,oaTime\n"
"    This function reads an oaTime value from the packed data at the specified location. The location index is then incremented past the data that is read. Byte-swapping is performed if the swap-flag is set.\n"
;

static PyObject*
oaPackedData_readTime(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaTime p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaTime_Convert,&p2)) {
        data.DataCall()->readTime(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readUInt2_doc[] = 
"Class: oaPackedData, Function: readUInt2\n"
"  Paramegers: (oaUInt4,oaUInt2)\n"
"    Calls: void readUInt2(oaUInt4& loc,oaUInt2& val) const\n"
"    Signature: readUInt2|void-void|ref-oaUInt4,ref-oaUInt2,\n"
"    BrowseData: 0,oaUInt4,oaUInt2\n"
"    This function reads an oaUInt2 value from the packed data at the specified location. The location index is then incremented past the data that is read. Byte-swapping is performed if the swap-flag is set.\n"
;

static PyObject*
oaPackedData_readUInt2(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaUInt2 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt2_Convert,&p2)) {
        data.DataCall()->readUInt2(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readUInt2Array_doc[] = 
"Class: oaPackedData, Function: readUInt2Array\n"
"  Paramegers: (oaUInt4,[oaUInt2])\n"
"    Calls: void readUInt2Array(oaUInt4& loc,oaUInt2* val) const\n"
"    Signature: readUInt2Array|void-void|ref-oaUInt4,simple-oaUInt4,ptr-oaUInt2,\n"
"    This function reads an oaUInt2 array from the packed data at the specified location. The location index is then incremented past the data that is read. Byte-swapping is performed if the swap-flag is set. This operation is 4-byte aligned.\n"
;

static PyObject*
oaPackedData_readUInt2Array(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaUInt2_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt2_Array_Convert,&p2)) {
        data.DataCall()->readUInt2Array(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readUInt4_doc[] = 
"Class: oaPackedData, Function: readUInt4\n"
"  Paramegers: (oaUInt4,oaUInt4)\n"
"    Calls: void readUInt4(oaUInt4& loc,oaUInt4& val) const\n"
"    Signature: readUInt4|void-void|ref-oaUInt4,ref-oaUInt4,\n"
"    BrowseData: 0,oaUInt4,oaUInt4\n"
"    This function reads an oaUInt4 value from the packed data at the specified location. The location index is then incremented past the data that is read. Byte-swapping is performed if the swap-flag is set.\n"
;

static PyObject*
oaPackedData_readUInt4(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2)) {
        data.DataCall()->readUInt4(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readUInt4Array_doc[] = 
"Class: oaPackedData, Function: readUInt4Array\n"
"  Paramegers: (oaUInt4,[oaUInt4])\n"
"    Calls: void readUInt4Array(oaUInt4& loc,oaUInt4* val) const\n"
"    Signature: readUInt4Array|void-void|ref-oaUInt4,simple-oaUInt4,ptr-oaUInt4,\n"
"    This function reads an oaUInt4 array from the packed data at the specified location. The location index is then incremented past the data that is read. Byte-swapping is performed if the swap-flag is set.\n"
;

static PyObject*
oaPackedData_readUInt4Array(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaUInt4_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Array_Convert,&p2)) {
        data.DataCall()->readUInt4Array(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readUInt8_doc[] = 
"Class: oaPackedData, Function: readUInt8\n"
"  Paramegers: (oaUInt4,oaUInt8)\n"
"    Calls: void readUInt8(oaUInt4& loc,oaUInt8& val) const\n"
"    Signature: readUInt8|void-void|ref-oaUInt4,ref-oaUInt8,\n"
"    BrowseData: 0,oaUInt4,oaUInt8\n"
"    This function reads an oaUInt8 value from the packed data at the specified location. The location index is aligned and then incremented past the data that is read. Byte-swapping is performed if the swap-flag is set.\n"
;

static PyObject*
oaPackedData_readUInt8(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaUInt8 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt8_Convert,&p2)) {
        data.DataCall()->readUInt8(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readUInt8Array_doc[] = 
"Class: oaPackedData, Function: readUInt8Array\n"
"  Paramegers: (oaUInt4,[oaUInt8])\n"
"    Calls: void readUInt8Array(oaUInt4& loc,oaUInt8* val) const\n"
"    Signature: readUInt8Array|void-void|ref-oaUInt4,simple-oaUInt4,ptr-oaUInt8,\n"
"    This function reads an oaInt8 array from the packed data at the specified location. The location index is then incremented past the data that is read. Byte-swapping is performed if the swap-flag is set.\n"
;

static PyObject*
oaPackedData_readUInt8Array(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaUInt8_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt8_Array_Convert,&p2)) {
        data.DataCall()->readUInt8Array(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_readUnalignedUInt4_doc[] = 
"Class: oaPackedData, Function: readUnalignedUInt4\n"
"  Paramegers: (oaUInt4,oaUInt4)\n"
"    Calls: void readUnalignedUInt4(oaUInt4& loc,oaUInt4& val) const\n"
"    Signature: readUnalignedUInt4|void-void|ref-oaUInt4,ref-oaUInt4,\n"
"    BrowseData: 0,oaUInt4,oaUInt4\n"
"    This function reads an unaligned UInt4 from the packed data at the specified location. The location index is then incremented past the data that is read. Byte-swapping is performed if the swap-flag is set.\n"
;

static PyObject*
oaPackedData_readUnalignedUInt4(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2)) {
        data.DataCall()->readUnalignedUInt4(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_size_doc[] = 
"Class: oaPackedData, Function: size\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4& size()\n"
"    Signature: size|ref-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the reference of byte array size of this packed data.\n"
;

static PyObject*
oaPackedData_size(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4* result=&(data.DataCall()->size());
        return PyoaUInt4_FromoaUInt4(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_swap_doc[] = 
"Class: oaPackedData, Function: swap\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean& swap()\n"
"    Signature: swap|ref-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns the reference of the swap flag of this packed data.\n"
;

static PyObject*
oaPackedData_swap(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean* result=&(data.DataCall()->swap());
        return PyoaBoolean_FromoaBoolean(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writeBox_doc[] = 
"Class: oaPackedData, Function: writeBox\n"
"  Paramegers: (oaUInt4,oaBox)\n"
"    Calls: void writeBox(oaUInt4& loc,const oaBox& val) const\n"
"    Signature: writeBox|void-void|ref-oaUInt4,cref-oaBox,\n"
"    This function writes an oaBox to the packed data at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writeBox(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaBox p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaBox_Convert,&p2)) {
        data.DataCall()->writeBox(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writeBoxArray_doc[] = 
"Class: oaPackedData, Function: writeBoxArray\n"
"  Paramegers: (oaUInt4,[oaBox])\n"
"    Calls: void writeBoxArray(oaUInt4& loc,const oaBox* val) const\n"
"    Signature: writeBoxArray|void-void|ref-oaUInt4,simple-oaUInt4,cptr-oaBox,\n"
"    This function writes an oaBox array to the packed data at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writeBoxArray(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaBox_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaBox_Array_Convert,&p2)) {
        data.DataCall()->writeBoxArray(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writeByte_doc[] = 
"Class: oaPackedData, Function: writeByte\n"
"  Paramegers: (oaUInt4,oaByte)\n"
"    Calls: void writeByte(oaUInt4& loc,oaByte val) const\n"
"    Signature: writeByte|void-void|ref-oaUInt4,simple-oaByte,\n"
"    This function writes a byte to the packed data at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writeByte(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaByte p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaByte_Convert,&p2)) {
        data.DataCall()->writeByte(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writeByteArray_doc[] = 
"Class: oaPackedData, Function: writeByteArray\n"
"  Paramegers: (oaUInt4,[oaByte])\n"
"    Calls: void writeByteArray(oaUInt4& loc,const oaByte* val) const\n"
"    Signature: writeByteArray|void-void|ref-oaUInt4,simple-oaUInt4,cptr-oaByte,\n"
"    This function writes a byte array to the packed data at the specified location. The location index is then incremented past the data that is written. This operation is 4-byte aligned.\n"
;

static PyObject*
oaPackedData_writeByteArray(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        data.DataCall()->writeByteArray(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writeBytes_doc[] = 
"Class: oaPackedData, Function: writeBytes\n"
"  Paramegers: (oaUInt4,[oaByte])\n"
"    Calls: void writeBytes(oaUInt4& loc,const oaByte* val) const\n"
"    Signature: writeBytes|void-void|ref-oaUInt4,simple-oaUInt4,cptr-oaByte,\n"
"    This function writes a byte array to the packed data at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writeBytes(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        data.DataCall()->writeBytes(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writeDouble_doc[] = 
"Class: oaPackedData, Function: writeDouble\n"
"  Paramegers: (oaUInt4,oaDouble)\n"
"    Calls: void writeDouble(oaUInt4& loc,oaDouble val) const\n"
"    Signature: writeDouble|void-void|ref-oaUInt4,simple-oaDouble,\n"
"    This function writes an oaDouble value to the packed data at the specified location. The location index is aligned and then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writeDouble(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaDouble p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaDouble_Convert,&p2)) {
        data.DataCall()->writeDouble(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writeDoubleArray_doc[] = 
"Class: oaPackedData, Function: writeDoubleArray\n"
"  Paramegers: (oaUInt4,[oaDouble])\n"
"    Calls: void writeDoubleArray(oaUInt4& loc,const oaDouble* val) const\n"
"    Signature: writeDoubleArray|void-void|ref-oaUInt4,simple-oaUInt4,cptr-oaDouble,\n"
"    This function writes an oaDouble array to the packed data at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writeDoubleArray(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaDouble_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaDouble_Array_Convert,&p2)) {
        data.DataCall()->writeDoubleArray(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writeFloat_doc[] = 
"Class: oaPackedData, Function: writeFloat\n"
"  Paramegers: (oaUInt4,oaFloat)\n"
"    Calls: void writeFloat(oaUInt4& loc,oaFloat val) const\n"
"    Signature: writeFloat|void-void|ref-oaUInt4,simple-oaFloat,\n"
"    This function writes an oaFloat value to the packed data at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writeFloat(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaFloat p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaFloat_Convert,&p2)) {
        data.DataCall()->writeFloat(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writeFloatArray_doc[] = 
"Class: oaPackedData, Function: writeFloatArray\n"
"  Paramegers: (oaUInt4,[oaFloat])\n"
"    Calls: void writeFloatArray(oaUInt4& loc,const oaFloat* val) const\n"
"    Signature: writeFloatArray|void-void|ref-oaUInt4,simple-oaUInt4,cptr-oaFloat,\n"
"    This function writes an oaFloat array to the packed data at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writeFloatArray(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaFloat_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaFloat_Array_Convert,&p2)) {
        data.DataCall()->writeFloatArray(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writeInt2_doc[] = 
"Class: oaPackedData, Function: writeInt2\n"
"  Paramegers: (oaUInt4,oaInt2)\n"
"    Calls: void writeInt2(oaUInt4& loc,oaInt2 val) const\n"
"    Signature: writeInt2|void-void|ref-oaUInt4,simple-oaInt2,\n"
"    This function writes an oaInt2 value to the packed data at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writeInt2(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaInt2 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaInt2_Convert,&p2)) {
        data.DataCall()->writeInt2(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writeInt2Array_doc[] = 
"Class: oaPackedData, Function: writeInt2Array\n"
"  Paramegers: (oaUInt4,[oaInt2])\n"
"    Calls: void writeInt2Array(oaUInt4& loc,const oaInt2* val) const\n"
"    Signature: writeInt2Array|void-void|ref-oaUInt4,simple-oaUInt4,cptr-oaInt2,\n"
"    This function writes an oaInt2 array to the packed data at the specified location. The location index is then incremented past the data that is written. This operation is 4-byte aligned.\n"
;

static PyObject*
oaPackedData_writeInt2Array(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaInt2_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaInt2_Array_Convert,&p2)) {
        data.DataCall()->writeInt2Array(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writeInt4_doc[] = 
"Class: oaPackedData, Function: writeInt4\n"
"  Paramegers: (oaUInt4,oaInt4)\n"
"    Calls: void writeInt4(oaUInt4& loc,oaInt4 val) const\n"
"    Signature: writeInt4|void-void|ref-oaUInt4,simple-oaInt4,\n"
"    This function writes an oaInt4 value to the packed data at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writeInt4(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaInt4_Convert,&p2)) {
        data.DataCall()->writeInt4(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writeInt4Array_doc[] = 
"Class: oaPackedData, Function: writeInt4Array\n"
"  Paramegers: (oaUInt4,[oaInt4])\n"
"    Calls: void writeInt4Array(oaUInt4& loc,const oaInt4* val) const\n"
"    Signature: writeInt4Array|void-void|ref-oaUInt4,simple-oaUInt4,cptr-oaInt4,\n"
"    This function writes an oaInt4 array to the packed data at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writeInt4Array(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaInt4_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaInt4_Array_Convert,&p2)) {
        data.DataCall()->writeInt4Array(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writeInt8_doc[] = 
"Class: oaPackedData, Function: writeInt8\n"
"  Paramegers: (oaUInt4,oaInt8)\n"
"    Calls: void writeInt8(oaUInt4& loc,oaInt8 val) const\n"
"    Signature: writeInt8|void-void|ref-oaUInt4,simple-oaInt8,\n"
"    This function writes an oaInt8 value to the packed data at the specified location. The location index is aligned and then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writeInt8(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaInt8 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaInt8_Convert,&p2)) {
        data.DataCall()->writeInt8(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writeInt8Array_doc[] = 
"Class: oaPackedData, Function: writeInt8Array\n"
"  Paramegers: (oaUInt4,[oaInt8])\n"
"    Calls: void writeInt8Array(oaUInt4& loc,const oaInt8* val) const\n"
"    Signature: writeInt8Array|void-void|ref-oaUInt4,simple-oaUInt4,cptr-oaInt8,\n"
"    This function writes an oaInt8 array to the packed data at the specified location. The location index is then incremented past the array that is written. All array writes are 4-byte aligned.\n"
;

static PyObject*
oaPackedData_writeInt8Array(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaInt8_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaInt8_Array_Convert,&p2)) {
        data.DataCall()->writeInt8Array(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writePackedBox_doc[] = 
"Class: oaPackedData, Function: writePackedBox\n"
"  Paramegers: (oaUInt4,oaBox)\n"
"    Calls: void writePackedBox(oaUInt4& loc,const oaBox& box) const\n"
"    Signature: writePackedBox|void-void|ref-oaUInt4,cref-oaBox,\n"
"    This function packs and writes an oaBox value at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writePackedBox(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaBox p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaBox_Convert,&p2)) {
        data.DataCall()->writePackedBox(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writePackedDouble_doc[] = 
"Class: oaPackedData, Function: writePackedDouble\n"
"  Paramegers: (oaUInt4,oaDouble)\n"
"    Calls: void writePackedDouble(oaUInt4& loc,oaDouble val) const\n"
"    Signature: writePackedDouble|void-void|ref-oaUInt4,simple-oaDouble,\n"
"    This function packs and writes an oaDouble value at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writePackedDouble(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaDouble p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaDouble_Convert,&p2)) {
        data.DataCall()->writePackedDouble(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writePackedFloat_doc[] = 
"Class: oaPackedData, Function: writePackedFloat\n"
"  Paramegers: (oaUInt4,oaFloat)\n"
"    Calls: void writePackedFloat(oaUInt4& loc,oaFloat val) const\n"
"    Signature: writePackedFloat|void-void|ref-oaUInt4,simple-oaFloat,\n"
"    This function packs and writes an oaFloat value at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writePackedFloat(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaFloat p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaFloat_Convert,&p2)) {
        data.DataCall()->writePackedFloat(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writePackedInt4_doc[] = 
"Class: oaPackedData, Function: writePackedInt4\n"
"  Paramegers: (oaUInt4,oaInt4)\n"
"    Calls: void writePackedInt4(oaUInt4& loc,oaInt4 val) const\n"
"    Signature: writePackedInt4|void-void|ref-oaUInt4,simple-oaInt4,\n"
"    This function packs and writes an oaInt4 value at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writePackedInt4(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaInt4_Convert,&p2)) {
        data.DataCall()->writePackedInt4(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writePackedInt8_doc[] = 
"Class: oaPackedData, Function: writePackedInt8\n"
"  Paramegers: (oaUInt4,oaInt8)\n"
"    Calls: void writePackedInt8(oaUInt4& loc,oaInt8 val) const\n"
"    Signature: writePackedInt8|void-void|ref-oaUInt4,simple-oaInt8,\n"
"    This function packs and writes an oaInt8 value at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writePackedInt8(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaInt8 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaInt8_Convert,&p2)) {
        data.DataCall()->writePackedInt8(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writePackedPoint_doc[] = 
"Class: oaPackedData, Function: writePackedPoint\n"
"  Paramegers: (oaUInt4,oaPoint)\n"
"    Calls: void writePackedPoint(oaUInt4& loc,const oaPoint& point) const\n"
"    Signature: writePackedPoint|void-void|ref-oaUInt4,cref-oaPoint,\n"
"    This function packs and writes an oaPoint value at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writePackedPoint(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaPoint p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaPoint_Convert,&p2)) {
        data.DataCall()->writePackedPoint(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writePackedPointArray_doc[] = 
"Class: oaPackedData, Function: writePackedPointArray\n"
"  Paramegers: (oaUInt4,oaPointArray,oaBoolean,oaBoolean)\n"
"    Calls: void writePackedPointArray(oaUInt4& loc,const oaPointArray& points,oaBoolean isOrtho,oaBoolean isVFst) const\n"
"    Signature: writePackedPointArray|void-void|ref-oaUInt4,cref-oaPointArray,simple-oaBoolean,simple-oaBoolean,\n"
"    This function packs and writes an oaPointArray at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writePackedPointArray(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaPointArray p2;
    PyParamoaBoolean p3;
    PyParamoaBoolean p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaPointArray_Convert,&p2,
          &PyoaBoolean_Convert,&p3,
          &PyoaBoolean_Convert,&p4)) {
        data.DataCall()->writePackedPointArray(p1.Data(),p2.Data(),p3.Data(),p4.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writePackedTime_doc[] = 
"Class: oaPackedData, Function: writePackedTime\n"
"  Paramegers: (oaUInt4,oaTime)\n"
"    Calls: void writePackedTime(oaUInt4& loc,oaTime val) const\n"
"    Signature: writePackedTime|void-void|ref-oaUInt4,simple-oaTime,\n"
"    This function packs and writes an oaTime value at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writePackedTime(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaTime p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaTime_Convert,&p2)) {
        data.DataCall()->writePackedTime(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writePackedUInt4_doc[] = 
"Class: oaPackedData, Function: writePackedUInt4\n"
"  Paramegers: (oaUInt4,oaUInt4)\n"
"    Calls: void writePackedUInt4(oaUInt4& loc,oaUInt4 val) const\n"
"    Signature: writePackedUInt4|void-void|ref-oaUInt4,simple-oaUInt4,\n"
"    This function packs and writes an oaUInt4 value at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writePackedUInt4(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2)) {
        data.DataCall()->writePackedUInt4(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writePackedUInt8_doc[] = 
"Class: oaPackedData, Function: writePackedUInt8\n"
"  Paramegers: (oaUInt4,oaUInt8)\n"
"    Calls: void writePackedUInt8(oaUInt4& loc,oaUInt8 val) const\n"
"    Signature: writePackedUInt8|void-void|ref-oaUInt4,simple-oaUInt8,\n"
"    This function packs and writes an oaUInt8 value at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writePackedUInt8(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaUInt8 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt8_Convert,&p2)) {
        data.DataCall()->writePackedUInt8(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writePoint_doc[] = 
"Class: oaPackedData, Function: writePoint\n"
"  Paramegers: (oaUInt4,oaPoint)\n"
"    Calls: void writePoint(oaUInt4& loc,const oaPoint& val) const\n"
"    Signature: writePoint|void-void|ref-oaUInt4,cref-oaPoint,\n"
"    This function writes an oaPoint to the packed data at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writePoint(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaPoint p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaPoint_Convert,&p2)) {
        data.DataCall()->writePoint(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writePointArray_doc[] = 
"Class: oaPackedData, Function: writePointArray\n"
"  Paramegers: (oaUInt4,[oaPoint])\n"
"    Calls: void writePointArray(oaUInt4& loc,const oaPoint* val) const\n"
"    Signature: writePointArray|void-void|ref-oaUInt4,simple-oaUInt4,cptr-oaPoint,\n"
"    This function writes an oaPoint array to the packed data at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writePointArray(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaPoint_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaPoint_Array_Convert,&p2)) {
        data.DataCall()->writePointArray(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writeString_doc[] = 
"Class: oaPackedData, Function: writeString\n"
"  Paramegers: (oaUInt4,oaString)\n"
"    Calls: void writeString(oaUInt4& loc,const oaString& val) const\n"
"    Signature: writeString|void-void|ref-oaUInt4,cref-oaString,\n"
"    This function writes a string to the packed data at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writeString(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaString p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaString_Convert,&p2)) {
        data.DataCall()->writeString(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writeTime_doc[] = 
"Class: oaPackedData, Function: writeTime\n"
"  Paramegers: (oaUInt4,oaTime)\n"
"    Calls: void writeTime(oaUInt4& loc,oaTime val) const\n"
"    Signature: writeTime|void-void|ref-oaUInt4,simple-oaTime,\n"
"    This function writes an oaTime value to the packed data at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writeTime(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaTime p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaTime_Convert,&p2)) {
        data.DataCall()->writeTime(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writeUInt2_doc[] = 
"Class: oaPackedData, Function: writeUInt2\n"
"  Paramegers: (oaUInt4,oaUInt2)\n"
"    Calls: void writeUInt2(oaUInt4& loc,oaUInt2 val) const\n"
"    Signature: writeUInt2|void-void|ref-oaUInt4,simple-oaUInt2,\n"
"    This function writes an oaUInt2 value to the packed data at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writeUInt2(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaUInt2 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt2_Convert,&p2)) {
        data.DataCall()->writeUInt2(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writeUInt2Array_doc[] = 
"Class: oaPackedData, Function: writeUInt2Array\n"
"  Paramegers: (oaUInt4,[oaUInt2])\n"
"    Calls: void writeUInt2Array(oaUInt4& loc,const oaUInt2* val) const\n"
"    Signature: writeUInt2Array|void-void|ref-oaUInt4,simple-oaUInt4,cptr-oaUInt2,\n"
"    This function writes an oaUInt2 array to the packed data at the specified location. The location index is then incremented past the data that is written. This operation is 4-byte aligned.\n"
;

static PyObject*
oaPackedData_writeUInt2Array(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaUInt2_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt2_Array_Convert,&p2)) {
        data.DataCall()->writeUInt2Array(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writeUInt4_doc[] = 
"Class: oaPackedData, Function: writeUInt4\n"
"  Paramegers: (oaUInt4,oaUInt4)\n"
"    Calls: void writeUInt4(oaUInt4& loc,oaUInt4 val) const\n"
"    Signature: writeUInt4|void-void|ref-oaUInt4,simple-oaUInt4,\n"
"    This function writes an oaUInt4 value to the packed data at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writeUInt4(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2)) {
        data.DataCall()->writeUInt4(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writeUInt4Array_doc[] = 
"Class: oaPackedData, Function: writeUInt4Array\n"
"  Paramegers: (oaUInt4,[oaUInt4])\n"
"    Calls: void writeUInt4Array(oaUInt4& loc,const oaUInt4* val) const\n"
"    Signature: writeUInt4Array|void-void|ref-oaUInt4,simple-oaUInt4,cptr-oaUInt4,\n"
"    This function writes an oaUInt4 array to the packed data at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writeUInt4Array(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaUInt4_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Array_Convert,&p2)) {
        data.DataCall()->writeUInt4Array(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writeUInt8_doc[] = 
"Class: oaPackedData, Function: writeUInt8\n"
"  Paramegers: (oaUInt4,oaUInt8)\n"
"    Calls: void writeUInt8(oaUInt4& loc,oaUInt8 val) const\n"
"    Signature: writeUInt8|void-void|ref-oaUInt4,simple-oaUInt8,\n"
"    This function writes an oaUInt8 value to the packed data at the specified location. The location index is aligned and then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writeUInt8(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaUInt8 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt8_Convert,&p2)) {
        data.DataCall()->writeUInt8(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writeUInt8Array_doc[] = 
"Class: oaPackedData, Function: writeUInt8Array\n"
"  Paramegers: (oaUInt4,[oaUInt8])\n"
"    Calls: void writeUInt8Array(oaUInt4& loc,const oaUInt8* val) const\n"
"    Signature: writeUInt8Array|void-void|ref-oaUInt4,simple-oaUInt4,cptr-oaUInt8,\n"
"    This function writes an oaUInt8 array to the packed data at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writeUInt8Array(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaUInt8_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt8_Array_Convert,&p2)) {
        data.DataCall()->writeUInt8Array(p1.Data(),p2.Len(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaPackedData_writeUnalignedUInt4_doc[] = 
"Class: oaPackedData, Function: writeUnalignedUInt4\n"
"  Paramegers: (oaUInt4,oaUInt4)\n"
"    Calls: void writeUnalignedUInt4(oaUInt4& loc,oaUInt4 val) const\n"
"    Signature: writeUnalignedUInt4|void-void|ref-oaUInt4,simple-oaUInt4,\n"
"    This function writes an unaligned UInt4 array to the packed data at the specified location. The location index is then incremented past the data that is written.\n"
;

static PyObject*
oaPackedData_writeUnalignedUInt4(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaPackedData data;
    int convert_status=PyoaPackedData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaPackedDataObject* self=(PyoaPackedDataObject*)ob;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2)) {
        data.DataCall()->writeUnalignedUInt4(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaPackedData_assign_doc[] = 
"Class: oaPackedData, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaPackedData_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaPackedData data;
  int convert_status=PyoaPackedData_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaPackedData p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaPackedData_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaPackedData_methodlist[] = {
    {"getPackedBoxSize",(PyCFunction)oaPackedData_getPackedBoxSize,METH_VARARGS,oaPackedData_getPackedBoxSize_doc},
    {"getPackedDoubleSize",(PyCFunction)oaPackedData_getPackedDoubleSize,METH_VARARGS,oaPackedData_getPackedDoubleSize_doc},
    {"getPackedFloatSize",(PyCFunction)oaPackedData_getPackedFloatSize,METH_VARARGS,oaPackedData_getPackedFloatSize_doc},
    {"getPackedInt4Size",(PyCFunction)oaPackedData_getPackedInt4Size,METH_VARARGS,oaPackedData_getPackedInt4Size_doc},
    {"getPackedInt8Size",(PyCFunction)oaPackedData_getPackedInt8Size,METH_VARARGS,oaPackedData_getPackedInt8Size_doc},
    {"getPackedPointArraySize",(PyCFunction)oaPackedData_getPackedPointArraySize,METH_VARARGS,oaPackedData_getPackedPointArraySize_doc},
    {"getPackedPointSize",(PyCFunction)oaPackedData_getPackedPointSize,METH_VARARGS,oaPackedData_getPackedPointSize_doc},
    {"getPackedTimeSize",(PyCFunction)oaPackedData_getPackedTimeSize,METH_VARARGS,oaPackedData_getPackedTimeSize_doc},
    {"readBox",(PyCFunction)oaPackedData_readBox,METH_VARARGS,oaPackedData_readBox_doc},
    {"readBoxArray",(PyCFunction)oaPackedData_readBoxArray,METH_VARARGS,oaPackedData_readBoxArray_doc},
    {"readByte",(PyCFunction)oaPackedData_readByte,METH_VARARGS,oaPackedData_readByte_doc},
    {"readByteArray",(PyCFunction)oaPackedData_readByteArray,METH_VARARGS,oaPackedData_readByteArray_doc},
    {"readBytes",(PyCFunction)oaPackedData_readBytes,METH_VARARGS,oaPackedData_readBytes_doc},
    {"readDouble",(PyCFunction)oaPackedData_readDouble,METH_VARARGS,oaPackedData_readDouble_doc},
    {"readDoubleArray",(PyCFunction)oaPackedData_readDoubleArray,METH_VARARGS,oaPackedData_readDoubleArray_doc},
    {"readFloat",(PyCFunction)oaPackedData_readFloat,METH_VARARGS,oaPackedData_readFloat_doc},
    {"readFloatArray",(PyCFunction)oaPackedData_readFloatArray,METH_VARARGS,oaPackedData_readFloatArray_doc},
    {"readInt2",(PyCFunction)oaPackedData_readInt2,METH_VARARGS,oaPackedData_readInt2_doc},
    {"readInt2Array",(PyCFunction)oaPackedData_readInt2Array,METH_VARARGS,oaPackedData_readInt2Array_doc},
    {"readInt4",(PyCFunction)oaPackedData_readInt4,METH_VARARGS,oaPackedData_readInt4_doc},
    {"readInt4Array",(PyCFunction)oaPackedData_readInt4Array,METH_VARARGS,oaPackedData_readInt4Array_doc},
    {"readInt8",(PyCFunction)oaPackedData_readInt8,METH_VARARGS,oaPackedData_readInt8_doc},
    {"readInt8Array",(PyCFunction)oaPackedData_readInt8Array,METH_VARARGS,oaPackedData_readInt8Array_doc},
    {"readPackedBox",(PyCFunction)oaPackedData_readPackedBox,METH_VARARGS,oaPackedData_readPackedBox_doc},
    {"readPackedDouble",(PyCFunction)oaPackedData_readPackedDouble,METH_VARARGS,oaPackedData_readPackedDouble_doc},
    {"readPackedFloat",(PyCFunction)oaPackedData_readPackedFloat,METH_VARARGS,oaPackedData_readPackedFloat_doc},
    {"readPackedInt4",(PyCFunction)oaPackedData_readPackedInt4,METH_VARARGS,oaPackedData_readPackedInt4_doc},
    {"readPackedInt8",(PyCFunction)oaPackedData_readPackedInt8,METH_VARARGS,oaPackedData_readPackedInt8_doc},
    {"readPackedPoint",(PyCFunction)oaPackedData_readPackedPoint,METH_VARARGS,oaPackedData_readPackedPoint_doc},
    {"readPackedPointArray",(PyCFunction)oaPackedData_readPackedPointArray,METH_VARARGS,oaPackedData_readPackedPointArray_doc},
    {"readPackedTime",(PyCFunction)oaPackedData_readPackedTime,METH_VARARGS,oaPackedData_readPackedTime_doc},
    {"readPackedUInt4",(PyCFunction)oaPackedData_readPackedUInt4,METH_VARARGS,oaPackedData_readPackedUInt4_doc},
    {"readPackedUInt8",(PyCFunction)oaPackedData_readPackedUInt8,METH_VARARGS,oaPackedData_readPackedUInt8_doc},
    {"readPoint",(PyCFunction)oaPackedData_readPoint,METH_VARARGS,oaPackedData_readPoint_doc},
    {"readPointArray",(PyCFunction)oaPackedData_readPointArray,METH_VARARGS,oaPackedData_readPointArray_doc},
    {"readString",(PyCFunction)oaPackedData_readString,METH_VARARGS,oaPackedData_readString_doc},
    {"readTime",(PyCFunction)oaPackedData_readTime,METH_VARARGS,oaPackedData_readTime_doc},
    {"readUInt2",(PyCFunction)oaPackedData_readUInt2,METH_VARARGS,oaPackedData_readUInt2_doc},
    {"readUInt2Array",(PyCFunction)oaPackedData_readUInt2Array,METH_VARARGS,oaPackedData_readUInt2Array_doc},
    {"readUInt4",(PyCFunction)oaPackedData_readUInt4,METH_VARARGS,oaPackedData_readUInt4_doc},
    {"readUInt4Array",(PyCFunction)oaPackedData_readUInt4Array,METH_VARARGS,oaPackedData_readUInt4Array_doc},
    {"readUInt8",(PyCFunction)oaPackedData_readUInt8,METH_VARARGS,oaPackedData_readUInt8_doc},
    {"readUInt8Array",(PyCFunction)oaPackedData_readUInt8Array,METH_VARARGS,oaPackedData_readUInt8Array_doc},
    {"readUnalignedUInt4",(PyCFunction)oaPackedData_readUnalignedUInt4,METH_VARARGS,oaPackedData_readUnalignedUInt4_doc},
    {"size",(PyCFunction)oaPackedData_size,METH_VARARGS,oaPackedData_size_doc},
    {"swap",(PyCFunction)oaPackedData_swap,METH_VARARGS,oaPackedData_swap_doc},
    {"writeBox",(PyCFunction)oaPackedData_writeBox,METH_VARARGS,oaPackedData_writeBox_doc},
    {"writeBoxArray",(PyCFunction)oaPackedData_writeBoxArray,METH_VARARGS,oaPackedData_writeBoxArray_doc},
    {"writeByte",(PyCFunction)oaPackedData_writeByte,METH_VARARGS,oaPackedData_writeByte_doc},
    {"writeByteArray",(PyCFunction)oaPackedData_writeByteArray,METH_VARARGS,oaPackedData_writeByteArray_doc},
    {"writeBytes",(PyCFunction)oaPackedData_writeBytes,METH_VARARGS,oaPackedData_writeBytes_doc},
    {"writeDouble",(PyCFunction)oaPackedData_writeDouble,METH_VARARGS,oaPackedData_writeDouble_doc},
    {"writeDoubleArray",(PyCFunction)oaPackedData_writeDoubleArray,METH_VARARGS,oaPackedData_writeDoubleArray_doc},
    {"writeFloat",(PyCFunction)oaPackedData_writeFloat,METH_VARARGS,oaPackedData_writeFloat_doc},
    {"writeFloatArray",(PyCFunction)oaPackedData_writeFloatArray,METH_VARARGS,oaPackedData_writeFloatArray_doc},
    {"writeInt2",(PyCFunction)oaPackedData_writeInt2,METH_VARARGS,oaPackedData_writeInt2_doc},
    {"writeInt2Array",(PyCFunction)oaPackedData_writeInt2Array,METH_VARARGS,oaPackedData_writeInt2Array_doc},
    {"writeInt4",(PyCFunction)oaPackedData_writeInt4,METH_VARARGS,oaPackedData_writeInt4_doc},
    {"writeInt4Array",(PyCFunction)oaPackedData_writeInt4Array,METH_VARARGS,oaPackedData_writeInt4Array_doc},
    {"writeInt8",(PyCFunction)oaPackedData_writeInt8,METH_VARARGS,oaPackedData_writeInt8_doc},
    {"writeInt8Array",(PyCFunction)oaPackedData_writeInt8Array,METH_VARARGS,oaPackedData_writeInt8Array_doc},
    {"writePackedBox",(PyCFunction)oaPackedData_writePackedBox,METH_VARARGS,oaPackedData_writePackedBox_doc},
    {"writePackedDouble",(PyCFunction)oaPackedData_writePackedDouble,METH_VARARGS,oaPackedData_writePackedDouble_doc},
    {"writePackedFloat",(PyCFunction)oaPackedData_writePackedFloat,METH_VARARGS,oaPackedData_writePackedFloat_doc},
    {"writePackedInt4",(PyCFunction)oaPackedData_writePackedInt4,METH_VARARGS,oaPackedData_writePackedInt4_doc},
    {"writePackedInt8",(PyCFunction)oaPackedData_writePackedInt8,METH_VARARGS,oaPackedData_writePackedInt8_doc},
    {"writePackedPoint",(PyCFunction)oaPackedData_writePackedPoint,METH_VARARGS,oaPackedData_writePackedPoint_doc},
    {"writePackedPointArray",(PyCFunction)oaPackedData_writePackedPointArray,METH_VARARGS,oaPackedData_writePackedPointArray_doc},
    {"writePackedTime",(PyCFunction)oaPackedData_writePackedTime,METH_VARARGS,oaPackedData_writePackedTime_doc},
    {"writePackedUInt4",(PyCFunction)oaPackedData_writePackedUInt4,METH_VARARGS,oaPackedData_writePackedUInt4_doc},
    {"writePackedUInt8",(PyCFunction)oaPackedData_writePackedUInt8,METH_VARARGS,oaPackedData_writePackedUInt8_doc},
    {"writePoint",(PyCFunction)oaPackedData_writePoint,METH_VARARGS,oaPackedData_writePoint_doc},
    {"writePointArray",(PyCFunction)oaPackedData_writePointArray,METH_VARARGS,oaPackedData_writePointArray_doc},
    {"writeString",(PyCFunction)oaPackedData_writeString,METH_VARARGS,oaPackedData_writeString_doc},
    {"writeTime",(PyCFunction)oaPackedData_writeTime,METH_VARARGS,oaPackedData_writeTime_doc},
    {"writeUInt2",(PyCFunction)oaPackedData_writeUInt2,METH_VARARGS,oaPackedData_writeUInt2_doc},
    {"writeUInt2Array",(PyCFunction)oaPackedData_writeUInt2Array,METH_VARARGS,oaPackedData_writeUInt2Array_doc},
    {"writeUInt4",(PyCFunction)oaPackedData_writeUInt4,METH_VARARGS,oaPackedData_writeUInt4_doc},
    {"writeUInt4Array",(PyCFunction)oaPackedData_writeUInt4Array,METH_VARARGS,oaPackedData_writeUInt4Array_doc},
    {"writeUInt8",(PyCFunction)oaPackedData_writeUInt8,METH_VARARGS,oaPackedData_writeUInt8_doc},
    {"writeUInt8Array",(PyCFunction)oaPackedData_writeUInt8Array,METH_VARARGS,oaPackedData_writeUInt8Array_doc},
    {"writeUnalignedUInt4",(PyCFunction)oaPackedData_writeUnalignedUInt4,METH_VARARGS,oaPackedData_writeUnalignedUInt4_doc},
    {"assign",(PyCFunction)oaPackedData_tp_assign,METH_VARARGS,oaPackedData_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaPackedData_doc[] = 
"Class: oaPackedData\n"
"  The oaPackedData class implements an interface object used to read and write various types of data from and to a byte array, in either a packed form or as standard data types that could require byte-swapping.\n"
"  This class is primarily used internally to OpenAccess, but it is public because it can be used to store private data in a pcell supermaster that is used to evaluate instances of that pcell. For example, it could be used to store a tokenized extension language routine that performs the evaluation for the pcell.\n"
"  Such users do not ever construct an oaPackedData. They only need to use the various read and write functions documented here. Byte swapping is handled automatically for them. See oaPcellDataCallback::onPcellRead and oaPcellDataCallback::onPcellWrite for the starting point of the calls that such users will invoke. An oaPackedData is handed to the caller by oaMapWindow::data .\n"
"  The caller is responsible for making sure their sequence of read calls match exactly the sequence of write calls that previously wrote the data into an oaPackedData.\n"
"Constructors:\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaPackedData_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaPackedData",
    sizeof(PyoaPackedDataObject),
    0,
    (destructor)oaPackedData_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaPackedData_tp_compare,	/* tp_compare */
    (reprfunc)oaPackedData_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaPackedData_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaPackedData_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaBasePackedData_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaPackedData_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaPackedData_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaPackedData_Type)<0) {
      printf("** PyType_Ready failed for: oaPackedData\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaPackedData",
           (PyObject*)(&PyoaPackedData_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaPackedData\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaParam
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaParam_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaParam_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaParamObject* self = (PyoaParamObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaParam();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaParam)
    {
        PyParamoaParam p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaParam_Convert,&p1)) {
            self->value =  new oaParam(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaInt4)
    {
        PyParamoaString p1;
        PyParamoaInt4 p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaInt4_Convert,&p2)) {
            self->value =  new oaParam(p1.Data(),p2.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaFloat)
    {
        PyParamoaString p1;
        PyParamoaFloat p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaFloat_Convert,&p2)) {
            self->value =  new oaParam(p1.Data(),p2.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString)
    {
        PyParamoaString p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            self->value =  new oaParam(p1.Data(),p2.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaDouble)
    {
        PyParamoaString p1;
        PyParamoaDouble p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaDouble_Convert,&p2)) {
            self->value =  new oaParam(p1.Data(),p2.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaString,[oaByte])
    {
        PyParamoaString p1;
        PyParamoaString p2;
        PyParamoaByte_Array p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaByte_Array_Convert,&p3)) {
            self->value =  new oaParam(p1.Data(),p2.Data(),p3.Len(),p3.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaParam, Choices are:\n"
        "    ()\n"
        "    (oaParam)\n"
        "    (oaString,oaInt4)\n"
        "    (oaString,oaFloat)\n"
        "    (oaString,oaString)\n"
        "    (oaString,oaDouble)\n"
        "    (oaString,oaString,[oaByte])\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaParam_tp_dealloc(PyoaParamObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaParam_tp_repr(PyObject *ob)
{
    PyParamoaParam value;
    int convert_status=PyoaParam_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[29];
    sprintf(buffer,"<oaParam::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaParam_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaParam v1;
    PyParamoaParam v2;
    int convert_status1=PyoaParam_Convert(ob1,&v1);
    int convert_status2=PyoaParam_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    if (v1.Data()==v2.Data()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaParam_Convert(PyObject* ob,PyParamoaParam* result)
{
    if (ob == NULL) return 1;
    if (PyoaParam_Check(ob)) {
        result->SetData(  ((PyoaParamObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaParam Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaParam_FromoaParam(oaParam* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaParam_Type.tp_alloc(&PyoaParam_Type,0);
        if (bself == NULL) return bself;
        PyoaParamObject* self = (PyoaParamObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaParam_FromoaParam(const oaParam& data)
{
    PyObject* bself = PyoaParam_Type.tp_alloc(&PyoaParam_Type,0);
    if (bself == NULL) return bself;
    PyoaParamObject* self = (PyoaParamObject*)bself;
    self->value =  new oaParam(data);
    self->borrow = 0;
    self->locks = NULL;
    return bself;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaParam_getAppType_doc[] = 
"Class: oaParam, Function: getAppType\n"
"  Paramegers: (oaString)\n"
"    Calls: void getAppType(oaString& value) const\n"
"    Signature: getAppType|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function retrieves the oaAppType string of this application-type oaParam object using the 'appTypeIn' parameter.\n"
"    appTypeIn\n"
"    A reference to an oaString to be populated with the appType information\n"
;

static PyObject*
oaParam_getAppType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParam data;
    int convert_status=PyoaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParamObject* self=(PyoaParamObject*)ob;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getAppType(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParam_getAppVal_doc[] = 
"Class: oaParam, Function: getAppVal\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getAppVal(oaByte* byteData) const\n"
"    Signature: getAppVal|void-void|ptr-oaByte,\n"
"    This function gets the value of this application-type oaParam object. It assumes that the application had earlier assigned such a value to the oaParam object. A fatal application error can occur if an attempt is made to retrieve a value that was not stored earlier.\n"
"    value\n"
"    A pointer to an array of bytes to be populated\n"
;

static PyObject*
oaParam_getAppVal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParam data;
    int convert_status=PyoaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParamObject* self=(PyoaParamObject*)ob;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data().getNumBytes()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match parameter size");
            return NULL;
        }
        data.DataCall()->getAppVal(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParam_getBooleanVal_doc[] = 
"Class: oaParam, Function: getBooleanVal\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean getBooleanVal() const\n"
"    Signature: getBooleanVal|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns the value of this boolean-type oaParam object. If the param isn't storing a boolean value, then the result is indeterminate.\n"
;

static PyObject*
oaParam_getBooleanVal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParam data;
    int convert_status=PyoaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParamObject* self=(PyoaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->getBooleanVal());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParam_getDoubleVal_doc[] = 
"Class: oaParam, Function: getDoubleVal\n"
"  Paramegers: ()\n"
"    Calls: oaDouble getDoubleVal() const\n"
"    Signature: getDoubleVal|simple-oaDouble|\n"
"    BrowseData: 1\n"
"    This function returns the value of this double-type oaParam object. If the param isn't storing a double value then the result is indeterminate.\n"
;

static PyObject*
oaParam_getDoubleVal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParam data;
    int convert_status=PyoaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParamObject* self=(PyoaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaDouble result= (data.DataCall()->getDoubleVal());
        return PyoaDouble_FromoaDouble(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParam_getFloatVal_doc[] = 
"Class: oaParam, Function: getFloatVal\n"
"  Paramegers: ()\n"
"    Calls: oaFloat getFloatVal() const\n"
"    Signature: getFloatVal|simple-oaFloat|\n"
"    BrowseData: 1\n"
"    This function returns the value of this float-type oaParam object. If the param isn't storing a float value then the result is indeterminate.\n"
;

static PyObject*
oaParam_getFloatVal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParam data;
    int convert_status=PyoaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParamObject* self=(PyoaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaFloat result= (data.DataCall()->getFloatVal());
        return PyoaFloat_FromoaFloat(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParam_getIntVal_doc[] = 
"Class: oaParam, Function: getIntVal\n"
"  Paramegers: ()\n"
"    Calls: oaInt4 getIntVal() const\n"
"    Signature: getIntVal|simple-oaInt4|\n"
"    BrowseData: 1\n"
"    This function returns the value of this integer-type oaParam object. If the param isn't storing an integer value then the result is indeterminate.\n"
;

static PyObject*
oaParam_getIntVal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParam data;
    int convert_status=PyoaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParamObject* self=(PyoaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaInt4 result= (data.DataCall()->getIntVal());
        return PyoaInt4_FromoaInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParam_getName_doc[] = 
"Class: oaParam, Function: getName\n"
"  Paramegers: (oaString)\n"
"    Calls: void getName(oaString& name) const\n"
"    Signature: getName|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function retrieves the name of this oaParam object in the 'nameIn' parameter.\n"
"    nameIn\n"
"    A reference to an oaString object to be populated with the name of this oaParam object\n"
;

static PyObject*
oaParam_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParam data;
    int convert_status=PyoaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParamObject* self=(PyoaParamObject*)ob;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParam_getNumBytes_doc[] = 
"Class: oaParam, Function: getNumBytes\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumBytes() const\n"
"    Signature: getNumBytes|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of bytes of this application-type oaParam object. If it isn't storing an application param then it returns 0.\n"
;

static PyObject*
oaParam_getNumBytes(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParam data;
    int convert_status=PyoaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParamObject* self=(PyoaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumBytes());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParam_getStringVal_doc[] = 
"Class: oaParam, Function: getStringVal\n"
"  Paramegers: ()\n"
"    Calls: const oaChar* getStringVal() const\n"
"    Signature: getStringVal|cptr-oaChar|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the string value of this string-type oaParam object. If it isn't storing a string value then the result is indeterminate.\n"
"  Paramegers: (oaString)\n"
"    Calls: void getStringVal(oaString& value) const\n"
"    Signature: getStringVal|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function retrieves the value of this string-type oaParam object in the 'value' parameter. If it isn't storing a string value then the result is indeterminate.\n"
"    value\n"
"    A reference to an oaString object to be populated with the string value that this oaParam object represents\n"
;

static PyObject*
oaParam_getStringVal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParam data;
    int convert_status=PyoaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParamObject* self=(PyoaParamObject*)ob;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaChar* result=(oaChar*)(data.DataCall()->getStringVal());
            return PyoaChar_Array_FromoaChar_Array(result,0,ob);
        }
    }
    PyErr_Clear();
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            data.DataCall()->getStringVal(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaParam, function: getStringVal, Choices are:\n"
        "    ()\n"
        "    (oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParam_getTimeVal_doc[] = 
"Class: oaParam, Function: getTimeVal\n"
"  Paramegers: ()\n"
"    Calls: oaTime getTimeVal() const\n"
"    Signature: getTimeVal|simple-oaTime|\n"
"    BrowseData: 1\n"
"    This function returns the value of this time-type oaParam object. If it isn't storing a time value then the result is indeterminate.\n"
;

static PyObject*
oaParam_getTimeVal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParam data;
    int convert_status=PyoaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParamObject* self=(PyoaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaTime result= (data.DataCall()->getTimeVal());
        return PyoaTime_FromoaTime(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParam_getType_doc[] = 
"Class: oaParam, Function: getType\n"
"  Paramegers: ()\n"
"    Calls: oaParamType getType() const\n"
"    Signature: getType|simple-oaParamType|\n"
"    BrowseData: 1\n"
"    This function returns the type of this oaParam object which specifies the form of its value.\n"
;

static PyObject*
oaParam_getType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParam data;
    int convert_status=PyoaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParamObject* self=(PyoaParamObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaParamType* result= new oaParamType(data.DataCall()->getType());
        return PyoaParamType_FromoaParamType(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParam_setAppType_doc[] = 
"Class: oaParam, Function: setAppType\n"
"  Paramegers: ([oaChar])\n"
"    Calls: void setAppType(const oaChar* value)\n"
"    Signature: setAppType|void-void|cptr-oaChar,\n"
"    This function sets the appType string for this application-type oaParam object. The oaAppType string distinguishes this application-type parameter from other application-type parameters that can have the same name.\n"
"    If this param isn't an application param then this call has no effect. So if you are using an oaParam that previously held a different type and you are setting it to be an application-type param, you must call setAppVal before calling setAppType.\n"
"    value\n"
"    The appType string to be associated with this oaParam object\n"
;

static PyObject*
oaParam_setAppType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParam data;
    int convert_status=PyoaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParamObject* self=(PyoaParamObject*)ob;

    PyParamoaChar_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaChar_Array_Convert,&p1)) {
        data.DataCall()->setAppType(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParam_setAppVal_doc[] = 
"Class: oaParam, Function: setAppVal\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void setAppVal(const oaByte* byteData)\n"
"    Signature: setAppVal|void-void|simple-oaUInt4,cptr-oaByte,\n"
"    This function sets the value of this application-type oaParam object to be the raw array of bytes 'byteDataIn' with a length of 'numBytesIn'.\n"
"    numBytesIn\n"
"    The number of bytes to be assigned to this oaParam object\n"
"    byteDataIn\n"
"    A pointer to the location where the byte array starts\n"
;

static PyObject*
oaParam_setAppVal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParam data;
    int convert_status=PyoaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParamObject* self=(PyoaParamObject*)ob;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        data.DataCall()->setAppVal(p1.Len(),p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParam_setBooleanVal_doc[] = 
"Class: oaParam, Function: setBooleanVal\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: void setBooleanVal(oaBoolean value)\n"
"    Signature: setBooleanVal|void-void|simple-oaBoolean,\n"
"    This function sets this oaParam to be a boolean-type param with the specified 'value'.\n"
"    value\n"
"    The boolean value to be assigned to this oaParam object\n"
;

static PyObject*
oaParam_setBooleanVal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParam data;
    int convert_status=PyoaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParamObject* self=(PyoaParamObject*)ob;

    PyParamoaBoolean p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBoolean_Convert,&p1)) {
        data.DataCall()->setBooleanVal(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParam_setDoubleVal_doc[] = 
"Class: oaParam, Function: setDoubleVal\n"
"  Paramegers: (oaDouble)\n"
"    Calls: void setDoubleVal(oaDouble value)\n"
"    Signature: setDoubleVal|void-void|simple-oaDouble,\n"
"    This function sets this oaParam to be a double-type param with the specified 'value'.\n"
"    value\n"
"    A double value to be assigned to this oaParam object\n"
;

static PyObject*
oaParam_setDoubleVal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParam data;
    int convert_status=PyoaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParamObject* self=(PyoaParamObject*)ob;

    PyParamoaDouble p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaDouble_Convert,&p1)) {
        data.DataCall()->setDoubleVal(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParam_setFloatVal_doc[] = 
"Class: oaParam, Function: setFloatVal\n"
"  Paramegers: (oaFloat)\n"
"    Calls: void setFloatVal(oaFloat value)\n"
"    Signature: setFloatVal|void-void|simple-oaFloat,\n"
"    This function sets this oaParam to be a float-type param with the specified 'value'.\n"
"    value\n"
"    A float value to be assigned to this oaParam object\n"
;

static PyObject*
oaParam_setFloatVal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParam data;
    int convert_status=PyoaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParamObject* self=(PyoaParamObject*)ob;

    PyParamoaFloat p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaFloat_Convert,&p1)) {
        data.DataCall()->setFloatVal(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParam_setIntVal_doc[] = 
"Class: oaParam, Function: setIntVal\n"
"  Paramegers: (oaInt4)\n"
"    Calls: void setIntVal(oaInt4 value)\n"
"    Signature: setIntVal|void-void|simple-oaInt4,\n"
"    This function sets this oaParam to be an integer-type param with the specified 'value'.\n"
"    value\n"
"    An integer value to be assigned to this oaParam object\n"
;

static PyObject*
oaParam_setIntVal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParam data;
    int convert_status=PyoaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParamObject* self=(PyoaParamObject*)ob;

    PyParamoaInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaInt4_Convert,&p1)) {
        data.DataCall()->setIntVal(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParam_setName_doc[] = 
"Class: oaParam, Function: setName\n"
"  Paramegers: ([oaChar])\n"
"    Calls: void setName(const oaChar* nameIn)\n"
"    Signature: setName|void-void|cptr-oaChar,\n"
"    This function sets the name of this oaParam object to that specified by the string parameter 'nameIn'.\n"
"    nameIn\n"
"    A string representing the name to be assigned to this oaParam object\n"
;

static PyObject*
oaParam_setName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParam data;
    int convert_status=PyoaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParamObject* self=(PyoaParamObject*)ob;

    PyParamoaChar_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaChar_Array_Convert,&p1)) {
        data.DataCall()->setName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParam_setStringVal_doc[] = 
"Class: oaParam, Function: setStringVal\n"
"  Paramegers: ([oaChar])\n"
"    Calls: void setStringVal(const oaChar* value)\n"
"    Signature: setStringVal|void-void|cptr-oaChar,\n"
"    This function sets this oaParam to be a string-type param with the specified 'value'.\n"
"    value\n"
"    A string to be assigned to this oaParam object as its new value\n"
;

static PyObject*
oaParam_setStringVal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParam data;
    int convert_status=PyoaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParamObject* self=(PyoaParamObject*)ob;

    PyParamoaChar_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaChar_Array_Convert,&p1)) {
        data.DataCall()->setStringVal(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParam_setTimeVal_doc[] = 
"Class: oaParam, Function: setTimeVal\n"
"  Paramegers: (oaTime)\n"
"    Calls: void setTimeVal(oaTime value)\n"
"    Signature: setTimeVal|void-void|simple-oaTime,\n"
"    This function sets this oaParam to be a time-type param with the specified 'value'.\n"
"    value\n"
"    An oaTime value to be assigned to this oaParam object\n"
;

static PyObject*
oaParam_setTimeVal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParam data;
    int convert_status=PyoaParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParamObject* self=(PyoaParamObject*)ob;

    PyParamoaTime p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTime_Convert,&p1)) {
        data.DataCall()->setTimeVal(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaParam_assign_doc[] = 
"Class: oaParam, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaParam_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaParam data;
  int convert_status=PyoaParam_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaParam p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaParam_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaParam_methodlist[] = {
    {"getAppType",(PyCFunction)oaParam_getAppType,METH_VARARGS,oaParam_getAppType_doc},
    {"getAppVal",(PyCFunction)oaParam_getAppVal,METH_VARARGS,oaParam_getAppVal_doc},
    {"getBooleanVal",(PyCFunction)oaParam_getBooleanVal,METH_VARARGS,oaParam_getBooleanVal_doc},
    {"getDoubleVal",(PyCFunction)oaParam_getDoubleVal,METH_VARARGS,oaParam_getDoubleVal_doc},
    {"getFloatVal",(PyCFunction)oaParam_getFloatVal,METH_VARARGS,oaParam_getFloatVal_doc},
    {"getIntVal",(PyCFunction)oaParam_getIntVal,METH_VARARGS,oaParam_getIntVal_doc},
    {"getName",(PyCFunction)oaParam_getName,METH_VARARGS,oaParam_getName_doc},
    {"getNumBytes",(PyCFunction)oaParam_getNumBytes,METH_VARARGS,oaParam_getNumBytes_doc},
    {"getStringVal",(PyCFunction)oaParam_getStringVal,METH_VARARGS,oaParam_getStringVal_doc},
    {"getTimeVal",(PyCFunction)oaParam_getTimeVal,METH_VARARGS,oaParam_getTimeVal_doc},
    {"getType",(PyCFunction)oaParam_getType,METH_VARARGS,oaParam_getType_doc},
    {"setAppType",(PyCFunction)oaParam_setAppType,METH_VARARGS,oaParam_setAppType_doc},
    {"setAppVal",(PyCFunction)oaParam_setAppVal,METH_VARARGS,oaParam_setAppVal_doc},
    {"setBooleanVal",(PyCFunction)oaParam_setBooleanVal,METH_VARARGS,oaParam_setBooleanVal_doc},
    {"setDoubleVal",(PyCFunction)oaParam_setDoubleVal,METH_VARARGS,oaParam_setDoubleVal_doc},
    {"setFloatVal",(PyCFunction)oaParam_setFloatVal,METH_VARARGS,oaParam_setFloatVal_doc},
    {"setIntVal",(PyCFunction)oaParam_setIntVal,METH_VARARGS,oaParam_setIntVal_doc},
    {"setName",(PyCFunction)oaParam_setName,METH_VARARGS,oaParam_setName_doc},
    {"setStringVal",(PyCFunction)oaParam_setStringVal,METH_VARARGS,oaParam_setStringVal_doc},
    {"setTimeVal",(PyCFunction)oaParam_setTimeVal,METH_VARARGS,oaParam_setTimeVal_doc},
    {"assign",(PyCFunction)oaParam_tp_assign,METH_VARARGS,oaParam_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaParam_doc[] = 
"Class: oaParam\n"
"  The oaParam utility class represents a parameter used to specify a desired customization of a pcell . Pcells are parameterized designs that can be modified for each instance by specifying appropriate parameter values.\n"
"  A parameter is essentially a name/type/value triplet. Each oaParam can be of any of the supported types. The type of its value must be consistent with the type of the oaParam.\n"
"  While oaParam objects may be constructed by themselves, when they are used in the API for pcells they are always elements of an oaParamArray . Hence that is the most common way for applications to use them.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaParam()\n"
"    Signature: oaParam||\n"
"    This function constructs an empty oaParam object which has an undefined value and type.\n"
"  Paramegers: (oaParam)\n"
"    Calls: oaParam(const oaParam& param)\n"
"    Signature: oaParam||cref-oaParam,\n"
"    This function constructs a copy of the oaParam object 'param' being passed in.\n"
"    param\n"
"    A reference to the oaParam object whose copy is to be made\n"
"  Paramegers: (oaString,oaInt4)\n"
"    Calls: oaParam(const oaString& nameIn,oaInt4 value)\n"
"    Signature: oaParam||cref-oaString,simple-oaInt4,\n"
"    This function constructs an oaParam object with an integer 'value' and which has the specified name 'nameIn'.\n"
"    nameIn\n"
"    The name to assign to the new oaParam object\n"
"    value\n"
"    An integer value to be assigned to the oaParam object\n"
"  Paramegers: (oaString,oaFloat)\n"
"    Calls: oaParam(const oaString& nameIn,oaFloat value)\n"
"    Signature: oaParam||cref-oaString,simple-oaFloat,\n"
"    This function constructs an oaParam object with a float 'value' and which has the specified name 'nameIn'.\n"
"    nameIn\n"
"    The name to assign to the new oaParam object\n"
"    value\n"
"    A float value to be assigned to the oaParam object\n"
"  Paramegers: (oaString,oaString)\n"
"    Calls: oaParam(const oaString& nameIn,const oaString& value)\n"
"    Signature: oaParam||cref-oaString,cref-oaString,\n"
"    This function constructs an oaParam object with a string 'value' and which has the specified name 'nameIn'.\n"
"    nameIn\n"
"    The name to assign to the new oaParam object\n"
"    value\n"
"    A reference to an oaString object to be assigned to the oaParam object\n"
"  Paramegers: (oaString,oaDouble)\n"
"    Calls: oaParam(const oaString& nameIn,oaDouble value)\n"
"    Signature: oaParam||cref-oaString,simple-oaDouble,\n"
"    This function constructs an oaParam object with a double 'value' and which has the specified name 'nameIn'.\n"
"    nameIn\n"
"    The name to assign to the new oaParam object\n"
"    value\n"
"    A double value to be assigned to the oaParam object\n"
"  Paramegers: (oaString,oaString,[oaByte])\n"
"    Calls: oaParam(const oaString& nameIn,const oaString& appTypeIn,const oaByte* byteDataIn)\n"
"    Signature: oaParam||cref-oaString,cref-oaString,simple-oaUInt4,cptr-oaByte,\n"
"    This function constructs an oaParam object that has an arbitrary set of application-defined bytes for a value. This kind of parameter has an additional string associated with it that is defined by the application to further define what the value is.\n"
"    Note that the database cannot do byte-swapping for embedded binary fields (such as integers) in this value when it is written on one kind of computer and read on another. Hence the use of this type of param is discouraged.\n"
"    nameIn\n"
"    The name to assign to the new oaParam object\n"
"    appTypeIn\n"
"    A reference to an oaString object to specify additional application specific information\n"
"    numBytesIn\n"
"    An integer value indicating the number of bytes being assigned to this oaParam object with 'byteDataIn'\n"
"    byteDataIn\n"
"    A pointer to an array of bytes to be assigned to this oaParam object\n"
"  Paramegers: (oaParam)\n"
"    Calls: (const oaParam&)\n"
"    Signature: oaParam||cref-oaParam,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaParam_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaParam",
    sizeof(PyoaParamObject),
    0,
    (destructor)oaParam_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaParam_tp_compare,	/* tp_compare */
    (reprfunc)oaParam_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaParam_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaParam_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaParam_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaParam_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaParam_Type)<0) {
      printf("** PyType_Ready failed for: oaParam\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaParam",
           (PyObject*)(&PyoaParam_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaParam\n");
       return -1;
    }
    return 0;
}


// ==================================================================
// Array for class: oaParam
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaParam_Array_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaParam_Array_Type);
    PyObject* gself = type->tp_alloc(type,0);
    if (gself == NULL) return gself;
    PyoaParam_ArrayObject* self = (PyoaParam_ArrayObject*)gself;
    self->borrow = 0;
    self->locks=NULL;
    static char *kwlist [] = { NULL } ;
    /* Case: () */ 
    {
        if (PyArg_ParseTuple(args,"")) {
            return gself;
        }
    }
    PyErr_Clear();
    /* Case: (int) */
    {
        int p1;
        if (PyArg_ParseTuple(args,(char*)"i",&p1)) {
            self->data.SetLen(p1);
            return gself;
        }
    }
    PyErr_Clear();
    /* Case: (oaParam_Array) */
    {
        PyParamoaParam_Array p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaParam_Array_Convert,&p1)) {
            self->data.TakeAway(p1);
            return gself;
        }
    }
    /* Error */
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaParam_Array, Choices are:\n"
        "    ()\n"
        "    (int)\n"
        "    (oaParam_Array)\n"
    );
    Py_DECREF(gself);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaParam_Array_dealloc(PyObject* gself)
{
    PyoaParam_ArrayObject* self = (PyoaParam_ArrayObject*)gself;
    Py_XDECREF(self->locks);
    self->ob_type->tp_free(gself);
}

// ------------------------------------------------------------------
static PyObject*
oaParam_Array_str(PyObject *ob)
{
    PyParamoaParam_Array value;
    int convert_status=PyoaParam_Array_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* lst=PyoaParam_Array_CreateList(value);
    PyObject* result=PyObject_Str(lst);
    Py_DECREF(lst);
    return result;
}

// ------------------------------------------------------------------
static PyObject*
oaParam_Array_repr(PyObject *ob)
{
    PyParamoaParam_Array value;
    int convert_status=PyoaParam_Array_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* lst=PyoaParam_Array_CreateList(value);
    PyObject* result=PyObject_Repr(lst);
    Py_DECREF(lst);
    return result;
}

// ------------------------------------------------------------------
static int
oaParam_Array_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaParam_Array p1;
    PyParamoaParam_Array p2;
    int s1=PyoaParam_Array_Convert(ob1,&p1);
    int s2=PyoaParam_Array_Convert(ob2,&p2);
    assert(s1!=0);
    assert(s2!=0);
    PyObject* l1=PyoaParam_Array_CreateList(p1);
    PyObject* l2=PyoaParam_Array_CreateList(p2);
    int result=PyObject_Compare(l1,l2);
    Py_DECREF(l1);
    Py_DECREF(l2);
    return result;
}

// ------------------------------------------------------------------
int
PyoaParam_Array_Convert(PyObject* ob,PyParamoaParam_Array* result)
{
  Pyoa_ssize_t len,i;
  if (PyoaParam_Array_Check(ob)) {
    PyoaParam_ArrayObject* self = (PyoaParam_ArrayObject*)ob;
    result->Borrow(self->data);
  }
  else if (PyList_Check(ob)) {
    len=PyList_Size(ob);
    result->SetLen(len);
    PyParamoaParam data;
    for(i=0;i<len;i++) {
      PyObject* a=PyList_GetItem(ob,i);
      if (!PyoaParam_Convert(a,&data)) return 0;
      result->SetItem(i,data.Data());
    }
  }
  else if (PyTuple_Check(ob)) {
    len=PyTuple_Size(ob);
    result->SetLen(len);
    PyParamoaParam data;
    for(i=0;i<len;i++) {
      PyObject* a=PyTuple_GetItem(ob,i);
      if (!PyoaParam_Convert(a,&data)) return 0;
      result->SetItem(i,data.Data());
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError,
      "Convertion of parameter to class: oaParam_Array Failed");
    return 0;
  }
  return 1;
}

// ------------------------------------------------------------------
PyObject* PyoaParam_Array_FromoaParam_Array(const oaParam_Array& value)
{
  PyObject* gself = PyoaParam_Array_Type.tp_alloc(&PyoaParam_Array_Type,0);
  if (gself == NULL) return gself;
  PyoaParam_ArrayObject* self = (PyoaParam_ArrayObject*)gself;
  self->data = value;
  self->borrow = 0;
  self->locks=NULL;
  return gself;
}

// ------------------------------------------------------------------
PyObject* PyoaParam_Array_FromoaParam_Array(PyTypeoaParam* data,Pyoa_ssize_t len,PyObject* lock)
{
  PyObject* gself = PyoaParam_Array_Type.tp_alloc(&PyoaParam_Array_Type,0);
  if (gself == NULL) return gself;
  PyoaParam_ArrayObject* self = (PyoaParam_ArrayObject*)gself;
  self->data.Borrow(data,len);
  self->borrow = 1;
  self->locks=NULL;
  if (lock) PyoaLockObject(self->locks,lock);
  return gself;
}

// ------------------------------------------------------------------
PyObject* PyoaParam_Array_CreateList(PyParamoaParam_Array& value)
{
  Pyoa_ssize_t i;
  PyObject* lst=PyList_New(value.Len());
  for(i=0;i<value.Len();i++) {
    PyObject* ob=PyoaParam_FromoaParam(value.Data()[i]);
    PyList_SetItem(lst,i,ob);
  }
  return lst;
}

// ------------------------------------------------------------------
// Methods
// ------------------------------------------------------------------
static char oaParam_Array_assign_doc[] = 
"Class: oaParam_Array, Function: assign\n"
"  Paramegers: (oaParam_Array)\n"
"    This function assigns the current value.\n"
;

static PyObject*
oaParam_Array_assign(PyObject* ob, PyObject *args)
{
  PyoaParam_ArrayObject* self=(PyoaParam_ArrayObject*)ob;
  try {
    PyParamoaParam_Array p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaParam_Array_Convert,&p1)) {
        self->data=p1;
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}
// ------------------------------------------------------------------
static char oaParam_Array_list_doc[] = 
"Class: oaParam_Array, Function: list\n"
"  Paramegers: ()\n"
"    This function returns the current value as a list.\n"
;

static PyObject*
oaParam_Array_list(PyObject* ob, PyObject *args)
{
  PyoaParam_ArrayObject* self=(PyoaParam_ArrayObject*)ob;
  try {
    if (PyArg_ParseTuple(args,(char*)"")) {
      return PyoaParam_Array_CreateList(self->data);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}
// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------
static PyMethodDef oaParam_Array_methodlist[] = {
    {"assign",(PyCFunction)oaParam_Array_assign,METH_VARARGS,oaParam_Array_assign_doc},
    {"list",(PyCFunction)oaParam_Array_list,METH_VARARGS,oaParam_Array_list_doc},
   {NULL,NULL,0,NULL}
};

// ------------------------------------------------------------------
static PyObject*
oaParam_Array_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaParam_ArrayObject* self=(PyoaParam_ArrayObject*)ob;
  try {
    PyParamoaParam_Array data;
    int convert_status=PyoaParam_Array_Convert(ob,&data);
    assert(convert_status!=0);
    if (index<0 || index>=data.Len()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    return PyoaParam_FromoaParam(data.GetItemPtr(index),1,self->locks);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static Pyoa_ssize_t
oaParam_Array_index_get_length(PyObject* ob)
{
    PyParamoaParam_Array data;
    int convert_status=PyoaParam_Array_Convert(ob,&data);
    assert(convert_status!=0);
    return data.Len();
}

// ------------------------------------------------------------------
static int
oaParam_Array_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaParam_Array data;
    PyParamoaParam dataitem;
    int convert_status=PyoaParam_Array_Convert(ob,&data);
    assert(convert_status!=0);
    if (index<0 || index>=data.Len()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    if (PyoaParam_Convert(value,&dataitem)==0) return -1;
    data.SetItem(index,dataitem.Data());
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return 0;
  }
}

// ------------------------------------------------------------------
static char oaParam_Array_doc[] =
"Class: oaParam_Array\n"
"  The oaParam_Array utility class provides an array of oaParam.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaParam_Array()\n"
"    Signature: oaParam_Array||\n"
"    This is the default constructor for the oaParam_Array class. This constructor creates an empty oaParam_Array.\n"
"  Paramegers: (oaParam_Array)\n"
"    Calls: (const oaParam_Array&)\n"
"    Signature: oaParam_Array||cref-oaParam_Array,\n"
;

// ------------------------------------------------------------------
static PySequenceMethods oaParam_Array_as_sequence = {
    (Pyoa_inquiry)oaParam_Array_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,              /* sq_concat */
    (Pyoa_intargfunc)0,              /* sq_repeat */
    (Pyoa_intargfunc)oaParam_Array_index_get, /* sq_item */
    (Pyoa_intintargfunc)0,           /* sq_slice */
    (Pyoa_intobjargproc)oaParam_Array_index_set,      /* sq_ass_item */
};

// ------------------------------------------------------------------
PyTypeObject PyoaParam_Array_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaParam_Array",
    sizeof(PyoaParam_ArrayObject),
    0,
    oaParam_Array_dealloc, /* tp_dealloc */
    0,  /* tp_print */
    0,                                  /* tp_getattr */
    0,                                  /* tp_setattr */
    oaParam_Array_compare,    /* tp_compare */
    oaParam_Array_repr,      /* tp_repr */
    0,                                  /* tp_as_number */
    &oaParam_Array_as_sequence,  /* tp_as_sequence */
    0,                                  /* tp_as_mapping */
    0,                                  /* tp_as_hash */
    0,                                  /* tp_as_call */
    oaParam_Array_str,               /* tp_str */
    0,                                  /* tp_getattro */
    0,                                  /* tp_setattro */
    0,                                  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaParam_Array_doc, /* tp_doc */
    0,                                  /* tp_traverse */
    0,                                  /* tp_clear */
    0,                                  /* tp_richcompre */
    0,                                  /* tp_weaklistoffset */
    0,                                  /* tp_iter */
    0,                                  /* tp_iternext */
    oaParam_Array_methodlist, /* tp_methods */
    0,                                  /* tp_members */
    0,                                  /* tp_getset */
    0,                                  /* tp_base */
    0,                                  /* tp_dict */
    0,                                  /* tp_descr_get */
    0,                                  /* tp_descr_set */
    0,                                  /* tp_dictoffset */
    0,                                  /* tp_init */
    PyType_GenericAlloc,        /* tp_alloc */
    oaParam_Array_new, /* tp_new */
    _PyObject_Del,      /* tp_free */
};


// ------------------------------------------------------------------
int
PyoaParam_Array_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaParam_Array_Type)<0) {
      printf("** PyType_Ready failed for: oaParam_Array\n");
      return -1;
    }
    if (PyDict_SetItemString(mod_dict,"oaParam_Array",
           (PyObject*)(&PyoaParam_Array_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaParam_Array\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaParamArray
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaParamArray_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaParamArray_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaParamArrayObject* self = (PyoaParamArrayObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaArrayBase_oaParam*)  new oaParamArray();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value = (oaArrayBase_oaParam*)  new oaParamArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaParamArray)
    {
        PyParamoaParamArray p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaParamArray_Convert,&p1)) {
            self->value = (oaArrayBase_oaParam*)  new oaParamArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaParamArray, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaParamArray)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaParamArray_tp_dealloc(PyoaParamArrayObject* self)
{
    if (!self->borrow) {
        delete (oaParamArray*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaParamArray_tp_repr(PyObject *ob)
{
    PyParamoaParamArray value;
    int convert_status=PyoaParamArray_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[34];
    sprintf(buffer,"<oaParamArray::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaParamArray_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaParamArray v1;
    PyParamoaParamArray v2;
    int convert_status1=PyoaParamArray_Convert(ob1,&v1);
    int convert_status2=PyoaParamArray_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    if (v1.Data()==v2.Data()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaParamArray_Convert(PyObject* ob,PyParamoaParamArray* result)
{
    if (ob == NULL) return 1;
    if (PyoaParamArray_Check(ob)) {
        result->SetData( (oaParamArray*) ((PyoaParamArrayObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaParamArray Failed");
    return 0;
}
int
PyoaParamArray_ConvertAof(PyObject* ob,PyParamoaParamArray* result)
{
    if (ob == NULL) return 1;
    if (ob==Py_None) {
        result->SetData(NULL);
        return 1;
    }
    if (PyoaParamArray_Check(ob)) {
        result->SetData( (oaParamArray*) ((PyoaParamArrayObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaParamArray Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaParamArray_FromoaParamArray(oaParamArray* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaParamArray_Type.tp_alloc(&PyoaParamArray_Type,0);
        if (bself == NULL) return bself;
        PyoaParamArrayObject* self = (PyoaParamArrayObject*)bself;
        self->value = (oaArrayBase_oaParam*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaParamArray_find_doc[] = 
"Class: oaParamArray, Function: find\n"
"  Paramegers: (oaParam)\n"
"    Calls: oaUInt4 find(const oaParam& param) const\n"
"    Signature: find|simple-oaUInt4|cref-oaParam,\n"
"    This function searches the parameters of this paramArray looking for the specified parameter param . If found, the index of the matching param is returned as an unsigned integer, otherwise the oacNullIndex value is returned.\n"
"    param\n"
"    input parameter to look for in this paramArray\n"
"  Paramegers: (oaString,oaParam)\n"
"    Calls: oaBoolean find(const oaString& name,oaParam& param) const\n"
"    Signature: find|simple-oaBoolean|cref-oaString,ref-oaParam,\n"
"    This function searches the parameters of this oaParamArray for a parameter with the specified name. If found, the specified param is filled and true is returned. Otherwise, false is returned.\n"
"    nameIn\n"
"    A reference to an oaString object that represents the name of the oaParam object being searched in this oaParamArray object\n"
"    param\n"
"    A reference to an oaParam object to be populated if an oaParam object with the specified name is found in this array\n"
;

static PyObject*
oaParamArray_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParamArray data;
    int convert_status=PyoaParamArray_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParamArrayObject* self=(PyoaParamArrayObject*)ob;

    // Case: (oaParam)
    {
        PyParamoaParam p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaParam_Convert,&p1)) {
            oaUInt4 result= (data.DataCall()->find(p1.Data()));
            return PyoaUInt4_FromoaUInt4(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaParam)
    {
        PyParamoaString p1;
        PyParamoaParam p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaParam_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->find(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaParamArray, function: find, Choices are:\n"
        "    (oaParam)\n"
        "    (oaString,oaParam)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaParamArray_assign_doc[] = 
"Class: oaParamArray, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaParamArray_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaParamArray data;
  int convert_status=PyoaParamArray_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaParamArray p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaParamArray_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaParamArray_methodlist[] = {
    {"find",(PyCFunction)oaParamArray_find,METH_VARARGS,oaParamArray_find_doc},
    {"assign",(PyCFunction)oaParamArray_tp_assign,METH_VARARGS,oaParamArray_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaParamArray_doc[] = 
"Class: oaParamArray\n"
"  The oaParamArray class implements an array of oaParam objects. Arrays of parameters are typically used to set or retrieve the data for parameterized designs (pCells) and instances.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaParamArray()\n"
"    Signature: oaParamArray||simple-oaUInt4,\n"
"    This function constructs an oaParamArray object, setting the number of parameters, and allocating storage for the parameters.\n"
"    sizeIn\n"
"    An integer value indicating the initial size of the parameter array\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaParamArray(oaUInt4 sizeIn)\n"
"    Signature: oaParamArray||simple-oaUInt4,\n"
"    This function constructs an oaParamArray object, setting the number of parameters, and allocating storage for the parameters.\n"
"    sizeIn\n"
"    An integer value indicating the initial size of the parameter array\n"
"  Paramegers: (oaParamArray)\n"
"    Calls: oaParamArray(const oaParamArray& paramsIn)\n"
"    Signature: oaParamArray||cref-oaParamArray,\n"
"    This function constructs an oaParamArray instance by creating a copy of the specified oaParamArray object 'paramsIn'.\n"
"    paramsIn\n"
"    A reference to an existing oaParamArray object whose elements are to be copied for creating this oaParamArray object\n"
"  Paramegers: (oaParamArray)\n"
"    Calls: (const oaParamArray&)\n"
"    Signature: oaParamArray||cref-oaParamArray,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaParamArray_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaParamArray",
    sizeof(PyoaParamArrayObject),
    0,
    (destructor)oaParamArray_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaParamArray_tp_compare,	/* tp_compare */
    (reprfunc)oaParamArray_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaParamArray_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaParamArray_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaArray_oaParam_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaParamArray_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaParamArray_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaParamArray_Type)<0) {
      printf("** PyType_Ready failed for: oaParamArray\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaParamArray",
           (PyObject*)(&PyoaParamArray_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaParamArray\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaParamType
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaParamType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaParamType_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaParamTypeObject* self = (PyoaParamTypeObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaParamTypeEnum)
    {
        PyParamoaParamTypeEnum p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaParamTypeEnum_Convert,&p1)) {
            self->value =  new oaParamType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            self->value =  new oaParamType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaParamType)
    {
        PyParamoaParamType p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaParamType_Convert,&p1)) {
            self->value= new oaParamType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaParamType, Choices are:\n"
        "    (oaParamTypeEnum)\n"
        "    (oaString)\n"
        "    (oaParamType)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaParamType_tp_dealloc(PyoaParamTypeObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaParamType_tp_repr(PyObject *ob)
{
    PyParamoaParamType value;
    int convert_status=PyoaParamType_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    oaString sresult(value.DataCall()->getName());

    char addr[33];
    sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
    oaString buffer;
    buffer+=oaString("<oaParamType::");
    buffer+=oaString(addr);
    buffer+=oaString("::");
    buffer+=oaString(sresult);
    buffer+=oaString(">");
    result=PyString_FromString((char*)(const char*)buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaParamType_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaParamType v1;
    PyParamoaParamType v2;
    int convert_status1=PyoaParamType_Convert(ob1,&v1);
    int convert_status2=PyoaParamType_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaParamType_Convert(PyObject* ob,PyParamoaParamType* result)
{
    if (ob == NULL) return 1;
    if (PyoaParamType_Check(ob)) {
        result->SetData(  ((PyoaParamTypeObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaParamType Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaParamType_FromoaParamType(oaParamType* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaParamType_Type.tp_alloc(&PyoaParamType_Type,0);
        if (bself == NULL) return bself;
        PyoaParamTypeObject* self = (PyoaParamTypeObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaParamType_getName_doc[] = 
"Class: oaParamType, Function: getName\n"
"  Paramegers: ()\n"
"    Calls: const oaString& getName() const\n"
"    Signature: getName|cref-oaString|\n"
"    BrowseData: 1\n"
"    This function returns the name string associated with the encapsulated #oaParamTypeEnum object.\n"
;

static PyObject*
oaParamType_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParamType data;
    int convert_status=PyoaParamType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParamTypeObject* self=(PyoaParamTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaString result= (data.DataCall()->getName());
        return PyoaString_FromoaString(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParamType_oaParamTypeEnum_doc[] = 
"Class: oaParamType, Function: oaParamTypeEnum\n"
"  Paramegers: ()\n"
"    Calls: oaParamTypeEnum oaParamTypeEnum() const\n"
"    Signature: operator oaParamTypeEnum|simple-oaParamTypeEnum|\n"
"    BrowseData: 1\n"
"    This operator casts this oaParamType object into the corresponding #oaParamTypeEnum value.\n"
;

static PyObject*
oaParamType_oaParamTypeEnum(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParamType data;
    int convert_status=PyoaParamType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParamTypeObject* self=(PyoaParamTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaParamTypeEnum result= (data.DataCall()->operator oaParamTypeEnum());
        return PyoaParamTypeEnum_FromoaParamTypeEnum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaParamType_assign_doc[] = 
"Class: oaParamType, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaParamType_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaParamType data;
  int convert_status=PyoaParamType_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaParamType p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaParamType_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaParamType_methodlist[] = {
    {"getName",(PyCFunction)oaParamType_getName,METH_VARARGS,oaParamType_getName_doc},
    {"oaParamTypeEnum",(PyCFunction)oaParamType_oaParamTypeEnum,METH_VARARGS,oaParamType_oaParamTypeEnum_doc},
    {"assign",(PyCFunction)oaParamType_tp_assign,METH_VARARGS,oaParamType_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaParamType_doc[] = 
"Class: oaParamType\n"
"  The oaParamType class is an enum wrapper class that has values that specify the type of a given oaParam object. See oaParam::getType for its usage.\n"
"  See Enum Wrappers in the Programmers Guide for a discussion of enum wrappers.\n"
"  oaParamTypeEnum\n"
"Constructors:\n"
"  Paramegers: (oaParamTypeEnum)\n"
"    Calls: oaParamType(oaParamTypeEnum typeIn)\n"
"    Signature: oaParamType||simple-oaParamTypeEnum,\n"
"    This function constructs an instance of an oaParamType class using the specified #oaParamTypeEnum value 'typeIn'.\n"
"  Paramegers: (oaString)\n"
"    Calls: oaParamType(const oaString& name)\n"
"    Signature: oaParamType||cref-oaString,\n"
"    This function constructs an instance of an oaParamType class using the #oaParamTypeEnum associated with the specified string name . This name must be defined in the legal set of names associated with #oaParamTypeEnum.\n"
"    name\n"
"    A reference to an oaString object representing a valid parameter type name\n"
"    oacInvalidParamTypeName\n"
"  Paramegers: (oaParamType)\n"
"    Calls: (const oaParamType&)\n"
"    Signature: oaParamType||cref-oaParamType,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaParamType_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaParamType",
    sizeof(PyoaParamTypeObject),
    0,
    (destructor)oaParamType_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaParamType_tp_compare,	/* tp_compare */
    (reprfunc)oaParamType_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaParamType_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaParamType_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaParamType_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaParamType_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaParamType_Type)<0) {
      printf("** PyType_Ready failed for: oaParamType\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaParamType",
           (PyObject*)(&PyoaParamType_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaParamType\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaParamTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaParamTypeEnum_Convert(PyObject* ob,PyParamoaParamTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacIntParamType")==0) { result->SetData(oacIntParamType); return 1;}
        if (strcasecmp(str,"oacFloatParamType")==0) { result->SetData(oacFloatParamType); return 1;}
        if (strcasecmp(str,"oacStringParamType")==0) { result->SetData(oacStringParamType); return 1;}
        if (strcasecmp(str,"oacAppParamType")==0) { result->SetData(oacAppParamType); return 1;}
        if (strcasecmp(str,"oacDoubleParamType")==0) { result->SetData(oacDoubleParamType); return 1;}
        if (strcasecmp(str,"oacBooleanParamType")==0) { result->SetData(oacBooleanParamType); return 1;}
        if (strcasecmp(str,"oacTimeParamType")==0) { result->SetData(oacTimeParamType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaParamTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaParamTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaParamTypeEnum_FromoaParamTypeEnum(oaParamTypeEnum ob)
{
    if (ob==oacIntParamType) return PyString_FromString("oacIntParamType");
    if (ob==oacFloatParamType) return PyString_FromString("oacFloatParamType");
    if (ob==oacStringParamType) return PyString_FromString("oacStringParamType");
    if (ob==oacAppParamType) return PyString_FromString("oacAppParamType");
    if (ob==oacDoubleParamType) return PyString_FromString("oacDoubleParamType");
    if (ob==oacBooleanParamType) return PyString_FromString("oacBooleanParamType");
    if (ob==oacTimeParamType) return PyString_FromString("oacTimeParamType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaParamTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaParamTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaParamTypeEnum_FromoaParamTypeEnum(oaParamTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaParamTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaParamTypeEnum_doc[] =
"Type convert function for enum: oaParamTypeEnum";
                               
static PyMethodDef PyoaParamTypeEnum_method =
  {"oaParamTypeEnum",(PyCFunction)PyoaParamTypeEnum_TypeFunction,METH_VARARGS,oaParamTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaParamTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacIntParamType");
    PyDict_SetItemString(mod_dict,"oacIntParamType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacFloatParamType");
    PyDict_SetItemString(mod_dict,"oacFloatParamType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacStringParamType");
    PyDict_SetItemString(mod_dict,"oacStringParamType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAppParamType");
    PyDict_SetItemString(mod_dict,"oacAppParamType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDoubleParamType");
    PyDict_SetItemString(mod_dict,"oacDoubleParamType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBooleanParamType");
    PyDict_SetItemString(mod_dict,"oacBooleanParamType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacTimeParamType");
    PyDict_SetItemString(mod_dict,"oacTimeParamType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaParamTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaParamTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaParamTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaParasiticNetwork
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaParasiticNetwork_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaParasiticNetwork_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaParasiticNetworkObject* self = (PyoaParasiticNetworkObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaParasiticNetwork)
    {
        PyParamoaParasiticNetwork p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaParasiticNetwork_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaParasiticNetwork, Choices are:\n"
        "    (oaParasiticNetwork)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaParasiticNetwork_tp_dealloc(PyoaParasiticNetworkObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaParasiticNetwork_tp_repr(PyObject *ob)
{
    PyParamoaParasiticNetwork value;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[40];
    sprintf(buffer,"<oaParasiticNetwork::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaParasiticNetwork_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaParasiticNetwork v1;
    PyParamoaParasiticNetwork v2;
    int convert_status1=PyoaParasiticNetwork_Convert(ob1,&v1);
    int convert_status2=PyoaParasiticNetwork_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaParasiticNetwork_Convert(PyObject* ob,PyParamoaParasiticNetwork* result)
{
    if (ob == NULL) return 1;
    if (PyoaParasiticNetwork_Check(ob)) {
        result->SetData( (oaParasiticNetwork**) ((PyoaParasiticNetworkObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaParasiticNetwork Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaParasiticNetwork_FromoaParasiticNetwork(oaParasiticNetwork** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaParasiticNetwork* data=*value;
        PyObject* bself = PyoaParasiticNetwork_Type.tp_alloc(&PyoaParasiticNetwork_Type,0);
        if (bself == NULL) return bself;
        PyoaParasiticNetworkObject* self = (PyoaParasiticNetworkObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaParasiticNetwork_FromoaParasiticNetwork(oaParasiticNetwork* data)
{
    if (data) {
       PyObject* bself = PyoaParasiticNetwork_Type.tp_alloc(&PyoaParasiticNetwork_Type,0);
       if (bself == NULL) return bself;
       PyoaParasiticNetworkObject* self = (PyoaParasiticNetworkObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaParasiticNetwork_destroy_doc[] = 
"Class: oaParasiticNetwork, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function destroys this parasiticNetwork object, including data for all analysis points that share this parasiticNetwork.\n"
;

static PyObject*
oaParasiticNetwork_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_getAnalysisPoints_doc[] = 
"Class: oaParasiticNetwork, Function: getAnalysisPoints\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaAnalysisPoint_oaParasiticNetwork getAnalysisPoints() const\n"
"    Signature: getAnalysisPoints|simple-oaCollection_oaAnalysisPoint_oaParasiticNetwork|\n"
"    BrowseData: 1\n"
"    This function returns a collection of all the analysis points in this parasitic network.\n"
;

static PyObject*
oaParasiticNetwork_getAnalysisPoints(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaAnalysisPoint_oaParasiticNetwork* result= new oaCollection_oaAnalysisPoint_oaParasiticNetwork(data.DataCall()->getAnalysisPoints());
        return PyoaCollection_oaAnalysisPoint_oaParasiticNetwork_FromoaCollection_oaAnalysisPoint_oaParasiticNetwork(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_getAnalysisPointsIter_doc[] = 
"Class: oaParasiticNetwork, Function: getAnalysisPointsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaAnalysisPoint getAnalysisPointsIter() const\n"
"    Signature: getAnalysisPointsIter|simple-oaIter_oaAnalysisPoint|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of all the analysis points in this parasitic network.\n"
;

static PyObject*
oaParasiticNetwork_getAnalysisPointsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaAnalysisPoint* result= new oaIter_oaAnalysisPoint(data.DataCall()->getAnalysisPoints());
        return PyoaIter_oaAnalysisPoint_FromoaIter_oaAnalysisPoint(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_getBBox_doc[] = 
"Class: oaParasiticNetwork, Function: getBBox\n"
"  Paramegers: (oaBox)\n"
"    Calls: void getBBox(oaBox& bBox) const\n"
"    Signature: getBBox|void-void|ref-oaBox,\n"
"    BrowseData: 0,oaBox\n"
"    This function returns the bounding box of this parasiticNetwork. A bounding box on a parasitic network is provided for use in partitioned networks.\n"
"    bBox\n"
"    The returned bounding box\n"
;

static PyObject*
oaParasiticNetwork_getBBox(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBox p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBox_Convert,&p1)) {
        data.DataCall()->getBBox(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_getConnNodes_doc[] = 
"Class: oaParasiticNetwork, Function: getConnNodes\n"
"  Paramegers: (oaDesignObject)\n"
"    Calls: oaCollection_oaNode_oaParasiticNetwork getConnNodes(const oaDesignObject* conn) const\n"
"    Signature: getConnNodes|simple-oaCollection_oaNode_oaParasiticNetwork|cptr-oaDesignObject,\n"
"    This function returns a collection of all the nodes in this parasitic network that are connected to the specified object. The object must be an instTerm or a bitTerm for parasitic networks that are on oaNets, or must be an occInstTerm or an occBitTerm for parasitic networks that are on occNets.\n"
"    oacInvalidNodeConnType\n"
;

static PyObject*
oaParasiticNetwork_getConnNodes(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDesignObject p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaDesignObject_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaCollection_oaNode_oaParasiticNetwork* result= new oaCollection_oaNode_oaParasiticNetwork(data.DataCall()->getConnNodes(p1.Data()));
        return PyoaCollection_oaNode_oaParasiticNetwork_FromoaCollection_oaNode_oaParasiticNetwork(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_getConnNodesIter_doc[] = 
"Class: oaParasiticNetwork, Function: getConnNodesIter\n"
"  Paramegers: (oaDesignObject)\n"
"    Calls: oaIter_oaNode getConnNodesIter(const oaDesignObject* conn) const\n"
"    Signature: getConnNodesIter|simple-oaIter_oaNode|cptr-oaDesignObject,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of all the nodes in this parasitic network that are connected to the specified object. The object must be an instTerm or a bitTerm for parasitic networks that are on oaNets, or must be an occInstTerm or an occBitTerm for parasitic networks that are on occNets.\n"
"    oacInvalidNodeConnType\n"
;

static PyObject*
oaParasiticNetwork_getConnNodesIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDesignObject p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaDesignObject_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaIter_oaNode* result= new oaIter_oaNode(data.DataCall()->getConnNodes(p1.Data()));
        return PyoaIter_oaNode_FromoaIter_oaNode(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_getCoupledNets_doc[] = 
"Class: oaParasiticNetwork, Function: getCoupledNets\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaDesignObject_oaParasiticNetwork getCoupledNets() const\n"
"    Signature: getCoupledNets|simple-oaCollection_oaDesignObject_oaParasiticNetwork|\n"
"    BrowseData: 1\n"
"    This function returns a collection containing the nets to which this net is coupled, through either a coupling capacitor or a mutual inductor.\n"
;

static PyObject*
oaParasiticNetwork_getCoupledNets(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaDesignObject_oaParasiticNetwork* result= new oaCollection_oaDesignObject_oaParasiticNetwork(data.DataCall()->getCoupledNets());
        return PyoaCollection_oaDesignObject_oaParasiticNetwork_FromoaCollection_oaDesignObject_oaParasiticNetwork(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_getCoupledNetsIter_doc[] = 
"Class: oaParasiticNetwork, Function: getCoupledNetsIter\n"
"  Paramegers: ()\n"
"    Calls: oaDesignObjectIter getCoupledNetsIter() const\n"
"    Signature: getCoupledNetsIter|simple-oaDesignObjectIter|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection containing the nets to which this net is coupled, through either a coupling capacitor or a mutual inductor.\n"
;

static PyObject*
oaParasiticNetwork_getCoupledNetsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaDesignObjectIter* result= new oaDesignObjectIter(data.DataCall()->getCoupledNets());
        return PyoaDesignObjectIter_FromoaDesignObjectIter(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_getDevices_doc[] = 
"Class: oaParasiticNetwork, Function: getDevices\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaDevice_oaParasiticNetwork getDevices() const\n"
"    Signature: getDevices|simple-oaCollection_oaDevice_oaParasiticNetwork|\n"
"    BrowseData: 1\n"
"    This function returns a collection of all the devices belonging to this parasiticNetwork.\n"
;

static PyObject*
oaParasiticNetwork_getDevices(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaDevice_oaParasiticNetwork* result= new oaCollection_oaDevice_oaParasiticNetwork(data.DataCall()->getDevices());
        return PyoaCollection_oaDevice_oaParasiticNetwork_FromoaCollection_oaDevice_oaParasiticNetwork(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_getDevicesIter_doc[] = 
"Class: oaParasiticNetwork, Function: getDevicesIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaDevice getDevicesIter() const\n"
"    Signature: getDevicesIter|simple-oaIter_oaDevice|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of all the devices belonging to this parasiticNetwork.\n"
;

static PyObject*
oaParasiticNetwork_getDevicesIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaDevice* result= new oaIter_oaDevice(data.DataCall()->getDevices());
        return PyoaIter_oaDevice_FromoaIter_oaDevice(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_getDomain_doc[] = 
"Class: oaParasiticNetwork, Function: getDomain\n"
"  Paramegers: ()\n"
"    Calls: oaDomain getDomain() const\n"
"    Signature: getDomain|simple-oaDomain|\n"
"    BrowseData: 1\n"
"    This function returns the domain of this parasitic network, which is the same domain of the net that this parasitic network associates with. The domain will either be oacBlockDomain or oacOccDomain.\n"
;

static PyObject*
oaParasiticNetwork_getDomain(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaDomain* result= new oaDomain(data.DataCall()->getDomain());
        return PyoaDomain_FromoaDomain(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_getName_doc[] = 
"Class: oaParasiticNetwork, Function: getName\n"
"  Paramegers: (oaString)\n"
"    Calls: void getName(oaString& name) const\n"
"    Signature: getName|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function returns the name of this parasiticNetwork.\n"
;

static PyObject*
oaParasiticNetwork_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_getNet_doc[] = 
"Class: oaParasiticNetwork, Function: getNet\n"
"  Paramegers: ()\n"
"    Calls: oaDesignObject* getNet() const\n"
"    Signature: getNet|ptr-oaDesignObject|\n"
"    BrowseData: 1\n"
"    This function returns the net to which this parasitic network belongs. It will either be an oaNet or an oaOccNet .\n"
;

static PyObject*
oaParasiticNetwork_getNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaDesignObjectp result= (data.DataCall()->getNet());
        return PyoaDesignObject_FromoaDesignObject(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_getNodes_doc[] = 
"Class: oaParasiticNetwork, Function: getNodes\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaNode_oaParasiticNetwork getNodes() const\n"
"    Signature: getNodes|simple-oaCollection_oaNode_oaParasiticNetwork|\n"
"    BrowseData: 1\n"
"    This function returns a collection of all the nodes belonging to this parasiticNetwork.\n"
;

static PyObject*
oaParasiticNetwork_getNodes(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaNode_oaParasiticNetwork* result= new oaCollection_oaNode_oaParasiticNetwork(data.DataCall()->getNodes());
        return PyoaCollection_oaNode_oaParasiticNetwork_FromoaCollection_oaNode_oaParasiticNetwork(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_getNodesIter_doc[] = 
"Class: oaParasiticNetwork, Function: getNodesIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaNode getNodesIter() const\n"
"    Signature: getNodesIter|simple-oaIter_oaNode|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of all the nodes belonging to this parasiticNetwork.\n"
;

static PyObject*
oaParasiticNetwork_getNodesIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaNode* result= new oaIter_oaNode(data.DataCall()->getNodes());
        return PyoaIter_oaNode_FromoaIter_oaNode(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_getParent_doc[] = 
"Class: oaParasiticNetwork, Function: getParent\n"
"  Paramegers: ()\n"
"    Calls: oaParasiticNetwork* getParent()\n"
"    Signature: getParent|ptr-oaParasiticNetwork|\n"
"    BrowseData: 1\n"
"    This function returns the parent parasitic network of this parasitic network. Null is returned if this parasitic network does not have a parent.\n"
;

static PyObject*
oaParasiticNetwork_getParent(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaParasiticNetworkp result= (data.DataCall()->getParent());
        return PyoaParasiticNetwork_FromoaParasiticNetwork(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_getPartitions_doc[] = 
"Class: oaParasiticNetwork, Function: getPartitions\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaParasiticNetwork_oaParasiticNetwork getPartitions() const\n"
"    Signature: getPartitions|simple-oaCollection_oaParasiticNetwork_oaParasiticNetwork|\n"
"    BrowseData: 1\n"
"    This function can be used if parasitics are partitioned. It returns a collection of ParasiticNetworks that represent the child partitions of this parent partition. These collections can be returned repeatedly to descend the tree of partitions until a bottom level partition returns an empty collection.\n"
"    When a child partition is first returned by a getNext() call on this collection, it is not yet loaded. The child oaParasiticNetwork may be used to check its name and BBox. That child must be loaded with a call to load(oaBoolean) before any objects in that network can be accessed.\n"
;

static PyObject*
oaParasiticNetwork_getPartitions(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaParasiticNetwork_oaParasiticNetwork* result= new oaCollection_oaParasiticNetwork_oaParasiticNetwork(data.DataCall()->getPartitions());
        return PyoaCollection_oaParasiticNetwork_oaParasiticNetwork_FromoaCollection_oaParasiticNetwork_oaParasiticNetwork(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_getPartitionsIter_doc[] = 
"Class: oaParasiticNetwork, Function: getPartitionsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaParasiticNetwork getPartitionsIter() const\n"
"    Signature: getPartitionsIter|simple-oaIter_oaParasiticNetwork|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function can be used if parasitics are partitioned. It returns a collection of ParasiticNetworks that represent the child partitions of this parent partition. These collections can be returned repeatedly to descend the tree of partitions until a bottom level partition returns an empty collection.\n"
"    When a child partition is first returned by a getNext() call on this collection, it is not yet loaded. The child oaParasiticNetwork may be used to check its name and BBox. That child must be loaded with a call to load(oaBoolean) before any objects in that network can be accessed.\n"
;

static PyObject*
oaParasiticNetwork_getPartitionsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaParasiticNetwork* result= new oaIter_oaParasiticNetwork(data.DataCall()->getPartitions());
        return PyoaIter_oaParasiticNetwork_FromoaIter_oaParasiticNetwork(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_getSubNetworks_doc[] = 
"Class: oaParasiticNetwork, Function: getSubNetworks\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaSubNetwork_oaParasiticNetwork getSubNetworks() const\n"
"    Signature: getSubNetworks|simple-oaCollection_oaSubNetwork_oaParasiticNetwork|\n"
"    BrowseData: 1\n"
"    This function returns a collection of all the subNetworks belonging to this oaParasiticNetwork.\n"
;

static PyObject*
oaParasiticNetwork_getSubNetworks(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaSubNetwork_oaParasiticNetwork* result= new oaCollection_oaSubNetwork_oaParasiticNetwork(data.DataCall()->getSubNetworks());
        return PyoaCollection_oaSubNetwork_oaParasiticNetwork_FromoaCollection_oaSubNetwork_oaParasiticNetwork(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_getSubNetworksIter_doc[] = 
"Class: oaParasiticNetwork, Function: getSubNetworksIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaSubNetwork getSubNetworksIter() const\n"
"    Signature: getSubNetworksIter|simple-oaIter_oaSubNetwork|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of all the subNetworks belonging to this oaParasiticNetwork.\n"
;

static PyObject*
oaParasiticNetwork_getSubNetworksIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaSubNetwork* result= new oaIter_oaSubNetwork(data.DataCall()->getSubNetworks());
        return PyoaIter_oaSubNetwork_FromoaIter_oaSubNetwork(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_isLoaded_doc[] = 
"Class: oaParasiticNetwork, Function: isLoaded\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isLoaded()\n"
"    Signature: isLoaded|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether or not this parasitic network has been loaded.\n"
"    Note that oaParasiticNetwork pointers returned by load() or create() are loaded when they are returned by those calls. Only for child partitions of a partitioned parasitic network can there be valid pointers to unloaded oaParasiticNetworks. At the time that such a pointer is first returned by a getNext() call on the collection returned by getPartitions() , the pointer is not yet loaded, and load() must be called before accessing the objects in that network.\n"
;

static PyObject*
oaParasiticNetwork_isLoaded(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isLoaded());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_isParent_doc[] = 
"Class: oaParasiticNetwork, Function: isParent\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isParent()\n"
"    Signature: isParent|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether or not this parasitic network is a parent of the parasitic network partitions.\n"
;

static PyObject*
oaParasiticNetwork_isParent(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isParent());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_load_doc[] = 
"Class: oaParasiticNetwork, Function: load\n"
"  Paramegers: ()\n"
"    Calls: void load()\n"
"    Signature: load|void-void|simple-oaBoolean,\n"
"    BrowseData: 0\n"
"    This function loads this parasitic network if it has not been loaded. This call is only applicable to partitioned parasitic networks. The reference count for the parasitic network is incremented. If allPartitions is true and this is a parent, all of the descendant partitions will be loaded, and the reference count of each partition will be incremented.\n"
"    Note that an oaParasiticNetwork is not yet loaded when its pointer is first returned from a getPartitions() collection.\n"
"    allPartitions\n"
"    Specifies whether or not to load all partitions.\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: void load(oaBoolean allPartitions)\n"
"    Signature: load|void-void|simple-oaBoolean,\n"
"    This function loads this parasitic network if it has not been loaded. This call is only applicable to partitioned parasitic networks. The reference count for the parasitic network is incremented. If allPartitions is true and this is a parent, all of the descendant partitions will be loaded, and the reference count of each partition will be incremented.\n"
"    Note that an oaParasiticNetwork is not yet loaded when its pointer is first returned from a getPartitions() collection.\n"
"    allPartitions\n"
"    Specifies whether or not to load all partitions.\n"
;

static PyObject*
oaParasiticNetwork_load(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            data.DataCall()->load();
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            data.DataCall()->load(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaParasiticNetwork, function: load, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_setBBox_doc[] = 
"Class: oaParasiticNetwork, Function: setBBox\n"
"  Paramegers: (oaBox)\n"
"    Calls: void setBBox(const oaBox& bBox)\n"
"    Signature: setBBox|void-void|cref-oaBox,\n"
"    This function sets the bounding box of this parasitic network.\n"
"    Note that this BBox is not automatically maintained by OpenAccess. This attribute is provided for partitioned networks. Applications creating partitioned networks generally will break the entire design area into smaller regions that delimit the parasitic devices that will be assigned to a given partition. The bounding box of each region will be stored on its partition.\n"
"    bBox\n"
"    The bounding box to set\n"
;

static PyObject*
oaParasiticNetwork_setBBox(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBox p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBox_Convert,&p1)) {
        data.DataCall()->setBBox(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_setName_doc[] = 
"Class: oaParasiticNetwork, Function: setName\n"
"  Paramegers: (oaString)\n"
"    Calls: void setName(const oaString& name)\n"
"    Signature: setName|void-void|cref-oaString,\n"
"    This function sets the name of this parasitic network.\n"
;

static PyObject*
oaParasiticNetwork_setName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->setName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_unload_doc[] = 
"Class: oaParasiticNetwork, Function: unload\n"
"  Paramegers: ()\n"
"    Calls: void unload()\n"
"    Signature: unload|void-void|\n"
"    BrowseData: 0\n"
"    This function unloads a parasitic network for the specified net and decrements a reference count for the parasitic network. Once the reference count becomes zero, the database is free to page the parasitic network out from memory at any time. After calling unload() , a caller must not continue to use the pointer to this parasiticNetwork object or pointers to any objects within the network.\n"
"    Note that a partitioned parent network will be unloaded when its refCount is 0, even if the refCount kept on any of its loaded child networks is greater than 0.\n"
;

static PyObject*
oaParasiticNetwork_unload(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaParasiticNetworkObject* self=(PyoaParasiticNetworkObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->unload();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_isNull_doc[] =
"Class: oaParasiticNetwork, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaParasiticNetwork_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaParasiticNetwork data;
    int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaParasiticNetwork_assign_doc[] = 
"Class: oaParasiticNetwork, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaParasiticNetwork_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaParasiticNetwork data;
  int convert_status=PyoaParasiticNetwork_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaParasiticNetwork p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaParasiticNetwork_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaParasiticNetwork_methodlist[] = {
    {"destroy",(PyCFunction)oaParasiticNetwork_destroy,METH_VARARGS,oaParasiticNetwork_destroy_doc},
    {"getAnalysisPoints",(PyCFunction)oaParasiticNetwork_getAnalysisPoints,METH_VARARGS,oaParasiticNetwork_getAnalysisPoints_doc},
    {"getAnalysisPointsIter",(PyCFunction)oaParasiticNetwork_getAnalysisPointsIter,METH_VARARGS,oaParasiticNetwork_getAnalysisPointsIter_doc},
    {"getBBox",(PyCFunction)oaParasiticNetwork_getBBox,METH_VARARGS,oaParasiticNetwork_getBBox_doc},
    {"getConnNodes",(PyCFunction)oaParasiticNetwork_getConnNodes,METH_VARARGS,oaParasiticNetwork_getConnNodes_doc},
    {"getConnNodesIter",(PyCFunction)oaParasiticNetwork_getConnNodesIter,METH_VARARGS,oaParasiticNetwork_getConnNodesIter_doc},
    {"getCoupledNets",(PyCFunction)oaParasiticNetwork_getCoupledNets,METH_VARARGS,oaParasiticNetwork_getCoupledNets_doc},
    {"getCoupledNetsIter",(PyCFunction)oaParasiticNetwork_getCoupledNetsIter,METH_VARARGS,oaParasiticNetwork_getCoupledNetsIter_doc},
    {"getDevices",(PyCFunction)oaParasiticNetwork_getDevices,METH_VARARGS,oaParasiticNetwork_getDevices_doc},
    {"getDevicesIter",(PyCFunction)oaParasiticNetwork_getDevicesIter,METH_VARARGS,oaParasiticNetwork_getDevicesIter_doc},
    {"getDomain",(PyCFunction)oaParasiticNetwork_getDomain,METH_VARARGS,oaParasiticNetwork_getDomain_doc},
    {"getName",(PyCFunction)oaParasiticNetwork_getName,METH_VARARGS,oaParasiticNetwork_getName_doc},
    {"getNet",(PyCFunction)oaParasiticNetwork_getNet,METH_VARARGS,oaParasiticNetwork_getNet_doc},
    {"getNodes",(PyCFunction)oaParasiticNetwork_getNodes,METH_VARARGS,oaParasiticNetwork_getNodes_doc},
    {"getNodesIter",(PyCFunction)oaParasiticNetwork_getNodesIter,METH_VARARGS,oaParasiticNetwork_getNodesIter_doc},
    {"getParent",(PyCFunction)oaParasiticNetwork_getParent,METH_VARARGS,oaParasiticNetwork_getParent_doc},
    {"getPartitions",(PyCFunction)oaParasiticNetwork_getPartitions,METH_VARARGS,oaParasiticNetwork_getPartitions_doc},
    {"getPartitionsIter",(PyCFunction)oaParasiticNetwork_getPartitionsIter,METH_VARARGS,oaParasiticNetwork_getPartitionsIter_doc},
    {"getSubNetworks",(PyCFunction)oaParasiticNetwork_getSubNetworks,METH_VARARGS,oaParasiticNetwork_getSubNetworks_doc},
    {"getSubNetworksIter",(PyCFunction)oaParasiticNetwork_getSubNetworksIter,METH_VARARGS,oaParasiticNetwork_getSubNetworksIter_doc},
    {"isLoaded",(PyCFunction)oaParasiticNetwork_isLoaded,METH_VARARGS,oaParasiticNetwork_isLoaded_doc},
    {"isParent",(PyCFunction)oaParasiticNetwork_isParent,METH_VARARGS,oaParasiticNetwork_isParent_doc},
    {"load",(PyCFunction)oaParasiticNetwork_load,METH_VARARGS,oaParasiticNetwork_load_doc},
    {"setBBox",(PyCFunction)oaParasiticNetwork_setBBox,METH_VARARGS,oaParasiticNetwork_setBBox_doc},
    {"setName",(PyCFunction)oaParasiticNetwork_setName,METH_VARARGS,oaParasiticNetwork_setName_doc},
    {"unload",(PyCFunction)oaParasiticNetwork_unload,METH_VARARGS,oaParasiticNetwork_unload_doc},
    {"isNull",(PyCFunction)oaParasiticNetwork_tp_isNull,METH_VARARGS,oaParasiticNetwork_isNull_doc},
    {"assign",(PyCFunction)oaParasiticNetwork_tp_assign,METH_VARARGS,oaParasiticNetwork_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaParasiticNetwork_doc[] = 
"Class: oaParasiticNetwork\n"
"  The oaParasiticNetwork class represents the parasitic elements for a particular net and analysis point pair as a graph containing nodes and devices. Each analysis point can have a separate parasitic network, or values associated with several analysis points can be annotated on a shared parasitic network common to those analysis points.\n"
"  Parasitic networks can be associated with nets in the block and occurrence domains. These networks are generally created by an extractor that analyzes the geometry of the nets to create the parasitics. If the extraction runs hierarchically one block at a time it will create a parasitic network on an oaNet . If it runs on an expanded hierarchy it will write the parasitic network on an oaOccNet .\n"
"  A caller accesses existing oaParasiticNetwork objects by calling the load() function, which loads the network from disk, if necessary. Several different callers can access the same parasitic network at the same time. A reference count is kept to ensure that the parasitic network remains in memory at least until the last caller signals that it is done with the network by calling the unload() function.\n"
"  Note, however, that pointers to the oaParasiticNetwork and to any objects within the network are only valid between a given caller's load() and unload() calls. After calling unload() for a parasitic network, the caller should assume that all of the pointers to that parasitic network's objects are no longer valid (even though the network remains in memory for other callers who have loaded but not yet unloaded the network. Each caller also should assume that the values of the object pointers change each time the same parasitic network is reloaded.\n"
"  Changes made to a parasitic network are preserved across subsequent calls to unload() and load() . As with other design data, changes to parasitic networks do not affect the primary on-disk representation of the design until the changes are saved using oaDesign::save() . Saving a design that contains parasitic networks creates or updates an oaDMFile , detailed_rc.oa , that is a follower of the primary oaDesign database within the oaCellView .\n"
"  When the create() function is used to build a new parasitic network, the data for that network remains in memory until the unload() function is called.\n"
"  Undo, properties, and groups are not supported for oaParasiticNetwork. Extensions on oaParasiticNetwork (and interPointer extensions that refer to an oaParasiticNetwork) are accessible only while the oaParasiticNetwork is loaded.\n"
"  Note: Any change to the connectivity of the net that the ParasiticNetwork is on will cause the ParasiticNetwork to be destroyed. This includes creating, destroying, or moving Terminals or InstTerms.\n"
"  For nets with exceptionally large parasitic graphs, the ParasiticNetwork may be split into a set of partitions. This technique allows selected partitions rather than the entire network to be loaded into memory. Typically, parasitic network partitioning is used for power and ground nets.\n"
"  If partitions are used, the parasitics for a given net and analysis point are represented by a tree of oaParasiticNetworks. There is a top ParasiticNetwork, which has a set of child networks. Each of these child networks, in turn, may have child networks, and so on down the tree. When a child network is in memory, all of its parent partitions also must be in memory, but its siblings need not be.\n"
"  Note that a 2-node device that crosses partitions within a given net may reference a node in one partition, and another node in one of its ancestor partitions, but not in other partitions. Such a device will be stored in the lower of the two partitions. The node in the higher (parent) partition is required to have an id. Therefore a node that is connected to devices in multiple partitions must be created in a common ancestor to those partitions.\n"
"  Also note that unloading a parent network, whose reference count equals 0, also will unload any of its loaded child networks even if the reference count of one or more child networks is greater than 0.\n"
"  The oaParasiticNetwork class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaParasiticNetwork)\n"
"    Calls: (const oaParasiticNetwork&)\n"
"    Signature: oaParasiticNetwork||cref-oaParasiticNetwork,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaParasiticNetwork_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaParasiticNetwork",
    sizeof(PyoaParasiticNetworkObject),
    0,
    (destructor)oaParasiticNetwork_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaParasiticNetwork_tp_compare,	/* tp_compare */
    (reprfunc)oaParasiticNetwork_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaParasiticNetwork_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaParasiticNetwork_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaDesignObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaParasiticNetwork_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaParasiticNetwork_static_create_doc[] = 
"Class: oaParasiticNetwork, Function: create\n"
"  Paramegers: (oaDesignObject,oaAnalysisPointArray)\n"
"    Calls: oaParasiticNetwork* create(oaDesignObject* net,const oaAnalysisPointArray& aps)\n"
"    Signature: create|ptr-oaParasiticNetwork|ptr-oaDesignObject,cref-oaAnalysisPointArray,\n"
"    This function creates a parasitic network for the specified net or occNet, where each node and device in the network will have one value for each of the analysis points in the aps array. An oacParasiticNetworkExists exception will be thrown if a parasitic network already exists for any of the analysis points in the aps array.\n"
"    net\n"
"    The oaNet or oaOccNet for which the oaParasiticNetwork will be created.\n"
"    aps\n"
"    An array of oaAnalysisPoints. Each node and device will have the same number of values as there are oaAnalysisPoints in the array.\n"
"    oacInvalidNet\n"
"    oacParasiticNetworkExists\n"
"  Paramegers: (oaDesignObject,[oaAnalysisPoint])\n"
"    Calls: oaParasiticNetwork* create(oaDesignObject* net, aps)\n"
"    Signature: create|ptr-oaParasiticNetwork|ptr-oaDesignObject,simple-oaUInt4,pptr-oaAnalysisPoint,\n"
"    This function creates a parasitic network for the specified net , where each node and device in the network have numAPs values, one for each of the analysis points in the aps array. The specified net must be either an oaNet , or an oaOccNet .\n"
"    oacInvalidNet\n"
"    oacParasiticNetworkExists\n"
"  Paramegers: (oaParasiticNetwork)\n"
"    Calls: oaParasiticNetwork* create(oaParasiticNetwork* parent)\n"
"    Signature: create|ptr-oaParasiticNetwork|ptr-oaParasiticNetwork,\n"
"    This create function is used when the parasitics are to be partitioned. It creates a partition with the specified parent oaParasiticNetwork as its parent partition. This parasitic network partition will have a generated name.\n"
"  Paramegers: (oaParasiticNetwork,oaString)\n"
"    Calls: oaParasiticNetwork* create(oaParasiticNetwork* parent,const oaString& name)\n"
"    Signature: create|ptr-oaParasiticNetwork|ptr-oaParasiticNetwork,cref-oaString,\n"
"    This create function is used when the parasitics are to be partitioned. It creates a partition with the specified name with the specified parent oaParasiticNetwork as its parent partition. An exception will be thrown if the partition with the specified name already exists in the specified parent parasitic network.\n"
"    oacParasiticNetworkPartitionNameExists\n"
;

static PyObject*
oaParasiticNetwork_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaDesignObject,oaAnalysisPointArray)
    {
        PyParamoaDesignObject p1;
        PyParamoaAnalysisPointArray p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaDesignObject_Convert,&p1,
              &PyoaAnalysisPointArray_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaParasiticNetworkp result= (oaParasiticNetwork::create(p1.Data(),p2.Data()));
            return PyoaParasiticNetwork_FromoaParasiticNetwork(result);
        }
    }
    PyErr_Clear();
    // Case: (oaDesignObject,[oaAnalysisPoint])
    {
        PyParamoaDesignObject p1;
        PyParamoaAnalysisPoint_Array p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaDesignObject_Convert,&p1,
              &PyoaAnalysisPoint_Array_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaParasiticNetworkp result= (oaParasiticNetwork::create(p1.Data(),p2.Len(),p2.Data()));
            return PyoaParasiticNetwork_FromoaParasiticNetwork(result);
        }
    }
    PyErr_Clear();
    // Case: (oaParasiticNetwork)
    {
        PyParamoaParasiticNetwork p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaParasiticNetwork_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaParasiticNetworkp result= (oaParasiticNetwork::create(p1.Data()));
            return PyoaParasiticNetwork_FromoaParasiticNetwork(result);
        }
    }
    PyErr_Clear();
    // Case: (oaParasiticNetwork,oaString)
    {
        PyParamoaParasiticNetwork p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaParasiticNetwork_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaParasiticNetworkp result= (oaParasiticNetwork::create(p1.Data(),p2.Data()));
            return PyoaParasiticNetwork_FromoaParasiticNetwork(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaParasiticNetwork, function: create, Choices are:\n"
        "    (oaDesignObject,oaAnalysisPointArray)\n"
        "    (oaDesignObject,[oaAnalysisPoint])\n"
        "    (oaParasiticNetwork)\n"
        "    (oaParasiticNetwork,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_static_destroy_doc[] = 
"Class: oaParasiticNetwork, Function: destroy\n"
"  Paramegers: (oaDesignObject,oaAnalysisPoint)\n"
"    Calls: void destroy(oaDesignObject* net,const oaAnalysisPoint* ap)\n"
"    Signature: destroy|void-void|ptr-oaDesignObject,cptr-oaAnalysisPoint,\n"
"    This function destroys the parasitic network data associated with the ap analysis point for the specified net . This function will also destroy the data for any other analysis points represented by the same parasitic network.\n"
"    oacInvalidNet\n"
"  Paramegers: (oaDesign,oaAnalysisPoint)\n"
"    Calls: void destroy(oaDesign* design,const oaAnalysisPoint* ap)\n"
"    Signature: destroy|void-void|ptr-oaDesign,cptr-oaAnalysisPoint,\n"
"    This function destroys the parasitic network data associated with the ap analysis point for all nets in the specified design . For parasitic networks that represent other analysis points in addition to ap , this function will also destroy the data for the other analysis points.\n"
"  Paramegers: (oaDesignObject)\n"
"    Calls: void destroy(oaDesignObject* net)\n"
"    Signature: destroy|void-void|ptr-oaDesignObject,\n"
"    This function destroys all parasitic networks for all analysis points for the specified net .\n"
"    oacInvalidNet\n"
"  Paramegers: (oaDesign)\n"
"    Calls: void destroy(oaDesign* design)\n"
"    Signature: destroy|void-void|ptr-oaDesign,\n"
"    This function destroys all parasitic networks for all analysis points for all nets in the specified design .\n"
;

static PyObject*
oaParasiticNetwork_static_destroy(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaDesignObject,oaAnalysisPoint)
    {
        PyParamoaDesignObject p1;
        PyParamoaAnalysisPoint p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaDesignObject_Convert,&p1,
              &PyoaAnalysisPoint_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaParasiticNetwork::destroy(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaAnalysisPoint)
    {
        PyParamoaDesign p1;
        PyParamoaAnalysisPoint p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaAnalysisPoint_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaParasiticNetwork::destroy(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesignObject)
    {
        PyParamoaDesignObject p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDesignObject_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaParasiticNetwork::destroy(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaDesign)
    {
        PyParamoaDesign p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDesign_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaParasiticNetwork::destroy(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaParasiticNetwork, function: destroy, Choices are:\n"
        "    (oaDesignObject,oaAnalysisPoint)\n"
        "    (oaDesign,oaAnalysisPoint)\n"
        "    (oaDesignObject)\n"
        "    (oaDesign)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_static_exists_doc[] = 
"Class: oaParasiticNetwork, Function: exists\n"
"  Paramegers: (oaDesignObject,oaAnalysisPoint)\n"
"    Calls: oaBoolean exists(const oaDesignObject* net,const oaAnalysisPoint* ap)\n"
"    Signature: exists|simple-oaBoolean|cptr-oaDesignObject,cptr-oaAnalysisPoint,\n"
"    This function determines if a parasitic network exists for the specified net and analysis point pair, regardless of whether the parasitic network is currently loaded.\n"
"    oacInvalidNet\n"
;

static PyObject*
oaParasiticNetwork_static_exists(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesignObject p1;
    PyParamoaAnalysisPoint p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaDesignObject_Convert,&p1,
          &PyoaAnalysisPoint_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!PyValidateDbObject(p2.Data(),2)) return NULL;
        oaBoolean result= (oaParasiticNetwork::exists(p1.Data(),p2.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_static_find_doc[] = 
"Class: oaParasiticNetwork, Function: find\n"
"  Paramegers: (oaDesignObject,oaAnalysisPoint)\n"
"    Calls: oaParasiticNetwork* find(const oaDesignObject* net,const oaAnalysisPoint* ap)\n"
"    Signature: find|ptr-oaParasiticNetwork|cptr-oaDesignObject,cptr-oaAnalysisPoint,\n"
"    This function finds a parasitic network for the specified net or occNet that has already been loaded into memory. This function does not change the reference count for the parasitic network. NULL will be returned if the parasitic network is not currently loaded or if no parasitic network exists for the specified net and analysis point.\n"
"    net\n"
"    The oaNet object to search for the parasitic network\n"
"    ap\n"
"    The oaAnalysisPoint object to search for the parasitic network\n"
"    oacInvalidNet\n"
"  Paramegers: (oaParasiticNetwork,oaString)\n"
"    Calls: oaParasiticNetwork* find(const oaParasiticNetwork* parent,const oaString& name)\n"
"    Signature: find|ptr-oaParasiticNetwork|cptr-oaParasiticNetwork,cref-oaString,\n"
"    This function finds a parasitic network partition for the specified parasitic network with the specified name. This function does not change the reference count for the parasitic network. NULL will be returned if the parasitic network partition does not exists or is not fully loaded.\n"
"    parent\n"
"    The parent parasitic network to search for the partition\n"
"    name\n"
"    The name of the partition network\n"
;

static PyObject*
oaParasiticNetwork_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaDesignObject,oaAnalysisPoint)
    {
        PyParamoaDesignObject p1;
        PyParamoaAnalysisPoint p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaDesignObject_Convert,&p1,
              &PyoaAnalysisPoint_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaParasiticNetworkp result= (oaParasiticNetwork::find(p1.Data(),p2.Data()));
            return PyoaParasiticNetwork_FromoaParasiticNetwork(result);
        }
    }
    PyErr_Clear();
    // Case: (oaParasiticNetwork,oaString)
    {
        PyParamoaParasiticNetwork p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaParasiticNetwork_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaParasiticNetworkp result= (oaParasiticNetwork::find(p1.Data(),p2.Data()));
            return PyoaParasiticNetwork_FromoaParasiticNetwork(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaParasiticNetwork, function: find, Choices are:\n"
        "    (oaDesignObject,oaAnalysisPoint)\n"
        "    (oaParasiticNetwork,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaParasiticNetwork_static_load_doc[] = 
"Class: oaParasiticNetwork, Function: load\n"
"  Paramegers: (oaDesignObject,oaAnalysisPoint)\n"
"    Calls: oaParasiticNetwork* load(const oaDesignObject* net,const oaAnalysisPoint* ap)\n"
"    Signature: load|ptr-oaParasiticNetwork|cptr-oaDesignObject,cptr-oaAnalysisPoint,simple-oaBoolean,\n"
"    This function loads a parasitic network for the specified net or occNet into memory if it is not already loaded. The reference count for the parasitic network is incremented. If allPartitions is true, all partitions of this parasitic network will loaded, and the reference count of each partition will be incremented. An exception will be thrown if the parasitic network does not exist.\n"
"    net\n"
"    The oaNet or oaOccNet in which to search for the parasitic network\n"
"    ap\n"
"    The analysis point in which to search for the parasitic network\n"
"    allPartitions\n"
"    Specifies whether or not to load all partitions\n"
"    oacNoParasiticNetworkToLoad\n"
"  Paramegers: (oaDesignObject,oaAnalysisPoint,oaBoolean)\n"
"    Calls: oaParasiticNetwork* load(const oaDesignObject* net,const oaAnalysisPoint* ap,oaBoolean allPartitions)\n"
"    Signature: load|ptr-oaParasiticNetwork|cptr-oaDesignObject,cptr-oaAnalysisPoint,simple-oaBoolean,\n"
"    This function loads a parasitic network for the specified net or occNet into memory if it is not already loaded. The reference count for the parasitic network is incremented. If allPartitions is true, all partitions of this parasitic network will loaded, and the reference count of each partition will be incremented. An exception will be thrown if the parasitic network does not exist.\n"
"    net\n"
"    The oaNet or oaOccNet in which to search for the parasitic network\n"
"    ap\n"
"    The analysis point in which to search for the parasitic network\n"
"    allPartitions\n"
"    Specifies whether or not to load all partitions\n"
"    oacNoParasiticNetworkToLoad\n"
;

static PyObject*
oaParasiticNetwork_static_load(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaDesignObject,oaAnalysisPoint)
    {
        PyParamoaDesignObject p1;
        PyParamoaAnalysisPoint p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaDesignObject_Convert,&p1,
              &PyoaAnalysisPoint_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaParasiticNetworkp result= (oaParasiticNetwork::load(p1.Data(),p2.Data()));
            return PyoaParasiticNetwork_FromoaParasiticNetwork(result);
        }
    }
    PyErr_Clear();
    // Case: (oaDesignObject,oaAnalysisPoint,oaBoolean)
    {
        PyParamoaDesignObject p1;
        PyParamoaAnalysisPoint p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaDesignObject_Convert,&p1,
              &PyoaAnalysisPoint_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaParasiticNetworkp result= (oaParasiticNetwork::load(p1.Data(),p2.Data(),p3.Data()));
            return PyoaParasiticNetwork_FromoaParasiticNetwork(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaParasiticNetwork, function: load, Choices are:\n"
        "    (oaDesignObject,oaAnalysisPoint)\n"
        "    (oaDesignObject,oaAnalysisPoint,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaParasiticNetwork_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaParasiticNetwork_static_create,METH_VARARGS,oaParasiticNetwork_static_create_doc},
    {"static_destroy",(PyCFunction)oaParasiticNetwork_static_destroy,METH_VARARGS,oaParasiticNetwork_static_destroy_doc},
    {"static_exists",(PyCFunction)oaParasiticNetwork_static_exists,METH_VARARGS,oaParasiticNetwork_static_exists_doc},
    {"static_find",(PyCFunction)oaParasiticNetwork_static_find,METH_VARARGS,oaParasiticNetwork_static_find_doc},
    {"static_load",(PyCFunction)oaParasiticNetwork_static_load,METH_VARARGS,oaParasiticNetwork_static_load_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaParasiticNetwork_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaParasiticNetwork_Type)<0) {
      printf("** PyType_Ready failed for: oaParasiticNetwork\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaParasiticNetwork",
           (PyObject*)(&PyoaParasiticNetwork_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaParasiticNetwork\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaParasiticNetwork_Type.tp_dict;
    for(method=oaParasiticNetwork_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaParasiticNetworkModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaParasiticNetworkModTypeEnum_Convert(PyObject* ob,PyParamoaParasiticNetworkModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacSetNameParasiticNetworkModType")==0) { result->SetData(oacSetNameParasiticNetworkModType); return 1;}
        if (strcasecmp(str,"oacSetBBoxParasiticNetworkModType")==0) { result->SetData(oacSetBBoxParasiticNetworkModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaParasiticNetworkModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaParasiticNetworkModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaParasiticNetworkModTypeEnum_FromoaParasiticNetworkModTypeEnum(oaParasiticNetworkModTypeEnum ob)
{
    if (ob==oacSetNameParasiticNetworkModType) return PyString_FromString("oacSetNameParasiticNetworkModType");
    if (ob==oacSetBBoxParasiticNetworkModType) return PyString_FromString("oacSetBBoxParasiticNetworkModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaParasiticNetworkModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaParasiticNetworkModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaParasiticNetworkModTypeEnum_FromoaParasiticNetworkModTypeEnum(oaParasiticNetworkModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaParasiticNetworkModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaParasiticNetworkModTypeEnum_doc[] =
"Type convert function for enum: oaParasiticNetworkModTypeEnum";
                               
static PyMethodDef PyoaParasiticNetworkModTypeEnum_method =
  {"oaParasiticNetworkModTypeEnum",(PyCFunction)PyoaParasiticNetworkModTypeEnum_TypeFunction,METH_VARARGS,oaParasiticNetworkModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaParasiticNetworkModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacSetNameParasiticNetworkModType");
    PyDict_SetItemString(mod_dict,"oacSetNameParasiticNetworkModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetBBoxParasiticNetworkModType");
    PyDict_SetItemString(mod_dict,"oacSetBBoxParasiticNetworkModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaParasiticNetworkModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaParasiticNetworkModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaParasiticNetworkModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}
