
/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDMMsgIds
// ==================================================================

// ------------------------------------------------------------------

int
PyoaDMMsgIds_Convert(PyObject* ob,PyParamoaDMMsgIds* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacInvalidLib")==0) { result->SetData(oacInvalidLib); return 1;}
        if (strcasecmp(str,"oacNotALib")==0) { result->SetData(oacNotALib); return 1;}
        if (strcasecmp(str,"oacLibNameExists")==0) { result->SetData(oacLibNameExists); return 1;}
        if (strcasecmp(str,"oacLibNotFound")==0) { result->SetData(oacLibNotFound); return 1;}
        if (strcasecmp(str,"oacCellNotFound")==0) { result->SetData(oacCellNotFound); return 1;}
        if (strcasecmp(str,"oacViewNotFound")==0) { result->SetData(oacViewNotFound); return 1;}
        if (strcasecmp(str,"oacLibCouldNotCreate")==0) { result->SetData(oacLibCouldNotCreate); return 1;}
        if (strcasecmp(str,"oacLibCouldNotOpen")==0) { result->SetData(oacLibCouldNotOpen); return 1;}
        if (strcasecmp(str,"oacInvalidLibDataTypeName")==0) { result->SetData(oacInvalidLibDataTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidDMObject")==0) { result->SetData(oacInvalidDMObject); return 1;}
        if (strcasecmp(str,"oacInvalidContainer")==0) { result->SetData(oacInvalidContainer); return 1;}
        if (strcasecmp(str,"oacInvalidCell")==0) { result->SetData(oacInvalidCell); return 1;}
        if (strcasecmp(str,"oacInvalidView")==0) { result->SetData(oacInvalidView); return 1;}
        if (strcasecmp(str,"oacInvalidViewType")==0) { result->SetData(oacInvalidViewType); return 1;}
        if (strcasecmp(str,"oacViewTypeExists")==0) { result->SetData(oacViewTypeExists); return 1;}
        if (strcasecmp(str,"oacInvalidReservedViewTypeName")==0) { result->SetData(oacInvalidReservedViewTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidCellView")==0) { result->SetData(oacInvalidCellView); return 1;}
        if (strcasecmp(str,"oacCellViewNotInSameLib")==0) { result->SetData(oacCellViewNotInSameLib); return 1;}
        if (strcasecmp(str,"oacCVExists")==0) { result->SetData(oacCVExists); return 1;}
        if (strcasecmp(str,"oacCVSetViewPrimaryFileExists")==0) { result->SetData(oacCVSetViewPrimaryFileExists); return 1;}
        if (strcasecmp(str,"oacCVSetViewPrimaryFileLocked")==0) { result->SetData(oacCVSetViewPrimaryFileLocked); return 1;}
        if (strcasecmp(str,"oacInvalidDMFile")==0) { result->SetData(oacInvalidDMFile); return 1;}
        if (strcasecmp(str,"oacDMFileExists")==0) { result->SetData(oacDMFileExists); return 1;}
        if (strcasecmp(str,"oacDMFileDoesNotExistOnDisk")==0) { result->SetData(oacDMFileDoesNotExistOnDisk); return 1;}
        if (strcasecmp(str,"oacDMFileCouldNotCreate")==0) { result->SetData(oacDMFileCouldNotCreate); return 1;}
        if (strcasecmp(str,"oacDMFileCannotLockFollower")==0) { result->SetData(oacDMFileCannotLockFollower); return 1;}
        if (strcasecmp(str,"oacDMFileCannotUnlockFollower")==0) { result->SetData(oacDMFileCannotUnlockFollower); return 1;}
        if (strcasecmp(str,"oacDMFileCannotSetLeaderOnLocked")==0) { result->SetData(oacDMFileCannotSetLeaderOnLocked); return 1;}
        if (strcasecmp(str,"oacInvalidLibAccessName")==0) { result->SetData(oacInvalidLibAccessName); return 1;}
        if (strcasecmp(str,"oacInvalidLibModeName")==0) { result->SetData(oacInvalidLibModeName); return 1;}
        if (strcasecmp(str,"oacLibDefFileSyntaxError")==0) { result->SetData(oacLibDefFileSyntaxError); return 1;}
        if (strcasecmp(str,"oacLibDefFileCannotOpenInclude")==0) { result->SetData(oacLibDefFileCannotOpenInclude); return 1;}
        if (strcasecmp(str,"oacLibDefFileRecursiveInclude")==0) { result->SetData(oacLibDefFileRecursiveInclude); return 1;}
        if (strcasecmp(str,"oacLibDefFileInvalidCommand")==0) { result->SetData(oacLibDefFileInvalidCommand); return 1;}
        if (strcasecmp(str,"oacLibDefFileFailedToGetLibName")==0) { result->SetData(oacLibDefFileFailedToGetLibName); return 1;}
        if (strcasecmp(str,"oacLibDefFileFailedToGetLibPath")==0) { result->SetData(oacLibDefFileFailedToGetLibPath); return 1;}
        if (strcasecmp(str,"oacLibDefFileFailedToGetAttrName")==0) { result->SetData(oacLibDefFileFailedToGetAttrName); return 1;}
        if (strcasecmp(str,"oacLibDefFileFailedToGetAttrVal")==0) { result->SetData(oacLibDefFileFailedToGetAttrVal); return 1;}
        if (strcasecmp(str,"oacLibDefFileFailedToGetIncludePath")==0) { result->SetData(oacLibDefFileFailedToGetIncludePath); return 1;}
        if (strcasecmp(str,"oacLibDefFileMultipleDefinitions")==0) { result->SetData(oacLibDefFileMultipleDefinitions); return 1;}
        if (strcasecmp(str,"oacLibDefFileCannotOpenFile")==0) { result->SetData(oacLibDefFileCannotOpenFile); return 1;}
        if (strcasecmp(str,"oacFailedToGetDMInterface")==0) { result->SetData(oacFailedToGetDMInterface); return 1;}
        if (strcasecmp(str,"oacInterfaceException")==0) { result->SetData(oacInterfaceException); return 1;}
        if (strcasecmp(str,"oacCannotHaveMultiLevelFollowers")==0) { result->SetData(oacCannotHaveMultiLevelFollowers); return 1;}
        if (strcasecmp(str,"oacPrimaryCannotBeFollower")==0) { result->SetData(oacPrimaryCannotBeFollower); return 1;}
        if (strcasecmp(str,"oacLeaderFollowerNotInSameParent")==0) { result->SetData(oacLeaderFollowerNotInSameParent); return 1;}
        if (strcasecmp(str,"oacFailedToGetLockingInterface")==0) { result->SetData(oacFailedToGetLockingInterface); return 1;}
        if (strcasecmp(str,"oacInvalidVCCapName")==0) { result->SetData(oacInvalidVCCapName); return 1;}
        if (strcasecmp(str,"oacInvalidVersionCompName")==0) { result->SetData(oacInvalidVersionCompName); return 1;}
        if (strcasecmp(str,"oacInvalidVCOperationName")==0) { result->SetData(oacInvalidVCOperationName); return 1;}
        if (strcasecmp(str,"oacInvalidVCMessageTypeName")==0) { result->SetData(oacInvalidVCMessageTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidVCObserverResultName")==0) { result->SetData(oacInvalidVCObserverResultName); return 1;}
        if (strcasecmp(str,"oacInvalidVCQueryDepthName")==0) { result->SetData(oacInvalidVCQueryDepthName); return 1;}
        if (strcasecmp(str,"oacVersionControlNotInstalled")==0) { result->SetData(oacVersionControlNotInstalled); return 1;}
        if (strcasecmp(str,"oacLibAccessCannotUpgrade")==0) { result->SetData(oacLibAccessCannotUpgrade); return 1;}
        if (strcasecmp(str,"oacLibReleaseNoAccess")==0) { result->SetData(oacLibReleaseNoAccess); return 1;}
        if (strcasecmp(str,"oacLibHasNoAccess")==0) { result->SetData(oacLibHasNoAccess); return 1;}
        if (strcasecmp(str,"oacLibAccessDenied")==0) { result->SetData(oacLibAccessDenied); return 1;}
        if (strcasecmp(str,"oacCannotOpenOpenedLib")==0) { result->SetData(oacCannotOpenOpenedLib); return 1;}
        if (strcasecmp(str,"oacInvalidLibName")==0) { result->SetData(oacInvalidLibName); return 1;}
        if (strcasecmp(str,"oacLibNameDoesNotMatchPath")==0) { result->SetData(oacLibNameDoesNotMatchPath); return 1;}
        if (strcasecmp(str,"oacInvalidLibDefList")==0) { result->SetData(oacInvalidLibDefList); return 1;}
        if (strcasecmp(str,"oacInvalidLibDefListMem")==0) { result->SetData(oacInvalidLibDefListMem); return 1;}
        if (strcasecmp(str,"oacInvalidLibDefListMemMove")==0) { result->SetData(oacInvalidLibDefListMemMove); return 1;}
        if (strcasecmp(str,"oacInvalidLibDefListMemCreate")==0) { result->SetData(oacInvalidLibDefListMemCreate); return 1;}
        if (strcasecmp(str,"oacLibDefExists")==0) { result->SetData(oacLibDefExists); return 1;}
        if (strcasecmp(str,"oacLibDefListRefExists")==0) { result->SetData(oacLibDefListRefExists); return 1;}
        if (strcasecmp(str,"oacUndefinedLibDefListMode")==0) { result->SetData(oacUndefinedLibDefListMode); return 1;}
        if (strcasecmp(str,"oacLibDefListFileNotWritable")==0) { result->SetData(oacLibDefListFileNotWritable); return 1;}
        if (strcasecmp(str,"oacLibDefListFileNotReadable")==0) { result->SetData(oacLibDefListFileNotReadable); return 1;}
        if (strcasecmp(str,"oacSaveReadOnlyLibDefList")==0) { result->SetData(oacSaveReadOnlyLibDefList); return 1;}
        if (strcasecmp(str,"oacUnableToOpenLibDescFile")==0) { result->SetData(oacUnableToOpenLibDescFile); return 1;}
        if (strcasecmp(str,"oacInvalidDMTransTypeName")==0) { result->SetData(oacInvalidDMTransTypeName); return 1;}
        if (strcasecmp(str,"oacInvalidDMDataTypeName")==0) { result->SetData(oacInvalidDMDataTypeName); return 1;}
        if (strcasecmp(str,"oacOpenUndefinedModeDMData")==0) { result->SetData(oacOpenUndefinedModeDMData); return 1;}
        if (strcasecmp(str,"oacNotADMData")==0) { result->SetData(oacNotADMData); return 1;}
        if (strcasecmp(str,"oacInvalidDMDataObject")==0) { result->SetData(oacInvalidDMDataObject); return 1;}
        if (strcasecmp(str,"oacInvalidDMData")==0) { result->SetData(oacInvalidDMData); return 1;}
        if (strcasecmp(str,"oacDMDataDoesNotExist")==0) { result->SetData(oacDMDataDoesNotExist); return 1;}
        if (strcasecmp(str,"oacCannotLockDMData")==0) { result->SetData(oacCannotLockDMData); return 1;}
        if (strcasecmp(str,"oacOpenOnDMDataBeingPurged")==0) { result->SetData(oacOpenOnDMDataBeingPurged); return 1;}
        if (strcasecmp(str,"oacCloseOnDMDataBeingPurged")==0) { result->SetData(oacCloseOnDMDataBeingPurged); return 1;}
        if (strcasecmp(str,"oacPurgeOnDMDataBeingPurged")==0) { result->SetData(oacPurgeOnDMDataBeingPurged); return 1;}
        if (strcasecmp(str,"oacSaveReadOnlyDMData")==0) { result->SetData(oacSaveReadOnlyDMData); return 1;}
        if (strcasecmp(str,"oacDestroyDMDataOpen")==0) { result->SetData(oacDestroyDMDataOpen); return 1;}
        if (strcasecmp(str,"oacDestroyDMDataDoesNotExist")==0) { result->SetData(oacDestroyDMDataDoesNotExist); return 1;}
        if (strcasecmp(str,"oacDMDataCannotGetReadAccess")==0) { result->SetData(oacDMDataCannotGetReadAccess); return 1;}
        if (strcasecmp(str,"oacDMDataCannotGetWriteAccess")==0) { result->SetData(oacDMDataCannotGetWriteAccess); return 1;}
        if (strcasecmp(str,"oacDMDataHasReadNeedWriteAccess")==0) { result->SetData(oacDMDataHasReadNeedWriteAccess); return 1;}
        if (strcasecmp(str,"oacInvalidDMDataTypeForTimeStamp")==0) { result->SetData(oacInvalidDMDataTypeForTimeStamp); return 1;}
        if (strcasecmp(str,"oacInvalidLibAccessLevelName")==0) { result->SetData(oacInvalidLibAccessLevelName); return 1;}
        if (strcasecmp(str,"oacLibExists")==0) { result->SetData(oacLibExists); return 1;}
        if (strcasecmp(str,"oacLibVCSystemAlreadyDefined")==0) { result->SetData(oacLibVCSystemAlreadyDefined); return 1;}
        if (strcasecmp(str,"oacLibOpenedInNonSharedMode")==0) { result->SetData(oacLibOpenedInNonSharedMode); return 1;}
        if (strcasecmp(str,"oacCannotDestroyLockedObject")==0) { result->SetData(oacCannotDestroyLockedObject); return 1;}
        if (strcasecmp(str,"oacReleaseLockNoLock")==0) { result->SetData(oacReleaseLockNoLock); return 1;}
        if (strcasecmp(str,"oacUnableToCreateTempFile")==0) { result->SetData(oacUnableToCreateTempFile); return 1;}
        if (strcasecmp(str,"oacCellViewOwnerDoesNotExist")==0) { result->SetData(oacCellViewOwnerDoesNotExist); return 1;}
        if (strcasecmp(str,"oacCVSetViewPrimaryFileDoesNotExist")==0) { result->SetData(oacCVSetViewPrimaryFileDoesNotExist); return 1;}
        if (strcasecmp(str,"oacFSLockDNotActive")==0) { result->SetData(oacFSLockDNotActive); return 1;}
        if (strcasecmp(str,"oacLibDefFileUndefinedVarLibPath")==0) { result->SetData(oacLibDefFileUndefinedVarLibPath); return 1;}
        if (strcasecmp(str,"oacLibDefFileUndefinedVarIncludePath")==0) { result->SetData(oacLibDefFileUndefinedVarIncludePath); return 1;}
        if (strcasecmp(str,"oacLibDefFileUndefinedVarWritePath")==0) { result->SetData(oacLibDefFileUndefinedVarWritePath); return 1;}
        if (strcasecmp(str,"oacLibDefFileCannotAppendSymbolicLink")==0) { result->SetData(oacLibDefFileCannotAppendSymbolicLink); return 1;}
        if (strcasecmp(str,"oacNoWriteAccessOnReadOnlyLib")==0) { result->SetData(oacNoWriteAccessOnReadOnlyLib); return 1;}
        if (strcasecmp(str,"oacCannotDestroyObjectWithCacheActive")==0) { result->SetData(oacCannotDestroyObjectWithCacheActive); return 1;}
        if (strcasecmp(str,"oacInvalidCSMessageLength")==0) { result->SetData(oacInvalidCSMessageLength); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaDMMsgIds)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDMMsgIds Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaDMMsgIds_FromoaDMMsgIds(oaDMMsgIds ob)
{
    if (ob==oacInvalidLib) return PyString_FromString("oacInvalidLib");
    if (ob==oacNotALib) return PyString_FromString("oacNotALib");
    if (ob==oacLibNameExists) return PyString_FromString("oacLibNameExists");
    if (ob==oacLibNotFound) return PyString_FromString("oacLibNotFound");
    if (ob==oacCellNotFound) return PyString_FromString("oacCellNotFound");
    if (ob==oacViewNotFound) return PyString_FromString("oacViewNotFound");
    if (ob==oacLibCouldNotCreate) return PyString_FromString("oacLibCouldNotCreate");
    if (ob==oacLibCouldNotOpen) return PyString_FromString("oacLibCouldNotOpen");
    if (ob==oacInvalidLibDataTypeName) return PyString_FromString("oacInvalidLibDataTypeName");
    if (ob==oacInvalidDMObject) return PyString_FromString("oacInvalidDMObject");
    if (ob==oacInvalidContainer) return PyString_FromString("oacInvalidContainer");
    if (ob==oacInvalidCell) return PyString_FromString("oacInvalidCell");
    if (ob==oacInvalidView) return PyString_FromString("oacInvalidView");
    if (ob==oacInvalidViewType) return PyString_FromString("oacInvalidViewType");
    if (ob==oacViewTypeExists) return PyString_FromString("oacViewTypeExists");
    if (ob==oacInvalidReservedViewTypeName) return PyString_FromString("oacInvalidReservedViewTypeName");
    if (ob==oacInvalidCellView) return PyString_FromString("oacInvalidCellView");
    if (ob==oacCellViewNotInSameLib) return PyString_FromString("oacCellViewNotInSameLib");
    if (ob==oacCVExists) return PyString_FromString("oacCVExists");
    if (ob==oacCVSetViewPrimaryFileExists) return PyString_FromString("oacCVSetViewPrimaryFileExists");
    if (ob==oacCVSetViewPrimaryFileLocked) return PyString_FromString("oacCVSetViewPrimaryFileLocked");
    if (ob==oacInvalidDMFile) return PyString_FromString("oacInvalidDMFile");
    if (ob==oacDMFileExists) return PyString_FromString("oacDMFileExists");
    if (ob==oacDMFileDoesNotExistOnDisk) return PyString_FromString("oacDMFileDoesNotExistOnDisk");
    if (ob==oacDMFileCouldNotCreate) return PyString_FromString("oacDMFileCouldNotCreate");
    if (ob==oacDMFileCannotLockFollower) return PyString_FromString("oacDMFileCannotLockFollower");
    if (ob==oacDMFileCannotUnlockFollower) return PyString_FromString("oacDMFileCannotUnlockFollower");
    if (ob==oacDMFileCannotSetLeaderOnLocked) return PyString_FromString("oacDMFileCannotSetLeaderOnLocked");
    if (ob==oacInvalidLibAccessName) return PyString_FromString("oacInvalidLibAccessName");
    if (ob==oacInvalidLibModeName) return PyString_FromString("oacInvalidLibModeName");
    if (ob==oacLibDefFileSyntaxError) return PyString_FromString("oacLibDefFileSyntaxError");
    if (ob==oacLibDefFileCannotOpenInclude) return PyString_FromString("oacLibDefFileCannotOpenInclude");
    if (ob==oacLibDefFileRecursiveInclude) return PyString_FromString("oacLibDefFileRecursiveInclude");
    if (ob==oacLibDefFileInvalidCommand) return PyString_FromString("oacLibDefFileInvalidCommand");
    if (ob==oacLibDefFileFailedToGetLibName) return PyString_FromString("oacLibDefFileFailedToGetLibName");
    if (ob==oacLibDefFileFailedToGetLibPath) return PyString_FromString("oacLibDefFileFailedToGetLibPath");
    if (ob==oacLibDefFileFailedToGetAttrName) return PyString_FromString("oacLibDefFileFailedToGetAttrName");
    if (ob==oacLibDefFileFailedToGetAttrVal) return PyString_FromString("oacLibDefFileFailedToGetAttrVal");
    if (ob==oacLibDefFileFailedToGetIncludePath) return PyString_FromString("oacLibDefFileFailedToGetIncludePath");
    if (ob==oacLibDefFileMultipleDefinitions) return PyString_FromString("oacLibDefFileMultipleDefinitions");
    if (ob==oacLibDefFileCannotOpenFile) return PyString_FromString("oacLibDefFileCannotOpenFile");
    if (ob==oacFailedToGetDMInterface) return PyString_FromString("oacFailedToGetDMInterface");
    if (ob==oacInterfaceException) return PyString_FromString("oacInterfaceException");
    if (ob==oacCannotHaveMultiLevelFollowers) return PyString_FromString("oacCannotHaveMultiLevelFollowers");
    if (ob==oacPrimaryCannotBeFollower) return PyString_FromString("oacPrimaryCannotBeFollower");
    if (ob==oacLeaderFollowerNotInSameParent) return PyString_FromString("oacLeaderFollowerNotInSameParent");
    if (ob==oacFailedToGetLockingInterface) return PyString_FromString("oacFailedToGetLockingInterface");
    if (ob==oacInvalidVCCapName) return PyString_FromString("oacInvalidVCCapName");
    if (ob==oacInvalidVersionCompName) return PyString_FromString("oacInvalidVersionCompName");
    if (ob==oacInvalidVCOperationName) return PyString_FromString("oacInvalidVCOperationName");
    if (ob==oacInvalidVCMessageTypeName) return PyString_FromString("oacInvalidVCMessageTypeName");
    if (ob==oacInvalidVCObserverResultName) return PyString_FromString("oacInvalidVCObserverResultName");
    if (ob==oacInvalidVCQueryDepthName) return PyString_FromString("oacInvalidVCQueryDepthName");
    if (ob==oacVersionControlNotInstalled) return PyString_FromString("oacVersionControlNotInstalled");
    if (ob==oacLibAccessCannotUpgrade) return PyString_FromString("oacLibAccessCannotUpgrade");
    if (ob==oacLibReleaseNoAccess) return PyString_FromString("oacLibReleaseNoAccess");
    if (ob==oacLibHasNoAccess) return PyString_FromString("oacLibHasNoAccess");
    if (ob==oacLibAccessDenied) return PyString_FromString("oacLibAccessDenied");
    if (ob==oacCannotOpenOpenedLib) return PyString_FromString("oacCannotOpenOpenedLib");
    if (ob==oacInvalidLibName) return PyString_FromString("oacInvalidLibName");
    if (ob==oacLibNameDoesNotMatchPath) return PyString_FromString("oacLibNameDoesNotMatchPath");
    if (ob==oacInvalidLibDefList) return PyString_FromString("oacInvalidLibDefList");
    if (ob==oacInvalidLibDefListMem) return PyString_FromString("oacInvalidLibDefListMem");
    if (ob==oacInvalidLibDefListMemMove) return PyString_FromString("oacInvalidLibDefListMemMove");
    if (ob==oacInvalidLibDefListMemCreate) return PyString_FromString("oacInvalidLibDefListMemCreate");
    if (ob==oacLibDefExists) return PyString_FromString("oacLibDefExists");
    if (ob==oacLibDefListRefExists) return PyString_FromString("oacLibDefListRefExists");
    if (ob==oacUndefinedLibDefListMode) return PyString_FromString("oacUndefinedLibDefListMode");
    if (ob==oacLibDefListFileNotWritable) return PyString_FromString("oacLibDefListFileNotWritable");
    if (ob==oacLibDefListFileNotReadable) return PyString_FromString("oacLibDefListFileNotReadable");
    if (ob==oacSaveReadOnlyLibDefList) return PyString_FromString("oacSaveReadOnlyLibDefList");
    if (ob==oacUnableToOpenLibDescFile) return PyString_FromString("oacUnableToOpenLibDescFile");
    if (ob==oacInvalidDMTransTypeName) return PyString_FromString("oacInvalidDMTransTypeName");
    if (ob==oacInvalidDMDataTypeName) return PyString_FromString("oacInvalidDMDataTypeName");
    if (ob==oacOpenUndefinedModeDMData) return PyString_FromString("oacOpenUndefinedModeDMData");
    if (ob==oacNotADMData) return PyString_FromString("oacNotADMData");
    if (ob==oacInvalidDMDataObject) return PyString_FromString("oacInvalidDMDataObject");
    if (ob==oacInvalidDMData) return PyString_FromString("oacInvalidDMData");
    if (ob==oacDMDataDoesNotExist) return PyString_FromString("oacDMDataDoesNotExist");
    if (ob==oacCannotLockDMData) return PyString_FromString("oacCannotLockDMData");
    if (ob==oacOpenOnDMDataBeingPurged) return PyString_FromString("oacOpenOnDMDataBeingPurged");
    if (ob==oacCloseOnDMDataBeingPurged) return PyString_FromString("oacCloseOnDMDataBeingPurged");
    if (ob==oacPurgeOnDMDataBeingPurged) return PyString_FromString("oacPurgeOnDMDataBeingPurged");
    if (ob==oacSaveReadOnlyDMData) return PyString_FromString("oacSaveReadOnlyDMData");
    if (ob==oacDestroyDMDataOpen) return PyString_FromString("oacDestroyDMDataOpen");
    if (ob==oacDestroyDMDataDoesNotExist) return PyString_FromString("oacDestroyDMDataDoesNotExist");
    if (ob==oacDMDataCannotGetReadAccess) return PyString_FromString("oacDMDataCannotGetReadAccess");
    if (ob==oacDMDataCannotGetWriteAccess) return PyString_FromString("oacDMDataCannotGetWriteAccess");
    if (ob==oacDMDataHasReadNeedWriteAccess) return PyString_FromString("oacDMDataHasReadNeedWriteAccess");
    if (ob==oacInvalidDMDataTypeForTimeStamp) return PyString_FromString("oacInvalidDMDataTypeForTimeStamp");
    if (ob==oacInvalidLibAccessLevelName) return PyString_FromString("oacInvalidLibAccessLevelName");
    if (ob==oacLibExists) return PyString_FromString("oacLibExists");
    if (ob==oacLibVCSystemAlreadyDefined) return PyString_FromString("oacLibVCSystemAlreadyDefined");
    if (ob==oacLibOpenedInNonSharedMode) return PyString_FromString("oacLibOpenedInNonSharedMode");
    if (ob==oacCannotDestroyLockedObject) return PyString_FromString("oacCannotDestroyLockedObject");
    if (ob==oacReleaseLockNoLock) return PyString_FromString("oacReleaseLockNoLock");
    if (ob==oacUnableToCreateTempFile) return PyString_FromString("oacUnableToCreateTempFile");
    if (ob==oacCellViewOwnerDoesNotExist) return PyString_FromString("oacCellViewOwnerDoesNotExist");
    if (ob==oacCVSetViewPrimaryFileDoesNotExist) return PyString_FromString("oacCVSetViewPrimaryFileDoesNotExist");
    if (ob==oacFSLockDNotActive) return PyString_FromString("oacFSLockDNotActive");
    if (ob==oacLibDefFileUndefinedVarLibPath) return PyString_FromString("oacLibDefFileUndefinedVarLibPath");
    if (ob==oacLibDefFileUndefinedVarIncludePath) return PyString_FromString("oacLibDefFileUndefinedVarIncludePath");
    if (ob==oacLibDefFileUndefinedVarWritePath) return PyString_FromString("oacLibDefFileUndefinedVarWritePath");
    if (ob==oacLibDefFileCannotAppendSymbolicLink) return PyString_FromString("oacLibDefFileCannotAppendSymbolicLink");
    if (ob==oacNoWriteAccessOnReadOnlyLib) return PyString_FromString("oacNoWriteAccessOnReadOnlyLib");
    if (ob==oacCannotDestroyObjectWithCacheActive) return PyString_FromString("oacCannotDestroyObjectWithCacheActive");
    if (ob==oacInvalidCSMessageLength) return PyString_FromString("oacInvalidCSMessageLength");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaDMMsgIds_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaDMMsgIds e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaDMMsgIds_FromoaDMMsgIds(oaDMMsgIds(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaDMMsgIds_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaDMMsgIds_doc[] =
"Type convert function for enum: oaDMMsgIds";
                               
static PyMethodDef PyoaDMMsgIds_method =
  {"oaDMMsgIds",(PyCFunction)PyoaDMMsgIds_TypeFunction,METH_VARARGS,oaDMMsgIds_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaDMMsgIds_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacInvalidLib");
    PyDict_SetItemString(mod_dict,"oacInvalidLib",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNotALib");
    PyDict_SetItemString(mod_dict,"oacNotALib",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibNameExists");
    PyDict_SetItemString(mod_dict,"oacLibNameExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibNotFound");
    PyDict_SetItemString(mod_dict,"oacLibNotFound",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCellNotFound");
    PyDict_SetItemString(mod_dict,"oacCellNotFound",value);
    Py_DECREF(value);
    value=PyString_FromString("oacViewNotFound");
    PyDict_SetItemString(mod_dict,"oacViewNotFound",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibCouldNotCreate");
    PyDict_SetItemString(mod_dict,"oacLibCouldNotCreate",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibCouldNotOpen");
    PyDict_SetItemString(mod_dict,"oacLibCouldNotOpen",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidLibDataTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidLibDataTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDMObject");
    PyDict_SetItemString(mod_dict,"oacInvalidDMObject",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidContainer");
    PyDict_SetItemString(mod_dict,"oacInvalidContainer",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidCell");
    PyDict_SetItemString(mod_dict,"oacInvalidCell",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidView");
    PyDict_SetItemString(mod_dict,"oacInvalidView",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidViewType");
    PyDict_SetItemString(mod_dict,"oacInvalidViewType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacViewTypeExists");
    PyDict_SetItemString(mod_dict,"oacViewTypeExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidReservedViewTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidReservedViewTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidCellView");
    PyDict_SetItemString(mod_dict,"oacInvalidCellView",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCellViewNotInSameLib");
    PyDict_SetItemString(mod_dict,"oacCellViewNotInSameLib",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCVExists");
    PyDict_SetItemString(mod_dict,"oacCVExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCVSetViewPrimaryFileExists");
    PyDict_SetItemString(mod_dict,"oacCVSetViewPrimaryFileExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCVSetViewPrimaryFileLocked");
    PyDict_SetItemString(mod_dict,"oacCVSetViewPrimaryFileLocked",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDMFile");
    PyDict_SetItemString(mod_dict,"oacInvalidDMFile",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDMFileExists");
    PyDict_SetItemString(mod_dict,"oacDMFileExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDMFileDoesNotExistOnDisk");
    PyDict_SetItemString(mod_dict,"oacDMFileDoesNotExistOnDisk",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDMFileCouldNotCreate");
    PyDict_SetItemString(mod_dict,"oacDMFileCouldNotCreate",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDMFileCannotLockFollower");
    PyDict_SetItemString(mod_dict,"oacDMFileCannotLockFollower",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDMFileCannotUnlockFollower");
    PyDict_SetItemString(mod_dict,"oacDMFileCannotUnlockFollower",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDMFileCannotSetLeaderOnLocked");
    PyDict_SetItemString(mod_dict,"oacDMFileCannotSetLeaderOnLocked",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidLibAccessName");
    PyDict_SetItemString(mod_dict,"oacInvalidLibAccessName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidLibModeName");
    PyDict_SetItemString(mod_dict,"oacInvalidLibModeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibDefFileSyntaxError");
    PyDict_SetItemString(mod_dict,"oacLibDefFileSyntaxError",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibDefFileCannotOpenInclude");
    PyDict_SetItemString(mod_dict,"oacLibDefFileCannotOpenInclude",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibDefFileRecursiveInclude");
    PyDict_SetItemString(mod_dict,"oacLibDefFileRecursiveInclude",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibDefFileInvalidCommand");
    PyDict_SetItemString(mod_dict,"oacLibDefFileInvalidCommand",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibDefFileFailedToGetLibName");
    PyDict_SetItemString(mod_dict,"oacLibDefFileFailedToGetLibName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibDefFileFailedToGetLibPath");
    PyDict_SetItemString(mod_dict,"oacLibDefFileFailedToGetLibPath",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibDefFileFailedToGetAttrName");
    PyDict_SetItemString(mod_dict,"oacLibDefFileFailedToGetAttrName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibDefFileFailedToGetAttrVal");
    PyDict_SetItemString(mod_dict,"oacLibDefFileFailedToGetAttrVal",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibDefFileFailedToGetIncludePath");
    PyDict_SetItemString(mod_dict,"oacLibDefFileFailedToGetIncludePath",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibDefFileMultipleDefinitions");
    PyDict_SetItemString(mod_dict,"oacLibDefFileMultipleDefinitions",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibDefFileCannotOpenFile");
    PyDict_SetItemString(mod_dict,"oacLibDefFileCannotOpenFile",value);
    Py_DECREF(value);
    value=PyString_FromString("oacFailedToGetDMInterface");
    PyDict_SetItemString(mod_dict,"oacFailedToGetDMInterface",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInterfaceException");
    PyDict_SetItemString(mod_dict,"oacInterfaceException",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotHaveMultiLevelFollowers");
    PyDict_SetItemString(mod_dict,"oacCannotHaveMultiLevelFollowers",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPrimaryCannotBeFollower");
    PyDict_SetItemString(mod_dict,"oacPrimaryCannotBeFollower",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLeaderFollowerNotInSameParent");
    PyDict_SetItemString(mod_dict,"oacLeaderFollowerNotInSameParent",value);
    Py_DECREF(value);
    value=PyString_FromString("oacFailedToGetLockingInterface");
    PyDict_SetItemString(mod_dict,"oacFailedToGetLockingInterface",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidVCCapName");
    PyDict_SetItemString(mod_dict,"oacInvalidVCCapName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidVersionCompName");
    PyDict_SetItemString(mod_dict,"oacInvalidVersionCompName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidVCOperationName");
    PyDict_SetItemString(mod_dict,"oacInvalidVCOperationName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidVCMessageTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidVCMessageTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidVCObserverResultName");
    PyDict_SetItemString(mod_dict,"oacInvalidVCObserverResultName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidVCQueryDepthName");
    PyDict_SetItemString(mod_dict,"oacInvalidVCQueryDepthName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacVersionControlNotInstalled");
    PyDict_SetItemString(mod_dict,"oacVersionControlNotInstalled",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibAccessCannotUpgrade");
    PyDict_SetItemString(mod_dict,"oacLibAccessCannotUpgrade",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibReleaseNoAccess");
    PyDict_SetItemString(mod_dict,"oacLibReleaseNoAccess",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibHasNoAccess");
    PyDict_SetItemString(mod_dict,"oacLibHasNoAccess",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibAccessDenied");
    PyDict_SetItemString(mod_dict,"oacLibAccessDenied",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotOpenOpenedLib");
    PyDict_SetItemString(mod_dict,"oacCannotOpenOpenedLib",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidLibName");
    PyDict_SetItemString(mod_dict,"oacInvalidLibName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibNameDoesNotMatchPath");
    PyDict_SetItemString(mod_dict,"oacLibNameDoesNotMatchPath",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidLibDefList");
    PyDict_SetItemString(mod_dict,"oacInvalidLibDefList",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidLibDefListMem");
    PyDict_SetItemString(mod_dict,"oacInvalidLibDefListMem",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidLibDefListMemMove");
    PyDict_SetItemString(mod_dict,"oacInvalidLibDefListMemMove",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidLibDefListMemCreate");
    PyDict_SetItemString(mod_dict,"oacInvalidLibDefListMemCreate",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibDefExists");
    PyDict_SetItemString(mod_dict,"oacLibDefExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibDefListRefExists");
    PyDict_SetItemString(mod_dict,"oacLibDefListRefExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacUndefinedLibDefListMode");
    PyDict_SetItemString(mod_dict,"oacUndefinedLibDefListMode",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibDefListFileNotWritable");
    PyDict_SetItemString(mod_dict,"oacLibDefListFileNotWritable",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibDefListFileNotReadable");
    PyDict_SetItemString(mod_dict,"oacLibDefListFileNotReadable",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSaveReadOnlyLibDefList");
    PyDict_SetItemString(mod_dict,"oacSaveReadOnlyLibDefList",value);
    Py_DECREF(value);
    value=PyString_FromString("oacUnableToOpenLibDescFile");
    PyDict_SetItemString(mod_dict,"oacUnableToOpenLibDescFile",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDMTransTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidDMTransTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDMDataTypeName");
    PyDict_SetItemString(mod_dict,"oacInvalidDMDataTypeName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOpenUndefinedModeDMData");
    PyDict_SetItemString(mod_dict,"oacOpenUndefinedModeDMData",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNotADMData");
    PyDict_SetItemString(mod_dict,"oacNotADMData",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDMDataObject");
    PyDict_SetItemString(mod_dict,"oacInvalidDMDataObject",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDMData");
    PyDict_SetItemString(mod_dict,"oacInvalidDMData",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDMDataDoesNotExist");
    PyDict_SetItemString(mod_dict,"oacDMDataDoesNotExist",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotLockDMData");
    PyDict_SetItemString(mod_dict,"oacCannotLockDMData",value);
    Py_DECREF(value);
    value=PyString_FromString("oacOpenOnDMDataBeingPurged");
    PyDict_SetItemString(mod_dict,"oacOpenOnDMDataBeingPurged",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCloseOnDMDataBeingPurged");
    PyDict_SetItemString(mod_dict,"oacCloseOnDMDataBeingPurged",value);
    Py_DECREF(value);
    value=PyString_FromString("oacPurgeOnDMDataBeingPurged");
    PyDict_SetItemString(mod_dict,"oacPurgeOnDMDataBeingPurged",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSaveReadOnlyDMData");
    PyDict_SetItemString(mod_dict,"oacSaveReadOnlyDMData",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDestroyDMDataOpen");
    PyDict_SetItemString(mod_dict,"oacDestroyDMDataOpen",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDestroyDMDataDoesNotExist");
    PyDict_SetItemString(mod_dict,"oacDestroyDMDataDoesNotExist",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDMDataCannotGetReadAccess");
    PyDict_SetItemString(mod_dict,"oacDMDataCannotGetReadAccess",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDMDataCannotGetWriteAccess");
    PyDict_SetItemString(mod_dict,"oacDMDataCannotGetWriteAccess",value);
    Py_DECREF(value);
    value=PyString_FromString("oacDMDataHasReadNeedWriteAccess");
    PyDict_SetItemString(mod_dict,"oacDMDataHasReadNeedWriteAccess",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidDMDataTypeForTimeStamp");
    PyDict_SetItemString(mod_dict,"oacInvalidDMDataTypeForTimeStamp",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidLibAccessLevelName");
    PyDict_SetItemString(mod_dict,"oacInvalidLibAccessLevelName",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibExists");
    PyDict_SetItemString(mod_dict,"oacLibExists",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibVCSystemAlreadyDefined");
    PyDict_SetItemString(mod_dict,"oacLibVCSystemAlreadyDefined",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibOpenedInNonSharedMode");
    PyDict_SetItemString(mod_dict,"oacLibOpenedInNonSharedMode",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotDestroyLockedObject");
    PyDict_SetItemString(mod_dict,"oacCannotDestroyLockedObject",value);
    Py_DECREF(value);
    value=PyString_FromString("oacReleaseLockNoLock");
    PyDict_SetItemString(mod_dict,"oacReleaseLockNoLock",value);
    Py_DECREF(value);
    value=PyString_FromString("oacUnableToCreateTempFile");
    PyDict_SetItemString(mod_dict,"oacUnableToCreateTempFile",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCellViewOwnerDoesNotExist");
    PyDict_SetItemString(mod_dict,"oacCellViewOwnerDoesNotExist",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCVSetViewPrimaryFileDoesNotExist");
    PyDict_SetItemString(mod_dict,"oacCVSetViewPrimaryFileDoesNotExist",value);
    Py_DECREF(value);
    value=PyString_FromString("oacFSLockDNotActive");
    PyDict_SetItemString(mod_dict,"oacFSLockDNotActive",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibDefFileUndefinedVarLibPath");
    PyDict_SetItemString(mod_dict,"oacLibDefFileUndefinedVarLibPath",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibDefFileUndefinedVarIncludePath");
    PyDict_SetItemString(mod_dict,"oacLibDefFileUndefinedVarIncludePath",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibDefFileUndefinedVarWritePath");
    PyDict_SetItemString(mod_dict,"oacLibDefFileUndefinedVarWritePath",value);
    Py_DECREF(value);
    value=PyString_FromString("oacLibDefFileCannotAppendSymbolicLink");
    PyDict_SetItemString(mod_dict,"oacLibDefFileCannotAppendSymbolicLink",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNoWriteAccessOnReadOnlyLib");
    PyDict_SetItemString(mod_dict,"oacNoWriteAccessOnReadOnlyLib",value);
    Py_DECREF(value);
    value=PyString_FromString("oacCannotDestroyObjectWithCacheActive");
    PyDict_SetItemString(mod_dict,"oacCannotDestroyObjectWithCacheActive",value);
    Py_DECREF(value);
    value=PyString_FromString("oacInvalidCSMessageLength");
    PyDict_SetItemString(mod_dict,"oacInvalidCSMessageLength",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaDMMsgIds_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaDMMsgIds",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaDMMsgIds\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDMObject
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDMObject_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDMObject_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDMObjectObject* self = (PyoaDMObjectObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDMObject)
    {
        PyParamoaDMObject p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDMObject_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDMObject, Choices are:\n"
        "    (oaDMObject)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDMObject_tp_dealloc(PyoaDMObjectObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDMObject_tp_repr(PyObject *ob)
{
    PyParamoaDMObject value;
    int convert_status=PyoaDMObject_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[32];
    sprintf(buffer,"<oaDMObject::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDMObject_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDMObject v1;
    PyParamoaDMObject v2;
    int convert_status1=PyoaDMObject_Convert(ob1,&v1);
    int convert_status2=PyoaDMObject_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDMObject_Convert(PyObject* ob,PyParamoaDMObject* result)
{
    if (ob == NULL) return 1;
    if (PyoaDMObject_Check(ob)) {
        result->SetData( (oaDMObject**) ((PyoaDMObjectObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDMObject Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDMObject_FromoaDMObject(oaDMObject** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDMObject* data=*value;
        if (data->getType()==oacCellViewType) return PyoaCellView_FromoaCellView((oaCellView**)value,borrow,lock);
        if (data->getType()==oacDMFileType) return PyoaDMFile_FromoaDMFile((oaDMFile**)value,borrow,lock);
        if (data->getType()==oacLibType) return PyoaLib_FromoaLib((oaLib**)value,borrow,lock);
        if (data->getType()==oacCellType) return PyoaCell_FromoaCell((oaCell**)value,borrow,lock);
        if (data->getType()==oacViewType) return PyoaView_FromoaView((oaView**)value,borrow,lock);
        PyObject* bself = PyoaDMObject_Type.tp_alloc(&PyoaDMObject_Type,0);
        if (bself == NULL) return bself;
        PyoaDMObjectObject* self = (PyoaDMObjectObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDMObject_FromoaDMObject(oaDMObject* data)
{
    if (data) {
        if (data->getType()==oacCellViewType) return PyoaCellView_FromoaCellView((oaCellView*)data);
        if (data->getType()==oacDMFileType) return PyoaDMFile_FromoaDMFile((oaDMFile*)data);
        if (data->getType()==oacLibType) return PyoaLib_FromoaLib((oaLib*)data);
        if (data->getType()==oacCellType) return PyoaCell_FromoaCell((oaCell*)data);
        if (data->getType()==oacViewType) return PyoaView_FromoaView((oaView*)data);
       PyObject* bself = PyoaDMObject_Type.tp_alloc(&PyoaDMObject_Type,0);
       if (bself == NULL) return bself;
       PyoaDMObjectObject* self = (PyoaDMObjectObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDMObject_cancelEdit_doc[] = 
"Class: oaDMObject, Function: cancelEdit\n"
"  Paramegers: ()\n"
"    Calls: void cancelEdit()\n"
"    Signature: cancelEdit|void-void|simple-oaBoolean,cptr-oaChar,\n"
"    BrowseData: 0\n"
"    oaDMObject::cancelEdit\n"
"    This function is only active when a Version Control system is in place for the library this object is in. It will cancel the editable state of the object (and it's children if \"recurse\" is set to \"true\"). Note that in most VC systems this operation will cause the underlying file(s) to revert to what's currently in the repository.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    recurse\n"
"    signals to the version control system to apply this operation to all children of this object.\n"
"    options\n"
"    a string that represents options that are specific to the version control system that's install for this library.\n"
"    oacLibAccessDenied\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: void cancelEdit(oaBoolean recurse)\n"
"    Signature: cancelEdit|void-void|simple-oaBoolean,cptr-oaChar,\n"
"    oaDMObject::cancelEdit\n"
"    This function is only active when a Version Control system is in place for the library this object is in. It will cancel the editable state of the object (and it's children if \"recurse\" is set to \"true\"). Note that in most VC systems this operation will cause the underlying file(s) to revert to what's currently in the repository.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    recurse\n"
"    signals to the version control system to apply this operation to all children of this object.\n"
"    options\n"
"    a string that represents options that are specific to the version control system that's install for this library.\n"
"    oacLibAccessDenied\n"
"  Paramegers: (oaBoolean,[oaChar])\n"
"    Calls: void cancelEdit(oaBoolean recurse,const oaChar* options)\n"
"    Signature: cancelEdit|void-void|simple-oaBoolean,cptr-oaChar,\n"
"    oaDMObject::cancelEdit\n"
"    This function is only active when a Version Control system is in place for the library this object is in. It will cancel the editable state of the object (and it's children if \"recurse\" is set to \"true\"). Note that in most VC systems this operation will cause the underlying file(s) to revert to what's currently in the repository.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    recurse\n"
"    signals to the version control system to apply this operation to all children of this object.\n"
"    options\n"
"    a string that represents options that are specific to the version control system that's install for this library.\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaDMObject_cancelEdit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDMObject data;
    int convert_status=PyoaDMObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDMObjectObject* self=(PyoaDMObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            data.DataCall()->cancelEdit();
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            data.DataCall()->cancelEdit(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean,[oaChar])
    {
        PyParamoaBoolean p1;
        PyParamoaChar_Array p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBoolean_Convert,&p1,
              &PyoaChar_Array_Convert,&p2)) {
            data.DataCall()->cancelEdit(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDMObject, function: cancelEdit, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
        "    (oaBoolean,[oaChar])\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDMObject_commitEdits_doc[] = 
"Class: oaDMObject, Function: commitEdits\n"
"  Paramegers: ([oaChar])\n"
"    Calls: void commitEdits(const oaChar* comment)\n"
"    Signature: commitEdits|void-void|cptr-oaChar,simple-oaBoolean,simple-oaBoolean,cptr-oaChar,\n"
"    oaDMObject::commitEdits\n"
"    This function is only active when a Version Control system is in place for the library this object is in. It will commit the current set of edits to this object to the version control system's repository.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    comment\n"
"    the comment that will be stored with the new version of this object in the repository\n"
"    recurse\n"
"    signals to the version control system to apply this operation to all children of this object.\n"
"    keepEditable\n"
"    setting this to true is equivalent to calling \"makeEditable\" immediately after this function\n"
"    options\n"
"    a string that represents options that are specific to the version control system that's install for this library.\n"
"    oacLibAccessDenied\n"
"  Paramegers: ([oaChar],oaBoolean)\n"
"    Calls: void commitEdits(const oaChar* comment,oaBoolean recurse)\n"
"    Signature: commitEdits|void-void|cptr-oaChar,simple-oaBoolean,simple-oaBoolean,cptr-oaChar,\n"
"    oaDMObject::commitEdits\n"
"    This function is only active when a Version Control system is in place for the library this object is in. It will commit the current set of edits to this object to the version control system's repository.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    comment\n"
"    the comment that will be stored with the new version of this object in the repository\n"
"    recurse\n"
"    signals to the version control system to apply this operation to all children of this object.\n"
"    keepEditable\n"
"    setting this to true is equivalent to calling \"makeEditable\" immediately after this function\n"
"    options\n"
"    a string that represents options that are specific to the version control system that's install for this library.\n"
"    oacLibAccessDenied\n"
"  Paramegers: ([oaChar],oaBoolean,oaBoolean)\n"
"    Calls: void commitEdits(const oaChar* comment,oaBoolean recurse,oaBoolean keepEditable)\n"
"    Signature: commitEdits|void-void|cptr-oaChar,simple-oaBoolean,simple-oaBoolean,cptr-oaChar,\n"
"    oaDMObject::commitEdits\n"
"    This function is only active when a Version Control system is in place for the library this object is in. It will commit the current set of edits to this object to the version control system's repository.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    comment\n"
"    the comment that will be stored with the new version of this object in the repository\n"
"    recurse\n"
"    signals to the version control system to apply this operation to all children of this object.\n"
"    keepEditable\n"
"    setting this to true is equivalent to calling \"makeEditable\" immediately after this function\n"
"    options\n"
"    a string that represents options that are specific to the version control system that's install for this library.\n"
"    oacLibAccessDenied\n"
"  Paramegers: ([oaChar],oaBoolean,oaBoolean,[oaChar])\n"
"    Calls: void commitEdits(const oaChar* comment,oaBoolean recurse,oaBoolean keepEditable,const oaChar* options)\n"
"    Signature: commitEdits|void-void|cptr-oaChar,simple-oaBoolean,simple-oaBoolean,cptr-oaChar,\n"
"    oaDMObject::commitEdits\n"
"    This function is only active when a Version Control system is in place for the library this object is in. It will commit the current set of edits to this object to the version control system's repository.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    comment\n"
"    the comment that will be stored with the new version of this object in the repository\n"
"    recurse\n"
"    signals to the version control system to apply this operation to all children of this object.\n"
"    keepEditable\n"
"    setting this to true is equivalent to calling \"makeEditable\" immediately after this function\n"
"    options\n"
"    a string that represents options that are specific to the version control system that's install for this library.\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaDMObject_commitEdits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDMObject data;
    int convert_status=PyoaDMObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDMObjectObject* self=(PyoaDMObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ([oaChar])
    {
        PyParamoaChar_Array p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaChar_Array_Convert,&p1)) {
            data.DataCall()->commitEdits(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: ([oaChar],oaBoolean)
    {
        PyParamoaChar_Array p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaChar_Array_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->commitEdits(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: ([oaChar],oaBoolean,oaBoolean)
    {
        PyParamoaChar_Array p1;
        PyParamoaBoolean p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaChar_Array_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            data.DataCall()->commitEdits(p1.Data(),p2.Data(),p3.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: ([oaChar],oaBoolean,oaBoolean,[oaChar])
    {
        PyParamoaChar_Array p1;
        PyParamoaBoolean p2;
        PyParamoaBoolean p3;
        PyParamoaChar_Array p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaChar_Array_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaBoolean_Convert,&p3,
              &PyoaChar_Array_Convert,&p4)) {
            data.DataCall()->commitEdits(p1.Data(),p2.Data(),p3.Data(),p4.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDMObject, function: commitEdits, Choices are:\n"
        "    ([oaChar])\n"
        "    ([oaChar],oaBoolean)\n"
        "    ([oaChar],oaBoolean,oaBoolean)\n"
        "    ([oaChar],oaBoolean,oaBoolean,[oaChar])\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDMObject_getLib_doc[] = 
"Class: oaDMObject, Function: getLib\n"
"  Paramegers: ()\n"
"    Calls: oaLib* getLib() const\n"
"    Signature: getLib|ptr-oaLib|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the library database associated with this object.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    oacInvalidContainer\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaDMObject_getLib(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDMObject data;
    int convert_status=PyoaDMObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDMObjectObject* self=(PyoaDMObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaLibp result= (data.DataCall()->getLib());
        return PyoaLib_FromoaLib(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDMObject_getTempFile_doc[] = 
"Class: oaDMObject, Function: getTempFile\n"
"  Paramegers: (oaString)\n"
"    Calls: void getTempFile(oaString& path) const\n"
"    Signature: getTempFile|void-void|ref-oaString,simple-oaBoolean,\n"
"    BrowseData: 0,oaString\n"
"    This function returns a path to a new, unique, temporary file which is associated with this object. Temporary files are not DM objects, and the management of such files is left up to the application. Temporary files are expected to be process-specific. The user may specify the directory to create the temporary file in by using the writePath argument in oaLib::open() . If the library being used has been created in the process with oaLib::create() , then the library directory is assumed to be writeable and is used for temporary file creation.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    path\n"
"    returned unique path to the temp file associated with this object.\n"
"    sameFileSystem\n"
"    A boolean flag indicating whether the temp file should be created on the same file system as the one that the library is on\n"
"    oacLibAccessDenied\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: void getTempFile(oaString& path,oaBoolean sameFileSystem) const\n"
"    Signature: getTempFile|void-void|ref-oaString,simple-oaBoolean,\n"
"    This function returns a path to a new, unique, temporary file which is associated with this object. Temporary files are not DM objects, and the management of such files is left up to the application. Temporary files are expected to be process-specific. The user may specify the directory to create the temporary file in by using the writePath argument in oaLib::open() . If the library being used has been created in the process with oaLib::create() , then the library directory is assumed to be writeable and is used for temporary file creation.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    path\n"
"    returned unique path to the temp file associated with this object.\n"
"    sameFileSystem\n"
"    A boolean flag indicating whether the temp file should be created on the same file system as the one that the library is on\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaDMObject_getTempFile(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDMObject data;
    int convert_status=PyoaDMObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDMObjectObject* self=(PyoaDMObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            data.DataCall()->getTempFile(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->getTempFile(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDMObject, function: getTempFile, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDMObject_getVCStatus_doc[] = 
"Class: oaDMObject, Function: getVCStatus\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getVCStatus() const\n"
"    Signature: getVCStatus|simple-oaUInt4|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    oaDMObject::getVCStatus\n"
"    This function is only active when a Version Control system is in place for the library this object is in. It gets the version control status of the object. This status only relates to the given object and is not hierarchical.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    mask\n"
"    this parameter is used to limit the status bits being retrieved. Some types of status are more expensive to discover than others; use this mask to optimize performance\n"
"    oacLibAccessDenied\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaUInt4 getVCStatus(oaUInt4 mask) const\n"
"    Signature: getVCStatus|simple-oaUInt4|simple-oaUInt4,\n"
"    oaDMObject::getVCStatus\n"
"    This function is only active when a Version Control system is in place for the library this object is in. It gets the version control status of the object. This status only relates to the given object and is not hierarchical.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    mask\n"
"    this parameter is used to limit the status bits being retrieved. Some types of status are more expensive to discover than others; use this mask to optimize performance\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaDMObject_getVCStatus(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDMObject data;
    int convert_status=PyoaDMObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDMObjectObject* self=(PyoaDMObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaUInt4 result= (data.DataCall()->getVCStatus());
            return PyoaUInt4_FromoaUInt4(result);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaUInt4 result= (data.DataCall()->getVCStatus(p1.Data()));
            return PyoaUInt4_FromoaUInt4(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDMObject, function: getVCStatus, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDMObject_getVersions_doc[] = 
"Class: oaDMObject, Function: getVersions\n"
"  Paramegers: ()\n"
"    Calls: oaVCVersionIter getVersions() const\n"
"    Signature: getVersions|simple-oaVCVersionIter|\n"
"    BrowseData: 1\n"
"    This function gets the versions that exist for this object in the form of an oaVCVersionIter . This information is for this object only and is not recursive.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaDMObject_getVersions(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDMObject data;
    int convert_status=PyoaDMObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDMObjectObject* self=(PyoaDMObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaVCVersionIter* result= new oaVCVersionIter(data.DataCall()->getVersions());
        return PyoaVCVersionIter_FromoaVCVersionIter(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDMObject_isContainer_doc[] = 
"Class: oaDMObject, Function: isContainer\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isContainer() const\n"
"    Signature: isContainer|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns true if this object is an oaDMContainer object implying that it is either an oaLib , oaCell , oaView or an oaCellView object.\n"
;

static PyObject*
oaDMObject_isContainer(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDMObject data;
    int convert_status=PyoaDMObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDMObjectObject* self=(PyoaDMObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isContainer());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDMObject_makeEditable_doc[] = 
"Class: oaDMObject, Function: makeEditable\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: void makeEditable(oaBoolean lock)\n"
"    Signature: makeEditable|void-void|simple-oaBoolean,simple-oaBoolean,cptr-oaChar,\n"
"    oaDMObject::makeEditable\n"
"    This function is only active when a Version Control system is in place for the library this object is in. It will set the version control access mode of the object (and it's children if \"recurse\" is \"true\") to be editable. On some version control systems this could result in a check-out of the underlying file(s).\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    lock\n"
"    if this parameter is true, the file(s) will be locked after this call returns\n"
"    recurse\n"
"    signals to the version control system to apply this operation to all children of this object.\n"
"    options\n"
"    a string that represents options that are specific to the version control system that's install for this library.\n"
"    oacLibAccessDenied\n"
"  Paramegers: (oaBoolean,oaBoolean)\n"
"    Calls: void makeEditable(oaBoolean lock,oaBoolean recurse)\n"
"    Signature: makeEditable|void-void|simple-oaBoolean,simple-oaBoolean,cptr-oaChar,\n"
"    oaDMObject::makeEditable\n"
"    This function is only active when a Version Control system is in place for the library this object is in. It will set the version control access mode of the object (and it's children if \"recurse\" is \"true\") to be editable. On some version control systems this could result in a check-out of the underlying file(s).\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    lock\n"
"    if this parameter is true, the file(s) will be locked after this call returns\n"
"    recurse\n"
"    signals to the version control system to apply this operation to all children of this object.\n"
"    options\n"
"    a string that represents options that are specific to the version control system that's install for this library.\n"
"    oacLibAccessDenied\n"
"  Paramegers: (oaBoolean,oaBoolean,[oaChar])\n"
"    Calls: void makeEditable(oaBoolean lock,oaBoolean recurse,const oaChar* options)\n"
"    Signature: makeEditable|void-void|simple-oaBoolean,simple-oaBoolean,cptr-oaChar,\n"
"    oaDMObject::makeEditable\n"
"    This function is only active when a Version Control system is in place for the library this object is in. It will set the version control access mode of the object (and it's children if \"recurse\" is \"true\") to be editable. On some version control systems this could result in a check-out of the underlying file(s).\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    lock\n"
"    if this parameter is true, the file(s) will be locked after this call returns\n"
"    recurse\n"
"    signals to the version control system to apply this operation to all children of this object.\n"
"    options\n"
"    a string that represents options that are specific to the version control system that's install for this library.\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaDMObject_makeEditable(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDMObject data;
    int convert_status=PyoaDMObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDMObjectObject* self=(PyoaDMObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            data.DataCall()->makeEditable(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean,oaBoolean)
    {
        PyParamoaBoolean p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBoolean_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->makeEditable(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean,oaBoolean,[oaChar])
    {
        PyParamoaBoolean p1;
        PyParamoaBoolean p2;
        PyParamoaChar_Array p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaBoolean_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaChar_Array_Convert,&p3)) {
            data.DataCall()->makeEditable(p1.Data(),p2.Data(),p3.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDMObject, function: makeEditable, Choices are:\n"
        "    (oaBoolean)\n"
        "    (oaBoolean,oaBoolean)\n"
        "    (oaBoolean,oaBoolean,[oaChar])\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDMObject_setControlled_doc[] = 
"Class: oaDMObject, Function: setControlled\n"
"  Paramegers: ()\n"
"    Calls: void setControlled()\n"
"    Signature: setControlled|void-void|simple-oaBoolean,cptr-oaChar,\n"
"    BrowseData: 0\n"
"    oaDMObject::setControlled\n"
"    This function is only active when a Version Control system is in place for the library this object is in. It adds the object to the version control system's repository.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    recurse\n"
"    signals to the version control system to apply this operation to all children of this object.\n"
"    options\n"
"    a string that represents options that are specific to the version control system that's install for this library.\n"
"    oacLibAccessDenied\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: void setControlled(oaBoolean recurse)\n"
"    Signature: setControlled|void-void|simple-oaBoolean,cptr-oaChar,\n"
"    oaDMObject::setControlled\n"
"    This function is only active when a Version Control system is in place for the library this object is in. It adds the object to the version control system's repository.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    recurse\n"
"    signals to the version control system to apply this operation to all children of this object.\n"
"    options\n"
"    a string that represents options that are specific to the version control system that's install for this library.\n"
"    oacLibAccessDenied\n"
"  Paramegers: (oaBoolean,[oaChar])\n"
"    Calls: void setControlled(oaBoolean recurse,const oaChar* options)\n"
"    Signature: setControlled|void-void|simple-oaBoolean,cptr-oaChar,\n"
"    oaDMObject::setControlled\n"
"    This function is only active when a Version Control system is in place for the library this object is in. It adds the object to the version control system's repository.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    recurse\n"
"    signals to the version control system to apply this operation to all children of this object.\n"
"    options\n"
"    a string that represents options that are specific to the version control system that's install for this library.\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaDMObject_setControlled(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDMObject data;
    int convert_status=PyoaDMObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDMObjectObject* self=(PyoaDMObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            data.DataCall()->setControlled();
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            data.DataCall()->setControlled(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean,[oaChar])
    {
        PyParamoaBoolean p1;
        PyParamoaChar_Array p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBoolean_Convert,&p1,
              &PyoaChar_Array_Convert,&p2)) {
            data.DataCall()->setControlled(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDMObject, function: setControlled, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
        "    (oaBoolean,[oaChar])\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDMObject_unsetControlled_doc[] = 
"Class: oaDMObject, Function: unsetControlled\n"
"  Paramegers: ()\n"
"    Calls: void unsetControlled()\n"
"    Signature: unsetControlled|void-void|simple-oaBoolean,simple-oaBoolean,cptr-oaChar,\n"
"    BrowseData: 0\n"
"    This function is only active when a Version Control system is in place for the library this object is in. It will remove the object from the version control systems repository. if keepLocalRep is \"false\" the local file will also be removed.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    recurse\n"
"    signals to the version control system to apply this operation to all children of this object.\n"
"    keepLocalRep\n"
"    set to true to prevent the local file from being removed from disk after it is removed from the version control repository\n"
"    options\n"
"    a string that represents options that are specific to the version control system that's install for this library.\n"
"    oacLibAccessDenied\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: void unsetControlled(oaBoolean recurse)\n"
"    Signature: unsetControlled|void-void|simple-oaBoolean,simple-oaBoolean,cptr-oaChar,\n"
"    This function is only active when a Version Control system is in place for the library this object is in. It will remove the object from the version control systems repository. if keepLocalRep is \"false\" the local file will also be removed.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    recurse\n"
"    signals to the version control system to apply this operation to all children of this object.\n"
"    keepLocalRep\n"
"    set to true to prevent the local file from being removed from disk after it is removed from the version control repository\n"
"    options\n"
"    a string that represents options that are specific to the version control system that's install for this library.\n"
"    oacLibAccessDenied\n"
"  Paramegers: (oaBoolean,oaBoolean)\n"
"    Calls: void unsetControlled(oaBoolean recurse,oaBoolean keepLocalRep)\n"
"    Signature: unsetControlled|void-void|simple-oaBoolean,simple-oaBoolean,cptr-oaChar,\n"
"    This function is only active when a Version Control system is in place for the library this object is in. It will remove the object from the version control systems repository. if keepLocalRep is \"false\" the local file will also be removed.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    recurse\n"
"    signals to the version control system to apply this operation to all children of this object.\n"
"    keepLocalRep\n"
"    set to true to prevent the local file from being removed from disk after it is removed from the version control repository\n"
"    options\n"
"    a string that represents options that are specific to the version control system that's install for this library.\n"
"    oacLibAccessDenied\n"
"  Paramegers: (oaBoolean,oaBoolean,[oaChar])\n"
"    Calls: void unsetControlled(oaBoolean recurse,oaBoolean keepLocalRep,const oaChar* options)\n"
"    Signature: unsetControlled|void-void|simple-oaBoolean,simple-oaBoolean,cptr-oaChar,\n"
"    This function is only active when a Version Control system is in place for the library this object is in. It will remove the object from the version control systems repository. if keepLocalRep is \"false\" the local file will also be removed.\n"
"    This function requires access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    recurse\n"
"    signals to the version control system to apply this operation to all children of this object.\n"
"    keepLocalRep\n"
"    set to true to prevent the local file from being removed from disk after it is removed from the version control repository\n"
"    options\n"
"    a string that represents options that are specific to the version control system that's install for this library.\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaDMObject_unsetControlled(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDMObject data;
    int convert_status=PyoaDMObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDMObjectObject* self=(PyoaDMObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            data.DataCall()->unsetControlled();
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            data.DataCall()->unsetControlled(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean,oaBoolean)
    {
        PyParamoaBoolean p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBoolean_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->unsetControlled(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean,oaBoolean,[oaChar])
    {
        PyParamoaBoolean p1;
        PyParamoaBoolean p2;
        PyParamoaChar_Array p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaBoolean_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaChar_Array_Convert,&p3)) {
            data.DataCall()->unsetControlled(p1.Data(),p2.Data(),p3.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDMObject, function: unsetControlled, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
        "    (oaBoolean,oaBoolean)\n"
        "    (oaBoolean,oaBoolean,[oaChar])\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDMObject_update_doc[] = 
"Class: oaDMObject, Function: update\n"
"  Paramegers: (oaVCVersion)\n"
"    Calls: void update(const oaVCVersion& version)\n"
"    Signature: update|void-void|cref-oaVCVersion,simple-oaBoolean,cptr-oaChar,\n"
"    oaDMObject::update\n"
"    This function is only active when a Version Control system is in place for the library this object is in. It will retrieve the given version of the object from the repository. If the object is current, it will be left unchanged; if it didn't previously exist in the local directory, it will be retrieved.\n"
"    This function requires write access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if write access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    version\n"
"    the version of the object to retrieve from version control. Use an oaVCVersion created with the default constructor to denote the most recent version in the repository.\n"
"    recurse\n"
"    signals to the version control system to apply this operation to all children of this object.\n"
"    options\n"
"    a string that represents options that are specific to the version control system that's install for this library.\n"
"    oacLibAccessDenied\n"
"  Paramegers: (oaVCVersion,oaBoolean)\n"
"    Calls: void update(const oaVCVersion& version,oaBoolean recurse)\n"
"    Signature: update|void-void|cref-oaVCVersion,simple-oaBoolean,cptr-oaChar,\n"
"    oaDMObject::update\n"
"    This function is only active when a Version Control system is in place for the library this object is in. It will retrieve the given version of the object from the repository. If the object is current, it will be left unchanged; if it didn't previously exist in the local directory, it will be retrieved.\n"
"    This function requires write access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if write access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    version\n"
"    the version of the object to retrieve from version control. Use an oaVCVersion created with the default constructor to denote the most recent version in the repository.\n"
"    recurse\n"
"    signals to the version control system to apply this operation to all children of this object.\n"
"    options\n"
"    a string that represents options that are specific to the version control system that's install for this library.\n"
"    oacLibAccessDenied\n"
"  Paramegers: (oaVCVersion,oaBoolean,[oaChar])\n"
"    Calls: void update(const oaVCVersion& version,oaBoolean recurse,const oaChar* options)\n"
"    Signature: update|void-void|cref-oaVCVersion,simple-oaBoolean,cptr-oaChar,\n"
"    oaDMObject::update\n"
"    This function is only active when a Version Control system is in place for the library this object is in. It will retrieve the given version of the object from the repository. If the object is current, it will be left unchanged; if it didn't previously exist in the local directory, it will be retrieved.\n"
"    This function requires write access to the library associated with this object (through a call to oaLib::getAccess ). An oacLibAccessDenied exception is thrown if write access to the library does not exist.\n"
"    For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"    version\n"
"    the version of the object to retrieve from version control. Use an oaVCVersion created with the default constructor to denote the most recent version in the repository.\n"
"    recurse\n"
"    signals to the version control system to apply this operation to all children of this object.\n"
"    options\n"
"    a string that represents options that are specific to the version control system that's install for this library.\n"
"    oacLibAccessDenied\n"
;

static PyObject*
oaDMObject_update(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDMObject data;
    int convert_status=PyoaDMObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDMObjectObject* self=(PyoaDMObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaVCVersion)
    {
        PyParamoaVCVersion p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVCVersion_Convert,&p1)) {
            data.DataCall()->update(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaVCVersion,oaBoolean)
    {
        PyParamoaVCVersion p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaVCVersion_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            data.DataCall()->update(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaVCVersion,oaBoolean,[oaChar])
    {
        PyParamoaVCVersion p1;
        PyParamoaBoolean p2;
        PyParamoaChar_Array p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaVCVersion_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaChar_Array_Convert,&p3)) {
            data.DataCall()->update(p1.Data(),p2.Data(),p3.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDMObject, function: update, Choices are:\n"
        "    (oaVCVersion)\n"
        "    (oaVCVersion,oaBoolean)\n"
        "    (oaVCVersion,oaBoolean,[oaChar])\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDMObject_isNull_doc[] =
"Class: oaDMObject, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDMObject_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDMObject data;
    int convert_status=PyoaDMObject_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDMObject_assign_doc[] = 
"Class: oaDMObject, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDMObject_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDMObject data;
  int convert_status=PyoaDMObject_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDMObject p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDMObject_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDMObject_methodlist[] = {
    {"cancelEdit",(PyCFunction)oaDMObject_cancelEdit,METH_VARARGS,oaDMObject_cancelEdit_doc},
    {"commitEdits",(PyCFunction)oaDMObject_commitEdits,METH_VARARGS,oaDMObject_commitEdits_doc},
    {"getLib",(PyCFunction)oaDMObject_getLib,METH_VARARGS,oaDMObject_getLib_doc},
    {"getTempFile",(PyCFunction)oaDMObject_getTempFile,METH_VARARGS,oaDMObject_getTempFile_doc},
    {"getVCStatus",(PyCFunction)oaDMObject_getVCStatus,METH_VARARGS,oaDMObject_getVCStatus_doc},
    {"getVersions",(PyCFunction)oaDMObject_getVersions,METH_VARARGS,oaDMObject_getVersions_doc},
    {"isContainer",(PyCFunction)oaDMObject_isContainer,METH_VARARGS,oaDMObject_isContainer_doc},
    {"makeEditable",(PyCFunction)oaDMObject_makeEditable,METH_VARARGS,oaDMObject_makeEditable_doc},
    {"setControlled",(PyCFunction)oaDMObject_setControlled,METH_VARARGS,oaDMObject_setControlled_doc},
    {"unsetControlled",(PyCFunction)oaDMObject_unsetControlled,METH_VARARGS,oaDMObject_unsetControlled_doc},
    {"update",(PyCFunction)oaDMObject_update,METH_VARARGS,oaDMObject_update_doc},
    {"isNull",(PyCFunction)oaDMObject_tp_isNull,METH_VARARGS,oaDMObject_isNull_doc},
    {"assign",(PyCFunction)oaDMObject_tp_assign,METH_VARARGS,oaDMObject_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDMObject_doc[] = 
"Class: oaDMObject\n"
"  The oaDMObject class is an abstract base for all OpenAccess DM objects. Child classes are the oaDMContainer classes -- oaCell , oaView , oaCellView and oaLib -- and oaDMFile .\n"
"  Note: The oaDMObject function descriptions indicate if access to the library associated with the object is required for the called function. If the access type must be write access, this requirement also is noted.\n"
"  For more information on library access, see Library Access in the detailed description for oaLib and OpenAccess 2.2 Libraries and Design Management in the Programmers Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDMObject)\n"
"    Calls: (const oaDMObject&)\n"
"    Signature: oaDMObject||cref-oaDMObject,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDMObject_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDMObject",
    sizeof(PyoaDMObjectObject),
    0,
    (destructor)oaDMObject_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDMObject_tp_compare,	/* tp_compare */
    (reprfunc)oaDMObject_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDMObject_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDMObject_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDMObject_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDMObject_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDMObject_Type)<0) {
      printf("** PyType_Ready failed for: oaDMObject\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDMObject",
           (PyObject*)(&PyoaDMObject_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDMObject\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDMObjectIter
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDMObjectIter_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDMObjectIter_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDMObjectIterObject* self = (PyoaDMObjectIterObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDMObjectIter)
    {
        PyParamoaDMObjectIter p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDMObjectIter_Convert,&p1)) {
            self->value =  new oaDMObjectIter(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDMObjectIter, Choices are:\n"
        "    (oaDMObjectIter)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDMObjectIter_tp_dealloc(PyoaDMObjectIterObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDMObjectIter_tp_repr(PyObject *ob)
{
    PyParamoaDMObjectIter value;
    int convert_status=PyoaDMObjectIter_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[36];
    sprintf(buffer,"<oaDMObjectIter::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDMObjectIter_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDMObjectIter v1;
    PyParamoaDMObjectIter v2;
    int convert_status1=PyoaDMObjectIter_Convert(ob1,&v1);
    int convert_status2=PyoaDMObjectIter_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
static PyObject*
oaDMObjectIter_getiter(PyObject *self)
{
    Py_INCREF(self);
    return self;
}

// ------------------------------------------------------------------
static PyObject*
oaDMObjectIter_iternext(PyObject *self)
{
  try {
    PyParamoaDMObjectIter ob;
    int convert_status=PyoaDMObjectIter_Convert(self,&ob);
    assert(convert_status!=0);
    oaDMObject* result;
    result=ob.DataCall()->getNext();
    if (result==NULL) {
       PyErr_SetObject(PyExc_StopIteration,Py_None);
       return NULL;
    }
    return PyoaDMObject_FromoaDMObject(result);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
int
PyoaDMObjectIter_Convert(PyObject* ob,PyParamoaDMObjectIter* result)
{
    if (ob == NULL) return 1;
    if (PyoaDMObjectIter_Check(ob)) {
        result->SetData(  ((PyoaDMObjectIterObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDMObjectIter Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDMObjectIter_FromoaDMObjectIter(oaDMObjectIter* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaDMObjectIter_Type.tp_alloc(&PyoaDMObjectIter_Type,0);
        if (bself == NULL) return bself;
        PyoaDMObjectIterObject* self = (PyoaDMObjectIterObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDMObjectIter_getNext_doc[] = 
"Class: oaDMObjectIter, Function: getNext\n"
"  Paramegers: ()\n"
"    Calls: oaDMObject* getNext()\n"
"    Signature: getNext|ptr-oaDMObject|\n"
"    BrowseData: 1\n"
"    This function gets the next (oaDMObject*, status) pair. If there is no more data, the oaDMObject* will be NULL.\n"
;

static PyObject*
oaDMObjectIter_getNext(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDMObjectIter data;
    int convert_status=PyoaDMObjectIter_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDMObjectIterObject* self=(PyoaDMObjectIterObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaDMObjectp result= (data.DataCall()->getNext());
        return PyoaDMObject_FromoaDMObject(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDMObjectIter_next_doc[] = 
"Class: oaDMObjectIter, Function: next\n"
"  Paramegers: ()\n"
"    Calls: oaDMObject* next()\n"
"    Signature: next|ptr-oaDMObject|,\n"
"    BrowseData: 1\n"
"    get next value or raise StopIteration\n"
;

static PyObject*
oaDMObjectIter_next(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDMObjectIter data;
    int convert_status=PyoaDMObjectIter_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDMObjectIterObject* self=(PyoaDMObjectIterObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaDMObjectp result= (data.DataCall()->getNext());
        if (result==NULL) {
            PyErr_SetObject(PyExc_StopIteration,Py_None);
            return NULL;
        }
        return PyoaDMObject_FromoaDMObject(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDMObjectIter_reset_doc[] = 
"Class: oaDMObjectIter, Function: reset\n"
"  Paramegers: ()\n"
"    Calls: void reset()\n"
"    Signature: reset|void-void|\n"
"    BrowseData: 0\n"
"    This function resets the iterator so that a subsequent getNext() will get the first entry in the set.\n"
;

static PyObject*
oaDMObjectIter_reset(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDMObjectIter data;
    int convert_status=PyoaDMObjectIter_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDMObjectIterObject* self=(PyoaDMObjectIterObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->reset();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaDMObjectIter_assign_doc[] = 
"Class: oaDMObjectIter, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDMObjectIter_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDMObjectIter data;
  int convert_status=PyoaDMObjectIter_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDMObjectIter p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDMObjectIter_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDMObjectIter_methodlist[] = {
    {"getNext",(PyCFunction)oaDMObjectIter_getNext,METH_VARARGS,oaDMObjectIter_getNext_doc},
    {"next",(PyCFunction)oaDMObjectIter_next,METH_VARARGS,oaDMObjectIter_next_doc},
    {"reset",(PyCFunction)oaDMObjectIter_reset,METH_VARARGS,oaDMObjectIter_reset_doc},
    {"assign",(PyCFunction)oaDMObjectIter_tp_assign,METH_VARARGS,oaDMObjectIter_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDMObjectIter_doc[] = 
"Class: oaDMObjectIter\n"
"  The oaDMObjectIter is used to iterate a collection of oaDMObjects.\n"
"Constructors:\n"
"  Paramegers: (oaDMObjectIter)\n"
"    Calls: oaDMObjectIter(const oaDMObjectIter& iter)\n"
"    Signature: oaDMObjectIter||cref-oaDMObjectIter,\n"
"    This is the copy constructor for the oaDMObjectIter class.\n"
"    iter\n"
"    the oaDMObjectIter object to copy\n"
"  Paramegers: (oaDMObjectIter)\n"
"    Calls: (const oaDMObjectIter&)\n"
"    Signature: oaDMObjectIter||cref-oaDMObjectIter,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDMObjectIter_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDMObjectIter",
    sizeof(PyoaDMObjectIterObject),
    0,
    (destructor)oaDMObjectIter_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDMObjectIter_tp_compare,	/* tp_compare */
    (reprfunc)oaDMObjectIter_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDMObjectIter_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    (getiterfunc)oaDMObjectIter_getiter,	/* tp_iter */
    (iternextfunc)oaDMObjectIter_iternext,	/* tp_iternext */
    oaDMObjectIter_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDMObjectIter_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDMObjectIter_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDMObjectIter_Type)<0) {
      printf("** PyType_Ready failed for: oaDMObjectIter\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDMObjectIter",
           (PyObject*)(&PyoaDMObjectIter_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDMObjectIter\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDMObjectStatusRef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDMObjectStatusRef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDMObjectStatusRef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDMObjectStatusRefObject* self = (PyoaDMObjectStatusRefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaDMObjectStatusRef();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaDMObject)
    {
        PyParamoaDMObject p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDMObject_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            self->value =  new oaDMObjectStatusRef(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaDMObject,oaUInt4)
    {
        PyParamoaDMObject p1;
        PyParamoaUInt4 p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaDMObject_Convert,&p1,
              &PyoaUInt4_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            self->value =  new oaDMObjectStatusRef(p1.Data(),p2.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaDMObjectStatusRef)
    {
        PyParamoaDMObjectStatusRef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDMObjectStatusRef_Convert,&p1)) {
            self->value= new oaDMObjectStatusRef(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDMObjectStatusRef, Choices are:\n"
        "    ()\n"
        "    (oaDMObject)\n"
        "    (oaDMObject,oaUInt4)\n"
        "    (oaDMObjectStatusRef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDMObjectStatusRef_tp_dealloc(PyoaDMObjectStatusRefObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDMObjectStatusRef_tp_repr(PyObject *ob)
{
    PyParamoaDMObjectStatusRef value;
    int convert_status=PyoaDMObjectStatusRef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[41];
    sprintf(buffer,"<oaDMObjectStatusRef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDMObjectStatusRef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDMObjectStatusRef v1;
    PyParamoaDMObjectStatusRef v2;
    int convert_status1=PyoaDMObjectStatusRef_Convert(ob1,&v1);
    int convert_status2=PyoaDMObjectStatusRef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDMObjectStatusRef_Convert(PyObject* ob,PyParamoaDMObjectStatusRef* result)
{
    if (ob == NULL) return 1;
    if (PyoaDMObjectStatusRef_Check(ob)) {
        result->SetData(  ((PyoaDMObjectStatusRefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDMObjectStatusRef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDMObjectStatusRef_FromoaDMObjectStatusRef(oaDMObjectStatusRef* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaDMObjectStatusRef_Type.tp_alloc(&PyoaDMObjectStatusRef_Type,0);
        if (bself == NULL) return bself;
        PyoaDMObjectStatusRefObject* self = (PyoaDMObjectStatusRefObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDMObjectStatusRef_getObject_doc[] = 
"Class: oaDMObjectStatusRef, Function: getObject\n"
"  Paramegers: ()\n"
"    Calls: oaDMObject*& getObject()\n"
"    Signature: getObject|ptrref-oaDMObject|\n"
"    BrowseData: 1\n"
"    This function retrieves a reference to the object from this class.\n"
;

static PyObject*
oaDMObjectStatusRef_getObject(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDMObjectStatusRef data;
    int convert_status=PyoaDMObjectStatusRef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDMObjectStatusRefObject* self=(PyoaDMObjectStatusRefObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaDMObjectp* result=&(data.DataCall()->getObject());
        return PyoaDMObject_FromoaDMObject(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDMObjectStatusRef_getStatus_doc[] = 
"Class: oaDMObjectStatusRef, Function: getStatus\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4& getStatus()\n"
"    Signature: getStatus|ref-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function retrieves a reference to the status value from this class.\n"
;

static PyObject*
oaDMObjectStatusRef_getStatus(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDMObjectStatusRef data;
    int convert_status=PyoaDMObjectStatusRef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDMObjectStatusRefObject* self=(PyoaDMObjectStatusRefObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4* result=&(data.DataCall()->getStatus());
        return PyoaUInt4_FromoaUInt4(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaDMObjectStatusRef_assign_doc[] = 
"Class: oaDMObjectStatusRef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDMObjectStatusRef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDMObjectStatusRef data;
  int convert_status=PyoaDMObjectStatusRef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDMObjectStatusRef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDMObjectStatusRef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDMObjectStatusRef_methodlist[] = {
    {"getObject",(PyCFunction)oaDMObjectStatusRef_getObject,METH_VARARGS,oaDMObjectStatusRef_getObject_doc},
    {"getStatus",(PyCFunction)oaDMObjectStatusRef_getStatus,METH_VARARGS,oaDMObjectStatusRef_getStatus_doc},
    {"assign",(PyCFunction)oaDMObjectStatusRef_tp_assign,METH_VARARGS,oaDMObjectStatusRef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDMObjectStatusRef_doc[] = 
"Class: oaDMObjectStatusRef\n"
"  The oaDMObjectStatusRef represents a relationship between an oaDMObject and a status bitfield. It is used by the version control API functions to supply status information for a set of objects. See also oaDMObjectStatusRefIter .\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaDMObjectStatusRef()\n"
"    Signature: oaDMObjectStatusRef||ptr-oaDMObject,simple-oaUInt4,\n"
"    This function is the constructor for the oaDMObjectStatusRef class.\n"
"    obj\n"
"    the object to be stored in the object/status relationship\n"
"    stat\n"
"    the status value to be associated with the given object\n"
"  Paramegers: (oaDMObject)\n"
"    Calls: oaDMObjectStatusRef(oaDMObject* obj)\n"
"    Signature: oaDMObjectStatusRef||ptr-oaDMObject,simple-oaUInt4,\n"
"    This function is the constructor for the oaDMObjectStatusRef class.\n"
"    obj\n"
"    the object to be stored in the object/status relationship\n"
"    stat\n"
"    the status value to be associated with the given object\n"
"  Paramegers: (oaDMObject,oaUInt4)\n"
"    Calls: oaDMObjectStatusRef(oaDMObject* obj,oaUInt4 stat)\n"
"    Signature: oaDMObjectStatusRef||ptr-oaDMObject,simple-oaUInt4,\n"
"    This function is the constructor for the oaDMObjectStatusRef class.\n"
"    obj\n"
"    the object to be stored in the object/status relationship\n"
"    stat\n"
"    the status value to be associated with the given object\n"
"  Paramegers: (oaDMObjectStatusRef)\n"
"    Calls: (const oaDMObjectStatusRef&)\n"
"    Signature: oaDMObjectStatusRef||cref-oaDMObjectStatusRef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDMObjectStatusRef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDMObjectStatusRef",
    sizeof(PyoaDMObjectStatusRefObject),
    0,
    (destructor)oaDMObjectStatusRef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDMObjectStatusRef_tp_compare,	/* tp_compare */
    (reprfunc)oaDMObjectStatusRef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDMObjectStatusRef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDMObjectStatusRef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDMObjectStatusRef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDMObjectStatusRef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDMObjectStatusRef_Type)<0) {
      printf("** PyType_Ready failed for: oaDMObjectStatusRef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDMObjectStatusRef",
           (PyObject*)(&PyoaDMObjectStatusRef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDMObjectStatusRef\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDMObjectStatusRefIter
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDMObjectStatusRefIter_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDMObjectStatusRefIter_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDMObjectStatusRefIterObject* self = (PyoaDMObjectStatusRefIterObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDMObjectStatusRefIter)
    {
        PyParamoaDMObjectStatusRefIter p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDMObjectStatusRefIter_Convert,&p1)) {
            self->value =  new oaDMObjectStatusRefIter(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDMObjectStatusRefIter, Choices are:\n"
        "    (oaDMObjectStatusRefIter)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDMObjectStatusRefIter_tp_dealloc(PyoaDMObjectStatusRefIterObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDMObjectStatusRefIter_tp_repr(PyObject *ob)
{
    PyParamoaDMObjectStatusRefIter value;
    int convert_status=PyoaDMObjectStatusRefIter_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[45];
    sprintf(buffer,"<oaDMObjectStatusRefIter::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDMObjectStatusRefIter_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDMObjectStatusRefIter v1;
    PyParamoaDMObjectStatusRefIter v2;
    int convert_status1=PyoaDMObjectStatusRefIter_Convert(ob1,&v1);
    int convert_status2=PyoaDMObjectStatusRefIter_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
static PyObject*
oaDMObjectStatusRefIter_getiter(PyObject *self)
{
    Py_INCREF(self);
    return self;
}

// ------------------------------------------------------------------
PyObject* oaDMObjectStatusRefIter_iternext(PyObject *self);

// ------------------------------------------------------------------
int
PyoaDMObjectStatusRefIter_Convert(PyObject* ob,PyParamoaDMObjectStatusRefIter* result)
{
    if (ob == NULL) return 1;
    if (PyoaDMObjectStatusRefIter_Check(ob)) {
        result->SetData(  ((PyoaDMObjectStatusRefIterObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDMObjectStatusRefIter Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDMObjectStatusRefIter_FromoaDMObjectStatusRefIter(oaDMObjectStatusRefIter* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaDMObjectStatusRefIter_Type.tp_alloc(&PyoaDMObjectStatusRefIter_Type,0);
        if (bself == NULL) return bself;
        PyoaDMObjectStatusRefIterObject* self = (PyoaDMObjectStatusRefIterObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDMObjectStatusRefIter_getNext_doc[] = 
"Class: oaDMObjectStatusRefIter, Function: getNext\n"
"  Paramegers: ()\n"
"    Calls: oaDMObjectStatusRef getNext()\n"
"    Signature: getNext|simple-oaDMObjectStatusRef|\n"
"    BrowseData: 1\n"
"    This function gets the next (oaDMObject*, status) pair. If there is no more data, the oaDMObject* will be NULL.\n"
;

extern PyObject* oaDMObjectStatusRefIter_getNext(PyObject *self, PyObject *args);

// ------------------------------------------------------------------
static char oaDMObjectStatusRefIter_next_doc[] = 
"Class: oaDMObjectStatusRefIter, Function: next\n"
"  Paramegers: ()\n"
"    Calls: oaDMObjectStatusRef* next()\n"
"    Signature: next|ptr-oaDMObjectStatusRef|,\n"
"    BrowseData: 1\n"
"    get next value or raise StopIteration\n"
;

extern PyObject* oaDMObjectStatusRefIter_next(PyObject *self, PyObject *args);

// ------------------------------------------------------------------
static char oaDMObjectStatusRefIter_reset_doc[] = 
"Class: oaDMObjectStatusRefIter, Function: reset\n"
"  Paramegers: ()\n"
"    Calls: void reset()\n"
"    Signature: reset|void-void|\n"
"    BrowseData: 0\n"
"    This function resets the iterator so that getNext() will get the first entry in the set.\n"
;

static PyObject*
oaDMObjectStatusRefIter_reset(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDMObjectStatusRefIter data;
    int convert_status=PyoaDMObjectStatusRefIter_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDMObjectStatusRefIterObject* self=(PyoaDMObjectStatusRefIterObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->reset();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaDMObjectStatusRefIter_assign_doc[] = 
"Class: oaDMObjectStatusRefIter, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDMObjectStatusRefIter_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDMObjectStatusRefIter data;
  int convert_status=PyoaDMObjectStatusRefIter_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDMObjectStatusRefIter p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDMObjectStatusRefIter_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDMObjectStatusRefIter_methodlist[] = {
    {"getNext",(PyCFunction)oaDMObjectStatusRefIter_getNext,METH_VARARGS,oaDMObjectStatusRefIter_getNext_doc},
    {"next",(PyCFunction)oaDMObjectStatusRefIter_next,METH_VARARGS,oaDMObjectStatusRefIter_next_doc},
    {"reset",(PyCFunction)oaDMObjectStatusRefIter_reset,METH_VARARGS,oaDMObjectStatusRefIter_reset_doc},
    {"assign",(PyCFunction)oaDMObjectStatusRefIter_tp_assign,METH_VARARGS,oaDMObjectStatusRefIter_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDMObjectStatusRefIter_doc[] = 
"Class: oaDMObjectStatusRefIter\n"
"  The oaDMObjectStatusRefIter is used to iterate a collection of oaDMObjectStatusRefs.\n"
"Constructors:\n"
"  Paramegers: (oaDMObjectStatusRefIter)\n"
"    Calls: oaDMObjectStatusRefIter(const oaDMObjectStatusRefIter& iter)\n"
"    Signature: oaDMObjectStatusRefIter||cref-oaDMObjectStatusRefIter,\n"
"    This is the copy constructor for the oaDMObjectStatusRefIter class.\n"
"    iter\n"
"    the aDMObjectStatusRefIter object to copy\n"
"  Paramegers: (oaDMObjectStatusRefIter)\n"
"    Calls: (const oaDMObjectStatusRefIter&)\n"
"    Signature: oaDMObjectStatusRefIter||cref-oaDMObjectStatusRefIter,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDMObjectStatusRefIter_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDMObjectStatusRefIter",
    sizeof(PyoaDMObjectStatusRefIterObject),
    0,
    (destructor)oaDMObjectStatusRefIter_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDMObjectStatusRefIter_tp_compare,	/* tp_compare */
    (reprfunc)oaDMObjectStatusRefIter_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDMObjectStatusRefIter_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    (getiterfunc)oaDMObjectStatusRefIter_getiter,	/* tp_iter */
    (iternextfunc)oaDMObjectStatusRefIter_iternext,	/* tp_iternext */
    oaDMObjectStatusRefIter_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDMObjectStatusRefIter_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDMObjectStatusRefIter_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDMObjectStatusRefIter_Type)<0) {
      printf("** PyType_Ready failed for: oaDMObjectStatusRefIter\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDMObjectStatusRefIter",
           (PyObject*)(&PyoaDMObjectStatusRefIter_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDMObjectStatusRefIter\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDMObjectVersionRef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDMObjectVersionRef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDMObjectVersionRef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDMObjectVersionRefObject* self = (PyoaDMObjectVersionRefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDMObject,oaVCVersion)
    {
        PyParamoaDMObject p1;
        PyParamoaVCVersion p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaDMObject_Convert,&p1,
              &PyoaVCVersion_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            self->value =  new oaDMObjectVersionRef(p1.Data(),p2.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaDMObjectVersionRef();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaDMObject)
    {
        PyParamoaDMObject p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDMObject_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            self->value =  new oaDMObjectVersionRef(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaDMObjectVersionRef)
    {
        PyParamoaDMObjectVersionRef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDMObjectVersionRef_Convert,&p1)) {
            self->value= new oaDMObjectVersionRef(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDMObjectVersionRef, Choices are:\n"
        "    (oaDMObject,oaVCVersion)\n"
        "    ()\n"
        "    (oaDMObject)\n"
        "    (oaDMObjectVersionRef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDMObjectVersionRef_tp_dealloc(PyoaDMObjectVersionRefObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDMObjectVersionRef_tp_repr(PyObject *ob)
{
    PyParamoaDMObjectVersionRef value;
    int convert_status=PyoaDMObjectVersionRef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaDMObjectVersionRef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDMObjectVersionRef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDMObjectVersionRef v1;
    PyParamoaDMObjectVersionRef v2;
    int convert_status1=PyoaDMObjectVersionRef_Convert(ob1,&v1);
    int convert_status2=PyoaDMObjectVersionRef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDMObjectVersionRef_Convert(PyObject* ob,PyParamoaDMObjectVersionRef* result)
{
    if (ob == NULL) return 1;
    if (PyoaDMObjectVersionRef_Check(ob)) {
        result->SetData(  ((PyoaDMObjectVersionRefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDMObjectVersionRef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDMObjectVersionRef_FromoaDMObjectVersionRef(oaDMObjectVersionRef* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaDMObjectVersionRef_Type.tp_alloc(&PyoaDMObjectVersionRef_Type,0);
        if (bself == NULL) return bself;
        PyoaDMObjectVersionRefObject* self = (PyoaDMObjectVersionRefObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDMObjectVersionRef_getVersion_doc[] = 
"Class: oaDMObjectVersionRef, Function: getVersion\n"
"  Paramegers: ()\n"
"    Calls: oaVCVersion& getVersion()\n"
"    Signature: getVersion|ref-oaVCVersion|\n"
"    BrowseData: 1\n"
"    This function retrieves a reference to the version value from this class.\n"
;

static PyObject*
oaDMObjectVersionRef_getVersion(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDMObjectVersionRef data;
    int convert_status=PyoaDMObjectVersionRef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDMObjectVersionRefObject* self=(PyoaDMObjectVersionRefObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaVCVersion* result=&(data.DataCall()->getVersion());
        return PyoaVCVersion_FromoaVCVersion(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaDMObjectVersionRef_assign_doc[] = 
"Class: oaDMObjectVersionRef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDMObjectVersionRef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDMObjectVersionRef data;
  int convert_status=PyoaDMObjectVersionRef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDMObjectVersionRef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDMObjectVersionRef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDMObjectVersionRef_methodlist[] = {
    {"getVersion",(PyCFunction)oaDMObjectVersionRef_getVersion,METH_VARARGS,oaDMObjectVersionRef_getVersion_doc},
    {"assign",(PyCFunction)oaDMObjectVersionRef_tp_assign,METH_VARARGS,oaDMObjectVersionRef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDMObjectVersionRef_doc[] = 
"Class: oaDMObjectVersionRef\n"
"  The oaDMObjectVersionRef represents a relationship between an oaDMObject and an oaVCVersion . It is used by the version control API functions to supply version information for a set of objects. See also oaDMObjectVersionRefIter .\n"
"Constructors:\n"
"  Paramegers: (oaDMObject,oaVCVersion)\n"
"    Calls: oaDMObjectVersionRef(const oaDMObject* obj,const oaVCVersion& ver)\n"
"    Signature: oaDMObjectVersionRef||cptr-oaDMObject,cref-oaVCVersion,\n"
"    This function is a constructor for the oaDMObjectVersionRef class. It is used to establish a relationship between an oaDMObject and a particular version value.\n"
"    obj\n"
"    the object to be stored in the object/version relationship\n"
"    ver\n"
"    the version value to be associated with the given object\n"
"  Paramegers: ()\n"
"    Calls: oaDMObjectVersionRef()\n"
"    Signature: oaDMObjectVersionRef||cptr-oaDMObject,\n"
"    This function is a constructor for the oaDMObjectVersionRef class. This form of the constructor is used to construct an empty instance of an oaDMObjectVersionRef or one with a default version.\n"
"    obj\n"
"    the object to be stored in the object/version relationship\n"
"  Paramegers: (oaDMObject)\n"
"    Calls: oaDMObjectVersionRef(const oaDMObject* obj)\n"
"    Signature: oaDMObjectVersionRef||cptr-oaDMObject,\n"
"    This function is a constructor for the oaDMObjectVersionRef class. This form of the constructor is used to construct an empty instance of an oaDMObjectVersionRef or one with a default version.\n"
"    obj\n"
"    the object to be stored in the object/version relationship\n"
"  Paramegers: (oaDMObjectVersionRef)\n"
"    Calls: (const oaDMObjectVersionRef&)\n"
"    Signature: oaDMObjectVersionRef||cref-oaDMObjectVersionRef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDMObjectVersionRef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDMObjectVersionRef",
    sizeof(PyoaDMObjectVersionRefObject),
    0,
    (destructor)oaDMObjectVersionRef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDMObjectVersionRef_tp_compare,	/* tp_compare */
    (reprfunc)oaDMObjectVersionRef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDMObjectVersionRef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDMObjectVersionRef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDMObjectVersionRef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDMObjectVersionRef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDMObjectVersionRef_Type)<0) {
      printf("** PyType_Ready failed for: oaDMObjectVersionRef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDMObjectVersionRef",
           (PyObject*)(&PyoaDMObjectVersionRef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDMObjectVersionRef\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDMObjectVersionRefIter
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDMObjectVersionRefIter_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDMObjectVersionRefIter_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDMObjectVersionRefIterObject* self = (PyoaDMObjectVersionRefIterObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDMObjectVersionRefIter)
    {
        PyParamoaDMObjectVersionRefIter p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDMObjectVersionRefIter_Convert,&p1)) {
            self->value =  new oaDMObjectVersionRefIter(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDMObjectVersionRefIter, Choices are:\n"
        "    (oaDMObjectVersionRefIter)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDMObjectVersionRefIter_tp_dealloc(PyoaDMObjectVersionRefIterObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDMObjectVersionRefIter_tp_repr(PyObject *ob)
{
    PyParamoaDMObjectVersionRefIter value;
    int convert_status=PyoaDMObjectVersionRefIter_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[46];
    sprintf(buffer,"<oaDMObjectVersionRefIter::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDMObjectVersionRefIter_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDMObjectVersionRefIter v1;
    PyParamoaDMObjectVersionRefIter v2;
    int convert_status1=PyoaDMObjectVersionRefIter_Convert(ob1,&v1);
    int convert_status2=PyoaDMObjectVersionRefIter_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
static PyObject*
oaDMObjectVersionRefIter_getiter(PyObject *self)
{
    Py_INCREF(self);
    return self;
}

// ------------------------------------------------------------------
PyObject* oaDMObjectVersionRefIter_iternext(PyObject *self);

// ------------------------------------------------------------------
int
PyoaDMObjectVersionRefIter_Convert(PyObject* ob,PyParamoaDMObjectVersionRefIter* result)
{
    if (ob == NULL) return 1;
    if (PyoaDMObjectVersionRefIter_Check(ob)) {
        result->SetData(  ((PyoaDMObjectVersionRefIterObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDMObjectVersionRefIter Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDMObjectVersionRefIter_FromoaDMObjectVersionRefIter(oaDMObjectVersionRefIter* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaDMObjectVersionRefIter_Type.tp_alloc(&PyoaDMObjectVersionRefIter_Type,0);
        if (bself == NULL) return bself;
        PyoaDMObjectVersionRefIterObject* self = (PyoaDMObjectVersionRefIterObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDMObjectVersionRefIter_getNext_doc[] = 
"Class: oaDMObjectVersionRefIter, Function: getNext\n"
"  Paramegers: ()\n"
"    Calls: oaDMObjectVersionRef getNext()\n"
"    Signature: getNext|simple-oaDMObjectVersionRef|\n"
"    BrowseData: 1\n"
"    This function gets the next (oaDMObject*, status) pair. If there is no more data, then the oaDMObject* will be NULL.\n"
;

extern PyObject* oaDMObjectVersionRefIter_getNext(PyObject *self, PyObject *args);

// ------------------------------------------------------------------
static char oaDMObjectVersionRefIter_next_doc[] = 
"Class: oaDMObjectVersionRefIter, Function: next\n"
"  Paramegers: ()\n"
"    Calls: oaDMObjectVersionRef* next()\n"
"    Signature: next|ptr-oaDMObjectVersionRef|,\n"
"    BrowseData: 1\n"
"    get next value or raise StopIteration\n"
;

extern PyObject* oaDMObjectVersionRefIter_next(PyObject *self, PyObject *args);

// ------------------------------------------------------------------
static char oaDMObjectVersionRefIter_reset_doc[] = 
"Class: oaDMObjectVersionRefIter, Function: reset\n"
"  Paramegers: ()\n"
"    Calls: void reset()\n"
"    Signature: reset|void-void|\n"
"    BrowseData: 0\n"
"    This function resets the iterator so that getNext() will get the first entry in the set.\n"
;

static PyObject*
oaDMObjectVersionRefIter_reset(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDMObjectVersionRefIter data;
    int convert_status=PyoaDMObjectVersionRefIter_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDMObjectVersionRefIterObject* self=(PyoaDMObjectVersionRefIterObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->reset();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaDMObjectVersionRefIter_assign_doc[] = 
"Class: oaDMObjectVersionRefIter, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDMObjectVersionRefIter_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDMObjectVersionRefIter data;
  int convert_status=PyoaDMObjectVersionRefIter_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDMObjectVersionRefIter p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDMObjectVersionRefIter_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDMObjectVersionRefIter_methodlist[] = {
    {"getNext",(PyCFunction)oaDMObjectVersionRefIter_getNext,METH_VARARGS,oaDMObjectVersionRefIter_getNext_doc},
    {"next",(PyCFunction)oaDMObjectVersionRefIter_next,METH_VARARGS,oaDMObjectVersionRefIter_next_doc},
    {"reset",(PyCFunction)oaDMObjectVersionRefIter_reset,METH_VARARGS,oaDMObjectVersionRefIter_reset_doc},
    {"assign",(PyCFunction)oaDMObjectVersionRefIter_tp_assign,METH_VARARGS,oaDMObjectVersionRefIter_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDMObjectVersionRefIter_doc[] = 
"Class: oaDMObjectVersionRefIter\n"
"  The oaDMObjectVersionRefIter is used to iterate a collection of oaDMObjectVersionRefs.\n"
"Constructors:\n"
"  Paramegers: (oaDMObjectVersionRefIter)\n"
"    Calls: oaDMObjectVersionRefIter(const oaDMObjectVersionRefIter& iter)\n"
"    Signature: oaDMObjectVersionRefIter||cref-oaDMObjectVersionRefIter,\n"
"    This is the copy constructor for the oaDMObjectVersionRefIter class.\n"
"    iter\n"
"    the oaDMObjectVersionRefIter to copy\n"
"  Paramegers: (oaDMObjectVersionRefIter)\n"
"    Calls: (const oaDMObjectVersionRefIter&)\n"
"    Signature: oaDMObjectVersionRefIter||cref-oaDMObjectVersionRefIter,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDMObjectVersionRefIter_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDMObjectVersionRefIter",
    sizeof(PyoaDMObjectVersionRefIterObject),
    0,
    (destructor)oaDMObjectVersionRefIter_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDMObjectVersionRefIter_tp_compare,	/* tp_compare */
    (reprfunc)oaDMObjectVersionRefIter_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDMObjectVersionRefIter_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    (getiterfunc)oaDMObjectVersionRefIter_getiter,	/* tp_iter */
    (iternextfunc)oaDMObjectVersionRefIter_iternext,	/* tp_iternext */
    oaDMObjectVersionRefIter_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDMObjectVersionRefIter_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDMObjectVersionRefIter_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDMObjectVersionRefIter_Type)<0) {
      printf("** PyType_Ready failed for: oaDMObjectVersionRefIter\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDMObjectVersionRefIter",
           (PyObject*)(&PyoaDMObjectVersionRefIter_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDMObjectVersionRefIter\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaAnalysisOpPoint
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaAnalysisOpPoint_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaAnalysisOpPoint_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaAnalysisOpPointObject* self = (PyoaDataAppDef_oaAnalysisOpPointObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaAnalysisOpPoint)
    {
        PyParamoaDataAppDef_oaAnalysisOpPoint p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaAnalysisOpPoint_Convert,&p1)) {
            PyoaDataAppDef_oaAnalysisOpPointObject* cself=((PyoaDataAppDef_oaAnalysisOpPointObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaAnalysisOpPoint, Choices are:\n"
        "    (oaDataAppDef_oaAnalysisOpPoint)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaAnalysisOpPoint_tp_dealloc(PyoaDataAppDef_oaAnalysisOpPointObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaAnalysisOpPoint_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaAnalysisOpPoint value;
    int convert_status=PyoaDataAppDef_oaAnalysisOpPoint_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[52];
    sprintf(buffer,"<oaDataAppDef_oaAnalysisOpPoint::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaAnalysisOpPoint_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaAnalysisOpPoint v1;
    PyParamoaDataAppDef_oaAnalysisOpPoint v2;
    int convert_status1=PyoaDataAppDef_oaAnalysisOpPoint_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaAnalysisOpPoint_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaAnalysisOpPoint_Convert(PyObject* ob,PyParamoaDataAppDef_oaAnalysisOpPoint* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaAnalysisOpPoint_Check(ob)) {
        result->SetData( (oaDataAppDef_oaAnalysisOpPoint**) ((PyoaDataAppDef_oaAnalysisOpPointObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaAnalysisOpPoint Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaAnalysisOpPoint_FromoaDataAppDef_oaAnalysisOpPoint(oaDataAppDef_oaAnalysisOpPoint** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaAnalysisOpPoint* data=*value;
        PyObject* bself = PyoaDataAppDef_oaAnalysisOpPoint_Type.tp_alloc(&PyoaDataAppDef_oaAnalysisOpPoint_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaAnalysisOpPointObject* self = (PyoaDataAppDef_oaAnalysisOpPointObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaAnalysisOpPoint_FromoaDataAppDef_oaAnalysisOpPoint(oaDataAppDef_oaAnalysisOpPoint* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaAnalysisOpPoint_Type.tp_alloc(&PyoaDataAppDef_oaAnalysisOpPoint_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaAnalysisOpPointObject* self = (PyoaDataAppDef_oaAnalysisOpPointObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaAnalysisOpPoint_get_doc[] = 
"Class: oaDataAppDef_oaAnalysisOpPoint, Function: get\n"
"  Paramegers: (oaAnalysisOpPoint,[oaByte])\n"
"    Calls: void get(const oaAnalysisOpPoint* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaAnalysisOpPoint,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaAnalysisOpPoint_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaAnalysisOpPoint data;
    int convert_status=PyoaDataAppDef_oaAnalysisOpPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaAnalysisOpPointObject* self=(PyoaDataAppDef_oaAnalysisOpPointObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaAnalysisOpPoint p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaAnalysisOpPoint_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaAnalysisOpPoint_getDefault_doc[] = 
"Class: oaDataAppDef_oaAnalysisOpPoint, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaAnalysisOpPoint_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaAnalysisOpPoint data;
    int convert_status=PyoaDataAppDef_oaAnalysisOpPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaAnalysisOpPointObject* self=(PyoaDataAppDef_oaAnalysisOpPointObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaAnalysisOpPoint_getSize_doc[] = 
"Class: oaDataAppDef_oaAnalysisOpPoint, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaAnalysisOpPoint_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaAnalysisOpPoint data;
    int convert_status=PyoaDataAppDef_oaAnalysisOpPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaAnalysisOpPointObject* self=(PyoaDataAppDef_oaAnalysisOpPointObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaAnalysisOpPoint_set_doc[] = 
"Class: oaDataAppDef_oaAnalysisOpPoint, Function: set\n"
"  Paramegers: (oaAnalysisOpPoint,[oaByte])\n"
"    Calls: void set(oaAnalysisOpPoint* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaAnalysisOpPoint,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaAnalysisOpPoint_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaAnalysisOpPoint data;
    int convert_status=PyoaDataAppDef_oaAnalysisOpPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaAnalysisOpPointObject* self=(PyoaDataAppDef_oaAnalysisOpPointObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaAnalysisOpPoint p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaAnalysisOpPoint_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaAnalysisOpPoint_isNull_doc[] =
"Class: oaDataAppDef_oaAnalysisOpPoint, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaAnalysisOpPoint_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaAnalysisOpPoint data;
    int convert_status=PyoaDataAppDef_oaAnalysisOpPoint_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaAnalysisOpPoint_assign_doc[] = 
"Class: oaDataAppDef_oaAnalysisOpPoint, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaAnalysisOpPoint_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaAnalysisOpPoint data;
  int convert_status=PyoaDataAppDef_oaAnalysisOpPoint_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaAnalysisOpPoint p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaAnalysisOpPoint_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaAnalysisOpPoint_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaAnalysisOpPoint_get,METH_VARARGS,oaDataAppDef_oaAnalysisOpPoint_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaAnalysisOpPoint_getDefault,METH_VARARGS,oaDataAppDef_oaAnalysisOpPoint_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaAnalysisOpPoint_getSize,METH_VARARGS,oaDataAppDef_oaAnalysisOpPoint_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaAnalysisOpPoint_set,METH_VARARGS,oaDataAppDef_oaAnalysisOpPoint_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaAnalysisOpPoint_tp_isNull,METH_VARARGS,oaDataAppDef_oaAnalysisOpPoint_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaAnalysisOpPoint_tp_assign,METH_VARARGS,oaDataAppDef_oaAnalysisOpPoint_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaAnalysisOpPoint_doc[] = 
"Class: oaDataAppDef_oaAnalysisOpPoint\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaAnalysisOpPoint)\n"
"    Calls: (const oaDataAppDef_oaAnalysisOpPoint&)\n"
"    Signature: oaDataAppDef_oaAnalysisOpPoint||cref-oaDataAppDef_oaAnalysisOpPoint,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaAnalysisOpPoint_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaAnalysisOpPoint",
    sizeof(PyoaDataAppDef_oaAnalysisOpPointObject),
    0,
    (destructor)oaDataAppDef_oaAnalysisOpPoint_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaAnalysisOpPoint_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaAnalysisOpPoint_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaAnalysisOpPoint_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaAnalysisOpPoint_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaAnalysisOpPoint_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaAnalysisOpPoint_static_find_doc[] = 
"Class: oaDataAppDef_oaAnalysisOpPoint, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaAnalysisOpPoint* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaAnalysisOpPoint|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaAnalysisOpPoint* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaAnalysisOpPoint|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaAnalysisOpPoint_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaAnalysisOpPointp result= (oaDataAppDef_oaAnalysisOpPoint::find(p1.Data()));
            return PyoaDataAppDef_oaAnalysisOpPoint_FromoaDataAppDef_oaAnalysisOpPoint(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaAnalysisOpPointp result= (oaDataAppDef_oaAnalysisOpPoint::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaAnalysisOpPoint_FromoaDataAppDef_oaAnalysisOpPoint(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaAnalysisOpPoint, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaAnalysisOpPoint_static_get_doc[] = 
"Class: oaDataAppDef_oaAnalysisOpPoint, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaAnalysisOpPoint* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaAnalysisOpPoint|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaAnalysisOpPoint* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaAnalysisOpPoint|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaAnalysisOpPoint_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaAnalysisOpPointp result= (oaDataAppDef_oaAnalysisOpPoint::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaAnalysisOpPoint_FromoaDataAppDef_oaAnalysisOpPoint(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaAnalysisOpPointp result= (oaDataAppDef_oaAnalysisOpPoint::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaAnalysisOpPoint_FromoaDataAppDef_oaAnalysisOpPoint(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaAnalysisOpPoint, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaAnalysisOpPoint_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaAnalysisOpPoint_static_find,METH_VARARGS,oaDataAppDef_oaAnalysisOpPoint_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaAnalysisOpPoint_static_get,METH_VARARGS,oaDataAppDef_oaAnalysisOpPoint_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaAnalysisOpPoint_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaAnalysisOpPoint_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaAnalysisOpPoint\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaAnalysisOpPoint",
           (PyObject*)(&PyoaDataAppDef_oaAnalysisOpPoint_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaAnalysisOpPoint\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaAnalysisOpPoint_Type.tp_dict;
    for(method=oaDataAppDef_oaAnalysisOpPoint_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaAnalysisPoint
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaAnalysisPoint_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaAnalysisPoint_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaAnalysisPointObject* self = (PyoaDataAppDef_oaAnalysisPointObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaAnalysisPoint)
    {
        PyParamoaDataAppDef_oaAnalysisPoint p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaAnalysisPoint_Convert,&p1)) {
            PyoaDataAppDef_oaAnalysisPointObject* cself=((PyoaDataAppDef_oaAnalysisPointObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaAnalysisPoint, Choices are:\n"
        "    (oaDataAppDef_oaAnalysisPoint)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaAnalysisPoint_tp_dealloc(PyoaDataAppDef_oaAnalysisPointObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaAnalysisPoint_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaAnalysisPoint value;
    int convert_status=PyoaDataAppDef_oaAnalysisPoint_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[50];
    sprintf(buffer,"<oaDataAppDef_oaAnalysisPoint::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaAnalysisPoint_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaAnalysisPoint v1;
    PyParamoaDataAppDef_oaAnalysisPoint v2;
    int convert_status1=PyoaDataAppDef_oaAnalysisPoint_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaAnalysisPoint_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaAnalysisPoint_Convert(PyObject* ob,PyParamoaDataAppDef_oaAnalysisPoint* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaAnalysisPoint_Check(ob)) {
        result->SetData( (oaDataAppDef_oaAnalysisPoint**) ((PyoaDataAppDef_oaAnalysisPointObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaAnalysisPoint Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaAnalysisPoint_FromoaDataAppDef_oaAnalysisPoint(oaDataAppDef_oaAnalysisPoint** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaAnalysisPoint* data=*value;
        PyObject* bself = PyoaDataAppDef_oaAnalysisPoint_Type.tp_alloc(&PyoaDataAppDef_oaAnalysisPoint_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaAnalysisPointObject* self = (PyoaDataAppDef_oaAnalysisPointObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaAnalysisPoint_FromoaDataAppDef_oaAnalysisPoint(oaDataAppDef_oaAnalysisPoint* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaAnalysisPoint_Type.tp_alloc(&PyoaDataAppDef_oaAnalysisPoint_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaAnalysisPointObject* self = (PyoaDataAppDef_oaAnalysisPointObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaAnalysisPoint_get_doc[] = 
"Class: oaDataAppDef_oaAnalysisPoint, Function: get\n"
"  Paramegers: (oaAnalysisPoint,[oaByte])\n"
"    Calls: void get(const oaAnalysisPoint* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaAnalysisPoint,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaAnalysisPoint_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaAnalysisPoint data;
    int convert_status=PyoaDataAppDef_oaAnalysisPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaAnalysisPointObject* self=(PyoaDataAppDef_oaAnalysisPointObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaAnalysisPoint p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaAnalysisPoint_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaAnalysisPoint_getDefault_doc[] = 
"Class: oaDataAppDef_oaAnalysisPoint, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaAnalysisPoint_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaAnalysisPoint data;
    int convert_status=PyoaDataAppDef_oaAnalysisPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaAnalysisPointObject* self=(PyoaDataAppDef_oaAnalysisPointObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaAnalysisPoint_getSize_doc[] = 
"Class: oaDataAppDef_oaAnalysisPoint, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaAnalysisPoint_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaAnalysisPoint data;
    int convert_status=PyoaDataAppDef_oaAnalysisPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaAnalysisPointObject* self=(PyoaDataAppDef_oaAnalysisPointObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaAnalysisPoint_set_doc[] = 
"Class: oaDataAppDef_oaAnalysisPoint, Function: set\n"
"  Paramegers: (oaAnalysisPoint,[oaByte])\n"
"    Calls: void set(oaAnalysisPoint* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaAnalysisPoint,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaAnalysisPoint_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaAnalysisPoint data;
    int convert_status=PyoaDataAppDef_oaAnalysisPoint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaAnalysisPointObject* self=(PyoaDataAppDef_oaAnalysisPointObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaAnalysisPoint p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaAnalysisPoint_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaAnalysisPoint_isNull_doc[] =
"Class: oaDataAppDef_oaAnalysisPoint, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaAnalysisPoint_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaAnalysisPoint data;
    int convert_status=PyoaDataAppDef_oaAnalysisPoint_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaAnalysisPoint_assign_doc[] = 
"Class: oaDataAppDef_oaAnalysisPoint, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaAnalysisPoint_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaAnalysisPoint data;
  int convert_status=PyoaDataAppDef_oaAnalysisPoint_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaAnalysisPoint p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaAnalysisPoint_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaAnalysisPoint_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaAnalysisPoint_get,METH_VARARGS,oaDataAppDef_oaAnalysisPoint_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaAnalysisPoint_getDefault,METH_VARARGS,oaDataAppDef_oaAnalysisPoint_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaAnalysisPoint_getSize,METH_VARARGS,oaDataAppDef_oaAnalysisPoint_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaAnalysisPoint_set,METH_VARARGS,oaDataAppDef_oaAnalysisPoint_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaAnalysisPoint_tp_isNull,METH_VARARGS,oaDataAppDef_oaAnalysisPoint_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaAnalysisPoint_tp_assign,METH_VARARGS,oaDataAppDef_oaAnalysisPoint_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaAnalysisPoint_doc[] = 
"Class: oaDataAppDef_oaAnalysisPoint\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaAnalysisPoint)\n"
"    Calls: (const oaDataAppDef_oaAnalysisPoint&)\n"
"    Signature: oaDataAppDef_oaAnalysisPoint||cref-oaDataAppDef_oaAnalysisPoint,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaAnalysisPoint_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaAnalysisPoint",
    sizeof(PyoaDataAppDef_oaAnalysisPointObject),
    0,
    (destructor)oaDataAppDef_oaAnalysisPoint_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaAnalysisPoint_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaAnalysisPoint_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaAnalysisPoint_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaAnalysisPoint_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaAnalysisPoint_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaAnalysisPoint_static_find_doc[] = 
"Class: oaDataAppDef_oaAnalysisPoint, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaAnalysisPoint* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaAnalysisPoint|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaAnalysisPoint* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaAnalysisPoint|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaAnalysisPoint_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaAnalysisPointp result= (oaDataAppDef_oaAnalysisPoint::find(p1.Data()));
            return PyoaDataAppDef_oaAnalysisPoint_FromoaDataAppDef_oaAnalysisPoint(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaAnalysisPointp result= (oaDataAppDef_oaAnalysisPoint::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaAnalysisPoint_FromoaDataAppDef_oaAnalysisPoint(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaAnalysisPoint, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaAnalysisPoint_static_get_doc[] = 
"Class: oaDataAppDef_oaAnalysisPoint, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaAnalysisPoint* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaAnalysisPoint|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaAnalysisPoint* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaAnalysisPoint|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaAnalysisPoint_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaAnalysisPointp result= (oaDataAppDef_oaAnalysisPoint::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaAnalysisPoint_FromoaDataAppDef_oaAnalysisPoint(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaAnalysisPointp result= (oaDataAppDef_oaAnalysisPoint::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaAnalysisPoint_FromoaDataAppDef_oaAnalysisPoint(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaAnalysisPoint, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaAnalysisPoint_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaAnalysisPoint_static_find,METH_VARARGS,oaDataAppDef_oaAnalysisPoint_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaAnalysisPoint_static_get,METH_VARARGS,oaDataAppDef_oaAnalysisPoint_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaAnalysisPoint_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaAnalysisPoint_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaAnalysisPoint\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaAnalysisPoint",
           (PyObject*)(&PyoaDataAppDef_oaAnalysisPoint_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaAnalysisPoint\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaAnalysisPoint_Type.tp_dict;
    for(method=oaDataAppDef_oaAnalysisPoint_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaAppObject
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaAppObject_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaAppObject_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaAppObjectObject* self = (PyoaDataAppDef_oaAppObjectObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaAppObject)
    {
        PyParamoaDataAppDef_oaAppObject p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaAppObject_Convert,&p1)) {
            PyoaDataAppDef_oaAppObjectObject* cself=((PyoaDataAppDef_oaAppObjectObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaAppObject, Choices are:\n"
        "    (oaDataAppDef_oaAppObject)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaAppObject_tp_dealloc(PyoaDataAppDef_oaAppObjectObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaAppObject_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaAppObject value;
    int convert_status=PyoaDataAppDef_oaAppObject_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[46];
    sprintf(buffer,"<oaDataAppDef_oaAppObject::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaAppObject_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaAppObject v1;
    PyParamoaDataAppDef_oaAppObject v2;
    int convert_status1=PyoaDataAppDef_oaAppObject_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaAppObject_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaAppObject_Convert(PyObject* ob,PyParamoaDataAppDef_oaAppObject* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaAppObject_Check(ob)) {
        result->SetData( (oaDataAppDef_oaAppObject**) ((PyoaDataAppDef_oaAppObjectObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaAppObject Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaAppObject_FromoaDataAppDef_oaAppObject(oaDataAppDef_oaAppObject** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaAppObject* data=*value;
        PyObject* bself = PyoaDataAppDef_oaAppObject_Type.tp_alloc(&PyoaDataAppDef_oaAppObject_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaAppObjectObject* self = (PyoaDataAppDef_oaAppObjectObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaAppObject_FromoaDataAppDef_oaAppObject(oaDataAppDef_oaAppObject* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaAppObject_Type.tp_alloc(&PyoaDataAppDef_oaAppObject_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaAppObjectObject* self = (PyoaDataAppDef_oaAppObjectObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaAppObject_get_doc[] = 
"Class: oaDataAppDef_oaAppObject, Function: get\n"
"  Paramegers: (oaAppObject,[oaByte])\n"
"    Calls: void get(const oaAppObject* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaAppObject,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaAppObject_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaAppObject data;
    int convert_status=PyoaDataAppDef_oaAppObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaAppObjectObject* self=(PyoaDataAppDef_oaAppObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaAppObject p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaAppObject_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaAppObject_getDefault_doc[] = 
"Class: oaDataAppDef_oaAppObject, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaAppObject_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaAppObject data;
    int convert_status=PyoaDataAppDef_oaAppObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaAppObjectObject* self=(PyoaDataAppDef_oaAppObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaAppObject_getSize_doc[] = 
"Class: oaDataAppDef_oaAppObject, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaAppObject_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaAppObject data;
    int convert_status=PyoaDataAppDef_oaAppObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaAppObjectObject* self=(PyoaDataAppDef_oaAppObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaAppObject_set_doc[] = 
"Class: oaDataAppDef_oaAppObject, Function: set\n"
"  Paramegers: (oaAppObject,[oaByte])\n"
"    Calls: void set(oaAppObject* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaAppObject,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaAppObject_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaAppObject data;
    int convert_status=PyoaDataAppDef_oaAppObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaAppObjectObject* self=(PyoaDataAppDef_oaAppObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaAppObject p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaAppObject_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaAppObject_isNull_doc[] =
"Class: oaDataAppDef_oaAppObject, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaAppObject_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaAppObject data;
    int convert_status=PyoaDataAppDef_oaAppObject_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaAppObject_assign_doc[] = 
"Class: oaDataAppDef_oaAppObject, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaAppObject_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaAppObject data;
  int convert_status=PyoaDataAppDef_oaAppObject_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaAppObject p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaAppObject_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaAppObject_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaAppObject_get,METH_VARARGS,oaDataAppDef_oaAppObject_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaAppObject_getDefault,METH_VARARGS,oaDataAppDef_oaAppObject_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaAppObject_getSize,METH_VARARGS,oaDataAppDef_oaAppObject_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaAppObject_set,METH_VARARGS,oaDataAppDef_oaAppObject_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaAppObject_tp_isNull,METH_VARARGS,oaDataAppDef_oaAppObject_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaAppObject_tp_assign,METH_VARARGS,oaDataAppDef_oaAppObject_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaAppObject_doc[] = 
"Class: oaDataAppDef_oaAppObject\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaAppObject)\n"
"    Calls: (const oaDataAppDef_oaAppObject&)\n"
"    Signature: oaDataAppDef_oaAppObject||cref-oaDataAppDef_oaAppObject,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaAppObject_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaAppObject",
    sizeof(PyoaDataAppDef_oaAppObjectObject),
    0,
    (destructor)oaDataAppDef_oaAppObject_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaAppObject_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaAppObject_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaAppObject_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaAppObject_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaAppObject_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaAppObject_static_find_doc[] = 
"Class: oaDataAppDef_oaAppObject, Function: find\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaAppObject* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaAppObject|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaAppObject_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaString p1;
    PyParamoaAppObjectDef p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaString_Convert,&p1,
          &PyoaAppObjectDef_Convert,&p2)) {
        if (!PyValidateDbObject(p2.Data(),2)) return NULL;
        oaDataAppDef_oaAppObjectp result= (oaDataAppDef_oaAppObject::find(p1.Data(),p2.Data()));
        return PyoaDataAppDef_oaAppObject_FromoaDataAppDef_oaAppObject(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaAppObject_static_get_doc[] = 
"Class: oaDataAppDef_oaAppObject, Function: get\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaAppObject* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaAppObject|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaAppObject_static_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaString p1;
    PyParamoaAppObjectDef p2;
    PyParamoaByte_Array p3;
    PyParamoaBoolean p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaString_Convert,&p1,
          &PyoaAppObjectDef_Convert,&p2,
          &PyoaByte_Array_Convert,&p3,
          &PyoaBoolean_Convert,&p4)) {
        if (!PyValidateDbObject(p2.Data(),2)) return NULL;
        oaDataAppDef_oaAppObjectp result= (oaDataAppDef_oaAppObject::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
        return PyoaDataAppDef_oaAppObject_FromoaDataAppDef_oaAppObject(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaAppObject_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaAppObject_static_find,METH_VARARGS,oaDataAppDef_oaAppObject_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaAppObject_static_get,METH_VARARGS,oaDataAppDef_oaAppObject_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaAppObject_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaAppObject_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaAppObject\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaAppObject",
           (PyObject*)(&PyoaDataAppDef_oaAppObject_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaAppObject\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaAppObject_Type.tp_dict;
    for(method=oaDataAppDef_oaAppObject_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaAssignment
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaAssignment_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaAssignment_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaAssignmentObject* self = (PyoaDataAppDef_oaAssignmentObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaAssignment)
    {
        PyParamoaDataAppDef_oaAssignment p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaAssignment_Convert,&p1)) {
            PyoaDataAppDef_oaAssignmentObject* cself=((PyoaDataAppDef_oaAssignmentObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaAssignment, Choices are:\n"
        "    (oaDataAppDef_oaAssignment)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaAssignment_tp_dealloc(PyoaDataAppDef_oaAssignmentObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaAssignment_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaAssignment value;
    int convert_status=PyoaDataAppDef_oaAssignment_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[47];
    sprintf(buffer,"<oaDataAppDef_oaAssignment::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaAssignment_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaAssignment v1;
    PyParamoaDataAppDef_oaAssignment v2;
    int convert_status1=PyoaDataAppDef_oaAssignment_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaAssignment_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaAssignment_Convert(PyObject* ob,PyParamoaDataAppDef_oaAssignment* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaAssignment_Check(ob)) {
        result->SetData( (oaDataAppDef_oaAssignment**) ((PyoaDataAppDef_oaAssignmentObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaAssignment Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaAssignment_FromoaDataAppDef_oaAssignment(oaDataAppDef_oaAssignment** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaAssignment* data=*value;
        PyObject* bself = PyoaDataAppDef_oaAssignment_Type.tp_alloc(&PyoaDataAppDef_oaAssignment_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaAssignmentObject* self = (PyoaDataAppDef_oaAssignmentObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaAssignment_FromoaDataAppDef_oaAssignment(oaDataAppDef_oaAssignment* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaAssignment_Type.tp_alloc(&PyoaDataAppDef_oaAssignment_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaAssignmentObject* self = (PyoaDataAppDef_oaAssignmentObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaAssignment_get_doc[] = 
"Class: oaDataAppDef_oaAssignment, Function: get\n"
"  Paramegers: (oaAssignment,[oaByte])\n"
"    Calls: void get(const oaAssignment* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaAssignment,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaAssignment_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaAssignment data;
    int convert_status=PyoaDataAppDef_oaAssignment_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaAssignmentObject* self=(PyoaDataAppDef_oaAssignmentObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaAssignment p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaAssignment_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaAssignment_getDefault_doc[] = 
"Class: oaDataAppDef_oaAssignment, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaAssignment_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaAssignment data;
    int convert_status=PyoaDataAppDef_oaAssignment_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaAssignmentObject* self=(PyoaDataAppDef_oaAssignmentObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaAssignment_getSize_doc[] = 
"Class: oaDataAppDef_oaAssignment, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaAssignment_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaAssignment data;
    int convert_status=PyoaDataAppDef_oaAssignment_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaAssignmentObject* self=(PyoaDataAppDef_oaAssignmentObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaAssignment_set_doc[] = 
"Class: oaDataAppDef_oaAssignment, Function: set\n"
"  Paramegers: (oaAssignment,[oaByte])\n"
"    Calls: void set(oaAssignment* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaAssignment,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaAssignment_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaAssignment data;
    int convert_status=PyoaDataAppDef_oaAssignment_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaAssignmentObject* self=(PyoaDataAppDef_oaAssignmentObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaAssignment p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaAssignment_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaAssignment_isNull_doc[] =
"Class: oaDataAppDef_oaAssignment, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaAssignment_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaAssignment data;
    int convert_status=PyoaDataAppDef_oaAssignment_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaAssignment_assign_doc[] = 
"Class: oaDataAppDef_oaAssignment, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaAssignment_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaAssignment data;
  int convert_status=PyoaDataAppDef_oaAssignment_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaAssignment p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaAssignment_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaAssignment_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaAssignment_get,METH_VARARGS,oaDataAppDef_oaAssignment_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaAssignment_getDefault,METH_VARARGS,oaDataAppDef_oaAssignment_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaAssignment_getSize,METH_VARARGS,oaDataAppDef_oaAssignment_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaAssignment_set,METH_VARARGS,oaDataAppDef_oaAssignment_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaAssignment_tp_isNull,METH_VARARGS,oaDataAppDef_oaAssignment_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaAssignment_tp_assign,METH_VARARGS,oaDataAppDef_oaAssignment_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaAssignment_doc[] = 
"Class: oaDataAppDef_oaAssignment\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaAssignment)\n"
"    Calls: (const oaDataAppDef_oaAssignment&)\n"
"    Signature: oaDataAppDef_oaAssignment||cref-oaDataAppDef_oaAssignment,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaAssignment_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaAssignment",
    sizeof(PyoaDataAppDef_oaAssignmentObject),
    0,
    (destructor)oaDataAppDef_oaAssignment_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaAssignment_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaAssignment_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaAssignment_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaAssignment_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaAssignment_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaAssignment_static_find_doc[] = 
"Class: oaDataAppDef_oaAssignment, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaAssignment* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaAssignment|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaAssignment* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaAssignment|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaAssignment_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaAssignmentp result= (oaDataAppDef_oaAssignment::find(p1.Data()));
            return PyoaDataAppDef_oaAssignment_FromoaDataAppDef_oaAssignment(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaAssignmentp result= (oaDataAppDef_oaAssignment::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaAssignment_FromoaDataAppDef_oaAssignment(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaAssignment, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaAssignment_static_get_doc[] = 
"Class: oaDataAppDef_oaAssignment, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaAssignment* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaAssignment|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaAssignment* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaAssignment|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaAssignment_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaAssignmentp result= (oaDataAppDef_oaAssignment::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaAssignment_FromoaDataAppDef_oaAssignment(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaAssignmentp result= (oaDataAppDef_oaAssignment::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaAssignment_FromoaDataAppDef_oaAssignment(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaAssignment, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaAssignment_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaAssignment_static_find,METH_VARARGS,oaDataAppDef_oaAssignment_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaAssignment_static_get,METH_VARARGS,oaDataAppDef_oaAssignment_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaAssignment_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaAssignment_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaAssignment\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaAssignment",
           (PyObject*)(&PyoaDataAppDef_oaAssignment_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaAssignment\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaAssignment_Type.tp_dict;
    for(method=oaDataAppDef_oaAssignment_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaBlock
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaBlock_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaBlock_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaBlockObject* self = (PyoaDataAppDef_oaBlockObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaBlock)
    {
        PyParamoaDataAppDef_oaBlock p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaBlock_Convert,&p1)) {
            PyoaDataAppDef_oaBlockObject* cself=((PyoaDataAppDef_oaBlockObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaBlock, Choices are:\n"
        "    (oaDataAppDef_oaBlock)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaBlock_tp_dealloc(PyoaDataAppDef_oaBlockObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaBlock_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaBlock value;
    int convert_status=PyoaDataAppDef_oaBlock_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaDataAppDef_oaBlock::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaBlock_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaBlock v1;
    PyParamoaDataAppDef_oaBlock v2;
    int convert_status1=PyoaDataAppDef_oaBlock_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaBlock_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaBlock_Convert(PyObject* ob,PyParamoaDataAppDef_oaBlock* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaBlock_Check(ob)) {
        result->SetData( (oaDataAppDef_oaBlock**) ((PyoaDataAppDef_oaBlockObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaBlock Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaBlock_FromoaDataAppDef_oaBlock(oaDataAppDef_oaBlock** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaBlock* data=*value;
        PyObject* bself = PyoaDataAppDef_oaBlock_Type.tp_alloc(&PyoaDataAppDef_oaBlock_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaBlockObject* self = (PyoaDataAppDef_oaBlockObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaBlock_FromoaDataAppDef_oaBlock(oaDataAppDef_oaBlock* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaBlock_Type.tp_alloc(&PyoaDataAppDef_oaBlock_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaBlockObject* self = (PyoaDataAppDef_oaBlockObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaBlock_get_doc[] = 
"Class: oaDataAppDef_oaBlock, Function: get\n"
"  Paramegers: (oaBlock,[oaByte])\n"
"    Calls: void get(const oaBlock* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaBlock,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaBlock_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaBlock data;
    int convert_status=PyoaDataAppDef_oaBlock_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaBlockObject* self=(PyoaDataAppDef_oaBlockObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBlock p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBlock_getDefault_doc[] = 
"Class: oaDataAppDef_oaBlock, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaBlock_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaBlock data;
    int convert_status=PyoaDataAppDef_oaBlock_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaBlockObject* self=(PyoaDataAppDef_oaBlockObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBlock_getSize_doc[] = 
"Class: oaDataAppDef_oaBlock, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaBlock_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaBlock data;
    int convert_status=PyoaDataAppDef_oaBlock_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaBlockObject* self=(PyoaDataAppDef_oaBlockObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBlock_set_doc[] = 
"Class: oaDataAppDef_oaBlock, Function: set\n"
"  Paramegers: (oaBlock,[oaByte])\n"
"    Calls: void set(oaBlock* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaBlock,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaBlock_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaBlock data;
    int convert_status=PyoaDataAppDef_oaBlock_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaBlockObject* self=(PyoaDataAppDef_oaBlockObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBlock p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBlock_isNull_doc[] =
"Class: oaDataAppDef_oaBlock, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaBlock_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaBlock data;
    int convert_status=PyoaDataAppDef_oaBlock_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaBlock_assign_doc[] = 
"Class: oaDataAppDef_oaBlock, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaBlock_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaBlock data;
  int convert_status=PyoaDataAppDef_oaBlock_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaBlock p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaBlock_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaBlock_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaBlock_get,METH_VARARGS,oaDataAppDef_oaBlock_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaBlock_getDefault,METH_VARARGS,oaDataAppDef_oaBlock_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaBlock_getSize,METH_VARARGS,oaDataAppDef_oaBlock_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaBlock_set,METH_VARARGS,oaDataAppDef_oaBlock_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaBlock_tp_isNull,METH_VARARGS,oaDataAppDef_oaBlock_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaBlock_tp_assign,METH_VARARGS,oaDataAppDef_oaBlock_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaBlock_doc[] = 
"Class: oaDataAppDef_oaBlock\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaBlock)\n"
"    Calls: (const oaDataAppDef_oaBlock&)\n"
"    Signature: oaDataAppDef_oaBlock||cref-oaDataAppDef_oaBlock,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaBlock_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaBlock",
    sizeof(PyoaDataAppDef_oaBlockObject),
    0,
    (destructor)oaDataAppDef_oaBlock_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaBlock_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaBlock_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaBlock_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaBlock_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaBlock_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaBlock_static_find_doc[] = 
"Class: oaDataAppDef_oaBlock, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaBlock* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaBlock|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaBlock* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaBlock|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaBlock_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaBlockp result= (oaDataAppDef_oaBlock::find(p1.Data()));
            return PyoaDataAppDef_oaBlock_FromoaDataAppDef_oaBlock(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaBlockp result= (oaDataAppDef_oaBlock::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaBlock_FromoaDataAppDef_oaBlock(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaBlock, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBlock_static_get_doc[] = 
"Class: oaDataAppDef_oaBlock, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaBlock* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaBlock|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaBlock* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaBlock|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaBlock_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaBlockp result= (oaDataAppDef_oaBlock::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaBlock_FromoaDataAppDef_oaBlock(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaBlockp result= (oaDataAppDef_oaBlock::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaBlock_FromoaDataAppDef_oaBlock(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaBlock, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaBlock_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaBlock_static_find,METH_VARARGS,oaDataAppDef_oaBlock_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaBlock_static_get,METH_VARARGS,oaDataAppDef_oaBlock_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaBlock_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaBlock_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaBlock\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaBlock",
           (PyObject*)(&PyoaDataAppDef_oaBlock_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaBlock\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaBlock_Type.tp_dict;
    for(method=oaDataAppDef_oaBlock_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaBlockage
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaBlockage_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaBlockage_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaBlockageObject* self = (PyoaDataAppDef_oaBlockageObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaBlockage)
    {
        PyParamoaDataAppDef_oaBlockage p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaBlockage_Convert,&p1)) {
            PyoaDataAppDef_oaBlockageObject* cself=((PyoaDataAppDef_oaBlockageObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaBlockage, Choices are:\n"
        "    (oaDataAppDef_oaBlockage)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaBlockage_tp_dealloc(PyoaDataAppDef_oaBlockageObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaBlockage_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaBlockage value;
    int convert_status=PyoaDataAppDef_oaBlockage_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[45];
    sprintf(buffer,"<oaDataAppDef_oaBlockage::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaBlockage_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaBlockage v1;
    PyParamoaDataAppDef_oaBlockage v2;
    int convert_status1=PyoaDataAppDef_oaBlockage_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaBlockage_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaBlockage_Convert(PyObject* ob,PyParamoaDataAppDef_oaBlockage* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaBlockage_Check(ob)) {
        result->SetData( (oaDataAppDef_oaBlockage**) ((PyoaDataAppDef_oaBlockageObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaBlockage Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaBlockage_FromoaDataAppDef_oaBlockage(oaDataAppDef_oaBlockage** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaBlockage* data=*value;
        PyObject* bself = PyoaDataAppDef_oaBlockage_Type.tp_alloc(&PyoaDataAppDef_oaBlockage_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaBlockageObject* self = (PyoaDataAppDef_oaBlockageObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaBlockage_FromoaDataAppDef_oaBlockage(oaDataAppDef_oaBlockage* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaBlockage_Type.tp_alloc(&PyoaDataAppDef_oaBlockage_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaBlockageObject* self = (PyoaDataAppDef_oaBlockageObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaBlockage_get_doc[] = 
"Class: oaDataAppDef_oaBlockage, Function: get\n"
"  Paramegers: (oaBlockage,[oaByte])\n"
"    Calls: void get(const oaBlockage* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaBlockage,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaBlockage_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaBlockage data;
    int convert_status=PyoaDataAppDef_oaBlockage_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaBlockageObject* self=(PyoaDataAppDef_oaBlockageObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBlockage p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaBlockage_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBlockage_getDefault_doc[] = 
"Class: oaDataAppDef_oaBlockage, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaBlockage_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaBlockage data;
    int convert_status=PyoaDataAppDef_oaBlockage_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaBlockageObject* self=(PyoaDataAppDef_oaBlockageObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBlockage_getSize_doc[] = 
"Class: oaDataAppDef_oaBlockage, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaBlockage_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaBlockage data;
    int convert_status=PyoaDataAppDef_oaBlockage_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaBlockageObject* self=(PyoaDataAppDef_oaBlockageObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBlockage_set_doc[] = 
"Class: oaDataAppDef_oaBlockage, Function: set\n"
"  Paramegers: (oaBlockage,[oaByte])\n"
"    Calls: void set(oaBlockage* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaBlockage,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaBlockage_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaBlockage data;
    int convert_status=PyoaDataAppDef_oaBlockage_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaBlockageObject* self=(PyoaDataAppDef_oaBlockageObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBlockage p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaBlockage_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBlockage_isNull_doc[] =
"Class: oaDataAppDef_oaBlockage, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaBlockage_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaBlockage data;
    int convert_status=PyoaDataAppDef_oaBlockage_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaBlockage_assign_doc[] = 
"Class: oaDataAppDef_oaBlockage, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaBlockage_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaBlockage data;
  int convert_status=PyoaDataAppDef_oaBlockage_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaBlockage p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaBlockage_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaBlockage_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaBlockage_get,METH_VARARGS,oaDataAppDef_oaBlockage_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaBlockage_getDefault,METH_VARARGS,oaDataAppDef_oaBlockage_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaBlockage_getSize,METH_VARARGS,oaDataAppDef_oaBlockage_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaBlockage_set,METH_VARARGS,oaDataAppDef_oaBlockage_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaBlockage_tp_isNull,METH_VARARGS,oaDataAppDef_oaBlockage_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaBlockage_tp_assign,METH_VARARGS,oaDataAppDef_oaBlockage_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaBlockage_doc[] = 
"Class: oaDataAppDef_oaBlockage\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaBlockage)\n"
"    Calls: (const oaDataAppDef_oaBlockage&)\n"
"    Signature: oaDataAppDef_oaBlockage||cref-oaDataAppDef_oaBlockage,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaBlockage_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaBlockage",
    sizeof(PyoaDataAppDef_oaBlockageObject),
    0,
    (destructor)oaDataAppDef_oaBlockage_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaBlockage_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaBlockage_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaBlockage_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaBlockage_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaBlockage_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaBlockage_static_find_doc[] = 
"Class: oaDataAppDef_oaBlockage, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaBlockage* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaBlockage|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaBlockage* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaBlockage|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaBlockage_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaBlockagep result= (oaDataAppDef_oaBlockage::find(p1.Data()));
            return PyoaDataAppDef_oaBlockage_FromoaDataAppDef_oaBlockage(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaBlockagep result= (oaDataAppDef_oaBlockage::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaBlockage_FromoaDataAppDef_oaBlockage(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaBlockage, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBlockage_static_get_doc[] = 
"Class: oaDataAppDef_oaBlockage, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaBlockage* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaBlockage|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaBlockage* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaBlockage|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaBlockage_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaBlockagep result= (oaDataAppDef_oaBlockage::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaBlockage_FromoaDataAppDef_oaBlockage(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaBlockagep result= (oaDataAppDef_oaBlockage::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaBlockage_FromoaDataAppDef_oaBlockage(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaBlockage, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaBlockage_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaBlockage_static_find,METH_VARARGS,oaDataAppDef_oaBlockage_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaBlockage_static_get,METH_VARARGS,oaDataAppDef_oaBlockage_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaBlockage_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaBlockage_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaBlockage\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaBlockage",
           (PyObject*)(&PyoaDataAppDef_oaBlockage_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaBlockage\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaBlockage_Type.tp_dict;
    for(method=oaDataAppDef_oaBlockage_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaBoundary
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaBoundary_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaBoundary_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaBoundaryObject* self = (PyoaDataAppDef_oaBoundaryObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaBoundary)
    {
        PyParamoaDataAppDef_oaBoundary p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaBoundary_Convert,&p1)) {
            PyoaDataAppDef_oaBoundaryObject* cself=((PyoaDataAppDef_oaBoundaryObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaBoundary, Choices are:\n"
        "    (oaDataAppDef_oaBoundary)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaBoundary_tp_dealloc(PyoaDataAppDef_oaBoundaryObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaBoundary_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaBoundary value;
    int convert_status=PyoaDataAppDef_oaBoundary_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[45];
    sprintf(buffer,"<oaDataAppDef_oaBoundary::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaBoundary_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaBoundary v1;
    PyParamoaDataAppDef_oaBoundary v2;
    int convert_status1=PyoaDataAppDef_oaBoundary_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaBoundary_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaBoundary_Convert(PyObject* ob,PyParamoaDataAppDef_oaBoundary* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaBoundary_Check(ob)) {
        result->SetData( (oaDataAppDef_oaBoundary**) ((PyoaDataAppDef_oaBoundaryObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaBoundary Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaBoundary_FromoaDataAppDef_oaBoundary(oaDataAppDef_oaBoundary** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaBoundary* data=*value;
        PyObject* bself = PyoaDataAppDef_oaBoundary_Type.tp_alloc(&PyoaDataAppDef_oaBoundary_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaBoundaryObject* self = (PyoaDataAppDef_oaBoundaryObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaBoundary_FromoaDataAppDef_oaBoundary(oaDataAppDef_oaBoundary* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaBoundary_Type.tp_alloc(&PyoaDataAppDef_oaBoundary_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaBoundaryObject* self = (PyoaDataAppDef_oaBoundaryObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaBoundary_get_doc[] = 
"Class: oaDataAppDef_oaBoundary, Function: get\n"
"  Paramegers: (oaBoundary,[oaByte])\n"
"    Calls: void get(const oaBoundary* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaBoundary,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaBoundary_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaBoundary data;
    int convert_status=PyoaDataAppDef_oaBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaBoundaryObject* self=(PyoaDataAppDef_oaBoundaryObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBoundary p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaBoundary_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBoundary_getDefault_doc[] = 
"Class: oaDataAppDef_oaBoundary, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaBoundary_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaBoundary data;
    int convert_status=PyoaDataAppDef_oaBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaBoundaryObject* self=(PyoaDataAppDef_oaBoundaryObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBoundary_getSize_doc[] = 
"Class: oaDataAppDef_oaBoundary, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaBoundary_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaBoundary data;
    int convert_status=PyoaDataAppDef_oaBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaBoundaryObject* self=(PyoaDataAppDef_oaBoundaryObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBoundary_set_doc[] = 
"Class: oaDataAppDef_oaBoundary, Function: set\n"
"  Paramegers: (oaBoundary,[oaByte])\n"
"    Calls: void set(oaBoundary* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaBoundary,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaBoundary_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaBoundary data;
    int convert_status=PyoaDataAppDef_oaBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaBoundaryObject* self=(PyoaDataAppDef_oaBoundaryObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBoundary p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaBoundary_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBoundary_isNull_doc[] =
"Class: oaDataAppDef_oaBoundary, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaBoundary_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaBoundary data;
    int convert_status=PyoaDataAppDef_oaBoundary_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaBoundary_assign_doc[] = 
"Class: oaDataAppDef_oaBoundary, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaBoundary_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaBoundary data;
  int convert_status=PyoaDataAppDef_oaBoundary_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaBoundary p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaBoundary_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaBoundary_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaBoundary_get,METH_VARARGS,oaDataAppDef_oaBoundary_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaBoundary_getDefault,METH_VARARGS,oaDataAppDef_oaBoundary_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaBoundary_getSize,METH_VARARGS,oaDataAppDef_oaBoundary_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaBoundary_set,METH_VARARGS,oaDataAppDef_oaBoundary_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaBoundary_tp_isNull,METH_VARARGS,oaDataAppDef_oaBoundary_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaBoundary_tp_assign,METH_VARARGS,oaDataAppDef_oaBoundary_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaBoundary_doc[] = 
"Class: oaDataAppDef_oaBoundary\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaBoundary)\n"
"    Calls: (const oaDataAppDef_oaBoundary&)\n"
"    Signature: oaDataAppDef_oaBoundary||cref-oaDataAppDef_oaBoundary,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaBoundary_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaBoundary",
    sizeof(PyoaDataAppDef_oaBoundaryObject),
    0,
    (destructor)oaDataAppDef_oaBoundary_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaBoundary_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaBoundary_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaBoundary_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaBoundary_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaBoundary_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaBoundary_static_find_doc[] = 
"Class: oaDataAppDef_oaBoundary, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaBoundary* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaBoundary|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaBoundary* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaBoundary|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaBoundary_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaBoundaryp result= (oaDataAppDef_oaBoundary::find(p1.Data()));
            return PyoaDataAppDef_oaBoundary_FromoaDataAppDef_oaBoundary(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaBoundaryp result= (oaDataAppDef_oaBoundary::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaBoundary_FromoaDataAppDef_oaBoundary(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaBoundary, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBoundary_static_get_doc[] = 
"Class: oaDataAppDef_oaBoundary, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaBoundary* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaBoundary|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaBoundary* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaBoundary|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaBoundary_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaBoundaryp result= (oaDataAppDef_oaBoundary::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaBoundary_FromoaDataAppDef_oaBoundary(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaBoundaryp result= (oaDataAppDef_oaBoundary::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaBoundary_FromoaDataAppDef_oaBoundary(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaBoundary, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaBoundary_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaBoundary_static_find,METH_VARARGS,oaDataAppDef_oaBoundary_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaBoundary_static_get,METH_VARARGS,oaDataAppDef_oaBoundary_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaBoundary_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaBoundary_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaBoundary\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaBoundary",
           (PyObject*)(&PyoaDataAppDef_oaBoundary_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaBoundary\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaBoundary_Type.tp_dict;
    for(method=oaDataAppDef_oaBoundary_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaBusNetDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaBusNetDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaBusNetDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaBusNetDefObject* self = (PyoaDataAppDef_oaBusNetDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaBusNetDef)
    {
        PyParamoaDataAppDef_oaBusNetDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaBusNetDef_Convert,&p1)) {
            PyoaDataAppDef_oaBusNetDefObject* cself=((PyoaDataAppDef_oaBusNetDefObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaBusNetDef, Choices are:\n"
        "    (oaDataAppDef_oaBusNetDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaBusNetDef_tp_dealloc(PyoaDataAppDef_oaBusNetDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaBusNetDef_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaBusNetDef value;
    int convert_status=PyoaDataAppDef_oaBusNetDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[46];
    sprintf(buffer,"<oaDataAppDef_oaBusNetDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaBusNetDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaBusNetDef v1;
    PyParamoaDataAppDef_oaBusNetDef v2;
    int convert_status1=PyoaDataAppDef_oaBusNetDef_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaBusNetDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaBusNetDef_Convert(PyObject* ob,PyParamoaDataAppDef_oaBusNetDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaBusNetDef_Check(ob)) {
        result->SetData( (oaDataAppDef_oaBusNetDef**) ((PyoaDataAppDef_oaBusNetDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaBusNetDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaBusNetDef_FromoaDataAppDef_oaBusNetDef(oaDataAppDef_oaBusNetDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaBusNetDef* data=*value;
        PyObject* bself = PyoaDataAppDef_oaBusNetDef_Type.tp_alloc(&PyoaDataAppDef_oaBusNetDef_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaBusNetDefObject* self = (PyoaDataAppDef_oaBusNetDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaBusNetDef_FromoaDataAppDef_oaBusNetDef(oaDataAppDef_oaBusNetDef* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaBusNetDef_Type.tp_alloc(&PyoaDataAppDef_oaBusNetDef_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaBusNetDefObject* self = (PyoaDataAppDef_oaBusNetDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaBusNetDef_get_doc[] = 
"Class: oaDataAppDef_oaBusNetDef, Function: get\n"
"  Paramegers: (oaBusNetDef,[oaByte])\n"
"    Calls: void get(const oaBusNetDef* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaBusNetDef,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaBusNetDef_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaBusNetDef data;
    int convert_status=PyoaDataAppDef_oaBusNetDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaBusNetDefObject* self=(PyoaDataAppDef_oaBusNetDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBusNetDef p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaBusNetDef_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBusNetDef_getDefault_doc[] = 
"Class: oaDataAppDef_oaBusNetDef, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaBusNetDef_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaBusNetDef data;
    int convert_status=PyoaDataAppDef_oaBusNetDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaBusNetDefObject* self=(PyoaDataAppDef_oaBusNetDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBusNetDef_getSize_doc[] = 
"Class: oaDataAppDef_oaBusNetDef, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaBusNetDef_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaBusNetDef data;
    int convert_status=PyoaDataAppDef_oaBusNetDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaBusNetDefObject* self=(PyoaDataAppDef_oaBusNetDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBusNetDef_set_doc[] = 
"Class: oaDataAppDef_oaBusNetDef, Function: set\n"
"  Paramegers: (oaBusNetDef,[oaByte])\n"
"    Calls: void set(oaBusNetDef* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaBusNetDef,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaBusNetDef_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaBusNetDef data;
    int convert_status=PyoaDataAppDef_oaBusNetDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaBusNetDefObject* self=(PyoaDataAppDef_oaBusNetDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBusNetDef p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaBusNetDef_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBusNetDef_isNull_doc[] =
"Class: oaDataAppDef_oaBusNetDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaBusNetDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaBusNetDef data;
    int convert_status=PyoaDataAppDef_oaBusNetDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaBusNetDef_assign_doc[] = 
"Class: oaDataAppDef_oaBusNetDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaBusNetDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaBusNetDef data;
  int convert_status=PyoaDataAppDef_oaBusNetDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaBusNetDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaBusNetDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaBusNetDef_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaBusNetDef_get,METH_VARARGS,oaDataAppDef_oaBusNetDef_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaBusNetDef_getDefault,METH_VARARGS,oaDataAppDef_oaBusNetDef_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaBusNetDef_getSize,METH_VARARGS,oaDataAppDef_oaBusNetDef_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaBusNetDef_set,METH_VARARGS,oaDataAppDef_oaBusNetDef_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaBusNetDef_tp_isNull,METH_VARARGS,oaDataAppDef_oaBusNetDef_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaBusNetDef_tp_assign,METH_VARARGS,oaDataAppDef_oaBusNetDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaBusNetDef_doc[] = 
"Class: oaDataAppDef_oaBusNetDef\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaBusNetDef)\n"
"    Calls: (const oaDataAppDef_oaBusNetDef&)\n"
"    Signature: oaDataAppDef_oaBusNetDef||cref-oaDataAppDef_oaBusNetDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaBusNetDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaBusNetDef",
    sizeof(PyoaDataAppDef_oaBusNetDefObject),
    0,
    (destructor)oaDataAppDef_oaBusNetDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaBusNetDef_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaBusNetDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaBusNetDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaBusNetDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaBusNetDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaBusNetDef_static_find_doc[] = 
"Class: oaDataAppDef_oaBusNetDef, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaBusNetDef* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaBusNetDef|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaBusNetDef* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaBusNetDef|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaBusNetDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaBusNetDefp result= (oaDataAppDef_oaBusNetDef::find(p1.Data()));
            return PyoaDataAppDef_oaBusNetDef_FromoaDataAppDef_oaBusNetDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaBusNetDefp result= (oaDataAppDef_oaBusNetDef::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaBusNetDef_FromoaDataAppDef_oaBusNetDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaBusNetDef, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBusNetDef_static_get_doc[] = 
"Class: oaDataAppDef_oaBusNetDef, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaBusNetDef* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaBusNetDef|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaBusNetDef* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaBusNetDef|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaBusNetDef_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaBusNetDefp result= (oaDataAppDef_oaBusNetDef::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaBusNetDef_FromoaDataAppDef_oaBusNetDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaBusNetDefp result= (oaDataAppDef_oaBusNetDef::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaBusNetDef_FromoaDataAppDef_oaBusNetDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaBusNetDef, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaBusNetDef_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaBusNetDef_static_find,METH_VARARGS,oaDataAppDef_oaBusNetDef_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaBusNetDef_static_get,METH_VARARGS,oaDataAppDef_oaBusNetDef_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaBusNetDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaBusNetDef_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaBusNetDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaBusNetDef",
           (PyObject*)(&PyoaDataAppDef_oaBusNetDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaBusNetDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaBusNetDef_Type.tp_dict;
    for(method=oaDataAppDef_oaBusNetDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaBusTermDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaBusTermDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaBusTermDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaBusTermDefObject* self = (PyoaDataAppDef_oaBusTermDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaBusTermDef)
    {
        PyParamoaDataAppDef_oaBusTermDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaBusTermDef_Convert,&p1)) {
            PyoaDataAppDef_oaBusTermDefObject* cself=((PyoaDataAppDef_oaBusTermDefObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaBusTermDef, Choices are:\n"
        "    (oaDataAppDef_oaBusTermDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaBusTermDef_tp_dealloc(PyoaDataAppDef_oaBusTermDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaBusTermDef_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaBusTermDef value;
    int convert_status=PyoaDataAppDef_oaBusTermDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[47];
    sprintf(buffer,"<oaDataAppDef_oaBusTermDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaBusTermDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaBusTermDef v1;
    PyParamoaDataAppDef_oaBusTermDef v2;
    int convert_status1=PyoaDataAppDef_oaBusTermDef_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaBusTermDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaBusTermDef_Convert(PyObject* ob,PyParamoaDataAppDef_oaBusTermDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaBusTermDef_Check(ob)) {
        result->SetData( (oaDataAppDef_oaBusTermDef**) ((PyoaDataAppDef_oaBusTermDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaBusTermDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaBusTermDef_FromoaDataAppDef_oaBusTermDef(oaDataAppDef_oaBusTermDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaBusTermDef* data=*value;
        PyObject* bself = PyoaDataAppDef_oaBusTermDef_Type.tp_alloc(&PyoaDataAppDef_oaBusTermDef_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaBusTermDefObject* self = (PyoaDataAppDef_oaBusTermDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaBusTermDef_FromoaDataAppDef_oaBusTermDef(oaDataAppDef_oaBusTermDef* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaBusTermDef_Type.tp_alloc(&PyoaDataAppDef_oaBusTermDef_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaBusTermDefObject* self = (PyoaDataAppDef_oaBusTermDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaBusTermDef_get_doc[] = 
"Class: oaDataAppDef_oaBusTermDef, Function: get\n"
"  Paramegers: (oaBusTermDef,[oaByte])\n"
"    Calls: void get(const oaBusTermDef* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaBusTermDef,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaBusTermDef_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaBusTermDef data;
    int convert_status=PyoaDataAppDef_oaBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaBusTermDefObject* self=(PyoaDataAppDef_oaBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBusTermDef p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaBusTermDef_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBusTermDef_getDefault_doc[] = 
"Class: oaDataAppDef_oaBusTermDef, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaBusTermDef_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaBusTermDef data;
    int convert_status=PyoaDataAppDef_oaBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaBusTermDefObject* self=(PyoaDataAppDef_oaBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBusTermDef_getSize_doc[] = 
"Class: oaDataAppDef_oaBusTermDef, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaBusTermDef_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaBusTermDef data;
    int convert_status=PyoaDataAppDef_oaBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaBusTermDefObject* self=(PyoaDataAppDef_oaBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBusTermDef_set_doc[] = 
"Class: oaDataAppDef_oaBusTermDef, Function: set\n"
"  Paramegers: (oaBusTermDef,[oaByte])\n"
"    Calls: void set(oaBusTermDef* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaBusTermDef,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaBusTermDef_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaBusTermDef data;
    int convert_status=PyoaDataAppDef_oaBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaBusTermDefObject* self=(PyoaDataAppDef_oaBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBusTermDef p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaBusTermDef_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBusTermDef_isNull_doc[] =
"Class: oaDataAppDef_oaBusTermDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaBusTermDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaBusTermDef data;
    int convert_status=PyoaDataAppDef_oaBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaBusTermDef_assign_doc[] = 
"Class: oaDataAppDef_oaBusTermDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaBusTermDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaBusTermDef data;
  int convert_status=PyoaDataAppDef_oaBusTermDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaBusTermDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaBusTermDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaBusTermDef_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaBusTermDef_get,METH_VARARGS,oaDataAppDef_oaBusTermDef_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaBusTermDef_getDefault,METH_VARARGS,oaDataAppDef_oaBusTermDef_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaBusTermDef_getSize,METH_VARARGS,oaDataAppDef_oaBusTermDef_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaBusTermDef_set,METH_VARARGS,oaDataAppDef_oaBusTermDef_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaBusTermDef_tp_isNull,METH_VARARGS,oaDataAppDef_oaBusTermDef_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaBusTermDef_tp_assign,METH_VARARGS,oaDataAppDef_oaBusTermDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaBusTermDef_doc[] = 
"Class: oaDataAppDef_oaBusTermDef\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaBusTermDef)\n"
"    Calls: (const oaDataAppDef_oaBusTermDef&)\n"
"    Signature: oaDataAppDef_oaBusTermDef||cref-oaDataAppDef_oaBusTermDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaBusTermDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaBusTermDef",
    sizeof(PyoaDataAppDef_oaBusTermDefObject),
    0,
    (destructor)oaDataAppDef_oaBusTermDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaBusTermDef_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaBusTermDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaBusTermDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaBusTermDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaBusTermDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaBusTermDef_static_find_doc[] = 
"Class: oaDataAppDef_oaBusTermDef, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaBusTermDef* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaBusTermDef|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaBusTermDef* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaBusTermDef|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaBusTermDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaBusTermDefp result= (oaDataAppDef_oaBusTermDef::find(p1.Data()));
            return PyoaDataAppDef_oaBusTermDef_FromoaDataAppDef_oaBusTermDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaBusTermDefp result= (oaDataAppDef_oaBusTermDef::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaBusTermDef_FromoaDataAppDef_oaBusTermDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaBusTermDef, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaBusTermDef_static_get_doc[] = 
"Class: oaDataAppDef_oaBusTermDef, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaBusTermDef* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaBusTermDef|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaBusTermDef* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaBusTermDef|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaBusTermDef_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaBusTermDefp result= (oaDataAppDef_oaBusTermDef::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaBusTermDef_FromoaDataAppDef_oaBusTermDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaBusTermDefp result= (oaDataAppDef_oaBusTermDef::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaBusTermDef_FromoaDataAppDef_oaBusTermDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaBusTermDef, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaBusTermDef_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaBusTermDef_static_find,METH_VARARGS,oaDataAppDef_oaBusTermDef_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaBusTermDef_static_get,METH_VARARGS,oaDataAppDef_oaBusTermDef_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaBusTermDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaBusTermDef_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaBusTermDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaBusTermDef",
           (PyObject*)(&PyoaDataAppDef_oaBusTermDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaBusTermDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaBusTermDef_Type.tp_dict;
    for(method=oaDataAppDef_oaBusTermDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaCMap
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaCMap_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaCMap_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaCMapObject* self = (PyoaDataAppDef_oaCMapObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaCMap)
    {
        PyParamoaDataAppDef_oaCMap p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaCMap_Convert,&p1)) {
            PyoaDataAppDef_oaCMapObject* cself=((PyoaDataAppDef_oaCMapObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaCMap, Choices are:\n"
        "    (oaDataAppDef_oaCMap)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaCMap_tp_dealloc(PyoaDataAppDef_oaCMapObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaCMap_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaCMap value;
    int convert_status=PyoaDataAppDef_oaCMap_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[41];
    sprintf(buffer,"<oaDataAppDef_oaCMap::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaCMap_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaCMap v1;
    PyParamoaDataAppDef_oaCMap v2;
    int convert_status1=PyoaDataAppDef_oaCMap_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaCMap_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaCMap_Convert(PyObject* ob,PyParamoaDataAppDef_oaCMap* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaCMap_Check(ob)) {
        result->SetData( (oaDataAppDef_oaCMap**) ((PyoaDataAppDef_oaCMapObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaCMap Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaCMap_FromoaDataAppDef_oaCMap(oaDataAppDef_oaCMap** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaCMap* data=*value;
        PyObject* bself = PyoaDataAppDef_oaCMap_Type.tp_alloc(&PyoaDataAppDef_oaCMap_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaCMapObject* self = (PyoaDataAppDef_oaCMapObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaCMap_FromoaDataAppDef_oaCMap(oaDataAppDef_oaCMap* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaCMap_Type.tp_alloc(&PyoaDataAppDef_oaCMap_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaCMapObject* self = (PyoaDataAppDef_oaCMapObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaCMap_get_doc[] = 
"Class: oaDataAppDef_oaCMap, Function: get\n"
"  Paramegers: (oaCMap,[oaByte])\n"
"    Calls: void get(const oaCMap* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaCMap,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaCMap_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaCMap data;
    int convert_status=PyoaDataAppDef_oaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaCMapObject* self=(PyoaDataAppDef_oaCMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaCMap p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaCMap_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaCMap_getDefault_doc[] = 
"Class: oaDataAppDef_oaCMap, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaCMap_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaCMap data;
    int convert_status=PyoaDataAppDef_oaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaCMapObject* self=(PyoaDataAppDef_oaCMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaCMap_getSize_doc[] = 
"Class: oaDataAppDef_oaCMap, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaCMap_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaCMap data;
    int convert_status=PyoaDataAppDef_oaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaCMapObject* self=(PyoaDataAppDef_oaCMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaCMap_set_doc[] = 
"Class: oaDataAppDef_oaCMap, Function: set\n"
"  Paramegers: (oaCMap,[oaByte])\n"
"    Calls: void set(oaCMap* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaCMap,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaCMap_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaCMap data;
    int convert_status=PyoaDataAppDef_oaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaCMapObject* self=(PyoaDataAppDef_oaCMapObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaCMap p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaCMap_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaCMap_isNull_doc[] =
"Class: oaDataAppDef_oaCMap, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaCMap_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaCMap data;
    int convert_status=PyoaDataAppDef_oaCMap_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaCMap_assign_doc[] = 
"Class: oaDataAppDef_oaCMap, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaCMap_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaCMap data;
  int convert_status=PyoaDataAppDef_oaCMap_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaCMap p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaCMap_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaCMap_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaCMap_get,METH_VARARGS,oaDataAppDef_oaCMap_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaCMap_getDefault,METH_VARARGS,oaDataAppDef_oaCMap_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaCMap_getSize,METH_VARARGS,oaDataAppDef_oaCMap_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaCMap_set,METH_VARARGS,oaDataAppDef_oaCMap_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaCMap_tp_isNull,METH_VARARGS,oaDataAppDef_oaCMap_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaCMap_tp_assign,METH_VARARGS,oaDataAppDef_oaCMap_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaCMap_doc[] = 
"Class: oaDataAppDef_oaCMap\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaCMap)\n"
"    Calls: (const oaDataAppDef_oaCMap&)\n"
"    Signature: oaDataAppDef_oaCMap||cref-oaDataAppDef_oaCMap,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaCMap_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaCMap",
    sizeof(PyoaDataAppDef_oaCMapObject),
    0,
    (destructor)oaDataAppDef_oaCMap_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaCMap_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaCMap_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaCMap_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaCMap_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaCMap_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaCMap_static_find_doc[] = 
"Class: oaDataAppDef_oaCMap, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaCMap* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaCMap|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaCMap* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaCMap|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaCMap_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaCMapp result= (oaDataAppDef_oaCMap::find(p1.Data()));
            return PyoaDataAppDef_oaCMap_FromoaDataAppDef_oaCMap(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaCMapp result= (oaDataAppDef_oaCMap::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaCMap_FromoaDataAppDef_oaCMap(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaCMap, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaCMap_static_get_doc[] = 
"Class: oaDataAppDef_oaCMap, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaCMap* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaCMap|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaCMap* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaCMap|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaCMap_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaCMapp result= (oaDataAppDef_oaCMap::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaCMap_FromoaDataAppDef_oaCMap(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaCMapp result= (oaDataAppDef_oaCMap::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaCMap_FromoaDataAppDef_oaCMap(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaCMap, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaCMap_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaCMap_static_find,METH_VARARGS,oaDataAppDef_oaCMap_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaCMap_static_get,METH_VARARGS,oaDataAppDef_oaCMap_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaCMap_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaCMap_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaCMap\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaCMap",
           (PyObject*)(&PyoaDataAppDef_oaCMap_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaCMap\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaCMap_Type.tp_dict;
    for(method=oaDataAppDef_oaCMap_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaCell
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaCell_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaCell_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaCellObject* self = (PyoaDataAppDef_oaCellObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaCell)
    {
        PyParamoaDataAppDef_oaCell p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaCell_Convert,&p1)) {
            PyoaDataAppDef_oaCellObject* cself=((PyoaDataAppDef_oaCellObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaCell, Choices are:\n"
        "    (oaDataAppDef_oaCell)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaCell_tp_dealloc(PyoaDataAppDef_oaCellObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaCell_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaCell value;
    int convert_status=PyoaDataAppDef_oaCell_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[41];
    sprintf(buffer,"<oaDataAppDef_oaCell::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaCell_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaCell v1;
    PyParamoaDataAppDef_oaCell v2;
    int convert_status1=PyoaDataAppDef_oaCell_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaCell_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaCell_Convert(PyObject* ob,PyParamoaDataAppDef_oaCell* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaCell_Check(ob)) {
        result->SetData( (oaDataAppDef_oaCell**) ((PyoaDataAppDef_oaCellObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaCell Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaCell_FromoaDataAppDef_oaCell(oaDataAppDef_oaCell** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaCell* data=*value;
        PyObject* bself = PyoaDataAppDef_oaCell_Type.tp_alloc(&PyoaDataAppDef_oaCell_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaCellObject* self = (PyoaDataAppDef_oaCellObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaCell_FromoaDataAppDef_oaCell(oaDataAppDef_oaCell* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaCell_Type.tp_alloc(&PyoaDataAppDef_oaCell_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaCellObject* self = (PyoaDataAppDef_oaCellObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaCell_get_doc[] = 
"Class: oaDataAppDef_oaCell, Function: get\n"
"  Paramegers: (oaCell,[oaByte])\n"
"    Calls: void get(const oaCell* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaCell,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaCell_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaCell data;
    int convert_status=PyoaDataAppDef_oaCell_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaCellObject* self=(PyoaDataAppDef_oaCellObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaCell p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaCell_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaCell_getDefault_doc[] = 
"Class: oaDataAppDef_oaCell, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaCell_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaCell data;
    int convert_status=PyoaDataAppDef_oaCell_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaCellObject* self=(PyoaDataAppDef_oaCellObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaCell_getSize_doc[] = 
"Class: oaDataAppDef_oaCell, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaCell_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaCell data;
    int convert_status=PyoaDataAppDef_oaCell_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaCellObject* self=(PyoaDataAppDef_oaCellObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaCell_set_doc[] = 
"Class: oaDataAppDef_oaCell, Function: set\n"
"  Paramegers: (oaCell,[oaByte])\n"
"    Calls: void set(oaCell* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaCell,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaCell_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaCell data;
    int convert_status=PyoaDataAppDef_oaCell_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaCellObject* self=(PyoaDataAppDef_oaCellObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaCell p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaCell_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaCell_isNull_doc[] =
"Class: oaDataAppDef_oaCell, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaCell_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaCell data;
    int convert_status=PyoaDataAppDef_oaCell_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaCell_assign_doc[] = 
"Class: oaDataAppDef_oaCell, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaCell_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaCell data;
  int convert_status=PyoaDataAppDef_oaCell_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaCell p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaCell_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaCell_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaCell_get,METH_VARARGS,oaDataAppDef_oaCell_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaCell_getDefault,METH_VARARGS,oaDataAppDef_oaCell_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaCell_getSize,METH_VARARGS,oaDataAppDef_oaCell_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaCell_set,METH_VARARGS,oaDataAppDef_oaCell_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaCell_tp_isNull,METH_VARARGS,oaDataAppDef_oaCell_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaCell_tp_assign,METH_VARARGS,oaDataAppDef_oaCell_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaCell_doc[] = 
"Class: oaDataAppDef_oaCell\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaCell)\n"
"    Calls: (const oaDataAppDef_oaCell&)\n"
"    Signature: oaDataAppDef_oaCell||cref-oaDataAppDef_oaCell,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaCell_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaCell",
    sizeof(PyoaDataAppDef_oaCellObject),
    0,
    (destructor)oaDataAppDef_oaCell_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaCell_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaCell_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaCell_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaCell_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaCell_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaCell_static_find_doc[] = 
"Class: oaDataAppDef_oaCell, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaCell* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaCell|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaCell* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaCell|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaCell_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaCellp result= (oaDataAppDef_oaCell::find(p1.Data()));
            return PyoaDataAppDef_oaCell_FromoaDataAppDef_oaCell(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaCellp result= (oaDataAppDef_oaCell::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaCell_FromoaDataAppDef_oaCell(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaCell, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaCell_static_get_doc[] = 
"Class: oaDataAppDef_oaCell, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaCell* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaCell|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaCell* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaCell|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaCell_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaCellp result= (oaDataAppDef_oaCell::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaCell_FromoaDataAppDef_oaCell(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaCellp result= (oaDataAppDef_oaCell::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaCell_FromoaDataAppDef_oaCell(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaCell, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaCell_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaCell_static_find,METH_VARARGS,oaDataAppDef_oaCell_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaCell_static_get,METH_VARARGS,oaDataAppDef_oaCell_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaCell_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaCell_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaCell\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaCell",
           (PyObject*)(&PyoaDataAppDef_oaCell_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaCell\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaCell_Type.tp_dict;
    for(method=oaDataAppDef_oaCell_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaCellView
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaCellView_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaCellView_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaCellViewObject* self = (PyoaDataAppDef_oaCellViewObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaCellView)
    {
        PyParamoaDataAppDef_oaCellView p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaCellView_Convert,&p1)) {
            PyoaDataAppDef_oaCellViewObject* cself=((PyoaDataAppDef_oaCellViewObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaCellView, Choices are:\n"
        "    (oaDataAppDef_oaCellView)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaCellView_tp_dealloc(PyoaDataAppDef_oaCellViewObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaCellView_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaCellView value;
    int convert_status=PyoaDataAppDef_oaCellView_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[45];
    sprintf(buffer,"<oaDataAppDef_oaCellView::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaCellView_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaCellView v1;
    PyParamoaDataAppDef_oaCellView v2;
    int convert_status1=PyoaDataAppDef_oaCellView_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaCellView_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaCellView_Convert(PyObject* ob,PyParamoaDataAppDef_oaCellView* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaCellView_Check(ob)) {
        result->SetData( (oaDataAppDef_oaCellView**) ((PyoaDataAppDef_oaCellViewObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaCellView Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaCellView_FromoaDataAppDef_oaCellView(oaDataAppDef_oaCellView** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaCellView* data=*value;
        PyObject* bself = PyoaDataAppDef_oaCellView_Type.tp_alloc(&PyoaDataAppDef_oaCellView_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaCellViewObject* self = (PyoaDataAppDef_oaCellViewObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaCellView_FromoaDataAppDef_oaCellView(oaDataAppDef_oaCellView* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaCellView_Type.tp_alloc(&PyoaDataAppDef_oaCellView_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaCellViewObject* self = (PyoaDataAppDef_oaCellViewObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaCellView_get_doc[] = 
"Class: oaDataAppDef_oaCellView, Function: get\n"
"  Paramegers: (oaCellView,[oaByte])\n"
"    Calls: void get(const oaCellView* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaCellView,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaCellView_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaCellView data;
    int convert_status=PyoaDataAppDef_oaCellView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaCellViewObject* self=(PyoaDataAppDef_oaCellViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaCellView p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaCellView_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaCellView_getDefault_doc[] = 
"Class: oaDataAppDef_oaCellView, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaCellView_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaCellView data;
    int convert_status=PyoaDataAppDef_oaCellView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaCellViewObject* self=(PyoaDataAppDef_oaCellViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaCellView_getSize_doc[] = 
"Class: oaDataAppDef_oaCellView, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaCellView_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaCellView data;
    int convert_status=PyoaDataAppDef_oaCellView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaCellViewObject* self=(PyoaDataAppDef_oaCellViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaCellView_set_doc[] = 
"Class: oaDataAppDef_oaCellView, Function: set\n"
"  Paramegers: (oaCellView,[oaByte])\n"
"    Calls: void set(oaCellView* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaCellView,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaCellView_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaCellView data;
    int convert_status=PyoaDataAppDef_oaCellView_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaCellViewObject* self=(PyoaDataAppDef_oaCellViewObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaCellView p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaCellView_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaCellView_isNull_doc[] =
"Class: oaDataAppDef_oaCellView, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaCellView_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaCellView data;
    int convert_status=PyoaDataAppDef_oaCellView_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaCellView_assign_doc[] = 
"Class: oaDataAppDef_oaCellView, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaCellView_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaCellView data;
  int convert_status=PyoaDataAppDef_oaCellView_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaCellView p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaCellView_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaCellView_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaCellView_get,METH_VARARGS,oaDataAppDef_oaCellView_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaCellView_getDefault,METH_VARARGS,oaDataAppDef_oaCellView_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaCellView_getSize,METH_VARARGS,oaDataAppDef_oaCellView_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaCellView_set,METH_VARARGS,oaDataAppDef_oaCellView_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaCellView_tp_isNull,METH_VARARGS,oaDataAppDef_oaCellView_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaCellView_tp_assign,METH_VARARGS,oaDataAppDef_oaCellView_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaCellView_doc[] = 
"Class: oaDataAppDef_oaCellView\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaCellView)\n"
"    Calls: (const oaDataAppDef_oaCellView&)\n"
"    Signature: oaDataAppDef_oaCellView||cref-oaDataAppDef_oaCellView,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaCellView_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaCellView",
    sizeof(PyoaDataAppDef_oaCellViewObject),
    0,
    (destructor)oaDataAppDef_oaCellView_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaCellView_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaCellView_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaCellView_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaCellView_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaCellView_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaCellView_static_find_doc[] = 
"Class: oaDataAppDef_oaCellView, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaCellView* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaCellView|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaCellView* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaCellView|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaCellView_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaCellViewp result= (oaDataAppDef_oaCellView::find(p1.Data()));
            return PyoaDataAppDef_oaCellView_FromoaDataAppDef_oaCellView(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaCellViewp result= (oaDataAppDef_oaCellView::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaCellView_FromoaDataAppDef_oaCellView(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaCellView, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaCellView_static_get_doc[] = 
"Class: oaDataAppDef_oaCellView, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaCellView* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaCellView|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaCellView* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaCellView|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaCellView_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaCellViewp result= (oaDataAppDef_oaCellView::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaCellView_FromoaDataAppDef_oaCellView(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaCellViewp result= (oaDataAppDef_oaCellView::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaCellView_FromoaDataAppDef_oaCellView(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaCellView, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaCellView_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaCellView_static_find,METH_VARARGS,oaDataAppDef_oaCellView_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaCellView_static_get,METH_VARARGS,oaDataAppDef_oaCellView_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaCellView_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaCellView_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaCellView\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaCellView",
           (PyObject*)(&PyoaDataAppDef_oaCellView_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaCellView\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaCellView_Type.tp_dict;
    for(method=oaDataAppDef_oaCellView_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaCluster
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaCluster_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaCluster_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaClusterObject* self = (PyoaDataAppDef_oaClusterObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaCluster)
    {
        PyParamoaDataAppDef_oaCluster p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaCluster_Convert,&p1)) {
            PyoaDataAppDef_oaClusterObject* cself=((PyoaDataAppDef_oaClusterObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaCluster, Choices are:\n"
        "    (oaDataAppDef_oaCluster)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaCluster_tp_dealloc(PyoaDataAppDef_oaClusterObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaCluster_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaCluster value;
    int convert_status=PyoaDataAppDef_oaCluster_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[44];
    sprintf(buffer,"<oaDataAppDef_oaCluster::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaCluster_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaCluster v1;
    PyParamoaDataAppDef_oaCluster v2;
    int convert_status1=PyoaDataAppDef_oaCluster_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaCluster_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaCluster_Convert(PyObject* ob,PyParamoaDataAppDef_oaCluster* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaCluster_Check(ob)) {
        result->SetData( (oaDataAppDef_oaCluster**) ((PyoaDataAppDef_oaClusterObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaCluster Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaCluster_FromoaDataAppDef_oaCluster(oaDataAppDef_oaCluster** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaCluster* data=*value;
        PyObject* bself = PyoaDataAppDef_oaCluster_Type.tp_alloc(&PyoaDataAppDef_oaCluster_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaClusterObject* self = (PyoaDataAppDef_oaClusterObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaCluster_FromoaDataAppDef_oaCluster(oaDataAppDef_oaCluster* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaCluster_Type.tp_alloc(&PyoaDataAppDef_oaCluster_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaClusterObject* self = (PyoaDataAppDef_oaClusterObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaCluster_get_doc[] = 
"Class: oaDataAppDef_oaCluster, Function: get\n"
"  Paramegers: (oaCluster,[oaByte])\n"
"    Calls: void get(const oaCluster* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaCluster,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaCluster_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaCluster data;
    int convert_status=PyoaDataAppDef_oaCluster_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaClusterObject* self=(PyoaDataAppDef_oaClusterObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaCluster p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaCluster_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaCluster_getDefault_doc[] = 
"Class: oaDataAppDef_oaCluster, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaCluster_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaCluster data;
    int convert_status=PyoaDataAppDef_oaCluster_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaClusterObject* self=(PyoaDataAppDef_oaClusterObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaCluster_getSize_doc[] = 
"Class: oaDataAppDef_oaCluster, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaCluster_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaCluster data;
    int convert_status=PyoaDataAppDef_oaCluster_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaClusterObject* self=(PyoaDataAppDef_oaClusterObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaCluster_set_doc[] = 
"Class: oaDataAppDef_oaCluster, Function: set\n"
"  Paramegers: (oaCluster,[oaByte])\n"
"    Calls: void set(oaCluster* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaCluster,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaCluster_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaCluster data;
    int convert_status=PyoaDataAppDef_oaCluster_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaClusterObject* self=(PyoaDataAppDef_oaClusterObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaCluster p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaCluster_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaCluster_isNull_doc[] =
"Class: oaDataAppDef_oaCluster, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaCluster_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaCluster data;
    int convert_status=PyoaDataAppDef_oaCluster_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaCluster_assign_doc[] = 
"Class: oaDataAppDef_oaCluster, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaCluster_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaCluster data;
  int convert_status=PyoaDataAppDef_oaCluster_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaCluster p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaCluster_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaCluster_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaCluster_get,METH_VARARGS,oaDataAppDef_oaCluster_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaCluster_getDefault,METH_VARARGS,oaDataAppDef_oaCluster_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaCluster_getSize,METH_VARARGS,oaDataAppDef_oaCluster_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaCluster_set,METH_VARARGS,oaDataAppDef_oaCluster_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaCluster_tp_isNull,METH_VARARGS,oaDataAppDef_oaCluster_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaCluster_tp_assign,METH_VARARGS,oaDataAppDef_oaCluster_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaCluster_doc[] = 
"Class: oaDataAppDef_oaCluster\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaCluster)\n"
"    Calls: (const oaDataAppDef_oaCluster&)\n"
"    Signature: oaDataAppDef_oaCluster||cref-oaDataAppDef_oaCluster,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaCluster_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaCluster",
    sizeof(PyoaDataAppDef_oaClusterObject),
    0,
    (destructor)oaDataAppDef_oaCluster_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaCluster_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaCluster_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaCluster_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaCluster_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaCluster_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaCluster_static_find_doc[] = 
"Class: oaDataAppDef_oaCluster, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaCluster* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaCluster|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaCluster* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaCluster|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaCluster_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaClusterp result= (oaDataAppDef_oaCluster::find(p1.Data()));
            return PyoaDataAppDef_oaCluster_FromoaDataAppDef_oaCluster(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaClusterp result= (oaDataAppDef_oaCluster::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaCluster_FromoaDataAppDef_oaCluster(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaCluster, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaCluster_static_get_doc[] = 
"Class: oaDataAppDef_oaCluster, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaCluster* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaCluster|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaCluster* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaCluster|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaCluster_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaClusterp result= (oaDataAppDef_oaCluster::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaCluster_FromoaDataAppDef_oaCluster(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaClusterp result= (oaDataAppDef_oaCluster::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaCluster_FromoaDataAppDef_oaCluster(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaCluster, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaCluster_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaCluster_static_find,METH_VARARGS,oaDataAppDef_oaCluster_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaCluster_static_get,METH_VARARGS,oaDataAppDef_oaCluster_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaCluster_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaCluster_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaCluster\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaCluster",
           (PyObject*)(&PyoaDataAppDef_oaCluster_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaCluster\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaCluster_Type.tp_dict;
    for(method=oaDataAppDef_oaCluster_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaConnectDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaConnectDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaConnectDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaConnectDefObject* self = (PyoaDataAppDef_oaConnectDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaConnectDef)
    {
        PyParamoaDataAppDef_oaConnectDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaConnectDef_Convert,&p1)) {
            PyoaDataAppDef_oaConnectDefObject* cself=((PyoaDataAppDef_oaConnectDefObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaConnectDef, Choices are:\n"
        "    (oaDataAppDef_oaConnectDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaConnectDef_tp_dealloc(PyoaDataAppDef_oaConnectDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaConnectDef_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaConnectDef value;
    int convert_status=PyoaDataAppDef_oaConnectDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[47];
    sprintf(buffer,"<oaDataAppDef_oaConnectDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaConnectDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaConnectDef v1;
    PyParamoaDataAppDef_oaConnectDef v2;
    int convert_status1=PyoaDataAppDef_oaConnectDef_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaConnectDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaConnectDef_Convert(PyObject* ob,PyParamoaDataAppDef_oaConnectDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaConnectDef_Check(ob)) {
        result->SetData( (oaDataAppDef_oaConnectDef**) ((PyoaDataAppDef_oaConnectDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaConnectDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaConnectDef_FromoaDataAppDef_oaConnectDef(oaDataAppDef_oaConnectDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaConnectDef* data=*value;
        PyObject* bself = PyoaDataAppDef_oaConnectDef_Type.tp_alloc(&PyoaDataAppDef_oaConnectDef_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaConnectDefObject* self = (PyoaDataAppDef_oaConnectDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaConnectDef_FromoaDataAppDef_oaConnectDef(oaDataAppDef_oaConnectDef* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaConnectDef_Type.tp_alloc(&PyoaDataAppDef_oaConnectDef_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaConnectDefObject* self = (PyoaDataAppDef_oaConnectDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaConnectDef_get_doc[] = 
"Class: oaDataAppDef_oaConnectDef, Function: get\n"
"  Paramegers: (oaConnectDef,[oaByte])\n"
"    Calls: void get(const oaConnectDef* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaConnectDef,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaConnectDef_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConnectDef data;
    int convert_status=PyoaDataAppDef_oaConnectDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConnectDefObject* self=(PyoaDataAppDef_oaConnectDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaConnectDef p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaConnectDef_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConnectDef_getDefault_doc[] = 
"Class: oaDataAppDef_oaConnectDef, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaConnectDef_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConnectDef data;
    int convert_status=PyoaDataAppDef_oaConnectDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConnectDefObject* self=(PyoaDataAppDef_oaConnectDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConnectDef_getSize_doc[] = 
"Class: oaDataAppDef_oaConnectDef, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaConnectDef_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConnectDef data;
    int convert_status=PyoaDataAppDef_oaConnectDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConnectDefObject* self=(PyoaDataAppDef_oaConnectDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConnectDef_set_doc[] = 
"Class: oaDataAppDef_oaConnectDef, Function: set\n"
"  Paramegers: (oaConnectDef,[oaByte])\n"
"    Calls: void set(oaConnectDef* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaConnectDef,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaConnectDef_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConnectDef data;
    int convert_status=PyoaDataAppDef_oaConnectDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConnectDefObject* self=(PyoaDataAppDef_oaConnectDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaConnectDef p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaConnectDef_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConnectDef_isNull_doc[] =
"Class: oaDataAppDef_oaConnectDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaConnectDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaConnectDef data;
    int convert_status=PyoaDataAppDef_oaConnectDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaConnectDef_assign_doc[] = 
"Class: oaDataAppDef_oaConnectDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaConnectDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaConnectDef data;
  int convert_status=PyoaDataAppDef_oaConnectDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaConnectDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaConnectDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaConnectDef_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaConnectDef_get,METH_VARARGS,oaDataAppDef_oaConnectDef_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaConnectDef_getDefault,METH_VARARGS,oaDataAppDef_oaConnectDef_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaConnectDef_getSize,METH_VARARGS,oaDataAppDef_oaConnectDef_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaConnectDef_set,METH_VARARGS,oaDataAppDef_oaConnectDef_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaConnectDef_tp_isNull,METH_VARARGS,oaDataAppDef_oaConnectDef_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaConnectDef_tp_assign,METH_VARARGS,oaDataAppDef_oaConnectDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaConnectDef_doc[] = 
"Class: oaDataAppDef_oaConnectDef\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaConnectDef)\n"
"    Calls: (const oaDataAppDef_oaConnectDef&)\n"
"    Signature: oaDataAppDef_oaConnectDef||cref-oaDataAppDef_oaConnectDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaConnectDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaConnectDef",
    sizeof(PyoaDataAppDef_oaConnectDefObject),
    0,
    (destructor)oaDataAppDef_oaConnectDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaConnectDef_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaConnectDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaConnectDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaConnectDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaConnectDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaConnectDef_static_find_doc[] = 
"Class: oaDataAppDef_oaConnectDef, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaConnectDef* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaConnectDef|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaConnectDef* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaConnectDef|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaConnectDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaConnectDefp result= (oaDataAppDef_oaConnectDef::find(p1.Data()));
            return PyoaDataAppDef_oaConnectDef_FromoaDataAppDef_oaConnectDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaConnectDefp result= (oaDataAppDef_oaConnectDef::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaConnectDef_FromoaDataAppDef_oaConnectDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaConnectDef, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConnectDef_static_get_doc[] = 
"Class: oaDataAppDef_oaConnectDef, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaConnectDef* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaConnectDef|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaConnectDef* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaConnectDef|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaConnectDef_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaConnectDefp result= (oaDataAppDef_oaConnectDef::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaConnectDef_FromoaDataAppDef_oaConnectDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaConnectDefp result= (oaDataAppDef_oaConnectDef::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaConnectDef_FromoaDataAppDef_oaConnectDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaConnectDef, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaConnectDef_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaConnectDef_static_find,METH_VARARGS,oaDataAppDef_oaConnectDef_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaConnectDef_static_get,METH_VARARGS,oaDataAppDef_oaConnectDef_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaConnectDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaConnectDef_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaConnectDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaConnectDef",
           (PyObject*)(&PyoaDataAppDef_oaConnectDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaConnectDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaConnectDef_Type.tp_dict;
    for(method=oaDataAppDef_oaConnectDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaConstraint
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaConstraint_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaConstraint_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaConstraintObject* self = (PyoaDataAppDef_oaConstraintObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaConstraint)
    {
        PyParamoaDataAppDef_oaConstraint p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaConstraint_Convert,&p1)) {
            PyoaDataAppDef_oaConstraintObject* cself=((PyoaDataAppDef_oaConstraintObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaConstraint, Choices are:\n"
        "    (oaDataAppDef_oaConstraint)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaConstraint_tp_dealloc(PyoaDataAppDef_oaConstraintObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaConstraint_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaConstraint value;
    int convert_status=PyoaDataAppDef_oaConstraint_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[47];
    sprintf(buffer,"<oaDataAppDef_oaConstraint::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaConstraint_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaConstraint v1;
    PyParamoaDataAppDef_oaConstraint v2;
    int convert_status1=PyoaDataAppDef_oaConstraint_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaConstraint_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaConstraint_Convert(PyObject* ob,PyParamoaDataAppDef_oaConstraint* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaConstraint_Check(ob)) {
        result->SetData( (oaDataAppDef_oaConstraint**) ((PyoaDataAppDef_oaConstraintObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaConstraint Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaConstraint_FromoaDataAppDef_oaConstraint(oaDataAppDef_oaConstraint** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaConstraint* data=*value;
        PyObject* bself = PyoaDataAppDef_oaConstraint_Type.tp_alloc(&PyoaDataAppDef_oaConstraint_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaConstraintObject* self = (PyoaDataAppDef_oaConstraintObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaConstraint_FromoaDataAppDef_oaConstraint(oaDataAppDef_oaConstraint* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaConstraint_Type.tp_alloc(&PyoaDataAppDef_oaConstraint_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaConstraintObject* self = (PyoaDataAppDef_oaConstraintObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraint_get_doc[] = 
"Class: oaDataAppDef_oaConstraint, Function: get\n"
"  Paramegers: (oaConstraint,[oaByte])\n"
"    Calls: void get(const oaConstraint* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaConstraint,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaConstraint_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraint data;
    int convert_status=PyoaDataAppDef_oaConstraint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintObject* self=(PyoaDataAppDef_oaConstraintObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaConstraint p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaConstraint_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraint_getDefault_doc[] = 
"Class: oaDataAppDef_oaConstraint, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaConstraint_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraint data;
    int convert_status=PyoaDataAppDef_oaConstraint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintObject* self=(PyoaDataAppDef_oaConstraintObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraint_getSize_doc[] = 
"Class: oaDataAppDef_oaConstraint, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaConstraint_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraint data;
    int convert_status=PyoaDataAppDef_oaConstraint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintObject* self=(PyoaDataAppDef_oaConstraintObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraint_set_doc[] = 
"Class: oaDataAppDef_oaConstraint, Function: set\n"
"  Paramegers: (oaConstraint,[oaByte])\n"
"    Calls: void set(oaConstraint* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaConstraint,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaConstraint_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraint data;
    int convert_status=PyoaDataAppDef_oaConstraint_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintObject* self=(PyoaDataAppDef_oaConstraintObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaConstraint p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaConstraint_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraint_isNull_doc[] =
"Class: oaDataAppDef_oaConstraint, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaConstraint_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaConstraint data;
    int convert_status=PyoaDataAppDef_oaConstraint_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaConstraint_assign_doc[] = 
"Class: oaDataAppDef_oaConstraint, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaConstraint_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaConstraint data;
  int convert_status=PyoaDataAppDef_oaConstraint_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaConstraint p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaConstraint_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaConstraint_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaConstraint_get,METH_VARARGS,oaDataAppDef_oaConstraint_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaConstraint_getDefault,METH_VARARGS,oaDataAppDef_oaConstraint_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaConstraint_getSize,METH_VARARGS,oaDataAppDef_oaConstraint_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaConstraint_set,METH_VARARGS,oaDataAppDef_oaConstraint_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaConstraint_tp_isNull,METH_VARARGS,oaDataAppDef_oaConstraint_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaConstraint_tp_assign,METH_VARARGS,oaDataAppDef_oaConstraint_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraint_doc[] = 
"Class: oaDataAppDef_oaConstraint\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaConstraint)\n"
"    Calls: (const oaDataAppDef_oaConstraint&)\n"
"    Signature: oaDataAppDef_oaConstraint||cref-oaDataAppDef_oaConstraint,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaConstraint_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaConstraint",
    sizeof(PyoaDataAppDef_oaConstraintObject),
    0,
    (destructor)oaDataAppDef_oaConstraint_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaConstraint_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaConstraint_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaConstraint_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaConstraint_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaConstraint_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraint_static_find_doc[] = 
"Class: oaDataAppDef_oaConstraint, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaConstraint* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaConstraint|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaConstraint* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaConstraint|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaConstraint_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaConstraintp result= (oaDataAppDef_oaConstraint::find(p1.Data()));
            return PyoaDataAppDef_oaConstraint_FromoaDataAppDef_oaConstraint(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaConstraintp result= (oaDataAppDef_oaConstraint::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaConstraint_FromoaDataAppDef_oaConstraint(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaConstraint, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraint_static_get_doc[] = 
"Class: oaDataAppDef_oaConstraint, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaConstraint* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaConstraint|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaConstraint* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaConstraint|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaConstraint_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaConstraintp result= (oaDataAppDef_oaConstraint::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaConstraint_FromoaDataAppDef_oaConstraint(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaConstraintp result= (oaDataAppDef_oaConstraint::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaConstraint_FromoaDataAppDef_oaConstraint(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaConstraint, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaConstraint_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaConstraint_static_find,METH_VARARGS,oaDataAppDef_oaConstraint_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaConstraint_static_get,METH_VARARGS,oaDataAppDef_oaConstraint_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaConstraint_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaConstraint_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaConstraint\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaConstraint",
           (PyObject*)(&PyoaDataAppDef_oaConstraint_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaConstraint\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaConstraint_Type.tp_dict;
    for(method=oaDataAppDef_oaConstraint_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaConstraintDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaConstraintDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaConstraintDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaConstraintDefObject* self = (PyoaDataAppDef_oaConstraintDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaConstraintDef)
    {
        PyParamoaDataAppDef_oaConstraintDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaConstraintDef_Convert,&p1)) {
            PyoaDataAppDef_oaConstraintDefObject* cself=((PyoaDataAppDef_oaConstraintDefObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaConstraintDef, Choices are:\n"
        "    (oaDataAppDef_oaConstraintDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaConstraintDef_tp_dealloc(PyoaDataAppDef_oaConstraintDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaConstraintDef_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaConstraintDef value;
    int convert_status=PyoaDataAppDef_oaConstraintDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[50];
    sprintf(buffer,"<oaDataAppDef_oaConstraintDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaConstraintDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaConstraintDef v1;
    PyParamoaDataAppDef_oaConstraintDef v2;
    int convert_status1=PyoaDataAppDef_oaConstraintDef_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaConstraintDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaConstraintDef_Convert(PyObject* ob,PyParamoaDataAppDef_oaConstraintDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaConstraintDef_Check(ob)) {
        result->SetData( (oaDataAppDef_oaConstraintDef**) ((PyoaDataAppDef_oaConstraintDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaConstraintDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaConstraintDef_FromoaDataAppDef_oaConstraintDef(oaDataAppDef_oaConstraintDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaConstraintDef* data=*value;
        PyObject* bself = PyoaDataAppDef_oaConstraintDef_Type.tp_alloc(&PyoaDataAppDef_oaConstraintDef_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaConstraintDefObject* self = (PyoaDataAppDef_oaConstraintDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaConstraintDef_FromoaDataAppDef_oaConstraintDef(oaDataAppDef_oaConstraintDef* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaConstraintDef_Type.tp_alloc(&PyoaDataAppDef_oaConstraintDef_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaConstraintDefObject* self = (PyoaDataAppDef_oaConstraintDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintDef_get_doc[] = 
"Class: oaDataAppDef_oaConstraintDef, Function: get\n"
"  Paramegers: (oaConstraintDef,[oaByte])\n"
"    Calls: void get(const oaConstraintDef* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaConstraintDef,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaConstraintDef_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraintDef data;
    int convert_status=PyoaDataAppDef_oaConstraintDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintDefObject* self=(PyoaDataAppDef_oaConstraintDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaConstraintDef p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaConstraintDef_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintDef_getDefault_doc[] = 
"Class: oaDataAppDef_oaConstraintDef, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaConstraintDef_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraintDef data;
    int convert_status=PyoaDataAppDef_oaConstraintDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintDefObject* self=(PyoaDataAppDef_oaConstraintDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintDef_getSize_doc[] = 
"Class: oaDataAppDef_oaConstraintDef, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaConstraintDef_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraintDef data;
    int convert_status=PyoaDataAppDef_oaConstraintDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintDefObject* self=(PyoaDataAppDef_oaConstraintDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintDef_set_doc[] = 
"Class: oaDataAppDef_oaConstraintDef, Function: set\n"
"  Paramegers: (oaConstraintDef,[oaByte])\n"
"    Calls: void set(oaConstraintDef* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaConstraintDef,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaConstraintDef_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraintDef data;
    int convert_status=PyoaDataAppDef_oaConstraintDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintDefObject* self=(PyoaDataAppDef_oaConstraintDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaConstraintDef p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaConstraintDef_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintDef_isNull_doc[] =
"Class: oaDataAppDef_oaConstraintDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaConstraintDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaConstraintDef data;
    int convert_status=PyoaDataAppDef_oaConstraintDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaConstraintDef_assign_doc[] = 
"Class: oaDataAppDef_oaConstraintDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaConstraintDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaConstraintDef data;
  int convert_status=PyoaDataAppDef_oaConstraintDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaConstraintDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaConstraintDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaConstraintDef_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaConstraintDef_get,METH_VARARGS,oaDataAppDef_oaConstraintDef_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaConstraintDef_getDefault,METH_VARARGS,oaDataAppDef_oaConstraintDef_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaConstraintDef_getSize,METH_VARARGS,oaDataAppDef_oaConstraintDef_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaConstraintDef_set,METH_VARARGS,oaDataAppDef_oaConstraintDef_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaConstraintDef_tp_isNull,METH_VARARGS,oaDataAppDef_oaConstraintDef_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaConstraintDef_tp_assign,METH_VARARGS,oaDataAppDef_oaConstraintDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintDef_doc[] = 
"Class: oaDataAppDef_oaConstraintDef\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaConstraintDef)\n"
"    Calls: (const oaDataAppDef_oaConstraintDef&)\n"
"    Signature: oaDataAppDef_oaConstraintDef||cref-oaDataAppDef_oaConstraintDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaConstraintDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaConstraintDef",
    sizeof(PyoaDataAppDef_oaConstraintDefObject),
    0,
    (destructor)oaDataAppDef_oaConstraintDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaConstraintDef_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaConstraintDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaConstraintDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaConstraintDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaConstraintDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintDef_static_find_doc[] = 
"Class: oaDataAppDef_oaConstraintDef, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaConstraintDef* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaConstraintDef|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaConstraintDef* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaConstraintDef|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaConstraintDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaConstraintDefp result= (oaDataAppDef_oaConstraintDef::find(p1.Data()));
            return PyoaDataAppDef_oaConstraintDef_FromoaDataAppDef_oaConstraintDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaConstraintDefp result= (oaDataAppDef_oaConstraintDef::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaConstraintDef_FromoaDataAppDef_oaConstraintDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaConstraintDef, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintDef_static_get_doc[] = 
"Class: oaDataAppDef_oaConstraintDef, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaConstraintDef* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaConstraintDef|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaConstraintDef* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaConstraintDef|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaConstraintDef_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaConstraintDefp result= (oaDataAppDef_oaConstraintDef::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaConstraintDef_FromoaDataAppDef_oaConstraintDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaConstraintDefp result= (oaDataAppDef_oaConstraintDef::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaConstraintDef_FromoaDataAppDef_oaConstraintDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaConstraintDef, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaConstraintDef_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaConstraintDef_static_find,METH_VARARGS,oaDataAppDef_oaConstraintDef_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaConstraintDef_static_get,METH_VARARGS,oaDataAppDef_oaConstraintDef_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaConstraintDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaConstraintDef_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaConstraintDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaConstraintDef",
           (PyObject*)(&PyoaDataAppDef_oaConstraintDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaConstraintDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaConstraintDef_Type.tp_dict;
    for(method=oaDataAppDef_oaConstraintDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaConstraintGroup
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaConstraintGroup_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaConstraintGroup_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaConstraintGroupObject* self = (PyoaDataAppDef_oaConstraintGroupObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaConstraintGroup)
    {
        PyParamoaDataAppDef_oaConstraintGroup p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaConstraintGroup_Convert,&p1)) {
            PyoaDataAppDef_oaConstraintGroupObject* cself=((PyoaDataAppDef_oaConstraintGroupObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaConstraintGroup, Choices are:\n"
        "    (oaDataAppDef_oaConstraintGroup)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaConstraintGroup_tp_dealloc(PyoaDataAppDef_oaConstraintGroupObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaConstraintGroup_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaConstraintGroup value;
    int convert_status=PyoaDataAppDef_oaConstraintGroup_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[52];
    sprintf(buffer,"<oaDataAppDef_oaConstraintGroup::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaConstraintGroup_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaConstraintGroup v1;
    PyParamoaDataAppDef_oaConstraintGroup v2;
    int convert_status1=PyoaDataAppDef_oaConstraintGroup_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaConstraintGroup_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaConstraintGroup_Convert(PyObject* ob,PyParamoaDataAppDef_oaConstraintGroup* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaConstraintGroup_Check(ob)) {
        result->SetData( (oaDataAppDef_oaConstraintGroup**) ((PyoaDataAppDef_oaConstraintGroupObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaConstraintGroup Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaConstraintGroup_FromoaDataAppDef_oaConstraintGroup(oaDataAppDef_oaConstraintGroup** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaConstraintGroup* data=*value;
        PyObject* bself = PyoaDataAppDef_oaConstraintGroup_Type.tp_alloc(&PyoaDataAppDef_oaConstraintGroup_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaConstraintGroupObject* self = (PyoaDataAppDef_oaConstraintGroupObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaConstraintGroup_FromoaDataAppDef_oaConstraintGroup(oaDataAppDef_oaConstraintGroup* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaConstraintGroup_Type.tp_alloc(&PyoaDataAppDef_oaConstraintGroup_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaConstraintGroupObject* self = (PyoaDataAppDef_oaConstraintGroupObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintGroup_get_doc[] = 
"Class: oaDataAppDef_oaConstraintGroup, Function: get\n"
"  Paramegers: (oaConstraintGroup,[oaByte])\n"
"    Calls: void get(const oaConstraintGroup* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaConstraintGroup,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaConstraintGroup_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraintGroup data;
    int convert_status=PyoaDataAppDef_oaConstraintGroup_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintGroupObject* self=(PyoaDataAppDef_oaConstraintGroupObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaConstraintGroup p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaConstraintGroup_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintGroup_getDefault_doc[] = 
"Class: oaDataAppDef_oaConstraintGroup, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaConstraintGroup_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraintGroup data;
    int convert_status=PyoaDataAppDef_oaConstraintGroup_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintGroupObject* self=(PyoaDataAppDef_oaConstraintGroupObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintGroup_getSize_doc[] = 
"Class: oaDataAppDef_oaConstraintGroup, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaConstraintGroup_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraintGroup data;
    int convert_status=PyoaDataAppDef_oaConstraintGroup_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintGroupObject* self=(PyoaDataAppDef_oaConstraintGroupObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintGroup_set_doc[] = 
"Class: oaDataAppDef_oaConstraintGroup, Function: set\n"
"  Paramegers: (oaConstraintGroup,[oaByte])\n"
"    Calls: void set(oaConstraintGroup* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaConstraintGroup,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaConstraintGroup_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraintGroup data;
    int convert_status=PyoaDataAppDef_oaConstraintGroup_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintGroupObject* self=(PyoaDataAppDef_oaConstraintGroupObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaConstraintGroup p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaConstraintGroup_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintGroup_isNull_doc[] =
"Class: oaDataAppDef_oaConstraintGroup, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaConstraintGroup_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaConstraintGroup data;
    int convert_status=PyoaDataAppDef_oaConstraintGroup_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaConstraintGroup_assign_doc[] = 
"Class: oaDataAppDef_oaConstraintGroup, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaConstraintGroup_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaConstraintGroup data;
  int convert_status=PyoaDataAppDef_oaConstraintGroup_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaConstraintGroup p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaConstraintGroup_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaConstraintGroup_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaConstraintGroup_get,METH_VARARGS,oaDataAppDef_oaConstraintGroup_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaConstraintGroup_getDefault,METH_VARARGS,oaDataAppDef_oaConstraintGroup_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaConstraintGroup_getSize,METH_VARARGS,oaDataAppDef_oaConstraintGroup_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaConstraintGroup_set,METH_VARARGS,oaDataAppDef_oaConstraintGroup_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaConstraintGroup_tp_isNull,METH_VARARGS,oaDataAppDef_oaConstraintGroup_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaConstraintGroup_tp_assign,METH_VARARGS,oaDataAppDef_oaConstraintGroup_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintGroup_doc[] = 
"Class: oaDataAppDef_oaConstraintGroup\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaConstraintGroup)\n"
"    Calls: (const oaDataAppDef_oaConstraintGroup&)\n"
"    Signature: oaDataAppDef_oaConstraintGroup||cref-oaDataAppDef_oaConstraintGroup,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaConstraintGroup_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaConstraintGroup",
    sizeof(PyoaDataAppDef_oaConstraintGroupObject),
    0,
    (destructor)oaDataAppDef_oaConstraintGroup_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaConstraintGroup_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaConstraintGroup_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaConstraintGroup_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaConstraintGroup_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaConstraintGroup_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintGroup_static_find_doc[] = 
"Class: oaDataAppDef_oaConstraintGroup, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaConstraintGroup* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaConstraintGroup|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaConstraintGroup* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaConstraintGroup|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaConstraintGroup_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaConstraintGroupp result= (oaDataAppDef_oaConstraintGroup::find(p1.Data()));
            return PyoaDataAppDef_oaConstraintGroup_FromoaDataAppDef_oaConstraintGroup(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaConstraintGroupp result= (oaDataAppDef_oaConstraintGroup::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaConstraintGroup_FromoaDataAppDef_oaConstraintGroup(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaConstraintGroup, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintGroup_static_get_doc[] = 
"Class: oaDataAppDef_oaConstraintGroup, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaConstraintGroup* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaConstraintGroup|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaConstraintGroup* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaConstraintGroup|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaConstraintGroup_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaConstraintGroupp result= (oaDataAppDef_oaConstraintGroup::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaConstraintGroup_FromoaDataAppDef_oaConstraintGroup(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaConstraintGroupp result= (oaDataAppDef_oaConstraintGroup::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaConstraintGroup_FromoaDataAppDef_oaConstraintGroup(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaConstraintGroup, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaConstraintGroup_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaConstraintGroup_static_find,METH_VARARGS,oaDataAppDef_oaConstraintGroup_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaConstraintGroup_static_get,METH_VARARGS,oaDataAppDef_oaConstraintGroup_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaConstraintGroup_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaConstraintGroup_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaConstraintGroup\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaConstraintGroup",
           (PyObject*)(&PyoaDataAppDef_oaConstraintGroup_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaConstraintGroup\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaConstraintGroup_Type.tp_dict;
    for(method=oaDataAppDef_oaConstraintGroup_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaConstraintGroupHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaConstraintGroupHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaConstraintGroupHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaConstraintGroupHeaderObject* self = (PyoaDataAppDef_oaConstraintGroupHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaConstraintGroupHeader)
    {
        PyParamoaDataAppDef_oaConstraintGroupHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaConstraintGroupHeader_Convert,&p1)) {
            PyoaDataAppDef_oaConstraintGroupHeaderObject* cself=((PyoaDataAppDef_oaConstraintGroupHeaderObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaConstraintGroupHeader, Choices are:\n"
        "    (oaDataAppDef_oaConstraintGroupHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaConstraintGroupHeader_tp_dealloc(PyoaDataAppDef_oaConstraintGroupHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaConstraintGroupHeader_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaConstraintGroupHeader value;
    int convert_status=PyoaDataAppDef_oaConstraintGroupHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[58];
    sprintf(buffer,"<oaDataAppDef_oaConstraintGroupHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaConstraintGroupHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaConstraintGroupHeader v1;
    PyParamoaDataAppDef_oaConstraintGroupHeader v2;
    int convert_status1=PyoaDataAppDef_oaConstraintGroupHeader_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaConstraintGroupHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaConstraintGroupHeader_Convert(PyObject* ob,PyParamoaDataAppDef_oaConstraintGroupHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaConstraintGroupHeader_Check(ob)) {
        result->SetData( (oaDataAppDef_oaConstraintGroupHeader**) ((PyoaDataAppDef_oaConstraintGroupHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaConstraintGroupHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaConstraintGroupHeader_FromoaDataAppDef_oaConstraintGroupHeader(oaDataAppDef_oaConstraintGroupHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaConstraintGroupHeader* data=*value;
        PyObject* bself = PyoaDataAppDef_oaConstraintGroupHeader_Type.tp_alloc(&PyoaDataAppDef_oaConstraintGroupHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaConstraintGroupHeaderObject* self = (PyoaDataAppDef_oaConstraintGroupHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaConstraintGroupHeader_FromoaDataAppDef_oaConstraintGroupHeader(oaDataAppDef_oaConstraintGroupHeader* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaConstraintGroupHeader_Type.tp_alloc(&PyoaDataAppDef_oaConstraintGroupHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaConstraintGroupHeaderObject* self = (PyoaDataAppDef_oaConstraintGroupHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintGroupHeader_get_doc[] = 
"Class: oaDataAppDef_oaConstraintGroupHeader, Function: get\n"
"  Paramegers: (oaConstraintGroupHeader,[oaByte])\n"
"    Calls: void get(const oaConstraintGroupHeader* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaConstraintGroupHeader,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaConstraintGroupHeader_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraintGroupHeader data;
    int convert_status=PyoaDataAppDef_oaConstraintGroupHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintGroupHeaderObject* self=(PyoaDataAppDef_oaConstraintGroupHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaConstraintGroupHeader p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaConstraintGroupHeader_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintGroupHeader_getDefault_doc[] = 
"Class: oaDataAppDef_oaConstraintGroupHeader, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaConstraintGroupHeader_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraintGroupHeader data;
    int convert_status=PyoaDataAppDef_oaConstraintGroupHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintGroupHeaderObject* self=(PyoaDataAppDef_oaConstraintGroupHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintGroupHeader_getSize_doc[] = 
"Class: oaDataAppDef_oaConstraintGroupHeader, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaConstraintGroupHeader_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraintGroupHeader data;
    int convert_status=PyoaDataAppDef_oaConstraintGroupHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintGroupHeaderObject* self=(PyoaDataAppDef_oaConstraintGroupHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintGroupHeader_set_doc[] = 
"Class: oaDataAppDef_oaConstraintGroupHeader, Function: set\n"
"  Paramegers: (oaConstraintGroupHeader,[oaByte])\n"
"    Calls: void set(oaConstraintGroupHeader* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaConstraintGroupHeader,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaConstraintGroupHeader_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraintGroupHeader data;
    int convert_status=PyoaDataAppDef_oaConstraintGroupHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintGroupHeaderObject* self=(PyoaDataAppDef_oaConstraintGroupHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaConstraintGroupHeader p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaConstraintGroupHeader_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintGroupHeader_isNull_doc[] =
"Class: oaDataAppDef_oaConstraintGroupHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaConstraintGroupHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaConstraintGroupHeader data;
    int convert_status=PyoaDataAppDef_oaConstraintGroupHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaConstraintGroupHeader_assign_doc[] = 
"Class: oaDataAppDef_oaConstraintGroupHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaConstraintGroupHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaConstraintGroupHeader data;
  int convert_status=PyoaDataAppDef_oaConstraintGroupHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaConstraintGroupHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaConstraintGroupHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaConstraintGroupHeader_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaConstraintGroupHeader_get,METH_VARARGS,oaDataAppDef_oaConstraintGroupHeader_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaConstraintGroupHeader_getDefault,METH_VARARGS,oaDataAppDef_oaConstraintGroupHeader_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaConstraintGroupHeader_getSize,METH_VARARGS,oaDataAppDef_oaConstraintGroupHeader_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaConstraintGroupHeader_set,METH_VARARGS,oaDataAppDef_oaConstraintGroupHeader_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaConstraintGroupHeader_tp_isNull,METH_VARARGS,oaDataAppDef_oaConstraintGroupHeader_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaConstraintGroupHeader_tp_assign,METH_VARARGS,oaDataAppDef_oaConstraintGroupHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintGroupHeader_doc[] = 
"Class: oaDataAppDef_oaConstraintGroupHeader\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaConstraintGroupHeader)\n"
"    Calls: (const oaDataAppDef_oaConstraintGroupHeader&)\n"
"    Signature: oaDataAppDef_oaConstraintGroupHeader||cref-oaDataAppDef_oaConstraintGroupHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaConstraintGroupHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaConstraintGroupHeader",
    sizeof(PyoaDataAppDef_oaConstraintGroupHeaderObject),
    0,
    (destructor)oaDataAppDef_oaConstraintGroupHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaConstraintGroupHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaConstraintGroupHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaConstraintGroupHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaConstraintGroupHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaConstraintGroupHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintGroupHeader_static_find_doc[] = 
"Class: oaDataAppDef_oaConstraintGroupHeader, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaConstraintGroupHeader* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaConstraintGroupHeader|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaConstraintGroupHeader* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaConstraintGroupHeader|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaConstraintGroupHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaConstraintGroupHeaderp result= (oaDataAppDef_oaConstraintGroupHeader::find(p1.Data()));
            return PyoaDataAppDef_oaConstraintGroupHeader_FromoaDataAppDef_oaConstraintGroupHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaConstraintGroupHeaderp result= (oaDataAppDef_oaConstraintGroupHeader::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaConstraintGroupHeader_FromoaDataAppDef_oaConstraintGroupHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaConstraintGroupHeader, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintGroupHeader_static_get_doc[] = 
"Class: oaDataAppDef_oaConstraintGroupHeader, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaConstraintGroupHeader* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaConstraintGroupHeader|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaConstraintGroupHeader* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaConstraintGroupHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaConstraintGroupHeader_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaConstraintGroupHeaderp result= (oaDataAppDef_oaConstraintGroupHeader::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaConstraintGroupHeader_FromoaDataAppDef_oaConstraintGroupHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaConstraintGroupHeaderp result= (oaDataAppDef_oaConstraintGroupHeader::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaConstraintGroupHeader_FromoaDataAppDef_oaConstraintGroupHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaConstraintGroupHeader, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaConstraintGroupHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaConstraintGroupHeader_static_find,METH_VARARGS,oaDataAppDef_oaConstraintGroupHeader_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaConstraintGroupHeader_static_get,METH_VARARGS,oaDataAppDef_oaConstraintGroupHeader_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaConstraintGroupHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaConstraintGroupHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaConstraintGroupHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaConstraintGroupHeader",
           (PyObject*)(&PyoaDataAppDef_oaConstraintGroupHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaConstraintGroupHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaConstraintGroupHeader_Type.tp_dict;
    for(method=oaDataAppDef_oaConstraintGroupHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaConstraintGroupMem
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaConstraintGroupMem_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaConstraintGroupMem_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaConstraintGroupMemObject* self = (PyoaDataAppDef_oaConstraintGroupMemObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaConstraintGroupMem)
    {
        PyParamoaDataAppDef_oaConstraintGroupMem p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaConstraintGroupMem_Convert,&p1)) {
            PyoaDataAppDef_oaConstraintGroupMemObject* cself=((PyoaDataAppDef_oaConstraintGroupMemObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaConstraintGroupMem, Choices are:\n"
        "    (oaDataAppDef_oaConstraintGroupMem)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaConstraintGroupMem_tp_dealloc(PyoaDataAppDef_oaConstraintGroupMemObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaConstraintGroupMem_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaConstraintGroupMem value;
    int convert_status=PyoaDataAppDef_oaConstraintGroupMem_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[55];
    sprintf(buffer,"<oaDataAppDef_oaConstraintGroupMem::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaConstraintGroupMem_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaConstraintGroupMem v1;
    PyParamoaDataAppDef_oaConstraintGroupMem v2;
    int convert_status1=PyoaDataAppDef_oaConstraintGroupMem_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaConstraintGroupMem_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaConstraintGroupMem_Convert(PyObject* ob,PyParamoaDataAppDef_oaConstraintGroupMem* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaConstraintGroupMem_Check(ob)) {
        result->SetData( (oaDataAppDef_oaConstraintGroupMem**) ((PyoaDataAppDef_oaConstraintGroupMemObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaConstraintGroupMem Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaConstraintGroupMem_FromoaDataAppDef_oaConstraintGroupMem(oaDataAppDef_oaConstraintGroupMem** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaConstraintGroupMem* data=*value;
        PyObject* bself = PyoaDataAppDef_oaConstraintGroupMem_Type.tp_alloc(&PyoaDataAppDef_oaConstraintGroupMem_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaConstraintGroupMemObject* self = (PyoaDataAppDef_oaConstraintGroupMemObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaConstraintGroupMem_FromoaDataAppDef_oaConstraintGroupMem(oaDataAppDef_oaConstraintGroupMem* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaConstraintGroupMem_Type.tp_alloc(&PyoaDataAppDef_oaConstraintGroupMem_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaConstraintGroupMemObject* self = (PyoaDataAppDef_oaConstraintGroupMemObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintGroupMem_get_doc[] = 
"Class: oaDataAppDef_oaConstraintGroupMem, Function: get\n"
"  Paramegers: (oaConstraintGroupMem,[oaByte])\n"
"    Calls: void get(const oaConstraintGroupMem* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaConstraintGroupMem,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaConstraintGroupMem_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraintGroupMem data;
    int convert_status=PyoaDataAppDef_oaConstraintGroupMem_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintGroupMemObject* self=(PyoaDataAppDef_oaConstraintGroupMemObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaConstraintGroupMem p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaConstraintGroupMem_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintGroupMem_getDefault_doc[] = 
"Class: oaDataAppDef_oaConstraintGroupMem, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaConstraintGroupMem_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraintGroupMem data;
    int convert_status=PyoaDataAppDef_oaConstraintGroupMem_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintGroupMemObject* self=(PyoaDataAppDef_oaConstraintGroupMemObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintGroupMem_getSize_doc[] = 
"Class: oaDataAppDef_oaConstraintGroupMem, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaConstraintGroupMem_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraintGroupMem data;
    int convert_status=PyoaDataAppDef_oaConstraintGroupMem_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintGroupMemObject* self=(PyoaDataAppDef_oaConstraintGroupMemObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintGroupMem_set_doc[] = 
"Class: oaDataAppDef_oaConstraintGroupMem, Function: set\n"
"  Paramegers: (oaConstraintGroupMem,[oaByte])\n"
"    Calls: void set(oaConstraintGroupMem* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaConstraintGroupMem,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaConstraintGroupMem_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraintGroupMem data;
    int convert_status=PyoaDataAppDef_oaConstraintGroupMem_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintGroupMemObject* self=(PyoaDataAppDef_oaConstraintGroupMemObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaConstraintGroupMem p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaConstraintGroupMem_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintGroupMem_isNull_doc[] =
"Class: oaDataAppDef_oaConstraintGroupMem, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaConstraintGroupMem_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaConstraintGroupMem data;
    int convert_status=PyoaDataAppDef_oaConstraintGroupMem_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaConstraintGroupMem_assign_doc[] = 
"Class: oaDataAppDef_oaConstraintGroupMem, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaConstraintGroupMem_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaConstraintGroupMem data;
  int convert_status=PyoaDataAppDef_oaConstraintGroupMem_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaConstraintGroupMem p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaConstraintGroupMem_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaConstraintGroupMem_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaConstraintGroupMem_get,METH_VARARGS,oaDataAppDef_oaConstraintGroupMem_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaConstraintGroupMem_getDefault,METH_VARARGS,oaDataAppDef_oaConstraintGroupMem_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaConstraintGroupMem_getSize,METH_VARARGS,oaDataAppDef_oaConstraintGroupMem_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaConstraintGroupMem_set,METH_VARARGS,oaDataAppDef_oaConstraintGroupMem_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaConstraintGroupMem_tp_isNull,METH_VARARGS,oaDataAppDef_oaConstraintGroupMem_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaConstraintGroupMem_tp_assign,METH_VARARGS,oaDataAppDef_oaConstraintGroupMem_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintGroupMem_doc[] = 
"Class: oaDataAppDef_oaConstraintGroupMem\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaConstraintGroupMem)\n"
"    Calls: (const oaDataAppDef_oaConstraintGroupMem&)\n"
"    Signature: oaDataAppDef_oaConstraintGroupMem||cref-oaDataAppDef_oaConstraintGroupMem,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaConstraintGroupMem_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaConstraintGroupMem",
    sizeof(PyoaDataAppDef_oaConstraintGroupMemObject),
    0,
    (destructor)oaDataAppDef_oaConstraintGroupMem_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaConstraintGroupMem_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaConstraintGroupMem_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaConstraintGroupMem_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaConstraintGroupMem_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaConstraintGroupMem_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintGroupMem_static_find_doc[] = 
"Class: oaDataAppDef_oaConstraintGroupMem, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaConstraintGroupMem* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaConstraintGroupMem|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaConstraintGroupMem* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaConstraintGroupMem|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaConstraintGroupMem_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaConstraintGroupMemp result= (oaDataAppDef_oaConstraintGroupMem::find(p1.Data()));
            return PyoaDataAppDef_oaConstraintGroupMem_FromoaDataAppDef_oaConstraintGroupMem(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaConstraintGroupMemp result= (oaDataAppDef_oaConstraintGroupMem::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaConstraintGroupMem_FromoaDataAppDef_oaConstraintGroupMem(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaConstraintGroupMem, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintGroupMem_static_get_doc[] = 
"Class: oaDataAppDef_oaConstraintGroupMem, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaConstraintGroupMem* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaConstraintGroupMem|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaConstraintGroupMem* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaConstraintGroupMem|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaConstraintGroupMem_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaConstraintGroupMemp result= (oaDataAppDef_oaConstraintGroupMem::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaConstraintGroupMem_FromoaDataAppDef_oaConstraintGroupMem(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaConstraintGroupMemp result= (oaDataAppDef_oaConstraintGroupMem::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaConstraintGroupMem_FromoaDataAppDef_oaConstraintGroupMem(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaConstraintGroupMem, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaConstraintGroupMem_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaConstraintGroupMem_static_find,METH_VARARGS,oaDataAppDef_oaConstraintGroupMem_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaConstraintGroupMem_static_get,METH_VARARGS,oaDataAppDef_oaConstraintGroupMem_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaConstraintGroupMem_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaConstraintGroupMem_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaConstraintGroupMem\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaConstraintGroupMem",
           (PyObject*)(&PyoaDataAppDef_oaConstraintGroupMem_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaConstraintGroupMem\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaConstraintGroupMem_Type.tp_dict;
    for(method=oaDataAppDef_oaConstraintGroupMem_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaConstraintParam
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaConstraintParam_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaConstraintParam_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaConstraintParamObject* self = (PyoaDataAppDef_oaConstraintParamObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaConstraintParam)
    {
        PyParamoaDataAppDef_oaConstraintParam p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaConstraintParam_Convert,&p1)) {
            PyoaDataAppDef_oaConstraintParamObject* cself=((PyoaDataAppDef_oaConstraintParamObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaConstraintParam, Choices are:\n"
        "    (oaDataAppDef_oaConstraintParam)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaConstraintParam_tp_dealloc(PyoaDataAppDef_oaConstraintParamObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaConstraintParam_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaConstraintParam value;
    int convert_status=PyoaDataAppDef_oaConstraintParam_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[52];
    sprintf(buffer,"<oaDataAppDef_oaConstraintParam::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaConstraintParam_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaConstraintParam v1;
    PyParamoaDataAppDef_oaConstraintParam v2;
    int convert_status1=PyoaDataAppDef_oaConstraintParam_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaConstraintParam_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaConstraintParam_Convert(PyObject* ob,PyParamoaDataAppDef_oaConstraintParam* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaConstraintParam_Check(ob)) {
        result->SetData( (oaDataAppDef_oaConstraintParam**) ((PyoaDataAppDef_oaConstraintParamObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaConstraintParam Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaConstraintParam_FromoaDataAppDef_oaConstraintParam(oaDataAppDef_oaConstraintParam** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaConstraintParam* data=*value;
        PyObject* bself = PyoaDataAppDef_oaConstraintParam_Type.tp_alloc(&PyoaDataAppDef_oaConstraintParam_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaConstraintParamObject* self = (PyoaDataAppDef_oaConstraintParamObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaConstraintParam_FromoaDataAppDef_oaConstraintParam(oaDataAppDef_oaConstraintParam* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaConstraintParam_Type.tp_alloc(&PyoaDataAppDef_oaConstraintParam_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaConstraintParamObject* self = (PyoaDataAppDef_oaConstraintParamObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintParam_get_doc[] = 
"Class: oaDataAppDef_oaConstraintParam, Function: get\n"
"  Paramegers: (oaConstraintParam,[oaByte])\n"
"    Calls: void get(const oaConstraintParam* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaConstraintParam,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaConstraintParam_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraintParam data;
    int convert_status=PyoaDataAppDef_oaConstraintParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintParamObject* self=(PyoaDataAppDef_oaConstraintParamObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaConstraintParam p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaConstraintParam_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintParam_getDefault_doc[] = 
"Class: oaDataAppDef_oaConstraintParam, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaConstraintParam_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraintParam data;
    int convert_status=PyoaDataAppDef_oaConstraintParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintParamObject* self=(PyoaDataAppDef_oaConstraintParamObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintParam_getSize_doc[] = 
"Class: oaDataAppDef_oaConstraintParam, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaConstraintParam_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraintParam data;
    int convert_status=PyoaDataAppDef_oaConstraintParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintParamObject* self=(PyoaDataAppDef_oaConstraintParamObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintParam_set_doc[] = 
"Class: oaDataAppDef_oaConstraintParam, Function: set\n"
"  Paramegers: (oaConstraintParam,[oaByte])\n"
"    Calls: void set(oaConstraintParam* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaConstraintParam,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaConstraintParam_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraintParam data;
    int convert_status=PyoaDataAppDef_oaConstraintParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintParamObject* self=(PyoaDataAppDef_oaConstraintParamObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaConstraintParam p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaConstraintParam_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintParam_isNull_doc[] =
"Class: oaDataAppDef_oaConstraintParam, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaConstraintParam_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaConstraintParam data;
    int convert_status=PyoaDataAppDef_oaConstraintParam_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaConstraintParam_assign_doc[] = 
"Class: oaDataAppDef_oaConstraintParam, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaConstraintParam_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaConstraintParam data;
  int convert_status=PyoaDataAppDef_oaConstraintParam_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaConstraintParam p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaConstraintParam_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaConstraintParam_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaConstraintParam_get,METH_VARARGS,oaDataAppDef_oaConstraintParam_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaConstraintParam_getDefault,METH_VARARGS,oaDataAppDef_oaConstraintParam_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaConstraintParam_getSize,METH_VARARGS,oaDataAppDef_oaConstraintParam_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaConstraintParam_set,METH_VARARGS,oaDataAppDef_oaConstraintParam_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaConstraintParam_tp_isNull,METH_VARARGS,oaDataAppDef_oaConstraintParam_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaConstraintParam_tp_assign,METH_VARARGS,oaDataAppDef_oaConstraintParam_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintParam_doc[] = 
"Class: oaDataAppDef_oaConstraintParam\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaConstraintParam)\n"
"    Calls: (const oaDataAppDef_oaConstraintParam&)\n"
"    Signature: oaDataAppDef_oaConstraintParam||cref-oaDataAppDef_oaConstraintParam,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaConstraintParam_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaConstraintParam",
    sizeof(PyoaDataAppDef_oaConstraintParamObject),
    0,
    (destructor)oaDataAppDef_oaConstraintParam_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaConstraintParam_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaConstraintParam_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaConstraintParam_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaConstraintParam_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaConstraintParam_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintParam_static_find_doc[] = 
"Class: oaDataAppDef_oaConstraintParam, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaConstraintParam* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaConstraintParam|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaConstraintParam* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaConstraintParam|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaConstraintParam_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaConstraintParamp result= (oaDataAppDef_oaConstraintParam::find(p1.Data()));
            return PyoaDataAppDef_oaConstraintParam_FromoaDataAppDef_oaConstraintParam(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaConstraintParamp result= (oaDataAppDef_oaConstraintParam::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaConstraintParam_FromoaDataAppDef_oaConstraintParam(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaConstraintParam, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintParam_static_get_doc[] = 
"Class: oaDataAppDef_oaConstraintParam, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaConstraintParam* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaConstraintParam|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaConstraintParam* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaConstraintParam|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaConstraintParam_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaConstraintParamp result= (oaDataAppDef_oaConstraintParam::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaConstraintParam_FromoaDataAppDef_oaConstraintParam(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaConstraintParamp result= (oaDataAppDef_oaConstraintParam::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaConstraintParam_FromoaDataAppDef_oaConstraintParam(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaConstraintParam, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaConstraintParam_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaConstraintParam_static_find,METH_VARARGS,oaDataAppDef_oaConstraintParam_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaConstraintParam_static_get,METH_VARARGS,oaDataAppDef_oaConstraintParam_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaConstraintParam_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaConstraintParam_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaConstraintParam\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaConstraintParam",
           (PyObject*)(&PyoaDataAppDef_oaConstraintParam_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaConstraintParam\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaConstraintParam_Type.tp_dict;
    for(method=oaDataAppDef_oaConstraintParam_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaConstraintParamDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaConstraintParamDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaConstraintParamDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaConstraintParamDefObject* self = (PyoaDataAppDef_oaConstraintParamDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaConstraintParamDef)
    {
        PyParamoaDataAppDef_oaConstraintParamDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaConstraintParamDef_Convert,&p1)) {
            PyoaDataAppDef_oaConstraintParamDefObject* cself=((PyoaDataAppDef_oaConstraintParamDefObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaConstraintParamDef, Choices are:\n"
        "    (oaDataAppDef_oaConstraintParamDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaConstraintParamDef_tp_dealloc(PyoaDataAppDef_oaConstraintParamDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaConstraintParamDef_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaConstraintParamDef value;
    int convert_status=PyoaDataAppDef_oaConstraintParamDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[55];
    sprintf(buffer,"<oaDataAppDef_oaConstraintParamDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaConstraintParamDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaConstraintParamDef v1;
    PyParamoaDataAppDef_oaConstraintParamDef v2;
    int convert_status1=PyoaDataAppDef_oaConstraintParamDef_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaConstraintParamDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaConstraintParamDef_Convert(PyObject* ob,PyParamoaDataAppDef_oaConstraintParamDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaConstraintParamDef_Check(ob)) {
        result->SetData( (oaDataAppDef_oaConstraintParamDef**) ((PyoaDataAppDef_oaConstraintParamDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaConstraintParamDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaConstraintParamDef_FromoaDataAppDef_oaConstraintParamDef(oaDataAppDef_oaConstraintParamDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaConstraintParamDef* data=*value;
        PyObject* bself = PyoaDataAppDef_oaConstraintParamDef_Type.tp_alloc(&PyoaDataAppDef_oaConstraintParamDef_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaConstraintParamDefObject* self = (PyoaDataAppDef_oaConstraintParamDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaConstraintParamDef_FromoaDataAppDef_oaConstraintParamDef(oaDataAppDef_oaConstraintParamDef* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaConstraintParamDef_Type.tp_alloc(&PyoaDataAppDef_oaConstraintParamDef_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaConstraintParamDefObject* self = (PyoaDataAppDef_oaConstraintParamDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintParamDef_get_doc[] = 
"Class: oaDataAppDef_oaConstraintParamDef, Function: get\n"
"  Paramegers: (oaConstraintParamDef,[oaByte])\n"
"    Calls: void get(const oaConstraintParamDef* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaConstraintParamDef,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaConstraintParamDef_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraintParamDef data;
    int convert_status=PyoaDataAppDef_oaConstraintParamDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintParamDefObject* self=(PyoaDataAppDef_oaConstraintParamDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaConstraintParamDef p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaConstraintParamDef_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintParamDef_getDefault_doc[] = 
"Class: oaDataAppDef_oaConstraintParamDef, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaConstraintParamDef_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraintParamDef data;
    int convert_status=PyoaDataAppDef_oaConstraintParamDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintParamDefObject* self=(PyoaDataAppDef_oaConstraintParamDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintParamDef_getSize_doc[] = 
"Class: oaDataAppDef_oaConstraintParamDef, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaConstraintParamDef_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraintParamDef data;
    int convert_status=PyoaDataAppDef_oaConstraintParamDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintParamDefObject* self=(PyoaDataAppDef_oaConstraintParamDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintParamDef_set_doc[] = 
"Class: oaDataAppDef_oaConstraintParamDef, Function: set\n"
"  Paramegers: (oaConstraintParamDef,[oaByte])\n"
"    Calls: void set(oaConstraintParamDef* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaConstraintParamDef,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaConstraintParamDef_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaConstraintParamDef data;
    int convert_status=PyoaDataAppDef_oaConstraintParamDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaConstraintParamDefObject* self=(PyoaDataAppDef_oaConstraintParamDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaConstraintParamDef p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaConstraintParamDef_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintParamDef_isNull_doc[] =
"Class: oaDataAppDef_oaConstraintParamDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaConstraintParamDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaConstraintParamDef data;
    int convert_status=PyoaDataAppDef_oaConstraintParamDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaConstraintParamDef_assign_doc[] = 
"Class: oaDataAppDef_oaConstraintParamDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaConstraintParamDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaConstraintParamDef data;
  int convert_status=PyoaDataAppDef_oaConstraintParamDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaConstraintParamDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaConstraintParamDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaConstraintParamDef_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaConstraintParamDef_get,METH_VARARGS,oaDataAppDef_oaConstraintParamDef_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaConstraintParamDef_getDefault,METH_VARARGS,oaDataAppDef_oaConstraintParamDef_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaConstraintParamDef_getSize,METH_VARARGS,oaDataAppDef_oaConstraintParamDef_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaConstraintParamDef_set,METH_VARARGS,oaDataAppDef_oaConstraintParamDef_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaConstraintParamDef_tp_isNull,METH_VARARGS,oaDataAppDef_oaConstraintParamDef_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaConstraintParamDef_tp_assign,METH_VARARGS,oaDataAppDef_oaConstraintParamDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintParamDef_doc[] = 
"Class: oaDataAppDef_oaConstraintParamDef\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaConstraintParamDef)\n"
"    Calls: (const oaDataAppDef_oaConstraintParamDef&)\n"
"    Signature: oaDataAppDef_oaConstraintParamDef||cref-oaDataAppDef_oaConstraintParamDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaConstraintParamDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaConstraintParamDef",
    sizeof(PyoaDataAppDef_oaConstraintParamDefObject),
    0,
    (destructor)oaDataAppDef_oaConstraintParamDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaConstraintParamDef_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaConstraintParamDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaConstraintParamDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaConstraintParamDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaConstraintParamDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintParamDef_static_find_doc[] = 
"Class: oaDataAppDef_oaConstraintParamDef, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaConstraintParamDef* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaConstraintParamDef|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaConstraintParamDef* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaConstraintParamDef|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaConstraintParamDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaConstraintParamDefp result= (oaDataAppDef_oaConstraintParamDef::find(p1.Data()));
            return PyoaDataAppDef_oaConstraintParamDef_FromoaDataAppDef_oaConstraintParamDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaConstraintParamDefp result= (oaDataAppDef_oaConstraintParamDef::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaConstraintParamDef_FromoaDataAppDef_oaConstraintParamDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaConstraintParamDef, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaConstraintParamDef_static_get_doc[] = 
"Class: oaDataAppDef_oaConstraintParamDef, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaConstraintParamDef* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaConstraintParamDef|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaConstraintParamDef* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaConstraintParamDef|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaConstraintParamDef_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaConstraintParamDefp result= (oaDataAppDef_oaConstraintParamDef::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaConstraintParamDef_FromoaDataAppDef_oaConstraintParamDef(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaConstraintParamDefp result= (oaDataAppDef_oaConstraintParamDef::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaConstraintParamDef_FromoaDataAppDef_oaConstraintParamDef(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaConstraintParamDef, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaConstraintParamDef_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaConstraintParamDef_static_find,METH_VARARGS,oaDataAppDef_oaConstraintParamDef_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaConstraintParamDef_static_get,METH_VARARGS,oaDataAppDef_oaConstraintParamDef_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaConstraintParamDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaConstraintParamDef_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaConstraintParamDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaConstraintParamDef",
           (PyObject*)(&PyoaDataAppDef_oaConstraintParamDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaConstraintParamDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaConstraintParamDef_Type.tp_dict;
    for(method=oaDataAppDef_oaConstraintParamDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaDMData
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaDMData_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaDMData_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaDMDataObject* self = (PyoaDataAppDef_oaDMDataObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaDMData)
    {
        PyParamoaDataAppDef_oaDMData p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaDMData_Convert,&p1)) {
            PyoaDataAppDef_oaDMDataObject* cself=((PyoaDataAppDef_oaDMDataObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaDMData, Choices are:\n"
        "    (oaDataAppDef_oaDMData)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaDMData_tp_dealloc(PyoaDataAppDef_oaDMDataObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaDMData_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaDMData value;
    int convert_status=PyoaDataAppDef_oaDMData_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaDataAppDef_oaDMData::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaDMData_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaDMData v1;
    PyParamoaDataAppDef_oaDMData v2;
    int convert_status1=PyoaDataAppDef_oaDMData_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaDMData_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaDMData_Convert(PyObject* ob,PyParamoaDataAppDef_oaDMData* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaDMData_Check(ob)) {
        result->SetData( (oaDataAppDef_oaDMData**) ((PyoaDataAppDef_oaDMDataObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaDMData Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaDMData_FromoaDataAppDef_oaDMData(oaDataAppDef_oaDMData** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaDMData* data=*value;
        PyObject* bself = PyoaDataAppDef_oaDMData_Type.tp_alloc(&PyoaDataAppDef_oaDMData_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaDMDataObject* self = (PyoaDataAppDef_oaDMDataObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaDMData_FromoaDataAppDef_oaDMData(oaDataAppDef_oaDMData* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaDMData_Type.tp_alloc(&PyoaDataAppDef_oaDMData_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaDMDataObject* self = (PyoaDataAppDef_oaDMDataObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaDMData_get_doc[] = 
"Class: oaDataAppDef_oaDMData, Function: get\n"
"  Paramegers: (oaDMData,[oaByte])\n"
"    Calls: void get(const oaDMData* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaDMData,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaDMData_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaDMData data;
    int convert_status=PyoaDataAppDef_oaDMData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaDMDataObject* self=(PyoaDataAppDef_oaDMDataObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDMData p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaDMData_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDMData_getDefault_doc[] = 
"Class: oaDataAppDef_oaDMData, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaDMData_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaDMData data;
    int convert_status=PyoaDataAppDef_oaDMData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaDMDataObject* self=(PyoaDataAppDef_oaDMDataObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDMData_getSize_doc[] = 
"Class: oaDataAppDef_oaDMData, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaDMData_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaDMData data;
    int convert_status=PyoaDataAppDef_oaDMData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaDMDataObject* self=(PyoaDataAppDef_oaDMDataObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDMData_set_doc[] = 
"Class: oaDataAppDef_oaDMData, Function: set\n"
"  Paramegers: (oaDMData,[oaByte])\n"
"    Calls: void set(oaDMData* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaDMData,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaDMData_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaDMData data;
    int convert_status=PyoaDataAppDef_oaDMData_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaDMDataObject* self=(PyoaDataAppDef_oaDMDataObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDMData p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaDMData_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDMData_isNull_doc[] =
"Class: oaDataAppDef_oaDMData, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaDMData_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaDMData data;
    int convert_status=PyoaDataAppDef_oaDMData_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaDMData_assign_doc[] = 
"Class: oaDataAppDef_oaDMData, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaDMData_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaDMData data;
  int convert_status=PyoaDataAppDef_oaDMData_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaDMData p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaDMData_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaDMData_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaDMData_get,METH_VARARGS,oaDataAppDef_oaDMData_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaDMData_getDefault,METH_VARARGS,oaDataAppDef_oaDMData_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaDMData_getSize,METH_VARARGS,oaDataAppDef_oaDMData_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaDMData_set,METH_VARARGS,oaDataAppDef_oaDMData_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaDMData_tp_isNull,METH_VARARGS,oaDataAppDef_oaDMData_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaDMData_tp_assign,METH_VARARGS,oaDataAppDef_oaDMData_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaDMData_doc[] = 
"Class: oaDataAppDef_oaDMData\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaDMData)\n"
"    Calls: (const oaDataAppDef_oaDMData&)\n"
"    Signature: oaDataAppDef_oaDMData||cref-oaDataAppDef_oaDMData,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaDMData_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaDMData",
    sizeof(PyoaDataAppDef_oaDMDataObject),
    0,
    (destructor)oaDataAppDef_oaDMData_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaDMData_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaDMData_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaDMData_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaDMData_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaDMData_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaDMData_static_find_doc[] = 
"Class: oaDataAppDef_oaDMData, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaDMData* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaDMData|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaDMData* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaDMData|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaDMData_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaDMDatap result= (oaDataAppDef_oaDMData::find(p1.Data()));
            return PyoaDataAppDef_oaDMData_FromoaDataAppDef_oaDMData(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaDMDatap result= (oaDataAppDef_oaDMData::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaDMData_FromoaDataAppDef_oaDMData(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaDMData, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDMData_static_get_doc[] = 
"Class: oaDataAppDef_oaDMData, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaDMData* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaDMData|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaDMData* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaDMData|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaDMData_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaDMDatap result= (oaDataAppDef_oaDMData::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaDMData_FromoaDataAppDef_oaDMData(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaDMDatap result= (oaDataAppDef_oaDMData::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaDMData_FromoaDataAppDef_oaDMData(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaDMData, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaDMData_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaDMData_static_find,METH_VARARGS,oaDataAppDef_oaDMData_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaDMData_static_get,METH_VARARGS,oaDataAppDef_oaDMData_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaDMData_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaDMData_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaDMData\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaDMData",
           (PyObject*)(&PyoaDataAppDef_oaDMData_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaDMData\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaDMData_Type.tp_dict;
    for(method=oaDataAppDef_oaDMData_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaDMFile
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaDMFile_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaDMFile_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaDMFileObject* self = (PyoaDataAppDef_oaDMFileObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaDMFile)
    {
        PyParamoaDataAppDef_oaDMFile p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaDMFile_Convert,&p1)) {
            PyoaDataAppDef_oaDMFileObject* cself=((PyoaDataAppDef_oaDMFileObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaDMFile, Choices are:\n"
        "    (oaDataAppDef_oaDMFile)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaDMFile_tp_dealloc(PyoaDataAppDef_oaDMFileObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaDMFile_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaDMFile value;
    int convert_status=PyoaDataAppDef_oaDMFile_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaDataAppDef_oaDMFile::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaDMFile_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaDMFile v1;
    PyParamoaDataAppDef_oaDMFile v2;
    int convert_status1=PyoaDataAppDef_oaDMFile_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaDMFile_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaDMFile_Convert(PyObject* ob,PyParamoaDataAppDef_oaDMFile* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaDMFile_Check(ob)) {
        result->SetData( (oaDataAppDef_oaDMFile**) ((PyoaDataAppDef_oaDMFileObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaDMFile Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaDMFile_FromoaDataAppDef_oaDMFile(oaDataAppDef_oaDMFile** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaDMFile* data=*value;
        PyObject* bself = PyoaDataAppDef_oaDMFile_Type.tp_alloc(&PyoaDataAppDef_oaDMFile_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaDMFileObject* self = (PyoaDataAppDef_oaDMFileObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaDMFile_FromoaDataAppDef_oaDMFile(oaDataAppDef_oaDMFile* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaDMFile_Type.tp_alloc(&PyoaDataAppDef_oaDMFile_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaDMFileObject* self = (PyoaDataAppDef_oaDMFileObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaDMFile_get_doc[] = 
"Class: oaDataAppDef_oaDMFile, Function: get\n"
"  Paramegers: (oaDMFile,[oaByte])\n"
"    Calls: void get(const oaDMFile* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaDMFile,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaDMFile_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaDMFile data;
    int convert_status=PyoaDataAppDef_oaDMFile_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaDMFileObject* self=(PyoaDataAppDef_oaDMFileObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDMFile p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaDMFile_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDMFile_getDefault_doc[] = 
"Class: oaDataAppDef_oaDMFile, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaDMFile_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaDMFile data;
    int convert_status=PyoaDataAppDef_oaDMFile_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaDMFileObject* self=(PyoaDataAppDef_oaDMFileObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDMFile_getSize_doc[] = 
"Class: oaDataAppDef_oaDMFile, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaDMFile_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaDMFile data;
    int convert_status=PyoaDataAppDef_oaDMFile_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaDMFileObject* self=(PyoaDataAppDef_oaDMFileObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDMFile_set_doc[] = 
"Class: oaDataAppDef_oaDMFile, Function: set\n"
"  Paramegers: (oaDMFile,[oaByte])\n"
"    Calls: void set(oaDMFile* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaDMFile,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaDMFile_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaDMFile data;
    int convert_status=PyoaDataAppDef_oaDMFile_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaDMFileObject* self=(PyoaDataAppDef_oaDMFileObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDMFile p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaDMFile_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDMFile_isNull_doc[] =
"Class: oaDataAppDef_oaDMFile, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaDMFile_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaDMFile data;
    int convert_status=PyoaDataAppDef_oaDMFile_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaDMFile_assign_doc[] = 
"Class: oaDataAppDef_oaDMFile, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaDMFile_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaDMFile data;
  int convert_status=PyoaDataAppDef_oaDMFile_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaDMFile p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaDMFile_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaDMFile_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaDMFile_get,METH_VARARGS,oaDataAppDef_oaDMFile_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaDMFile_getDefault,METH_VARARGS,oaDataAppDef_oaDMFile_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaDMFile_getSize,METH_VARARGS,oaDataAppDef_oaDMFile_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaDMFile_set,METH_VARARGS,oaDataAppDef_oaDMFile_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaDMFile_tp_isNull,METH_VARARGS,oaDataAppDef_oaDMFile_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaDMFile_tp_assign,METH_VARARGS,oaDataAppDef_oaDMFile_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaDMFile_doc[] = 
"Class: oaDataAppDef_oaDMFile\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaDMFile)\n"
"    Calls: (const oaDataAppDef_oaDMFile&)\n"
"    Signature: oaDataAppDef_oaDMFile||cref-oaDataAppDef_oaDMFile,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaDMFile_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaDMFile",
    sizeof(PyoaDataAppDef_oaDMFileObject),
    0,
    (destructor)oaDataAppDef_oaDMFile_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaDMFile_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaDMFile_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaDMFile_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaDMFile_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaDMFile_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaDMFile_static_find_doc[] = 
"Class: oaDataAppDef_oaDMFile, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaDMFile* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaDMFile|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaDMFile* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaDMFile|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaDMFile_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaDMFilep result= (oaDataAppDef_oaDMFile::find(p1.Data()));
            return PyoaDataAppDef_oaDMFile_FromoaDataAppDef_oaDMFile(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaDMFilep result= (oaDataAppDef_oaDMFile::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaDMFile_FromoaDataAppDef_oaDMFile(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaDMFile, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDMFile_static_get_doc[] = 
"Class: oaDataAppDef_oaDMFile, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaDMFile* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaDMFile|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaDMFile* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaDMFile|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaDMFile_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaDMFilep result= (oaDataAppDef_oaDMFile::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaDMFile_FromoaDataAppDef_oaDMFile(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaDMFilep result= (oaDataAppDef_oaDMFile::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaDMFile_FromoaDataAppDef_oaDMFile(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaDMFile, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaDMFile_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaDMFile_static_find,METH_VARARGS,oaDataAppDef_oaDMFile_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaDMFile_static_get,METH_VARARGS,oaDataAppDef_oaDMFile_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaDMFile_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaDMFile_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaDMFile\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaDMFile",
           (PyObject*)(&PyoaDataAppDef_oaDMFile_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaDMFile\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaDMFile_Type.tp_dict;
    for(method=oaDataAppDef_oaDMFile_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaDerivedLayerParam
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaDerivedLayerParam_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaDerivedLayerParam_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaDerivedLayerParamObject* self = (PyoaDataAppDef_oaDerivedLayerParamObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaDerivedLayerParam)
    {
        PyParamoaDataAppDef_oaDerivedLayerParam p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaDerivedLayerParam_Convert,&p1)) {
            PyoaDataAppDef_oaDerivedLayerParamObject* cself=((PyoaDataAppDef_oaDerivedLayerParamObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaDerivedLayerParam, Choices are:\n"
        "    (oaDataAppDef_oaDerivedLayerParam)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaDerivedLayerParam_tp_dealloc(PyoaDataAppDef_oaDerivedLayerParamObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaDerivedLayerParam_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaDerivedLayerParam value;
    int convert_status=PyoaDataAppDef_oaDerivedLayerParam_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[54];
    sprintf(buffer,"<oaDataAppDef_oaDerivedLayerParam::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaDerivedLayerParam_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaDerivedLayerParam v1;
    PyParamoaDataAppDef_oaDerivedLayerParam v2;
    int convert_status1=PyoaDataAppDef_oaDerivedLayerParam_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaDerivedLayerParam_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaDerivedLayerParam_Convert(PyObject* ob,PyParamoaDataAppDef_oaDerivedLayerParam* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaDerivedLayerParam_Check(ob)) {
        result->SetData( (oaDataAppDef_oaDerivedLayerParam**) ((PyoaDataAppDef_oaDerivedLayerParamObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaDerivedLayerParam Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaDerivedLayerParam_FromoaDataAppDef_oaDerivedLayerParam(oaDataAppDef_oaDerivedLayerParam** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaDerivedLayerParam* data=*value;
        PyObject* bself = PyoaDataAppDef_oaDerivedLayerParam_Type.tp_alloc(&PyoaDataAppDef_oaDerivedLayerParam_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaDerivedLayerParamObject* self = (PyoaDataAppDef_oaDerivedLayerParamObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaDerivedLayerParam_FromoaDataAppDef_oaDerivedLayerParam(oaDataAppDef_oaDerivedLayerParam* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaDerivedLayerParam_Type.tp_alloc(&PyoaDataAppDef_oaDerivedLayerParam_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaDerivedLayerParamObject* self = (PyoaDataAppDef_oaDerivedLayerParamObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaDerivedLayerParam_get_doc[] = 
"Class: oaDataAppDef_oaDerivedLayerParam, Function: get\n"
"  Paramegers: (oaDerivedLayerParam,[oaByte])\n"
"    Calls: void get(const oaDerivedLayerParam* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaDerivedLayerParam,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaDerivedLayerParam_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaDerivedLayerParam data;
    int convert_status=PyoaDataAppDef_oaDerivedLayerParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaDerivedLayerParamObject* self=(PyoaDataAppDef_oaDerivedLayerParamObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDerivedLayerParam p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaDerivedLayerParam_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDerivedLayerParam_getDefault_doc[] = 
"Class: oaDataAppDef_oaDerivedLayerParam, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaDerivedLayerParam_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaDerivedLayerParam data;
    int convert_status=PyoaDataAppDef_oaDerivedLayerParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaDerivedLayerParamObject* self=(PyoaDataAppDef_oaDerivedLayerParamObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDerivedLayerParam_getSize_doc[] = 
"Class: oaDataAppDef_oaDerivedLayerParam, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaDerivedLayerParam_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaDerivedLayerParam data;
    int convert_status=PyoaDataAppDef_oaDerivedLayerParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaDerivedLayerParamObject* self=(PyoaDataAppDef_oaDerivedLayerParamObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDerivedLayerParam_set_doc[] = 
"Class: oaDataAppDef_oaDerivedLayerParam, Function: set\n"
"  Paramegers: (oaDerivedLayerParam,[oaByte])\n"
"    Calls: void set(oaDerivedLayerParam* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaDerivedLayerParam,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaDerivedLayerParam_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaDerivedLayerParam data;
    int convert_status=PyoaDataAppDef_oaDerivedLayerParam_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaDerivedLayerParamObject* self=(PyoaDataAppDef_oaDerivedLayerParamObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDerivedLayerParam p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaDerivedLayerParam_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDerivedLayerParam_isNull_doc[] =
"Class: oaDataAppDef_oaDerivedLayerParam, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaDerivedLayerParam_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaDerivedLayerParam data;
    int convert_status=PyoaDataAppDef_oaDerivedLayerParam_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaDerivedLayerParam_assign_doc[] = 
"Class: oaDataAppDef_oaDerivedLayerParam, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaDerivedLayerParam_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaDerivedLayerParam data;
  int convert_status=PyoaDataAppDef_oaDerivedLayerParam_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaDerivedLayerParam p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaDerivedLayerParam_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaDerivedLayerParam_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaDerivedLayerParam_get,METH_VARARGS,oaDataAppDef_oaDerivedLayerParam_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaDerivedLayerParam_getDefault,METH_VARARGS,oaDataAppDef_oaDerivedLayerParam_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaDerivedLayerParam_getSize,METH_VARARGS,oaDataAppDef_oaDerivedLayerParam_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaDerivedLayerParam_set,METH_VARARGS,oaDataAppDef_oaDerivedLayerParam_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaDerivedLayerParam_tp_isNull,METH_VARARGS,oaDataAppDef_oaDerivedLayerParam_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaDerivedLayerParam_tp_assign,METH_VARARGS,oaDataAppDef_oaDerivedLayerParam_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaDerivedLayerParam_doc[] = 
"Class: oaDataAppDef_oaDerivedLayerParam\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaDerivedLayerParam)\n"
"    Calls: (const oaDataAppDef_oaDerivedLayerParam&)\n"
"    Signature: oaDataAppDef_oaDerivedLayerParam||cref-oaDataAppDef_oaDerivedLayerParam,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaDerivedLayerParam_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaDerivedLayerParam",
    sizeof(PyoaDataAppDef_oaDerivedLayerParamObject),
    0,
    (destructor)oaDataAppDef_oaDerivedLayerParam_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaDerivedLayerParam_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaDerivedLayerParam_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaDerivedLayerParam_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaDerivedLayerParam_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaDerivedLayerParam_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaDerivedLayerParam_static_find_doc[] = 
"Class: oaDataAppDef_oaDerivedLayerParam, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaDerivedLayerParam* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaDerivedLayerParam|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaDerivedLayerParam* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaDerivedLayerParam|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaDerivedLayerParam_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaDerivedLayerParamp result= (oaDataAppDef_oaDerivedLayerParam::find(p1.Data()));
            return PyoaDataAppDef_oaDerivedLayerParam_FromoaDataAppDef_oaDerivedLayerParam(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaDerivedLayerParamp result= (oaDataAppDef_oaDerivedLayerParam::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaDerivedLayerParam_FromoaDataAppDef_oaDerivedLayerParam(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaDerivedLayerParam, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDerivedLayerParam_static_get_doc[] = 
"Class: oaDataAppDef_oaDerivedLayerParam, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaDerivedLayerParam* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaDerivedLayerParam|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaDerivedLayerParam* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaDerivedLayerParam|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaDerivedLayerParam_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaDerivedLayerParamp result= (oaDataAppDef_oaDerivedLayerParam::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaDerivedLayerParam_FromoaDataAppDef_oaDerivedLayerParam(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaDerivedLayerParamp result= (oaDataAppDef_oaDerivedLayerParam::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaDerivedLayerParam_FromoaDataAppDef_oaDerivedLayerParam(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaDerivedLayerParam, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaDerivedLayerParam_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaDerivedLayerParam_static_find,METH_VARARGS,oaDataAppDef_oaDerivedLayerParam_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaDerivedLayerParam_static_get,METH_VARARGS,oaDataAppDef_oaDerivedLayerParam_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaDerivedLayerParam_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaDerivedLayerParam_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaDerivedLayerParam\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaDerivedLayerParam",
           (PyObject*)(&PyoaDataAppDef_oaDerivedLayerParam_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaDerivedLayerParam\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaDerivedLayerParam_Type.tp_dict;
    for(method=oaDataAppDef_oaDerivedLayerParam_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaDesign
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaDesign_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaDesign_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaDesignObject* self = (PyoaDataAppDef_oaDesignObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaDesign)
    {
        PyParamoaDataAppDef_oaDesign p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaDesign_Convert,&p1)) {
            PyoaDataAppDef_oaDesignObject* cself=((PyoaDataAppDef_oaDesignObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaDesign, Choices are:\n"
        "    (oaDataAppDef_oaDesign)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaDesign_tp_dealloc(PyoaDataAppDef_oaDesignObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaDesign_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaDesign value;
    int convert_status=PyoaDataAppDef_oaDesign_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaDataAppDef_oaDesign::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaDesign_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaDesign v1;
    PyParamoaDataAppDef_oaDesign v2;
    int convert_status1=PyoaDataAppDef_oaDesign_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaDesign_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaDesign_Convert(PyObject* ob,PyParamoaDataAppDef_oaDesign* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaDesign_Check(ob)) {
        result->SetData( (oaDataAppDef_oaDesign**) ((PyoaDataAppDef_oaDesignObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaDesign Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaDesign_FromoaDataAppDef_oaDesign(oaDataAppDef_oaDesign** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaDesign* data=*value;
        PyObject* bself = PyoaDataAppDef_oaDesign_Type.tp_alloc(&PyoaDataAppDef_oaDesign_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaDesignObject* self = (PyoaDataAppDef_oaDesignObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaDesign_FromoaDataAppDef_oaDesign(oaDataAppDef_oaDesign* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaDesign_Type.tp_alloc(&PyoaDataAppDef_oaDesign_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaDesignObject* self = (PyoaDataAppDef_oaDesignObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaDesign_get_doc[] = 
"Class: oaDataAppDef_oaDesign, Function: get\n"
"  Paramegers: (oaDesign,[oaByte])\n"
"    Calls: void get(const oaDesign* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaDesign,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaDesign_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaDesign data;
    int convert_status=PyoaDataAppDef_oaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaDesignObject* self=(PyoaDataAppDef_oaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDesign p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaDesign_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDesign_getDefault_doc[] = 
"Class: oaDataAppDef_oaDesign, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaDesign_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaDesign data;
    int convert_status=PyoaDataAppDef_oaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaDesignObject* self=(PyoaDataAppDef_oaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDesign_getSize_doc[] = 
"Class: oaDataAppDef_oaDesign, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaDesign_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaDesign data;
    int convert_status=PyoaDataAppDef_oaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaDesignObject* self=(PyoaDataAppDef_oaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDesign_set_doc[] = 
"Class: oaDataAppDef_oaDesign, Function: set\n"
"  Paramegers: (oaDesign,[oaByte])\n"
"    Calls: void set(oaDesign* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaDesign,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaDesign_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaDesign data;
    int convert_status=PyoaDataAppDef_oaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaDesignObject* self=(PyoaDataAppDef_oaDesignObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDesign p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaDesign_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDesign_isNull_doc[] =
"Class: oaDataAppDef_oaDesign, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaDesign_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaDesign data;
    int convert_status=PyoaDataAppDef_oaDesign_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaDesign_assign_doc[] = 
"Class: oaDataAppDef_oaDesign, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaDesign_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaDesign data;
  int convert_status=PyoaDataAppDef_oaDesign_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaDesign p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaDesign_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaDesign_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaDesign_get,METH_VARARGS,oaDataAppDef_oaDesign_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaDesign_getDefault,METH_VARARGS,oaDataAppDef_oaDesign_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaDesign_getSize,METH_VARARGS,oaDataAppDef_oaDesign_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaDesign_set,METH_VARARGS,oaDataAppDef_oaDesign_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaDesign_tp_isNull,METH_VARARGS,oaDataAppDef_oaDesign_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaDesign_tp_assign,METH_VARARGS,oaDataAppDef_oaDesign_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaDesign_doc[] = 
"Class: oaDataAppDef_oaDesign\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaDesign)\n"
"    Calls: (const oaDataAppDef_oaDesign&)\n"
"    Signature: oaDataAppDef_oaDesign||cref-oaDataAppDef_oaDesign,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaDesign_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaDesign",
    sizeof(PyoaDataAppDef_oaDesignObject),
    0,
    (destructor)oaDataAppDef_oaDesign_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaDesign_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaDesign_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaDesign_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaDesign_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaDesign_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaDesign_static_find_doc[] = 
"Class: oaDataAppDef_oaDesign, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaDesign* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaDesign|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaDesign* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaDesign|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaDesign_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaDesignp result= (oaDataAppDef_oaDesign::find(p1.Data()));
            return PyoaDataAppDef_oaDesign_FromoaDataAppDef_oaDesign(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaDesignp result= (oaDataAppDef_oaDesign::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaDesign_FromoaDataAppDef_oaDesign(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaDesign, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDesign_static_get_doc[] = 
"Class: oaDataAppDef_oaDesign, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaDesign* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaDesign|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaDesign* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaDesign|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaDesign_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaDesignp result= (oaDataAppDef_oaDesign::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaDesign_FromoaDataAppDef_oaDesign(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaDesignp result= (oaDataAppDef_oaDesign::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaDesign_FromoaDataAppDef_oaDesign(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaDesign, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaDesign_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaDesign_static_find,METH_VARARGS,oaDataAppDef_oaDesign_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaDesign_static_get,METH_VARARGS,oaDataAppDef_oaDesign_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaDesign_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaDesign_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaDesign\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaDesign",
           (PyObject*)(&PyoaDataAppDef_oaDesign_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaDesign\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaDesign_Type.tp_dict;
    for(method=oaDataAppDef_oaDesign_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaDesignInst
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaDesignInst_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaDesignInst_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaDesignInstObject* self = (PyoaDataAppDef_oaDesignInstObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaDesignInst)
    {
        PyParamoaDataAppDef_oaDesignInst p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaDesignInst_Convert,&p1)) {
            PyoaDataAppDef_oaDesignInstObject* cself=((PyoaDataAppDef_oaDesignInstObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaDesignInst, Choices are:\n"
        "    (oaDataAppDef_oaDesignInst)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaDesignInst_tp_dealloc(PyoaDataAppDef_oaDesignInstObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaDesignInst_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaDesignInst value;
    int convert_status=PyoaDataAppDef_oaDesignInst_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[47];
    sprintf(buffer,"<oaDataAppDef_oaDesignInst::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaDesignInst_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaDesignInst v1;
    PyParamoaDataAppDef_oaDesignInst v2;
    int convert_status1=PyoaDataAppDef_oaDesignInst_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaDesignInst_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaDesignInst_Convert(PyObject* ob,PyParamoaDataAppDef_oaDesignInst* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaDesignInst_Check(ob)) {
        result->SetData( (oaDataAppDef_oaDesignInst**) ((PyoaDataAppDef_oaDesignInstObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaDesignInst Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaDesignInst_FromoaDataAppDef_oaDesignInst(oaDataAppDef_oaDesignInst** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaDesignInst* data=*value;
        PyObject* bself = PyoaDataAppDef_oaDesignInst_Type.tp_alloc(&PyoaDataAppDef_oaDesignInst_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaDesignInstObject* self = (PyoaDataAppDef_oaDesignInstObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaDesignInst_FromoaDataAppDef_oaDesignInst(oaDataAppDef_oaDesignInst* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaDesignInst_Type.tp_alloc(&PyoaDataAppDef_oaDesignInst_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaDesignInstObject* self = (PyoaDataAppDef_oaDesignInstObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaDesignInst_get_doc[] = 
"Class: oaDataAppDef_oaDesignInst, Function: get\n"
"  Paramegers: (oaDesignInst,[oaByte])\n"
"    Calls: void get(const oaDesignInst* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaDesignInst,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaDesignInst_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaDesignInst data;
    int convert_status=PyoaDataAppDef_oaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaDesignInstObject* self=(PyoaDataAppDef_oaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDesignInst p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaDesignInst_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDesignInst_getDefault_doc[] = 
"Class: oaDataAppDef_oaDesignInst, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaDesignInst_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaDesignInst data;
    int convert_status=PyoaDataAppDef_oaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaDesignInstObject* self=(PyoaDataAppDef_oaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDesignInst_getSize_doc[] = 
"Class: oaDataAppDef_oaDesignInst, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaDesignInst_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaDesignInst data;
    int convert_status=PyoaDataAppDef_oaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaDesignInstObject* self=(PyoaDataAppDef_oaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDesignInst_set_doc[] = 
"Class: oaDataAppDef_oaDesignInst, Function: set\n"
"  Paramegers: (oaDesignInst,[oaByte])\n"
"    Calls: void set(oaDesignInst* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaDesignInst,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaDesignInst_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaDesignInst data;
    int convert_status=PyoaDataAppDef_oaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaDesignInstObject* self=(PyoaDataAppDef_oaDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDesignInst p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaDesignInst_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDesignInst_isNull_doc[] =
"Class: oaDataAppDef_oaDesignInst, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaDesignInst_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaDesignInst data;
    int convert_status=PyoaDataAppDef_oaDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaDesignInst_assign_doc[] = 
"Class: oaDataAppDef_oaDesignInst, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaDesignInst_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaDesignInst data;
  int convert_status=PyoaDataAppDef_oaDesignInst_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaDesignInst p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaDesignInst_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaDesignInst_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaDesignInst_get,METH_VARARGS,oaDataAppDef_oaDesignInst_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaDesignInst_getDefault,METH_VARARGS,oaDataAppDef_oaDesignInst_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaDesignInst_getSize,METH_VARARGS,oaDataAppDef_oaDesignInst_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaDesignInst_set,METH_VARARGS,oaDataAppDef_oaDesignInst_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaDesignInst_tp_isNull,METH_VARARGS,oaDataAppDef_oaDesignInst_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaDesignInst_tp_assign,METH_VARARGS,oaDataAppDef_oaDesignInst_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaDesignInst_doc[] = 
"Class: oaDataAppDef_oaDesignInst\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaDesignInst)\n"
"    Calls: (const oaDataAppDef_oaDesignInst&)\n"
"    Signature: oaDataAppDef_oaDesignInst||cref-oaDataAppDef_oaDesignInst,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaDesignInst_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaDesignInst",
    sizeof(PyoaDataAppDef_oaDesignInstObject),
    0,
    (destructor)oaDataAppDef_oaDesignInst_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaDesignInst_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaDesignInst_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaDesignInst_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaDesignInst_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaDesignInst_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaDesignInst_static_find_doc[] = 
"Class: oaDataAppDef_oaDesignInst, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaDesignInst* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaDesignInst|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaDesignInst* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaDesignInst|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaDesignInst_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaDesignInstp result= (oaDataAppDef_oaDesignInst::find(p1.Data()));
            return PyoaDataAppDef_oaDesignInst_FromoaDataAppDef_oaDesignInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaDesignInstp result= (oaDataAppDef_oaDesignInst::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaDesignInst_FromoaDataAppDef_oaDesignInst(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaDesignInst, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDesignInst_static_get_doc[] = 
"Class: oaDataAppDef_oaDesignInst, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaDesignInst* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaDesignInst|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaDesignInst* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaDesignInst|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaDesignInst_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaDesignInstp result= (oaDataAppDef_oaDesignInst::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaDesignInst_FromoaDataAppDef_oaDesignInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaDesignInstp result= (oaDataAppDef_oaDesignInst::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaDesignInst_FromoaDataAppDef_oaDesignInst(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaDesignInst, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaDesignInst_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaDesignInst_static_find,METH_VARARGS,oaDataAppDef_oaDesignInst_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaDesignInst_static_get,METH_VARARGS,oaDataAppDef_oaDesignInst_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaDesignInst_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaDesignInst_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaDesignInst\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaDesignInst",
           (PyObject*)(&PyoaDataAppDef_oaDesignInst_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaDesignInst\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaDesignInst_Type.tp_dict;
    for(method=oaDataAppDef_oaDesignInst_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaDevice
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaDevice_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaDevice_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaDeviceObject* self = (PyoaDataAppDef_oaDeviceObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaDevice)
    {
        PyParamoaDataAppDef_oaDevice p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaDevice_Convert,&p1)) {
            PyoaDataAppDef_oaDeviceObject* cself=((PyoaDataAppDef_oaDeviceObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaDevice, Choices are:\n"
        "    (oaDataAppDef_oaDevice)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaDevice_tp_dealloc(PyoaDataAppDef_oaDeviceObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaDevice_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaDevice value;
    int convert_status=PyoaDataAppDef_oaDevice_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaDataAppDef_oaDevice::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaDevice_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaDevice v1;
    PyParamoaDataAppDef_oaDevice v2;
    int convert_status1=PyoaDataAppDef_oaDevice_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaDevice_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaDevice_Convert(PyObject* ob,PyParamoaDataAppDef_oaDevice* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaDevice_Check(ob)) {
        result->SetData( (oaDataAppDef_oaDevice**) ((PyoaDataAppDef_oaDeviceObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaDevice Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaDevice_FromoaDataAppDef_oaDevice(oaDataAppDef_oaDevice** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaDevice* data=*value;
        PyObject* bself = PyoaDataAppDef_oaDevice_Type.tp_alloc(&PyoaDataAppDef_oaDevice_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaDeviceObject* self = (PyoaDataAppDef_oaDeviceObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaDevice_FromoaDataAppDef_oaDevice(oaDataAppDef_oaDevice* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaDevice_Type.tp_alloc(&PyoaDataAppDef_oaDevice_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaDeviceObject* self = (PyoaDataAppDef_oaDeviceObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaDevice_get_doc[] = 
"Class: oaDataAppDef_oaDevice, Function: get\n"
"  Paramegers: (oaDevice,[oaByte])\n"
"    Calls: void get(const oaDevice* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaDevice,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaDevice_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaDevice data;
    int convert_status=PyoaDataAppDef_oaDevice_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaDeviceObject* self=(PyoaDataAppDef_oaDeviceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDevice p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaDevice_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDevice_getDefault_doc[] = 
"Class: oaDataAppDef_oaDevice, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaDevice_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaDevice data;
    int convert_status=PyoaDataAppDef_oaDevice_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaDeviceObject* self=(PyoaDataAppDef_oaDeviceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDevice_getSize_doc[] = 
"Class: oaDataAppDef_oaDevice, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaDevice_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaDevice data;
    int convert_status=PyoaDataAppDef_oaDevice_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaDeviceObject* self=(PyoaDataAppDef_oaDeviceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDevice_set_doc[] = 
"Class: oaDataAppDef_oaDevice, Function: set\n"
"  Paramegers: (oaDevice,[oaByte])\n"
"    Calls: void set(oaDevice* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaDevice,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaDevice_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaDevice data;
    int convert_status=PyoaDataAppDef_oaDevice_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaDeviceObject* self=(PyoaDataAppDef_oaDeviceObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaDevice p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaDevice_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDevice_isNull_doc[] =
"Class: oaDataAppDef_oaDevice, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaDevice_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaDevice data;
    int convert_status=PyoaDataAppDef_oaDevice_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaDevice_assign_doc[] = 
"Class: oaDataAppDef_oaDevice, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaDevice_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaDevice data;
  int convert_status=PyoaDataAppDef_oaDevice_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaDevice p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaDevice_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaDevice_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaDevice_get,METH_VARARGS,oaDataAppDef_oaDevice_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaDevice_getDefault,METH_VARARGS,oaDataAppDef_oaDevice_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaDevice_getSize,METH_VARARGS,oaDataAppDef_oaDevice_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaDevice_set,METH_VARARGS,oaDataAppDef_oaDevice_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaDevice_tp_isNull,METH_VARARGS,oaDataAppDef_oaDevice_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaDevice_tp_assign,METH_VARARGS,oaDataAppDef_oaDevice_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaDevice_doc[] = 
"Class: oaDataAppDef_oaDevice\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaDevice)\n"
"    Calls: (const oaDataAppDef_oaDevice&)\n"
"    Signature: oaDataAppDef_oaDevice||cref-oaDataAppDef_oaDevice,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaDevice_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaDevice",
    sizeof(PyoaDataAppDef_oaDeviceObject),
    0,
    (destructor)oaDataAppDef_oaDevice_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaDevice_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaDevice_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaDevice_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaDevice_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaDevice_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaDevice_static_find_doc[] = 
"Class: oaDataAppDef_oaDevice, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaDevice* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaDevice|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaDevice* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaDevice|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaDevice_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaDevicep result= (oaDataAppDef_oaDevice::find(p1.Data()));
            return PyoaDataAppDef_oaDevice_FromoaDataAppDef_oaDevice(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaDevicep result= (oaDataAppDef_oaDevice::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaDevice_FromoaDataAppDef_oaDevice(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaDevice, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaDevice_static_get_doc[] = 
"Class: oaDataAppDef_oaDevice, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaDevice* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaDevice|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaDevice* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaDevice|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaDevice_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaDevicep result= (oaDataAppDef_oaDevice::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaDevice_FromoaDataAppDef_oaDevice(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaDevicep result= (oaDataAppDef_oaDevice::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaDevice_FromoaDataAppDef_oaDevice(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaDevice, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaDevice_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaDevice_static_find,METH_VARARGS,oaDataAppDef_oaDevice_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaDevice_static_get,METH_VARARGS,oaDataAppDef_oaDevice_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaDevice_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaDevice_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaDevice\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaDevice",
           (PyObject*)(&PyoaDataAppDef_oaDevice_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaDevice\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaDevice_Type.tp_dict;
    for(method=oaDataAppDef_oaDevice_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaElmore
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaElmore_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaElmore_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaElmoreObject* self = (PyoaDataAppDef_oaElmoreObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaElmore)
    {
        PyParamoaDataAppDef_oaElmore p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaElmore_Convert,&p1)) {
            PyoaDataAppDef_oaElmoreObject* cself=((PyoaDataAppDef_oaElmoreObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaElmore, Choices are:\n"
        "    (oaDataAppDef_oaElmore)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaElmore_tp_dealloc(PyoaDataAppDef_oaElmoreObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaElmore_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaElmore value;
    int convert_status=PyoaDataAppDef_oaElmore_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaDataAppDef_oaElmore::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaElmore_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaElmore v1;
    PyParamoaDataAppDef_oaElmore v2;
    int convert_status1=PyoaDataAppDef_oaElmore_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaElmore_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaElmore_Convert(PyObject* ob,PyParamoaDataAppDef_oaElmore* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaElmore_Check(ob)) {
        result->SetData( (oaDataAppDef_oaElmore**) ((PyoaDataAppDef_oaElmoreObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaElmore Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaElmore_FromoaDataAppDef_oaElmore(oaDataAppDef_oaElmore** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaElmore* data=*value;
        PyObject* bself = PyoaDataAppDef_oaElmore_Type.tp_alloc(&PyoaDataAppDef_oaElmore_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaElmoreObject* self = (PyoaDataAppDef_oaElmoreObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaElmore_FromoaDataAppDef_oaElmore(oaDataAppDef_oaElmore* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaElmore_Type.tp_alloc(&PyoaDataAppDef_oaElmore_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaElmoreObject* self = (PyoaDataAppDef_oaElmoreObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaElmore_get_doc[] = 
"Class: oaDataAppDef_oaElmore, Function: get\n"
"  Paramegers: (oaElmore,[oaByte])\n"
"    Calls: void get(const oaElmore* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaElmore,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaElmore_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaElmore data;
    int convert_status=PyoaDataAppDef_oaElmore_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaElmoreObject* self=(PyoaDataAppDef_oaElmoreObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaElmore p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaElmore_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaElmore_getDefault_doc[] = 
"Class: oaDataAppDef_oaElmore, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaElmore_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaElmore data;
    int convert_status=PyoaDataAppDef_oaElmore_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaElmoreObject* self=(PyoaDataAppDef_oaElmoreObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaElmore_getSize_doc[] = 
"Class: oaDataAppDef_oaElmore, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaElmore_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaElmore data;
    int convert_status=PyoaDataAppDef_oaElmore_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaElmoreObject* self=(PyoaDataAppDef_oaElmoreObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaElmore_set_doc[] = 
"Class: oaDataAppDef_oaElmore, Function: set\n"
"  Paramegers: (oaElmore,[oaByte])\n"
"    Calls: void set(oaElmore* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaElmore,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaElmore_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaElmore data;
    int convert_status=PyoaDataAppDef_oaElmore_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaElmoreObject* self=(PyoaDataAppDef_oaElmoreObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaElmore p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaElmore_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaElmore_isNull_doc[] =
"Class: oaDataAppDef_oaElmore, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaElmore_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaElmore data;
    int convert_status=PyoaDataAppDef_oaElmore_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaElmore_assign_doc[] = 
"Class: oaDataAppDef_oaElmore, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaElmore_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaElmore data;
  int convert_status=PyoaDataAppDef_oaElmore_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaElmore p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaElmore_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaElmore_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaElmore_get,METH_VARARGS,oaDataAppDef_oaElmore_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaElmore_getDefault,METH_VARARGS,oaDataAppDef_oaElmore_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaElmore_getSize,METH_VARARGS,oaDataAppDef_oaElmore_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaElmore_set,METH_VARARGS,oaDataAppDef_oaElmore_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaElmore_tp_isNull,METH_VARARGS,oaDataAppDef_oaElmore_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaElmore_tp_assign,METH_VARARGS,oaDataAppDef_oaElmore_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaElmore_doc[] = 
"Class: oaDataAppDef_oaElmore\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaElmore)\n"
"    Calls: (const oaDataAppDef_oaElmore&)\n"
"    Signature: oaDataAppDef_oaElmore||cref-oaDataAppDef_oaElmore,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaElmore_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaElmore",
    sizeof(PyoaDataAppDef_oaElmoreObject),
    0,
    (destructor)oaDataAppDef_oaElmore_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaElmore_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaElmore_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaElmore_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaElmore_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaElmore_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaElmore_static_find_doc[] = 
"Class: oaDataAppDef_oaElmore, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaElmore* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaElmore|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaElmore* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaElmore|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaElmore_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaElmorep result= (oaDataAppDef_oaElmore::find(p1.Data()));
            return PyoaDataAppDef_oaElmore_FromoaDataAppDef_oaElmore(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaElmorep result= (oaDataAppDef_oaElmore::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaElmore_FromoaDataAppDef_oaElmore(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaElmore, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaElmore_static_get_doc[] = 
"Class: oaDataAppDef_oaElmore, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaElmore* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaElmore|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaElmore* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaElmore|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaElmore_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaElmorep result= (oaDataAppDef_oaElmore::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaElmore_FromoaDataAppDef_oaElmore(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaElmorep result= (oaDataAppDef_oaElmore::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaElmore_FromoaDataAppDef_oaElmore(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaElmore, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaElmore_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaElmore_static_find,METH_VARARGS,oaDataAppDef_oaElmore_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaElmore_static_get,METH_VARARGS,oaDataAppDef_oaElmore_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaElmore_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaElmore_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaElmore\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaElmore",
           (PyObject*)(&PyoaDataAppDef_oaElmore_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaElmore\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaElmore_Type.tp_dict;
    for(method=oaDataAppDef_oaElmore_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaFigGroup
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaFigGroup_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaFigGroup_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaFigGroupObject* self = (PyoaDataAppDef_oaFigGroupObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaFigGroup)
    {
        PyParamoaDataAppDef_oaFigGroup p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaFigGroup_Convert,&p1)) {
            PyoaDataAppDef_oaFigGroupObject* cself=((PyoaDataAppDef_oaFigGroupObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaFigGroup, Choices are:\n"
        "    (oaDataAppDef_oaFigGroup)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaFigGroup_tp_dealloc(PyoaDataAppDef_oaFigGroupObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaFigGroup_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaFigGroup value;
    int convert_status=PyoaDataAppDef_oaFigGroup_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[45];
    sprintf(buffer,"<oaDataAppDef_oaFigGroup::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaFigGroup_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaFigGroup v1;
    PyParamoaDataAppDef_oaFigGroup v2;
    int convert_status1=PyoaDataAppDef_oaFigGroup_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaFigGroup_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaFigGroup_Convert(PyObject* ob,PyParamoaDataAppDef_oaFigGroup* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaFigGroup_Check(ob)) {
        result->SetData( (oaDataAppDef_oaFigGroup**) ((PyoaDataAppDef_oaFigGroupObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaFigGroup Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaFigGroup_FromoaDataAppDef_oaFigGroup(oaDataAppDef_oaFigGroup** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaFigGroup* data=*value;
        PyObject* bself = PyoaDataAppDef_oaFigGroup_Type.tp_alloc(&PyoaDataAppDef_oaFigGroup_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaFigGroupObject* self = (PyoaDataAppDef_oaFigGroupObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaFigGroup_FromoaDataAppDef_oaFigGroup(oaDataAppDef_oaFigGroup* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaFigGroup_Type.tp_alloc(&PyoaDataAppDef_oaFigGroup_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaFigGroupObject* self = (PyoaDataAppDef_oaFigGroupObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaFigGroup_get_doc[] = 
"Class: oaDataAppDef_oaFigGroup, Function: get\n"
"  Paramegers: (oaFigGroup,[oaByte])\n"
"    Calls: void get(const oaFigGroup* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaFigGroup,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaFigGroup_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaFigGroup data;
    int convert_status=PyoaDataAppDef_oaFigGroup_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaFigGroupObject* self=(PyoaDataAppDef_oaFigGroupObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaFigGroup p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaFigGroup_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaFigGroup_getDefault_doc[] = 
"Class: oaDataAppDef_oaFigGroup, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaFigGroup_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaFigGroup data;
    int convert_status=PyoaDataAppDef_oaFigGroup_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaFigGroupObject* self=(PyoaDataAppDef_oaFigGroupObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaFigGroup_getSize_doc[] = 
"Class: oaDataAppDef_oaFigGroup, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaFigGroup_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaFigGroup data;
    int convert_status=PyoaDataAppDef_oaFigGroup_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaFigGroupObject* self=(PyoaDataAppDef_oaFigGroupObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaFigGroup_set_doc[] = 
"Class: oaDataAppDef_oaFigGroup, Function: set\n"
"  Paramegers: (oaFigGroup,[oaByte])\n"
"    Calls: void set(oaFigGroup* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaFigGroup,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaFigGroup_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaFigGroup data;
    int convert_status=PyoaDataAppDef_oaFigGroup_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaFigGroupObject* self=(PyoaDataAppDef_oaFigGroupObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaFigGroup p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaFigGroup_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaFigGroup_isNull_doc[] =
"Class: oaDataAppDef_oaFigGroup, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaFigGroup_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaFigGroup data;
    int convert_status=PyoaDataAppDef_oaFigGroup_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaFigGroup_assign_doc[] = 
"Class: oaDataAppDef_oaFigGroup, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaFigGroup_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaFigGroup data;
  int convert_status=PyoaDataAppDef_oaFigGroup_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaFigGroup p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaFigGroup_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaFigGroup_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaFigGroup_get,METH_VARARGS,oaDataAppDef_oaFigGroup_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaFigGroup_getDefault,METH_VARARGS,oaDataAppDef_oaFigGroup_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaFigGroup_getSize,METH_VARARGS,oaDataAppDef_oaFigGroup_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaFigGroup_set,METH_VARARGS,oaDataAppDef_oaFigGroup_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaFigGroup_tp_isNull,METH_VARARGS,oaDataAppDef_oaFigGroup_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaFigGroup_tp_assign,METH_VARARGS,oaDataAppDef_oaFigGroup_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaFigGroup_doc[] = 
"Class: oaDataAppDef_oaFigGroup\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaFigGroup)\n"
"    Calls: (const oaDataAppDef_oaFigGroup&)\n"
"    Signature: oaDataAppDef_oaFigGroup||cref-oaDataAppDef_oaFigGroup,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaFigGroup_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaFigGroup",
    sizeof(PyoaDataAppDef_oaFigGroupObject),
    0,
    (destructor)oaDataAppDef_oaFigGroup_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaFigGroup_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaFigGroup_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaFigGroup_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaFigGroup_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaFigGroup_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaFigGroup_static_find_doc[] = 
"Class: oaDataAppDef_oaFigGroup, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaFigGroup* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaFigGroup|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaFigGroup* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaFigGroup|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaFigGroup_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaFigGroupp result= (oaDataAppDef_oaFigGroup::find(p1.Data()));
            return PyoaDataAppDef_oaFigGroup_FromoaDataAppDef_oaFigGroup(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaFigGroupp result= (oaDataAppDef_oaFigGroup::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaFigGroup_FromoaDataAppDef_oaFigGroup(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaFigGroup, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaFigGroup_static_get_doc[] = 
"Class: oaDataAppDef_oaFigGroup, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaFigGroup* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaFigGroup|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaFigGroup* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaFigGroup|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaFigGroup_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaFigGroupp result= (oaDataAppDef_oaFigGroup::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaFigGroup_FromoaDataAppDef_oaFigGroup(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaFigGroupp result= (oaDataAppDef_oaFigGroup::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaFigGroup_FromoaDataAppDef_oaFigGroup(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaFigGroup, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaFigGroup_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaFigGroup_static_find,METH_VARARGS,oaDataAppDef_oaFigGroup_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaFigGroup_static_get,METH_VARARGS,oaDataAppDef_oaFigGroup_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaFigGroup_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaFigGroup_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaFigGroup\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaFigGroup",
           (PyObject*)(&PyoaDataAppDef_oaFigGroup_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaFigGroup\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaFigGroup_Type.tp_dict;
    for(method=oaDataAppDef_oaFigGroup_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaFigGroupMem
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaFigGroupMem_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaFigGroupMem_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaFigGroupMemObject* self = (PyoaDataAppDef_oaFigGroupMemObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaFigGroupMem)
    {
        PyParamoaDataAppDef_oaFigGroupMem p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaFigGroupMem_Convert,&p1)) {
            PyoaDataAppDef_oaFigGroupMemObject* cself=((PyoaDataAppDef_oaFigGroupMemObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaFigGroupMem, Choices are:\n"
        "    (oaDataAppDef_oaFigGroupMem)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaFigGroupMem_tp_dealloc(PyoaDataAppDef_oaFigGroupMemObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaFigGroupMem_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaFigGroupMem value;
    int convert_status=PyoaDataAppDef_oaFigGroupMem_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[48];
    sprintf(buffer,"<oaDataAppDef_oaFigGroupMem::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaFigGroupMem_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaFigGroupMem v1;
    PyParamoaDataAppDef_oaFigGroupMem v2;
    int convert_status1=PyoaDataAppDef_oaFigGroupMem_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaFigGroupMem_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaFigGroupMem_Convert(PyObject* ob,PyParamoaDataAppDef_oaFigGroupMem* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaFigGroupMem_Check(ob)) {
        result->SetData( (oaDataAppDef_oaFigGroupMem**) ((PyoaDataAppDef_oaFigGroupMemObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaFigGroupMem Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaFigGroupMem_FromoaDataAppDef_oaFigGroupMem(oaDataAppDef_oaFigGroupMem** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaFigGroupMem* data=*value;
        PyObject* bself = PyoaDataAppDef_oaFigGroupMem_Type.tp_alloc(&PyoaDataAppDef_oaFigGroupMem_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaFigGroupMemObject* self = (PyoaDataAppDef_oaFigGroupMemObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaFigGroupMem_FromoaDataAppDef_oaFigGroupMem(oaDataAppDef_oaFigGroupMem* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaFigGroupMem_Type.tp_alloc(&PyoaDataAppDef_oaFigGroupMem_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaFigGroupMemObject* self = (PyoaDataAppDef_oaFigGroupMemObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaFigGroupMem_get_doc[] = 
"Class: oaDataAppDef_oaFigGroupMem, Function: get\n"
"  Paramegers: (oaFigGroupMem,[oaByte])\n"
"    Calls: void get(const oaFigGroupMem* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaFigGroupMem,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaFigGroupMem_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaFigGroupMem data;
    int convert_status=PyoaDataAppDef_oaFigGroupMem_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaFigGroupMemObject* self=(PyoaDataAppDef_oaFigGroupMemObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaFigGroupMem p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaFigGroupMem_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaFigGroupMem_getDefault_doc[] = 
"Class: oaDataAppDef_oaFigGroupMem, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaFigGroupMem_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaFigGroupMem data;
    int convert_status=PyoaDataAppDef_oaFigGroupMem_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaFigGroupMemObject* self=(PyoaDataAppDef_oaFigGroupMemObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaFigGroupMem_getSize_doc[] = 
"Class: oaDataAppDef_oaFigGroupMem, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaFigGroupMem_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaFigGroupMem data;
    int convert_status=PyoaDataAppDef_oaFigGroupMem_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaFigGroupMemObject* self=(PyoaDataAppDef_oaFigGroupMemObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaFigGroupMem_set_doc[] = 
"Class: oaDataAppDef_oaFigGroupMem, Function: set\n"
"  Paramegers: (oaFigGroupMem,[oaByte])\n"
"    Calls: void set(oaFigGroupMem* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaFigGroupMem,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaFigGroupMem_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaFigGroupMem data;
    int convert_status=PyoaDataAppDef_oaFigGroupMem_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaFigGroupMemObject* self=(PyoaDataAppDef_oaFigGroupMemObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaFigGroupMem p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaFigGroupMem_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaFigGroupMem_isNull_doc[] =
"Class: oaDataAppDef_oaFigGroupMem, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaFigGroupMem_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaFigGroupMem data;
    int convert_status=PyoaDataAppDef_oaFigGroupMem_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaFigGroupMem_assign_doc[] = 
"Class: oaDataAppDef_oaFigGroupMem, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaFigGroupMem_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaFigGroupMem data;
  int convert_status=PyoaDataAppDef_oaFigGroupMem_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaFigGroupMem p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaFigGroupMem_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaFigGroupMem_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaFigGroupMem_get,METH_VARARGS,oaDataAppDef_oaFigGroupMem_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaFigGroupMem_getDefault,METH_VARARGS,oaDataAppDef_oaFigGroupMem_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaFigGroupMem_getSize,METH_VARARGS,oaDataAppDef_oaFigGroupMem_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaFigGroupMem_set,METH_VARARGS,oaDataAppDef_oaFigGroupMem_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaFigGroupMem_tp_isNull,METH_VARARGS,oaDataAppDef_oaFigGroupMem_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaFigGroupMem_tp_assign,METH_VARARGS,oaDataAppDef_oaFigGroupMem_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaFigGroupMem_doc[] = 
"Class: oaDataAppDef_oaFigGroupMem\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaFigGroupMem)\n"
"    Calls: (const oaDataAppDef_oaFigGroupMem&)\n"
"    Signature: oaDataAppDef_oaFigGroupMem||cref-oaDataAppDef_oaFigGroupMem,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaFigGroupMem_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaFigGroupMem",
    sizeof(PyoaDataAppDef_oaFigGroupMemObject),
    0,
    (destructor)oaDataAppDef_oaFigGroupMem_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaFigGroupMem_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaFigGroupMem_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaFigGroupMem_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaFigGroupMem_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaFigGroupMem_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaFigGroupMem_static_find_doc[] = 
"Class: oaDataAppDef_oaFigGroupMem, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaFigGroupMem* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaFigGroupMem|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaFigGroupMem* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaFigGroupMem|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaFigGroupMem_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaFigGroupMemp result= (oaDataAppDef_oaFigGroupMem::find(p1.Data()));
            return PyoaDataAppDef_oaFigGroupMem_FromoaDataAppDef_oaFigGroupMem(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaFigGroupMemp result= (oaDataAppDef_oaFigGroupMem::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaFigGroupMem_FromoaDataAppDef_oaFigGroupMem(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaFigGroupMem, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaFigGroupMem_static_get_doc[] = 
"Class: oaDataAppDef_oaFigGroupMem, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaFigGroupMem* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaFigGroupMem|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaFigGroupMem* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaFigGroupMem|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaFigGroupMem_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaFigGroupMemp result= (oaDataAppDef_oaFigGroupMem::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaFigGroupMem_FromoaDataAppDef_oaFigGroupMem(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaFigGroupMemp result= (oaDataAppDef_oaFigGroupMem::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaFigGroupMem_FromoaDataAppDef_oaFigGroupMem(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaFigGroupMem, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaFigGroupMem_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaFigGroupMem_static_find,METH_VARARGS,oaDataAppDef_oaFigGroupMem_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaFigGroupMem_static_get,METH_VARARGS,oaDataAppDef_oaFigGroupMem_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaFigGroupMem_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaFigGroupMem_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaFigGroupMem\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaFigGroupMem",
           (PyObject*)(&PyoaDataAppDef_oaFigGroupMem_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaFigGroupMem\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaFigGroupMem_Type.tp_dict;
    for(method=oaDataAppDef_oaFigGroupMem_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaFrame
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaFrame_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaFrame_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaFrameObject* self = (PyoaDataAppDef_oaFrameObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaFrame)
    {
        PyParamoaDataAppDef_oaFrame p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaFrame_Convert,&p1)) {
            PyoaDataAppDef_oaFrameObject* cself=((PyoaDataAppDef_oaFrameObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaFrame, Choices are:\n"
        "    (oaDataAppDef_oaFrame)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaFrame_tp_dealloc(PyoaDataAppDef_oaFrameObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaFrame_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaFrame value;
    int convert_status=PyoaDataAppDef_oaFrame_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaDataAppDef_oaFrame::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaFrame_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaFrame v1;
    PyParamoaDataAppDef_oaFrame v2;
    int convert_status1=PyoaDataAppDef_oaFrame_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaFrame_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaFrame_Convert(PyObject* ob,PyParamoaDataAppDef_oaFrame* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaFrame_Check(ob)) {
        result->SetData( (oaDataAppDef_oaFrame**) ((PyoaDataAppDef_oaFrameObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaFrame Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaFrame_FromoaDataAppDef_oaFrame(oaDataAppDef_oaFrame** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaFrame* data=*value;
        PyObject* bself = PyoaDataAppDef_oaFrame_Type.tp_alloc(&PyoaDataAppDef_oaFrame_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaFrameObject* self = (PyoaDataAppDef_oaFrameObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaFrame_FromoaDataAppDef_oaFrame(oaDataAppDef_oaFrame* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaFrame_Type.tp_alloc(&PyoaDataAppDef_oaFrame_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaFrameObject* self = (PyoaDataAppDef_oaFrameObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaFrame_get_doc[] = 
"Class: oaDataAppDef_oaFrame, Function: get\n"
"  Paramegers: (oaFrame,[oaByte])\n"
"    Calls: void get(const oaFrame* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaFrame,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaFrame_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaFrame data;
    int convert_status=PyoaDataAppDef_oaFrame_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaFrameObject* self=(PyoaDataAppDef_oaFrameObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaFrame p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaFrame_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaFrame_getDefault_doc[] = 
"Class: oaDataAppDef_oaFrame, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaFrame_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaFrame data;
    int convert_status=PyoaDataAppDef_oaFrame_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaFrameObject* self=(PyoaDataAppDef_oaFrameObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaFrame_getSize_doc[] = 
"Class: oaDataAppDef_oaFrame, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaFrame_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaFrame data;
    int convert_status=PyoaDataAppDef_oaFrame_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaFrameObject* self=(PyoaDataAppDef_oaFrameObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaFrame_set_doc[] = 
"Class: oaDataAppDef_oaFrame, Function: set\n"
"  Paramegers: (oaFrame,[oaByte])\n"
"    Calls: void set(oaFrame* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaFrame,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaFrame_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaFrame data;
    int convert_status=PyoaDataAppDef_oaFrame_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaFrameObject* self=(PyoaDataAppDef_oaFrameObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaFrame p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaFrame_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaFrame_isNull_doc[] =
"Class: oaDataAppDef_oaFrame, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaFrame_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaFrame data;
    int convert_status=PyoaDataAppDef_oaFrame_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaFrame_assign_doc[] = 
"Class: oaDataAppDef_oaFrame, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaFrame_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaFrame data;
  int convert_status=PyoaDataAppDef_oaFrame_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaFrame p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaFrame_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaFrame_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaFrame_get,METH_VARARGS,oaDataAppDef_oaFrame_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaFrame_getDefault,METH_VARARGS,oaDataAppDef_oaFrame_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaFrame_getSize,METH_VARARGS,oaDataAppDef_oaFrame_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaFrame_set,METH_VARARGS,oaDataAppDef_oaFrame_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaFrame_tp_isNull,METH_VARARGS,oaDataAppDef_oaFrame_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaFrame_tp_assign,METH_VARARGS,oaDataAppDef_oaFrame_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaFrame_doc[] = 
"Class: oaDataAppDef_oaFrame\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaFrame)\n"
"    Calls: (const oaDataAppDef_oaFrame&)\n"
"    Signature: oaDataAppDef_oaFrame||cref-oaDataAppDef_oaFrame,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaFrame_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaFrame",
    sizeof(PyoaDataAppDef_oaFrameObject),
    0,
    (destructor)oaDataAppDef_oaFrame_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaFrame_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaFrame_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaFrame_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaFrame_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaFrame_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaFrame_static_find_doc[] = 
"Class: oaDataAppDef_oaFrame, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaFrame* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaFrame|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaFrame* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaFrame|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaFrame_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaFramep result= (oaDataAppDef_oaFrame::find(p1.Data()));
            return PyoaDataAppDef_oaFrame_FromoaDataAppDef_oaFrame(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaFramep result= (oaDataAppDef_oaFrame::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaFrame_FromoaDataAppDef_oaFrame(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaFrame, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaFrame_static_get_doc[] = 
"Class: oaDataAppDef_oaFrame, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaFrame* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaFrame|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaFrame* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaFrame|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaFrame_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaFramep result= (oaDataAppDef_oaFrame::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaFrame_FromoaDataAppDef_oaFrame(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaFramep result= (oaDataAppDef_oaFrame::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaFrame_FromoaDataAppDef_oaFrame(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaFrame, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaFrame_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaFrame_static_find,METH_VARARGS,oaDataAppDef_oaFrame_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaFrame_static_get,METH_VARARGS,oaDataAppDef_oaFrame_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaFrame_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaFrame_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaFrame\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaFrame",
           (PyObject*)(&PyoaDataAppDef_oaFrame_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaFrame\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaFrame_Type.tp_dict;
    for(method=oaDataAppDef_oaFrame_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaFrameInst
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaFrameInst_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaFrameInst_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaFrameInstObject* self = (PyoaDataAppDef_oaFrameInstObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaFrameInst)
    {
        PyParamoaDataAppDef_oaFrameInst p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaFrameInst_Convert,&p1)) {
            PyoaDataAppDef_oaFrameInstObject* cself=((PyoaDataAppDef_oaFrameInstObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaFrameInst, Choices are:\n"
        "    (oaDataAppDef_oaFrameInst)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaFrameInst_tp_dealloc(PyoaDataAppDef_oaFrameInstObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaFrameInst_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaFrameInst value;
    int convert_status=PyoaDataAppDef_oaFrameInst_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[46];
    sprintf(buffer,"<oaDataAppDef_oaFrameInst::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaFrameInst_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaFrameInst v1;
    PyParamoaDataAppDef_oaFrameInst v2;
    int convert_status1=PyoaDataAppDef_oaFrameInst_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaFrameInst_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaFrameInst_Convert(PyObject* ob,PyParamoaDataAppDef_oaFrameInst* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaFrameInst_Check(ob)) {
        result->SetData( (oaDataAppDef_oaFrameInst**) ((PyoaDataAppDef_oaFrameInstObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaFrameInst Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaFrameInst_FromoaDataAppDef_oaFrameInst(oaDataAppDef_oaFrameInst** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaFrameInst* data=*value;
        PyObject* bself = PyoaDataAppDef_oaFrameInst_Type.tp_alloc(&PyoaDataAppDef_oaFrameInst_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaFrameInstObject* self = (PyoaDataAppDef_oaFrameInstObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaFrameInst_FromoaDataAppDef_oaFrameInst(oaDataAppDef_oaFrameInst* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaFrameInst_Type.tp_alloc(&PyoaDataAppDef_oaFrameInst_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaFrameInstObject* self = (PyoaDataAppDef_oaFrameInstObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaFrameInst_get_doc[] = 
"Class: oaDataAppDef_oaFrameInst, Function: get\n"
"  Paramegers: (oaFrameInst,[oaByte])\n"
"    Calls: void get(const oaFrameInst* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaFrameInst,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaFrameInst_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaFrameInst data;
    int convert_status=PyoaDataAppDef_oaFrameInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaFrameInstObject* self=(PyoaDataAppDef_oaFrameInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaFrameInst p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaFrameInst_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaFrameInst_getDefault_doc[] = 
"Class: oaDataAppDef_oaFrameInst, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaFrameInst_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaFrameInst data;
    int convert_status=PyoaDataAppDef_oaFrameInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaFrameInstObject* self=(PyoaDataAppDef_oaFrameInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaFrameInst_getSize_doc[] = 
"Class: oaDataAppDef_oaFrameInst, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaFrameInst_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaFrameInst data;
    int convert_status=PyoaDataAppDef_oaFrameInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaFrameInstObject* self=(PyoaDataAppDef_oaFrameInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaFrameInst_set_doc[] = 
"Class: oaDataAppDef_oaFrameInst, Function: set\n"
"  Paramegers: (oaFrameInst,[oaByte])\n"
"    Calls: void set(oaFrameInst* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaFrameInst,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaFrameInst_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaFrameInst data;
    int convert_status=PyoaDataAppDef_oaFrameInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaFrameInstObject* self=(PyoaDataAppDef_oaFrameInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaFrameInst p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaFrameInst_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaFrameInst_isNull_doc[] =
"Class: oaDataAppDef_oaFrameInst, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaFrameInst_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaFrameInst data;
    int convert_status=PyoaDataAppDef_oaFrameInst_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaFrameInst_assign_doc[] = 
"Class: oaDataAppDef_oaFrameInst, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaFrameInst_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaFrameInst data;
  int convert_status=PyoaDataAppDef_oaFrameInst_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaFrameInst p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaFrameInst_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaFrameInst_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaFrameInst_get,METH_VARARGS,oaDataAppDef_oaFrameInst_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaFrameInst_getDefault,METH_VARARGS,oaDataAppDef_oaFrameInst_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaFrameInst_getSize,METH_VARARGS,oaDataAppDef_oaFrameInst_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaFrameInst_set,METH_VARARGS,oaDataAppDef_oaFrameInst_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaFrameInst_tp_isNull,METH_VARARGS,oaDataAppDef_oaFrameInst_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaFrameInst_tp_assign,METH_VARARGS,oaDataAppDef_oaFrameInst_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaFrameInst_doc[] = 
"Class: oaDataAppDef_oaFrameInst\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaFrameInst)\n"
"    Calls: (const oaDataAppDef_oaFrameInst&)\n"
"    Signature: oaDataAppDef_oaFrameInst||cref-oaDataAppDef_oaFrameInst,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaFrameInst_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaFrameInst",
    sizeof(PyoaDataAppDef_oaFrameInstObject),
    0,
    (destructor)oaDataAppDef_oaFrameInst_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaFrameInst_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaFrameInst_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaFrameInst_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaFrameInst_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaFrameInst_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaFrameInst_static_find_doc[] = 
"Class: oaDataAppDef_oaFrameInst, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaFrameInst* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaFrameInst|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaFrameInst* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaFrameInst|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaFrameInst_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaFrameInstp result= (oaDataAppDef_oaFrameInst::find(p1.Data()));
            return PyoaDataAppDef_oaFrameInst_FromoaDataAppDef_oaFrameInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaFrameInstp result= (oaDataAppDef_oaFrameInst::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaFrameInst_FromoaDataAppDef_oaFrameInst(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaFrameInst, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaFrameInst_static_get_doc[] = 
"Class: oaDataAppDef_oaFrameInst, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaFrameInst* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaFrameInst|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaFrameInst* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaFrameInst|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaFrameInst_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaFrameInstp result= (oaDataAppDef_oaFrameInst::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaFrameInst_FromoaDataAppDef_oaFrameInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaFrameInstp result= (oaDataAppDef_oaFrameInst::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaFrameInst_FromoaDataAppDef_oaFrameInst(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaFrameInst, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaFrameInst_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaFrameInst_static_find,METH_VARARGS,oaDataAppDef_oaFrameInst_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaFrameInst_static_get,METH_VARARGS,oaDataAppDef_oaFrameInst_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaFrameInst_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaFrameInst_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaFrameInst\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaFrameInst",
           (PyObject*)(&PyoaDataAppDef_oaFrameInst_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaFrameInst\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaFrameInst_Type.tp_dict;
    for(method=oaDataAppDef_oaFrameInst_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaGCellPattern
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaGCellPattern_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaGCellPattern_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaGCellPatternObject* self = (PyoaDataAppDef_oaGCellPatternObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaGCellPattern)
    {
        PyParamoaDataAppDef_oaGCellPattern p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaGCellPattern_Convert,&p1)) {
            PyoaDataAppDef_oaGCellPatternObject* cself=((PyoaDataAppDef_oaGCellPatternObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaGCellPattern, Choices are:\n"
        "    (oaDataAppDef_oaGCellPattern)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaGCellPattern_tp_dealloc(PyoaDataAppDef_oaGCellPatternObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaGCellPattern_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaGCellPattern value;
    int convert_status=PyoaDataAppDef_oaGCellPattern_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[49];
    sprintf(buffer,"<oaDataAppDef_oaGCellPattern::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaGCellPattern_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaGCellPattern v1;
    PyParamoaDataAppDef_oaGCellPattern v2;
    int convert_status1=PyoaDataAppDef_oaGCellPattern_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaGCellPattern_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaGCellPattern_Convert(PyObject* ob,PyParamoaDataAppDef_oaGCellPattern* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaGCellPattern_Check(ob)) {
        result->SetData( (oaDataAppDef_oaGCellPattern**) ((PyoaDataAppDef_oaGCellPatternObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaGCellPattern Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaGCellPattern_FromoaDataAppDef_oaGCellPattern(oaDataAppDef_oaGCellPattern** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaGCellPattern* data=*value;
        PyObject* bself = PyoaDataAppDef_oaGCellPattern_Type.tp_alloc(&PyoaDataAppDef_oaGCellPattern_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaGCellPatternObject* self = (PyoaDataAppDef_oaGCellPatternObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaGCellPattern_FromoaDataAppDef_oaGCellPattern(oaDataAppDef_oaGCellPattern* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaGCellPattern_Type.tp_alloc(&PyoaDataAppDef_oaGCellPattern_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaGCellPatternObject* self = (PyoaDataAppDef_oaGCellPatternObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaGCellPattern_get_doc[] = 
"Class: oaDataAppDef_oaGCellPattern, Function: get\n"
"  Paramegers: (oaGCellPattern,[oaByte])\n"
"    Calls: void get(const oaGCellPattern* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaGCellPattern,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaGCellPattern_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaGCellPattern data;
    int convert_status=PyoaDataAppDef_oaGCellPattern_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaGCellPatternObject* self=(PyoaDataAppDef_oaGCellPatternObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaGCellPattern p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaGCellPattern_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaGCellPattern_getDefault_doc[] = 
"Class: oaDataAppDef_oaGCellPattern, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaGCellPattern_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaGCellPattern data;
    int convert_status=PyoaDataAppDef_oaGCellPattern_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaGCellPatternObject* self=(PyoaDataAppDef_oaGCellPatternObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaGCellPattern_getSize_doc[] = 
"Class: oaDataAppDef_oaGCellPattern, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaGCellPattern_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaGCellPattern data;
    int convert_status=PyoaDataAppDef_oaGCellPattern_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaGCellPatternObject* self=(PyoaDataAppDef_oaGCellPatternObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaGCellPattern_set_doc[] = 
"Class: oaDataAppDef_oaGCellPattern, Function: set\n"
"  Paramegers: (oaGCellPattern,[oaByte])\n"
"    Calls: void set(oaGCellPattern* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaGCellPattern,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaGCellPattern_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaGCellPattern data;
    int convert_status=PyoaDataAppDef_oaGCellPattern_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaGCellPatternObject* self=(PyoaDataAppDef_oaGCellPatternObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaGCellPattern p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaGCellPattern_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaGCellPattern_isNull_doc[] =
"Class: oaDataAppDef_oaGCellPattern, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaGCellPattern_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaGCellPattern data;
    int convert_status=PyoaDataAppDef_oaGCellPattern_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaGCellPattern_assign_doc[] = 
"Class: oaDataAppDef_oaGCellPattern, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaGCellPattern_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaGCellPattern data;
  int convert_status=PyoaDataAppDef_oaGCellPattern_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaGCellPattern p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaGCellPattern_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaGCellPattern_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaGCellPattern_get,METH_VARARGS,oaDataAppDef_oaGCellPattern_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaGCellPattern_getDefault,METH_VARARGS,oaDataAppDef_oaGCellPattern_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaGCellPattern_getSize,METH_VARARGS,oaDataAppDef_oaGCellPattern_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaGCellPattern_set,METH_VARARGS,oaDataAppDef_oaGCellPattern_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaGCellPattern_tp_isNull,METH_VARARGS,oaDataAppDef_oaGCellPattern_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaGCellPattern_tp_assign,METH_VARARGS,oaDataAppDef_oaGCellPattern_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaGCellPattern_doc[] = 
"Class: oaDataAppDef_oaGCellPattern\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaGCellPattern)\n"
"    Calls: (const oaDataAppDef_oaGCellPattern&)\n"
"    Signature: oaDataAppDef_oaGCellPattern||cref-oaDataAppDef_oaGCellPattern,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaGCellPattern_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaGCellPattern",
    sizeof(PyoaDataAppDef_oaGCellPatternObject),
    0,
    (destructor)oaDataAppDef_oaGCellPattern_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaGCellPattern_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaGCellPattern_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaGCellPattern_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaGCellPattern_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaGCellPattern_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaGCellPattern_static_find_doc[] = 
"Class: oaDataAppDef_oaGCellPattern, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaGCellPattern* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaGCellPattern|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaGCellPattern* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaGCellPattern|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaGCellPattern_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaGCellPatternp result= (oaDataAppDef_oaGCellPattern::find(p1.Data()));
            return PyoaDataAppDef_oaGCellPattern_FromoaDataAppDef_oaGCellPattern(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaGCellPatternp result= (oaDataAppDef_oaGCellPattern::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaGCellPattern_FromoaDataAppDef_oaGCellPattern(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaGCellPattern, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaGCellPattern_static_get_doc[] = 
"Class: oaDataAppDef_oaGCellPattern, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaGCellPattern* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaGCellPattern|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaGCellPattern* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaGCellPattern|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaGCellPattern_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaGCellPatternp result= (oaDataAppDef_oaGCellPattern::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaGCellPattern_FromoaDataAppDef_oaGCellPattern(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaGCellPatternp result= (oaDataAppDef_oaGCellPattern::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaGCellPattern_FromoaDataAppDef_oaGCellPattern(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaGCellPattern, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaGCellPattern_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaGCellPattern_static_find,METH_VARARGS,oaDataAppDef_oaGCellPattern_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaGCellPattern_static_get,METH_VARARGS,oaDataAppDef_oaGCellPattern_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaGCellPattern_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaGCellPattern_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaGCellPattern\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaGCellPattern",
           (PyObject*)(&PyoaDataAppDef_oaGCellPattern_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaGCellPattern\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaGCellPattern_Type.tp_dict;
    for(method=oaDataAppDef_oaGCellPattern_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaGroup
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaGroup_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaGroup_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaGroupObject* self = (PyoaDataAppDef_oaGroupObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaGroup)
    {
        PyParamoaDataAppDef_oaGroup p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaGroup_Convert,&p1)) {
            PyoaDataAppDef_oaGroupObject* cself=((PyoaDataAppDef_oaGroupObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaGroup, Choices are:\n"
        "    (oaDataAppDef_oaGroup)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaGroup_tp_dealloc(PyoaDataAppDef_oaGroupObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaGroup_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaGroup value;
    int convert_status=PyoaDataAppDef_oaGroup_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaDataAppDef_oaGroup::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaGroup_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaGroup v1;
    PyParamoaDataAppDef_oaGroup v2;
    int convert_status1=PyoaDataAppDef_oaGroup_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaGroup_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaGroup_Convert(PyObject* ob,PyParamoaDataAppDef_oaGroup* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaGroup_Check(ob)) {
        result->SetData( (oaDataAppDef_oaGroup**) ((PyoaDataAppDef_oaGroupObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaGroup Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaGroup_FromoaDataAppDef_oaGroup(oaDataAppDef_oaGroup** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaGroup* data=*value;
        PyObject* bself = PyoaDataAppDef_oaGroup_Type.tp_alloc(&PyoaDataAppDef_oaGroup_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaGroupObject* self = (PyoaDataAppDef_oaGroupObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaGroup_FromoaDataAppDef_oaGroup(oaDataAppDef_oaGroup* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaGroup_Type.tp_alloc(&PyoaDataAppDef_oaGroup_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaGroupObject* self = (PyoaDataAppDef_oaGroupObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaGroup_get_doc[] = 
"Class: oaDataAppDef_oaGroup, Function: get\n"
"  Paramegers: (oaGroup,[oaByte])\n"
"    Calls: void get(const oaGroup* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaGroup,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaGroup_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaGroup data;
    int convert_status=PyoaDataAppDef_oaGroup_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaGroupObject* self=(PyoaDataAppDef_oaGroupObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaGroup p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaGroup_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaGroup_getDefault_doc[] = 
"Class: oaDataAppDef_oaGroup, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaGroup_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaGroup data;
    int convert_status=PyoaDataAppDef_oaGroup_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaGroupObject* self=(PyoaDataAppDef_oaGroupObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaGroup_getSize_doc[] = 
"Class: oaDataAppDef_oaGroup, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaGroup_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaGroup data;
    int convert_status=PyoaDataAppDef_oaGroup_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaGroupObject* self=(PyoaDataAppDef_oaGroupObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaGroup_set_doc[] = 
"Class: oaDataAppDef_oaGroup, Function: set\n"
"  Paramegers: (oaGroup,[oaByte])\n"
"    Calls: void set(oaGroup* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaGroup,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaGroup_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaGroup data;
    int convert_status=PyoaDataAppDef_oaGroup_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaGroupObject* self=(PyoaDataAppDef_oaGroupObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaGroup p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaGroup_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaGroup_isNull_doc[] =
"Class: oaDataAppDef_oaGroup, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaGroup_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaGroup data;
    int convert_status=PyoaDataAppDef_oaGroup_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaGroup_assign_doc[] = 
"Class: oaDataAppDef_oaGroup, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaGroup_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaGroup data;
  int convert_status=PyoaDataAppDef_oaGroup_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaGroup p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaGroup_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaGroup_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaGroup_get,METH_VARARGS,oaDataAppDef_oaGroup_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaGroup_getDefault,METH_VARARGS,oaDataAppDef_oaGroup_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaGroup_getSize,METH_VARARGS,oaDataAppDef_oaGroup_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaGroup_set,METH_VARARGS,oaDataAppDef_oaGroup_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaGroup_tp_isNull,METH_VARARGS,oaDataAppDef_oaGroup_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaGroup_tp_assign,METH_VARARGS,oaDataAppDef_oaGroup_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaGroup_doc[] = 
"Class: oaDataAppDef_oaGroup\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaGroup)\n"
"    Calls: (const oaDataAppDef_oaGroup&)\n"
"    Signature: oaDataAppDef_oaGroup||cref-oaDataAppDef_oaGroup,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaGroup_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaGroup",
    sizeof(PyoaDataAppDef_oaGroupObject),
    0,
    (destructor)oaDataAppDef_oaGroup_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaGroup_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaGroup_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaGroup_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaGroup_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaGroup_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaGroup_static_find_doc[] = 
"Class: oaDataAppDef_oaGroup, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaGroup* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaGroup|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaGroup* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaGroup|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaGroup_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaGroupp result= (oaDataAppDef_oaGroup::find(p1.Data()));
            return PyoaDataAppDef_oaGroup_FromoaDataAppDef_oaGroup(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaGroupp result= (oaDataAppDef_oaGroup::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaGroup_FromoaDataAppDef_oaGroup(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaGroup, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaGroup_static_get_doc[] = 
"Class: oaDataAppDef_oaGroup, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaGroup* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaGroup|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaGroup* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaGroup|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaGroup_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaGroupp result= (oaDataAppDef_oaGroup::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaGroup_FromoaDataAppDef_oaGroup(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaGroupp result= (oaDataAppDef_oaGroup::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaGroup_FromoaDataAppDef_oaGroup(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaGroup, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaGroup_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaGroup_static_find,METH_VARARGS,oaDataAppDef_oaGroup_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaGroup_static_get,METH_VARARGS,oaDataAppDef_oaGroup_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaGroup_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaGroup_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaGroup\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaGroup",
           (PyObject*)(&PyoaDataAppDef_oaGroup_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaGroup\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaGroup_Type.tp_dict;
    for(method=oaDataAppDef_oaGroup_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaGroupMember
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaGroupMember_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaGroupMember_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaGroupMemberObject* self = (PyoaDataAppDef_oaGroupMemberObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaGroupMember)
    {
        PyParamoaDataAppDef_oaGroupMember p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaGroupMember_Convert,&p1)) {
            PyoaDataAppDef_oaGroupMemberObject* cself=((PyoaDataAppDef_oaGroupMemberObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaGroupMember, Choices are:\n"
        "    (oaDataAppDef_oaGroupMember)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaGroupMember_tp_dealloc(PyoaDataAppDef_oaGroupMemberObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaGroupMember_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaGroupMember value;
    int convert_status=PyoaDataAppDef_oaGroupMember_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[48];
    sprintf(buffer,"<oaDataAppDef_oaGroupMember::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaGroupMember_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaGroupMember v1;
    PyParamoaDataAppDef_oaGroupMember v2;
    int convert_status1=PyoaDataAppDef_oaGroupMember_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaGroupMember_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaGroupMember_Convert(PyObject* ob,PyParamoaDataAppDef_oaGroupMember* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaGroupMember_Check(ob)) {
        result->SetData( (oaDataAppDef_oaGroupMember**) ((PyoaDataAppDef_oaGroupMemberObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaGroupMember Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaGroupMember_FromoaDataAppDef_oaGroupMember(oaDataAppDef_oaGroupMember** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaGroupMember* data=*value;
        PyObject* bself = PyoaDataAppDef_oaGroupMember_Type.tp_alloc(&PyoaDataAppDef_oaGroupMember_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaGroupMemberObject* self = (PyoaDataAppDef_oaGroupMemberObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaGroupMember_FromoaDataAppDef_oaGroupMember(oaDataAppDef_oaGroupMember* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaGroupMember_Type.tp_alloc(&PyoaDataAppDef_oaGroupMember_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaGroupMemberObject* self = (PyoaDataAppDef_oaGroupMemberObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaGroupMember_get_doc[] = 
"Class: oaDataAppDef_oaGroupMember, Function: get\n"
"  Paramegers: (oaGroupMember,[oaByte])\n"
"    Calls: void get(const oaGroupMember* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaGroupMember,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaGroupMember_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaGroupMember data;
    int convert_status=PyoaDataAppDef_oaGroupMember_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaGroupMemberObject* self=(PyoaDataAppDef_oaGroupMemberObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaGroupMember p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaGroupMember_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaGroupMember_getDefault_doc[] = 
"Class: oaDataAppDef_oaGroupMember, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaGroupMember_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaGroupMember data;
    int convert_status=PyoaDataAppDef_oaGroupMember_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaGroupMemberObject* self=(PyoaDataAppDef_oaGroupMemberObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaGroupMember_getSize_doc[] = 
"Class: oaDataAppDef_oaGroupMember, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaGroupMember_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaGroupMember data;
    int convert_status=PyoaDataAppDef_oaGroupMember_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaGroupMemberObject* self=(PyoaDataAppDef_oaGroupMemberObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaGroupMember_set_doc[] = 
"Class: oaDataAppDef_oaGroupMember, Function: set\n"
"  Paramegers: (oaGroupMember,[oaByte])\n"
"    Calls: void set(oaGroupMember* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaGroupMember,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaGroupMember_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaGroupMember data;
    int convert_status=PyoaDataAppDef_oaGroupMember_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaGroupMemberObject* self=(PyoaDataAppDef_oaGroupMemberObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaGroupMember p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaGroupMember_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaGroupMember_isNull_doc[] =
"Class: oaDataAppDef_oaGroupMember, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaGroupMember_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaGroupMember data;
    int convert_status=PyoaDataAppDef_oaGroupMember_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaGroupMember_assign_doc[] = 
"Class: oaDataAppDef_oaGroupMember, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaGroupMember_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaGroupMember data;
  int convert_status=PyoaDataAppDef_oaGroupMember_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaGroupMember p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaGroupMember_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaGroupMember_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaGroupMember_get,METH_VARARGS,oaDataAppDef_oaGroupMember_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaGroupMember_getDefault,METH_VARARGS,oaDataAppDef_oaGroupMember_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaGroupMember_getSize,METH_VARARGS,oaDataAppDef_oaGroupMember_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaGroupMember_set,METH_VARARGS,oaDataAppDef_oaGroupMember_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaGroupMember_tp_isNull,METH_VARARGS,oaDataAppDef_oaGroupMember_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaGroupMember_tp_assign,METH_VARARGS,oaDataAppDef_oaGroupMember_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaGroupMember_doc[] = 
"Class: oaDataAppDef_oaGroupMember\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaGroupMember)\n"
"    Calls: (const oaDataAppDef_oaGroupMember&)\n"
"    Signature: oaDataAppDef_oaGroupMember||cref-oaDataAppDef_oaGroupMember,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaGroupMember_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaGroupMember",
    sizeof(PyoaDataAppDef_oaGroupMemberObject),
    0,
    (destructor)oaDataAppDef_oaGroupMember_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaGroupMember_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaGroupMember_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaGroupMember_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaGroupMember_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaGroupMember_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaGroupMember_static_find_doc[] = 
"Class: oaDataAppDef_oaGroupMember, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaGroupMember* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaGroupMember|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaGroupMember* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaGroupMember|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaGroupMember_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaGroupMemberp result= (oaDataAppDef_oaGroupMember::find(p1.Data()));
            return PyoaDataAppDef_oaGroupMember_FromoaDataAppDef_oaGroupMember(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaGroupMemberp result= (oaDataAppDef_oaGroupMember::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaGroupMember_FromoaDataAppDef_oaGroupMember(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaGroupMember, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaGroupMember_static_get_doc[] = 
"Class: oaDataAppDef_oaGroupMember, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaGroupMember* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaGroupMember|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaGroupMember* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaGroupMember|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaGroupMember_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaGroupMemberp result= (oaDataAppDef_oaGroupMember::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaGroupMember_FromoaDataAppDef_oaGroupMember(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaGroupMemberp result= (oaDataAppDef_oaGroupMember::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaGroupMember_FromoaDataAppDef_oaGroupMember(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaGroupMember, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaGroupMember_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaGroupMember_static_find,METH_VARARGS,oaDataAppDef_oaGroupMember_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaGroupMember_static_get,METH_VARARGS,oaDataAppDef_oaGroupMember_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaGroupMember_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaGroupMember_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaGroupMember\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaGroupMember",
           (PyObject*)(&PyoaDataAppDef_oaGroupMember_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaGroupMember\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaGroupMember_Type.tp_dict;
    for(method=oaDataAppDef_oaGroupMember_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaGuide
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaGuide_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaGuide_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaGuideObject* self = (PyoaDataAppDef_oaGuideObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaGuide)
    {
        PyParamoaDataAppDef_oaGuide p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaGuide_Convert,&p1)) {
            PyoaDataAppDef_oaGuideObject* cself=((PyoaDataAppDef_oaGuideObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaGuide, Choices are:\n"
        "    (oaDataAppDef_oaGuide)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaGuide_tp_dealloc(PyoaDataAppDef_oaGuideObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaGuide_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaGuide value;
    int convert_status=PyoaDataAppDef_oaGuide_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaDataAppDef_oaGuide::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaGuide_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaGuide v1;
    PyParamoaDataAppDef_oaGuide v2;
    int convert_status1=PyoaDataAppDef_oaGuide_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaGuide_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaGuide_Convert(PyObject* ob,PyParamoaDataAppDef_oaGuide* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaGuide_Check(ob)) {
        result->SetData( (oaDataAppDef_oaGuide**) ((PyoaDataAppDef_oaGuideObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaGuide Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaGuide_FromoaDataAppDef_oaGuide(oaDataAppDef_oaGuide** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaGuide* data=*value;
        PyObject* bself = PyoaDataAppDef_oaGuide_Type.tp_alloc(&PyoaDataAppDef_oaGuide_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaGuideObject* self = (PyoaDataAppDef_oaGuideObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaGuide_FromoaDataAppDef_oaGuide(oaDataAppDef_oaGuide* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaGuide_Type.tp_alloc(&PyoaDataAppDef_oaGuide_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaGuideObject* self = (PyoaDataAppDef_oaGuideObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaGuide_get_doc[] = 
"Class: oaDataAppDef_oaGuide, Function: get\n"
"  Paramegers: (oaGuide,[oaByte])\n"
"    Calls: void get(const oaGuide* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaGuide,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaGuide_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaGuide data;
    int convert_status=PyoaDataAppDef_oaGuide_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaGuideObject* self=(PyoaDataAppDef_oaGuideObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaGuide p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaGuide_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaGuide_getDefault_doc[] = 
"Class: oaDataAppDef_oaGuide, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaGuide_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaGuide data;
    int convert_status=PyoaDataAppDef_oaGuide_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaGuideObject* self=(PyoaDataAppDef_oaGuideObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaGuide_getSize_doc[] = 
"Class: oaDataAppDef_oaGuide, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaGuide_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaGuide data;
    int convert_status=PyoaDataAppDef_oaGuide_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaGuideObject* self=(PyoaDataAppDef_oaGuideObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaGuide_set_doc[] = 
"Class: oaDataAppDef_oaGuide, Function: set\n"
"  Paramegers: (oaGuide,[oaByte])\n"
"    Calls: void set(oaGuide* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaGuide,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaGuide_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaGuide data;
    int convert_status=PyoaDataAppDef_oaGuide_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaGuideObject* self=(PyoaDataAppDef_oaGuideObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaGuide p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaGuide_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaGuide_isNull_doc[] =
"Class: oaDataAppDef_oaGuide, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaGuide_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaGuide data;
    int convert_status=PyoaDataAppDef_oaGuide_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaGuide_assign_doc[] = 
"Class: oaDataAppDef_oaGuide, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaGuide_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaGuide data;
  int convert_status=PyoaDataAppDef_oaGuide_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaGuide p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaGuide_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaGuide_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaGuide_get,METH_VARARGS,oaDataAppDef_oaGuide_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaGuide_getDefault,METH_VARARGS,oaDataAppDef_oaGuide_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaGuide_getSize,METH_VARARGS,oaDataAppDef_oaGuide_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaGuide_set,METH_VARARGS,oaDataAppDef_oaGuide_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaGuide_tp_isNull,METH_VARARGS,oaDataAppDef_oaGuide_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaGuide_tp_assign,METH_VARARGS,oaDataAppDef_oaGuide_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaGuide_doc[] = 
"Class: oaDataAppDef_oaGuide\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaGuide)\n"
"    Calls: (const oaDataAppDef_oaGuide&)\n"
"    Signature: oaDataAppDef_oaGuide||cref-oaDataAppDef_oaGuide,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaGuide_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaGuide",
    sizeof(PyoaDataAppDef_oaGuideObject),
    0,
    (destructor)oaDataAppDef_oaGuide_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaGuide_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaGuide_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaGuide_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaGuide_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaGuide_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaGuide_static_find_doc[] = 
"Class: oaDataAppDef_oaGuide, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaGuide* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaGuide|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaGuide* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaGuide|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaGuide_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaGuidep result= (oaDataAppDef_oaGuide::find(p1.Data()));
            return PyoaDataAppDef_oaGuide_FromoaDataAppDef_oaGuide(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaGuidep result= (oaDataAppDef_oaGuide::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaGuide_FromoaDataAppDef_oaGuide(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaGuide, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaGuide_static_get_doc[] = 
"Class: oaDataAppDef_oaGuide, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaGuide* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaGuide|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaGuide* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaGuide|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaGuide_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaGuidep result= (oaDataAppDef_oaGuide::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaGuide_FromoaDataAppDef_oaGuide(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaGuidep result= (oaDataAppDef_oaGuide::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaGuide_FromoaDataAppDef_oaGuide(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaGuide, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaGuide_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaGuide_static_find,METH_VARARGS,oaDataAppDef_oaGuide_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaGuide_static_get,METH_VARARGS,oaDataAppDef_oaGuide_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaGuide_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaGuide_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaGuide\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaGuide",
           (PyObject*)(&PyoaDataAppDef_oaGuide_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaGuide\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaGuide_Type.tp_dict;
    for(method=oaDataAppDef_oaGuide_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaImage
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaImage_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaImage_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaImageObject* self = (PyoaDataAppDef_oaImageObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaImage)
    {
        PyParamoaDataAppDef_oaImage p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaImage_Convert,&p1)) {
            PyoaDataAppDef_oaImageObject* cself=((PyoaDataAppDef_oaImageObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaImage, Choices are:\n"
        "    (oaDataAppDef_oaImage)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaImage_tp_dealloc(PyoaDataAppDef_oaImageObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaImage_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaImage value;
    int convert_status=PyoaDataAppDef_oaImage_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaDataAppDef_oaImage::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaImage_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaImage v1;
    PyParamoaDataAppDef_oaImage v2;
    int convert_status1=PyoaDataAppDef_oaImage_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaImage_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaImage_Convert(PyObject* ob,PyParamoaDataAppDef_oaImage* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaImage_Check(ob)) {
        result->SetData( (oaDataAppDef_oaImage**) ((PyoaDataAppDef_oaImageObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaImage Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaImage_FromoaDataAppDef_oaImage(oaDataAppDef_oaImage** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaImage* data=*value;
        PyObject* bself = PyoaDataAppDef_oaImage_Type.tp_alloc(&PyoaDataAppDef_oaImage_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaImageObject* self = (PyoaDataAppDef_oaImageObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaImage_FromoaDataAppDef_oaImage(oaDataAppDef_oaImage* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaImage_Type.tp_alloc(&PyoaDataAppDef_oaImage_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaImageObject* self = (PyoaDataAppDef_oaImageObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaImage_get_doc[] = 
"Class: oaDataAppDef_oaImage, Function: get\n"
"  Paramegers: (oaImage,[oaByte])\n"
"    Calls: void get(const oaImage* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaImage,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaImage_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaImage data;
    int convert_status=PyoaDataAppDef_oaImage_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaImageObject* self=(PyoaDataAppDef_oaImageObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaImage p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaImage_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaImage_getDefault_doc[] = 
"Class: oaDataAppDef_oaImage, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaImage_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaImage data;
    int convert_status=PyoaDataAppDef_oaImage_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaImageObject* self=(PyoaDataAppDef_oaImageObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaImage_getSize_doc[] = 
"Class: oaDataAppDef_oaImage, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaImage_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaImage data;
    int convert_status=PyoaDataAppDef_oaImage_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaImageObject* self=(PyoaDataAppDef_oaImageObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaImage_set_doc[] = 
"Class: oaDataAppDef_oaImage, Function: set\n"
"  Paramegers: (oaImage,[oaByte])\n"
"    Calls: void set(oaImage* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaImage,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaImage_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaImage data;
    int convert_status=PyoaDataAppDef_oaImage_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaImageObject* self=(PyoaDataAppDef_oaImageObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaImage p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaImage_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaImage_isNull_doc[] =
"Class: oaDataAppDef_oaImage, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaImage_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaImage data;
    int convert_status=PyoaDataAppDef_oaImage_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaImage_assign_doc[] = 
"Class: oaDataAppDef_oaImage, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaImage_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaImage data;
  int convert_status=PyoaDataAppDef_oaImage_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaImage p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaImage_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaImage_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaImage_get,METH_VARARGS,oaDataAppDef_oaImage_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaImage_getDefault,METH_VARARGS,oaDataAppDef_oaImage_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaImage_getSize,METH_VARARGS,oaDataAppDef_oaImage_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaImage_set,METH_VARARGS,oaDataAppDef_oaImage_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaImage_tp_isNull,METH_VARARGS,oaDataAppDef_oaImage_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaImage_tp_assign,METH_VARARGS,oaDataAppDef_oaImage_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaImage_doc[] = 
"Class: oaDataAppDef_oaImage\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaImage)\n"
"    Calls: (const oaDataAppDef_oaImage&)\n"
"    Signature: oaDataAppDef_oaImage||cref-oaDataAppDef_oaImage,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaImage_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaImage",
    sizeof(PyoaDataAppDef_oaImageObject),
    0,
    (destructor)oaDataAppDef_oaImage_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaImage_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaImage_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaImage_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaImage_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaImage_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaImage_static_find_doc[] = 
"Class: oaDataAppDef_oaImage, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaImage* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaImage|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaImage* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaImage|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaImage_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaImagep result= (oaDataAppDef_oaImage::find(p1.Data()));
            return PyoaDataAppDef_oaImage_FromoaDataAppDef_oaImage(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaImagep result= (oaDataAppDef_oaImage::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaImage_FromoaDataAppDef_oaImage(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaImage, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaImage_static_get_doc[] = 
"Class: oaDataAppDef_oaImage, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaImage* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaImage|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaImage* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaImage|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaImage_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaImagep result= (oaDataAppDef_oaImage::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaImage_FromoaDataAppDef_oaImage(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaImagep result= (oaDataAppDef_oaImage::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaImage_FromoaDataAppDef_oaImage(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaImage, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaImage_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaImage_static_find,METH_VARARGS,oaDataAppDef_oaImage_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaImage_static_get,METH_VARARGS,oaDataAppDef_oaImage_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaImage_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaImage_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaImage\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaImage",
           (PyObject*)(&PyoaDataAppDef_oaImage_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaImage\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaImage_Type.tp_dict;
    for(method=oaDataAppDef_oaImage_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaInst
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaInst_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaInst_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaInstObject* self = (PyoaDataAppDef_oaInstObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaInst)
    {
        PyParamoaDataAppDef_oaInst p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaInst_Convert,&p1)) {
            PyoaDataAppDef_oaInstObject* cself=((PyoaDataAppDef_oaInstObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaInst, Choices are:\n"
        "    (oaDataAppDef_oaInst)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaInst_tp_dealloc(PyoaDataAppDef_oaInstObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaInst_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaInst value;
    int convert_status=PyoaDataAppDef_oaInst_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[41];
    sprintf(buffer,"<oaDataAppDef_oaInst::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaInst_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaInst v1;
    PyParamoaDataAppDef_oaInst v2;
    int convert_status1=PyoaDataAppDef_oaInst_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaInst_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaInst_Convert(PyObject* ob,PyParamoaDataAppDef_oaInst* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaInst_Check(ob)) {
        result->SetData( (oaDataAppDef_oaInst**) ((PyoaDataAppDef_oaInstObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaInst Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaInst_FromoaDataAppDef_oaInst(oaDataAppDef_oaInst** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaInst* data=*value;
        PyObject* bself = PyoaDataAppDef_oaInst_Type.tp_alloc(&PyoaDataAppDef_oaInst_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaInstObject* self = (PyoaDataAppDef_oaInstObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaInst_FromoaDataAppDef_oaInst(oaDataAppDef_oaInst* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaInst_Type.tp_alloc(&PyoaDataAppDef_oaInst_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaInstObject* self = (PyoaDataAppDef_oaInstObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaInst_get_doc[] = 
"Class: oaDataAppDef_oaInst, Function: get\n"
"  Paramegers: (oaInst,[oaByte])\n"
"    Calls: void get(const oaInst* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaInst,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaInst_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaInst data;
    int convert_status=PyoaDataAppDef_oaInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaInstObject* self=(PyoaDataAppDef_oaInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaInst p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaInst_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaInst_getDefault_doc[] = 
"Class: oaDataAppDef_oaInst, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaInst_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaInst data;
    int convert_status=PyoaDataAppDef_oaInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaInstObject* self=(PyoaDataAppDef_oaInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaInst_getSize_doc[] = 
"Class: oaDataAppDef_oaInst, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaInst_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaInst data;
    int convert_status=PyoaDataAppDef_oaInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaInstObject* self=(PyoaDataAppDef_oaInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaInst_set_doc[] = 
"Class: oaDataAppDef_oaInst, Function: set\n"
"  Paramegers: (oaInst,[oaByte])\n"
"    Calls: void set(oaInst* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaInst,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaInst_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaInst data;
    int convert_status=PyoaDataAppDef_oaInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaInstObject* self=(PyoaDataAppDef_oaInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaInst p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaInst_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaInst_isNull_doc[] =
"Class: oaDataAppDef_oaInst, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaInst_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaInst data;
    int convert_status=PyoaDataAppDef_oaInst_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaInst_assign_doc[] = 
"Class: oaDataAppDef_oaInst, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaInst_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaInst data;
  int convert_status=PyoaDataAppDef_oaInst_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaInst p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaInst_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaInst_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaInst_get,METH_VARARGS,oaDataAppDef_oaInst_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaInst_getDefault,METH_VARARGS,oaDataAppDef_oaInst_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaInst_getSize,METH_VARARGS,oaDataAppDef_oaInst_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaInst_set,METH_VARARGS,oaDataAppDef_oaInst_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaInst_tp_isNull,METH_VARARGS,oaDataAppDef_oaInst_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaInst_tp_assign,METH_VARARGS,oaDataAppDef_oaInst_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaInst_doc[] = 
"Class: oaDataAppDef_oaInst\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaInst)\n"
"    Calls: (const oaDataAppDef_oaInst&)\n"
"    Signature: oaDataAppDef_oaInst||cref-oaDataAppDef_oaInst,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaInst_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaInst",
    sizeof(PyoaDataAppDef_oaInstObject),
    0,
    (destructor)oaDataAppDef_oaInst_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaInst_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaInst_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaInst_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaInst_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaInst_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaInst_static_find_doc[] = 
"Class: oaDataAppDef_oaInst, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaInst* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaInst|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaInst* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaInst|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaInst_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaInstp result= (oaDataAppDef_oaInst::find(p1.Data()));
            return PyoaDataAppDef_oaInst_FromoaDataAppDef_oaInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaInstp result= (oaDataAppDef_oaInst::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaInst_FromoaDataAppDef_oaInst(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaInst, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaInst_static_get_doc[] = 
"Class: oaDataAppDef_oaInst, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaInst* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaInst|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaInst* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaInst|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaInst_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaInstp result= (oaDataAppDef_oaInst::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaInst_FromoaDataAppDef_oaInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaInstp result= (oaDataAppDef_oaInst::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaInst_FromoaDataAppDef_oaInst(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaInst, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaInst_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaInst_static_find,METH_VARARGS,oaDataAppDef_oaInst_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaInst_static_get,METH_VARARGS,oaDataAppDef_oaInst_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaInst_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaInst_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaInst\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaInst",
           (PyObject*)(&PyoaDataAppDef_oaInst_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaInst\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaInst_Type.tp_dict;
    for(method=oaDataAppDef_oaInst_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaInstHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaInstHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaInstHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaInstHeaderObject* self = (PyoaDataAppDef_oaInstHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaInstHeader)
    {
        PyParamoaDataAppDef_oaInstHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaInstHeader_Convert,&p1)) {
            PyoaDataAppDef_oaInstHeaderObject* cself=((PyoaDataAppDef_oaInstHeaderObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaInstHeader, Choices are:\n"
        "    (oaDataAppDef_oaInstHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaInstHeader_tp_dealloc(PyoaDataAppDef_oaInstHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaInstHeader_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaInstHeader value;
    int convert_status=PyoaDataAppDef_oaInstHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[47];
    sprintf(buffer,"<oaDataAppDef_oaInstHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaInstHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaInstHeader v1;
    PyParamoaDataAppDef_oaInstHeader v2;
    int convert_status1=PyoaDataAppDef_oaInstHeader_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaInstHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaInstHeader_Convert(PyObject* ob,PyParamoaDataAppDef_oaInstHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaInstHeader_Check(ob)) {
        result->SetData( (oaDataAppDef_oaInstHeader**) ((PyoaDataAppDef_oaInstHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaInstHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaInstHeader_FromoaDataAppDef_oaInstHeader(oaDataAppDef_oaInstHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaInstHeader* data=*value;
        PyObject* bself = PyoaDataAppDef_oaInstHeader_Type.tp_alloc(&PyoaDataAppDef_oaInstHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaInstHeaderObject* self = (PyoaDataAppDef_oaInstHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaInstHeader_FromoaDataAppDef_oaInstHeader(oaDataAppDef_oaInstHeader* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaInstHeader_Type.tp_alloc(&PyoaDataAppDef_oaInstHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaInstHeaderObject* self = (PyoaDataAppDef_oaInstHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaInstHeader_get_doc[] = 
"Class: oaDataAppDef_oaInstHeader, Function: get\n"
"  Paramegers: (oaInstHeader,[oaByte])\n"
"    Calls: void get(const oaInstHeader* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaInstHeader,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaInstHeader_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaInstHeader data;
    int convert_status=PyoaDataAppDef_oaInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaInstHeaderObject* self=(PyoaDataAppDef_oaInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaInstHeader p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaInstHeader_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaInstHeader_getDefault_doc[] = 
"Class: oaDataAppDef_oaInstHeader, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaInstHeader_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaInstHeader data;
    int convert_status=PyoaDataAppDef_oaInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaInstHeaderObject* self=(PyoaDataAppDef_oaInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaInstHeader_getSize_doc[] = 
"Class: oaDataAppDef_oaInstHeader, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaInstHeader_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaInstHeader data;
    int convert_status=PyoaDataAppDef_oaInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaInstHeaderObject* self=(PyoaDataAppDef_oaInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaInstHeader_set_doc[] = 
"Class: oaDataAppDef_oaInstHeader, Function: set\n"
"  Paramegers: (oaInstHeader,[oaByte])\n"
"    Calls: void set(oaInstHeader* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaInstHeader,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaInstHeader_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaInstHeader data;
    int convert_status=PyoaDataAppDef_oaInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaInstHeaderObject* self=(PyoaDataAppDef_oaInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaInstHeader p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaInstHeader_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaInstHeader_isNull_doc[] =
"Class: oaDataAppDef_oaInstHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaInstHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaInstHeader data;
    int convert_status=PyoaDataAppDef_oaInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaInstHeader_assign_doc[] = 
"Class: oaDataAppDef_oaInstHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaInstHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaInstHeader data;
  int convert_status=PyoaDataAppDef_oaInstHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaInstHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaInstHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaInstHeader_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaInstHeader_get,METH_VARARGS,oaDataAppDef_oaInstHeader_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaInstHeader_getDefault,METH_VARARGS,oaDataAppDef_oaInstHeader_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaInstHeader_getSize,METH_VARARGS,oaDataAppDef_oaInstHeader_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaInstHeader_set,METH_VARARGS,oaDataAppDef_oaInstHeader_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaInstHeader_tp_isNull,METH_VARARGS,oaDataAppDef_oaInstHeader_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaInstHeader_tp_assign,METH_VARARGS,oaDataAppDef_oaInstHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaInstHeader_doc[] = 
"Class: oaDataAppDef_oaInstHeader\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaInstHeader)\n"
"    Calls: (const oaDataAppDef_oaInstHeader&)\n"
"    Signature: oaDataAppDef_oaInstHeader||cref-oaDataAppDef_oaInstHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaInstHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaInstHeader",
    sizeof(PyoaDataAppDef_oaInstHeaderObject),
    0,
    (destructor)oaDataAppDef_oaInstHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaInstHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaInstHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaInstHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaInstHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaInstHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaInstHeader_static_find_doc[] = 
"Class: oaDataAppDef_oaInstHeader, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaInstHeader* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaInstHeader|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaInstHeader* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaInstHeader|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaInstHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaInstHeaderp result= (oaDataAppDef_oaInstHeader::find(p1.Data()));
            return PyoaDataAppDef_oaInstHeader_FromoaDataAppDef_oaInstHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaInstHeaderp result= (oaDataAppDef_oaInstHeader::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaInstHeader_FromoaDataAppDef_oaInstHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaInstHeader, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaInstHeader_static_get_doc[] = 
"Class: oaDataAppDef_oaInstHeader, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaInstHeader* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaInstHeader|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaInstHeader* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaInstHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaInstHeader_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaInstHeaderp result= (oaDataAppDef_oaInstHeader::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaInstHeader_FromoaDataAppDef_oaInstHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaInstHeaderp result= (oaDataAppDef_oaInstHeader::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaInstHeader_FromoaDataAppDef_oaInstHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaInstHeader, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaInstHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaInstHeader_static_find,METH_VARARGS,oaDataAppDef_oaInstHeader_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaInstHeader_static_get,METH_VARARGS,oaDataAppDef_oaInstHeader_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaInstHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaInstHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaInstHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaInstHeader",
           (PyObject*)(&PyoaDataAppDef_oaInstHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaInstHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaInstHeader_Type.tp_dict;
    for(method=oaDataAppDef_oaInstHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaInstTerm
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaInstTerm_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaInstTerm_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaInstTermObject* self = (PyoaDataAppDef_oaInstTermObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaInstTerm)
    {
        PyParamoaDataAppDef_oaInstTerm p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaInstTerm_Convert,&p1)) {
            PyoaDataAppDef_oaInstTermObject* cself=((PyoaDataAppDef_oaInstTermObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaInstTerm, Choices are:\n"
        "    (oaDataAppDef_oaInstTerm)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaInstTerm_tp_dealloc(PyoaDataAppDef_oaInstTermObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaInstTerm_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaInstTerm value;
    int convert_status=PyoaDataAppDef_oaInstTerm_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[45];
    sprintf(buffer,"<oaDataAppDef_oaInstTerm::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaInstTerm_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaInstTerm v1;
    PyParamoaDataAppDef_oaInstTerm v2;
    int convert_status1=PyoaDataAppDef_oaInstTerm_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaInstTerm_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaInstTerm_Convert(PyObject* ob,PyParamoaDataAppDef_oaInstTerm* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaInstTerm_Check(ob)) {
        result->SetData( (oaDataAppDef_oaInstTerm**) ((PyoaDataAppDef_oaInstTermObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaInstTerm Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaInstTerm_FromoaDataAppDef_oaInstTerm(oaDataAppDef_oaInstTerm** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaInstTerm* data=*value;
        PyObject* bself = PyoaDataAppDef_oaInstTerm_Type.tp_alloc(&PyoaDataAppDef_oaInstTerm_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaInstTermObject* self = (PyoaDataAppDef_oaInstTermObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaInstTerm_FromoaDataAppDef_oaInstTerm(oaDataAppDef_oaInstTerm* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaInstTerm_Type.tp_alloc(&PyoaDataAppDef_oaInstTerm_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaInstTermObject* self = (PyoaDataAppDef_oaInstTermObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaInstTerm_get_doc[] = 
"Class: oaDataAppDef_oaInstTerm, Function: get\n"
"  Paramegers: (oaInstTerm,[oaByte])\n"
"    Calls: void get(const oaInstTerm* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaInstTerm,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaInstTerm_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaInstTerm data;
    int convert_status=PyoaDataAppDef_oaInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaInstTermObject* self=(PyoaDataAppDef_oaInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaInstTerm p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaInstTerm_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaInstTerm_getDefault_doc[] = 
"Class: oaDataAppDef_oaInstTerm, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaInstTerm_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaInstTerm data;
    int convert_status=PyoaDataAppDef_oaInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaInstTermObject* self=(PyoaDataAppDef_oaInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaInstTerm_getSize_doc[] = 
"Class: oaDataAppDef_oaInstTerm, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaInstTerm_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaInstTerm data;
    int convert_status=PyoaDataAppDef_oaInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaInstTermObject* self=(PyoaDataAppDef_oaInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaInstTerm_set_doc[] = 
"Class: oaDataAppDef_oaInstTerm, Function: set\n"
"  Paramegers: (oaInstTerm,[oaByte])\n"
"    Calls: void set(oaInstTerm* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaInstTerm,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaInstTerm_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaInstTerm data;
    int convert_status=PyoaDataAppDef_oaInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaInstTermObject* self=(PyoaDataAppDef_oaInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaInstTerm p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaInstTerm_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaInstTerm_isNull_doc[] =
"Class: oaDataAppDef_oaInstTerm, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaInstTerm_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaInstTerm data;
    int convert_status=PyoaDataAppDef_oaInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaInstTerm_assign_doc[] = 
"Class: oaDataAppDef_oaInstTerm, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaInstTerm_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaInstTerm data;
  int convert_status=PyoaDataAppDef_oaInstTerm_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaInstTerm p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaInstTerm_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaInstTerm_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaInstTerm_get,METH_VARARGS,oaDataAppDef_oaInstTerm_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaInstTerm_getDefault,METH_VARARGS,oaDataAppDef_oaInstTerm_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaInstTerm_getSize,METH_VARARGS,oaDataAppDef_oaInstTerm_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaInstTerm_set,METH_VARARGS,oaDataAppDef_oaInstTerm_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaInstTerm_tp_isNull,METH_VARARGS,oaDataAppDef_oaInstTerm_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaInstTerm_tp_assign,METH_VARARGS,oaDataAppDef_oaInstTerm_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaInstTerm_doc[] = 
"Class: oaDataAppDef_oaInstTerm\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaInstTerm)\n"
"    Calls: (const oaDataAppDef_oaInstTerm&)\n"
"    Signature: oaDataAppDef_oaInstTerm||cref-oaDataAppDef_oaInstTerm,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaInstTerm_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaInstTerm",
    sizeof(PyoaDataAppDef_oaInstTermObject),
    0,
    (destructor)oaDataAppDef_oaInstTerm_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaInstTerm_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaInstTerm_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaInstTerm_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaInstTerm_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaInstTerm_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaInstTerm_static_find_doc[] = 
"Class: oaDataAppDef_oaInstTerm, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaInstTerm* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaInstTerm|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaInstTerm* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaInstTerm|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaInstTerm_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaInstTermp result= (oaDataAppDef_oaInstTerm::find(p1.Data()));
            return PyoaDataAppDef_oaInstTerm_FromoaDataAppDef_oaInstTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaInstTermp result= (oaDataAppDef_oaInstTerm::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaInstTerm_FromoaDataAppDef_oaInstTerm(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaInstTerm, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaInstTerm_static_get_doc[] = 
"Class: oaDataAppDef_oaInstTerm, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaInstTerm* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaInstTerm|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaInstTerm* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaInstTerm|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaInstTerm_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaInstTermp result= (oaDataAppDef_oaInstTerm::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaInstTerm_FromoaDataAppDef_oaInstTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaInstTermp result= (oaDataAppDef_oaInstTerm::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaInstTerm_FromoaDataAppDef_oaInstTerm(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaInstTerm, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaInstTerm_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaInstTerm_static_find,METH_VARARGS,oaDataAppDef_oaInstTerm_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaInstTerm_static_get,METH_VARARGS,oaDataAppDef_oaInstTerm_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaInstTerm_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaInstTerm_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaInstTerm\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaInstTerm",
           (PyObject*)(&PyoaDataAppDef_oaInstTerm_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaInstTerm\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaInstTerm_Type.tp_dict;
    for(method=oaDataAppDef_oaInstTerm_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaLPPHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaLPPHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaLPPHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaLPPHeaderObject* self = (PyoaDataAppDef_oaLPPHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaLPPHeader)
    {
        PyParamoaDataAppDef_oaLPPHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaLPPHeader_Convert,&p1)) {
            PyoaDataAppDef_oaLPPHeaderObject* cself=((PyoaDataAppDef_oaLPPHeaderObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaLPPHeader, Choices are:\n"
        "    (oaDataAppDef_oaLPPHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaLPPHeader_tp_dealloc(PyoaDataAppDef_oaLPPHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaLPPHeader_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaLPPHeader value;
    int convert_status=PyoaDataAppDef_oaLPPHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[46];
    sprintf(buffer,"<oaDataAppDef_oaLPPHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaLPPHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaLPPHeader v1;
    PyParamoaDataAppDef_oaLPPHeader v2;
    int convert_status1=PyoaDataAppDef_oaLPPHeader_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaLPPHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaLPPHeader_Convert(PyObject* ob,PyParamoaDataAppDef_oaLPPHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaLPPHeader_Check(ob)) {
        result->SetData( (oaDataAppDef_oaLPPHeader**) ((PyoaDataAppDef_oaLPPHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaLPPHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaLPPHeader_FromoaDataAppDef_oaLPPHeader(oaDataAppDef_oaLPPHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaLPPHeader* data=*value;
        PyObject* bself = PyoaDataAppDef_oaLPPHeader_Type.tp_alloc(&PyoaDataAppDef_oaLPPHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaLPPHeaderObject* self = (PyoaDataAppDef_oaLPPHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaLPPHeader_FromoaDataAppDef_oaLPPHeader(oaDataAppDef_oaLPPHeader* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaLPPHeader_Type.tp_alloc(&PyoaDataAppDef_oaLPPHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaLPPHeaderObject* self = (PyoaDataAppDef_oaLPPHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaLPPHeader_get_doc[] = 
"Class: oaDataAppDef_oaLPPHeader, Function: get\n"
"  Paramegers: (oaLPPHeader,[oaByte])\n"
"    Calls: void get(const oaLPPHeader* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaLPPHeader,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaLPPHeader_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaLPPHeader data;
    int convert_status=PyoaDataAppDef_oaLPPHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaLPPHeaderObject* self=(PyoaDataAppDef_oaLPPHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaLPPHeader p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaLPPHeader_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaLPPHeader_getDefault_doc[] = 
"Class: oaDataAppDef_oaLPPHeader, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaLPPHeader_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaLPPHeader data;
    int convert_status=PyoaDataAppDef_oaLPPHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaLPPHeaderObject* self=(PyoaDataAppDef_oaLPPHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaLPPHeader_getSize_doc[] = 
"Class: oaDataAppDef_oaLPPHeader, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaLPPHeader_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaLPPHeader data;
    int convert_status=PyoaDataAppDef_oaLPPHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaLPPHeaderObject* self=(PyoaDataAppDef_oaLPPHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaLPPHeader_set_doc[] = 
"Class: oaDataAppDef_oaLPPHeader, Function: set\n"
"  Paramegers: (oaLPPHeader,[oaByte])\n"
"    Calls: void set(oaLPPHeader* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaLPPHeader,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaLPPHeader_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaLPPHeader data;
    int convert_status=PyoaDataAppDef_oaLPPHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaLPPHeaderObject* self=(PyoaDataAppDef_oaLPPHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaLPPHeader p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaLPPHeader_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaLPPHeader_isNull_doc[] =
"Class: oaDataAppDef_oaLPPHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaLPPHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaLPPHeader data;
    int convert_status=PyoaDataAppDef_oaLPPHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaLPPHeader_assign_doc[] = 
"Class: oaDataAppDef_oaLPPHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaLPPHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaLPPHeader data;
  int convert_status=PyoaDataAppDef_oaLPPHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaLPPHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaLPPHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaLPPHeader_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaLPPHeader_get,METH_VARARGS,oaDataAppDef_oaLPPHeader_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaLPPHeader_getDefault,METH_VARARGS,oaDataAppDef_oaLPPHeader_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaLPPHeader_getSize,METH_VARARGS,oaDataAppDef_oaLPPHeader_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaLPPHeader_set,METH_VARARGS,oaDataAppDef_oaLPPHeader_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaLPPHeader_tp_isNull,METH_VARARGS,oaDataAppDef_oaLPPHeader_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaLPPHeader_tp_assign,METH_VARARGS,oaDataAppDef_oaLPPHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaLPPHeader_doc[] = 
"Class: oaDataAppDef_oaLPPHeader\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaLPPHeader)\n"
"    Calls: (const oaDataAppDef_oaLPPHeader&)\n"
"    Signature: oaDataAppDef_oaLPPHeader||cref-oaDataAppDef_oaLPPHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaLPPHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaLPPHeader",
    sizeof(PyoaDataAppDef_oaLPPHeaderObject),
    0,
    (destructor)oaDataAppDef_oaLPPHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaLPPHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaLPPHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaLPPHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaLPPHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaLPPHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaLPPHeader_static_find_doc[] = 
"Class: oaDataAppDef_oaLPPHeader, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaLPPHeader* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaLPPHeader|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaLPPHeader* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaLPPHeader|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaLPPHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaLPPHeaderp result= (oaDataAppDef_oaLPPHeader::find(p1.Data()));
            return PyoaDataAppDef_oaLPPHeader_FromoaDataAppDef_oaLPPHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaLPPHeaderp result= (oaDataAppDef_oaLPPHeader::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaLPPHeader_FromoaDataAppDef_oaLPPHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaLPPHeader, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaLPPHeader_static_get_doc[] = 
"Class: oaDataAppDef_oaLPPHeader, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaLPPHeader* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaLPPHeader|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaLPPHeader* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaLPPHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaLPPHeader_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaLPPHeaderp result= (oaDataAppDef_oaLPPHeader::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaLPPHeader_FromoaDataAppDef_oaLPPHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaLPPHeaderp result= (oaDataAppDef_oaLPPHeader::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaLPPHeader_FromoaDataAppDef_oaLPPHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaLPPHeader, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaLPPHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaLPPHeader_static_find,METH_VARARGS,oaDataAppDef_oaLPPHeader_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaLPPHeader_static_get,METH_VARARGS,oaDataAppDef_oaLPPHeader_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaLPPHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaLPPHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaLPPHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaLPPHeader",
           (PyObject*)(&PyoaDataAppDef_oaLPPHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaLPPHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaLPPHeader_Type.tp_dict;
    for(method=oaDataAppDef_oaLPPHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaLayer
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaLayer_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaLayer_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaLayerObject* self = (PyoaDataAppDef_oaLayerObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaLayer)
    {
        PyParamoaDataAppDef_oaLayer p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaLayer_Convert,&p1)) {
            PyoaDataAppDef_oaLayerObject* cself=((PyoaDataAppDef_oaLayerObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaLayer, Choices are:\n"
        "    (oaDataAppDef_oaLayer)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaLayer_tp_dealloc(PyoaDataAppDef_oaLayerObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaLayer_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaLayer value;
    int convert_status=PyoaDataAppDef_oaLayer_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaDataAppDef_oaLayer::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaLayer_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaLayer v1;
    PyParamoaDataAppDef_oaLayer v2;
    int convert_status1=PyoaDataAppDef_oaLayer_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaLayer_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaLayer_Convert(PyObject* ob,PyParamoaDataAppDef_oaLayer* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaLayer_Check(ob)) {
        result->SetData( (oaDataAppDef_oaLayer**) ((PyoaDataAppDef_oaLayerObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaLayer Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaLayer_FromoaDataAppDef_oaLayer(oaDataAppDef_oaLayer** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaLayer* data=*value;
        PyObject* bself = PyoaDataAppDef_oaLayer_Type.tp_alloc(&PyoaDataAppDef_oaLayer_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaLayerObject* self = (PyoaDataAppDef_oaLayerObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaLayer_FromoaDataAppDef_oaLayer(oaDataAppDef_oaLayer* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaLayer_Type.tp_alloc(&PyoaDataAppDef_oaLayer_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaLayerObject* self = (PyoaDataAppDef_oaLayerObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaLayer_get_doc[] = 
"Class: oaDataAppDef_oaLayer, Function: get\n"
"  Paramegers: (oaLayer,[oaByte])\n"
"    Calls: void get(const oaLayer* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaLayer,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaLayer_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaLayer data;
    int convert_status=PyoaDataAppDef_oaLayer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaLayerObject* self=(PyoaDataAppDef_oaLayerObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaLayer p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaLayer_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaLayer_getDefault_doc[] = 
"Class: oaDataAppDef_oaLayer, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaLayer_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaLayer data;
    int convert_status=PyoaDataAppDef_oaLayer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaLayerObject* self=(PyoaDataAppDef_oaLayerObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaLayer_getSize_doc[] = 
"Class: oaDataAppDef_oaLayer, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaLayer_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaLayer data;
    int convert_status=PyoaDataAppDef_oaLayer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaLayerObject* self=(PyoaDataAppDef_oaLayerObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaLayer_set_doc[] = 
"Class: oaDataAppDef_oaLayer, Function: set\n"
"  Paramegers: (oaLayer,[oaByte])\n"
"    Calls: void set(oaLayer* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaLayer,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaLayer_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaLayer data;
    int convert_status=PyoaDataAppDef_oaLayer_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaLayerObject* self=(PyoaDataAppDef_oaLayerObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaLayer p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaLayer_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaLayer_isNull_doc[] =
"Class: oaDataAppDef_oaLayer, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaLayer_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaLayer data;
    int convert_status=PyoaDataAppDef_oaLayer_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaLayer_assign_doc[] = 
"Class: oaDataAppDef_oaLayer, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaLayer_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaLayer data;
  int convert_status=PyoaDataAppDef_oaLayer_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaLayer p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaLayer_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaLayer_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaLayer_get,METH_VARARGS,oaDataAppDef_oaLayer_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaLayer_getDefault,METH_VARARGS,oaDataAppDef_oaLayer_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaLayer_getSize,METH_VARARGS,oaDataAppDef_oaLayer_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaLayer_set,METH_VARARGS,oaDataAppDef_oaLayer_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaLayer_tp_isNull,METH_VARARGS,oaDataAppDef_oaLayer_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaLayer_tp_assign,METH_VARARGS,oaDataAppDef_oaLayer_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaLayer_doc[] = 
"Class: oaDataAppDef_oaLayer\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaLayer)\n"
"    Calls: (const oaDataAppDef_oaLayer&)\n"
"    Signature: oaDataAppDef_oaLayer||cref-oaDataAppDef_oaLayer,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaLayer_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaLayer",
    sizeof(PyoaDataAppDef_oaLayerObject),
    0,
    (destructor)oaDataAppDef_oaLayer_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaLayer_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaLayer_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaLayer_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaLayer_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaLayer_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaLayer_static_find_doc[] = 
"Class: oaDataAppDef_oaLayer, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaLayer* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaLayer|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaLayer* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaLayer|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaLayer_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaLayerp result= (oaDataAppDef_oaLayer::find(p1.Data()));
            return PyoaDataAppDef_oaLayer_FromoaDataAppDef_oaLayer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaLayerp result= (oaDataAppDef_oaLayer::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaLayer_FromoaDataAppDef_oaLayer(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaLayer, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaLayer_static_get_doc[] = 
"Class: oaDataAppDef_oaLayer, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaLayer* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaLayer|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaLayer* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaLayer|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaLayer_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaLayerp result= (oaDataAppDef_oaLayer::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaLayer_FromoaDataAppDef_oaLayer(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaLayerp result= (oaDataAppDef_oaLayer::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaLayer_FromoaDataAppDef_oaLayer(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaLayer, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaLayer_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaLayer_static_find,METH_VARARGS,oaDataAppDef_oaLayer_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaLayer_static_get,METH_VARARGS,oaDataAppDef_oaLayer_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaLayer_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaLayer_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaLayer\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaLayer",
           (PyObject*)(&PyoaDataAppDef_oaLayer_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaLayer\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaLayer_Type.tp_dict;
    for(method=oaDataAppDef_oaLayer_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaDataAppDef_oaLayerHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaLayerHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaDataAppDef_oaLayerHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaDataAppDef_oaLayerHeaderObject* self = (PyoaDataAppDef_oaLayerHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaDataAppDef_oaLayerHeader)
    {
        PyParamoaDataAppDef_oaLayerHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaDataAppDef_oaLayerHeader_Convert,&p1)) {
            PyoaDataAppDef_oaLayerHeaderObject* cself=((PyoaDataAppDef_oaLayerHeaderObject*)PyTuple_GetItem(args,0));
            self->data=p1.Data();
            self->value=&(self->data);
            self->size=cself->size;
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaDataAppDef_oaLayerHeader, Choices are:\n"
        "    (oaDataAppDef_oaLayerHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaDataAppDef_oaLayerHeader_tp_dealloc(PyoaDataAppDef_oaLayerHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaDataAppDef_oaLayerHeader_tp_repr(PyObject *ob)
{
    PyParamoaDataAppDef_oaLayerHeader value;
    int convert_status=PyoaDataAppDef_oaLayerHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[48];
    sprintf(buffer,"<oaDataAppDef_oaLayerHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaDataAppDef_oaLayerHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaDataAppDef_oaLayerHeader v1;
    PyParamoaDataAppDef_oaLayerHeader v2;
    int convert_status1=PyoaDataAppDef_oaLayerHeader_Convert(ob1,&v1);
    int convert_status2=PyoaDataAppDef_oaLayerHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaDataAppDef_oaLayerHeader_Convert(PyObject* ob,PyParamoaDataAppDef_oaLayerHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaDataAppDef_oaLayerHeader_Check(ob)) {
        result->SetData( (oaDataAppDef_oaLayerHeader**) ((PyoaDataAppDef_oaLayerHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaDataAppDef_oaLayerHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaLayerHeader_FromoaDataAppDef_oaLayerHeader(oaDataAppDef_oaLayerHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaDataAppDef_oaLayerHeader* data=*value;
        PyObject* bself = PyoaDataAppDef_oaLayerHeader_Type.tp_alloc(&PyoaDataAppDef_oaLayerHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaDataAppDef_oaLayerHeaderObject* self = (PyoaDataAppDef_oaLayerHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaDataAppDef_oaLayerHeader_FromoaDataAppDef_oaLayerHeader(oaDataAppDef_oaLayerHeader* data)
{
    if (data) {
       PyObject* bself = PyoaDataAppDef_oaLayerHeader_Type.tp_alloc(&PyoaDataAppDef_oaLayerHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaDataAppDef_oaLayerHeaderObject* self = (PyoaDataAppDef_oaLayerHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaLayerHeader_get_doc[] = 
"Class: oaDataAppDef_oaLayerHeader, Function: get\n"
"  Paramegers: (oaLayerHeader,[oaByte])\n"
"    Calls: void get(const oaLayerHeader* object,oaByte* value)\n"
"    Signature: get|void-void|cptr-oaLayerHeader,ptr-oaByte,\n"
"    This function fills out the given byte array with the value of this data extension. The byte array should be allocated before calling this function.\n"
"    object\n"
"    The object on which to get the value\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaLayerHeader_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaLayerHeader data;
    int convert_status=PyoaDataAppDef_oaLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaLayerHeaderObject* self=(PyoaDataAppDef_oaLayerHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaLayerHeader p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaLayerHeader_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->get(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaLayerHeader_getDefault_doc[] = 
"Class: oaDataAppDef_oaLayerHeader, Function: getDefault\n"
"  Paramegers: ([oaByte])\n"
"    Calls: void getDefault(oaByte* value) const\n"
"    Signature: getDefault|void-void|ptr-oaByte,\n"
"    This function fills out the given byte array with the default value of this data extension. The byte array should be allocated before calling this function.\n"
"    value\n"
"    The byte array to fill out with the value\n"
;

static PyObject*
oaDataAppDef_oaLayerHeader_getDefault(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaLayerHeader data;
    int convert_status=PyoaDataAppDef_oaLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaLayerHeaderObject* self=(PyoaDataAppDef_oaLayerHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaByte_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaByte_Array_Convert,&p1)) {
        if (!(data.Data()->getSize()!=p1.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->getDefault(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaLayerHeader_getSize_doc[] = 
"Class: oaDataAppDef_oaLayerHeader, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize()\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size in bytes of the value for this data extension.\n"
;

static PyObject*
oaDataAppDef_oaLayerHeader_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaLayerHeader data;
    int convert_status=PyoaDataAppDef_oaLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaLayerHeaderObject* self=(PyoaDataAppDef_oaLayerHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaLayerHeader_set_doc[] = 
"Class: oaDataAppDef_oaLayerHeader, Function: set\n"
"  Paramegers: (oaLayerHeader,[oaByte])\n"
"    Calls: void set(oaLayerHeader* object,const oaByte* value)\n"
"    Signature: set|void-void|ptr-oaLayerHeader,cptr-oaByte,\n"
"    This function sets the value of this data extension.\n"
"    object\n"
"    The object on which to set the value\n"
"    value\n"
"    The value to store on the object\n"
;

static PyObject*
oaDataAppDef_oaLayerHeader_set(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDataAppDef_oaLayerHeader data;
    int convert_status=PyoaDataAppDef_oaLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaDataAppDef_oaLayerHeaderObject* self=(PyoaDataAppDef_oaLayerHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaLayerHeader p1;
    PyParamoaByte_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaLayerHeader_Convert,&p1,
          &PyoaByte_Array_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!(data.Data()->getSize()!=p2.Len())) {
            PyErr_SetString(PyExc_TypeError,
                "number of bytes does not match oaDataAppDef::getSize");
            return NULL;
        }
        data.DataCall()->set(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaLayerHeader_isNull_doc[] =
"Class: oaDataAppDef_oaLayerHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaDataAppDef_oaLayerHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaDataAppDef_oaLayerHeader data;
    int convert_status=PyoaDataAppDef_oaLayerHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaDataAppDef_oaLayerHeader_assign_doc[] = 
"Class: oaDataAppDef_oaLayerHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaDataAppDef_oaLayerHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaDataAppDef_oaLayerHeader data;
  int convert_status=PyoaDataAppDef_oaLayerHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaDataAppDef_oaLayerHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaDataAppDef_oaLayerHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaDataAppDef_oaLayerHeader_methodlist[] = {
    {"get",(PyCFunction)oaDataAppDef_oaLayerHeader_get,METH_VARARGS,oaDataAppDef_oaLayerHeader_get_doc},
    {"getDefault",(PyCFunction)oaDataAppDef_oaLayerHeader_getDefault,METH_VARARGS,oaDataAppDef_oaLayerHeader_getDefault_doc},
    {"getSize",(PyCFunction)oaDataAppDef_oaLayerHeader_getSize,METH_VARARGS,oaDataAppDef_oaLayerHeader_getSize_doc},
    {"set",(PyCFunction)oaDataAppDef_oaLayerHeader_set,METH_VARARGS,oaDataAppDef_oaLayerHeader_set_doc},
    {"isNull",(PyCFunction)oaDataAppDef_oaLayerHeader_tp_isNull,METH_VARARGS,oaDataAppDef_oaLayerHeader_isNull_doc},
    {"assign",(PyCFunction)oaDataAppDef_oaLayerHeader_tp_assign,METH_VARARGS,oaDataAppDef_oaLayerHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaLayerHeader_doc[] = 
"Class: oaDataAppDef_oaLayerHeader\n"
"  The oaDataAppDef class implements an application-specific extension on a specified class of managed objects in a database.\n"
"  A data field is added to each object of the specified dataType when the dataType is created. The default value of the data field is NULL. When an application is created, it can use the new data field for any necessary purpose. This type of extension is useful because it allows an application-defined block of data to be associated with each object.\n"
"  Note: Since the type of data is unknown to OpenAccess, the contents are not byte swapped.\n"
"  For additional information on defining and using AppDefs, see oaAppDef and Extending the Database in the Programmer's Guide.\n"
"Constructors:\n"
"  Paramegers: (oaDataAppDef_oaLayerHeader)\n"
"    Calls: (const oaDataAppDef_oaLayerHeader&)\n"
"    Signature: oaDataAppDef_oaLayerHeader||cref-oaDataAppDef_oaLayerHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaDataAppDef_oaLayerHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaDataAppDef_oaLayerHeader",
    sizeof(PyoaDataAppDef_oaLayerHeaderObject),
    0,
    (destructor)oaDataAppDef_oaLayerHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaDataAppDef_oaLayerHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaDataAppDef_oaLayerHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaDataAppDef_oaLayerHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaDataAppDef_oaLayerHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAppDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaDataAppDef_oaLayerHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaDataAppDef_oaLayerHeader_static_find_doc[] = 
"Class: oaDataAppDef_oaLayerHeader, Function: find\n"
"  Paramegers: (oaString)\n"
"    Calls: oaDataAppDef_oaLayerHeader* find(const oaString& name)\n"
"    Signature: find|ptr-oaDataAppDef_oaLayerHeader|cref-oaString,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' if it exists.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"  Paramegers: (oaString,oaAppObjectDef)\n"
"    Calls: oaDataAppDef_oaLayerHeader* find(const oaString& name,const oaAppObjectDef* objDef)\n"
"    Signature: find|ptr-oaDataAppDef_oaLayerHeader|cref-oaString,cptr-oaAppObjectDef,\n"
"    This function returns an oaDataAppDef object with this dataType and the specified 'name' that is associated with the specified object extension 'objDef'.\n"
"    name\n"
"    The name of the oaAppDef object to look for\n"
"    objDef\n"
"    A constant pointer to the object extension\n"
;

static PyObject*
oaDataAppDef_oaLayerHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            oaDataAppDef_oaLayerHeaderp result= (oaDataAppDef_oaLayerHeader::find(p1.Data()));
            return PyoaDataAppDef_oaLayerHeader_FromoaDataAppDef_oaLayerHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaLayerHeaderp result= (oaDataAppDef_oaLayerHeader::find(p1.Data(),p2.Data()));
            return PyoaDataAppDef_oaLayerHeader_FromoaDataAppDef_oaLayerHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaLayerHeader, function: find, Choices are:\n"
        "    (oaString)\n"
        "    (oaString,oaAppObjectDef)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaDataAppDef_oaLayerHeader_static_get_doc[] = 
"Class: oaDataAppDef_oaLayerHeader, Function: get\n"
"  Paramegers: (oaString,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaLayerHeader* get(const oaString& name,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaLayerHeader|cref-oaString,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize .\n"
"    name\n"
"    The name given to the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
"  Paramegers: (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
"    Calls: oaDataAppDef_oaLayerHeader* get(const oaString& name,const oaAppObjectDef* objDef,const oaByte* defValue,oaBoolean persist)\n"
"    Signature: get|ptr-oaDataAppDef_oaLayerHeader|cref-oaString,cptr-oaAppObjectDef,simple-oaUInt4,cptr-oaByte,simple-oaBoolean,\n"
"    This function constructs an oaDataAppDef object, creating a data extension with the specified name and dataSize for the specified type of object.\n"
"    name\n"
"    The name for the oaDataAppDef object\n"
"    dataSize\n"
"    The size of each data object, in bytes\n"
"    defValue\n"
"    The default value for the extension\n"
"    objDef\n"
"    The object extension with which to associate the extension\n"
"    persist\n"
"    Saves the oaDataAppDef data in the database\n"
"    oacAppDefExists\n"
;

static PyObject*
oaDataAppDef_oaLayerHeader_static_get(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaString,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaByte_Array p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaByte_Array_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            oaDataAppDef_oaLayerHeaderp result= (oaDataAppDef_oaLayerHeader::get(p1.Data(),p2.Len(),p2.Data(),p3.Data()));
            return PyoaDataAppDef_oaLayerHeader_FromoaDataAppDef_oaLayerHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaAppObjectDef,[oaByte],oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaAppObjectDef p2;
        PyParamoaByte_Array p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaString_Convert,&p1,
              &PyoaAppObjectDef_Convert,&p2,
              &PyoaByte_Array_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaDataAppDef_oaLayerHeaderp result= (oaDataAppDef_oaLayerHeader::get(p1.Data(),p2.Data(),p3.Len(),p3.Data(),p4.Data()));
            return PyoaDataAppDef_oaLayerHeader_FromoaDataAppDef_oaLayerHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaDataAppDef_oaLayerHeader, function: get, Choices are:\n"
        "    (oaString,[oaByte],oaBoolean)\n"
        "    (oaString,oaAppObjectDef,[oaByte],oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaDataAppDef_oaLayerHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaDataAppDef_oaLayerHeader_static_find,METH_VARARGS,oaDataAppDef_oaLayerHeader_static_find_doc},
    {"static_get",(PyCFunction)oaDataAppDef_oaLayerHeader_static_get,METH_VARARGS,oaDataAppDef_oaLayerHeader_static_get_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaDataAppDef_oaLayerHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaDataAppDef_oaLayerHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaDataAppDef_oaLayerHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaDataAppDef_oaLayerHeader",
           (PyObject*)(&PyoaDataAppDef_oaLayerHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaDataAppDef_oaLayerHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaDataAppDef_oaLayerHeader_Type.tp_dict;
    for(method=oaDataAppDef_oaLayerHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}

