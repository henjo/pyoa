
/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModBusTermDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModBusTermDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModBusTermDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModBusTermDefObject* self = (PyoaModBusTermDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModBusTermDef)
    {
        PyParamoaModBusTermDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModBusTermDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModBusTermDef, Choices are:\n"
        "    (oaModBusTermDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModBusTermDef_tp_dealloc(PyoaModBusTermDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModBusTermDef_tp_repr(PyObject *ob)
{
    PyParamoaModBusTermDef value;
    int convert_status=PyoaModBusTermDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaModBusTermDef::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaScalarName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[37];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaModBusTermDef::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModBusTermDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModBusTermDef v1;
    PyParamoaModBusTermDef v2;
    int convert_status1=PyoaModBusTermDef_Convert(ob1,&v1);
    int convert_status2=PyoaModBusTermDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModBusTermDef_Convert(PyObject* ob,PyParamoaModBusTermDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaModBusTermDef_Check(ob)) {
        result->SetData( (oaModBusTermDef**) ((PyoaModBusTermDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModBusTermDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModBusTermDef_FromoaModBusTermDef(oaModBusTermDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaModBusTermDef* data=*value;
        PyObject* bself = PyoaModBusTermDef_Type.tp_alloc(&PyoaModBusTermDef_Type,0);
        if (bself == NULL) return bself;
        PyoaModBusTermDefObject* self = (PyoaModBusTermDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaModBusTermDef_FromoaModBusTermDef(oaModBusTermDef* data)
{
    if (data) {
       PyObject* bself = PyoaModBusTermDef_Type.tp_alloc(&PyoaModBusTermDef_Type,0);
       if (bself == NULL) return bself;
       PyoaModBusTermDefObject* self = (PyoaModBusTermDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModBusTermDef_destroy_doc[] = 
"Class: oaModBusTermDef, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function destroys this oaModBusTermDef, removing it from the database. An exception is thrown if the oaModBusTermDef is implicit or if there are still oaModBusTerms associated with it.\n"
"    oacCannotDestroyImplicitBusTermDef\n"
"    oacCannotDestroyBusTermDefWithTerms\n"
;

static PyObject*
oaModBusTermDef_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModBusTermDef data;
    int convert_status=PyoaModBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModBusTermDefObject* self=(PyoaModBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModBusTermDef_getBitOrder_doc[] = 
"Class: oaModBusTermDef, Function: getBitOrder\n"
"  Paramegers: ()\n"
"    Calls: oaBitOrder getBitOrder() const\n"
"    Signature: getBitOrder|simple-oaBitOrder|\n"
"    BrowseData: 1\n"
"    This function returns the bitOrder associated with this oaModBusTermDef object.\n"
;

static PyObject*
oaModBusTermDef_getBitOrder(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModBusTermDef data;
    int convert_status=PyoaModBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModBusTermDefObject* self=(PyoaModBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBitOrder* result= new oaBitOrder(data.DataCall()->getBitOrder());
        return PyoaBitOrder_FromoaBitOrder(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModBusTermDef_getBusTermBits_doc[] = 
"Class: oaModBusTermDef, Function: getBusTermBits\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaModBusTermBit_oaModBusTermDef getBusTermBits() const\n"
"    Signature: getBusTermBits|simple-oaCollection_oaModBusTermBit_oaModBusTermDef|\n"
"    BrowseData: 1\n"
"    This function returns a collection of busTermBits in this busTermDef.\n"
;

static PyObject*
oaModBusTermDef_getBusTermBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModBusTermDef data;
    int convert_status=PyoaModBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModBusTermDefObject* self=(PyoaModBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaModBusTermBit_oaModBusTermDef* result= new oaCollection_oaModBusTermBit_oaModBusTermDef(data.DataCall()->getBusTermBits());
        return PyoaCollection_oaModBusTermBit_oaModBusTermDef_FromoaCollection_oaModBusTermBit_oaModBusTermDef(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModBusTermDef_getBusTermBitsIter_doc[] = 
"Class: oaModBusTermDef, Function: getBusTermBitsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaModBusTermBit getBusTermBitsIter() const\n"
"    Signature: getBusTermBitsIter|simple-oaIter_oaModBusTermBit|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of busTermBits in this busTermDef.\n"
;

static PyObject*
oaModBusTermDef_getBusTermBitsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModBusTermDef data;
    int convert_status=PyoaModBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModBusTermDefObject* self=(PyoaModBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaModBusTermBit* result= new oaIter_oaModBusTermBit(data.DataCall()->getBusTermBits());
        return PyoaIter_oaModBusTermBit_FromoaIter_oaModBusTermBit(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModBusTermDef_getBusTerms_doc[] = 
"Class: oaModBusTermDef, Function: getBusTerms\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaModBusTerm_oaModBusTermDef getBusTerms() const\n"
"    Signature: getBusTerms|simple-oaCollection_oaModBusTerm_oaModBusTermDef|\n"
"    BrowseData: 1\n"
"    This function returns a collection of busTerms in this busTermDef.\n"
;

static PyObject*
oaModBusTermDef_getBusTerms(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModBusTermDef data;
    int convert_status=PyoaModBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModBusTermDefObject* self=(PyoaModBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaModBusTerm_oaModBusTermDef* result= new oaCollection_oaModBusTerm_oaModBusTermDef(data.DataCall()->getBusTerms());
        return PyoaCollection_oaModBusTerm_oaModBusTermDef_FromoaCollection_oaModBusTerm_oaModBusTermDef(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModBusTermDef_getBusTermsIter_doc[] = 
"Class: oaModBusTermDef, Function: getBusTermsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaModBusTerm getBusTermsIter() const\n"
"    Signature: getBusTermsIter|simple-oaIter_oaModBusTerm|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of busTerms in this busTermDef.\n"
;

static PyObject*
oaModBusTermDef_getBusTermsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModBusTermDef data;
    int convert_status=PyoaModBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModBusTermDefObject* self=(PyoaModBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaModBusTerm* result= new oaIter_oaModBusTerm(data.DataCall()->getBusTerms());
        return PyoaIter_oaModBusTerm_FromoaIter_oaModBusTerm(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModBusTermDef_getMaxIndex_doc[] = 
"Class: oaModBusTermDef, Function: getMaxIndex\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getMaxIndex() const\n"
"    Signature: getMaxIndex|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the largest bit number in use for this oaModBusTermDef object. This is the largest index used across all oaModBusTerms associated with this oaModBusTermDef object.\n"
;

static PyObject*
oaModBusTermDef_getMaxIndex(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModBusTermDef data;
    int convert_status=PyoaModBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModBusTermDefObject* self=(PyoaModBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getMaxIndex());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModBusTermDef_getMinIndex_doc[] = 
"Class: oaModBusTermDef, Function: getMinIndex\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getMinIndex() const\n"
"    Signature: getMinIndex|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the smallest bit number in use for this oaModBusTermDef object. This is the smallest index used across all oaModBusTerms associated with this oaOccBusTermDef object.\n"
;

static PyObject*
oaModBusTermDef_getMinIndex(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModBusTermDef data;
    int convert_status=PyoaModBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModBusTermDefObject* self=(PyoaModBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getMinIndex());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModBusTermDef_getName_doc[] = 
"Class: oaModBusTermDef, Function: getName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getName(oaScalarName& name) const\n"
"    Signature: getName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the name of this oaModBusTermDef object.\n"
"    name\n"
"    The scalar name in which to return the name of this oaModBusTermDef\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the name string of this oaModBusTermDef in the specified nameSpace.\n"
"    ns\n"
"    The nameSpace to use when getting the name string\n"
"    name\n"
"    Returns the string name of this oaModBusTermDef\n"
;

static PyObject*
oaModBusTermDef_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModBusTermDef data;
    int convert_status=PyoaModBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModBusTermDefObject* self=(PyoaModBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModBusTermDef, function: getName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModBusTermDef_getNumBits_doc[] = 
"Class: oaModBusTermDef, Function: getNumBits\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumBits() const\n"
"    Signature: getNumBits|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of bits covered by the busses in this oaModBusTermDef. The number of bits is equal to abs(maxIndex - minIndex) + 1; it is not necessarily the number of busTermBits present in this busTermDef. To get the number of busTermBits in this busTermDef, use oaModBusTermDef::getBusTermBits() .getCount() .\n"
;

static PyObject*
oaModBusTermDef_getNumBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModBusTermDef data;
    int convert_status=PyoaModBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModBusTermDefObject* self=(PyoaModBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumBits());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModBusTermDef_isImplicit_doc[] = 
"Class: oaModBusTermDef, Function: isImplicit\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isImplicit() const\n"
"    Signature: isImplicit|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether this oaModBusTermDef was implicitly created or not.\n"
;

static PyObject*
oaModBusTermDef_isImplicit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModBusTermDef data;
    int convert_status=PyoaModBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModBusTermDefObject* self=(PyoaModBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isImplicit());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModBusTermDef_setBitOrder_doc[] = 
"Class: oaModBusTermDef, Function: setBitOrder\n"
"  Paramegers: (oaBitOrder)\n"
"    Calls: void setBitOrder(oaBitOrder order)\n"
"    Signature: setBitOrder|void-void|simple-oaBitOrder,\n"
"    This function changes the bitOrder value associated with the oaModBusTermDef. An exception is thrown if this busTermDef was implicitly created.\n"
"    order\n"
"    The new bitOrder value for this busTermDef\n"
"    oacBitOrderBusTermDefImplicit\n"
;

static PyObject*
oaModBusTermDef_setBitOrder(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModBusTermDef data;
    int convert_status=PyoaModBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModBusTermDefObject* self=(PyoaModBusTermDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBitOrder p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBitOrder_Convert,&p1)) {
        data.DataCall()->setBitOrder(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModBusTermDef_isNull_doc[] =
"Class: oaModBusTermDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaModBusTermDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaModBusTermDef data;
    int convert_status=PyoaModBusTermDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaModBusTermDef_assign_doc[] = 
"Class: oaModBusTermDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModBusTermDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModBusTermDef data;
  int convert_status=PyoaModBusTermDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModBusTermDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModBusTermDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModBusTermDef_methodlist[] = {
    {"destroy",(PyCFunction)oaModBusTermDef_destroy,METH_VARARGS,oaModBusTermDef_destroy_doc},
    {"getBitOrder",(PyCFunction)oaModBusTermDef_getBitOrder,METH_VARARGS,oaModBusTermDef_getBitOrder_doc},
    {"getBusTermBits",(PyCFunction)oaModBusTermDef_getBusTermBits,METH_VARARGS,oaModBusTermDef_getBusTermBits_doc},
    {"getBusTermBitsIter",(PyCFunction)oaModBusTermDef_getBusTermBitsIter,METH_VARARGS,oaModBusTermDef_getBusTermBitsIter_doc},
    {"getBusTerms",(PyCFunction)oaModBusTermDef_getBusTerms,METH_VARARGS,oaModBusTermDef_getBusTerms_doc},
    {"getBusTermsIter",(PyCFunction)oaModBusTermDef_getBusTermsIter,METH_VARARGS,oaModBusTermDef_getBusTermsIter_doc},
    {"getMaxIndex",(PyCFunction)oaModBusTermDef_getMaxIndex,METH_VARARGS,oaModBusTermDef_getMaxIndex_doc},
    {"getMinIndex",(PyCFunction)oaModBusTermDef_getMinIndex,METH_VARARGS,oaModBusTermDef_getMinIndex_doc},
    {"getName",(PyCFunction)oaModBusTermDef_getName,METH_VARARGS,oaModBusTermDef_getName_doc},
    {"getNumBits",(PyCFunction)oaModBusTermDef_getNumBits,METH_VARARGS,oaModBusTermDef_getNumBits_doc},
    {"isImplicit",(PyCFunction)oaModBusTermDef_isImplicit,METH_VARARGS,oaModBusTermDef_isImplicit_doc},
    {"setBitOrder",(PyCFunction)oaModBusTermDef_setBitOrder,METH_VARARGS,oaModBusTermDef_setBitOrder_doc},
    {"isNull",(PyCFunction)oaModBusTermDef_tp_isNull,METH_VARARGS,oaModBusTermDef_isNull_doc},
    {"assign",(PyCFunction)oaModBusTermDef_tp_assign,METH_VARARGS,oaModBusTermDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModBusTermDef_doc[] = 
"Class: oaModBusTermDef\n"
"  The oaModBusTermDef class defines an object that manages all oaModBusTerms with the same base name in the module domain. An oaModBusTermDef also tracks the least significant and most significant bits of all of its oaModBusTerms, as well as all of the corresponding oaModBusTermBits.\n"
"  A bus definition can be 'sparse' (have missing bits). Busses do not have to start or end at zero. For example, a<22:25> is a legal bus name. Bus indexes must be non-negative.\n"
"  An oaModBusTermDef is automatically created if necessary whenever applications create oaModBusTerms. Implicitly created oaModBusTermDefs have no bitOrder. Applications may explicitly create an oaModBusTermDef in order to specify that it has a specific bitOrder.\n"
"  Implicitly created busTerm definitions are automatically destroyed when the last busTerm with the same base name is destroyed. Explicitly created busTerm definitions must be explicitly destroyed.\n"
"  oaModBusTermDef, oaOccBusTermDef , and oaBusTermDef each manage the bus terminals on a different kind of master, where in each case the master represents a level of hierarchy in the design.\n"
"  For oaModBusTermDef, the master is an oaModule , and each module in a design will have a set of zero or more modBusTermDefs. For oaOccBusTerm , the master is an oaOccurrence .\n"
"  For oaBusTermDef , the master is an oaBlock , and the top block for the design will have a set of zero or more modBusTermDefs. Typically, many of the oaBusTermDefs on the top oaBlock have a corresponding oaModBusTermDef on the top oaModule . All of the oaBusTerms on the top oaBlock have a corresponding oaOccBusTerm on the top oaOccurrence .\n"
"  OpenAccess requires a consistent definition of bus terminals shared between the top module and the top block in a design. When an oaBusTerm has been created that is not visible in the module domain, it is not possible to create an oaModBusTerm that uses the same base name.\n"
"Constructors:\n"
"  Paramegers: (oaModBusTermDef)\n"
"    Calls: (const oaModBusTermDef&)\n"
"    Signature: oaModBusTermDef||cref-oaModBusTermDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModBusTermDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModBusTermDef",
    sizeof(PyoaModBusTermDefObject),
    0,
    (destructor)oaModBusTermDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModBusTermDef_tp_compare,	/* tp_compare */
    (reprfunc)oaModBusTermDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModBusTermDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaModBusTermDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaModObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModBusTermDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModBusTermDef_static_create_doc[] = 
"Class: oaModBusTermDef, Function: create\n"
"  Paramegers: (oaModule,oaScalarName,oaBitOrder)\n"
"    Calls: oaModBusTermDef* create(const oaModule* module,const oaScalarName& name,oaBitOrder order)\n"
"    Signature: create|ptr-oaModBusTermDef|cptr-oaModule,cref-oaScalarName,simple-oaBitOrder,\n"
"    This function creates an oaModBusTermDef in the specified block with the given base name and bit order. An exception is thrown if an oaModBusTermDef already exists with the specified name . Explicitly creating an oaModBusTermDef also means that the oaModBusTermDef be explicitly destroyed.\n"
"    module\n"
"    The module to create the oaModBusTermDef object in\n"
"    name\n"
"    The base name for the oaModBusTermDef\n"
"    order\n"
"    The bit order for the oaModBusTermDef\n"
"    oacBusTermDefAlreadyExists\n"
;

static PyObject*
oaModBusTermDef_static_create(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule p1;
    PyParamoaScalarName p2;
    PyParamoaBitOrder p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaModule_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaBitOrder_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaModBusTermDefp result= (oaModBusTermDef::create(p1.Data(),p2.Data(),p3.Data()));
        return PyoaModBusTermDef_FromoaModBusTermDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModBusTermDef_static_find_doc[] = 
"Class: oaModBusTermDef, Function: find\n"
"  Paramegers: (oaModule,oaScalarName)\n"
"    Calls: oaModBusTermDef* find(const oaModule* module,const oaScalarName& name)\n"
"    Signature: find|ptr-oaModBusTermDef|cptr-oaModule,cref-oaScalarName,\n"
"    This function searches the specified design for a busTermDef with the specified name. The busTermDef is returned if found. Otherwise, NULL is returned.\n"
;

static PyObject*
oaModBusTermDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaModule_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaModBusTermDefp result= (oaModBusTermDef::find(p1.Data(),p2.Data()));
        return PyoaModBusTermDef_FromoaModBusTermDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaModBusTermDef_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaModBusTermDef_static_create,METH_VARARGS,oaModBusTermDef_static_create_doc},
    {"static_find",(PyCFunction)oaModBusTermDef_static_find,METH_VARARGS,oaModBusTermDef_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModBusTermDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModBusTermDef_Type)<0) {
      printf("** PyType_Ready failed for: oaModBusTermDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModBusTermDef",
           (PyObject*)(&PyoaModBusTermDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModBusTermDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaModBusTermDef_Type.tp_dict;
    for(method=oaModBusTermDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModConnectDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModConnectDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModConnectDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModConnectDefObject* self = (PyoaModConnectDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModConnectDef)
    {
        PyParamoaModConnectDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModConnectDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModConnectDef, Choices are:\n"
        "    (oaModConnectDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModConnectDef_tp_dealloc(PyoaModConnectDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModConnectDef_tp_repr(PyObject *ob)
{
    PyParamoaModConnectDef value;
    int convert_status=PyoaModConnectDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[37];
    sprintf(buffer,"<oaModConnectDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModConnectDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModConnectDef v1;
    PyParamoaModConnectDef v2;
    int convert_status1=PyoaModConnectDef_Convert(ob1,&v1);
    int convert_status2=PyoaModConnectDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModConnectDef_Convert(PyObject* ob,PyParamoaModConnectDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaModConnectDef_Check(ob)) {
        result->SetData( (oaModConnectDef**) ((PyoaModConnectDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModConnectDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModConnectDef_FromoaModConnectDef(oaModConnectDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaModConnectDef* data=*value;
        if (data->getType()==oacModNetConnectDefType) return PyoaModNetConnectDef_FromoaModNetConnectDef((oaModNetConnectDef**)value,borrow,lock);
        if (data->getType()==oacModTermConnectDefType) return PyoaModTermConnectDef_FromoaModTermConnectDef((oaModTermConnectDef**)value,borrow,lock);
        PyObject* bself = PyoaModConnectDef_Type.tp_alloc(&PyoaModConnectDef_Type,0);
        if (bself == NULL) return bself;
        PyoaModConnectDefObject* self = (PyoaModConnectDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaModConnectDef_FromoaModConnectDef(oaModConnectDef* data)
{
    if (data) {
        if (data->getType()==oacModNetConnectDefType) return PyoaModNetConnectDef_FromoaModNetConnectDef((oaModNetConnectDef*)data);
        if (data->getType()==oacModTermConnectDefType) return PyoaModTermConnectDef_FromoaModTermConnectDef((oaModTermConnectDef*)data);
       PyObject* bself = PyoaModConnectDef_Type.tp_alloc(&PyoaModConnectDef_Type,0);
       if (bself == NULL) return bself;
       PyoaModConnectDefObject* self = (PyoaModConnectDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModConnectDef_destroy_doc[] = 
"Class: oaModConnectDef, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function destroys this connection definiton.\n"
;

static PyObject*
oaModConnectDef_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModConnectDef data;
    int convert_status=PyoaModConnectDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModConnectDefObject* self=(PyoaModConnectDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModConnectDef_getAssignmentDef_doc[] = 
"Class: oaModConnectDef, Function: getAssignmentDef\n"
"  Paramegers: (oaAssignmentDef)\n"
"    Calls: void getAssignmentDef(oaAssignmentDef& assignmentDef) const\n"
"    Signature: getAssignmentDef|void-void|ref-oaAssignmentDef,\n"
"    BrowseData: 0,oaAssignmentDef\n"
"    This function returns the connection definition of this oaModConnectDef in the specified assignmentDef .\n"
;

static PyObject*
oaModConnectDef_getAssignmentDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModConnectDef data;
    int convert_status=PyoaModConnectDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModConnectDefObject* self=(PyoaModConnectDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaAssignmentDef p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaAssignmentDef_Convert,&p1)) {
        data.DataCall()->getAssignmentDef(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModConnectDef_isNull_doc[] =
"Class: oaModConnectDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaModConnectDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaModConnectDef data;
    int convert_status=PyoaModConnectDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaModConnectDef_assign_doc[] = 
"Class: oaModConnectDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModConnectDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModConnectDef data;
  int convert_status=PyoaModConnectDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModConnectDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModConnectDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModConnectDef_methodlist[] = {
    {"destroy",(PyCFunction)oaModConnectDef_destroy,METH_VARARGS,oaModConnectDef_destroy_doc},
    {"getAssignmentDef",(PyCFunction)oaModConnectDef_getAssignmentDef,METH_VARARGS,oaModConnectDef_getAssignmentDef_doc},
    {"isNull",(PyCFunction)oaModConnectDef_tp_isNull,METH_VARARGS,oaModConnectDef_isNull_doc},
    {"assign",(PyCFunction)oaModConnectDef_tp_assign,METH_VARARGS,oaModConnectDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModConnectDef_doc[] = 
"Class: oaModConnectDef\n"
"  The oaModConnectDef class is an abstract base for both terminal and net connection definitions in the module domain. A connection definition associates an assignment definition (defined by an oaAssignmentDef ) with either a net or a terminal.\n"
"  The oaModConnectDef classes are used to allow the actual connection of a ModNet or a ModTerm to be specified by a parent instance in the design hierarchy. That specification is done by creating an oaModAssignment object. This is primarily used to handle multiple power supplies and substrate connections.\n"
"  The usage of oaModConnectDefs and oaModAssignments exactly parallels of the usage of oaConnectDef and oaAssignment objects in the block domain. See oaConnectDef for more information.\n"
"  The oaModConnectDef class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaModConnectDef)\n"
"    Calls: (const oaModConnectDef&)\n"
"    Signature: oaModConnectDef||cref-oaModConnectDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModConnectDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModConnectDef",
    sizeof(PyoaModConnectDefObject),
    0,
    (destructor)oaModConnectDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModConnectDef_tp_compare,	/* tp_compare */
    (reprfunc)oaModConnectDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModConnectDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaModConnectDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaModObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModConnectDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModConnectDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModConnectDef_Type)<0) {
      printf("** PyType_Ready failed for: oaModConnectDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModConnectDef",
           (PyObject*)(&PyoaModConnectDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModConnectDef\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModDesignInst
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModDesignInst_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModDesignInst_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModDesignInstObject* self = (PyoaModDesignInstObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModDesignInst)
    {
        PyParamoaModDesignInst p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModDesignInst_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModDesignInst, Choices are:\n"
        "    (oaModDesignInst)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModDesignInst_tp_dealloc(PyoaModDesignInstObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModDesignInst_tp_repr(PyObject *ob)
{
    PyParamoaModDesignInst value;
    int convert_status=PyoaModDesignInst_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaModDesignInst::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaSimpleName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[37];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaModDesignInst::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModDesignInst_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModDesignInst v1;
    PyParamoaModDesignInst v2;
    int convert_status1=PyoaModDesignInst_Convert(ob1,&v1);
    int convert_status2=PyoaModDesignInst_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModDesignInst_Convert(PyObject* ob,PyParamoaModDesignInst* result)
{
    if (ob == NULL) return 1;
    if (PyoaModDesignInst_Check(ob)) {
        result->SetData( (oaModDesignInst**) ((PyoaModDesignInstObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModDesignInst Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModDesignInst_FromoaModDesignInst(oaModDesignInst** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaModDesignInst* data=*value;
        if (data->isModBitInst()) return PyoaModBitInst_FromoaModBitInst((oaModBitInst**)value,borrow,lock);
        if (data->getType()==oacModVectorInstType) return PyoaModVectorInst_FromoaModVectorInst((oaModVectorInst**)value,borrow,lock);
        PyObject* bself = PyoaModDesignInst_Type.tp_alloc(&PyoaModDesignInst_Type,0);
        if (bself == NULL) return bself;
        PyoaModDesignInstObject* self = (PyoaModDesignInstObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaModDesignInst_FromoaModDesignInst(oaModDesignInst* data)
{
    if (data) {
        if (data->isModBitInst()) return PyoaModBitInst_FromoaModBitInst((oaModBitInst*)data);
        if (data->getType()==oacModVectorInstType) return PyoaModVectorInst_FromoaModVectorInst((oaModVectorInst*)data);
       PyObject* bself = PyoaModDesignInst_Type.tp_alloc(&PyoaModDesignInst_Type,0);
       if (bself == NULL) return bself;
       PyoaModDesignInstObject* self = (PyoaModDesignInstObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModDesignInst_findParam_doc[] = 
"Class: oaModDesignInst, Function: findParam\n"
"  Paramegers: (oaString,oaParam)\n"
"    Calls: oaBoolean findParam(const oaString& name,oaParam& param)\n"
"    Signature: findParam|simple-oaBoolean|cref-oaString,ref-oaParam,\n"
"    This function searches the parameter list of this instance for a parameter with the specified name . If found, it fills out param with the appropriate attributes and returns true. Otherwise, the function returns false. Only Pcell instances have parameters.\n"
"    name\n"
"    The parameter name to find\n"
"    param\n"
"    The parameter class to fill out if the parameter is found\n"
;

static PyObject*
oaModDesignInst_findParam(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModDesignInst data;
    int convert_status=PyoaModDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModDesignInstObject* self=(PyoaModDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaString p1;
    PyParamoaParam p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaString_Convert,&p1,
          &PyoaParam_Convert,&p2)) {
        oaBoolean result= (data.DataCall()->findParam(p1.Data(),p2.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModDesignInst_getCellName_doc[] = 
"Class: oaModDesignInst, Function: getCellName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getCellName(oaScalarName& cellName) const\n"
"    Signature: getCellName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the cell name for the master design referenced by this instance.\n"
"    cellName\n"
"    The name of the cell for the master design\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getCellName(const oaNameSpace& ns,oaString& cellName) const\n"
"    Signature: getCellName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the cell name for the master design referenced by this instance in the namespace specified.\n"
"    ns\n"
"    The namespace for the cell name\n"
"    cellName\n"
"    The cell name for the master design\n"
;

static PyObject*
oaModDesignInst_getCellName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModDesignInst data;
    int convert_status=PyoaModDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModDesignInstObject* self=(PyoaModDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getCellName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getCellName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModDesignInst, function: getCellName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModDesignInst_getHeader_doc[] = 
"Class: oaModDesignInst, Function: getHeader\n"
"  Paramegers: ()\n"
"    Calls: oaModInstHeader* getHeader() const\n"
"    Signature: getHeader|ptr-oaModInstHeader|\n"
"    BrowseData: 1\n"
"    This function returns the instHeader associated with this instance. The instHeader is a collection of the attributes that are common to all instances of a particular master. For Pcell instances, this function returns the subheader.\n"
"    The pointer to the instance header\n"
;

static PyObject*
oaModDesignInst_getHeader(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModDesignInst data;
    int convert_status=PyoaModDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModDesignInstObject* self=(PyoaModDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModInstHeaderp result= (data.DataCall()->getHeader());
        return PyoaModInstHeader_FromoaModInstHeader(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModDesignInst_getLibName_doc[] = 
"Class: oaModDesignInst, Function: getLibName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getLibName(oaScalarName& libName) const\n"
"    Signature: getLibName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the library name for the master design referenced by this instance.\n"
"    libName\n"
"    The name of the library for the master design\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getLibName(const oaNameSpace& ns,oaString& libName) const\n"
"    Signature: getLibName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the library name for the master design referenced by this instance in the namespace specified.\n"
"    ns\n"
"    The namespace for the library name\n"
"    libName\n"
"    The library name for the master design\n"
;

static PyObject*
oaModDesignInst_getLibName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModDesignInst data;
    int convert_status=PyoaModDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModDesignInstObject* self=(PyoaModDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getLibName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getLibName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModDesignInst, function: getLibName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModDesignInst_getMaster_doc[] = 
"Class: oaModDesignInst, Function: getMaster\n"
"  Paramegers: ()\n"
"    Calls: oaDesign* getMaster() const\n"
"    Signature: getMaster|ptr-oaDesign|\n"
"    BrowseData: 1\n"
"    This function attempts to return the master associated with this instance. If the instance is not previously bound, it attempts to open the master and bind this instance. If the instance cannot be bound, NULL is returned.\n"
;

static PyObject*
oaModDesignInst_getMaster(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModDesignInst data;
    int convert_status=PyoaModDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModDesignInstObject* self=(PyoaModDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaDesignp result= (data.DataCall()->getMaster());
        return PyoaDesign_FromoaDesign(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModDesignInst_getParams_doc[] = 
"Class: oaModDesignInst, Function: getParams\n"
"  Paramegers: (oaParamArray)\n"
"    Calls: void getParams(oaParamArray& params) const\n"
"    Signature: getParams|void-void|ref-oaParamArray,\n"
"    BrowseData: 0,oaParamArray\n"
"    This function fills out params with the parameters of this instance. Only Pcell instances have parameters. This call only returns the parameters that were specified during creation or through calls to setParams() . If invoked on an inst that is not a Pcell or if no parameter is specified for the instance, the returned params paramArray will have a numParams of zero.\n"
;

static PyObject*
oaModDesignInst_getParams(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModDesignInst data;
    int convert_status=PyoaModDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModDesignInstObject* self=(PyoaModDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaParamArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaParamArray_Convert,&p1)) {
        data.DataCall()->getParams(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModDesignInst_getViewName_doc[] = 
"Class: oaModDesignInst, Function: getViewName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getViewName(oaScalarName& viewName) const\n"
"    Signature: getViewName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the view name for the master design referenced by this instance.\n"
"    viewName\n"
"    The name of the view for the master design\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getViewName(const oaNameSpace& ns,oaString& viewName) const\n"
"    Signature: getViewName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the view name for the master design referenced by this instance in the namespace specified.\n"
"    ns\n"
"    The namespace for the view name\n"
"    viewName\n"
"    The view name for the master design\n"
;

static PyObject*
oaModDesignInst_getViewName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModDesignInst data;
    int convert_status=PyoaModDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModDesignInstObject* self=(PyoaModDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getViewName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getViewName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModDesignInst, function: getViewName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModDesignInst_setMaster_doc[] = 
"Class: oaModDesignInst, Function: setMaster\n"
"  Paramegers: (oaDesign)\n"
"    Calls: void setMaster(oaDesign* master)\n"
"    Signature: setMaster|void-void|ptr-oaDesign,\n"
"    This function sets the master of this instance. This version sets the master to the specified design.\n"
"    master\n"
"    The pointer to the new instance master\n"
"    oacInvalidSuperMaster\n"
"  Paramegers: (oaScalarName,oaScalarName,oaScalarName)\n"
"    Calls: void setMaster(const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName)\n"
"    Signature: setMaster|void-void|cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,\n"
"    This function sets the master of this instance. This version sets the master to the design specified by the specified library, cell, and view names and does not force the master to open.\n"
"    libName\n"
"    The library name for the new instance master\n"
"    cellName\n"
"    The cell name for the new instance master\n"
"    viewName\n"
"    The view name for the new instance master\n"
;

static PyObject*
oaModDesignInst_setMaster(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModDesignInst data;
    int convert_status=PyoaModDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModDesignInstObject* self=(PyoaModDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaDesign)
    {
        PyParamoaDesign p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDesign_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            data.DataCall()->setMaster(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaScalarName,oaScalarName,oaScalarName)
    {
        PyParamoaScalarName p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaScalarName_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3)) {
            data.DataCall()->setMaster(p1.Data(),p2.Data(),p3.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModDesignInst, function: setMaster, Choices are:\n"
        "    (oaDesign)\n"
        "    (oaScalarName,oaScalarName,oaScalarName)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModDesignInst_setParams_doc[] = 
"Class: oaModDesignInst, Function: setParams\n"
"  Paramegers: (oaParamArray)\n"
"    Calls: void setParams(const oaParamArray& params)\n"
"    Signature: setParams|void-void|cref-oaParamArray,\n"
"    This function sets the parameters of this instance to the specified list. If this instance already has parameters attached to it, the existing parameters are replaced.\n"
"    The oaParamArray is any subset of the master's oaParamArray definition. Any parameter omitted is given the default value from the master.\n"
"    params\n"
"    The array of parameters to apply to the instance\n"
"    oacInvalidPcellMaster\n"
"    oacPcellMasterNotBound\n"
;

static PyObject*
oaModDesignInst_setParams(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModDesignInst data;
    int convert_status=PyoaModDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModDesignInstObject* self=(PyoaModDesignInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaParamArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaParamArray_Convert,&p1)) {
        data.DataCall()->setParams(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModDesignInst_isNull_doc[] =
"Class: oaModDesignInst, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaModDesignInst_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaModDesignInst data;
    int convert_status=PyoaModDesignInst_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaModDesignInst_assign_doc[] = 
"Class: oaModDesignInst, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModDesignInst_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModDesignInst data;
  int convert_status=PyoaModDesignInst_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModDesignInst p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModDesignInst_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModDesignInst_methodlist[] = {
    {"findParam",(PyCFunction)oaModDesignInst_findParam,METH_VARARGS,oaModDesignInst_findParam_doc},
    {"getCellName",(PyCFunction)oaModDesignInst_getCellName,METH_VARARGS,oaModDesignInst_getCellName_doc},
    {"getHeader",(PyCFunction)oaModDesignInst_getHeader,METH_VARARGS,oaModDesignInst_getHeader_doc},
    {"getLibName",(PyCFunction)oaModDesignInst_getLibName,METH_VARARGS,oaModDesignInst_getLibName_doc},
    {"getMaster",(PyCFunction)oaModDesignInst_getMaster,METH_VARARGS,oaModDesignInst_getMaster_doc},
    {"getParams",(PyCFunction)oaModDesignInst_getParams,METH_VARARGS,oaModDesignInst_getParams_doc},
    {"getViewName",(PyCFunction)oaModDesignInst_getViewName,METH_VARARGS,oaModDesignInst_getViewName_doc},
    {"setMaster",(PyCFunction)oaModDesignInst_setMaster,METH_VARARGS,oaModDesignInst_setMaster_doc},
    {"setParams",(PyCFunction)oaModDesignInst_setParams,METH_VARARGS,oaModDesignInst_setParams_doc},
    {"isNull",(PyCFunction)oaModDesignInst_tp_isNull,METH_VARARGS,oaModDesignInst_isNull_doc},
    {"assign",(PyCFunction)oaModDesignInst_tp_assign,METH_VARARGS,oaModDesignInst_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModDesignInst_doc[] = 
"Class: oaModDesignInst\n"
"  The oaModDesignInst class is a base for instances of a design master.\n"
"  oaModDesignInst objects are always in the module domain.\n"
"Constructors:\n"
"  Paramegers: (oaModDesignInst)\n"
"    Calls: (const oaModDesignInst&)\n"
"    Signature: oaModDesignInst||cref-oaModDesignInst,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModDesignInst_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModDesignInst",
    sizeof(PyoaModDesignInstObject),
    0,
    (destructor)oaModDesignInst_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModDesignInst_tp_compare,	/* tp_compare */
    (reprfunc)oaModDesignInst_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModDesignInst_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaModDesignInst_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaModInst_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModDesignInst_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModDesignInst_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModDesignInst_Type)<0) {
      printf("** PyType_Ready failed for: oaModDesignInst\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModDesignInst",
           (PyObject*)(&PyoaModDesignInst_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModDesignInst\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModInst
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModInst_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModInst_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModInstObject* self = (PyoaModInstObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModInst)
    {
        PyParamoaModInst p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModInst_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModInst, Choices are:\n"
        "    (oaModInst)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModInst_tp_dealloc(PyoaModInstObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModInst_tp_repr(PyObject *ob)
{
    PyParamoaModInst value;
    int convert_status=PyoaModInst_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaModInst::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaSimpleName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[31];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaModInst::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModInst_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModInst v1;
    PyParamoaModInst v2;
    int convert_status1=PyoaModInst_Convert(ob1,&v1);
    int convert_status2=PyoaModInst_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModInst_Convert(PyObject* ob,PyParamoaModInst* result)
{
    if (ob == NULL) return 1;
    if (PyoaModInst_Check(ob)) {
        result->SetData( (oaModInst**) ((PyoaModInstObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModInst Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModInst_FromoaModInst(oaModInst** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaModInst* data=*value;
        if (data->isModDesignInst()) return PyoaModDesignInst_FromoaModDesignInst((oaModDesignInst**)value,borrow,lock);
        if (data->isModModuleInst()) return PyoaModModuleInst_FromoaModModuleInst((oaModModuleInst**)value,borrow,lock);
        PyObject* bself = PyoaModInst_Type.tp_alloc(&PyoaModInst_Type,0);
        if (bself == NULL) return bself;
        PyoaModInstObject* self = (PyoaModInstObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaModInst_FromoaModInst(oaModInst* data)
{
    if (data) {
        if (data->isModDesignInst()) return PyoaModDesignInst_FromoaModDesignInst((oaModDesignInst*)data);
        if (data->isModModuleInst()) return PyoaModModuleInst_FromoaModModuleInst((oaModModuleInst*)data);
       PyObject* bself = PyoaModInst_Type.tp_alloc(&PyoaModInst_Type,0);
       if (bself == NULL) return bself;
       PyoaModInstObject* self = (PyoaModInstObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModInst_destroy_doc[] = 
"Class: oaModInst, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    Removes this modInst from the database. If this was the last instance of the module or design that is its master then the oaModInstHeader that it belongs to is destroyed as well.\n"
;

static PyObject*
oaModInst_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInst data;
    int convert_status=PyoaModInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstObject* self=(PyoaModInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInst_getAssignments_doc[] = 
"Class: oaModInst, Function: getAssignments\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaModAssignment_oaModInst getAssignments() const\n"
"    Signature: getAssignments|simple-oaCollection_oaModAssignment_oaModInst|\n"
"    BrowseData: 1\n"
"    This function returns a collection of module assignments associated with this instance.\n"
;

static PyObject*
oaModInst_getAssignments(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInst data;
    int convert_status=PyoaModInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstObject* self=(PyoaModInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaModAssignment_oaModInst* result= new oaCollection_oaModAssignment_oaModInst(data.DataCall()->getAssignments());
        return PyoaCollection_oaModAssignment_oaModInst_FromoaCollection_oaModAssignment_oaModInst(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInst_getAssignmentsIter_doc[] = 
"Class: oaModInst, Function: getAssignmentsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaModAssignment getAssignmentsIter() const\n"
"    Signature: getAssignmentsIter|simple-oaIter_oaModAssignment|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of module assignments associated with this instance.\n"
;

static PyObject*
oaModInst_getAssignmentsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInst data;
    int convert_status=PyoaModInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstObject* self=(PyoaModInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaModAssignment* result= new oaIter_oaModAssignment(data.DataCall()->getAssignments());
        return PyoaIter_oaModAssignment_FromoaIter_oaModAssignment(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInst_getInstTerms_doc[] = 
"Class: oaModInst, Function: getInstTerms\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaModInstTerm_oaModInst getInstTerms() const\n"
"    Signature: getInstTerms|simple-oaCollection_oaModInstTerm_oaModInst|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns a collection of module instTerms associated with this instance.\n"
"    When oacInstTermIterNotImplicit is included in filterFlags , the collection will only contain explicit instTerms associated with the instance\n"
"    When oacInstTermIterSingleBit is included in filterFlags , the collection will only contain instTerms that make a single-bit connection to the instance\n"
"    filterFlags\n"
"    Specifies which types of instTerms to include in the collection\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaModInstTerm_oaModInst getInstTerms(oaUInt4 filterFlags) const\n"
"    Signature: getInstTerms|simple-oaCollection_oaModInstTerm_oaModInst|simple-oaUInt4,\n"
"    This function returns a collection of module instTerms associated with this instance.\n"
"    When oacInstTermIterNotImplicit is included in filterFlags , the collection will only contain explicit instTerms associated with the instance\n"
"    When oacInstTermIterSingleBit is included in filterFlags , the collection will only contain instTerms that make a single-bit connection to the instance\n"
"    filterFlags\n"
"    Specifies which types of instTerms to include in the collection\n"
;

static PyObject*
oaModInst_getInstTerms(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInst data;
    int convert_status=PyoaModInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstObject* self=(PyoaModInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaModInstTerm_oaModInst* result= new oaCollection_oaModInstTerm_oaModInst(data.DataCall()->getInstTerms());
            return PyoaCollection_oaModInstTerm_oaModInst_FromoaCollection_oaModInstTerm_oaModInst(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaModInstTerm_oaModInst* result= new oaCollection_oaModInstTerm_oaModInst(data.DataCall()->getInstTerms(p1.Data()));
            return PyoaCollection_oaModInstTerm_oaModInst_FromoaCollection_oaModInstTerm_oaModInst(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModInst, function: getInstTerms, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInst_getInstTermsIter_doc[] = 
"Class: oaModInst, Function: getInstTermsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaModInstTerm getInstTermsIter() const\n"
"    Signature: getInstTermsIter|simple-oaIter_oaModInstTerm|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of module instTerms associated with this instance.\n"
"    When oacInstTermIterNotImplicit is included in filterFlags , the collection will only contain explicit instTerms associated with the instance\n"
"    When oacInstTermIterSingleBit is included in filterFlags , the collection will only contain instTerms that make a single-bit connection to the instance\n"
"    filterFlags\n"
"    Specifies which types of instTerms to include in the collection\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaModInstTerm getInstTermsIter(oaUInt4 filterFlags) const\n"
"    Signature: getInstTermsIter|simple-oaIter_oaModInstTerm|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of module instTerms associated with this instance.\n"
"    When oacInstTermIterNotImplicit is included in filterFlags , the collection will only contain explicit instTerms associated with the instance\n"
"    When oacInstTermIterSingleBit is included in filterFlags , the collection will only contain instTerms that make a single-bit connection to the instance\n"
"    filterFlags\n"
"    Specifies which types of instTerms to include in the collection\n"
;

static PyObject*
oaModInst_getInstTermsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInst data;
    int convert_status=PyoaModInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstObject* self=(PyoaModInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaModInstTerm* result= new oaIter_oaModInstTerm(data.DataCall()->getInstTerms());
            return PyoaIter_oaModInstTerm_FromoaIter_oaModInstTerm(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaModInstTerm* result= new oaIter_oaModInstTerm(data.DataCall()->getInstTerms(p1.Data()));
            return PyoaIter_oaModInstTerm_FromoaIter_oaModInstTerm(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModInst, function: getInstTermsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInst_getMasterModule_doc[] = 
"Class: oaModInst, Function: getMasterModule\n"
"  Paramegers: ()\n"
"    Calls: oaModule* getMasterModule() const\n"
"    Signature: getMasterModule|ptr-oaModule|\n"
"    BrowseData: 1\n"
"    This function returns the master module of this instance. NULL is returned if the module master can not be bound.\n"
;

static PyObject*
oaModInst_getMasterModule(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInst data;
    int convert_status=PyoaModInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstObject* self=(PyoaModInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModulep result= (data.DataCall()->getMasterModule());
        return PyoaModule_FromoaModule(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInst_getName_doc[] = 
"Class: oaModInst, Function: getName\n"
"  Paramegers: (oaSimpleName)\n"
"    Calls: void getName(oaSimpleName& name) const\n"
"    Signature: getName|void-void|ref-oaSimpleName,\n"
"    BrowseData: 0,oaSimpleName\n"
"    This function fills out name with the name of this instance.\n"
"    name\n"
"    The returned instance name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function fills out name with the name of this instance. The name is mapped according to the specified nameSpace.\n"
"    ns\n"
"    The nameSpace used to map the name\n"
"    name\n"
"    The returned instance name\n"
;

static PyObject*
oaModInst_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInst data;
    int convert_status=PyoaModInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstObject* self=(PyoaModInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaSimpleName)
    {
        PyParamoaSimpleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSimpleName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModInst, function: getName, Choices are:\n"
        "    (oaSimpleName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInst_getNumBits_doc[] = 
"Class: oaModInst, Function: getNumBits\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumBits() const\n"
"    Signature: getNumBits|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of bits of this instance. This function always returns '1' for scalar and array instances. The function can return '1' or more for vector instances.\n"
;

static PyObject*
oaModInst_getNumBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInst data;
    int convert_status=PyoaModInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstObject* self=(PyoaModInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumBits());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInst_getOccInsts_doc[] = 
"Class: oaModInst, Function: getOccInsts\n"
"  Paramegers: (oaOccurrence)\n"
"    Calls: oaCollection_oaOccInst_oaModInst getOccInsts(const oaOccurrence* top) const\n"
"    Signature: getOccInsts|simple-oaCollection_oaOccInst_oaModInst|cptr-oaOccurrence,\n"
"    This function returns a collection of occurrence instances associated with this instance in the design hierarchy under the specified 'top' occurrence. It is an error if the specified top occurrence is not in the same design as this module instance is in.\n"
;

static PyObject*
oaModInst_getOccInsts(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInst data;
    int convert_status=PyoaModInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstObject* self=(PyoaModInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaOccurrence p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccurrence_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaCollection_oaOccInst_oaModInst* result= new oaCollection_oaOccInst_oaModInst(data.DataCall()->getOccInsts(p1.Data()));
        return PyoaCollection_oaOccInst_oaModInst_FromoaCollection_oaOccInst_oaModInst(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInst_getOccInstsIter_doc[] = 
"Class: oaModInst, Function: getOccInstsIter\n"
"  Paramegers: (oaOccurrence)\n"
"    Calls: oaIter_oaOccInst getOccInstsIter(const oaOccurrence* top) const\n"
"    Signature: getOccInstsIter|simple-oaIter_oaOccInst|cptr-oaOccurrence,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of occurrence instances associated with this instance in the design hierarchy under the specified 'top' occurrence. It is an error if the specified top occurrence is not in the same design as this module instance is in.\n"
;

static PyObject*
oaModInst_getOccInstsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInst data;
    int convert_status=PyoaModInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstObject* self=(PyoaModInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaOccurrence p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccurrence_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaIter_oaOccInst* result= new oaIter_oaOccInst(data.DataCall()->getOccInsts(p1.Data()));
        return PyoaIter_oaOccInst_FromoaIter_oaOccInst(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInst_isBound_doc[] = 
"Class: oaModInst, Function: isBound\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isBound() const\n"
"    Signature: isBound|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value indicating whether this instance is currently bound to its master. An instance is bound to its master if some traversal is made from the instance to the master or an object in the master. If the instance is bound, then its master is in memory and the linkage from the instance to the master is established.\n"
"    true if the instance is bound, otherwise false\n"
;

static PyObject*
oaModInst_isBound(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInst data;
    int convert_status=PyoaModInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstObject* self=(PyoaModInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isBound());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInst_isImplicit_doc[] = 
"Class: oaModInst, Function: isImplicit\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isImplicit() const\n"
"    Signature: isImplicit|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value that indicates if this instance is implicit, having been automatically created as a result of the creation of a vectorInst.\n"
;

static PyObject*
oaModInst_isImplicit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInst data;
    int convert_status=PyoaModInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstObject* self=(PyoaModInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isImplicit());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInst_isModDesignInst_doc[] = 
"Class: oaModInst, Function: isModDesignInst\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isModDesignInst() const\n"
"    Signature: isModDesignInst|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object is an instance of one of the classes derived from the oaModDesignInst class. The function returns a boolean value of true if the oaModInst is an oaModDesignInst .\n"
;

static PyObject*
oaModInst_isModDesignInst(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInst data;
    int convert_status=PyoaModInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstObject* self=(PyoaModInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isModDesignInst());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInst_isModModuleInst_doc[] = 
"Class: oaModInst, Function: isModModuleInst\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isModModuleInst() const\n"
"    Signature: isModModuleInst|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object is an instance of one of the classes derived from the oaModModuleInst class. The function returns a boolean value of true if the oaModInst is an oaModModuleInst .\n"
;

static PyObject*
oaModInst_isModModuleInst(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInst data;
    int convert_status=PyoaModInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstObject* self=(PyoaModInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isModModuleInst());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInst_scalarize_doc[] = 
"Class: oaModInst, Function: scalarize\n"
"  Paramegers: ()\n"
"    Calls: void scalarize()\n"
"    Signature: scalarize|void-void|\n"
"    BrowseData: 0\n"
"    This function insures that the bitInsts associated with this instance have been promoted to the explicit state so that they can support implementation data.\n"
"    If this instance is a multibit instance, this function insures that all constituent bitInsts are promoted to the explicit state. The multibit instance is then demoted to the implicit state so that no implementation data can be associated with it. When an instance is demoted to the implicit state, associated implementation data is removed from it.\n"
"    When an instance is scalarized, all of its connections are also scalarized. Each bit of any multi-bit connection associated with the instance is promoted to the explicit state and is available for editing.\n"
"    oacCannotScalarizeImplicitInst\n"
;

static PyObject*
oaModInst_scalarize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInst data;
    int convert_status=PyoaModInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstObject* self=(PyoaModInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->scalarize();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInst_usesTermPositions_doc[] = 
"Class: oaModInst, Function: usesTermPositions\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean usesTermPositions() const\n"
"    Signature: usesTermPositions|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating how connections to this instance have been made. If the instTerms associated with this instance connect to terminal positions, this function returns true . Otherwise, this function returns false . Note that if the collection of instTerms for this instance is empty, this function will also return false .\n"
;

static PyObject*
oaModInst_usesTermPositions(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInst data;
    int convert_status=PyoaModInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstObject* self=(PyoaModInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->usesTermPositions());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInst_isNull_doc[] =
"Class: oaModInst, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaModInst_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaModInst data;
    int convert_status=PyoaModInst_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaModInst_assign_doc[] = 
"Class: oaModInst, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModInst_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModInst data;
  int convert_status=PyoaModInst_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModInst p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModInst_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModInst_methodlist[] = {
    {"destroy",(PyCFunction)oaModInst_destroy,METH_VARARGS,oaModInst_destroy_doc},
    {"getAssignments",(PyCFunction)oaModInst_getAssignments,METH_VARARGS,oaModInst_getAssignments_doc},
    {"getAssignmentsIter",(PyCFunction)oaModInst_getAssignmentsIter,METH_VARARGS,oaModInst_getAssignmentsIter_doc},
    {"getInstTerms",(PyCFunction)oaModInst_getInstTerms,METH_VARARGS,oaModInst_getInstTerms_doc},
    {"getInstTermsIter",(PyCFunction)oaModInst_getInstTermsIter,METH_VARARGS,oaModInst_getInstTermsIter_doc},
    {"getMasterModule",(PyCFunction)oaModInst_getMasterModule,METH_VARARGS,oaModInst_getMasterModule_doc},
    {"getName",(PyCFunction)oaModInst_getName,METH_VARARGS,oaModInst_getName_doc},
    {"getNumBits",(PyCFunction)oaModInst_getNumBits,METH_VARARGS,oaModInst_getNumBits_doc},
    {"getOccInsts",(PyCFunction)oaModInst_getOccInsts,METH_VARARGS,oaModInst_getOccInsts_doc},
    {"getOccInstsIter",(PyCFunction)oaModInst_getOccInstsIter,METH_VARARGS,oaModInst_getOccInstsIter_doc},
    {"isBound",(PyCFunction)oaModInst_isBound,METH_VARARGS,oaModInst_isBound_doc},
    {"isImplicit",(PyCFunction)oaModInst_isImplicit,METH_VARARGS,oaModInst_isImplicit_doc},
    {"isModDesignInst",(PyCFunction)oaModInst_isModDesignInst,METH_VARARGS,oaModInst_isModDesignInst_doc},
    {"isModModuleInst",(PyCFunction)oaModInst_isModModuleInst,METH_VARARGS,oaModInst_isModModuleInst_doc},
    {"scalarize",(PyCFunction)oaModInst_scalarize,METH_VARARGS,oaModInst_scalarize_doc},
    {"usesTermPositions",(PyCFunction)oaModInst_usesTermPositions,METH_VARARGS,oaModInst_usesTermPositions_doc},
    {"isNull",(PyCFunction)oaModInst_tp_isNull,METH_VARARGS,oaModInst_isNull_doc},
    {"assign",(PyCFunction)oaModInst_tp_assign,METH_VARARGS,oaModInst_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModInst_doc[] = 
"Class: oaModInst\n"
"  The oaModInst class is an abstract base class for module instances. An instance represents the inclusion of one module (or a design containing a top module) as a part of the contents of another. The module containing the instance is the parent module, and the module that is included is the master module of the instance.\n"
"  oaModInst objects are always in the module domain. An oaModInst can have an equivalent oaInst in the block domain and will always have an equivalent oaOccInst in the occurrence hierarchy.\n"
"  Note that oaModInst::getOccInsts will return oaOccInsts only if the occurrence hierarchy has been expanded to include those objects. See Working in the Occurrence Domain for more details.\n"
"  Instances can create hierarchical designs. The master of an instance can contain instances of other masters. This hierarchy can continue for as many levels as needed to express a complete design.\n"
"  All instances have names. These names can be assigned by the creator. For scalar modules, instance names can be automatically assigned by the database.\n"
"  Module instances always have an InstHeader, which contains the attributes that are constant for all instances of a given master module. However, the InstHeader class for oaModModuleInsts is oaModModuleInstHeader and the InstHeader class for oaModDesignInsts is oaModInstHeader . An oaModModuleInstHeader collects all the same oaModModuleInsts for a given parent module, while an oaModInstHeader collects all of the same oaModDesignInsts across an oaDesign for all parent modules.\n"
"  Instances of pCells include a set of parameter values used to tailor the pCell for each specific instance.\n"
"  The oaModInst class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaModInst)\n"
"    Calls: (const oaModInst&)\n"
"    Signature: oaModInst||cref-oaModInst,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModInst_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModInst",
    sizeof(PyoaModInstObject),
    0,
    (destructor)oaModInst_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModInst_tp_compare,	/* tp_compare */
    (reprfunc)oaModInst_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModInst_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaModInst_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaModObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModInst_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModInst_static_find_doc[] = 
"Class: oaModInst, Function: find\n"
"  Paramegers: (oaModule,oaSimpleName)\n"
"    Calls: oaModInst* find(const oaModule* module,const oaSimpleName& name)\n"
"    Signature: find|ptr-oaModInst|cptr-oaModule,cref-oaSimpleName,\n"
"    This function searches the specified module for an instance with the specified name. If the name is hierarchical, then this function searches for the instance as specified in the hierarchical path name. If found, the instance is returned. Otherwise, NULL is returned.\n"
"    module\n"
"    The module to search\n"
"    name\n"
"    The instance name to find\n"
"    A pointer to the module instance, if found; otherwise, NULL\n"
;

static PyObject*
oaModInst_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule p1;
    PyParamoaSimpleName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaModule_Convert,&p1,
          &PyoaSimpleName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaModInstp result= (oaModInst::find(p1.Data(),p2.Data()));
        return PyoaModInst_FromoaModInst(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaModInst_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaModInst_static_find,METH_VARARGS,oaModInst_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModInst_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModInst_Type)<0) {
      printf("** PyType_Ready failed for: oaModInst\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModInst",
           (PyObject*)(&PyoaModInst_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModInst\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaModInst_Type.tp_dict;
    for(method=oaModInst_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModInstHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModInstHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModInstHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModInstHeaderObject* self = (PyoaModInstHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModInstHeader)
    {
        PyParamoaModInstHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModInstHeader_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModInstHeader, Choices are:\n"
        "    (oaModInstHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModInstHeader_tp_dealloc(PyoaModInstHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModInstHeader_tp_repr(PyObject *ob)
{
    PyParamoaModInstHeader value;
    int convert_status=PyoaModInstHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaModInstHeader::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaString sresult;
        oaString sep=" ";
        sep[(oaUInt4)0]=oacInternalHierDelimiter;
        oaScalarName name;
        oaString str;
        value.DataCall()->getLibName(name);
        name.get(str);
        sresult+=oaString(str);
        sresult+=sep;
        value.DataCall()->getCellName(name);
        name.get(str);
        sresult+=oaString(str);
        sresult+=sep;
        value.DataCall()->getViewName(name);
        name.get(str);
        sresult+=oaString(str);
    
        char addr[37];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaModInstHeader::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModInstHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModInstHeader v1;
    PyParamoaModInstHeader v2;
    int convert_status1=PyoaModInstHeader_Convert(ob1,&v1);
    int convert_status2=PyoaModInstHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModInstHeader_Convert(PyObject* ob,PyParamoaModInstHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaModInstHeader_Check(ob)) {
        result->SetData( (oaModInstHeader**) ((PyoaModInstHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModInstHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModInstHeader_FromoaModInstHeader(oaModInstHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaModInstHeader* data=*value;
        PyObject* bself = PyoaModInstHeader_Type.tp_alloc(&PyoaModInstHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaModInstHeaderObject* self = (PyoaModInstHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaModInstHeader_FromoaModInstHeader(oaModInstHeader* data)
{
    if (data) {
       PyObject* bself = PyoaModInstHeader_Type.tp_alloc(&PyoaModInstHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaModInstHeaderObject* self = (PyoaModInstHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModInstHeader_getAllParams_doc[] = 
"Class: oaModInstHeader, Function: getAllParams\n"
"  Paramegers: (oaParamArray)\n"
"    Calls: void getAllParams(oaParamArray& params) const\n"
"    Signature: getAllParams|void-void|ref-oaParamArray,\n"
"    BrowseData: 0,oaParamArray\n"
"    This function fills out params with the parameters associated with this instHeader and the parameters associated with the superMaster. If this instHeader is not associated with parameters, params will have a numParams value of zero.\n"
;

static PyObject*
oaModInstHeader_getAllParams(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstHeader data;
    int convert_status=PyoaModInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstHeaderObject* self=(PyoaModInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaParamArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaParamArray_Convert,&p1)) {
        data.DataCall()->getAllParams(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstHeader_getCellName_doc[] = 
"Class: oaModInstHeader, Function: getCellName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getCellName(oaScalarName& cellName) const\n"
"    Signature: getCellName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the cell name of the master oaDesign referenced by this modInstHeader.\n"
"    cellName\n"
"    The returned cell name.\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getCellName(const oaNameSpace& ns,oaString& cellName) const\n"
"    Signature: getCellName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the cell name of the master oaDesign referenced by this modInstHeader.\n"
"    ns\n"
"    The namespace in which to return the cell name.\n"
"    cellName\n"
"    The returned cell name.\n"
;

static PyObject*
oaModInstHeader_getCellName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstHeader data;
    int convert_status=PyoaModInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstHeaderObject* self=(PyoaModInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getCellName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getCellName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModInstHeader, function: getCellName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstHeader_getInsts_doc[] = 
"Class: oaModInstHeader, Function: getInsts\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaModDesignInst_oaModInstHeader getInsts() const\n"
"    Signature: getInsts|simple-oaCollection_oaModDesignInst_oaModInstHeader|simple-oaUInt4,ptr-oaModule,\n"
"    BrowseData: 1\n"
"    oaModInstHeader::getInsts\n"
"    This function returns a collection of instances associated with this instHeader. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection. If the optional parentModule is specified, the collection contains only the modInsts which directly belong to that module as parent.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
"    module\n"
"    Specifies that the collection should only contain those instances where the module is the parent\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaModDesignInst_oaModInstHeader getInsts(oaUInt4 filterFlags) const\n"
"    Signature: getInsts|simple-oaCollection_oaModDesignInst_oaModInstHeader|simple-oaUInt4,ptr-oaModule,\n"
"    oaModInstHeader::getInsts\n"
"    This function returns a collection of instances associated with this instHeader. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection. If the optional parentModule is specified, the collection contains only the modInsts which directly belong to that module as parent.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
"    module\n"
"    Specifies that the collection should only contain those instances where the module is the parent\n"
"  Paramegers: (oaUInt4,oaModule)\n"
"    Calls: oaCollection_oaModDesignInst_oaModInstHeader getInsts(oaUInt4 filterFlags,oaModule* parentModule) const\n"
"    Signature: getInsts|simple-oaCollection_oaModDesignInst_oaModInstHeader|simple-oaUInt4,ptr-oaModule,\n"
"    oaModInstHeader::getInsts\n"
"    This function returns a collection of instances associated with this instHeader. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection. If the optional parentModule is specified, the collection contains only the modInsts which directly belong to that module as parent.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
"    module\n"
"    Specifies that the collection should only contain those instances where the module is the parent\n"
;

static PyObject*
oaModInstHeader_getInsts(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstHeader data;
    int convert_status=PyoaModInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstHeaderObject* self=(PyoaModInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaModDesignInst_oaModInstHeader* result= new oaCollection_oaModDesignInst_oaModInstHeader(data.DataCall()->getInsts());
            return PyoaCollection_oaModDesignInst_oaModInstHeader_FromoaCollection_oaModDesignInst_oaModInstHeader(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaModDesignInst_oaModInstHeader* result= new oaCollection_oaModDesignInst_oaModInstHeader(data.DataCall()->getInsts(p1.Data()));
            return PyoaCollection_oaModDesignInst_oaModInstHeader_FromoaCollection_oaModDesignInst_oaModInstHeader(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaModule)
    {
        PyParamoaUInt4 p1;
        PyParamoaModule p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaModule_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaCollection_oaModDesignInst_oaModInstHeader* result= new oaCollection_oaModDesignInst_oaModInstHeader(data.DataCall()->getInsts(p1.Data(),p2.Data()));
            return PyoaCollection_oaModDesignInst_oaModInstHeader_FromoaCollection_oaModDesignInst_oaModInstHeader(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModInstHeader, function: getInsts, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaModule)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstHeader_getInstsIter_doc[] = 
"Class: oaModInstHeader, Function: getInstsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaModDesignInst getInstsIter() const\n"
"    Signature: getInstsIter|simple-oaIter_oaModDesignInst|simple-oaUInt4,ptr-oaModule,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: oaModInstHeader::getInsts\n"
"    This function returns a collection of instances associated with this instHeader. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection. If the optional parentModule is specified, the collection contains only the modInsts which directly belong to that module as parent.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
"    module\n"
"    Specifies that the collection should only contain those instances where the module is the parent\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaModDesignInst getInstsIter(oaUInt4 filterFlags) const\n"
"    Signature: getInstsIter|simple-oaIter_oaModDesignInst|simple-oaUInt4,ptr-oaModule,\n"
"    This function returns an Iterator over the following collection: oaModInstHeader::getInsts\n"
"    This function returns a collection of instances associated with this instHeader. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection. If the optional parentModule is specified, the collection contains only the modInsts which directly belong to that module as parent.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
"    module\n"
"    Specifies that the collection should only contain those instances where the module is the parent\n"
"  Paramegers: (oaUInt4,oaModule)\n"
"    Calls: oaIter_oaModDesignInst getInstsIter(oaUInt4 filterFlags,oaModule* parentModule) const\n"
"    Signature: getInstsIter|simple-oaIter_oaModDesignInst|simple-oaUInt4,ptr-oaModule,\n"
"    This function returns an Iterator over the following collection: oaModInstHeader::getInsts\n"
"    This function returns a collection of instances associated with this instHeader. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection. If the optional parentModule is specified, the collection contains only the modInsts which directly belong to that module as parent.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
"    module\n"
"    Specifies that the collection should only contain those instances where the module is the parent\n"
;

static PyObject*
oaModInstHeader_getInstsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstHeader data;
    int convert_status=PyoaModInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstHeaderObject* self=(PyoaModInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaModDesignInst* result= new oaIter_oaModDesignInst(data.DataCall()->getInsts());
            return PyoaIter_oaModDesignInst_FromoaIter_oaModDesignInst(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaModDesignInst* result= new oaIter_oaModDesignInst(data.DataCall()->getInsts(p1.Data()));
            return PyoaIter_oaModDesignInst_FromoaIter_oaModDesignInst(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaModule)
    {
        PyParamoaUInt4 p1;
        PyParamoaModule p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaModule_Convert,&p2)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaIter_oaModDesignInst* result= new oaIter_oaModDesignInst(data.DataCall()->getInsts(p1.Data(),p2.Data()));
            return PyoaIter_oaModDesignInst_FromoaIter_oaModDesignInst(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModInstHeader, function: getInstsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaModule)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstHeader_getLibName_doc[] = 
"Class: oaModInstHeader, Function: getLibName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getLibName(oaScalarName& libName) const\n"
"    Signature: getLibName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the library name of the master oaDesign referenced by this modInstHeader.\n"
"    libName\n"
"    The returned library name.\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getLibName(const oaNameSpace& ns,oaString& libName) const\n"
"    Signature: getLibName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the library name of the master oaDesign referenced by this modInstHeader.\n"
"    ns\n"
"    The namespace in which to return the library name.\n"
"    libName\n"
"    The returned library name.\n"
;

static PyObject*
oaModInstHeader_getLibName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstHeader data;
    int convert_status=PyoaModInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstHeaderObject* self=(PyoaModInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getLibName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getLibName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModInstHeader, function: getLibName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstHeader_getMaster_doc[] = 
"Class: oaModInstHeader, Function: getMaster\n"
"  Paramegers: ()\n"
"    Calls: oaDesign* getMaster() const\n"
"    Signature: getMaster|ptr-oaDesign|\n"
"    BrowseData: 1\n"
"    This function returns the master associated with this instHeader. If this instHeader isn't bound, an attempt is made to bind it. A pointer to the master design is returned if this instHeader is, or was successfully, bound. Otherwise, NULL is returned.\n"
;

static PyObject*
oaModInstHeader_getMaster(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstHeader data;
    int convert_status=PyoaModInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstHeaderObject* self=(PyoaModInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaDesignp result= (data.DataCall()->getMaster());
        return PyoaDesign_FromoaDesign(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstHeader_getMasterModule_doc[] = 
"Class: oaModInstHeader, Function: getMasterModule\n"
"  Paramegers: ()\n"
"    Calls: oaModule* getMasterModule() const\n"
"    Signature: getMasterModule|ptr-oaModule|\n"
"    BrowseData: 1\n"
"    This function returns the top module of the design associated with this instHeader. If this instHeader isn't bound, an attempt is made to bind it. A pointer to the top module in the bound master design is returned if this instHeader is, or was successfully, bound. Otherwise, NULL is returned. Note that NULL may also be returned if the bound master design has no top module.\n"
;

static PyObject*
oaModInstHeader_getMasterModule(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstHeader data;
    int convert_status=PyoaModInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstHeaderObject* self=(PyoaModInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModulep result= (data.DataCall()->getMasterModule());
        return PyoaModule_FromoaModule(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstHeader_getParams_doc[] = 
"Class: oaModInstHeader, Function: getParams\n"
"  Paramegers: (oaParamArray)\n"
"    Calls: void getParams(oaParamArray& params) const\n"
"    Signature: getParams|void-void|ref-oaParamArray,\n"
"    BrowseData: 0,oaParamArray\n"
"    This function fills out params with the parameters associated with this instHeader. This call only returns the non-default parameters that were specified during creation or through calls to setParams() on the instances. If this instHeader is not associated with a Pcell master or uses all default parameters, params will have a numParams of zero.\n"
;

static PyObject*
oaModInstHeader_getParams(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstHeader data;
    int convert_status=PyoaModInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstHeaderObject* self=(PyoaModInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaParamArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaParamArray_Convert,&p1)) {
        data.DataCall()->getParams(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstHeader_getSubHeaders_doc[] = 
"Class: oaModInstHeader, Function: getSubHeaders\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaModInstHeader_oaModInstHeader getSubHeaders() const\n"
"    Signature: getSubHeaders|simple-oaCollection_oaModInstHeader_oaModInstHeader|\n"
"    BrowseData: 1\n"
"    This function returns a collection of subHeaders in this superHeader.\n"
;

static PyObject*
oaModInstHeader_getSubHeaders(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstHeader data;
    int convert_status=PyoaModInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstHeaderObject* self=(PyoaModInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaModInstHeader_oaModInstHeader* result= new oaCollection_oaModInstHeader_oaModInstHeader(data.DataCall()->getSubHeaders());
        return PyoaCollection_oaModInstHeader_oaModInstHeader_FromoaCollection_oaModInstHeader_oaModInstHeader(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstHeader_getSubHeadersIter_doc[] = 
"Class: oaModInstHeader, Function: getSubHeadersIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaModInstHeader getSubHeadersIter() const\n"
"    Signature: getSubHeadersIter|simple-oaIter_oaModInstHeader|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of subHeaders in this superHeader.\n"
;

static PyObject*
oaModInstHeader_getSubHeadersIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstHeader data;
    int convert_status=PyoaModInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstHeaderObject* self=(PyoaModInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaModInstHeader* result= new oaIter_oaModInstHeader(data.DataCall()->getSubHeaders());
        return PyoaIter_oaModInstHeader_FromoaIter_oaModInstHeader(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstHeader_getSuperHeader_doc[] = 
"Class: oaModInstHeader, Function: getSuperHeader\n"
"  Paramegers: ()\n"
"    Calls: oaModInstHeader* getSuperHeader() const\n"
"    Signature: getSuperHeader|ptr-oaModInstHeader|\n"
"    BrowseData: 1\n"
"    This function returns the superHeader of this instHeader. The function returns NULL if it is not a subHeader.\n"
;

static PyObject*
oaModInstHeader_getSuperHeader(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstHeader data;
    int convert_status=PyoaModInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstHeaderObject* self=(PyoaModInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModInstHeaderp result= (data.DataCall()->getSuperHeader());
        return PyoaModInstHeader_FromoaModInstHeader(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstHeader_getViewName_doc[] = 
"Class: oaModInstHeader, Function: getViewName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getViewName(oaScalarName& viewName) const\n"
"    Signature: getViewName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the view name of the master oaDesign referenced by this modInstHeader.\n"
"    viewName\n"
"    The returned view name.\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getViewName(const oaNameSpace& ns,oaString& viewName) const\n"
"    Signature: getViewName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the view name of the master oaDesign referenced by this modInstHeader.\n"
"    ns\n"
"    The namespace in which to return the view name.\n"
"    viewName\n"
"    The returned view name.\n"
;

static PyObject*
oaModInstHeader_getViewName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstHeader data;
    int convert_status=PyoaModInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstHeaderObject* self=(PyoaModInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getViewName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getViewName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModInstHeader, function: getViewName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstHeader_isBound_doc[] = 
"Class: oaModInstHeader, Function: isBound\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isBound() const\n"
"    Signature: isBound|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value indicating whether this instHeader is bound to its master design. A bound master means the master is read in and the linkage from the instHeader is established by traversing from an instance to that master.\n"
;

static PyObject*
oaModInstHeader_isBound(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstHeader data;
    int convert_status=PyoaModInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstHeaderObject* self=(PyoaModInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isBound());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstHeader_isSubHeader_doc[] = 
"Class: oaModInstHeader, Function: isSubHeader\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isSubHeader() const\n"
"    Signature: isSubHeader|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value indicating whether this instHeader is a subHeader.\n"
;

static PyObject*
oaModInstHeader_isSubHeader(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstHeader data;
    int convert_status=PyoaModInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstHeaderObject* self=(PyoaModInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isSubHeader());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstHeader_isSuperHeader_doc[] = 
"Class: oaModInstHeader, Function: isSuperHeader\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isSuperHeader() const\n"
"    Signature: isSuperHeader|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value indicating whether this instHeader is a superHeader.\n"
;

static PyObject*
oaModInstHeader_isSuperHeader(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstHeader data;
    int convert_status=PyoaModInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstHeaderObject* self=(PyoaModInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isSuperHeader());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstHeader_isNull_doc[] =
"Class: oaModInstHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaModInstHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaModInstHeader data;
    int convert_status=PyoaModInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaModInstHeader_assign_doc[] = 
"Class: oaModInstHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModInstHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModInstHeader data;
  int convert_status=PyoaModInstHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModInstHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModInstHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModInstHeader_methodlist[] = {
    {"getAllParams",(PyCFunction)oaModInstHeader_getAllParams,METH_VARARGS,oaModInstHeader_getAllParams_doc},
    {"getCellName",(PyCFunction)oaModInstHeader_getCellName,METH_VARARGS,oaModInstHeader_getCellName_doc},
    {"getInsts",(PyCFunction)oaModInstHeader_getInsts,METH_VARARGS,oaModInstHeader_getInsts_doc},
    {"getInstsIter",(PyCFunction)oaModInstHeader_getInstsIter,METH_VARARGS,oaModInstHeader_getInstsIter_doc},
    {"getLibName",(PyCFunction)oaModInstHeader_getLibName,METH_VARARGS,oaModInstHeader_getLibName_doc},
    {"getMaster",(PyCFunction)oaModInstHeader_getMaster,METH_VARARGS,oaModInstHeader_getMaster_doc},
    {"getMasterModule",(PyCFunction)oaModInstHeader_getMasterModule,METH_VARARGS,oaModInstHeader_getMasterModule_doc},
    {"getParams",(PyCFunction)oaModInstHeader_getParams,METH_VARARGS,oaModInstHeader_getParams_doc},
    {"getSubHeaders",(PyCFunction)oaModInstHeader_getSubHeaders,METH_VARARGS,oaModInstHeader_getSubHeaders_doc},
    {"getSubHeadersIter",(PyCFunction)oaModInstHeader_getSubHeadersIter,METH_VARARGS,oaModInstHeader_getSubHeadersIter_doc},
    {"getSuperHeader",(PyCFunction)oaModInstHeader_getSuperHeader,METH_VARARGS,oaModInstHeader_getSuperHeader_doc},
    {"getViewName",(PyCFunction)oaModInstHeader_getViewName,METH_VARARGS,oaModInstHeader_getViewName_doc},
    {"isBound",(PyCFunction)oaModInstHeader_isBound,METH_VARARGS,oaModInstHeader_isBound_doc},
    {"isSubHeader",(PyCFunction)oaModInstHeader_isSubHeader,METH_VARARGS,oaModInstHeader_isSubHeader_doc},
    {"isSuperHeader",(PyCFunction)oaModInstHeader_isSuperHeader,METH_VARARGS,oaModInstHeader_isSuperHeader_doc},
    {"isNull",(PyCFunction)oaModInstHeader_tp_isNull,METH_VARARGS,oaModInstHeader_isNull_doc},
    {"assign",(PyCFunction)oaModInstHeader_tp_assign,METH_VARARGS,oaModInstHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModInstHeader_doc[] = 
"Class: oaModInstHeader\n"
"  The oaModInstHeader class implements an object that contains information common to all the instances of a particular master oaDesign in a given parent module. For instances of Pcells, there are two kinds of instHeaders:\n"
"  SuperHeaders represent all of the instances of a Pcell master, regardless of parameter settings\n"
"  SubHeaders represent all of the instances that have one specific set of parameter values\n"
"  Every instance of a Pcell has exactly one subHeader, which, in turn, has exactly one superHeader. InstHeaders for instances that are not Pcells are neither subheaders nor superheaders.\n"
"  The oaModInstHeader class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaModInstHeader)\n"
"    Calls: (const oaModInstHeader&)\n"
"    Signature: oaModInstHeader||cref-oaModInstHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModInstHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModInstHeader",
    sizeof(PyoaModInstHeaderObject),
    0,
    (destructor)oaModInstHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModInstHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaModInstHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModInstHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaModInstHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaModObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModInstHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModInstHeader_static_find_doc[] = 
"Class: oaModInstHeader, Function: find\n"
"  Paramegers: (oaDesign,oaDesign)\n"
"    Calls: oaModInstHeader* find(const oaDesign* design,const oaDesign* master)\n"
"    Signature: find|ptr-oaModInstHeader|cptr-oaDesign,cptr-oaDesign,\n"
"    This function searches the specified design for an instHeader with the specified master design. If the specified master is a Pcell, the superMaster is returned.\n"
"  Paramegers: (oaDesign,oaScalarName,oaScalarName,oaScalarName)\n"
"    Calls: oaModInstHeader* find(const oaDesign* design,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName)\n"
"    Signature: find|ptr-oaModInstHeader|cptr-oaDesign,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,\n"
"    This function searches the specified design for an instHeader with the specified master design library, cell, and view names. If the specified master is a Pcell, the superMaster is returned.\n"
;

static PyObject*
oaModInstHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaDesign,oaDesign)
    {
        PyParamoaDesign p1;
        PyParamoaDesign p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaDesign_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaModInstHeaderp result= (oaModInstHeader::find(p1.Data(),p2.Data()));
            return PyoaModInstHeader_FromoaModInstHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaDesign,oaScalarName,oaScalarName,oaScalarName)
    {
        PyParamoaDesign p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModInstHeaderp result= (oaModInstHeader::find(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaModInstHeader_FromoaModInstHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModInstHeader, function: find, Choices are:\n"
        "    (oaDesign,oaDesign)\n"
        "    (oaDesign,oaScalarName,oaScalarName,oaScalarName)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaModInstHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaModInstHeader_static_find,METH_VARARGS,oaModInstHeader_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModInstHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModInstHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaModInstHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModInstHeader",
           (PyObject*)(&PyoaModInstHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModInstHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaModInstHeader_Type.tp_dict;
    for(method=oaModInstHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModInstTerm
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModInstTerm_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModInstTerm_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModInstTermObject* self = (PyoaModInstTermObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModInstTerm)
    {
        PyParamoaModInstTerm p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModInstTerm_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModInstTerm, Choices are:\n"
        "    (oaModInstTerm)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModInstTerm_tp_dealloc(PyoaModInstTermObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModInstTerm_tp_repr(PyObject *ob)
{
    PyParamoaModInstTerm value;
    int convert_status=PyoaModInstTerm_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaModInstTerm::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaString sresult;
        oaString sep=" ";
        sep[(oaUInt4)0]=oacInternalHierDelimiter;
        oaSimpleName sname;
        oaName name;
        oaString str;
        if (value.DataCall()->getInst()->isValid()) {
          value.DataCall()->getInst()->getName(sname);
          sname.get(str);
        }
        else {
          str="-";
        }
        sname.get(str);
        sresult+=oaString(str);
        sresult+=sep;
        value.DataCall()->getTermName(name);
        name.get(str);
        sresult+=oaString(str);
    
        char addr[35];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaModInstTerm::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModInstTerm_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModInstTerm v1;
    PyParamoaModInstTerm v2;
    int convert_status1=PyoaModInstTerm_Convert(ob1,&v1);
    int convert_status2=PyoaModInstTerm_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModInstTerm_Convert(PyObject* ob,PyParamoaModInstTerm* result)
{
    if (ob == NULL) return 1;
    if (PyoaModInstTerm_Check(ob)) {
        result->SetData( (oaModInstTerm**) ((PyoaModInstTermObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModInstTerm Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModInstTerm_FromoaModInstTerm(oaModInstTerm** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaModInstTerm* data=*value;
        PyObject* bself = PyoaModInstTerm_Type.tp_alloc(&PyoaModInstTerm_Type,0);
        if (bself == NULL) return bself;
        PyoaModInstTermObject* self = (PyoaModInstTermObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaModInstTerm_FromoaModInstTerm(oaModInstTerm* data)
{
    if (data) {
       PyObject* bself = PyoaModInstTerm_Type.tp_alloc(&PyoaModInstTerm_Type,0);
       if (bself == NULL) return bself;
       PyoaModInstTermObject* self = (PyoaModInstTermObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModInstTerm_addToNet_doc[] = 
"Class: oaModInstTerm, Function: addToNet\n"
"  Paramegers: (oaModNet)\n"
"    Calls: void addToNet(oaModNet* net)\n"
"    Signature: addToNet|void-void|ptr-oaModNet,\n"
"    This function adds this instTerm to the specified net. If this instTerm is already connected to another net, it detaches first.\n"
"    net\n"
"    The new net to which to attach the instTerm\n"
"    oacNetAndInstNotInSameModule\n"
"    oacNetInstTermWidthMismatchForInstTerm\n"
"    oacCannotModifyImplicitInstTerm\n"
;

static PyObject*
oaModInstTerm_addToNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstTerm data;
    int convert_status=PyoaModInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstTermObject* self=(PyoaModInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaModNet p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaModNet_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->addToNet(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstTerm_destroy_doc[] = 
"Class: oaModInstTerm, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function destroys this instTerm, removing it from the database. The reference for the instTerm is removed from the corresponding net.\n"
;

static PyObject*
oaModInstTerm_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstTerm data;
    int convert_status=PyoaModInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstTermObject* self=(PyoaModInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstTerm_getBit_doc[] = 
"Class: oaModInstTerm, Function: getBit\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaModInstTerm* getBit(oaUInt4 bitIndex) const\n"
"    Signature: getBit|ptr-oaModInstTerm|simple-oaUInt4,\n"
"    This function returns a pointer to the modInstTerm that corresponds to the specified bitIndex bit of this modInstTerm. For single-bit instTerms, this function returns this modInstTerm if the bitIndex value is zero.\n"
"    oacInvalidInstTermBitIndex\n"
;

static PyObject*
oaModInstTerm_getBit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstTerm data;
    int convert_status=PyoaModInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstTermObject* self=(PyoaModInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaModInstTermp result= (data.DataCall()->getBit(p1.Data()));
        return PyoaModInstTerm_FromoaModInstTerm(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstTerm_getInst_doc[] = 
"Class: oaModInstTerm, Function: getInst\n"
"  Paramegers: ()\n"
"    Calls: oaModInst* getInst() const\n"
"    Signature: getInst|ptr-oaModInst|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the instance associated with this instTerm.\n"
;

static PyObject*
oaModInstTerm_getInst(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstTerm data;
    int convert_status=PyoaModInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstTermObject* self=(PyoaModInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModInstp result= (data.DataCall()->getInst());
        return PyoaModInst_FromoaModInst(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstTerm_getNet_doc[] = 
"Class: oaModInstTerm, Function: getNet\n"
"  Paramegers: ()\n"
"    Calls: oaModNet* getNet() const\n"
"    Signature: getNet|ptr-oaModNet|simple-oaBoolean,\n"
"    BrowseData: 1\n"
"    oaModInstTerm::getNet\n"
"    This function returns the net associated with this instTerm. NULL is returned if the instTerm was created with a NULL net or if the instTerm was disconnected from the net. If preferred is true , the preferred equivalent net associated with the net will be returned instead.\n"
"    preferred\n"
"    indicates whether to return the preferred equivalent\n"
"    A pointer to an oaModNet\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: oaModNet* getNet(oaBoolean preferred) const\n"
"    Signature: getNet|ptr-oaModNet|simple-oaBoolean,\n"
"    oaModInstTerm::getNet\n"
"    This function returns the net associated with this instTerm. NULL is returned if the instTerm was created with a NULL net or if the instTerm was disconnected from the net. If preferred is true , the preferred equivalent net associated with the net will be returned instead.\n"
"    preferred\n"
"    indicates whether to return the preferred equivalent\n"
"    A pointer to an oaModNet\n"
;

static PyObject*
oaModInstTerm_getNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstTerm data;
    int convert_status=PyoaModInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstTermObject* self=(PyoaModInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaModNetp result= (data.DataCall()->getNet());
            return PyoaModNet_FromoaModNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            oaModNetp result= (data.DataCall()->getNet(p1.Data()));
            return PyoaModNet_FromoaModNet(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModInstTerm, function: getNet, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstTerm_getNumBits_doc[] = 
"Class: oaModInstTerm, Function: getNumBits\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumBits() const\n"
"    Signature: getNumBits|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of bits for this instTerm. This value is equal to the number of bits in the associated net. If the instTerm has no net, the value is calculated from the number of bits in the corresponding terminal multiplied by the number of bits in the corresponding instance. If the terminal is not bound, the number of bits for the terminal is derived from the terminal name. If the terminal is not bound and the instTerm connects by position, the number of bits cannot be determined if there is no net, and a value of zero is returned.\n"
;

static PyObject*
oaModInstTerm_getNumBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstTerm data;
    int convert_status=PyoaModInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstTermObject* self=(PyoaModInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumBits());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstTerm_getOccInstTerms_doc[] = 
"Class: oaModInstTerm, Function: getOccInstTerms\n"
"  Paramegers: (oaOccurrence)\n"
"    Calls: oaCollection_oaOccInstTerm_oaModInstTerm getOccInstTerms(const oaOccurrence* top) const\n"
"    Signature: getOccInstTerms|simple-oaCollection_oaOccInstTerm_oaModInstTerm|cptr-oaOccurrence,\n"
"    This function returns a collection of oaOccInstTerm objects that represent this instTerm in the occurrence hierarchy specified by top .\n"
"    top\n"
"    The top oaOccurrence in the occurrence hierarchy.\n"
;

static PyObject*
oaModInstTerm_getOccInstTerms(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstTerm data;
    int convert_status=PyoaModInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstTermObject* self=(PyoaModInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaOccurrence p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccurrence_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaCollection_oaOccInstTerm_oaModInstTerm* result= new oaCollection_oaOccInstTerm_oaModInstTerm(data.DataCall()->getOccInstTerms(p1.Data()));
        return PyoaCollection_oaOccInstTerm_oaModInstTerm_FromoaCollection_oaOccInstTerm_oaModInstTerm(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstTerm_getOccInstTermsIter_doc[] = 
"Class: oaModInstTerm, Function: getOccInstTermsIter\n"
"  Paramegers: (oaOccurrence)\n"
"    Calls: oaIter_oaOccInstTerm getOccInstTermsIter(const oaOccurrence* top) const\n"
"    Signature: getOccInstTermsIter|simple-oaIter_oaOccInstTerm|cptr-oaOccurrence,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of oaOccInstTerm objects that represent this instTerm in the occurrence hierarchy specified by top .\n"
"    top\n"
"    The top oaOccurrence in the occurrence hierarchy.\n"
;

static PyObject*
oaModInstTerm_getOccInstTermsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstTerm data;
    int convert_status=PyoaModInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstTermObject* self=(PyoaModInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaOccurrence p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccurrence_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaIter_oaOccInstTerm* result= new oaIter_oaOccInstTerm(data.DataCall()->getOccInstTerms(p1.Data()));
        return PyoaIter_oaOccInstTerm_FromoaIter_oaOccInstTerm(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstTerm_getTerm_doc[] = 
"Class: oaModInstTerm, Function: getTerm\n"
"  Paramegers: ()\n"
"    Calls: oaModTerm* getTerm() const\n"
"    Signature: getTerm|ptr-oaModTerm|\n"
"    BrowseData: 1\n"
"    This function returns the terminal associated with this instTerm. An attempt is made to bind the master if the instTerm is unbound. NULL is returned if the instance is unbound or the terminal is not found in the master.\n"
;

static PyObject*
oaModInstTerm_getTerm(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstTerm data;
    int convert_status=PyoaModInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstTermObject* self=(PyoaModInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModTermp result= (data.DataCall()->getTerm());
        return PyoaModTerm_FromoaModTerm(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstTerm_getTermName_doc[] = 
"Class: oaModInstTerm, Function: getTermName\n"
"  Paramegers: (oaName)\n"
"    Calls: void getTermName(oaName& name) const\n"
"    Signature: getTermName|void-void|ref-oaName,\n"
"    BrowseData: 0,oaName\n"
"    This function returns the name of the terminal associated with this instTerm in the given name argument. A name is returned even if the instTerm is not bound. The existence of a terminal name does not guarantee that the terminal exists in the corresponding instance master.\n"
"    name\n"
"    The name object to return the terminal name in\n"
"    oacInstTermConnectsByPosition\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getTermName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getTermName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the name of the terminal associated with this instTerm in the nameSpace specified. A name is returned even if the instTerm is not bound. The existence of a terminal name does not necessarily guarantee that the corresponding terminal exists in the instance master.\n"
"    ns\n"
"    The nameSpace for processing the name\n"
"    name\n"
"    The string that the terminal name is returned in\n"
"    oacInstTermConnectsByPosition\n"
;

static PyObject*
oaModInstTerm_getTermName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstTerm data;
    int convert_status=PyoaModInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstTermObject* self=(PyoaModInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaName)
    {
        PyParamoaName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaName_Convert,&p1)) {
            data.DataCall()->getTermName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getTermName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModInstTerm, function: getTermName, Choices are:\n"
        "    (oaName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstTerm_getTermPosition_doc[] = 
"Class: oaModInstTerm, Function: getTermPosition\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getTermPosition() const\n"
"    Signature: getTermPosition|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the terminal position that this instTerm connects to. If this instTerm is not bound by position, the value oacNullIndex is returned.\n"
"    oacInstTermConnectsByName\n"
;

static PyObject*
oaModInstTerm_getTermPosition(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstTerm data;
    int convert_status=PyoaModInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstTermObject* self=(PyoaModInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getTermPosition());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstTerm_isBound_doc[] = 
"Class: oaModInstTerm, Function: isBound\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isBound() const\n"
"    Signature: isBound|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value that indicates if the instance associated with this instTerm is bound and if the associated terminal exists in the instance master.\n"
;

static PyObject*
oaModInstTerm_isBound(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstTerm data;
    int convert_status=PyoaModInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstTermObject* self=(PyoaModInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isBound());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstTerm_isImplicit_doc[] = 
"Class: oaModInstTerm, Function: isImplicit\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isImplicit() const\n"
"    Signature: isImplicit|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value indicating whether this instTerm is implicit, having been created as a result of the creation of a multi-bit instTerm.\n"
;

static PyObject*
oaModInstTerm_isImplicit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstTerm data;
    int convert_status=PyoaModInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstTermObject* self=(PyoaModInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isImplicit());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstTerm_removeFromNet_doc[] = 
"Class: oaModInstTerm, Function: removeFromNet\n"
"  Paramegers: ()\n"
"    Calls: void removeFromNet()\n"
"    Signature: removeFromNet|void-void|\n"
"    BrowseData: 0\n"
"    This function removes this instTerm from the net to which it is attached. If this instTerm is not attached to a net, this function does nothing.\n"
"    oacCannotModifyImplicitInstTerm\n"
;

static PyObject*
oaModInstTerm_removeFromNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstTerm data;
    int convert_status=PyoaModInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstTermObject* self=(PyoaModInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->removeFromNet();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstTerm_scalarize_doc[] = 
"Class: oaModInstTerm, Function: scalarize\n"
"  Paramegers: ()\n"
"    Calls: void scalarize()\n"
"    Signature: scalarize|void-void|\n"
"    BrowseData: 0\n"
"    This function insures that the bits associated of the connection formed by this instTerm are explicit and available to support implementation data.\n"
"    If this instTerm represents a single-bit connection, this function insures that this instTerm and its associated bitNet are explicit.\n"
"    If this instTerm represents a multibit connection, this function insures all corresponding single-bit connections are scalarized. That is, for each bit of the connection, the implicit instTerm and its associated bitNet are made explicit. After processing all of the bits in the connection, the instTerm is made implicit. This insures that no implementation data can be added to the instTerm. If the instTerm becomes implicit, any associated impmentation data is removed from it.\n"
"    oacCannotScalarizeImplicitInstTerm\n"
;

static PyObject*
oaModInstTerm_scalarize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstTerm data;
    int convert_status=PyoaModInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstTermObject* self=(PyoaModInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->scalarize();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstTerm_usesTermPosition_doc[] = 
"Class: oaModInstTerm, Function: usesTermPosition\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean usesTermPosition() const\n"
"    Signature: usesTermPosition|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether this instTerm was created to connect to a terminal position. This function returns 'true' if this instTerm binds to a particular terminal position. It returns 'false' if this instTerm binds to a terminal by name.\n"
;

static PyObject*
oaModInstTerm_usesTermPosition(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModInstTerm data;
    int convert_status=PyoaModInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModInstTermObject* self=(PyoaModInstTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->usesTermPosition());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstTerm_isNull_doc[] =
"Class: oaModInstTerm, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaModInstTerm_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaModInstTerm data;
    int convert_status=PyoaModInstTerm_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaModInstTerm_assign_doc[] = 
"Class: oaModInstTerm, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModInstTerm_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModInstTerm data;
  int convert_status=PyoaModInstTerm_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModInstTerm p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModInstTerm_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModInstTerm_methodlist[] = {
    {"addToNet",(PyCFunction)oaModInstTerm_addToNet,METH_VARARGS,oaModInstTerm_addToNet_doc},
    {"destroy",(PyCFunction)oaModInstTerm_destroy,METH_VARARGS,oaModInstTerm_destroy_doc},
    {"getBit",(PyCFunction)oaModInstTerm_getBit,METH_VARARGS,oaModInstTerm_getBit_doc},
    {"getInst",(PyCFunction)oaModInstTerm_getInst,METH_VARARGS,oaModInstTerm_getInst_doc},
    {"getNet",(PyCFunction)oaModInstTerm_getNet,METH_VARARGS,oaModInstTerm_getNet_doc},
    {"getNumBits",(PyCFunction)oaModInstTerm_getNumBits,METH_VARARGS,oaModInstTerm_getNumBits_doc},
    {"getOccInstTerms",(PyCFunction)oaModInstTerm_getOccInstTerms,METH_VARARGS,oaModInstTerm_getOccInstTerms_doc},
    {"getOccInstTermsIter",(PyCFunction)oaModInstTerm_getOccInstTermsIter,METH_VARARGS,oaModInstTerm_getOccInstTermsIter_doc},
    {"getTerm",(PyCFunction)oaModInstTerm_getTerm,METH_VARARGS,oaModInstTerm_getTerm_doc},
    {"getTermName",(PyCFunction)oaModInstTerm_getTermName,METH_VARARGS,oaModInstTerm_getTermName_doc},
    {"getTermPosition",(PyCFunction)oaModInstTerm_getTermPosition,METH_VARARGS,oaModInstTerm_getTermPosition_doc},
    {"isBound",(PyCFunction)oaModInstTerm_isBound,METH_VARARGS,oaModInstTerm_isBound_doc},
    {"isImplicit",(PyCFunction)oaModInstTerm_isImplicit,METH_VARARGS,oaModInstTerm_isImplicit_doc},
    {"removeFromNet",(PyCFunction)oaModInstTerm_removeFromNet,METH_VARARGS,oaModInstTerm_removeFromNet_doc},
    {"scalarize",(PyCFunction)oaModInstTerm_scalarize,METH_VARARGS,oaModInstTerm_scalarize_doc},
    {"usesTermPosition",(PyCFunction)oaModInstTerm_usesTermPosition,METH_VARARGS,oaModInstTerm_usesTermPosition_doc},
    {"isNull",(PyCFunction)oaModInstTerm_tp_isNull,METH_VARARGS,oaModInstTerm_isNull_doc},
    {"assign",(PyCFunction)oaModInstTerm_tp_assign,METH_VARARGS,oaModInstTerm_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModInstTerm_doc[] = 
"Class: oaModInstTerm\n"
"  The oaModInstTerm class is an abstract base for all types of connections between a net and a terminal in the master of an instance in the module domain. The connection is proper if the number of bits in the net is equal to the number of bits implied by the instTerm's terminal name. In the case of oaModVectorInsts the net width must be multiplied by the number of bits represented by the instance name.\n"
"  oaModInstTerm, oaOccInstTerm , and oaInstTerm each represent instances of terminals on a different kind of master, where in each case the master represents a level of hierarchy in the design.\n"
"  For oaModInstTerm, the master is an oaModule , and each instance of a module in a design will have a set of zero or more modInstTerms. For oaOccInstTerm , the master is an oaOccurrence . For oaInstTerm , the master is an oaBlock .\n"
"  Note that oaModInstTerm::getOccInstTerms will return oaOccInstTerms only if the occurrence hierarchy has been expanded to include those objects. See Working in the Occurrence Domain for more details.\n"
"  oaModInstTerms may exist that do not have a proper corresponding terminal in the master of the instance. This allows instTerms to be created when the instance master is not read in, and it allows changes to instTerms that happen before the master is updated. The traversal from an instTerm to its corresponding terminal will not succeed unless a terminal with an exactly matching name is present in the master.\n"
"  When oaInstTerm objects are created in the block domain, corresponding oaModInstTerm objects are automatically created in the module domain for oaInsts that are visible in the module domain.\n"
"  When an instTerm is created by specifying a terminal or terminal name, the instTerm is said to connect by name. Binding is done to the named terminal if it exists in the instance master. The width of the connection must match the width of the associated net. When an instTerm is created by specifying a terminal position, the instTerm is said to connect by position. Binding is to the terminal in the master that is assigned to the position and if the resulting connection width matches the width of the corresponding net. To avoid confusion, the instTerms associated with a particular instance must either all be connected by name or all by connected by position.\n"
"  The oaModInstTerm class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaModInstTerm)\n"
"    Calls: (const oaModInstTerm&)\n"
"    Signature: oaModInstTerm||cref-oaModInstTerm,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModInstTerm_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModInstTerm",
    sizeof(PyoaModInstTermObject),
    0,
    (destructor)oaModInstTerm_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModInstTerm_tp_compare,	/* tp_compare */
    (reprfunc)oaModInstTerm_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModInstTerm_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaModInstTerm_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaModObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModInstTerm_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModInstTerm_static_create_doc[] = 
"Class: oaModInstTerm, Function: create\n"
"  Paramegers: (oaModNet,oaModInst,oaModTerm)\n"
"    Calls: oaModInstTerm* create(oaModNet* net,oaModInst* inst,oaModTerm* term)\n"
"    Signature: create|ptr-oaModInstTerm|ptr-oaModNet,ptr-oaModInst,ptr-oaModTerm,\n"
"    This function creates an instTerm connecting the specified terminal in the master of the given instance to the specified net. You can specify a NULL net value.\n"
"    An oacInstTermNetMismatchInRepeatedMembers exception is thrown if repeated bundle instTerm bits connect to different nets.\n"
"    net\n"
"    The net to use for the connection; it may be NULL\n"
"    inst\n"
"    The instance to make the connection to\n"
"    term\n"
"    The terminal in the instance master to connect to\n"
"    A pointer to the instTerm created\n"
"    oacNetAndInstNotInSameDesign\n"
"    oacTermNotInInstMasterForInstTerm\n"
"    oacInstTermAlreadyExists\n"
"    oacNetInstTermWidthMismatchForInstTerm\n"
"    oacInstTermNetMismatchInRepeatedMembers\n"
"  Paramegers: (oaModNet,oaModInst,oaName)\n"
"    Calls: oaModInstTerm* create(oaModNet* net,oaModInst* inst,const oaName& termName)\n"
"    Signature: create|ptr-oaModInstTerm|ptr-oaModNet,ptr-oaModInst,cref-oaName,\n"
"    This function creates an instTerm connecting the named terminal in the master of the given instance to the specified net. You can specify a NULL net value. InstTerms can be created with names of terminals that do not exist in the instance master; these instTerms are unbound until the named terminal is created in the instance master.\n"
"    An oacInstTermNetMismatchInRepeatedMembers exception is thrown if repeated bundle instTerm bits connect to different nets.\n"
"    net\n"
"    The net to use for the connection; it may be NULL\n"
"    inst\n"
"    The instance to make the connection to\n"
"    termName\n"
"    The name of the terminal in the instance master to connect to\n"
"    A pointer to the instTerm created\n"
"    oacNetAndInstNotInSameDesign\n"
"    oacInstTermAlreadyExists\n"
"    oacNetInstTermWidthMismatchForInstTerm\n"
"    oacInstTermNetMismatchInRepeatedMembers\n"
"  Paramegers: (oaModNet,oaModInst,oaUInt4)\n"
"    Calls: oaModInstTerm* create(oaModNet* net,oaModInst* inst,oaUInt4 termPosition)\n"
"    Signature: create|ptr-oaModInstTerm|ptr-oaModNet,ptr-oaModInst,simple-oaUInt4,\n"
"    This function creates an instTerm connecting a terminal at the specified position in the master of the given instance to the specified net. You may specify a NULL net value.\n"
"    net\n"
"    The net to use for the connection; it may be NULL\n"
"    inst\n"
"    The instance to make the connection to\n"
"    termPosition\n"
"    The position of a terminal in the instance master to connect to\n"
"    oacNetAndInstNotInSameDesign\n"
"    oacInstTermAlreadyExists\n"
"  Paramegers: (oaModInst,oaModNetTermArray)\n"
"    Calls: void create(oaModInst* inst,const oaModNetTermArray& connData)\n"
"    Signature: create|void-void|ptr-oaModInst,cref-oaModNetTermArray,\n"
"    This function creates a set of modInstTerms, connecting the specified instance's terminals to the specified nets. The specifications for which nets are connected to which terminals are stored in an oaModNetTermArray (which associates net and term pointers).\n"
"    Exceptions are thrown if any net and the given instance are not in the same design, if any net is an implicit net, if any terminal is not in the instance master design, if an instance of any terminal already exists where the net is not NULL, or if a connection width does not match the number of bits in the net (if one is specified).\n"
"    inst\n"
"    The instance on which the instTerms are created\n"
"    connData\n"
"    An array of instTerm specifications where each entry in the array describes a specification that is used to create a single instTerm.\n"
"    oacInstTermBatchCreateHasInstTerms\n"
"  Paramegers: (oaModInst,oaModNetTermNameArray)\n"
"    Calls: void create(oaModInst* inst,const oaModNetTermNameArray& connData)\n"
"    Signature: create|void-void|ptr-oaModInst,cref-oaModNetTermNameArray,\n"
"    This function creates a set of modInstTerms, connecting the specified instance's terminals to the specified nets. The specifications for which nets are connected to which terminals are stored in an oaModNetTermNameArray (which associates net pointers with term names).\n"
"    Exceptions are thrown if any net and the given instance are not in the same design, if any net is an implicit net, if any terminal is not in the instance master design, if an instance of any terminal already exists where the net is not NULL, or if a connection width does not match the number of bits in the net (if one is specified).\n"
"    inst\n"
"    The instance on which the instTerms are created\n"
"    connData\n"
"    An array of instTerm specifications where each entry in the array describes a specification that is used to create a single instTerm.\n"
"    oacInstTermBatchCreateHasInstTerms\n"
"  Paramegers: (oaModInst,oaModNetTermPosArray)\n"
"    Calls: void create(oaModInst* inst,const oaModNetTermPosArray& connData)\n"
"    Signature: create|void-void|ptr-oaModInst,cref-oaModNetTermPosArray,\n"
"    This function creates a set of modInstTerms, connecting the specified instance's terminals to the specified nets. The specifications for which nets are connected to which terminals are stored in an oaModNetTermPosArray (which associates net pointers with term positions).\n"
"    Exceptions are thrown if any net and the given instance are not in the same design, if any net is an implicit net, if any terminal is not in the instance master design, if an instance of any terminal already exists where the net is not NULL, or if a connection width does not match the number of bits in the net (if one is specified).\n"
"    inst\n"
"    The instance on which the instTerms are created\n"
"    connData\n"
"    An array of instTerm specifications where each entry in the array describes a specification that is used to create a single instTerm.\n"
"    oacInstTermBatchCreateHasInstTerms\n"
;

static PyObject*
oaModInstTerm_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaModNet,oaModInst,oaModTerm)
    {
        PyParamoaModNet p1;
        PyParamoaModInst p2;
        PyParamoaModTerm p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaModNet_Convert,&p1,
              &PyoaModInst_Convert,&p2,
              &PyoaModTerm_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            if (!PyValidateDbObject(p3.Data(),3)) return NULL;
            oaModInstTermp result= (oaModInstTerm::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaModInstTerm_FromoaModInstTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModNet,oaModInst,oaName)
    {
        PyParamoaModNet p1;
        PyParamoaModInst p2;
        PyParamoaName p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaModNet_Convert,&p1,
              &PyoaModInst_Convert,&p2,
              &PyoaName_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaModInstTermp result= (oaModInstTerm::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaModInstTerm_FromoaModInstTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModNet,oaModInst,oaUInt4)
    {
        PyParamoaModNet p1;
        PyParamoaModInst p2;
        PyParamoaUInt4 p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaModNet_Convert,&p1,
              &PyoaModInst_Convert,&p2,
              &PyoaUInt4_Convert,&p3)) {
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaModInstTermp result= (oaModInstTerm::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaModInstTerm_FromoaModInstTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModInst,oaModNetTermArray)
    {
        PyParamoaModInst p1;
        PyParamoaModNetTermArray p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaModInst_Convert,&p1,
              &PyoaModNetTermArray_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModInstTerm::create(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaModInst,oaModNetTermNameArray)
    {
        PyParamoaModInst p1;
        PyParamoaModNetTermNameArray p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaModInst_Convert,&p1,
              &PyoaModNetTermNameArray_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModInstTerm::create(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaModInst,oaModNetTermPosArray)
    {
        PyParamoaModInst p1;
        PyParamoaModNetTermPosArray p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaModInst_Convert,&p1,
              &PyoaModNetTermPosArray_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModInstTerm::create(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModInstTerm, function: create, Choices are:\n"
        "    (oaModNet,oaModInst,oaModTerm)\n"
        "    (oaModNet,oaModInst,oaName)\n"
        "    (oaModNet,oaModInst,oaUInt4)\n"
        "    (oaModInst,oaModNetTermArray)\n"
        "    (oaModInst,oaModNetTermNameArray)\n"
        "    (oaModInst,oaModNetTermPosArray)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModInstTerm_static_find_doc[] = 
"Class: oaModInstTerm, Function: find\n"
"  Paramegers: (oaModInst,oaModTerm)\n"
"    Calls: oaModInstTerm* find(const oaModInst* inst,const oaModTerm* term)\n"
"    Signature: find|ptr-oaModInstTerm|cptr-oaModInst,cptr-oaModTerm,\n"
"    This function searches all of the instTerms associated with the specified instance and returns the one that is associated with the specified terminal. NULL is returned if no such terminal exists on the instance.\n"
"    inst\n"
"    The instance whose instTerms are searched\n"
"    term\n"
"    The terminal to use in the search\n"
"    oacTermNotInInstMasterForInstTerm\n"
"    oacInstTermInstUsesTermPosition\n"
"  Paramegers: (oaModInst,oaName)\n"
"    Calls: oaModInstTerm* find(const oaModInst* inst,const oaName& termName)\n"
"    Signature: find|ptr-oaModInstTerm|cptr-oaModInst,cref-oaName,\n"
"    This function searches all of the instTerms associated with the specified instance and returns the one that is associated with the specified terminal name. NULL is returned if no such terminal exists on the instance.\n"
"    If termName is hierarchical, then this function searches through the hierarchy path for the specified terminal. If termName is a bundle name, and any of its members has hierarchy, all of its members must have the same level of hierarchy or an exception is thrown.\n"
"    inst\n"
"    The instance whose instTerms are searched\n"
"    termName\n"
"    The terminal name to use in the search\n"
"    oacInstTermInstUsesTermPosition\n"
"    oacCannotDestroyImplicitInstTerm\n"
"  Paramegers: (oaModInst,oaUInt4)\n"
"    Calls: oaModInstTerm* find(const oaModInst* inst,oaUInt4 termPosition)\n"
"    Signature: find|ptr-oaModInstTerm|cptr-oaModInst,simple-oaUInt4,\n"
"    This function searches all of the instTerms associated with the specified instance and returns the one that makes a connection to the specified terminal position. NULL is returned if no terminal exists in the instance master at the specified position.\n"
"    inst\n"
"    The instance whose instTerms are searched\n"
"    termPosition\n"
"    The terminal position used in the search\n"
"    oacInstTermInstUsesTermName\n"
;

static PyObject*
oaModInstTerm_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaModInst,oaModTerm)
    {
        PyParamoaModInst p1;
        PyParamoaModTerm p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaModInst_Convert,&p1,
              &PyoaModTerm_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaModInstTermp result= (oaModInstTerm::find(p1.Data(),p2.Data()));
            return PyoaModInstTerm_FromoaModInstTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModInst,oaName)
    {
        PyParamoaModInst p1;
        PyParamoaName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaModInst_Convert,&p1,
              &PyoaName_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModInstTermp result= (oaModInstTerm::find(p1.Data(),p2.Data()));
            return PyoaModInstTerm_FromoaModInstTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModInst,oaUInt4)
    {
        PyParamoaModInst p1;
        PyParamoaUInt4 p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaModInst_Convert,&p1,
              &PyoaUInt4_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModInstTermp result= (oaModInstTerm::find(p1.Data(),p2.Data()));
            return PyoaModInstTerm_FromoaModInstTerm(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModInstTerm, function: find, Choices are:\n"
        "    (oaModInst,oaModTerm)\n"
        "    (oaModInst,oaName)\n"
        "    (oaModInst,oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaModInstTerm_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaModInstTerm_static_create,METH_VARARGS,oaModInstTerm_static_create_doc},
    {"static_find",(PyCFunction)oaModInstTerm_static_find,METH_VARARGS,oaModInstTerm_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModInstTerm_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModInstTerm_Type)<0) {
      printf("** PyType_Ready failed for: oaModInstTerm\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModInstTerm",
           (PyObject*)(&PyoaModInstTerm_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModInstTerm\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaModInstTerm_Type.tp_dict;
    for(method=oaModInstTerm_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModMemNetCollection
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModMemNetCollection_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModMemNetCollection_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModMemNetCollectionObject* self = (PyoaModMemNetCollectionObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModMemNetCollection, Choices are:\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModMemNetCollection_tp_dealloc(PyoaModMemNetCollectionObject* self)
{
    if (!self->borrow) {
        delete (oaModMemNetCollection*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModMemNetCollection_tp_repr(PyObject *ob)
{
    PyParamoaModMemNetCollection value;
    int convert_status=PyoaModMemNetCollection_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaModMemNetCollection::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModMemNetCollection_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModMemNetCollection v1;
    PyParamoaModMemNetCollection v2;
    int convert_status1=PyoaModMemNetCollection_Convert(ob1,&v1);
    int convert_status2=PyoaModMemNetCollection_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModMemNetCollection_Convert(PyObject* ob,PyParamoaModMemNetCollection* result)
{
    if (ob == NULL) return 1;
    if (PyoaModMemNetCollection_Check(ob)) {
        result->SetData( (oaModMemNetCollection*) ((PyoaModMemNetCollectionObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModMemNetCollection Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModMemNetCollection_FromoaModMemNetCollection(oaModMemNetCollection* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaModMemNetCollection_Type.tp_alloc(&PyoaModMemNetCollection_Type,0);
        if (bself == NULL) return bself;
        PyoaModMemNetCollectionObject* self = (PyoaModMemNetCollectionObject*)bself;
        self->value = (oaBaseMemNetCollection*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModMemNetCollection_includes_doc[] = 
"Class: oaModMemNetCollection, Function: includes\n"
"  Paramegers: (oaModNet)\n"
"    Calls: oaBoolean includes(const oaModNet* object)\n"
"    Signature: includes|simple-oaBoolean|cptr-oaModNet,\n"
"    This functions determines if the specified module net is a member of the collection.\n"
;

static PyObject*
oaModMemNetCollection_includes(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModMemNetCollection data;
    int convert_status=PyoaModMemNetCollection_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModMemNetCollectionObject* self=(PyoaModMemNetCollectionObject*)ob;

    PyParamoaModNet p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaModNet_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->includes(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaModMemNetCollection_assign_doc[] = 
"Class: oaModMemNetCollection, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModMemNetCollection_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModMemNetCollection data;
  int convert_status=PyoaModMemNetCollection_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModMemNetCollection p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModMemNetCollection_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModMemNetCollection_methodlist[] = {
    {"includes",(PyCFunction)oaModMemNetCollection_includes,METH_VARARGS,oaModMemNetCollection_includes_doc},
    {"assign",(PyCFunction)oaModMemNetCollection_tp_assign,METH_VARARGS,oaModMemNetCollection_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModMemNetCollection_doc[] = 
"Class: oaModMemNetCollection\n"
"  The member net collection class represents a collection of nets that the starting net is a member of. The oaModMemNetCollection is such a collection of oaModNet objects in the module domain. Examples are that a[1] is a member of a[4:0] . All explicit nets are members of themselves and so have a non-empty member net collection. See oaNet::getMemberNets() for a complete description of which nets are members of which other nets.\n"
"  The oaModMemNetCollection class is a specialized collection class because the oaModMemNetIter used to iterate over it does not have the standard getNext signature use by the template collection classes.\n"
"  The most common way to use an oaModMemNetCollection is to use it inline in the construction of an oaModMemNetIter , so the oaModMemNetCollection is never explicitly declared. In the following example, modnet->getMemberNets() returns an oaModMemNetCollection.\n"
"  oaModMemNetIter nIter(modnet->getMemberNets()); while ( oaModNet *mnet = nIter.getNext()) { ... }\n"
"Constructors:\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModMemNetCollection_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModMemNetCollection",
    sizeof(PyoaModMemNetCollectionObject),
    0,
    (destructor)oaModMemNetCollection_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModMemNetCollection_tp_compare,	/* tp_compare */
    (reprfunc)oaModMemNetCollection_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModMemNetCollection_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaModMemNetCollection_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaBaseMemNetCollection_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModMemNetCollection_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModMemNetCollection_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModMemNetCollection_Type)<0) {
      printf("** PyType_Ready failed for: oaModMemNetCollection\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModMemNetCollection",
           (PyObject*)(&PyoaModMemNetCollection_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModMemNetCollection\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModMemNetIter
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModMemNetIter_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModMemNetIter_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModMemNetIterObject* self = (PyoaModMemNetIterObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModMemNetCollection)
    {
        PyParamoaModMemNetCollection p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaModMemNetCollection_Convert,&p1)) {
            self->value = (oaBaseMemNetIter*)  new oaModMemNetIter(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaModMemNetIter)
    {
        PyParamoaModMemNetIter p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaModMemNetIter_Convert,&p1)) {
            self->value = (oaBaseMemNetIter*)  new oaModMemNetIter(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModMemNetIter, Choices are:\n"
        "    (oaModMemNetCollection)\n"
        "    (oaModMemNetIter)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModMemNetIter_tp_dealloc(PyoaModMemNetIterObject* self)
{
    if (!self->borrow) {
        delete (oaModMemNetIter*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModMemNetIter_tp_repr(PyObject *ob)
{
    PyParamoaModMemNetIter value;
    int convert_status=PyoaModMemNetIter_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[37];
    sprintf(buffer,"<oaModMemNetIter::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModMemNetIter_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModMemNetIter v1;
    PyParamoaModMemNetIter v2;
    int convert_status1=PyoaModMemNetIter_Convert(ob1,&v1);
    int convert_status2=PyoaModMemNetIter_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
static PyObject*
oaModMemNetIter_getiter(PyObject *self)
{
    Py_INCREF(self);
    return self;
}

// ------------------------------------------------------------------
PyObject* oaModMemNetIter_iternext(PyObject *self);

// ------------------------------------------------------------------
int
PyoaModMemNetIter_Convert(PyObject* ob,PyParamoaModMemNetIter* result)
{
    if (ob == NULL) return 1;
    if (PyoaModMemNetIter_Check(ob)) {
        result->SetData( (oaModMemNetIter*) ((PyoaModMemNetIterObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModMemNetIter Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModMemNetIter_FromoaModMemNetIter(oaModMemNetIter* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaModMemNetIter_Type.tp_alloc(&PyoaModMemNetIter_Type,0);
        if (bself == NULL) return bself;
        PyoaModMemNetIterObject* self = (PyoaModMemNetIterObject*)bself;
        self->value = (oaBaseMemNetIter*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModMemNetIter_getNext_doc[] = 
"Class: oaModMemNetIter, Function: getNext\n"
"  Paramegers: ()\n"
"    Calls: oaModNet* getNext()\n"
"    Signature: getNext|ptr-oaModNet|ref-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the next object in the collection that is being iterated. NULL is returned when there are no more objects to return.\n"
"    arg\n"
"    The member index of the current net in the returned net\n"
;

extern PyObject* oaModMemNetIter_getNext(PyObject *self, PyObject *args);

// ------------------------------------------------------------------
static char oaModMemNetIter_next_doc[] = 
"Class: oaModMemNetIter, Function: next\n"
"  Paramegers: ()\n"
"    Calls: oaModNet* next()\n"
"    Signature: next|ptr-oaModNet|,\n"
"    BrowseData: 1\n"
"    get next value or raise StopIteration\n"
;

extern PyObject* oaModMemNetIter_next(PyObject *self, PyObject *args);

static char oaModMemNetIter_assign_doc[] = 
"Class: oaModMemNetIter, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModMemNetIter_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModMemNetIter data;
  int convert_status=PyoaModMemNetIter_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModMemNetIter p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModMemNetIter_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModMemNetIter_methodlist[] = {
    {"getNext",(PyCFunction)oaModMemNetIter_getNext,METH_VARARGS,oaModMemNetIter_getNext_doc},
    {"next",(PyCFunction)oaModMemNetIter_next,METH_VARARGS,oaModMemNetIter_next_doc},
    {"assign",(PyCFunction)oaModMemNetIter_tp_assign,METH_VARARGS,oaModMemNetIter_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModMemNetIter_doc[] = 
"Class: oaModMemNetIter\n"
"  The oaModMemNetIter class implements a special case iterator. This class returns member oaNets of an oaModMemNetCollection . A collection of member nets is all those nets of whom the current net is a member. Because all nets are members of themselves, this iterator will always return at least one net.\n"
"  For example, a collection of member nets for net a would contain all of the following nets:\n"
"  a\n"
"  x,y,a\n"
"  a*4\n"
"  The member net index is returned in the getNext() function. This index indicates the member position of the specified net in the collection. For the example above, the iterator would return the following values:\n"
"  a 0\n"
"  x,y,a 2\n"
"  a*4 0\n"
"  a*4 1\n"
"  a*4 2\n"
"  a*4 3\n"
"  This particular collection and iterator are primarily for those applications that want to traverse single-bit connectivity.\n"
"Constructors:\n"
"  Paramegers: (oaModMemNetCollection)\n"
"    Calls: oaModMemNetIter(const oaModMemNetCollection& cl)\n"
"    Signature: oaModMemNetIter||cref-oaModMemNetCollection,\n"
"    This function constructs a new oaModMemNetIter object according to the specified memNet collection cl .\n"
"    cl\n"
"    The specified oaModMemNetCollection object\n"
"  Paramegers: (oaModMemNetIter)\n"
"    Calls: oaModMemNetIter(const oaModMemNetIter& iterIn)\n"
"    Signature: oaModMemNetIter||cref-oaModMemNetIter,\n"
"    This function constructs a new oaModMemNetIter class and iterates over the same set of objects as the specified oaModMemNetIter iterator. The new iterator starts at the beginning of the collection.\n"
"    iterIn\n"
"    The iterator value to use\n"
"  Paramegers: (oaModMemNetIter)\n"
"    Calls: (const oaModMemNetIter&)\n"
"    Signature: oaModMemNetIter||cref-oaModMemNetIter,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModMemNetIter_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModMemNetIter",
    sizeof(PyoaModMemNetIterObject),
    0,
    (destructor)oaModMemNetIter_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModMemNetIter_tp_compare,	/* tp_compare */
    (reprfunc)oaModMemNetIter_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModMemNetIter_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    (getiterfunc)oaModMemNetIter_getiter,	/* tp_iter */
    (iternextfunc)oaModMemNetIter_iternext,	/* tp_iternext */
    oaModMemNetIter_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaBaseMemNetIter_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModMemNetIter_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModMemNetIter_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModMemNetIter_Type)<0) {
      printf("** PyType_Ready failed for: oaModMemNetIter\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModMemNetIter",
           (PyObject*)(&PyoaModMemNetIter_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModMemNetIter\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModModuleBitInst
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModModuleBitInst_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModModuleBitInst_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModModuleBitInstObject* self = (PyoaModModuleBitInstObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModModuleBitInst)
    {
        PyParamoaModModuleBitInst p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModModuleBitInst_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModModuleBitInst, Choices are:\n"
        "    (oaModModuleBitInst)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModModuleBitInst_tp_dealloc(PyoaModModuleBitInstObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModModuleBitInst_tp_repr(PyObject *ob)
{
    PyParamoaModModuleBitInst value;
    int convert_status=PyoaModModuleBitInst_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaModModuleBitInst::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaSimpleName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[40];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaModModuleBitInst::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModModuleBitInst_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModModuleBitInst v1;
    PyParamoaModModuleBitInst v2;
    int convert_status1=PyoaModModuleBitInst_Convert(ob1,&v1);
    int convert_status2=PyoaModModuleBitInst_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModModuleBitInst_Convert(PyObject* ob,PyParamoaModModuleBitInst* result)
{
    if (ob == NULL) return 1;
    if (PyoaModModuleBitInst_Check(ob)) {
        result->SetData( (oaModModuleBitInst**) ((PyoaModModuleBitInstObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModModuleBitInst Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModModuleBitInst_FromoaModModuleBitInst(oaModModuleBitInst** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaModModuleBitInst* data=*value;
        if (data->getType()==oacModModuleScalarInstType) return PyoaModModuleScalarInst_FromoaModModuleScalarInst((oaModModuleScalarInst**)value,borrow,lock);
        if (data->getType()==oacModModuleVectorInstBitType) return PyoaModModuleVectorInstBit_FromoaModModuleVectorInstBit((oaModModuleVectorInstBit**)value,borrow,lock);
        PyObject* bself = PyoaModModuleBitInst_Type.tp_alloc(&PyoaModModuleBitInst_Type,0);
        if (bself == NULL) return bself;
        PyoaModModuleBitInstObject* self = (PyoaModModuleBitInstObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaModModuleBitInst_FromoaModModuleBitInst(oaModModuleBitInst* data)
{
    if (data) {
        if (data->getType()==oacModModuleScalarInstType) return PyoaModModuleScalarInst_FromoaModModuleScalarInst((oaModModuleScalarInst*)data);
        if (data->getType()==oacModModuleVectorInstBitType) return PyoaModModuleVectorInstBit_FromoaModModuleVectorInstBit((oaModModuleVectorInstBit*)data);
       PyObject* bself = PyoaModModuleBitInst_Type.tp_alloc(&PyoaModModuleBitInst_Type,0);
       if (bself == NULL) return bself;
       PyoaModModuleBitInstObject* self = (PyoaModModuleBitInstObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModModuleBitInst_doc[] = 
"Class: oaModModuleBitInst\n"
"  The oaModModuleBitInst class is a base class for scalar instances of a module master in a parent module within the module domain.\n"
"  oaModModuleBitInst objects refer to a master oaModule and are scoped to their parent module.\n"
"Constructors:\n"
"  Paramegers: (oaModModuleBitInst)\n"
"    Calls: (const oaModModuleBitInst&)\n"
"    Signature: oaModModuleBitInst||cref-oaModModuleBitInst,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModModuleBitInst_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModModuleBitInst",
    sizeof(PyoaModModuleBitInstObject),
    0,
    (destructor)oaModModuleBitInst_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModModuleBitInst_tp_compare,	/* tp_compare */
    (reprfunc)oaModModuleBitInst_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModModuleBitInst_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaModModuleInst_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModModuleBitInst_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModModuleBitInst_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModModuleBitInst_Type)<0) {
      printf("** PyType_Ready failed for: oaModModuleBitInst\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModModuleBitInst",
           (PyObject*)(&PyoaModModuleBitInst_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModModuleBitInst\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModModuleInst
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModModuleInst_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModModuleInst_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModModuleInstObject* self = (PyoaModModuleInstObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModModuleInst)
    {
        PyParamoaModModuleInst p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModModuleInst_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModModuleInst, Choices are:\n"
        "    (oaModModuleInst)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModModuleInst_tp_dealloc(PyoaModModuleInstObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModModuleInst_tp_repr(PyObject *ob)
{
    PyParamoaModModuleInst value;
    int convert_status=PyoaModModuleInst_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaModModuleInst::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaSimpleName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[37];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaModModuleInst::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModModuleInst_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModModuleInst v1;
    PyParamoaModModuleInst v2;
    int convert_status1=PyoaModModuleInst_Convert(ob1,&v1);
    int convert_status2=PyoaModModuleInst_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModModuleInst_Convert(PyObject* ob,PyParamoaModModuleInst* result)
{
    if (ob == NULL) return 1;
    if (PyoaModModuleInst_Check(ob)) {
        result->SetData( (oaModModuleInst**) ((PyoaModModuleInstObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModModuleInst Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModModuleInst_FromoaModModuleInst(oaModModuleInst** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaModModuleInst* data=*value;
        if (data->getType()==oacModModuleScalarInstType) return PyoaModModuleScalarInst_FromoaModModuleScalarInst((oaModModuleScalarInst**)value,borrow,lock);
        if (data->getType()==oacModModuleVectorInstBitType) return PyoaModModuleVectorInstBit_FromoaModModuleVectorInstBit((oaModModuleVectorInstBit**)value,borrow,lock);
        if (data->getType()==oacModModuleVectorInstType) return PyoaModModuleVectorInst_FromoaModModuleVectorInst((oaModModuleVectorInst**)value,borrow,lock);
        PyObject* bself = PyoaModModuleInst_Type.tp_alloc(&PyoaModModuleInst_Type,0);
        if (bself == NULL) return bself;
        PyoaModModuleInstObject* self = (PyoaModModuleInstObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaModModuleInst_FromoaModModuleInst(oaModModuleInst* data)
{
    if (data) {
        if (data->getType()==oacModModuleScalarInstType) return PyoaModModuleScalarInst_FromoaModModuleScalarInst((oaModModuleScalarInst*)data);
        if (data->getType()==oacModModuleVectorInstBitType) return PyoaModModuleVectorInstBit_FromoaModModuleVectorInstBit((oaModModuleVectorInstBit*)data);
        if (data->getType()==oacModModuleVectorInstType) return PyoaModModuleVectorInst_FromoaModModuleVectorInst((oaModModuleVectorInst*)data);
       PyObject* bself = PyoaModModuleInst_Type.tp_alloc(&PyoaModModuleInst_Type,0);
       if (bself == NULL) return bself;
       PyoaModModuleInstObject* self = (PyoaModModuleInstObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModModuleInst_getHeader_doc[] = 
"Class: oaModModuleInst, Function: getHeader\n"
"  Paramegers: ()\n"
"    Calls: oaModModuleInstHeader* getHeader() const\n"
"    Signature: getHeader|ptr-oaModModuleInstHeader|\n"
"    BrowseData: 1\n"
"    This function returns the instHeader associated with this instance. The module instHeader is a collection of the attributes that are common to all instances of a particular module master.\n"
"    The pointer to the instance header\n"
;

static PyObject*
oaModModuleInst_getHeader(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModModuleInst data;
    int convert_status=PyoaModModuleInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModModuleInstObject* self=(PyoaModModuleInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModModuleInstHeaderp result= (data.DataCall()->getHeader());
        return PyoaModModuleInstHeader_FromoaModModuleInstHeader(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleInst_isNull_doc[] =
"Class: oaModModuleInst, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaModModuleInst_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaModModuleInst data;
    int convert_status=PyoaModModuleInst_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaModModuleInst_assign_doc[] = 
"Class: oaModModuleInst, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModModuleInst_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModModuleInst data;
  int convert_status=PyoaModModuleInst_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModModuleInst p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModModuleInst_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModModuleInst_methodlist[] = {
    {"getHeader",(PyCFunction)oaModModuleInst_getHeader,METH_VARARGS,oaModModuleInst_getHeader_doc},
    {"isNull",(PyCFunction)oaModModuleInst_tp_isNull,METH_VARARGS,oaModModuleInst_isNull_doc},
    {"assign",(PyCFunction)oaModModuleInst_tp_assign,METH_VARARGS,oaModModuleInst_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModModuleInst_doc[] = 
"Class: oaModModuleInst\n"
"  The oaModModuleInst class is a base for instances of a module master in a parent module within the module domain.\n"
"  oaModModuleInst objects refer to a master oaModule and are scoped to their parent module.\n"
"Constructors:\n"
"  Paramegers: (oaModModuleInst)\n"
"    Calls: (const oaModModuleInst&)\n"
"    Signature: oaModModuleInst||cref-oaModModuleInst,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModModuleInst_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModModuleInst",
    sizeof(PyoaModModuleInstObject),
    0,
    (destructor)oaModModuleInst_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModModuleInst_tp_compare,	/* tp_compare */
    (reprfunc)oaModModuleInst_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModModuleInst_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaModModuleInst_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaModInst_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModModuleInst_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModModuleInst_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModModuleInst_Type)<0) {
      printf("** PyType_Ready failed for: oaModModuleInst\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModModuleInst",
           (PyObject*)(&PyoaModModuleInst_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModModuleInst\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModModuleInstHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModModuleInstHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModModuleInstHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModModuleInstHeaderObject* self = (PyoaModModuleInstHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModModuleInstHeader)
    {
        PyParamoaModModuleInstHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModModuleInstHeader_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModModuleInstHeader, Choices are:\n"
        "    (oaModModuleInstHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModModuleInstHeader_tp_dealloc(PyoaModModuleInstHeaderObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModModuleInstHeader_tp_repr(PyObject *ob)
{
    PyParamoaModModuleInstHeader value;
    int convert_status=PyoaModModuleInstHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaModModuleInstHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModModuleInstHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModModuleInstHeader v1;
    PyParamoaModModuleInstHeader v2;
    int convert_status1=PyoaModModuleInstHeader_Convert(ob1,&v1);
    int convert_status2=PyoaModModuleInstHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModModuleInstHeader_Convert(PyObject* ob,PyParamoaModModuleInstHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaModModuleInstHeader_Check(ob)) {
        result->SetData( (oaModModuleInstHeader**) ((PyoaModModuleInstHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModModuleInstHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModModuleInstHeader_FromoaModModuleInstHeader(oaModModuleInstHeader** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaModModuleInstHeader* data=*value;
        PyObject* bself = PyoaModModuleInstHeader_Type.tp_alloc(&PyoaModModuleInstHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaModModuleInstHeaderObject* self = (PyoaModModuleInstHeaderObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaModModuleInstHeader_FromoaModModuleInstHeader(oaModModuleInstHeader* data)
{
    if (data) {
       PyObject* bself = PyoaModModuleInstHeader_Type.tp_alloc(&PyoaModModuleInstHeader_Type,0);
       if (bself == NULL) return bself;
       PyoaModModuleInstHeaderObject* self = (PyoaModModuleInstHeaderObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModModuleInstHeader_getInsts_doc[] = 
"Class: oaModModuleInstHeader, Function: getInsts\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaModModuleInst_oaModModuleInstHeader getInsts() const\n"
"    Signature: getInsts|simple-oaCollection_oaModModuleInst_oaModModuleInstHeader|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns a collection of module instances associated with this instHeader. These instances refer to master modules embedded within the containing design. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaModModuleInst_oaModModuleInstHeader getInsts(oaUInt4 filterFlags) const\n"
"    Signature: getInsts|simple-oaCollection_oaModModuleInst_oaModModuleInstHeader|simple-oaUInt4,\n"
"    This function returns a collection of module instances associated with this instHeader. These instances refer to master modules embedded within the containing design. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
;

static PyObject*
oaModModuleInstHeader_getInsts(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModModuleInstHeader data;
    int convert_status=PyoaModModuleInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModModuleInstHeaderObject* self=(PyoaModModuleInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaModModuleInst_oaModModuleInstHeader* result= new oaCollection_oaModModuleInst_oaModModuleInstHeader(data.DataCall()->getInsts());
            return PyoaCollection_oaModModuleInst_oaModModuleInstHeader_FromoaCollection_oaModModuleInst_oaModModuleInstHeader(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaModModuleInst_oaModModuleInstHeader* result= new oaCollection_oaModModuleInst_oaModModuleInstHeader(data.DataCall()->getInsts(p1.Data()));
            return PyoaCollection_oaModModuleInst_oaModModuleInstHeader_FromoaCollection_oaModModuleInst_oaModModuleInstHeader(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModModuleInstHeader, function: getInsts, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleInstHeader_getInstsIter_doc[] = 
"Class: oaModModuleInstHeader, Function: getInstsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaModModuleInst getInstsIter() const\n"
"    Signature: getInstsIter|simple-oaIter_oaModModuleInst|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of module instances associated with this instHeader. These instances refer to master modules embedded within the containing design. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaModModuleInst getInstsIter(oaUInt4 filterFlags) const\n"
"    Signature: getInstsIter|simple-oaIter_oaModModuleInst|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of module instances associated with this instHeader. These instances refer to master modules embedded within the containing design. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
;

static PyObject*
oaModModuleInstHeader_getInstsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModModuleInstHeader data;
    int convert_status=PyoaModModuleInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModModuleInstHeaderObject* self=(PyoaModModuleInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaModModuleInst* result= new oaIter_oaModModuleInst(data.DataCall()->getInsts());
            return PyoaIter_oaModModuleInst_FromoaIter_oaModModuleInst(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaModModuleInst* result= new oaIter_oaModModuleInst(data.DataCall()->getInsts(p1.Data()));
            return PyoaIter_oaModModuleInst_FromoaIter_oaModModuleInst(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModModuleInstHeader, function: getInstsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleInstHeader_getMasterModule_doc[] = 
"Class: oaModModuleInstHeader, Function: getMasterModule\n"
"  Paramegers: ()\n"
"    Calls: oaModule* getMasterModule() const\n"
"    Signature: getMasterModule|ptr-oaModule|\n"
"    BrowseData: 1\n"
"    This function attempts to return the master module associated with this module instHeader. If the instHeader is bound, the master module is returned. Otherwise, NULL is returned.\n"
;

static PyObject*
oaModModuleInstHeader_getMasterModule(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModModuleInstHeader data;
    int convert_status=PyoaModModuleInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModModuleInstHeaderObject* self=(PyoaModModuleInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModulep result= (data.DataCall()->getMasterModule());
        return PyoaModule_FromoaModule(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleInstHeader_getName_doc[] = 
"Class: oaModModuleInstHeader, Function: getName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getName(oaScalarName& name) const\n"
"    Signature: getName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the name referenced by this instHeader. The second version returns the name in the nameSpace specified.\n"
"    name\n"
"    The master module name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the name referenced by this instHeader. The second version returns the name in the nameSpace specified.\n"
"    ns\n"
"    The namespace for the name\n"
"    name\n"
"    The master module name\n"
;

static PyObject*
oaModModuleInstHeader_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModModuleInstHeader data;
    int convert_status=PyoaModModuleInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModModuleInstHeaderObject* self=(PyoaModModuleInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModModuleInstHeader, function: getName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleInstHeader_isBound_doc[] = 
"Class: oaModModuleInstHeader, Function: isBound\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isBound() const\n"
"    Signature: isBound|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value that indicates if this instHeader is bound to its master module. A bound master means the master is read in and the linkage from the instHeader is established by traversing from an instance to that master.\n"
;

static PyObject*
oaModModuleInstHeader_isBound(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModModuleInstHeader data;
    int convert_status=PyoaModModuleInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModModuleInstHeaderObject* self=(PyoaModModuleInstHeaderObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isBound());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleInstHeader_isNull_doc[] =
"Class: oaModModuleInstHeader, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaModModuleInstHeader_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaModModuleInstHeader data;
    int convert_status=PyoaModModuleInstHeader_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaModModuleInstHeader_assign_doc[] = 
"Class: oaModModuleInstHeader, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModModuleInstHeader_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModModuleInstHeader data;
  int convert_status=PyoaModModuleInstHeader_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModModuleInstHeader p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModModuleInstHeader_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModModuleInstHeader_methodlist[] = {
    {"getInsts",(PyCFunction)oaModModuleInstHeader_getInsts,METH_VARARGS,oaModModuleInstHeader_getInsts_doc},
    {"getInstsIter",(PyCFunction)oaModModuleInstHeader_getInstsIter,METH_VARARGS,oaModModuleInstHeader_getInstsIter_doc},
    {"getMasterModule",(PyCFunction)oaModModuleInstHeader_getMasterModule,METH_VARARGS,oaModModuleInstHeader_getMasterModule_doc},
    {"getName",(PyCFunction)oaModModuleInstHeader_getName,METH_VARARGS,oaModModuleInstHeader_getName_doc},
    {"isBound",(PyCFunction)oaModModuleInstHeader_isBound,METH_VARARGS,oaModModuleInstHeader_isBound_doc},
    {"isNull",(PyCFunction)oaModModuleInstHeader_tp_isNull,METH_VARARGS,oaModModuleInstHeader_isNull_doc},
    {"assign",(PyCFunction)oaModModuleInstHeader_tp_assign,METH_VARARGS,oaModModuleInstHeader_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModModuleInstHeader_doc[] = 
"Class: oaModModuleInstHeader\n"
"  The oaModModuleInstHeader class implements an object that contains information common to all the logical instances of a particular master module in a given parent module. oaModModuleInstHeader objects are scoped within the parent module.\n"
"  The oaModModuleInstHeader class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaModModuleInstHeader)\n"
"    Calls: (const oaModModuleInstHeader&)\n"
"    Signature: oaModModuleInstHeader||cref-oaModModuleInstHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModModuleInstHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModModuleInstHeader",
    sizeof(PyoaModModuleInstHeaderObject),
    0,
    (destructor)oaModModuleInstHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModModuleInstHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaModModuleInstHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModModuleInstHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaModModuleInstHeader_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaModObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModModuleInstHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModModuleInstHeader_static_find_doc[] = 
"Class: oaModModuleInstHeader, Function: find\n"
"  Paramegers: (oaModule,oaModule)\n"
"    Calls: oaModModuleInstHeader* find(const oaModule* module,const oaModule* master)\n"
"    Signature: find|ptr-oaModModuleInstHeader|cptr-oaModule,cptr-oaModule,\n"
"    This function searches the specified module for an instHeader with the specified master module. If the specified master is a pCell, the superHeader is returned.\n"
"  Paramegers: (oaModule,oaScalarName)\n"
"    Calls: oaModModuleInstHeader* find(const oaModule* module,const oaScalarName& masterModuleName)\n"
"    Signature: find|ptr-oaModModuleInstHeader|cptr-oaModule,cref-oaScalarName,\n"
"    This function searches the specified module looking for an instHeader with the specified master module name.\n"
"    module\n"
"    The module to be searched\n"
"    masterModuleName\n"
"    The name of the master module\n"
;

static PyObject*
oaModModuleInstHeader_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaModule,oaModule)
    {
        PyParamoaModule p1;
        PyParamoaModule p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaModule_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaModModuleInstHeaderp result= (oaModModuleInstHeader::find(p1.Data(),p2.Data()));
            return PyoaModModuleInstHeader_FromoaModModuleInstHeader(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaScalarName)
    {
        PyParamoaModule p1;
        PyParamoaScalarName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaScalarName_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModModuleInstHeaderp result= (oaModModuleInstHeader::find(p1.Data(),p2.Data()));
            return PyoaModModuleInstHeader_FromoaModModuleInstHeader(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModModuleInstHeader, function: find, Choices are:\n"
        "    (oaModule,oaModule)\n"
        "    (oaModule,oaScalarName)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaModModuleInstHeader_staticmethodlist[] = {
    {"static_find",(PyCFunction)oaModModuleInstHeader_static_find,METH_VARARGS,oaModModuleInstHeader_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModModuleInstHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModModuleInstHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaModModuleInstHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModModuleInstHeader",
           (PyObject*)(&PyoaModModuleInstHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModModuleInstHeader\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaModModuleInstHeader_Type.tp_dict;
    for(method=oaModModuleInstHeader_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModModuleScalarInst
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModModuleScalarInst_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModModuleScalarInst_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModModuleScalarInstObject* self = (PyoaModModuleScalarInstObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModModuleScalarInst)
    {
        PyParamoaModModuleScalarInst p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModModuleScalarInst_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModModuleScalarInst, Choices are:\n"
        "    (oaModModuleScalarInst)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModModuleScalarInst_tp_dealloc(PyoaModModuleScalarInstObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModModuleScalarInst_tp_repr(PyObject *ob)
{
    PyParamoaModModuleScalarInst value;
    int convert_status=PyoaModModuleScalarInst_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaModModuleScalarInst::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaSimpleName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[43];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaModModuleScalarInst::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModModuleScalarInst_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModModuleScalarInst v1;
    PyParamoaModModuleScalarInst v2;
    int convert_status1=PyoaModModuleScalarInst_Convert(ob1,&v1);
    int convert_status2=PyoaModModuleScalarInst_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModModuleScalarInst_Convert(PyObject* ob,PyParamoaModModuleScalarInst* result)
{
    if (ob == NULL) return 1;
    if (PyoaModModuleScalarInst_Check(ob)) {
        result->SetData( (oaModModuleScalarInst**) ((PyoaModModuleScalarInstObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModModuleScalarInst Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModModuleScalarInst_FromoaModModuleScalarInst(oaModModuleScalarInst** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaModModuleScalarInst* data=*value;
        PyObject* bself = PyoaModModuleScalarInst_Type.tp_alloc(&PyoaModModuleScalarInst_Type,0);
        if (bself == NULL) return bself;
        PyoaModModuleScalarInstObject* self = (PyoaModModuleScalarInstObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaModModuleScalarInst_FromoaModModuleScalarInst(oaModModuleScalarInst* data)
{
    if (data) {
       PyObject* bself = PyoaModModuleScalarInst_Type.tp_alloc(&PyoaModModuleScalarInst_Type,0);
       if (bself == NULL) return bself;
       PyoaModModuleScalarInstObject* self = (PyoaModModuleScalarInstObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModModuleScalarInst_getName_doc[] = 
"Class: oaModModuleScalarInst, Function: getName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getName(oaScalarName& name) const\n"
"    Signature: getName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the name of this scalarModuleInst in the name argument.\n"
"  Paramegers: (oaSimpleName)\n"
"    Calls: void getName(oaSimpleName& name) const\n"
"    Signature: getName|void-void|ref-oaSimpleName,\n"
"    BrowseData: 0,oaSimpleName\n"
"    This function fills out name with the name of this instance.\n"
"    name\n"
"    The returned instance name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function fills out name with the name of this instance. The name is mapped according to the specified nameSpace.\n"
"    ns\n"
"    The nameSpace used to map the name\n"
"    name\n"
"    The returned instance name\n"
;

static PyObject*
oaModModuleScalarInst_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModModuleScalarInst data;
    int convert_status=PyoaModModuleScalarInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModModuleScalarInstObject* self=(PyoaModModuleScalarInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName)
    {
        PyParamoaSimpleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSimpleName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModModuleScalarInst, function: getName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaSimpleName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleScalarInst_setName_doc[] = 
"Class: oaModModuleScalarInst, Function: setName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void setName(const oaScalarName& name)\n"
"    Signature: setName|void-void|cref-oaScalarName,\n"
"    This function changes the name of this instance to the specified name .\n"
"    Exceptions are thrown if:\n"
"    the new name does not imply a scalar name\n"
"    an instance already exists with the given name\n"
"    a vectorInstDef exists with the given name\n"
"    name\n"
"    The new name to be set for this instance.\n"
"    oacInvalidHierInstName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
;

static PyObject*
oaModModuleScalarInst_setName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModModuleScalarInst data;
    int convert_status=PyoaModModuleScalarInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModModuleScalarInstObject* self=(PyoaModModuleScalarInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScalarName p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaScalarName_Convert,&p1)) {
        data.DataCall()->setName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleScalarInst_isNull_doc[] =
"Class: oaModModuleScalarInst, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaModModuleScalarInst_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaModModuleScalarInst data;
    int convert_status=PyoaModModuleScalarInst_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaModModuleScalarInst_assign_doc[] = 
"Class: oaModModuleScalarInst, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModModuleScalarInst_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModModuleScalarInst data;
  int convert_status=PyoaModModuleScalarInst_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModModuleScalarInst p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModModuleScalarInst_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModModuleScalarInst_methodlist[] = {
    {"getName",(PyCFunction)oaModModuleScalarInst_getName,METH_VARARGS,oaModModuleScalarInst_getName_doc},
    {"setName",(PyCFunction)oaModModuleScalarInst_setName,METH_VARARGS,oaModModuleScalarInst_setName_doc},
    {"isNull",(PyCFunction)oaModModuleScalarInst_tp_isNull,METH_VARARGS,oaModModuleScalarInst_isNull_doc},
    {"assign",(PyCFunction)oaModModuleScalarInst_tp_assign,METH_VARARGS,oaModModuleScalarInst_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModModuleScalarInst_doc[] = 
"Class: oaModModuleScalarInst\n"
"  The oaModModuleScalarInst class implements a scalar instance of a module master in a module hierarchy. The module containing the instance, the instance, and its master are always contained with the same oaDesign .\n"
"Constructors:\n"
"  Paramegers: (oaModModuleScalarInst)\n"
"    Calls: (const oaModModuleScalarInst&)\n"
"    Signature: oaModModuleScalarInst||cref-oaModModuleScalarInst,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModModuleScalarInst_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModModuleScalarInst",
    sizeof(PyoaModModuleScalarInstObject),
    0,
    (destructor)oaModModuleScalarInst_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModModuleScalarInst_tp_compare,	/* tp_compare */
    (reprfunc)oaModModuleScalarInst_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModModuleScalarInst_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaModModuleScalarInst_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaModModuleBitInst_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModModuleScalarInst_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModModuleScalarInst_static_create_doc[] = 
"Class: oaModModuleScalarInst, Function: create\n"
"  Paramegers: (oaModule,oaModule,oaScalarName)\n"
"    Calls: oaModModuleScalarInst* create(oaModule* module,oaModule* master,const oaScalarName& name)\n"
"    Signature: create|ptr-oaModModuleScalarInst|ptr-oaModule,ptr-oaModule,cref-oaScalarName,\n"
"    This function creates an oaModModuleScalarInst object with the specified attributes. This form of the create specifies the master module so that the master module needs to exist to use it.\n"
"    Exceptions are thrown if:\n"
"    the new name does not imply a scalar name\n"
"    an instance already exists with the given name\n"
"    a vectorInstDef exists with the given name\n"
"    module\n"
"    The module in which to create the instance\n"
"    master\n"
"    The master for the instance\n"
"    name\n"
"    The instance name\n"
"    oacModulesNotInSameDesign\n"
"    oacInvalidHierInstName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"  Paramegers: (oaModule,oaModule)\n"
"    Calls: oaModModuleScalarInst* create(oaModule* module,oaModule* master)\n"
"    Signature: create|ptr-oaModModuleScalarInst|ptr-oaModule,ptr-oaModule,\n"
"    This function creates an oaModModuleScalarInst object with the specified attributes. This form of the create requires an existing master module. The name of the instance is automatically generated.\n"
"    module\n"
"    The parent module in which to create the instance\n"
"    master\n"
"    The master for the instance\n"
"    oacModulesNotInSameDesign\n"
"  Paramegers: (oaModule,oaScalarName,oaScalarName)\n"
"    Calls: oaModModuleScalarInst* create(oaModule* module,const oaScalarName& masterModName,const oaScalarName& name)\n"
"    Signature: create|ptr-oaModModuleScalarInst|ptr-oaModule,cref-oaScalarName,cref-oaScalarName,\n"
"    This function creates an oaModModuleScalarInst object with the specified attributes. This form of the create specifies the name of the master module so that the master module does not need to exist to use it.\n"
"    Exceptions are thrown if:\n"
"    the new name does not imply a scalar name\n"
"    an instance already exists with the given name\n"
"    a vectorInstDef exists with the given name\n"
"    module\n"
"    The module in which to create the instance\n"
"    masterModuleName\n"
"    The name of the master module\n"
"    name\n"
"    The name of the instance\n"
"    oacInvalidHierInstName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"  Paramegers: (oaModule,oaScalarName)\n"
"    Calls: oaModModuleScalarInst* create(oaModule* module,const oaScalarName& masterModName)\n"
"    Signature: create|ptr-oaModModuleScalarInst|ptr-oaModule,cref-oaScalarName,\n"
"    This function creates an oaModModuleScalarInst object with the specified attributes. This form of the create specifies the name of the master module so that the master module does not need to exist to use it. The name of the instance is automatically generated.\n"
"    module\n"
"    The module in which to create the instance\n"
"    masterModuleName\n"
"    The name of the master module\n"
;

static PyObject*
oaModModuleScalarInst_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaModule,oaModule,oaScalarName)
    {
        PyParamoaModule p1;
        PyParamoaModule p2;
        PyParamoaScalarName p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaModule_Convert,&p2,
              &PyoaScalarName_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaModModuleScalarInstp result= (oaModModuleScalarInst::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaModModuleScalarInst_FromoaModModuleScalarInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaModule)
    {
        PyParamoaModule p1;
        PyParamoaModule p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaModule_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaModModuleScalarInstp result= (oaModModuleScalarInst::create(p1.Data(),p2.Data()));
            return PyoaModModuleScalarInst_FromoaModModuleScalarInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaScalarName,oaScalarName)
    {
        PyParamoaModule p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModModuleScalarInstp result= (oaModModuleScalarInst::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaModModuleScalarInst_FromoaModModuleScalarInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaScalarName)
    {
        PyParamoaModule p1;
        PyParamoaScalarName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaScalarName_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModModuleScalarInstp result= (oaModModuleScalarInst::create(p1.Data(),p2.Data()));
            return PyoaModModuleScalarInst_FromoaModModuleScalarInst(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModModuleScalarInst, function: create, Choices are:\n"
        "    (oaModule,oaModule,oaScalarName)\n"
        "    (oaModule,oaModule)\n"
        "    (oaModule,oaScalarName,oaScalarName)\n"
        "    (oaModule,oaScalarName)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleScalarInst_static_find_doc[] = 
"Class: oaModModuleScalarInst, Function: find\n"
"  Paramegers: (oaModule,oaScalarName)\n"
"    Calls: oaModModuleScalarInst* find(const oaModule* module,const oaScalarName& name)\n"
"    Signature: find|ptr-oaModModuleScalarInst|cptr-oaModule,cref-oaScalarName,\n"
"    This function searches the specified module for a module scalar inst with the specified name. The function returns the instance if it finds one. Otherwise, NULL is returned.\n"
"    module\n"
"    The module in which to search for the instance\n"
"    name\n"
"    The instance name\n"
"    The oaModModuleScalarInst pointer or NULL\n"
;

static PyObject*
oaModModuleScalarInst_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaModule_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaModModuleScalarInstp result= (oaModModuleScalarInst::find(p1.Data(),p2.Data()));
        return PyoaModModuleScalarInst_FromoaModModuleScalarInst(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleScalarInst_static_isValidName_doc[] = 
"Class: oaModModuleScalarInst, Function: isValidName\n"
"  Paramegers: (oaModule,oaScalarName)\n"
"    Calls: oaBoolean isValidName(const oaModule* module,const oaScalarName& name)\n"
"    Signature: isValidName|simple-oaBoolean|cptr-oaModule,cref-oaScalarName,\n"
"    This function returns a boolean value that indicates if the specified name is valid for a new oaModModuleScalarInst in the specified module .\n"
"    module\n"
"    The module in which to validate the name\n"
"    name\n"
"    The instance name to validate\n"
;

static PyObject*
oaModModuleScalarInst_static_isValidName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaModule_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (oaModModuleScalarInst::isValidName(p1.Data(),p2.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaModModuleScalarInst_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaModModuleScalarInst_static_create,METH_VARARGS,oaModModuleScalarInst_static_create_doc},
    {"static_find",(PyCFunction)oaModModuleScalarInst_static_find,METH_VARARGS,oaModModuleScalarInst_static_find_doc},
    {"static_isValidName",(PyCFunction)oaModModuleScalarInst_static_isValidName,METH_VARARGS,oaModModuleScalarInst_static_isValidName_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModModuleScalarInst_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModModuleScalarInst_Type)<0) {
      printf("** PyType_Ready failed for: oaModModuleScalarInst\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModModuleScalarInst",
           (PyObject*)(&PyoaModModuleScalarInst_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModModuleScalarInst\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaModModuleScalarInst_Type.tp_dict;
    for(method=oaModModuleScalarInst_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModModuleVectorInst
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModModuleVectorInst_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModModuleVectorInst_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModModuleVectorInstObject* self = (PyoaModModuleVectorInstObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModModuleVectorInst)
    {
        PyParamoaModModuleVectorInst p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModModuleVectorInst_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModModuleVectorInst, Choices are:\n"
        "    (oaModModuleVectorInst)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModModuleVectorInst_tp_dealloc(PyoaModModuleVectorInstObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModModuleVectorInst_tp_repr(PyObject *ob)
{
    PyParamoaModModuleVectorInst value;
    int convert_status=PyoaModModuleVectorInst_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaModModuleVectorInst::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaSimpleName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[43];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaModModuleVectorInst::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModModuleVectorInst_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModModuleVectorInst v1;
    PyParamoaModModuleVectorInst v2;
    int convert_status1=PyoaModModuleVectorInst_Convert(ob1,&v1);
    int convert_status2=PyoaModModuleVectorInst_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModModuleVectorInst_Convert(PyObject* ob,PyParamoaModModuleVectorInst* result)
{
    if (ob == NULL) return 1;
    if (PyoaModModuleVectorInst_Check(ob)) {
        result->SetData( (oaModModuleVectorInst**) ((PyoaModModuleVectorInstObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModModuleVectorInst Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModModuleVectorInst_FromoaModModuleVectorInst(oaModModuleVectorInst** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaModModuleVectorInst* data=*value;
        PyObject* bself = PyoaModModuleVectorInst_Type.tp_alloc(&PyoaModModuleVectorInst_Type,0);
        if (bself == NULL) return bself;
        PyoaModModuleVectorInstObject* self = (PyoaModModuleVectorInstObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaModModuleVectorInst_FromoaModModuleVectorInst(oaModModuleVectorInst* data)
{
    if (data) {
       PyObject* bself = PyoaModModuleVectorInst_Type.tp_alloc(&PyoaModModuleVectorInst_Type,0);
       if (bself == NULL) return bself;
       PyoaModModuleVectorInstObject* self = (PyoaModModuleVectorInstObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModModuleVectorInst_getBit_doc[] = 
"Class: oaModModuleVectorInst, Function: getBit\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaModModuleVectorInstBit* getBit(oaUInt4 bitIndex) const\n"
"    Signature: getBit|ptr-oaModModuleVectorInstBit|simple-oaUInt4,\n"
"    This function returns a pointer to the vectorInstBit that corresponds to the specified bitIndex bit of this vectorInst. For example, if this is a vectorInst \"i[7:0]\" and bitIndex is zero, this function will return the vectorInstBit corresponding to \"i[7]\".\n"
"    bitIndex\n"
"    Specifies which bit of the instance to return\n"
"    A pointer to an oaModModuleVectorInstBit\n"
"    oacInvalidBitIndexIntoInst\n"
;

static PyObject*
oaModModuleVectorInst_getBit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModModuleVectorInst data;
    int convert_status=PyoaModModuleVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModModuleVectorInstObject* self=(PyoaModModuleVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaModModuleVectorInstBitp result= (data.DataCall()->getBit(p1.Data()));
        return PyoaModModuleVectorInstBit_FromoaModModuleVectorInstBit(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleVectorInst_getDef_doc[] = 
"Class: oaModModuleVectorInst, Function: getDef\n"
"  Paramegers: ()\n"
"    Calls: oaModVectorInstDef* getDef() const\n"
"    Signature: getDef|ptr-oaModVectorInstDef|\n"
"    BrowseData: 1\n"
"    This function returns the module vectorInstDef for this module vectorInst. The module vectorInstDef is used to access all module vectorInts with the same baseName.\n"
;

static PyObject*
oaModModuleVectorInst_getDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModModuleVectorInst data;
    int convert_status=PyoaModModuleVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModModuleVectorInstObject* self=(PyoaModModuleVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModVectorInstDefp result= (data.DataCall()->getDef());
        return PyoaModVectorInstDef_FromoaModVectorInstDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleVectorInst_getName_doc[] = 
"Class: oaModModuleVectorInst, Function: getName\n"
"  Paramegers: (oaVectorName)\n"
"    Calls: void getName(oaVectorName& name) const\n"
"    Signature: getName|void-void|ref-oaVectorName,\n"
"    BrowseData: 0,oaVectorName\n"
"    This function returns the vectorName of this modModuleVectorInst.\n"
"    name\n"
"    The name of the modModuleVectorInst to return\n"
"  Paramegers: (oaSimpleName)\n"
"    Calls: void getName(oaSimpleName& name) const\n"
"    Signature: getName|void-void|ref-oaSimpleName,\n"
"    BrowseData: 0,oaSimpleName\n"
"    This function fills out name with the name of this instance.\n"
"    name\n"
"    The returned instance name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function fills out name with the name of this instance. The name is mapped according to the specified nameSpace.\n"
"    ns\n"
"    The nameSpace used to map the name\n"
"    name\n"
"    The returned instance name\n"
;

static PyObject*
oaModModuleVectorInst_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModModuleVectorInst data;
    int convert_status=PyoaModModuleVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModModuleVectorInstObject* self=(PyoaModModuleVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaVectorName)
    {
        PyParamoaVectorName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName)
    {
        PyParamoaSimpleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSimpleName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModModuleVectorInst, function: getName, Choices are:\n"
        "    (oaVectorName)\n"
        "    (oaSimpleName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleVectorInst_getStart_doc[] = 
"Class: oaModModuleVectorInst, Function: getStart\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getStart() const\n"
"    Signature: getStart|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the start index of this module vectorInst.\n"
;

static PyObject*
oaModModuleVectorInst_getStart(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModModuleVectorInst data;
    int convert_status=PyoaModModuleVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModModuleVectorInstObject* self=(PyoaModModuleVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getStart());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleVectorInst_getStop_doc[] = 
"Class: oaModModuleVectorInst, Function: getStop\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getStop() const\n"
"    Signature: getStop|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the stop index of this module vectorInst.\n"
;

static PyObject*
oaModModuleVectorInst_getStop(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModModuleVectorInst data;
    int convert_status=PyoaModModuleVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModModuleVectorInstObject* self=(PyoaModModuleVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getStop());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleVectorInst_setBaseName_doc[] = 
"Class: oaModModuleVectorInst, Function: setBaseName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void setBaseName(const oaScalarName& baseName)\n"
"    Signature: setBaseName|void-void|cref-oaScalarName,\n"
"    This function changes the base name of this vectorInst. Exceptions are thrown if the new name is the name of an existing scalar, an arrayInst, or if another vectorInst exists whose indices overlap with this vectorInst, or if the given baseName matches the form of the system-generated scalarInst name.\n"
"    baseName\n"
"    The new base name to give this instance\n"
"    oacCannotSetNameOfImplicitInst\n"
;

static PyObject*
oaModModuleVectorInst_setBaseName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModModuleVectorInst data;
    int convert_status=PyoaModModuleVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModModuleVectorInstObject* self=(PyoaModModuleVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScalarName p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaScalarName_Convert,&p1)) {
        data.DataCall()->setBaseName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleVectorInst_setRange_doc[] = 
"Class: oaModModuleVectorInst, Function: setRange\n"
"  Paramegers: (oaUInt4,oaUInt4)\n"
"    Calls: void setRange(oaUInt4 start,oaUInt4 stop)\n"
"    Signature: setRange|void-void|simple-oaUInt4,simple-oaUInt4,\n"
"    This function sets the start and stop bit indices of this vectorInst.\n"
"    start\n"
"    The new start value to give this instance\n"
"    stop\n"
"    The new stop value to give this instance\n"
"    oacInstNameOverlapsOtherInst\n"
"    oacCannotSetNameOfImplicitInst\n"
"    oacInvalidBusStartStopRange\n"
;

static PyObject*
oaModModuleVectorInst_setRange(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModModuleVectorInst data;
    int convert_status=PyoaModModuleVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModModuleVectorInstObject* self=(PyoaModModuleVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2)) {
        data.DataCall()->setRange(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleVectorInst_isNull_doc[] =
"Class: oaModModuleVectorInst, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaModModuleVectorInst_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaModModuleVectorInst data;
    int convert_status=PyoaModModuleVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaModModuleVectorInst_assign_doc[] = 
"Class: oaModModuleVectorInst, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModModuleVectorInst_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModModuleVectorInst data;
  int convert_status=PyoaModModuleVectorInst_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModModuleVectorInst p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModModuleVectorInst_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModModuleVectorInst_methodlist[] = {
    {"getBit",(PyCFunction)oaModModuleVectorInst_getBit,METH_VARARGS,oaModModuleVectorInst_getBit_doc},
    {"getDef",(PyCFunction)oaModModuleVectorInst_getDef,METH_VARARGS,oaModModuleVectorInst_getDef_doc},
    {"getName",(PyCFunction)oaModModuleVectorInst_getName,METH_VARARGS,oaModModuleVectorInst_getName_doc},
    {"getStart",(PyCFunction)oaModModuleVectorInst_getStart,METH_VARARGS,oaModModuleVectorInst_getStart_doc},
    {"getStop",(PyCFunction)oaModModuleVectorInst_getStop,METH_VARARGS,oaModModuleVectorInst_getStop_doc},
    {"setBaseName",(PyCFunction)oaModModuleVectorInst_setBaseName,METH_VARARGS,oaModModuleVectorInst_setBaseName_doc},
    {"setRange",(PyCFunction)oaModModuleVectorInst_setRange,METH_VARARGS,oaModModuleVectorInst_setRange_doc},
    {"isNull",(PyCFunction)oaModModuleVectorInst_tp_isNull,METH_VARARGS,oaModModuleVectorInst_isNull_doc},
    {"assign",(PyCFunction)oaModModuleVectorInst_tp_assign,METH_VARARGS,oaModModuleVectorInst_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModModuleVectorInst_doc[] = 
"Class: oaModModuleVectorInst\n"
"  The oaModModuleVectorInst class implements a vector instance of a module master in a module hierarchy. A vector instance represents several copies of the instance master with a range of index numbers to differentiate them.\n"
"  An oaModModuleVectorInst object is always in the module domain. It is an instance of a module as opposed to an oaModVectorInst which would be a vector instance of a design.\n"
"Constructors:\n"
"  Paramegers: (oaModModuleVectorInst)\n"
"    Calls: (const oaModModuleVectorInst&)\n"
"    Signature: oaModModuleVectorInst||cref-oaModModuleVectorInst,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModModuleVectorInst_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModModuleVectorInst",
    sizeof(PyoaModModuleVectorInstObject),
    0,
    (destructor)oaModModuleVectorInst_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModModuleVectorInst_tp_compare,	/* tp_compare */
    (reprfunc)oaModModuleVectorInst_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModModuleVectorInst_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaModModuleVectorInst_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaModModuleInst_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModModuleVectorInst_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModModuleVectorInst_static_create_doc[] = 
"Class: oaModModuleVectorInst, Function: create\n"
"  Paramegers: (oaModule,oaModule,oaScalarName,oaUInt4,oaUInt4)\n"
"    Calls: oaModModuleVectorInst* create(oaModule* module,oaModule* master,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop)\n"
"    Signature: create|ptr-oaModModuleVectorInst|ptr-oaModule,ptr-oaModule,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,\n"
"    This function creates an oaModModuleVectorInst object with the specified attributes. This form of the create specifies the master module so that the master module needs to be exist to use it. Exceptions are thrown if the new name is the name of an existing scalarInst, vectorInst, or an arrayInst.\n"
"    module\n"
"    The parent module in which to create the instance\n"
"    master\n"
"    The master module the instance refers o\n"
"    baseName\n"
"    The base name for the instance\n"
"    start\n"
"    The start index for the instance range\n"
"    stop\n"
"    The stop index for the instance range\n"
"    oacModulesNotInSameDesign\n"
"    oacVectorInstNameMatchesAutoName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"    oacInvalidHierInstName\n"
"    oacVectorDefInstMustBeModuleInst\n"
"    oacVectorDefIsBlockDomainSpecific\n"
"  Paramegers: (oaModule,oaScalarName,oaScalarName,oaUInt4,oaUInt4)\n"
"    Calls: oaModModuleVectorInst* create(oaModule* module,const oaScalarName& masterModuleName,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop)\n"
"    Signature: create|ptr-oaModModuleVectorInst|ptr-oaModule,cref-oaScalarName,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,\n"
"    This function creates an oaModModuleVectorInst object with the specified attributes. This form of the create specifies the name of the master module so that the master module does not need to be exist to use it. Exceptions are thrown if the new name is the name of an existing scalarInst, vectorInst, or an arrayInst.\n"
"    module\n"
"    The module in which to create the instance\n"
"    masterModuleName\n"
"    The name of the master module\n"
"    baseName\n"
"    The base name for the instance\n"
"    start\n"
"    The start index of the instance range\n"
"    stop\n"
"    The stop index of the instance range\n"
"    oacVectorInstNameMatchesAutoName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"    oacInvalidHierInstName\n"
"    oacVectorDefInstMustBeModuleInst\n"
"    oacVectorDefIsBlockDomainSpecific\n"
;

static PyObject*
oaModModuleVectorInst_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaModule,oaModule,oaScalarName,oaUInt4,oaUInt4)
    {
        PyParamoaModule p1;
        PyParamoaModule p2;
        PyParamoaScalarName p3;
        PyParamoaUInt4 p4;
        PyParamoaUInt4 p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaModule_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaUInt4_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaModModuleVectorInstp result= (oaModModuleVectorInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
            return PyoaModModuleVectorInst_FromoaModModuleVectorInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaScalarName,oaScalarName,oaUInt4,oaUInt4)
    {
        PyParamoaModule p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaUInt4 p4;
        PyParamoaUInt4 p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaUInt4_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModModuleVectorInstp result= (oaModModuleVectorInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
            return PyoaModModuleVectorInst_FromoaModModuleVectorInst(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModModuleVectorInst, function: create, Choices are:\n"
        "    (oaModule,oaModule,oaScalarName,oaUInt4,oaUInt4)\n"
        "    (oaModule,oaScalarName,oaScalarName,oaUInt4,oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleVectorInst_static_find_doc[] = 
"Class: oaModModuleVectorInst, Function: find\n"
"  Paramegers: (oaModule,oaScalarName,oaUInt4,oaUInt4)\n"
"    Calls: oaModModuleVectorInst* find(const oaModule* module,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop)\n"
"    Signature: find|ptr-oaModModuleVectorInst|cptr-oaModule,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,\n"
"    This function searches the specified module for a module vectorInst with the specified name. The function returns the instance if it finds one. Otherwise, NULL is returned.\n"
"    module\n"
"    The module in which to search for the instance\n"
"    baseName\n"
"    The base name of the instance to look for\n"
"    start\n"
"    The start index of the instance to look for\n"
"    stop\n"
"    The stop index of the instance to look for\n"
;

static PyObject*
oaModModuleVectorInst_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule p1;
    PyParamoaScalarName p2;
    PyParamoaUInt4 p3;
    PyParamoaUInt4 p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaModule_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaUInt4_Convert,&p3,
          &PyoaUInt4_Convert,&p4)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaModModuleVectorInstp result= (oaModModuleVectorInst::find(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
        return PyoaModModuleVectorInst_FromoaModModuleVectorInst(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleVectorInst_static_isValidName_doc[] = 
"Class: oaModModuleVectorInst, Function: isValidName\n"
"  Paramegers: (oaModule,oaScalarName,oaUInt4,oaUInt4)\n"
"    Calls: oaBoolean isValidName(const oaModule* module,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop)\n"
"    Signature: isValidName|simple-oaBoolean|cptr-oaModule,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,\n"
"    This function returns a boolean value that indicates if the specified baseName , combined with the start and stop values, is a valid new oaModModuleVectorInst in the specified module .\n"
"    module\n"
"    The module to check the name against\n"
"    baseName\n"
"    The base name of the instance\n"
"    start\n"
"    The start index of the instance\n"
"    stop\n"
"    The stop index of the instance\n"
;

static PyObject*
oaModModuleVectorInst_static_isValidName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule p1;
    PyParamoaScalarName p2;
    PyParamoaUInt4 p3;
    PyParamoaUInt4 p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaModule_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaUInt4_Convert,&p3,
          &PyoaUInt4_Convert,&p4)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (oaModModuleVectorInst::isValidName(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaModModuleVectorInst_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaModModuleVectorInst_static_create,METH_VARARGS,oaModModuleVectorInst_static_create_doc},
    {"static_find",(PyCFunction)oaModModuleVectorInst_static_find,METH_VARARGS,oaModModuleVectorInst_static_find_doc},
    {"static_isValidName",(PyCFunction)oaModModuleVectorInst_static_isValidName,METH_VARARGS,oaModModuleVectorInst_static_isValidName_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModModuleVectorInst_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModModuleVectorInst_Type)<0) {
      printf("** PyType_Ready failed for: oaModModuleVectorInst\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModModuleVectorInst",
           (PyObject*)(&PyoaModModuleVectorInst_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModModuleVectorInst\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaModModuleVectorInst_Type.tp_dict;
    for(method=oaModModuleVectorInst_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModModuleVectorInstBit
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModModuleVectorInstBit_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModModuleVectorInstBit_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModModuleVectorInstBitObject* self = (PyoaModModuleVectorInstBitObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModModuleVectorInstBit)
    {
        PyParamoaModModuleVectorInstBit p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModModuleVectorInstBit_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModModuleVectorInstBit, Choices are:\n"
        "    (oaModModuleVectorInstBit)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModModuleVectorInstBit_tp_dealloc(PyoaModModuleVectorInstBitObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModModuleVectorInstBit_tp_repr(PyObject *ob)
{
    PyParamoaModModuleVectorInstBit value;
    int convert_status=PyoaModModuleVectorInstBit_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaModModuleVectorInstBit::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaSimpleName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[46];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaModModuleVectorInstBit::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModModuleVectorInstBit_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModModuleVectorInstBit v1;
    PyParamoaModModuleVectorInstBit v2;
    int convert_status1=PyoaModModuleVectorInstBit_Convert(ob1,&v1);
    int convert_status2=PyoaModModuleVectorInstBit_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModModuleVectorInstBit_Convert(PyObject* ob,PyParamoaModModuleVectorInstBit* result)
{
    if (ob == NULL) return 1;
    if (PyoaModModuleVectorInstBit_Check(ob)) {
        result->SetData( (oaModModuleVectorInstBit**) ((PyoaModModuleVectorInstBitObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModModuleVectorInstBit Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModModuleVectorInstBit_FromoaModModuleVectorInstBit(oaModModuleVectorInstBit** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaModModuleVectorInstBit* data=*value;
        PyObject* bself = PyoaModModuleVectorInstBit_Type.tp_alloc(&PyoaModModuleVectorInstBit_Type,0);
        if (bself == NULL) return bself;
        PyoaModModuleVectorInstBitObject* self = (PyoaModModuleVectorInstBitObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaModModuleVectorInstBit_FromoaModModuleVectorInstBit(oaModModuleVectorInstBit* data)
{
    if (data) {
       PyObject* bself = PyoaModModuleVectorInstBit_Type.tp_alloc(&PyoaModModuleVectorInstBit_Type,0);
       if (bself == NULL) return bself;
       PyoaModModuleVectorInstBitObject* self = (PyoaModModuleVectorInstBitObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModModuleVectorInstBit_getBitIndex_doc[] = 
"Class: oaModModuleVectorInstBit, Function: getBitIndex\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getBitIndex() const\n"
"    Signature: getBitIndex|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the bitIndex of this vectorInstBit.\n"
;

static PyObject*
oaModModuleVectorInstBit_getBitIndex(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModModuleVectorInstBit data;
    int convert_status=PyoaModModuleVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModModuleVectorInstBitObject* self=(PyoaModModuleVectorInstBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getBitIndex());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleVectorInstBit_getDef_doc[] = 
"Class: oaModModuleVectorInstBit, Function: getDef\n"
"  Paramegers: ()\n"
"    Calls: oaModVectorInstDef* getDef() const\n"
"    Signature: getDef|ptr-oaModVectorInstDef|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the vectorInstDef for this vectorInstBit.\n"
;

static PyObject*
oaModModuleVectorInstBit_getDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModModuleVectorInstBit data;
    int convert_status=PyoaModModuleVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModModuleVectorInstBitObject* self=(PyoaModModuleVectorInstBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModVectorInstDefp result= (data.DataCall()->getDef());
        return PyoaModVectorInstDef_FromoaModVectorInstDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleVectorInstBit_getName_doc[] = 
"Class: oaModModuleVectorInstBit, Function: getName\n"
"  Paramegers: (oaVectorBitName)\n"
"    Calls: void getName(oaVectorBitName& name) const\n"
"    Signature: getName|void-void|ref-oaVectorBitName,\n"
"    BrowseData: 0,oaVectorBitName\n"
"    This function returns the vectorName of this modModuleVectorInstBit.\n"
"    name\n"
"    The name fo the modModuleVectorInstBit to return\n"
"  Paramegers: (oaSimpleName)\n"
"    Calls: void getName(oaSimpleName& name) const\n"
"    Signature: getName|void-void|ref-oaSimpleName,\n"
"    BrowseData: 0,oaSimpleName\n"
"    This function fills out name with the name of this instance.\n"
"    name\n"
"    The returned instance name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function fills out name with the name of this instance. The name is mapped according to the specified nameSpace.\n"
"    ns\n"
"    The nameSpace used to map the name\n"
"    name\n"
"    The returned instance name\n"
;

static PyObject*
oaModModuleVectorInstBit_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModModuleVectorInstBit data;
    int convert_status=PyoaModModuleVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModModuleVectorInstBitObject* self=(PyoaModModuleVectorInstBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaVectorBitName)
    {
        PyParamoaVectorBitName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorBitName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName)
    {
        PyParamoaSimpleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSimpleName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModModuleVectorInstBit, function: getName, Choices are:\n"
        "    (oaVectorBitName)\n"
        "    (oaSimpleName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleVectorInstBit_setName_doc[] = 
"Class: oaModModuleVectorInstBit, Function: setName\n"
"  Paramegers: (oaScalarName,oaUInt4)\n"
"    Calls: void setName(const oaScalarName& baseName,oaUInt4 bitIndex)\n"
"    Signature: setName|void-void|cref-oaScalarName,simple-oaUInt4,\n"
"    This function changes the name of this vectorInstBit. An exception is thrown if the new baseName is the name of an existing scalar or array instance or if a vectorInstBit already exists with the new name. An exception is also thrown if the new name would overlap with existing vectorInsts.\n"
"    baseName\n"
"    The new base name for this instance\n"
"    bitIndex\n"
"    The new bit index for this instance\n"
"    oacCannotSetNameOfImplicitInst\n"
;

static PyObject*
oaModModuleVectorInstBit_setName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModModuleVectorInstBit data;
    int convert_status=PyoaModModuleVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModModuleVectorInstBitObject* self=(PyoaModModuleVectorInstBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScalarName p1;
    PyParamoaUInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaScalarName_Convert,&p1,
          &PyoaUInt4_Convert,&p2)) {
        data.DataCall()->setName(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleVectorInstBit_isNull_doc[] =
"Class: oaModModuleVectorInstBit, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaModModuleVectorInstBit_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaModModuleVectorInstBit data;
    int convert_status=PyoaModModuleVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaModModuleVectorInstBit_assign_doc[] = 
"Class: oaModModuleVectorInstBit, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModModuleVectorInstBit_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModModuleVectorInstBit data;
  int convert_status=PyoaModModuleVectorInstBit_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModModuleVectorInstBit p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModModuleVectorInstBit_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModModuleVectorInstBit_methodlist[] = {
    {"getBitIndex",(PyCFunction)oaModModuleVectorInstBit_getBitIndex,METH_VARARGS,oaModModuleVectorInstBit_getBitIndex_doc},
    {"getDef",(PyCFunction)oaModModuleVectorInstBit_getDef,METH_VARARGS,oaModModuleVectorInstBit_getDef_doc},
    {"getName",(PyCFunction)oaModModuleVectorInstBit_getName,METH_VARARGS,oaModModuleVectorInstBit_getName_doc},
    {"setName",(PyCFunction)oaModModuleVectorInstBit_setName,METH_VARARGS,oaModModuleVectorInstBit_setName_doc},
    {"isNull",(PyCFunction)oaModModuleVectorInstBit_tp_isNull,METH_VARARGS,oaModModuleVectorInstBit_isNull_doc},
    {"assign",(PyCFunction)oaModModuleVectorInstBit_tp_assign,METH_VARARGS,oaModModuleVectorInstBit_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModModuleVectorInstBit_doc[] = 
"Class: oaModModuleVectorInstBit\n"
"  The oaModModuleVectorInstBit class implements a single bit of a module vectorInst in a module. VectorInstBits are automatically created and destroyed as vectorInsts are created or destroyed. Implicitly-created vectorInstBits cannot be modified to insure consistency with its defining vectorInst.\n"
"  Explicitly-created vectorInstBits define a unique bit of a vectorInst definition since the bits of a vectorInst are not allowed to overlap with other vectorInsts.\n"
"Constructors:\n"
"  Paramegers: (oaModModuleVectorInstBit)\n"
"    Calls: (const oaModModuleVectorInstBit&)\n"
"    Signature: oaModModuleVectorInstBit||cref-oaModModuleVectorInstBit,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModModuleVectorInstBit_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModModuleVectorInstBit",
    sizeof(PyoaModModuleVectorInstBitObject),
    0,
    (destructor)oaModModuleVectorInstBit_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModModuleVectorInstBit_tp_compare,	/* tp_compare */
    (reprfunc)oaModModuleVectorInstBit_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModModuleVectorInstBit_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaModModuleVectorInstBit_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaModModuleBitInst_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModModuleVectorInstBit_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModModuleVectorInstBit_static_create_doc[] = 
"Class: oaModModuleVectorInstBit, Function: create\n"
"  Paramegers: (oaModule,oaModule,oaScalarName,oaUInt4)\n"
"    Calls: oaModModuleVectorInstBit* create(oaModule* module,oaModule* master,const oaScalarName& baseName,oaUInt4 bitIndex)\n"
"    Signature: create|ptr-oaModModuleVectorInstBit|ptr-oaModule,ptr-oaModule,cref-oaScalarName,simple-oaUInt4,\n"
"    This function creates an oaModModuleVectorInstBit object with the specified attributes. The given baseName and bitIndex are checked if they are legal and do not specify an instance that already exists. This version creates an instance of the specified master module.\n"
"    module\n"
"    The module to create the instance in\n"
"    master\n"
"    The master module to instantiate\n"
"    baseName\n"
"    The base name to give the instance\n"
"    bitIndex\n"
"    The bit index to give the instance\n"
"    oacInvalidHierInstName\n"
"    oacVectorInstBitNameMatchesAutoName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"  Paramegers: (oaModule,oaScalarName,oaScalarName,oaUInt4)\n"
"    Calls: oaModModuleVectorInstBit* create(oaModule* module,const oaScalarName& masterName,const oaScalarName& baseName,oaUInt4 bitIndex)\n"
"    Signature: create|ptr-oaModModuleVectorInstBit|ptr-oaModule,cref-oaScalarName,cref-oaScalarName,simple-oaUInt4,\n"
"    This function creates an oaModModuleVectorInstBit object with the specified attributes. The given baseName and bitIndex are checked if they are legal and do not specify an instance that already exists. This version creates an instance of the master implied by the specified module name.\n"
"    module\n"
"    The module to create the instance in\n"
"    masterName\n"
"    The name of the master module\n"
"    baseName\n"
"    The base name to give the instance\n"
"    bitIndex\n"
"    The bit index to give the instance\n"
"    oacInvalidHierInstName\n"
"    oacVectorInstBitNameMatchesAutoName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
;

static PyObject*
oaModModuleVectorInstBit_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaModule,oaModule,oaScalarName,oaUInt4)
    {
        PyParamoaModule p1;
        PyParamoaModule p2;
        PyParamoaScalarName p3;
        PyParamoaUInt4 p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaModule_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaUInt4_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaModModuleVectorInstBitp result= (oaModModuleVectorInstBit::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaModModuleVectorInstBit_FromoaModModuleVectorInstBit(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaScalarName,oaScalarName,oaUInt4)
    {
        PyParamoaModule p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaUInt4 p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaUInt4_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModModuleVectorInstBitp result= (oaModModuleVectorInstBit::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaModModuleVectorInstBit_FromoaModModuleVectorInstBit(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModModuleVectorInstBit, function: create, Choices are:\n"
        "    (oaModule,oaModule,oaScalarName,oaUInt4)\n"
        "    (oaModule,oaScalarName,oaScalarName,oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleVectorInstBit_static_find_doc[] = 
"Class: oaModModuleVectorInstBit, Function: find\n"
"  Paramegers: (oaModule,oaScalarName,oaUInt4)\n"
"    Calls: oaModModuleVectorInstBit* find(const oaModule* module,const oaScalarName& baseName,oaUInt4 bitIndex)\n"
"    Signature: find|ptr-oaModModuleVectorInstBit|cptr-oaModule,cref-oaScalarName,simple-oaUInt4,\n"
"    This function searches the specified module looking for a vectorInstBit with the specified name and bitIndex. If the instance is found, it is returned; otherwise, NULL is returned.\n"
"    module\n"
"    The module to search\n"
"    baseName\n"
"    The base name of the instance to look for\n"
"    bitIndex\n"
"    The bit index of the instance to look for\n"
;

static PyObject*
oaModModuleVectorInstBit_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule p1;
    PyParamoaScalarName p2;
    PyParamoaUInt4 p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaModule_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaUInt4_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaModModuleVectorInstBitp result= (oaModModuleVectorInstBit::find(p1.Data(),p2.Data(),p3.Data()));
        return PyoaModModuleVectorInstBit_FromoaModModuleVectorInstBit(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModModuleVectorInstBit_static_isValidName_doc[] = 
"Class: oaModModuleVectorInstBit, Function: isValidName\n"
"  Paramegers: (oaModule,oaScalarName,oaUInt4)\n"
"    Calls: oaBoolean isValidName(const oaModule* module,const oaScalarName& baseName,oaUInt4 bitIndex)\n"
"    Signature: isValidName|simple-oaBoolean|cptr-oaModule,cref-oaScalarName,simple-oaUInt4,\n"
"    This function returns a boolean indicating whether the specified baseName and bitIndex would be valid for an oaModVectorInstBit in the specified module.\n"
"    module\n"
"    The module to search\n"
"    baseName\n"
"    The base name to validate\n"
"    bitIndex\n"
"    The bit index to validate\n"
;

static PyObject*
oaModModuleVectorInstBit_static_isValidName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule p1;
    PyParamoaScalarName p2;
    PyParamoaUInt4 p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaModule_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaUInt4_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (oaModModuleVectorInstBit::isValidName(p1.Data(),p2.Data(),p3.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaModModuleVectorInstBit_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaModModuleVectorInstBit_static_create,METH_VARARGS,oaModModuleVectorInstBit_static_create_doc},
    {"static_find",(PyCFunction)oaModModuleVectorInstBit_static_find,METH_VARARGS,oaModModuleVectorInstBit_static_find_doc},
    {"static_isValidName",(PyCFunction)oaModModuleVectorInstBit_static_isValidName,METH_VARARGS,oaModModuleVectorInstBit_static_isValidName_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModModuleVectorInstBit_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModModuleVectorInstBit_Type)<0) {
      printf("** PyType_Ready failed for: oaModModuleVectorInstBit\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModModuleVectorInstBit",
           (PyObject*)(&PyoaModModuleVectorInstBit_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModModuleVectorInstBit\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaModModuleVectorInstBit_Type.tp_dict;
    for(method=oaModModuleVectorInstBit_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModNet
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModNet_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModNet_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModNetObject* self = (PyoaModNetObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModNet)
    {
        PyParamoaModNet p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModNet_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModNet, Choices are:\n"
        "    (oaModNet)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModNet_tp_dealloc(PyoaModNetObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModNet_tp_repr(PyObject *ob)
{
    PyParamoaModNet value;
    int convert_status=PyoaModNet_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaModNet::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[30];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaModNet::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModNet_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModNet v1;
    PyParamoaModNet v2;
    int convert_status1=PyoaModNet_Convert(ob1,&v1);
    int convert_status2=PyoaModNet_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModNet_Convert(PyObject* ob,PyParamoaModNet* result)
{
    if (ob == NULL) return 1;
    if (PyoaModNet_Check(ob)) {
        result->SetData( (oaModNet**) ((PyoaModNetObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModNet Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModNet_FromoaModNet(oaModNet** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaModNet* data=*value;
        if (data->getType()==oacModBusNetType) return PyoaModBusNet_FromoaModBusNet((oaModBusNet**)value,borrow,lock);
        if (data->isModBitNet()) return PyoaModBitNet_FromoaModBitNet((oaModBitNet**)value,borrow,lock);
        if (data->getType()==oacModBundleNetType) return PyoaModBundleNet_FromoaModBundleNet((oaModBundleNet**)value,borrow,lock);
        PyObject* bself = PyoaModNet_Type.tp_alloc(&PyoaModNet_Type,0);
        if (bself == NULL) return bself;
        PyoaModNetObject* self = (PyoaModNetObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaModNet_FromoaModNet(oaModNet* data)
{
    if (data) {
        if (data->getType()==oacModBusNetType) return PyoaModBusNet_FromoaModBusNet((oaModBusNet*)data);
        if (data->isModBitNet()) return PyoaModBitNet_FromoaModBitNet((oaModBitNet*)data);
        if (data->getType()==oacModBundleNetType) return PyoaModBundleNet_FromoaModBundleNet((oaModBundleNet*)data);
       PyObject* bself = PyoaModNet_Type.tp_alloc(&PyoaModNet_Type,0);
       if (bself == NULL) return bself;
       PyoaModNetObject* self = (PyoaModNetObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModNet_destroy_doc[] = 
"Class: oaModNet, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function destroys this net, removing it from the database.\n"
"    oacCannotDestroyImplicitNet\n"
;

static PyObject*
oaModNet_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModNet data;
    int convert_status=PyoaModNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModNetObject* self=(PyoaModNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModNet_getBit_doc[] = 
"Class: oaModNet, Function: getBit\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaModBitNet* getBit(oaUInt4 bitIndex) const\n"
"    Signature: getBit|ptr-oaModBitNet|simple-oaUInt4,\n"
"    This function returns a pointer to the net that corresponds to the specified bitIndex bit of this net. For scalarNets, this function simply returns the net. For busNets, the busNetBit corresponding to the bitIndex bit is returned. For example, if this net is a busNet \"a[7:0]\" and bitIndex is zero, this function will return the busNetBit corresponding to \"a[7]\". For bundleNets, a scalarNet or busNetBit is returned.\n"
"    bitIndex\n"
"    Specifies which bit of the net to return\n"
"    A pointer to an oaModNet\n"
"    oacInvalidBusNetBitIndex\n"
"    oacInvalidNetIndex\n"
;

static PyObject*
oaModNet_getBit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModNet data;
    int convert_status=PyoaModNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModNetObject* self=(PyoaModNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaModBitNetp result= (data.DataCall()->getBit(p1.Data()));
        return PyoaModBitNet_FromoaModBitNet(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModNet_getInstTerms_doc[] = 
"Class: oaModNet, Function: getInstTerms\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaModInstTerm_oaModNet getInstTerms() const\n"
"    Signature: getInstTerms|simple-oaCollection_oaModInstTerm_oaModNet|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    oaModNet::getInstTerms\n"
"    This function returns a collection of instTerms in this net. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bits flags are defined as follows:\n"
"    oacInstTermIterNotImplicit: the collection will only contain instTerms that were explicitly created\n"
"    oacInstTermIterEquivNets: the collection will also contain the instTerms on the nets that are equivalent to this one\n"
"    oacInstTermIterFlagNotApplicableOnNets\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaModInstTerm_oaModNet getInstTerms(oaUInt4 filterFlags) const\n"
"    Signature: getInstTerms|simple-oaCollection_oaModInstTerm_oaModNet|simple-oaUInt4,\n"
"    oaModNet::getInstTerms\n"
"    This function returns a collection of instTerms in this net. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bits flags are defined as follows:\n"
"    oacInstTermIterNotImplicit: the collection will only contain instTerms that were explicitly created\n"
"    oacInstTermIterEquivNets: the collection will also contain the instTerms on the nets that are equivalent to this one\n"
"    oacInstTermIterFlagNotApplicableOnNets\n"
;

static PyObject*
oaModNet_getInstTerms(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModNet data;
    int convert_status=PyoaModNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModNetObject* self=(PyoaModNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaModInstTerm_oaModNet* result= new oaCollection_oaModInstTerm_oaModNet(data.DataCall()->getInstTerms());
            return PyoaCollection_oaModInstTerm_oaModNet_FromoaCollection_oaModInstTerm_oaModNet(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaModInstTerm_oaModNet* result= new oaCollection_oaModInstTerm_oaModNet(data.DataCall()->getInstTerms(p1.Data()));
            return PyoaCollection_oaModInstTerm_oaModNet_FromoaCollection_oaModInstTerm_oaModNet(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModNet, function: getInstTerms, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModNet_getInstTermsIter_doc[] = 
"Class: oaModNet, Function: getInstTermsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaModInstTerm getInstTermsIter() const\n"
"    Signature: getInstTermsIter|simple-oaIter_oaModInstTerm|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: oaModNet::getInstTerms\n"
"    This function returns a collection of instTerms in this net. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bits flags are defined as follows:\n"
"    oacInstTermIterNotImplicit: the collection will only contain instTerms that were explicitly created\n"
"    oacInstTermIterEquivNets: the collection will also contain the instTerms on the nets that are equivalent to this one\n"
"    oacInstTermIterFlagNotApplicableOnNets\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaModInstTerm getInstTermsIter(oaUInt4 filterFlags) const\n"
"    Signature: getInstTermsIter|simple-oaIter_oaModInstTerm|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: oaModNet::getInstTerms\n"
"    This function returns a collection of instTerms in this net. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bits flags are defined as follows:\n"
"    oacInstTermIterNotImplicit: the collection will only contain instTerms that were explicitly created\n"
"    oacInstTermIterEquivNets: the collection will also contain the instTerms on the nets that are equivalent to this one\n"
"    oacInstTermIterFlagNotApplicableOnNets\n"
;

static PyObject*
oaModNet_getInstTermsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModNet data;
    int convert_status=PyoaModNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModNetObject* self=(PyoaModNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaModInstTerm* result= new oaIter_oaModInstTerm(data.DataCall()->getInstTerms());
            return PyoaIter_oaModInstTerm_FromoaIter_oaModInstTerm(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaModInstTerm* result= new oaIter_oaModInstTerm(data.DataCall()->getInstTerms(p1.Data()));
            return PyoaIter_oaModInstTerm_FromoaIter_oaModInstTerm(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModNet, function: getInstTermsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModNet_getMemberNets_doc[] = 
"Class: oaModNet, Function: getMemberNets\n"
"  Paramegers: ()\n"
"    Calls: oaModMemNetCollection getMemberNets() const\n"
"    Signature: getMemberNets|simple-oaModMemNetCollection|simple-oaBoolean,\n"
"    BrowseData: 1\n"
"    oaModNet::getMemberNets\n"
"    This function returns a collection of module nets of which this module net is a member. For example, if a module contains both scalar net a and bundle net x,y,a this collection for net a contains both of those nets.\n"
"    In particular:\n"
"    Explicit nets are always members of themselves so the collection is never empty for such nets.\n"
"    Implicit nets are never returned in this collection.\n"
"    BundleNets can only be members of themselves.\n"
"    ScalarNets and busNets are members of themselves and bundleNets.\n"
"    BusNetBits are members of all busNets where the bit is present so busNetBit A[1] is a member of A[2:0]\n"
"    A single-bit busNet will only return itself\n"
"    Nets are members of bundles that contain a member that is in exactly the same form as the specified net\n"
"    A[1:0] is not a member of A[4:0]\n"
"    A[1:0] is not a member of A[0:1]\n"
"    Where a net occurs multiple times in a bundle, it will occur multiple times in this collection. See oaMemNetIter for details about iterating over this collection.\n"
"    unique\n"
"    Specifies that only the preferred equivalent nets are included in the collection\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: oaModMemNetCollection getMemberNets(oaBoolean unique) const\n"
"    Signature: getMemberNets|simple-oaModMemNetCollection|simple-oaBoolean,\n"
"    oaModNet::getMemberNets\n"
"    This function returns a collection of module nets of which this module net is a member. For example, if a module contains both scalar net a and bundle net x,y,a this collection for net a contains both of those nets.\n"
"    In particular:\n"
"    Explicit nets are always members of themselves so the collection is never empty for such nets.\n"
"    Implicit nets are never returned in this collection.\n"
"    BundleNets can only be members of themselves.\n"
"    ScalarNets and busNets are members of themselves and bundleNets.\n"
"    BusNetBits are members of all busNets where the bit is present so busNetBit A[1] is a member of A[2:0]\n"
"    A single-bit busNet will only return itself\n"
"    Nets are members of bundles that contain a member that is in exactly the same form as the specified net\n"
"    A[1:0] is not a member of A[4:0]\n"
"    A[1:0] is not a member of A[0:1]\n"
"    Where a net occurs multiple times in a bundle, it will occur multiple times in this collection. See oaMemNetIter for details about iterating over this collection.\n"
"    unique\n"
"    Specifies that only the preferred equivalent nets are included in the collection\n"
;

static PyObject*
oaModNet_getMemberNets(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModNet data;
    int convert_status=PyoaModNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModNetObject* self=(PyoaModNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaModMemNetCollection* result= new oaModMemNetCollection(data.DataCall()->getMemberNets());
            return PyoaModMemNetCollection_FromoaModMemNetCollection(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            oaModMemNetCollection* result= new oaModMemNetCollection(data.DataCall()->getMemberNets(p1.Data()));
            return PyoaModMemNetCollection_FromoaModMemNetCollection(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModNet, function: getMemberNets, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModNet_getMemberNetsIter_doc[] = 
"Class: oaModNet, Function: getMemberNetsIter\n"
"  Paramegers: ()\n"
"    Calls: oaModMemNetIter getMemberNetsIter() const\n"
"    Signature: getMemberNetsIter|simple-oaModMemNetIter|simple-oaBoolean,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: oaModNet::getMemberNets\n"
"    This function returns a collection of module nets of which this module net is a member. For example, if a module contains both scalar net a and bundle net x,y,a this collection for net a contains both of those nets.\n"
"    In particular:\n"
"    Explicit nets are always members of themselves so the collection is never empty for such nets.\n"
"    Implicit nets are never returned in this collection.\n"
"    BundleNets can only be members of themselves.\n"
"    ScalarNets and busNets are members of themselves and bundleNets.\n"
"    BusNetBits are members of all busNets where the bit is present so busNetBit A[1] is a member of A[2:0]\n"
"    A single-bit busNet will only return itself\n"
"    Nets are members of bundles that contain a member that is in exactly the same form as the specified net\n"
"    A[1:0] is not a member of A[4:0]\n"
"    A[1:0] is not a member of A[0:1]\n"
"    Where a net occurs multiple times in a bundle, it will occur multiple times in this collection. See oaMemNetIter for details about iterating over this collection.\n"
"    unique\n"
"    Specifies that only the preferred equivalent nets are included in the collection\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: oaModMemNetIter getMemberNetsIter(oaBoolean unique) const\n"
"    Signature: getMemberNetsIter|simple-oaModMemNetIter|simple-oaBoolean,\n"
"    This function returns an Iterator over the following collection: oaModNet::getMemberNets\n"
"    This function returns a collection of module nets of which this module net is a member. For example, if a module contains both scalar net a and bundle net x,y,a this collection for net a contains both of those nets.\n"
"    In particular:\n"
"    Explicit nets are always members of themselves so the collection is never empty for such nets.\n"
"    Implicit nets are never returned in this collection.\n"
"    BundleNets can only be members of themselves.\n"
"    ScalarNets and busNets are members of themselves and bundleNets.\n"
"    BusNetBits are members of all busNets where the bit is present so busNetBit A[1] is a member of A[2:0]\n"
"    A single-bit busNet will only return itself\n"
"    Nets are members of bundles that contain a member that is in exactly the same form as the specified net\n"
"    A[1:0] is not a member of A[4:0]\n"
"    A[1:0] is not a member of A[0:1]\n"
"    Where a net occurs multiple times in a bundle, it will occur multiple times in this collection. See oaMemNetIter for details about iterating over this collection.\n"
"    unique\n"
"    Specifies that only the preferred equivalent nets are included in the collection\n"
;

static PyObject*
oaModNet_getMemberNetsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModNet data;
    int convert_status=PyoaModNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModNetObject* self=(PyoaModNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaModMemNetIter* result= new oaModMemNetIter(data.DataCall()->getMemberNets());
            return PyoaModMemNetIter_FromoaModMemNetIter(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            oaModMemNetIter* result= new oaModMemNetIter(data.DataCall()->getMemberNets(p1.Data()));
            return PyoaModMemNetIter_FromoaModMemNetIter(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModNet, function: getMemberNetsIter, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModNet_getName_doc[] = 
"Class: oaModNet, Function: getName\n"
"  Paramegers: (oaName)\n"
"    Calls: void getName(oaName& name) const\n"
"    Signature: getName|void-void|ref-oaName,\n"
"    BrowseData: 0,oaName\n"
"    This function returns the name of this net in the name argument.\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the name of this net in the specified nameSpace in the specified name string.\n"
;

static PyObject*
oaModNet_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModNet data;
    int convert_status=PyoaModNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModNetObject* self=(PyoaModNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaName)
    {
        PyParamoaName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModNet, function: getName, Choices are:\n"
        "    (oaName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModNet_getNumBits_doc[] = 
"Class: oaModNet, Function: getNumBits\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumBits() const\n"
"    Signature: getNumBits|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of bits in this net.\n"
;

static PyObject*
oaModNet_getNumBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModNet data;
    int convert_status=PyoaModNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModNetObject* self=(PyoaModNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumBits());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModNet_getOccNets_doc[] = 
"Class: oaModNet, Function: getOccNets\n"
"  Paramegers: (oaOccurrence)\n"
"    Calls: oaCollection_oaOccNet_oaModNet getOccNets(const oaOccurrence* occ) const\n"
"    Signature: getOccNets|simple-oaCollection_oaOccNet_oaModNet|cptr-oaOccurrence,\n"
"    This function returns a collection of the occurrences of this module net in the design hierarchy under the specified 'top' occurrence. It is an error if the top occurrence specified is not in the same design as the module net is in, and also if the specific \"top\" is not a top occurrence.\n"
"    oacInvalidTopOccurrence\n"
;

static PyObject*
oaModNet_getOccNets(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModNet data;
    int convert_status=PyoaModNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModNetObject* self=(PyoaModNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaOccurrence p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccurrence_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaCollection_oaOccNet_oaModNet* result= new oaCollection_oaOccNet_oaModNet(data.DataCall()->getOccNets(p1.Data()));
        return PyoaCollection_oaOccNet_oaModNet_FromoaCollection_oaOccNet_oaModNet(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModNet_getOccNetsIter_doc[] = 
"Class: oaModNet, Function: getOccNetsIter\n"
"  Paramegers: (oaOccurrence)\n"
"    Calls: oaIter_oaOccNet getOccNetsIter(const oaOccurrence* occ) const\n"
"    Signature: getOccNetsIter|simple-oaIter_oaOccNet|cptr-oaOccurrence,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of the occurrences of this module net in the design hierarchy under the specified 'top' occurrence. It is an error if the top occurrence specified is not in the same design as the module net is in, and also if the specific \"top\" is not a top occurrence.\n"
"    oacInvalidTopOccurrence\n"
;

static PyObject*
oaModNet_getOccNetsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModNet data;
    int convert_status=PyoaModNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModNetObject* self=(PyoaModNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaOccurrence p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccurrence_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaIter_oaOccNet* result= new oaIter_oaOccNet(data.DataCall()->getOccNets(p1.Data()));
        return PyoaIter_oaOccNet_FromoaIter_oaOccNet(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModNet_getSigType_doc[] = 
"Class: oaModNet, Function: getSigType\n"
"  Paramegers: ()\n"
"    Calls: oaSigType getSigType() const\n"
"    Signature: getSigType|simple-oaSigType|\n"
"    BrowseData: 1\n"
"    This function returns the signal type of this net, which indicates its usage such as clock, power or signal.\n"
;

static PyObject*
oaModNet_getSigType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModNet data;
    int convert_status=PyoaModNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModNetObject* self=(PyoaModNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaSigType* result= new oaSigType(data.DataCall()->getSigType());
        return PyoaSigType_FromoaSigType(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModNet_getSingleBitMembers_doc[] = 
"Class: oaModNet, Function: getSingleBitMembers\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaModBitNet_oaModNet getSingleBitMembers() const\n"
"    Signature: getSingleBitMembers|simple-oaCollection_oaModBitNet_oaModNet|\n"
"    BrowseData: 1\n"
"    This function returns a collection of single-bit member nets that are in this net. If this net is a single-bit net, the collection contains itself. If this net is a busNet, the collection contains all of the corresponding busNetBits.\n"
;

static PyObject*
oaModNet_getSingleBitMembers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModNet data;
    int convert_status=PyoaModNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModNetObject* self=(PyoaModNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaModBitNet_oaModNet* result= new oaCollection_oaModBitNet_oaModNet(data.DataCall()->getSingleBitMembers());
        return PyoaCollection_oaModBitNet_oaModNet_FromoaCollection_oaModBitNet_oaModNet(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModNet_getSingleBitMembersIter_doc[] = 
"Class: oaModNet, Function: getSingleBitMembersIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaModBitNet getSingleBitMembersIter() const\n"
"    Signature: getSingleBitMembersIter|simple-oaIter_oaModBitNet|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of single-bit member nets that are in this net. If this net is a single-bit net, the collection contains itself. If this net is a busNet, the collection contains all of the corresponding busNetBits.\n"
;

static PyObject*
oaModNet_getSingleBitMembersIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModNet data;
    int convert_status=PyoaModNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModNetObject* self=(PyoaModNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaModBitNet* result= new oaIter_oaModBitNet(data.DataCall()->getSingleBitMembers());
        return PyoaIter_oaModBitNet_FromoaIter_oaModBitNet(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModNet_getTerms_doc[] = 
"Class: oaModNet, Function: getTerms\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaModTerm_oaModNet getTerms() const\n"
"    Signature: getTerms|simple-oaCollection_oaModTerm_oaModNet|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    oaModNet::getTerms\n"
"    This function returns a collection of terminals in this modNet. By default, the collection only contains explicit terminals associated with this net.\n"
"    When oacTermIterAll is included in filterFlags , the collection will contain all terminals associated with this net, including implicit terminals.\n"
"    When oacTermIterEquivNets is included in filterFlags , the collection will contain all terminals in the set of nets that are equivalent to this net.\n"
"    filterFlags\n"
"    Specifies which types of terminals to include in the collection\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaModTerm_oaModNet getTerms(oaUInt4 filterFlags) const\n"
"    Signature: getTerms|simple-oaCollection_oaModTerm_oaModNet|simple-oaUInt4,\n"
"    oaModNet::getTerms\n"
"    This function returns a collection of terminals in this modNet. By default, the collection only contains explicit terminals associated with this net.\n"
"    When oacTermIterAll is included in filterFlags , the collection will contain all terminals associated with this net, including implicit terminals.\n"
"    When oacTermIterEquivNets is included in filterFlags , the collection will contain all terminals in the set of nets that are equivalent to this net.\n"
"    filterFlags\n"
"    Specifies which types of terminals to include in the collection\n"
;

static PyObject*
oaModNet_getTerms(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModNet data;
    int convert_status=PyoaModNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModNetObject* self=(PyoaModNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaModTerm_oaModNet* result= new oaCollection_oaModTerm_oaModNet(data.DataCall()->getTerms());
            return PyoaCollection_oaModTerm_oaModNet_FromoaCollection_oaModTerm_oaModNet(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaModTerm_oaModNet* result= new oaCollection_oaModTerm_oaModNet(data.DataCall()->getTerms(p1.Data()));
            return PyoaCollection_oaModTerm_oaModNet_FromoaCollection_oaModTerm_oaModNet(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModNet, function: getTerms, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModNet_getTermsIter_doc[] = 
"Class: oaModNet, Function: getTermsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaModTerm getTermsIter() const\n"
"    Signature: getTermsIter|simple-oaIter_oaModTerm|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: oaModNet::getTerms\n"
"    This function returns a collection of terminals in this modNet. By default, the collection only contains explicit terminals associated with this net.\n"
"    When oacTermIterAll is included in filterFlags , the collection will contain all terminals associated with this net, including implicit terminals.\n"
"    When oacTermIterEquivNets is included in filterFlags , the collection will contain all terminals in the set of nets that are equivalent to this net.\n"
"    filterFlags\n"
"    Specifies which types of terminals to include in the collection\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaModTerm getTermsIter(oaUInt4 filterFlags) const\n"
"    Signature: getTermsIter|simple-oaIter_oaModTerm|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: oaModNet::getTerms\n"
"    This function returns a collection of terminals in this modNet. By default, the collection only contains explicit terminals associated with this net.\n"
"    When oacTermIterAll is included in filterFlags , the collection will contain all terminals associated with this net, including implicit terminals.\n"
"    When oacTermIterEquivNets is included in filterFlags , the collection will contain all terminals in the set of nets that are equivalent to this net.\n"
"    filterFlags\n"
"    Specifies which types of terminals to include in the collection\n"
;

static PyObject*
oaModNet_getTermsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModNet data;
    int convert_status=PyoaModNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModNetObject* self=(PyoaModNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaModTerm* result= new oaIter_oaModTerm(data.DataCall()->getTerms());
            return PyoaIter_oaModTerm_FromoaIter_oaModTerm(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaModTerm* result= new oaIter_oaModTerm(data.DataCall()->getTerms(p1.Data()));
            return PyoaIter_oaModTerm_FromoaIter_oaModTerm(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModNet, function: getTermsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModNet_isEmpty_doc[] = 
"Class: oaModNet, Function: isEmpty\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isEmpty() const\n"
"    Signature: isEmpty|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value that indicates if this net has any objects attached to it or associated with it.\n"
;

static PyObject*
oaModNet_isEmpty(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModNet data;
    int convert_status=PyoaModNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModNetObject* self=(PyoaModNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isEmpty());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModNet_isGlobal_doc[] = 
"Class: oaModNet, Function: isGlobal\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isGlobal() const\n"
"    Signature: isGlobal|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value that indicates if this net is a global net. All global nets of a given name are connected regardless of where they are in a hierarchy.\n"
;

static PyObject*
oaModNet_isGlobal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModNet data;
    int convert_status=PyoaModNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModNetObject* self=(PyoaModNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isGlobal());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModNet_isImplicit_doc[] = 
"Class: oaModNet, Function: isImplicit\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isImplicit() const\n"
"    Signature: isImplicit|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether or not this net is implicit, that is, if it was automatically created as a result of the creation of a bundleNet or busNet.\n"
;

static PyObject*
oaModNet_isImplicit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModNet data;
    int convert_status=PyoaModNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModNetObject* self=(PyoaModNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isImplicit());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModNet_scalarize_doc[] = 
"Class: oaModNet, Function: scalarize\n"
"  Paramegers: ()\n"
"    Calls: void scalarize()\n"
"    Signature: scalarize|void-void|\n"
"    BrowseData: 0\n"
"    This function insures that the bitNets associated with this net have been promoted to the explicit state so that they can support implementation data.\n"
"    If this net is a multibit net, this function insures that all constituent bitNets are promoted to the explicit state. The multibit net is then demoted to the implicit state so that no implementation data can be associated with it. When a net is demoted to the implicit state, associated implementation data is removed from it.\n"
"    oacCannotScalarizeImplicitNet\n"
;

static PyObject*
oaModNet_scalarize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModNet data;
    int convert_status=PyoaModNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModNetObject* self=(PyoaModNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->scalarize();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModNet_setGlobal_doc[] = 
"Class: oaModNet, Function: setGlobal\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: void setGlobal(oaBoolean isGlobal)\n"
"    Signature: setGlobal|void-void|simple-oaBoolean,\n"
"    This function sets the global attribute of this net.\n"
;

static PyObject*
oaModNet_setGlobal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModNet data;
    int convert_status=PyoaModNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModNetObject* self=(PyoaModNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBoolean p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBoolean_Convert,&p1)) {
        data.DataCall()->setGlobal(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModNet_setSigType_doc[] = 
"Class: oaModNet, Function: setSigType\n"
"  Paramegers: (oaSigType)\n"
"    Calls: void setSigType(oaSigType sigType)\n"
"    Signature: setSigType|void-void|simple-oaSigType,\n"
"    oaModNet::setSigType\n"
"    This function sets the sigType attribute of this net to the specified value.\n"
"    Note: The sigType of an oaModNet can be different from the sigType of its corresponding oaNet . In other words, this function sets the sigType on the this net in the module domain only.\n"
;

static PyObject*
oaModNet_setSigType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModNet data;
    int convert_status=PyoaModNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModNetObject* self=(PyoaModNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaSigType p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaSigType_Convert,&p1)) {
        data.DataCall()->setSigType(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModNet_isNull_doc[] =
"Class: oaModNet, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaModNet_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaModNet data;
    int convert_status=PyoaModNet_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaModNet_assign_doc[] = 
"Class: oaModNet, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModNet_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModNet data;
  int convert_status=PyoaModNet_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModNet p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModNet_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModNet_methodlist[] = {
    {"destroy",(PyCFunction)oaModNet_destroy,METH_VARARGS,oaModNet_destroy_doc},
    {"getBit",(PyCFunction)oaModNet_getBit,METH_VARARGS,oaModNet_getBit_doc},
    {"getInstTerms",(PyCFunction)oaModNet_getInstTerms,METH_VARARGS,oaModNet_getInstTerms_doc},
    {"getInstTermsIter",(PyCFunction)oaModNet_getInstTermsIter,METH_VARARGS,oaModNet_getInstTermsIter_doc},
    {"getMemberNets",(PyCFunction)oaModNet_getMemberNets,METH_VARARGS,oaModNet_getMemberNets_doc},
    {"getMemberNetsIter",(PyCFunction)oaModNet_getMemberNetsIter,METH_VARARGS,oaModNet_getMemberNetsIter_doc},
    {"getName",(PyCFunction)oaModNet_getName,METH_VARARGS,oaModNet_getName_doc},
    {"getNumBits",(PyCFunction)oaModNet_getNumBits,METH_VARARGS,oaModNet_getNumBits_doc},
    {"getOccNets",(PyCFunction)oaModNet_getOccNets,METH_VARARGS,oaModNet_getOccNets_doc},
    {"getOccNetsIter",(PyCFunction)oaModNet_getOccNetsIter,METH_VARARGS,oaModNet_getOccNetsIter_doc},
    {"getSigType",(PyCFunction)oaModNet_getSigType,METH_VARARGS,oaModNet_getSigType_doc},
    {"getSingleBitMembers",(PyCFunction)oaModNet_getSingleBitMembers,METH_VARARGS,oaModNet_getSingleBitMembers_doc},
    {"getSingleBitMembersIter",(PyCFunction)oaModNet_getSingleBitMembersIter,METH_VARARGS,oaModNet_getSingleBitMembersIter_doc},
    {"getTerms",(PyCFunction)oaModNet_getTerms,METH_VARARGS,oaModNet_getTerms_doc},
    {"getTermsIter",(PyCFunction)oaModNet_getTermsIter,METH_VARARGS,oaModNet_getTermsIter_doc},
    {"isEmpty",(PyCFunction)oaModNet_isEmpty,METH_VARARGS,oaModNet_isEmpty_doc},
    {"isGlobal",(PyCFunction)oaModNet_isGlobal,METH_VARARGS,oaModNet_isGlobal_doc},
    {"isImplicit",(PyCFunction)oaModNet_isImplicit,METH_VARARGS,oaModNet_isImplicit_doc},
    {"scalarize",(PyCFunction)oaModNet_scalarize,METH_VARARGS,oaModNet_scalarize_doc},
    {"setGlobal",(PyCFunction)oaModNet_setGlobal,METH_VARARGS,oaModNet_setGlobal_doc},
    {"setSigType",(PyCFunction)oaModNet_setSigType,METH_VARARGS,oaModNet_setSigType_doc},
    {"isNull",(PyCFunction)oaModNet_tp_isNull,METH_VARARGS,oaModNet_isNull_doc},
    {"assign",(PyCFunction)oaModNet_tp_assign,METH_VARARGS,oaModNet_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModNet_doc[] = 
"Class: oaModNet\n"
"  The oaModNet class is an abstract base class for scalar and multi-bit nets that are part of the design's logical description. Nets represent the logical connectivity within a module of a design. Nets connect to terminals, which are the logical connection points to nets in the parent module. Nets also connect to instTerms that represent connections to the lower-level instances in the net's module.\n"
"  oaModNet, oaOccNet , and oaNet each represent nets in a different kind of master, where in each case, the master represents a level of hierarchy in the design.\n"
"  Note that oaModNet::getOccNets will return oaOccNets only if the occurrence hierarchy has been expanded to include those objects. See Working in the Occurrence Domain for more details.\n"
"  For oaModNet, the master is an oaModule , and each module in a design will contain a set of zero or more modNets.\n"
"  For a typical hierarchy where the oaNets in the block are visible in the module hierarchy each oaNet will have a corresponding oaModNet in the top oaModule . When oaNets are created in such a block, the corresponding oaModNets are automatically created on the top oaModule .\n"
"  All module nets have names. These names can be assigned by the creator. For scalar nets, a name can be automatically assigned by the database.\n"
"  There must be a consistent definition of single and multi-bit nets shared between the top module and the top block in a design. When an oaBusNet has been created that is not visible to the module domain, it is not possible to create an oaModBusNet that uses the same base name. Similarly, it is not possible to create an oaModScalarNet whose name would conflict with any oaScalarNet or oaBusNet in the block domain.\n"
"  Multi-bit nets represent a collection of logical connections. Nets can include busNets having a single base name with an index range, or they can include bundleNets, which are a more complex grouping of nets. Multi-bit nets can have overlapping names. For example, busNets addr<7:0> and addr<3:0> .\n"
"  All ModBusNets with the same root name are managed by an oaModBusNetDef . The modBusNetDef tracks:\n"
"  lowest numbered bit of all of the associated busNets\n"
"  highest numbered bit of all of the associated busNets\n"
"  busNets with the same base name\n"
"  associated busNetBits\n"
"  The modBusNetBits are automatically created for each bit of a modBusNet, if they do not already exist. They are available for those applications performing scalarized connectivity traversal of the data.\n"
"  The modBundleNets can contain modScalarNets or modBusNets. When a modBundleNet is created, the constituent modScalarNets and modBusNets are automatically created in addition to the modBundleNet itself. All automatically created net objects are considered \"implicit.\" Implicit nets are more restricted in terms of the operations that are allowed to work with them.\n"
"  The various net objects take and return names through the general oaName object but also use the oaScalarName , oaVectorBitName , oaVectorName , and oaBundleName objects. These name objects manage the mapping of names from one nameSpace to another. For example, where a net is created using the name in CDBA nameSpace; another application can retrieve the net's name in the Verilog nameSpace.\n"
"  You can have two or more nets that are equivalent. Equivalent nets can be traversed separately or logically as the same net. You can only set single-bit nets equivalent to each other.\n"
"  The oaModNet class can be observed by deriving from\n"
"  For information on creating global nets in the module domain, see Creating Global Nets in the Module Domain .\n"
"Constructors:\n"
"  Paramegers: (oaModNet)\n"
"    Calls: (const oaModNet&)\n"
"    Signature: oaModNet||cref-oaModNet,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModNet_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModNet",
    sizeof(PyoaModNetObject),
    0,
    (destructor)oaModNet_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModNet_tp_compare,	/* tp_compare */
    (reprfunc)oaModNet_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModNet_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaModNet_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaModObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModNet_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModNet_static_create_doc[] = 
"Class: oaModNet, Function: create\n"
"  Paramegers: (oaModule,oaName)\n"
"    Calls: oaModNet* create(oaModule* module,const oaName& name)\n"
"    Signature: create|ptr-oaModNet|ptr-oaModule,cref-oaName,simple-oaSigType,simple-oaBoolean,\n"
"    This function creates a net in the specified module with the specified name . The type of net (scalarNet, busNetBit, busNet, or bundleNet) created is determined by the specified name .\n"
"    module\n"
"    The module in which to create the net\n"
"    name\n"
"    The name of the net\n"
"    sigType\n"
"    The signal type to associate with the net; if not specified, the default is oacSignalSigType\n"
"    isGlobal\n"
"    Specifies if this net is considered global; if not specified, the default is false\n"
"    A pointer to an oaModNet\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacInvalidNetName\n"
"    oacNetExists\n"
"    oacScalarNetNameMatchesBusBaseName\n"
"  Paramegers: (oaModule,oaName,oaSigType)\n"
"    Calls: oaModNet* create(oaModule* module,const oaName& name,oaSigType type)\n"
"    Signature: create|ptr-oaModNet|ptr-oaModule,cref-oaName,simple-oaSigType,simple-oaBoolean,\n"
"    This function creates a net in the specified module with the specified name . The type of net (scalarNet, busNetBit, busNet, or bundleNet) created is determined by the specified name .\n"
"    module\n"
"    The module in which to create the net\n"
"    name\n"
"    The name of the net\n"
"    sigType\n"
"    The signal type to associate with the net; if not specified, the default is oacSignalSigType\n"
"    isGlobal\n"
"    Specifies if this net is considered global; if not specified, the default is false\n"
"    A pointer to an oaModNet\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacInvalidNetName\n"
"    oacNetExists\n"
"    oacScalarNetNameMatchesBusBaseName\n"
"  Paramegers: (oaModule,oaName,oaSigType,oaBoolean)\n"
"    Calls: oaModNet* create(oaModule* module,const oaName& name,oaSigType type,oaBoolean isGlobal)\n"
"    Signature: create|ptr-oaModNet|ptr-oaModule,cref-oaName,simple-oaSigType,simple-oaBoolean,\n"
"    This function creates a net in the specified module with the specified name . The type of net (scalarNet, busNetBit, busNet, or bundleNet) created is determined by the specified name .\n"
"    module\n"
"    The module in which to create the net\n"
"    name\n"
"    The name of the net\n"
"    sigType\n"
"    The signal type to associate with the net; if not specified, the default is oacSignalSigType\n"
"    isGlobal\n"
"    Specifies if this net is considered global; if not specified, the default is false\n"
"    A pointer to an oaModNet\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacInvalidNetName\n"
"    oacNetExists\n"
"    oacScalarNetNameMatchesBusBaseName\n"
;

static PyObject*
oaModNet_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaModule,oaName)
    {
        PyParamoaModule p1;
        PyParamoaName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaName_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModNetp result= (oaModNet::create(p1.Data(),p2.Data()));
            return PyoaModNet_FromoaModNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaName,oaSigType)
    {
        PyParamoaModule p1;
        PyParamoaName p2;
        PyParamoaSigType p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaName_Convert,&p2,
              &PyoaSigType_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModNetp result= (oaModNet::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaModNet_FromoaModNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaName,oaSigType,oaBoolean)
    {
        PyParamoaModule p1;
        PyParamoaName p2;
        PyParamoaSigType p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaName_Convert,&p2,
              &PyoaSigType_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModNetp result= (oaModNet::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaModNet_FromoaModNet(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModNet, function: create, Choices are:\n"
        "    (oaModule,oaName)\n"
        "    (oaModule,oaName,oaSigType)\n"
        "    (oaModule,oaName,oaSigType,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModNet_static_find_doc[] = 
"Class: oaModNet, Function: find\n"
"  Paramegers: (oaModule,oaName)\n"
"    Calls: oaModNet* find(const oaModule* module,const oaName& name)\n"
"    Signature: find|ptr-oaModNet|cptr-oaModule,cref-oaName,\n"
"    This function searches the specified module for a net with the specified name . If the name is hierarchical, then this function searches through the hierarchy path for the specified net. If the name is a bundle name, and any of its members has hierarchy, all of its members must have the same level of hierarchy or an exception is thrown. If the net is found, the function returns the net. Otherwise, NULL is returned.\n"
"    oacInvalidHierBundleNetName\n"
;

static PyObject*
oaModNet_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule p1;
    PyParamoaName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaModule_Convert,&p1,
          &PyoaName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaModNetp result= (oaModNet::find(p1.Data(),p2.Data()));
        return PyoaModNet_FromoaModNet(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModNet_static_isValidName_doc[] = 
"Class: oaModNet, Function: isValidName\n"
"  Paramegers: (oaModule,oaName)\n"
"    Calls: oaBoolean isValidName(const oaModule* module,const oaName& name)\n"
"    Signature: isValidName|simple-oaBoolean|cptr-oaModule,cref-oaName,\n"
"    This function returns a boolean value that indicates if the specified name is valid for a new oaModNet in the specified module .\n"
;

static PyObject*
oaModNet_static_isValidName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule p1;
    PyParamoaName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaModule_Convert,&p1,
          &PyoaName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (oaModNet::isValidName(p1.Data(),p2.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaModNet_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaModNet_static_create,METH_VARARGS,oaModNet_static_create_doc},
    {"static_find",(PyCFunction)oaModNet_static_find,METH_VARARGS,oaModNet_static_find_doc},
    {"static_isValidName",(PyCFunction)oaModNet_static_isValidName,METH_VARARGS,oaModNet_static_isValidName_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModNet_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModNet_Type)<0) {
      printf("** PyType_Ready failed for: oaModNet\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModNet",
           (PyObject*)(&PyoaModNet_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModNet\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaModNet_Type.tp_dict;
    for(method=oaModNet_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModNetConnectDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModNetConnectDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModNetConnectDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModNetConnectDefObject* self = (PyoaModNetConnectDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModNetConnectDef)
    {
        PyParamoaModNetConnectDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModNetConnectDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModNetConnectDef, Choices are:\n"
        "    (oaModNetConnectDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModNetConnectDef_tp_dealloc(PyoaModNetConnectDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModNetConnectDef_tp_repr(PyObject *ob)
{
    PyParamoaModNetConnectDef value;
    int convert_status=PyoaModNetConnectDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[40];
    sprintf(buffer,"<oaModNetConnectDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModNetConnectDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModNetConnectDef v1;
    PyParamoaModNetConnectDef v2;
    int convert_status1=PyoaModNetConnectDef_Convert(ob1,&v1);
    int convert_status2=PyoaModNetConnectDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModNetConnectDef_Convert(PyObject* ob,PyParamoaModNetConnectDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaModNetConnectDef_Check(ob)) {
        result->SetData( (oaModNetConnectDef**) ((PyoaModNetConnectDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModNetConnectDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModNetConnectDef_FromoaModNetConnectDef(oaModNetConnectDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaModNetConnectDef* data=*value;
        PyObject* bself = PyoaModNetConnectDef_Type.tp_alloc(&PyoaModNetConnectDef_Type,0);
        if (bself == NULL) return bself;
        PyoaModNetConnectDefObject* self = (PyoaModNetConnectDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaModNetConnectDef_FromoaModNetConnectDef(oaModNetConnectDef* data)
{
    if (data) {
       PyObject* bself = PyoaModNetConnectDef_Type.tp_alloc(&PyoaModNetConnectDef_Type,0);
       if (bself == NULL) return bself;
       PyoaModNetConnectDefObject* self = (PyoaModNetConnectDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModNetConnectDef_getNet_doc[] = 
"Class: oaModNetConnectDef, Function: getNet\n"
"  Paramegers: ()\n"
"    Calls: oaModBitNet* getNet() const\n"
"    Signature: getNet|ptr-oaModBitNet|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the modBitNet associated with this connection definition.\n"
;

static PyObject*
oaModNetConnectDef_getNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModNetConnectDef data;
    int convert_status=PyoaModNetConnectDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModNetConnectDefObject* self=(PyoaModNetConnectDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModBitNetp result= (data.DataCall()->getNet());
        return PyoaModBitNet_FromoaModBitNet(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModNetConnectDef_isNull_doc[] =
"Class: oaModNetConnectDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaModNetConnectDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaModNetConnectDef data;
    int convert_status=PyoaModNetConnectDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaModNetConnectDef_assign_doc[] = 
"Class: oaModNetConnectDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModNetConnectDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModNetConnectDef data;
  int convert_status=PyoaModNetConnectDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModNetConnectDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModNetConnectDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModNetConnectDef_methodlist[] = {
    {"getNet",(PyCFunction)oaModNetConnectDef_getNet,METH_VARARGS,oaModNetConnectDef_getNet_doc},
    {"isNull",(PyCFunction)oaModNetConnectDef_tp_isNull,METH_VARARGS,oaModNetConnectDef_isNull_doc},
    {"assign",(PyCFunction)oaModNetConnectDef_tp_assign,METH_VARARGS,oaModNetConnectDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModNetConnectDef_doc[] = 
"Class: oaModNetConnectDef\n"
"  The oaModNetConnectDef class implements a connection definition that associates an oaAssignmentDef with a single-bit net. The oaAssignmentDef used to create the oaModNetConnectDef specifies the name of an oaModAssignment and a default net name.\n"
"  Applications that analyze design connectivity must resolve the net name of the net associated with an oaModNetConnectDef. The application searches up the design hierarchy for an oaModAssignment that matches the assignment name specified in the oaModNetConnectDef. If the assignment is found, the application uses the net name it specifies instead of the name of the net that is associated with the oaModNetConnectDef. If an assignment is not found, the application uses the default net name specified in the oaModNetConnectDef.\n"
"  An oaModNetConnectDef is usually associated with a global net. This allows\n"
"  easier specification of multiple power supplies\n"
"  easier specification of substrate connections\n"
"  the use of parameterized power and ground symbols\n"
"  For example, a global net named vdd is used in a lower-level part of a design. At a higher level, you decide that you want all of the vdd connections connected to a net named vcc . To accomplish this, you could create an oaModNetConnectDef on the vdd net that specifies the name of an assignment called \"vdd_override\". Up in the hierarchy, you would then create an oaModAssignValue on an instance representing that part of the design you want to replace the net name vcc for vdd . The oaModAssignValue would be named \"vdd_override\" and it would have the net name value vcc .\n"
"  Note: Not all applications support resolving connectivity specified with connection definitions and assignments. You should verify that downstream consumers of the data are able to resolve such connectivity.\n"
"Constructors:\n"
"  Paramegers: (oaModNetConnectDef)\n"
"    Calls: (const oaModNetConnectDef&)\n"
"    Signature: oaModNetConnectDef||cref-oaModNetConnectDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModNetConnectDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModNetConnectDef",
    sizeof(PyoaModNetConnectDefObject),
    0,
    (destructor)oaModNetConnectDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModNetConnectDef_tp_compare,	/* tp_compare */
    (reprfunc)oaModNetConnectDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModNetConnectDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaModNetConnectDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaModConnectDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModNetConnectDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModNetConnectDef_static_create_doc[] = 
"Class: oaModNetConnectDef, Function: create\n"
"  Paramegers: (oaModBitNet,oaAssignmentDef)\n"
"    Calls: oaModNetConnectDef* create(const oaModBitNet* net,const oaAssignmentDef& assignmentDef)\n"
"    Signature: create|ptr-oaModNetConnectDef|cptr-oaModBitNet,cref-oaAssignmentDef,\n"
"    This function creates a connection definition on the specified net using the information in the given assignmentDef .\n"
"    net\n"
"    The single-bit net for which to define the connection\n"
"    assignmentDef\n"
"    The assignment definition that specifies the name of an assignment to search for in order to resolve the connectivity and a default net name to use if a matching assignment is not found\n"
"    A pointer to an oaModNetConnectDef\n"
"    oacNetAlreadyHasConnectDef\n"
;

static PyObject*
oaModNetConnectDef_static_create(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModBitNet p1;
    PyParamoaAssignmentDef p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaModBitNet_Convert,&p1,
          &PyoaAssignmentDef_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaModNetConnectDefp result= (oaModNetConnectDef::create(p1.Data(),p2.Data()));
        return PyoaModNetConnectDef_FromoaModNetConnectDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaModNetConnectDef_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaModNetConnectDef_static_create,METH_VARARGS,oaModNetConnectDef_static_create_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModNetConnectDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModNetConnectDef_Type)<0) {
      printf("** PyType_Ready failed for: oaModNetConnectDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModNetConnectDef",
           (PyObject*)(&PyoaModNetConnectDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModNetConnectDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaModNetConnectDef_Type.tp_dict;
    for(method=oaModNetConnectDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModNetTermArray
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModNetTermArray_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModNetTermArray_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModNetTermArrayObject* self = (PyoaModNetTermArrayObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaNetTermArrayBase_oaModNet_oaModTerm*)  new oaModNetTermArray();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value = (oaNetTermArrayBase_oaModNet_oaModTerm*)  new oaModNetTermArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaModNetTermArray)
    {
        PyParamoaModNetTermArray p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModNetTermArray_Convert,&p1)) {
            self->value=(oaNetTermArrayBase_oaModNet_oaModTerm*)  new oaModNetTermArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModNetTermArray, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaModNetTermArray)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModNetTermArray_tp_dealloc(PyoaModNetTermArrayObject* self)
{
    if (!self->borrow) {
        delete (oaModNetTermArray*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModNetTermArray_tp_repr(PyObject *ob)
{
    PyParamoaModNetTermArray value;
    int convert_status=PyoaModNetTermArray_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[39];
    sprintf(buffer,"<oaModNetTermArray::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModNetTermArray_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModNetTermArray v1;
    PyParamoaModNetTermArray v2;
    int convert_status1=PyoaModNetTermArray_Convert(ob1,&v1);
    int convert_status2=PyoaModNetTermArray_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModNetTermArray_Convert(PyObject* ob,PyParamoaModNetTermArray* result)
{
    if (ob == NULL) return 1;
    if (PyoaModNetTermArray_Check(ob)) {
        result->SetData( (oaModNetTermArray*) ((PyoaModNetTermArrayObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModNetTermArray Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModNetTermArray_FromoaModNetTermArray(oaModNetTermArray* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaModNetTermArray_Type.tp_alloc(&PyoaModNetTermArray_Type,0);
        if (bself == NULL) return bself;
        PyoaModNetTermArrayObject* self = (PyoaModNetTermArrayObject*)bself;
        self->value = (oaNetTermArrayBase_oaModNet_oaModTerm*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModNetTermArray_doc[] = 
"Class: oaModNetTermArray\n"
"  This class associates oaModNet pointers with oaModTerm pointers.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaModNetTermArray()\n"
"    Signature: oaModNetTermArray||simple-oaUInt4,\n"
"    This function constructs an array of oaModNet pointers and associated oaModTerm pointers.\n"
"    size\n"
"    An integer value indicating the initial size of the array.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaModNetTermArray(oaUInt4 size)\n"
"    Signature: oaModNetTermArray||simple-oaUInt4,\n"
"    This function constructs an array of oaModNet pointers and associated oaModTerm pointers.\n"
"    size\n"
"    An integer value indicating the initial size of the array.\n"
"  Paramegers: (oaModNetTermArray)\n"
"    Calls: (const oaModNetTermArray&)\n"
"    Signature: oaModNetTermArray||cref-oaModNetTermArray,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModNetTermArray_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModNetTermArray",
    sizeof(PyoaModNetTermArrayObject),
    0,
    (destructor)oaModNetTermArray_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModNetTermArray_tp_compare,	/* tp_compare */
    (reprfunc)oaModNetTermArray_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModNetTermArray_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaNetTermArrayBase_oaModNet_oaModTerm_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModNetTermArray_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModNetTermArray_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModNetTermArray_Type)<0) {
      printf("** PyType_Ready failed for: oaModNetTermArray\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModNetTermArray",
           (PyObject*)(&PyoaModNetTermArray_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModNetTermArray\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModNetTermNameArray
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModNetTermNameArray_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModNetTermNameArray_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModNetTermNameArrayObject* self = (PyoaModNetTermNameArrayObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaNetTermArrayBase_oaModNet_oaName*)  new oaModNetTermNameArray();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value = (oaNetTermArrayBase_oaModNet_oaName*)  new oaModNetTermNameArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaModNetTermNameArray)
    {
        PyParamoaModNetTermNameArray p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModNetTermNameArray_Convert,&p1)) {
            self->value=(oaNetTermArrayBase_oaModNet_oaName*)  new oaModNetTermNameArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModNetTermNameArray, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaModNetTermNameArray)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModNetTermNameArray_tp_dealloc(PyoaModNetTermNameArrayObject* self)
{
    if (!self->borrow) {
        delete (oaModNetTermNameArray*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModNetTermNameArray_tp_repr(PyObject *ob)
{
    PyParamoaModNetTermNameArray value;
    int convert_status=PyoaModNetTermNameArray_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaModNetTermNameArray::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModNetTermNameArray_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModNetTermNameArray v1;
    PyParamoaModNetTermNameArray v2;
    int convert_status1=PyoaModNetTermNameArray_Convert(ob1,&v1);
    int convert_status2=PyoaModNetTermNameArray_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModNetTermNameArray_Convert(PyObject* ob,PyParamoaModNetTermNameArray* result)
{
    if (ob == NULL) return 1;
    if (PyoaModNetTermNameArray_Check(ob)) {
        result->SetData( (oaModNetTermNameArray*) ((PyoaModNetTermNameArrayObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModNetTermNameArray Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModNetTermNameArray_FromoaModNetTermNameArray(oaModNetTermNameArray* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaModNetTermNameArray_Type.tp_alloc(&PyoaModNetTermNameArray_Type,0);
        if (bself == NULL) return bself;
        PyoaModNetTermNameArrayObject* self = (PyoaModNetTermNameArrayObject*)bself;
        self->value = (oaNetTermArrayBase_oaModNet_oaName*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModNetTermNameArray_doc[] = 
"Class: oaModNetTermNameArray\n"
"  This class associates oaModNet pointers with names of terms in the module domain.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaModNetTermNameArray()\n"
"    Signature: oaModNetTermNameArray||simple-oaUInt4,\n"
"    This class associates net points with term names.\n"
"    size\n"
"    An integer value indicating the initial size of the array.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaModNetTermNameArray(oaUInt4 size)\n"
"    Signature: oaModNetTermNameArray||simple-oaUInt4,\n"
"    This class associates net points with term names.\n"
"    size\n"
"    An integer value indicating the initial size of the array.\n"
"  Paramegers: (oaModNetTermNameArray)\n"
"    Calls: (const oaModNetTermNameArray&)\n"
"    Signature: oaModNetTermNameArray||cref-oaModNetTermNameArray,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModNetTermNameArray_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModNetTermNameArray",
    sizeof(PyoaModNetTermNameArrayObject),
    0,
    (destructor)oaModNetTermNameArray_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModNetTermNameArray_tp_compare,	/* tp_compare */
    (reprfunc)oaModNetTermNameArray_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModNetTermNameArray_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaNetTermArrayBase_oaModNet_oaName_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModNetTermNameArray_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModNetTermNameArray_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModNetTermNameArray_Type)<0) {
      printf("** PyType_Ready failed for: oaModNetTermNameArray\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModNetTermNameArray",
           (PyObject*)(&PyoaModNetTermNameArray_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModNetTermNameArray\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModNetTermPosArray
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModNetTermPosArray_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModNetTermPosArray_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModNetTermPosArrayObject* self = (PyoaModNetTermPosArrayObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaNetTermArrayBase_oaModNet_oaUInt4*)  new oaModNetTermPosArray();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value = (oaNetTermArrayBase_oaModNet_oaUInt4*)  new oaModNetTermPosArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaModNetTermPosArray)
    {
        PyParamoaModNetTermPosArray p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModNetTermPosArray_Convert,&p1)) {
            self->value=(oaNetTermArrayBase_oaModNet_oaUInt4*)  new oaModNetTermPosArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModNetTermPosArray, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaModNetTermPosArray)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModNetTermPosArray_tp_dealloc(PyoaModNetTermPosArrayObject* self)
{
    if (!self->borrow) {
        delete (oaModNetTermPosArray*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModNetTermPosArray_tp_repr(PyObject *ob)
{
    PyParamoaModNetTermPosArray value;
    int convert_status=PyoaModNetTermPosArray_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaModNetTermPosArray::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModNetTermPosArray_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModNetTermPosArray v1;
    PyParamoaModNetTermPosArray v2;
    int convert_status1=PyoaModNetTermPosArray_Convert(ob1,&v1);
    int convert_status2=PyoaModNetTermPosArray_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModNetTermPosArray_Convert(PyObject* ob,PyParamoaModNetTermPosArray* result)
{
    if (ob == NULL) return 1;
    if (PyoaModNetTermPosArray_Check(ob)) {
        result->SetData( (oaModNetTermPosArray*) ((PyoaModNetTermPosArrayObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModNetTermPosArray Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModNetTermPosArray_FromoaModNetTermPosArray(oaModNetTermPosArray* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaModNetTermPosArray_Type.tp_alloc(&PyoaModNetTermPosArray_Type,0);
        if (bself == NULL) return bself;
        PyoaModNetTermPosArrayObject* self = (PyoaModNetTermPosArrayObject*)bself;
        self->value = (oaNetTermArrayBase_oaModNet_oaUInt4*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModNetTermPosArray_doc[] = 
"Class: oaModNetTermPosArray\n"
"  This class ssociates oaModNet pointers with positions of terms in the module domain.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaModNetTermPosArray()\n"
"    Signature: oaModNetTermPosArray||simple-oaUInt4,\n"
"    size\n"
"    An integer value indicating the initial size of the array.\n"
"    Todo\n"
"    Add description of member function. Add description of each parameter.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaModNetTermPosArray(oaUInt4 size)\n"
"    Signature: oaModNetTermPosArray||simple-oaUInt4,\n"
"    size\n"
"    An integer value indicating the initial size of the array.\n"
"    Todo\n"
"    Add description of member function. Add description of each parameter.\n"
"  Paramegers: (oaModNetTermPosArray)\n"
"    Calls: (const oaModNetTermPosArray&)\n"
"    Signature: oaModNetTermPosArray||cref-oaModNetTermPosArray,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModNetTermPosArray_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModNetTermPosArray",
    sizeof(PyoaModNetTermPosArrayObject),
    0,
    (destructor)oaModNetTermPosArray_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModNetTermPosArray_tp_compare,	/* tp_compare */
    (reprfunc)oaModNetTermPosArray_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModNetTermPosArray_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaNetTermArrayBase_oaModNet_oaUInt4_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModNetTermPosArray_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModNetTermPosArray_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModNetTermPosArray_Type)<0) {
      printf("** PyType_Ready failed for: oaModNetTermPosArray\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModNetTermPosArray",
           (PyObject*)(&PyoaModNetTermPosArray_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModNetTermPosArray\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModObject
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModObject_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModObject_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModObjectObject* self = (PyoaModObjectObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModObject)
    {
        PyParamoaModObject p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModObject_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModObject, Choices are:\n"
        "    (oaModObject)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModObject_tp_dealloc(PyoaModObjectObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModObject_tp_repr(PyObject *ob)
{
    PyParamoaModObject value;
    int convert_status=PyoaModObject_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[33];
    sprintf(buffer,"<oaModObject::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModObject_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModObject v1;
    PyParamoaModObject v2;
    int convert_status1=PyoaModObject_Convert(ob1,&v1);
    int convert_status2=PyoaModObject_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModObject_Convert(PyObject* ob,PyParamoaModObject* result)
{
    if (ob == NULL) return 1;
    if (PyoaModObject_Check(ob)) {
        result->SetData( (oaModObject**) ((PyoaModObjectObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModObject Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModObject_FromoaModObject(oaModObject** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaModObject* data=*value;
        if (data->getType()==oacModInstHeaderType) return PyoaModInstHeader_FromoaModInstHeader((oaModInstHeader**)value,borrow,lock);
        if (data->isModInst()) return PyoaModInst_FromoaModInst((oaModInst**)value,borrow,lock);
        if (data->getType()==oacModModuleInstHeaderType) return PyoaModModuleInstHeader_FromoaModModuleInstHeader((oaModModuleInstHeader**)value,borrow,lock);
        if (data->isModTerm()) return PyoaModTerm_FromoaModTerm((oaModTerm**)value,borrow,lock);
        if (data->isModConnectDef()) return PyoaModConnectDef_FromoaModConnectDef((oaModConnectDef**)value,borrow,lock);
        if (data->getType()==oacModVectorInstDefType) return PyoaModVectorInstDef_FromoaModVectorInstDef((oaModVectorInstDef**)value,borrow,lock);
        if (data->getType()==oacModInstTermType) return PyoaModInstTerm_FromoaModInstTerm((oaModInstTerm**)value,borrow,lock);
        if (data->isModAssignment()) return PyoaModAssignment_FromoaModAssignment((oaModAssignment**)value,borrow,lock);
        if (data->getType()==oacModBusTermDefType) return PyoaModBusTermDef_FromoaModBusTermDef((oaModBusTermDef**)value,borrow,lock);
        if (data->isModNet()) return PyoaModNet_FromoaModNet((oaModNet**)value,borrow,lock);
        if (data->getType()==oacModuleType) return PyoaModule_FromoaModule((oaModule**)value,borrow,lock);
        if (data->getType()==oacModBusNetDefType) return PyoaModBusNetDef_FromoaModBusNetDef((oaModBusNetDef**)value,borrow,lock);
        PyObject* bself = PyoaModObject_Type.tp_alloc(&PyoaModObject_Type,0);
        if (bself == NULL) return bself;
        PyoaModObjectObject* self = (PyoaModObjectObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaModObject_FromoaModObject(oaModObject* data)
{
    if (data) {
        if (data->getType()==oacModInstHeaderType) return PyoaModInstHeader_FromoaModInstHeader((oaModInstHeader*)data);
        if (data->isModInst()) return PyoaModInst_FromoaModInst((oaModInst*)data);
        if (data->getType()==oacModModuleInstHeaderType) return PyoaModModuleInstHeader_FromoaModModuleInstHeader((oaModModuleInstHeader*)data);
        if (data->isModTerm()) return PyoaModTerm_FromoaModTerm((oaModTerm*)data);
        if (data->isModConnectDef()) return PyoaModConnectDef_FromoaModConnectDef((oaModConnectDef*)data);
        if (data->getType()==oacModVectorInstDefType) return PyoaModVectorInstDef_FromoaModVectorInstDef((oaModVectorInstDef*)data);
        if (data->getType()==oacModInstTermType) return PyoaModInstTerm_FromoaModInstTerm((oaModInstTerm*)data);
        if (data->isModAssignment()) return PyoaModAssignment_FromoaModAssignment((oaModAssignment*)data);
        if (data->getType()==oacModBusTermDefType) return PyoaModBusTermDef_FromoaModBusTermDef((oaModBusTermDef*)data);
        if (data->isModNet()) return PyoaModNet_FromoaModNet((oaModNet*)data);
        if (data->getType()==oacModuleType) return PyoaModule_FromoaModule((oaModule*)data);
        if (data->getType()==oacModBusNetDefType) return PyoaModBusNetDef_FromoaModBusNetDef((oaModBusNetDef*)data);
       PyObject* bself = PyoaModObject_Type.tp_alloc(&PyoaModObject_Type,0);
       if (bself == NULL) return bself;
       PyoaModObjectObject* self = (PyoaModObjectObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModObject_getModule_doc[] = 
"Class: oaModObject, Function: getModule\n"
"  Paramegers: ()\n"
"    Calls: oaModule* getModule() const\n"
"    Signature: getModule|ptr-oaModule|\n"
"    BrowseData: 1\n"
"    This function returns the oaModule that contains this object.\n"
;

static PyObject*
oaModObject_getModule(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModObject data;
    int convert_status=PyoaModObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModObjectObject* self=(PyoaModObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModulep result= (data.DataCall()->getModule());
        return PyoaModule_FromoaModule(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModObject_getTopModule_doc[] = 
"Class: oaModObject, Function: getTopModule\n"
"  Paramegers: ()\n"
"    Calls: oaModule* getTopModule() const\n"
"    Signature: getTopModule|ptr-oaModule|\n"
"    BrowseData: 1\n"
"    This function returns the top oaModule in the design that contains this object.\n"
;

static PyObject*
oaModObject_getTopModule(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModObject data;
    int convert_status=PyoaModObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModObjectObject* self=(PyoaModObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModulep result= (data.DataCall()->getTopModule());
        return PyoaModule_FromoaModule(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModObject_isModAssignment_doc[] = 
"Class: oaModObject, Function: isModAssignment\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isModAssignment() const\n"
"    Signature: isModAssignment|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object is an instance of one of the classes derived from the oaModAssignment class. The function returns a boolean value of true if the oaModObject is an oaModAssignment object.\n"
;

static PyObject*
oaModObject_isModAssignment(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModObject data;
    int convert_status=PyoaModObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModObjectObject* self=(PyoaModObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isModAssignment());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModObject_isModBitInst_doc[] = 
"Class: oaModObject, Function: isModBitInst\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isModBitInst() const\n"
"    Signature: isModBitInst|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object is an instance of one of the classes derived from the oaModBitInst class. The function returns a boolean value of true if the oaModObject is an oaModBitInst object.\n"
;

static PyObject*
oaModObject_isModBitInst(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModObject data;
    int convert_status=PyoaModObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModObjectObject* self=(PyoaModObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isModBitInst());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModObject_isModBitNet_doc[] = 
"Class: oaModObject, Function: isModBitNet\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isModBitNet() const\n"
"    Signature: isModBitNet|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object is an instance of one of the classes derived from the oaModBitNet class. The function returns a boolean value of true if the oaModObject is an oaModBitNet object.\n"
;

static PyObject*
oaModObject_isModBitNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModObject data;
    int convert_status=PyoaModObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModObjectObject* self=(PyoaModObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isModBitNet());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModObject_isModBitTerm_doc[] = 
"Class: oaModObject, Function: isModBitTerm\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isModBitTerm() const\n"
"    Signature: isModBitTerm|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object is an instance of one of the classes derived from the oaModBitTerm class. The function returns a boolean value of true if the oaModObject is an oaModBitTerm object.\n"
;

static PyObject*
oaModObject_isModBitTerm(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModObject data;
    int convert_status=PyoaModObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModObjectObject* self=(PyoaModObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isModBitTerm());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModObject_isModConnectDef_doc[] = 
"Class: oaModObject, Function: isModConnectDef\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isModConnectDef() const\n"
"    Signature: isModConnectDef|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object is an instance of one of the classes derived from the oaModConnectDef class. The function returns a boolean value of true if the oaModObject is an oaModConnectDef .\n"
;

static PyObject*
oaModObject_isModConnectDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModObject data;
    int convert_status=PyoaModObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModObjectObject* self=(PyoaModObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isModConnectDef());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModObject_isModInst_doc[] = 
"Class: oaModObject, Function: isModInst\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isModInst() const\n"
"    Signature: isModInst|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object is an instance of one of the classes derived from the oaModInst class. The function returns a boolean value of true if the oaModObject is an oaModInst .\n"
;

static PyObject*
oaModObject_isModInst(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModObject data;
    int convert_status=PyoaModObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModObjectObject* self=(PyoaModObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isModInst());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModObject_isModNet_doc[] = 
"Class: oaModObject, Function: isModNet\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isModNet() const\n"
"    Signature: isModNet|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object is an instance of one of the classes derived from the oaModNet class. The function returns a boolean value of true if the oaModObject is an oaModNet .\n"
;

static PyObject*
oaModObject_isModNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModObject data;
    int convert_status=PyoaModObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModObjectObject* self=(PyoaModObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isModNet());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModObject_isModTerm_doc[] = 
"Class: oaModObject, Function: isModTerm\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isModTerm() const\n"
"    Signature: isModTerm|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function determines if this object is an instance of one of the classes derived from the oaModTerm class. The function returns a boolean value of true if the oaModObject is an oaModTerm .\n"
;

static PyObject*
oaModObject_isModTerm(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModObject data;
    int convert_status=PyoaModObject_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModObjectObject* self=(PyoaModObjectObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isModTerm());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModObject_isNull_doc[] =
"Class: oaModObject, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaModObject_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaModObject data;
    int convert_status=PyoaModObject_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaModObject_assign_doc[] = 
"Class: oaModObject, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModObject_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModObject data;
  int convert_status=PyoaModObject_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModObject p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModObject_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModObject_methodlist[] = {
    {"getModule",(PyCFunction)oaModObject_getModule,METH_VARARGS,oaModObject_getModule_doc},
    {"getTopModule",(PyCFunction)oaModObject_getTopModule,METH_VARARGS,oaModObject_getTopModule_doc},
    {"isModAssignment",(PyCFunction)oaModObject_isModAssignment,METH_VARARGS,oaModObject_isModAssignment_doc},
    {"isModBitInst",(PyCFunction)oaModObject_isModBitInst,METH_VARARGS,oaModObject_isModBitInst_doc},
    {"isModBitNet",(PyCFunction)oaModObject_isModBitNet,METH_VARARGS,oaModObject_isModBitNet_doc},
    {"isModBitTerm",(PyCFunction)oaModObject_isModBitTerm,METH_VARARGS,oaModObject_isModBitTerm_doc},
    {"isModConnectDef",(PyCFunction)oaModObject_isModConnectDef,METH_VARARGS,oaModObject_isModConnectDef_doc},
    {"isModInst",(PyCFunction)oaModObject_isModInst,METH_VARARGS,oaModObject_isModInst_doc},
    {"isModNet",(PyCFunction)oaModObject_isModNet,METH_VARARGS,oaModObject_isModNet_doc},
    {"isModTerm",(PyCFunction)oaModObject_isModTerm,METH_VARARGS,oaModObject_isModTerm_doc},
    {"isNull",(PyCFunction)oaModObject_tp_isNull,METH_VARARGS,oaModObject_isNull_doc},
    {"assign",(PyCFunction)oaModObject_tp_assign,METH_VARARGS,oaModObject_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModObject_doc[] = 
"Class: oaModObject\n"
"  This is the abstract base class for all logical objects in a design database. It implements functions which are common to all logical objects, as well as functions to determine the base types of objects.\n"
"Constructors:\n"
"  Paramegers: (oaModObject)\n"
"    Calls: (const oaModObject&)\n"
"    Signature: oaModObject||cref-oaModObject,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModObject_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModObject",
    sizeof(PyoaModObjectObject),
    0,
    (destructor)oaModObject_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModObject_tp_compare,	/* tp_compare */
    (reprfunc)oaModObject_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModObject_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaModObject_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaDesignObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModObject_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModObject_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModObject_Type)<0) {
      printf("** PyType_Ready failed for: oaModObject\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModObject",
           (PyObject*)(&PyoaModObject_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModObject\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModScalarInst
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModScalarInst_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModScalarInst_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModScalarInstObject* self = (PyoaModScalarInstObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModScalarInst)
    {
        PyParamoaModScalarInst p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModScalarInst_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModScalarInst, Choices are:\n"
        "    (oaModScalarInst)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModScalarInst_tp_dealloc(PyoaModScalarInstObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModScalarInst_tp_repr(PyObject *ob)
{
    PyParamoaModScalarInst value;
    int convert_status=PyoaModScalarInst_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaModScalarInst::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaSimpleName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[37];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaModScalarInst::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModScalarInst_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModScalarInst v1;
    PyParamoaModScalarInst v2;
    int convert_status1=PyoaModScalarInst_Convert(ob1,&v1);
    int convert_status2=PyoaModScalarInst_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModScalarInst_Convert(PyObject* ob,PyParamoaModScalarInst* result)
{
    if (ob == NULL) return 1;
    if (PyoaModScalarInst_Check(ob)) {
        result->SetData( (oaModScalarInst**) ((PyoaModScalarInstObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModScalarInst Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModScalarInst_FromoaModScalarInst(oaModScalarInst** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaModScalarInst* data=*value;
        PyObject* bself = PyoaModScalarInst_Type.tp_alloc(&PyoaModScalarInst_Type,0);
        if (bself == NULL) return bself;
        PyoaModScalarInstObject* self = (PyoaModScalarInstObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaModScalarInst_FromoaModScalarInst(oaModScalarInst* data)
{
    if (data) {
       PyObject* bself = PyoaModScalarInst_Type.tp_alloc(&PyoaModScalarInst_Type,0);
       if (bself == NULL) return bself;
       PyoaModScalarInstObject* self = (PyoaModScalarInstObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModScalarInst_getName_doc[] = 
"Class: oaModScalarInst, Function: getName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getName(oaScalarName& name) const\n"
"    Signature: getName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the name of this scalarInst in the name argument.\n"
"  Paramegers: (oaSimpleName)\n"
"    Calls: void getName(oaSimpleName& name) const\n"
"    Signature: getName|void-void|ref-oaSimpleName,\n"
"    BrowseData: 0,oaSimpleName\n"
"    This function fills out name with the name of this instance.\n"
"    name\n"
"    The returned instance name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function fills out name with the name of this instance. The name is mapped according to the specified nameSpace.\n"
"    ns\n"
"    The nameSpace used to map the name\n"
"    name\n"
"    The returned instance name\n"
;

static PyObject*
oaModScalarInst_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModScalarInst data;
    int convert_status=PyoaModScalarInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModScalarInstObject* self=(PyoaModScalarInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName)
    {
        PyParamoaSimpleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSimpleName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModScalarInst, function: getName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaSimpleName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModScalarInst_setName_doc[] = 
"Class: oaModScalarInst, Function: setName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void setName(const oaScalarName& name)\n"
"    Signature: setName|void-void|cref-oaScalarName,\n"
"    This function sets the name for this scalar inst.\n"
"    Exceptions are thrown if:\n"
"    the new name does not imply a scalar name\n"
"    an instance already exists with the given name\n"
"    a vectorInstDef exists with the given name\n"
"    name\n"
"    The new name to be set for this instance.\n"
"    oacInvalidHierInstName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
;

static PyObject*
oaModScalarInst_setName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModScalarInst data;
    int convert_status=PyoaModScalarInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModScalarInstObject* self=(PyoaModScalarInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScalarName p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaScalarName_Convert,&p1)) {
        data.DataCall()->setName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModScalarInst_isNull_doc[] =
"Class: oaModScalarInst, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaModScalarInst_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaModScalarInst data;
    int convert_status=PyoaModScalarInst_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaModScalarInst_assign_doc[] = 
"Class: oaModScalarInst, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModScalarInst_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModScalarInst data;
  int convert_status=PyoaModScalarInst_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModScalarInst p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModScalarInst_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModScalarInst_methodlist[] = {
    {"getName",(PyCFunction)oaModScalarInst_getName,METH_VARARGS,oaModScalarInst_getName_doc},
    {"setName",(PyCFunction)oaModScalarInst_setName,METH_VARARGS,oaModScalarInst_setName_doc},
    {"isNull",(PyCFunction)oaModScalarInst_tp_isNull,METH_VARARGS,oaModScalarInst_isNull_doc},
    {"assign",(PyCFunction)oaModScalarInst_tp_assign,METH_VARARGS,oaModScalarInst_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModScalarInst_doc[] = 
"Class: oaModScalarInst\n"
"  The oaModScalarInst class implements a scalar (single-bit) instance of design master. Scalar inst is the most common kind of instance. This class has a simple name with no index.\n"
"  oaModScalarInst objects are always in the module domain.\n"
"Constructors:\n"
"  Paramegers: (oaModScalarInst)\n"
"    Calls: (const oaModScalarInst&)\n"
"    Signature: oaModScalarInst||cref-oaModScalarInst,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModScalarInst_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModScalarInst",
    sizeof(PyoaModScalarInstObject),
    0,
    (destructor)oaModScalarInst_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModScalarInst_tp_compare,	/* tp_compare */
    (reprfunc)oaModScalarInst_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModScalarInst_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaModScalarInst_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaModBitInst_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModScalarInst_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModScalarInst_static_create_doc[] = 
"Class: oaModScalarInst, Function: create\n"
"  Paramegers: (oaModule,oaDesign,oaScalarName)\n"
"    Calls: oaModScalarInst* create(oaModule* module,oaDesign* master,const oaScalarName& name)\n"
"    Signature: create|ptr-oaModScalarInst|ptr-oaModule,ptr-oaDesign,cref-oaScalarName,cptr-oaParamArray,\n"
"    This function create an oaModScalarInst object with the specified attributes. This function lets you specify the master design and name for the new instance.\n"
"    Exceptions are thrown if:\n"
"    the new name does not imply a scalar name\n"
"    an instance already exists with the given name\n"
"    a vectorInstDef exist with the given name\n"
"    module\n"
"    The module in which to create the instance\n"
"    master\n"
"    A pointer to the instance master\n"
"    name\n"
"    The instance name\n"
"    params\n"
"    Optional parameter array for pCell instances\n"
"    oacInvalidSuperMaster\n"
"    oacInvalidHierInstName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"  Paramegers: (oaModule,oaDesign,oaScalarName,oaParamArray)\n"
"    Calls: oaModScalarInst* create(oaModule* module,oaDesign* master,const oaScalarName& name,const oaParamArray* params)\n"
"    Signature: create|ptr-oaModScalarInst|ptr-oaModule,ptr-oaDesign,cref-oaScalarName,cptr-oaParamArray,\n"
"    This function create an oaModScalarInst object with the specified attributes. This function lets you specify the master design and name for the new instance.\n"
"    Exceptions are thrown if:\n"
"    the new name does not imply a scalar name\n"
"    an instance already exists with the given name\n"
"    a vectorInstDef exist with the given name\n"
"    module\n"
"    The module in which to create the instance\n"
"    master\n"
"    A pointer to the instance master\n"
"    name\n"
"    The instance name\n"
"    params\n"
"    Optional parameter array for pCell instances\n"
"    oacInvalidSuperMaster\n"
"    oacInvalidHierInstName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"  Paramegers: (oaModule,oaDesign)\n"
"    Calls: oaModScalarInst* create(oaModule* module,oaDesign* master)\n"
"    Signature: create|ptr-oaModScalarInst|ptr-oaModule,ptr-oaDesign,cptr-oaParamArray,\n"
"    This function create an oaModScalarInst object with the specified attributes. This function lets you specify the master design. A name for the new instance is automatically generated.\n"
"    module\n"
"    The module in which to create the instance\n"
"    master\n"
"    A pointer to the instance master\n"
"    params\n"
"    Optional parameter array for pCell instances\n"
"    oacInvalidSuperMaster\n"
"  Paramegers: (oaModule,oaDesign,oaParamArray)\n"
"    Calls: oaModScalarInst* create(oaModule* module,oaDesign* master,const oaParamArray* params)\n"
"    Signature: create|ptr-oaModScalarInst|ptr-oaModule,ptr-oaDesign,cptr-oaParamArray,\n"
"    This function create an oaModScalarInst object with the specified attributes. This function lets you specify the master design. A name for the new instance is automatically generated.\n"
"    module\n"
"    The module in which to create the instance\n"
"    master\n"
"    A pointer to the instance master\n"
"    params\n"
"    Optional parameter array for pCell instances\n"
"    oacInvalidSuperMaster\n"
"  Paramegers: (oaModule,oaScalarName,oaScalarName,oaScalarName,oaScalarName)\n"
"    Calls: oaModScalarInst* create(oaModule* module,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName,const oaScalarName& name)\n"
"    Signature: create|ptr-oaModScalarInst|ptr-oaModule,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cptr-oaParamArray,\n"
"    This function creates an oaModScalarInst object with the specified attributes. The name for the instance is specified. Exceptions are thrown if:\n"
"    the new name does not imply a scalar name\n"
"    an instance exists with the given name\n"
"    a vectorInstDef exists with the given name\n"
"    module\n"
"    The module in which to create the instance\n"
"    libName\n"
"    The libName of the instance master\n"
"    cellName\n"
"    The cellName of the instance master\n"
"    viewName\n"
"    The viewName of the instance master\n"
"    name\n"
"    The instance name\n"
"    params\n"
"    Optional parameter array for pCell instances\n"
"    oacInvalidHierInstName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"  Paramegers: (oaModule,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaParamArray)\n"
"    Calls: oaModScalarInst* create(oaModule* module,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName,const oaScalarName& name,const oaParamArray* params)\n"
"    Signature: create|ptr-oaModScalarInst|ptr-oaModule,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cptr-oaParamArray,\n"
"    This function creates an oaModScalarInst object with the specified attributes. The name for the instance is specified. Exceptions are thrown if:\n"
"    the new name does not imply a scalar name\n"
"    an instance exists with the given name\n"
"    a vectorInstDef exists with the given name\n"
"    module\n"
"    The module in which to create the instance\n"
"    libName\n"
"    The libName of the instance master\n"
"    cellName\n"
"    The cellName of the instance master\n"
"    viewName\n"
"    The viewName of the instance master\n"
"    name\n"
"    The instance name\n"
"    params\n"
"    Optional parameter array for pCell instances\n"
"    oacInvalidHierInstName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"  Paramegers: (oaModule,oaScalarName,oaScalarName,oaScalarName)\n"
"    Calls: oaModScalarInst* create(oaModule* module,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName)\n"
"    Signature: create|ptr-oaModScalarInst|ptr-oaModule,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cptr-oaParamArray,\n"
"    This function creates an oaModScalarInst object with the specified attributes. The name for the instance is generated automatically by this create function, with the default name prefix I__%d, where d refers to an integer it will generate to make this name unique.\n"
"    module\n"
"    The module in which to create the instance\n"
"    libName\n"
"    The libName of the instance master\n"
"    cellName\n"
"    The cellName of the instance master\n"
"    viewName\n"
"    The viewName of the instance master\n"
"    params\n"
"    Optional parameter array for pCell instances\n"
"  Paramegers: (oaModule,oaScalarName,oaScalarName,oaScalarName,oaParamArray)\n"
"    Calls: oaModScalarInst* create(oaModule* module,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName,const oaParamArray* params)\n"
"    Signature: create|ptr-oaModScalarInst|ptr-oaModule,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cptr-oaParamArray,\n"
"    This function creates an oaModScalarInst object with the specified attributes. The name for the instance is generated automatically by this create function, with the default name prefix I__%d, where d refers to an integer it will generate to make this name unique.\n"
"    module\n"
"    The module in which to create the instance\n"
"    libName\n"
"    The libName of the instance master\n"
"    cellName\n"
"    The cellName of the instance master\n"
"    viewName\n"
"    The viewName of the instance master\n"
"    params\n"
"    Optional parameter array for pCell instances\n"
;

static PyObject*
oaModScalarInst_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaModule,oaDesign,oaScalarName)
    {
        PyParamoaModule p1;
        PyParamoaDesign p2;
        PyParamoaScalarName p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaDesign_Convert,&p2,
              &PyoaScalarName_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaModScalarInstp result= (oaModScalarInst::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaModScalarInst_FromoaModScalarInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaDesign,oaScalarName,oaParamArray)
    {
        PyParamoaModule p1;
        PyParamoaDesign p2;
        PyParamoaScalarName p3;
        PyParamoaParamArray p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaDesign_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaParamArray_ConvertAof,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaModScalarInstp result= (oaModScalarInst::create(p1.Data(),p2.Data(),p3.Data(),p4.DataAof()));
            return PyoaModScalarInst_FromoaModScalarInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaDesign)
    {
        PyParamoaModule p1;
        PyParamoaDesign p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaDesign_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaModScalarInstp result= (oaModScalarInst::create(p1.Data(),p2.Data()));
            return PyoaModScalarInst_FromoaModScalarInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaDesign,oaParamArray)
    {
        PyParamoaModule p1;
        PyParamoaDesign p2;
        PyParamoaParamArray p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaDesign_Convert,&p2,
              &PyoaParamArray_ConvertAof,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaModScalarInstp result= (oaModScalarInst::create(p1.Data(),p2.Data(),p3.DataAof()));
            return PyoaModScalarInst_FromoaModScalarInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaScalarName,oaScalarName,oaScalarName,oaScalarName)
    {
        PyParamoaModule p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        PyParamoaScalarName p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4,
              &PyoaScalarName_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModScalarInstp result= (oaModScalarInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
            return PyoaModScalarInst_FromoaModScalarInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaParamArray)
    {
        PyParamoaModule p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        PyParamoaScalarName p5;
        PyParamoaParamArray p6;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4,
              &PyoaScalarName_Convert,&p5,
              &PyoaParamArray_ConvertAof,&p6)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModScalarInstp result= (oaModScalarInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.DataAof()));
            return PyoaModScalarInst_FromoaModScalarInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaScalarName,oaScalarName,oaScalarName)
    {
        PyParamoaModule p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModScalarInstp result= (oaModScalarInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaModScalarInst_FromoaModScalarInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaScalarName,oaScalarName,oaScalarName,oaParamArray)
    {
        PyParamoaModule p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        PyParamoaParamArray p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4,
              &PyoaParamArray_ConvertAof,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModScalarInstp result= (oaModScalarInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.DataAof()));
            return PyoaModScalarInst_FromoaModScalarInst(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModScalarInst, function: create, Choices are:\n"
        "    (oaModule,oaDesign,oaScalarName)\n"
        "    (oaModule,oaDesign,oaScalarName,oaParamArray)\n"
        "    (oaModule,oaDesign)\n"
        "    (oaModule,oaDesign,oaParamArray)\n"
        "    (oaModule,oaScalarName,oaScalarName,oaScalarName,oaScalarName)\n"
        "    (oaModule,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaParamArray)\n"
        "    (oaModule,oaScalarName,oaScalarName,oaScalarName)\n"
        "    (oaModule,oaScalarName,oaScalarName,oaScalarName,oaParamArray)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModScalarInst_static_find_doc[] = 
"Class: oaModScalarInst, Function: find\n"
"  Paramegers: (oaModule,oaScalarName)\n"
"    Calls: oaModScalarInst* find(const oaModule* module,const oaScalarName& name)\n"
"    Signature: find|ptr-oaModScalarInst|cptr-oaModule,cref-oaScalarName,\n"
"    This function searches the specified module for a module scalarInst with the specified name. If the name is found, the function returns the module scalar instance. Otherwise, NULL is returned.\n"
"    The oaModScalarInst pointer or NULL\n"
;

static PyObject*
oaModScalarInst_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaModule_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaModScalarInstp result= (oaModScalarInst::find(p1.Data(),p2.Data()));
        return PyoaModScalarInst_FromoaModScalarInst(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModScalarInst_static_isValidName_doc[] = 
"Class: oaModScalarInst, Function: isValidName\n"
"  Paramegers: (oaModule,oaScalarName)\n"
"    Calls: oaBoolean isValidName(const oaModule* module,const oaScalarName& name)\n"
"    Signature: isValidName|simple-oaBoolean|cptr-oaModule,cref-oaScalarName,\n"
"    This function returns a boolean value that indicates if the specified name is valid for a new oaModScalarInst in the specified module .\n"
"    Exceptions are thrown if:\n"
"    the specified name does not imply a scalar name\n"
"    an instance already exists with the specified name\n"
"    a vectorInstDef exists with the specified name\n"
"    oacInvalidHierInstName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
;

static PyObject*
oaModScalarInst_static_isValidName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaModule_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (oaModScalarInst::isValidName(p1.Data(),p2.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaModScalarInst_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaModScalarInst_static_create,METH_VARARGS,oaModScalarInst_static_create_doc},
    {"static_find",(PyCFunction)oaModScalarInst_static_find,METH_VARARGS,oaModScalarInst_static_find_doc},
    {"static_isValidName",(PyCFunction)oaModScalarInst_static_isValidName,METH_VARARGS,oaModScalarInst_static_isValidName_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModScalarInst_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModScalarInst_Type)<0) {
      printf("** PyType_Ready failed for: oaModScalarInst\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModScalarInst",
           (PyObject*)(&PyoaModScalarInst_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModScalarInst\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaModScalarInst_Type.tp_dict;
    for(method=oaModScalarInst_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModScalarNet
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModScalarNet_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModScalarNet_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModScalarNetObject* self = (PyoaModScalarNetObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModScalarNet)
    {
        PyParamoaModScalarNet p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModScalarNet_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModScalarNet, Choices are:\n"
        "    (oaModScalarNet)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModScalarNet_tp_dealloc(PyoaModScalarNetObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModScalarNet_tp_repr(PyObject *ob)
{
    PyParamoaModScalarNet value;
    int convert_status=PyoaModScalarNet_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaModScalarNet::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaScalarName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[36];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaModScalarNet::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModScalarNet_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModScalarNet v1;
    PyParamoaModScalarNet v2;
    int convert_status1=PyoaModScalarNet_Convert(ob1,&v1);
    int convert_status2=PyoaModScalarNet_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModScalarNet_Convert(PyObject* ob,PyParamoaModScalarNet* result)
{
    if (ob == NULL) return 1;
    if (PyoaModScalarNet_Check(ob)) {
        result->SetData( (oaModScalarNet**) ((PyoaModScalarNetObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModScalarNet Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModScalarNet_FromoaModScalarNet(oaModScalarNet** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaModScalarNet* data=*value;
        PyObject* bself = PyoaModScalarNet_Type.tp_alloc(&PyoaModScalarNet_Type,0);
        if (bself == NULL) return bself;
        PyoaModScalarNetObject* self = (PyoaModScalarNetObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaModScalarNet_FromoaModScalarNet(oaModScalarNet* data)
{
    if (data) {
       PyObject* bself = PyoaModScalarNet_Type.tp_alloc(&PyoaModScalarNet_Type,0);
       if (bself == NULL) return bself;
       PyoaModScalarNetObject* self = (PyoaModScalarNetObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModScalarNet_getName_doc[] = 
"Class: oaModScalarNet, Function: getName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getName(oaScalarName& name) const\n"
"    Signature: getName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the name of this scalar net.\n"
"    name\n"
"    The net name to return\n"
"  Paramegers: (oaName)\n"
"    Calls: void getName(oaName& name) const\n"
"    Signature: getName|void-void|ref-oaName,\n"
"    BrowseData: 0,oaName\n"
"    This function returns the name of this net in the name argument.\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the name of this net in the specified nameSpace in the specified name string.\n"
;

static PyObject*
oaModScalarNet_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModScalarNet data;
    int convert_status=PyoaModScalarNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModScalarNetObject* self=(PyoaModScalarNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaName)
    {
        PyParamoaName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModScalarNet, function: getName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModScalarNet_setName_doc[] = 
"Class: oaModScalarNet, Function: setName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void setName(const oaScalarName& name)\n"
"    Signature: setName|void-void|cref-oaScalarName,\n"
"    This function sets the name of this oaModScalarNet object. The name is also updated for each of the occurrences that the net appears in.\n"
"    name\n"
"    The new name to be set for this net.\n"
"    oacNetExists\n"
"    oacImplicitModuleNetExists\n"
"    oacImplicitBlockNetExists\n"
"    oacScalarNetNameMatchesBusBaseName\n"
"    oacInvalidHierNetName\n"
;

static PyObject*
oaModScalarNet_setName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModScalarNet data;
    int convert_status=PyoaModScalarNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModScalarNetObject* self=(PyoaModScalarNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScalarName p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaScalarName_Convert,&p1)) {
        data.DataCall()->setName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModScalarNet_isNull_doc[] =
"Class: oaModScalarNet, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaModScalarNet_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaModScalarNet data;
    int convert_status=PyoaModScalarNet_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaModScalarNet_assign_doc[] = 
"Class: oaModScalarNet, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModScalarNet_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModScalarNet data;
  int convert_status=PyoaModScalarNet_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModScalarNet p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModScalarNet_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModScalarNet_methodlist[] = {
    {"getName",(PyCFunction)oaModScalarNet_getName,METH_VARARGS,oaModScalarNet_getName_doc},
    {"setName",(PyCFunction)oaModScalarNet_setName,METH_VARARGS,oaModScalarNet_setName_doc},
    {"isNull",(PyCFunction)oaModScalarNet_tp_isNull,METH_VARARGS,oaModScalarNet_isNull_doc},
    {"assign",(PyCFunction)oaModScalarNet_tp_assign,METH_VARARGS,oaModScalarNet_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModScalarNet_doc[] = 
"Class: oaModScalarNet\n"
"  The oaModScalarNet class implements a scalar (single-bit) net.\n"
"Constructors:\n"
"  Paramegers: (oaModScalarNet)\n"
"    Calls: (const oaModScalarNet&)\n"
"    Signature: oaModScalarNet||cref-oaModScalarNet,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModScalarNet_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModScalarNet",
    sizeof(PyoaModScalarNetObject),
    0,
    (destructor)oaModScalarNet_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModScalarNet_tp_compare,	/* tp_compare */
    (reprfunc)oaModScalarNet_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModScalarNet_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaModScalarNet_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaModBitNet_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModScalarNet_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModScalarNet_static_create_doc[] = 
"Class: oaModScalarNet, Function: create\n"
"  Paramegers: (oaModule,oaScalarName)\n"
"    Calls: oaModScalarNet* create(oaModule* module,const oaScalarName& name)\n"
"    Signature: create|ptr-oaModScalarNet|ptr-oaModule,cref-oaScalarName,simple-oaSigType,simple-oaBoolean,\n"
"    This function creates a scalarNet with the specified name in the given module. The function checks the specified name to verify it is unused. If the name is used on an implicit net, that implicit net is set to explicit and nothing else is processed.\n"
"    module\n"
"    The module in which to create the net. This module may be any module inside of a design.\n"
"    name\n"
"    The name of the scalar net to create\n"
"    sigType\n"
"    The signal type\n"
"    isGlobal\n"
"    The flag to indicate global net; the default is false\n"
"    oacNetExists\n"
"    oacImplicitModuleNetExists\n"
"    oacImplicitBlockNetExists\n"
"    oacScalarNetNameMatchesBusBaseName\n"
"    oacInvalidHierNetName\n"
"  Paramegers: (oaModule,oaScalarName,oaSigType)\n"
"    Calls: oaModScalarNet* create(oaModule* module,const oaScalarName& name,oaSigType type)\n"
"    Signature: create|ptr-oaModScalarNet|ptr-oaModule,cref-oaScalarName,simple-oaSigType,simple-oaBoolean,\n"
"    This function creates a scalarNet with the specified name in the given module. The function checks the specified name to verify it is unused. If the name is used on an implicit net, that implicit net is set to explicit and nothing else is processed.\n"
"    module\n"
"    The module in which to create the net. This module may be any module inside of a design.\n"
"    name\n"
"    The name of the scalar net to create\n"
"    sigType\n"
"    The signal type\n"
"    isGlobal\n"
"    The flag to indicate global net; the default is false\n"
"    oacNetExists\n"
"    oacImplicitModuleNetExists\n"
"    oacImplicitBlockNetExists\n"
"    oacScalarNetNameMatchesBusBaseName\n"
"    oacInvalidHierNetName\n"
"  Paramegers: (oaModule,oaScalarName,oaSigType,oaBoolean)\n"
"    Calls: oaModScalarNet* create(oaModule* module,const oaScalarName& name,oaSigType type,oaBoolean isGlobal)\n"
"    Signature: create|ptr-oaModScalarNet|ptr-oaModule,cref-oaScalarName,simple-oaSigType,simple-oaBoolean,\n"
"    This function creates a scalarNet with the specified name in the given module. The function checks the specified name to verify it is unused. If the name is used on an implicit net, that implicit net is set to explicit and nothing else is processed.\n"
"    module\n"
"    The module in which to create the net. This module may be any module inside of a design.\n"
"    name\n"
"    The name of the scalar net to create\n"
"    sigType\n"
"    The signal type\n"
"    isGlobal\n"
"    The flag to indicate global net; the default is false\n"
"    oacNetExists\n"
"    oacImplicitModuleNetExists\n"
"    oacImplicitBlockNetExists\n"
"    oacScalarNetNameMatchesBusBaseName\n"
"    oacInvalidHierNetName\n"
"  Paramegers: (oaModule)\n"
"    Calls: oaModScalarNet* create(oaModule* module)\n"
"    Signature: create|ptr-oaModScalarNet|ptr-oaModule,simple-oaSigType,simple-oaBoolean,\n"
"    This function creates a scalarNet in the specified module with an automatically generated name. The default name prefix for automatically generated names is N__%d, where d is an integer that makes the name unique.\n"
"    module\n"
"    The module in which to create the net. This module may be any module inside of a cellview.\n"
"    type\n"
"    The signal type; the default value is oacSignalSigType\n"
"    isGlobal\n"
"    The flag to indicate whether this is a global net\n"
"    oacNetExists\n"
"    oacImplicitModuleNetExists\n"
"    oacImplicitBlockNetExists\n"
"    oacScalarNetNameMatchesBusBaseName\n"
"    oacInvalidHierNetName\n"
"  Paramegers: (oaModule,oaSigType)\n"
"    Calls: oaModScalarNet* create(oaModule* module,oaSigType type)\n"
"    Signature: create|ptr-oaModScalarNet|ptr-oaModule,simple-oaSigType,simple-oaBoolean,\n"
"    This function creates a scalarNet in the specified module with an automatically generated name. The default name prefix for automatically generated names is N__%d, where d is an integer that makes the name unique.\n"
"    module\n"
"    The module in which to create the net. This module may be any module inside of a cellview.\n"
"    type\n"
"    The signal type; the default value is oacSignalSigType\n"
"    isGlobal\n"
"    The flag to indicate whether this is a global net\n"
"    oacNetExists\n"
"    oacImplicitModuleNetExists\n"
"    oacImplicitBlockNetExists\n"
"    oacScalarNetNameMatchesBusBaseName\n"
"    oacInvalidHierNetName\n"
"  Paramegers: (oaModule,oaSigType,oaBoolean)\n"
"    Calls: oaModScalarNet* create(oaModule* module,oaSigType type,oaBoolean isGlobal)\n"
"    Signature: create|ptr-oaModScalarNet|ptr-oaModule,simple-oaSigType,simple-oaBoolean,\n"
"    This function creates a scalarNet in the specified module with an automatically generated name. The default name prefix for automatically generated names is N__%d, where d is an integer that makes the name unique.\n"
"    module\n"
"    The module in which to create the net. This module may be any module inside of a cellview.\n"
"    type\n"
"    The signal type; the default value is oacSignalSigType\n"
"    isGlobal\n"
"    The flag to indicate whether this is a global net\n"
"    oacNetExists\n"
"    oacImplicitModuleNetExists\n"
"    oacImplicitBlockNetExists\n"
"    oacScalarNetNameMatchesBusBaseName\n"
"    oacInvalidHierNetName\n"
;

static PyObject*
oaModScalarNet_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaModule,oaScalarName)
    {
        PyParamoaModule p1;
        PyParamoaScalarName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaScalarName_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModScalarNetp result= (oaModScalarNet::create(p1.Data(),p2.Data()));
            return PyoaModScalarNet_FromoaModScalarNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaScalarName,oaSigType)
    {
        PyParamoaModule p1;
        PyParamoaScalarName p2;
        PyParamoaSigType p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaSigType_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModScalarNetp result= (oaModScalarNet::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaModScalarNet_FromoaModScalarNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaScalarName,oaSigType,oaBoolean)
    {
        PyParamoaModule p1;
        PyParamoaScalarName p2;
        PyParamoaSigType p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaSigType_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModScalarNetp result= (oaModScalarNet::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaModScalarNet_FromoaModScalarNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule)
    {
        PyParamoaModule p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaModule_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModScalarNetp result= (oaModScalarNet::create(p1.Data()));
            return PyoaModScalarNet_FromoaModScalarNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaSigType)
    {
        PyParamoaModule p1;
        PyParamoaSigType p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaSigType_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModScalarNetp result= (oaModScalarNet::create(p1.Data(),p2.Data()));
            return PyoaModScalarNet_FromoaModScalarNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaSigType,oaBoolean)
    {
        PyParamoaModule p1;
        PyParamoaSigType p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaSigType_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModScalarNetp result= (oaModScalarNet::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaModScalarNet_FromoaModScalarNet(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModScalarNet, function: create, Choices are:\n"
        "    (oaModule,oaScalarName)\n"
        "    (oaModule,oaScalarName,oaSigType)\n"
        "    (oaModule,oaScalarName,oaSigType,oaBoolean)\n"
        "    (oaModule)\n"
        "    (oaModule,oaSigType)\n"
        "    (oaModule,oaSigType,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModScalarNet_static_find_doc[] = 
"Class: oaModScalarNet, Function: find\n"
"  Paramegers: (oaModule,oaScalarName)\n"
"    Calls: oaModScalarNet* find(const oaModule* module,const oaScalarName& name)\n"
"    Signature: find|ptr-oaModScalarNet|cptr-oaModule,cref-oaScalarName,\n"
"    This function searches the specified module for a scalarNet with the specified name. The function returns the net if it is found. Otherwise, NULL is returned.\n"
"    module\n"
"    The module to search\n"
"    name\n"
"    The scalar net name to find\n"
"    The scalar net name or NULL\n"
;

static PyObject*
oaModScalarNet_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaModule_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaModScalarNetp result= (oaModScalarNet::find(p1.Data(),p2.Data()));
        return PyoaModScalarNet_FromoaModScalarNet(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModScalarNet_static_isValidName_doc[] = 
"Class: oaModScalarNet, Function: isValidName\n"
"  Paramegers: (oaModule,oaScalarName)\n"
"    Calls: oaBoolean isValidName(const oaModule* module,const oaScalarName& name)\n"
"    Signature: isValidName|simple-oaBoolean|cptr-oaModule,cref-oaScalarName,\n"
"    This function returns a boolean value that indicates if the specified name is valid for a new oaModScalarNet in the specified module.\n"
"    module\n"
"    The module to search\n"
"    name\n"
"    The scalar net name to find\n"
;

static PyObject*
oaModScalarNet_static_isValidName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaModule_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (oaModScalarNet::isValidName(p1.Data(),p2.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaModScalarNet_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaModScalarNet_static_create,METH_VARARGS,oaModScalarNet_static_create_doc},
    {"static_find",(PyCFunction)oaModScalarNet_static_find,METH_VARARGS,oaModScalarNet_static_find_doc},
    {"static_isValidName",(PyCFunction)oaModScalarNet_static_isValidName,METH_VARARGS,oaModScalarNet_static_isValidName_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModScalarNet_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModScalarNet_Type)<0) {
      printf("** PyType_Ready failed for: oaModScalarNet\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModScalarNet",
           (PyObject*)(&PyoaModScalarNet_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModScalarNet\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaModScalarNet_Type.tp_dict;
    for(method=oaModScalarNet_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModScalarTerm
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModScalarTerm_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModScalarTerm_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModScalarTermObject* self = (PyoaModScalarTermObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModScalarTerm)
    {
        PyParamoaModScalarTerm p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModScalarTerm_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModScalarTerm, Choices are:\n"
        "    (oaModScalarTerm)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModScalarTerm_tp_dealloc(PyoaModScalarTermObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModScalarTerm_tp_repr(PyObject *ob)
{
    PyParamoaModScalarTerm value;
    int convert_status=PyoaModScalarTerm_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaModScalarTerm::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaScalarName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[37];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaModScalarTerm::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModScalarTerm_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModScalarTerm v1;
    PyParamoaModScalarTerm v2;
    int convert_status1=PyoaModScalarTerm_Convert(ob1,&v1);
    int convert_status2=PyoaModScalarTerm_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModScalarTerm_Convert(PyObject* ob,PyParamoaModScalarTerm* result)
{
    if (ob == NULL) return 1;
    if (PyoaModScalarTerm_Check(ob)) {
        result->SetData( (oaModScalarTerm**) ((PyoaModScalarTermObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModScalarTerm Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModScalarTerm_FromoaModScalarTerm(oaModScalarTerm** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaModScalarTerm* data=*value;
        PyObject* bself = PyoaModScalarTerm_Type.tp_alloc(&PyoaModScalarTerm_Type,0);
        if (bself == NULL) return bself;
        PyoaModScalarTermObject* self = (PyoaModScalarTermObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaModScalarTerm_FromoaModScalarTerm(oaModScalarTerm* data)
{
    if (data) {
       PyObject* bself = PyoaModScalarTerm_Type.tp_alloc(&PyoaModScalarTerm_Type,0);
       if (bself == NULL) return bself;
       PyoaModScalarTermObject* self = (PyoaModScalarTermObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModScalarTerm_getName_doc[] = 
"Class: oaModScalarTerm, Function: getName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getName(oaScalarName& name) const\n"
"    Signature: getName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the name of this terminal in the name argument.\n"
"    name\n"
"    The name of the scalar terminal to return\n"
"  Paramegers: (oaName)\n"
"    Calls: void getName(oaName& name) const\n"
"    Signature: getName|void-void|ref-oaName,\n"
"    BrowseData: 0,oaName\n"
"    This function fills out name with the name of this terminal.\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function fills in name with the name of this terminal mapped to the specified nameSpace.\n"
;

static PyObject*
oaModScalarTerm_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModScalarTerm data;
    int convert_status=PyoaModScalarTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModScalarTermObject* self=(PyoaModScalarTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaName)
    {
        PyParamoaName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModScalarTerm, function: getName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModScalarTerm_setName_doc[] = 
"Class: oaModScalarTerm, Function: setName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void setName(const oaScalarName& name)\n"
"    Signature: setName|void-void|cref-oaScalarName,\n"
"    This function sets the name of this oaModScalarTerm object. The name is also updated for each occurrence that the term appears in.\n"
"    name\n"
"    The new name to be set for this term.\n"
;

static PyObject*
oaModScalarTerm_setName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModScalarTerm data;
    int convert_status=PyoaModScalarTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModScalarTermObject* self=(PyoaModScalarTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScalarName p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaScalarName_Convert,&p1)) {
        data.DataCall()->setName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModScalarTerm_isNull_doc[] =
"Class: oaModScalarTerm, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaModScalarTerm_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaModScalarTerm data;
    int convert_status=PyoaModScalarTerm_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaModScalarTerm_assign_doc[] = 
"Class: oaModScalarTerm, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModScalarTerm_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModScalarTerm data;
  int convert_status=PyoaModScalarTerm_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModScalarTerm p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModScalarTerm_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModScalarTerm_methodlist[] = {
    {"getName",(PyCFunction)oaModScalarTerm_getName,METH_VARARGS,oaModScalarTerm_getName_doc},
    {"setName",(PyCFunction)oaModScalarTerm_setName,METH_VARARGS,oaModScalarTerm_setName_doc},
    {"isNull",(PyCFunction)oaModScalarTerm_tp_isNull,METH_VARARGS,oaModScalarTerm_isNull_doc},
    {"assign",(PyCFunction)oaModScalarTerm_tp_assign,METH_VARARGS,oaModScalarTerm_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModScalarTerm_doc[] = 
"Class: oaModScalarTerm\n"
"  The oaModScalarTerm class implements a scalar (single-bit) terminal in the module domain.\n"
"  oaModScalarTerm, oaOccScalarTerm , and oaScalarTerm each represent scalar terminals on a different kind of master, where in each case the master represents a level of hierarchy in the design.\n"
"  For oaModScalarTerm, the master is an oaModule , and each module in a design will have a set of zero or more modScalarTerms. For oaOccScalarTerm , the master is an oaOccurrence .\n"
"  For oaScalarTerm , the master is an oaBlock , and the top block for the design will have a set of zero or more oaScalarTerms. Typically, many of the oaScalarTerms on the top oaBlock have a corresponding oaModScalarTerm on the top oaModule . All of the oaScalarTerms on the top oaBlock have a corresponding oaOccScalarTerm on the top oaOccurrence .\n"
"  When oaScalarTerm objects are created in the block domain, the corresponding oaModScalarTerm objects are automatically created on the top oaModule .\n"
"Constructors:\n"
"  Paramegers: (oaModScalarTerm)\n"
"    Calls: (const oaModScalarTerm&)\n"
"    Signature: oaModScalarTerm||cref-oaModScalarTerm,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModScalarTerm_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModScalarTerm",
    sizeof(PyoaModScalarTermObject),
    0,
    (destructor)oaModScalarTerm_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModScalarTerm_tp_compare,	/* tp_compare */
    (reprfunc)oaModScalarTerm_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModScalarTerm_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaModScalarTerm_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaModBitTerm_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModScalarTerm_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModScalarTerm_static_create_doc[] = 
"Class: oaModScalarTerm, Function: create\n"
"  Paramegers: (oaModBitNet,oaScalarName)\n"
"    Calls: oaModScalarTerm* create(oaModBitNet* modNet,const oaScalarName& name)\n"
"    Signature: create|ptr-oaModScalarTerm|ptr-oaModBitNet,cref-oaScalarName,simple-oaTermType,\n"
"    This function creates a terminal with the given scalar name connected to the specified module net.\n"
"    modNet\n"
"    The module bitNet to create the terminal with\n"
"    name\n"
"    The name to use for the terminal\n"
"    type\n"
"    The type of terminal to create\n"
"    oacCannotCreateTermWithImplicitNet\n"
"  Paramegers: (oaModBitNet,oaScalarName,oaTermType)\n"
"    Calls: oaModScalarTerm* create(oaModBitNet* modNet,const oaScalarName& name,oaTermType type)\n"
"    Signature: create|ptr-oaModScalarTerm|ptr-oaModBitNet,cref-oaScalarName,simple-oaTermType,\n"
"    This function creates a terminal with the given scalar name connected to the specified module net.\n"
"    modNet\n"
"    The module bitNet to create the terminal with\n"
"    name\n"
"    The name to use for the terminal\n"
"    type\n"
"    The type of terminal to create\n"
"    oacCannotCreateTermWithImplicitNet\n"
;

static PyObject*
oaModScalarTerm_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaModBitNet,oaScalarName)
    {
        PyParamoaModBitNet p1;
        PyParamoaScalarName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaModBitNet_Convert,&p1,
              &PyoaScalarName_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModScalarTermp result= (oaModScalarTerm::create(p1.Data(),p2.Data()));
            return PyoaModScalarTerm_FromoaModScalarTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModBitNet,oaScalarName,oaTermType)
    {
        PyParamoaModBitNet p1;
        PyParamoaScalarName p2;
        PyParamoaTermType p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaModBitNet_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaTermType_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModScalarTermp result= (oaModScalarTerm::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaModScalarTerm_FromoaModScalarTerm(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModScalarTerm, function: create, Choices are:\n"
        "    (oaModBitNet,oaScalarName)\n"
        "    (oaModBitNet,oaScalarName,oaTermType)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModScalarTerm_static_find_doc[] = 
"Class: oaModScalarTerm, Function: find\n"
"  Paramegers: (oaModule,oaScalarName)\n"
"    Calls: oaModScalarTerm* find(const oaModule* module,const oaScalarName& name)\n"
"    Signature: find|ptr-oaModScalarTerm|cptr-oaModule,cref-oaScalarName,\n"
"    This function searches the specified module for a scalarTerm with the specified name. The function returns a pointer to the oaModScalarTerm if it is found. Otherwise, NULL is returned.\n"
"    module\n"
"    The module to search\n"
"    name\n"
"    The name of the scalar terminal to find\n"
"    A pointer to the scalar terminal, if found; otherwise, NULL is returned\n"
;

static PyObject*
oaModScalarTerm_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaModule_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaModScalarTermp result= (oaModScalarTerm::find(p1.Data(),p2.Data()));
        return PyoaModScalarTerm_FromoaModScalarTerm(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModScalarTerm_static_isValidName_doc[] = 
"Class: oaModScalarTerm, Function: isValidName\n"
"  Paramegers: (oaModule,oaScalarName)\n"
"    Calls: oaBoolean isValidName(const oaModule* module,const oaScalarName& name)\n"
"    Signature: isValidName|simple-oaBoolean|cptr-oaModule,cref-oaScalarName,\n"
"    This function returns a boolean value that indicates if specified name is valid for a new oaModScalarTerm on the specified module.\n"
"    module\n"
"    The module to search\n"
"    name\n"
"    The name of the scalar terminal to return\n"
;

static PyObject*
oaModScalarTerm_static_isValidName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaModule_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (oaModScalarTerm::isValidName(p1.Data(),p2.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaModScalarTerm_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaModScalarTerm_static_create,METH_VARARGS,oaModScalarTerm_static_create_doc},
    {"static_find",(PyCFunction)oaModScalarTerm_static_find,METH_VARARGS,oaModScalarTerm_static_find_doc},
    {"static_isValidName",(PyCFunction)oaModScalarTerm_static_isValidName,METH_VARARGS,oaModScalarTerm_static_isValidName_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModScalarTerm_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModScalarTerm_Type)<0) {
      printf("** PyType_Ready failed for: oaModScalarTerm\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModScalarTerm",
           (PyObject*)(&PyoaModScalarTerm_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModScalarTerm\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaModScalarTerm_Type.tp_dict;
    for(method=oaModScalarTerm_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModTerm
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModTerm_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModTerm_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModTermObject* self = (PyoaModTermObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModTerm)
    {
        PyParamoaModTerm p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModTerm_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModTerm, Choices are:\n"
        "    (oaModTerm)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModTerm_tp_dealloc(PyoaModTermObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModTerm_tp_repr(PyObject *ob)
{
    PyParamoaModTerm value;
    int convert_status=PyoaModTerm_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaModTerm::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[31];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaModTerm::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModTerm_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModTerm v1;
    PyParamoaModTerm v2;
    int convert_status1=PyoaModTerm_Convert(ob1,&v1);
    int convert_status2=PyoaModTerm_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModTerm_Convert(PyObject* ob,PyParamoaModTerm* result)
{
    if (ob == NULL) return 1;
    if (PyoaModTerm_Check(ob)) {
        result->SetData( (oaModTerm**) ((PyoaModTermObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModTerm Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModTerm_FromoaModTerm(oaModTerm** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaModTerm* data=*value;
        if (data->getType()==oacModBusTermType) return PyoaModBusTerm_FromoaModBusTerm((oaModBusTerm**)value,borrow,lock);
        if (data->getType()==oacModBundleTermType) return PyoaModBundleTerm_FromoaModBundleTerm((oaModBundleTerm**)value,borrow,lock);
        if (data->isModBitTerm()) return PyoaModBitTerm_FromoaModBitTerm((oaModBitTerm**)value,borrow,lock);
        PyObject* bself = PyoaModTerm_Type.tp_alloc(&PyoaModTerm_Type,0);
        if (bself == NULL) return bself;
        PyoaModTermObject* self = (PyoaModTermObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaModTerm_FromoaModTerm(oaModTerm* data)
{
    if (data) {
        if (data->getType()==oacModBusTermType) return PyoaModBusTerm_FromoaModBusTerm((oaModBusTerm*)data);
        if (data->getType()==oacModBundleTermType) return PyoaModBundleTerm_FromoaModBundleTerm((oaModBundleTerm*)data);
        if (data->isModBitTerm()) return PyoaModBitTerm_FromoaModBitTerm((oaModBitTerm*)data);
       PyObject* bself = PyoaModTerm_Type.tp_alloc(&PyoaModTerm_Type,0);
       if (bself == NULL) return bself;
       PyoaModTermObject* self = (PyoaModTermObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModTerm_destroy_doc[] = 
"Class: oaModTerm, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function removes the ModTerm from its module and design.\n"
;

static PyObject*
oaModTerm_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModTerm data;
    int convert_status=PyoaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModTermObject* self=(PyoaModTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModTerm_getBit_doc[] = 
"Class: oaModTerm, Function: getBit\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaModBitTerm* getBit(oaUInt4 bitIndex) const\n"
"    Signature: getBit|ptr-oaModBitTerm|simple-oaUInt4,\n"
"    This function returns a pointer to the bit terminal that corresponds to the specified bitIndex bit of this terminal. For single-bit terminals, this function returns a pointer to itself. For multi-bit terminals, a busTermBit is returned if this terminal is a busTerm, or a bit terminal is returned if this terminal is a bundleTerm.\n"
"    bitIndex\n"
"    Specifies which bit of the terminal to return\n"
"    oacInvalidTermIndex\n"
;

static PyObject*
oaModTerm_getBit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModTerm data;
    int convert_status=PyoaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModTermObject* self=(PyoaModTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaModBitTermp result= (data.DataCall()->getBit(p1.Data()));
        return PyoaModBitTerm_FromoaModBitTerm(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModTerm_getName_doc[] = 
"Class: oaModTerm, Function: getName\n"
"  Paramegers: (oaName)\n"
"    Calls: void getName(oaName& name) const\n"
"    Signature: getName|void-void|ref-oaName,\n"
"    BrowseData: 0,oaName\n"
"    This function fills out name with the name of this terminal.\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function fills in name with the name of this terminal mapped to the specified nameSpace.\n"
;

static PyObject*
oaModTerm_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModTerm data;
    int convert_status=PyoaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModTermObject* self=(PyoaModTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaName)
    {
        PyParamoaName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModTerm, function: getName, Choices are:\n"
        "    (oaName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModTerm_getNet_doc[] = 
"Class: oaModTerm, Function: getNet\n"
"  Paramegers: ()\n"
"    Calls: oaModNet* getNet() const\n"
"    Signature: getNet|ptr-oaModNet|simple-oaBoolean,\n"
"    BrowseData: 1\n"
"    oaModTerm::getNet\n"
"    This function returns the net to which this terminal is attached. If preferred is true , the preferred equivalent net associated with the net will be returned instead.\n"
"    preferred\n"
"    indicates whether to return the preferred equivalent\n"
"    A pointer to an oaModNet\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: oaModNet* getNet(oaBoolean preferred) const\n"
"    Signature: getNet|ptr-oaModNet|simple-oaBoolean,\n"
"    oaModTerm::getNet\n"
"    This function returns the net to which this terminal is attached. If preferred is true , the preferred equivalent net associated with the net will be returned instead.\n"
"    preferred\n"
"    indicates whether to return the preferred equivalent\n"
"    A pointer to an oaModNet\n"
;

static PyObject*
oaModTerm_getNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModTerm data;
    int convert_status=PyoaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModTermObject* self=(PyoaModTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaModNetp result= (data.DataCall()->getNet());
            return PyoaModNet_FromoaModNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            oaModNetp result= (data.DataCall()->getNet(p1.Data()));
            return PyoaModNet_FromoaModNet(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModTerm, function: getNet, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModTerm_getNumBits_doc[] = 
"Class: oaModTerm, Function: getNumBits\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumBits() const\n"
"    Signature: getNumBits|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of bits in this terminal.\n"
;

static PyObject*
oaModTerm_getNumBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModTerm data;
    int convert_status=PyoaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModTermObject* self=(PyoaModTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumBits());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModTerm_getOccTerms_doc[] = 
"Class: oaModTerm, Function: getOccTerms\n"
"  Paramegers: (oaOccurrence)\n"
"    Calls: oaCollection_oaOccTerm_oaModTerm getOccTerms(const oaOccurrence* top) const\n"
"    Signature: getOccTerms|simple-oaCollection_oaOccTerm_oaModTerm|cptr-oaOccurrence,\n"
"    This function returns a collection of all the occurrence terminals that correspond to this module terminal. There can be multiple such occurrence terminals because of folding in the module hierarchy that results in one occurrence terminal for each path to this module from the top of the occurrence hierarchy.\n"
"    top\n"
"    A pointer to the top occurrence in a design\n"
"    oacInvalidTopOccurrence\n"
"    this exception is thrown when the passed-in occurrence is not the top occurrence in the occurrence hierarchy\n"
;

static PyObject*
oaModTerm_getOccTerms(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModTerm data;
    int convert_status=PyoaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModTermObject* self=(PyoaModTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaOccurrence p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccurrence_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaCollection_oaOccTerm_oaModTerm* result= new oaCollection_oaOccTerm_oaModTerm(data.DataCall()->getOccTerms(p1.Data()));
        return PyoaCollection_oaOccTerm_oaModTerm_FromoaCollection_oaOccTerm_oaModTerm(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModTerm_getOccTermsIter_doc[] = 
"Class: oaModTerm, Function: getOccTermsIter\n"
"  Paramegers: (oaOccurrence)\n"
"    Calls: oaIter_oaOccTerm getOccTermsIter(const oaOccurrence* top) const\n"
"    Signature: getOccTermsIter|simple-oaIter_oaOccTerm|cptr-oaOccurrence,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of all the occurrence terminals that correspond to this module terminal. There can be multiple such occurrence terminals because of folding in the module hierarchy that results in one occurrence terminal for each path to this module from the top of the occurrence hierarchy.\n"
"    top\n"
"    A pointer to the top occurrence in a design\n"
"    oacInvalidTopOccurrence\n"
"    this exception is thrown when the passed-in occurrence is not the top occurrence in the occurrence hierarchy\n"
;

static PyObject*
oaModTerm_getOccTermsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModTerm data;
    int convert_status=PyoaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModTermObject* self=(PyoaModTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaOccurrence p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccurrence_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaIter_oaOccTerm* result= new oaIter_oaOccTerm(data.DataCall()->getOccTerms(p1.Data()));
        return PyoaIter_oaOccTerm_FromoaIter_oaOccTerm(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModTerm_getPosition_doc[] = 
"Class: oaModTerm, Function: getPosition\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getPosition() const\n"
"    Signature: getPosition|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the position that this terminal is assigned to. The value oacNullIndex is returned if this terminal has not been assigned to a position.\n"
;

static PyObject*
oaModTerm_getPosition(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModTerm data;
    int convert_status=PyoaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModTermObject* self=(PyoaModTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getPosition());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModTerm_getTermType_doc[] = 
"Class: oaModTerm, Function: getTermType\n"
"  Paramegers: ()\n"
"    Calls: oaTermType getTermType() const\n"
"    Signature: getTermType|simple-oaTermType|\n"
"    BrowseData: 1\n"
"    This function returns the terminal type of this terminal.\n"
;

static PyObject*
oaModTerm_getTermType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModTerm data;
    int convert_status=PyoaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModTermObject* self=(PyoaModTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaTermType* result= new oaTermType(data.DataCall()->getTermType());
        return PyoaTermType_FromoaTermType(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModTerm_isImplicit_doc[] = 
"Class: oaModTerm, Function: isImplicit\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isImplicit() const\n"
"    Signature: isImplicit|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value indicating whether this terminal is implicit. An implicit terminal is automatically created by the database as part of the explicit creation of a multi-bit terminal.\n"
;

static PyObject*
oaModTerm_isImplicit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModTerm data;
    int convert_status=PyoaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModTermObject* self=(PyoaModTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isImplicit());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModTerm_isInterface_doc[] = 
"Class: oaModTerm, Function: isInterface\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isInterface() const\n"
"    Signature: isInterface|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether this terminal is an interface terminal. An interface terminal is one that was explicitly created by an application calling one of the create functions on the objects derived from oaTerm . Explicitly created terminals define the interface to the block that contains them.\n"
"    Note that an interface terminal that is scalarized is still considered an interface terminal. Implementation data may be added to the resulting bitTerms after scalarization, but the interface terminal remains as a reference to how the interface was originally defined. Further edits to the block may delete the interface terminal, indicating that the interface to the block has indeed changed.\n"
;

static PyObject*
oaModTerm_isInterface(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModTerm data;
    int convert_status=PyoaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModTermObject* self=(PyoaModTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isInterface());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModTerm_moveToNet_doc[] = 
"Class: oaModTerm, Function: moveToNet\n"
"  Paramegers: (oaModNet)\n"
"    Calls: void moveToNet(oaModNet* net)\n"
"    Signature: moveToNet|void-void|ptr-oaModNet,\n"
"    This function moves this terminal to the specified net .\n"
"    oacCannotMoveToImplicitNet\n"
"    oacCannotTransferNetWithTerm\n"
"    oacMoveToNetNotInSameDesign\n"
;

static PyObject*
oaModTerm_moveToNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModTerm data;
    int convert_status=PyoaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModTermObject* self=(PyoaModTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaModNet p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaModNet_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->moveToNet(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModTerm_scalarize_doc[] = 
"Class: oaModTerm, Function: scalarize\n"
"  Paramegers: ()\n"
"    Calls: void scalarize()\n"
"    Signature: scalarize|void-void|\n"
"    BrowseData: 0\n"
"    This function insures that the bitTerms associated with this terminal have been promoted to the explicit state so that they can support implementation data such as pins and routes.\n"
"    If this terminal is a multibit terminal, this function insures that all constituent bitTerms are promoted to the explicit state. The multibit terminal is then demoted to the implicit state so that no implementation data can be associated with it. When a terminal is demoted to the implicit state, associated implementation data is removed from it.\n"
"    The demotion of a multi-bit terminal has no affect on whether the terminal is an interface terminal (a terminal that was explicitly created defines the original interface for its corresponding block).\n"
"    oacCannotScalarizeImplicitTerm\n"
;

static PyObject*
oaModTerm_scalarize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModTerm data;
    int convert_status=PyoaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModTermObject* self=(PyoaModTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->scalarize();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModTerm_setIsInterface_doc[] = 
"Class: oaModTerm, Function: setIsInterface\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: void setIsInterface(oaBoolean isInterface)\n"
"    Signature: setIsInterface|void-void|simple-oaBoolean,\n"
"    This function changes the isInterface value for this terminal. For more information, see oaModTerm::isInterface .\n"
"    isInterface\n"
"    true or false to set or unset isInterface value\n"
"    oacCannotSetIsInterfaceOfImplicitTerm\n"
;

static PyObject*
oaModTerm_setIsInterface(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModTerm data;
    int convert_status=PyoaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModTermObject* self=(PyoaModTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBoolean p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBoolean_Convert,&p1)) {
        data.DataCall()->setIsInterface(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModTerm_setPosition_doc[] = 
"Class: oaModTerm, Function: setPosition\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setPosition(oaUInt4 position)\n"
"    Signature: setPosition|void-void|simple-oaUInt4,\n"
"    This function assigns or changes the position of this terminal to the specified position. It is an error to assign a position to an implicit terminal. It is also an error to specify a position that is assigned to another terminal.\n"
"    position\n"
"    The position to assign the terminal to.\n"
"    oacCannotSetPositionOfImplicitTerm\n"
"    oacTermPositionAlreadyTaken\n"
;

static PyObject*
oaModTerm_setPosition(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModTerm data;
    int convert_status=PyoaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModTermObject* self=(PyoaModTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setPosition(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModTerm_setTermType_doc[] = 
"Class: oaModTerm, Function: setTermType\n"
"  Paramegers: (oaTermType)\n"
"    Calls: void setTermType(oaTermType termType)\n"
"    Signature: setTermType|void-void|simple-oaTermType,\n"
"    This function changes the terminal type for this terminal.\n"
"    oacCannotSetBusTermBitTermType\n"
;

static PyObject*
oaModTerm_setTermType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModTerm data;
    int convert_status=PyoaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModTermObject* self=(PyoaModTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaTermType p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTermType_Convert,&p1)) {
        data.DataCall()->setTermType(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModTerm_unsetPosition_doc[] = 
"Class: oaModTerm, Function: unsetPosition\n"
"  Paramegers: ()\n"
"    Calls: void unsetPosition()\n"
"    Signature: unsetPosition|void-void|\n"
"    BrowseData: 0\n"
"    This function clears the position this terminal is assigned to, freeing the position so that another terminal can be assigned to it. Nothing is done if this terminal is not currently assigned a position.\n"
;

static PyObject*
oaModTerm_unsetPosition(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModTerm data;
    int convert_status=PyoaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModTermObject* self=(PyoaModTermObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->unsetPosition();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModTerm_isNull_doc[] =
"Class: oaModTerm, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaModTerm_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaModTerm data;
    int convert_status=PyoaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaModTerm_assign_doc[] = 
"Class: oaModTerm, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModTerm_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModTerm data;
  int convert_status=PyoaModTerm_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModTerm p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModTerm_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModTerm_methodlist[] = {
    {"destroy",(PyCFunction)oaModTerm_destroy,METH_VARARGS,oaModTerm_destroy_doc},
    {"getBit",(PyCFunction)oaModTerm_getBit,METH_VARARGS,oaModTerm_getBit_doc},
    {"getName",(PyCFunction)oaModTerm_getName,METH_VARARGS,oaModTerm_getName_doc},
    {"getNet",(PyCFunction)oaModTerm_getNet,METH_VARARGS,oaModTerm_getNet_doc},
    {"getNumBits",(PyCFunction)oaModTerm_getNumBits,METH_VARARGS,oaModTerm_getNumBits_doc},
    {"getOccTerms",(PyCFunction)oaModTerm_getOccTerms,METH_VARARGS,oaModTerm_getOccTerms_doc},
    {"getOccTermsIter",(PyCFunction)oaModTerm_getOccTermsIter,METH_VARARGS,oaModTerm_getOccTermsIter_doc},
    {"getPosition",(PyCFunction)oaModTerm_getPosition,METH_VARARGS,oaModTerm_getPosition_doc},
    {"getTermType",(PyCFunction)oaModTerm_getTermType,METH_VARARGS,oaModTerm_getTermType_doc},
    {"isImplicit",(PyCFunction)oaModTerm_isImplicit,METH_VARARGS,oaModTerm_isImplicit_doc},
    {"isInterface",(PyCFunction)oaModTerm_isInterface,METH_VARARGS,oaModTerm_isInterface_doc},
    {"moveToNet",(PyCFunction)oaModTerm_moveToNet,METH_VARARGS,oaModTerm_moveToNet_doc},
    {"scalarize",(PyCFunction)oaModTerm_scalarize,METH_VARARGS,oaModTerm_scalarize_doc},
    {"setIsInterface",(PyCFunction)oaModTerm_setIsInterface,METH_VARARGS,oaModTerm_setIsInterface_doc},
    {"setPosition",(PyCFunction)oaModTerm_setPosition,METH_VARARGS,oaModTerm_setPosition_doc},
    {"setTermType",(PyCFunction)oaModTerm_setTermType,METH_VARARGS,oaModTerm_setTermType_doc},
    {"unsetPosition",(PyCFunction)oaModTerm_unsetPosition,METH_VARARGS,oaModTerm_unsetPosition_doc},
    {"isNull",(PyCFunction)oaModTerm_tp_isNull,METH_VARARGS,oaModTerm_isNull_doc},
    {"assign",(PyCFunction)oaModTerm_tp_assign,METH_VARARGS,oaModTerm_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModTerm_doc[] = 
"Class: oaModTerm\n"
"  The oaModTerm class is an abstract base class for all scalar and multi-bit terminals in the module domain. Module terminals represent the logical connection points for a module. The nets associated with the terminals are logically exported through the terminals to the next level of hierarchy in a design.\n"
"  oaModTerm, oaOccTerm , and oaTerm each represent terminals on a different kind of master, where in each case the master represents a level of hierarchy in the design.\n"
"  For oaModTerm, the master is an oaModule , and each module in a design will have a set of zero or more modTerms.\n"
"  For oaTerm , the master is an oaBlock , and the top block for the design will have a set of zero or more modTerms. Typically, many of the oaTerms on the top oaBlock have a corresponding oaModTerm on the top oaModule . All of the oaTerms on the top oaBlock have a corresponding oaOccTerm on the top oaOccurrence .\n"
"  Note that oaModTerm::getOccTerms will return oaOccTerms only if the occurrence hierarchy has been expanded to include those objects. See Working in the Occurrence Domain for more details.\n"
"  When oaTerm objects are created in the block domain, the corresponding oaModTerm objects are automatically created on the top oaModule unless the domain visibility is set to oacExcludeFromModuleDomain .\n"
"  Multi-bit terminals represent a group of logical connections to import or export from the module. The terminals can consist of busTerms having a single root name with an index range, or they can include bundleTerms that are a more complex grouping of terminals. Multi-bit terminals can have overlapping names. For example, you can have the busTerms \"addr<7:0>\" and \"addr<3:0>\" as long as the overlapping bits are connected to the same nets.\n"
"  OA requires a consistent definition of single and multi-bit terminals shared between the top module and the top block in a design. When an oaBusTerm has been created that is not visible in the module domain, it is not possible to create an oaModBusTerm that uses the same base name. Similarly, it is not possible to create an oaModScalarTerm whose name would conflict with any oaScalarTerm or oaBusTerm in the block domain.\n"
"  All oaModBusTerms with the same root name are managed by an oaModBusTermDef . The oaModBusTermDef tracks the least significant and most significant bits of all the associated oaModBusTerms, all of the oaModBusTerms with the same base name, and all of the associated oaModBusTermBits.\n"
"  oaModBusTermBits are automatically created for each bit of an oaModBusTerm , if they do not already exist. oaModBusTermBits are available for those applications performing scalarized connectivity traversal of the data.\n"
"  oaModBundleTerms can contain oaModScalarTerms or oaModBusTerms. When an oaModBundleTerm is created, the constituent scalarTerms and busTermBits are automatically created in addition to the bundleTerm itself. All automatically created terminal objects are considered implicit .\n"
"  Names are associated with terminals. The various terminal objects take and return names through the general oaName object but also use the oaScalarName , oaVectorBitName , oaVectorName , and oaBundleName objects. These name objects manage the mapping of names from one nameSpace to another. For example, you can create a terminal using a name in the CDBA nameSpace. Another application can retrieve the terminal name in the Verilog nameSpace directly from the database.\n"
"  The oaModTerm class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaModTerm)\n"
"    Calls: (const oaModTerm&)\n"
"    Signature: oaModTerm||cref-oaModTerm,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModTerm_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModTerm",
    sizeof(PyoaModTermObject),
    0,
    (destructor)oaModTerm_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModTerm_tp_compare,	/* tp_compare */
    (reprfunc)oaModTerm_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModTerm_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaModTerm_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaModObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModTerm_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModTerm_static_create_doc[] = 
"Class: oaModTerm, Function: create\n"
"  Paramegers: (oaModNet,oaName)\n"
"    Calls: oaModTerm* create(oaModNet* modNet,const oaName& name)\n"
"    Signature: create|ptr-oaModTerm|ptr-oaModNet,cref-oaName,simple-oaTermType,\n"
"    This will create a new ModTerm on the specified net. This function can create scalar, busBit, bus, and bundle terminals. The exact type of module terminal depends on the type of the oaName that is supplied.\n"
"    modNet\n"
"    The net to create the terminal with\n"
"    name\n"
"    The name of the terminal\n"
"    termType\n"
"    The type of terminal to create\n"
"    oacCannotCreateTermWithImplicitNet\n"
"    oacInvalidTermName\n"
"  Paramegers: (oaModNet,oaName,oaTermType)\n"
"    Calls: oaModTerm* create(oaModNet* modNet,const oaName& name,oaTermType termType)\n"
"    Signature: create|ptr-oaModTerm|ptr-oaModNet,cref-oaName,simple-oaTermType,\n"
"    This will create a new ModTerm on the specified net. This function can create scalar, busBit, bus, and bundle terminals. The exact type of module terminal depends on the type of the oaName that is supplied.\n"
"    modNet\n"
"    The net to create the terminal with\n"
"    name\n"
"    The name of the terminal\n"
"    termType\n"
"    The type of terminal to create\n"
"    oacCannotCreateTermWithImplicitNet\n"
"    oacInvalidTermName\n"
;

static PyObject*
oaModTerm_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaModNet,oaName)
    {
        PyParamoaModNet p1;
        PyParamoaName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaModNet_Convert,&p1,
              &PyoaName_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModTermp result= (oaModTerm::create(p1.Data(),p2.Data()));
            return PyoaModTerm_FromoaModTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModNet,oaName,oaTermType)
    {
        PyParamoaModNet p1;
        PyParamoaName p2;
        PyParamoaTermType p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaModNet_Convert,&p1,
              &PyoaName_Convert,&p2,
              &PyoaTermType_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModTermp result= (oaModTerm::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaModTerm_FromoaModTerm(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModTerm, function: create, Choices are:\n"
        "    (oaModNet,oaName)\n"
        "    (oaModNet,oaName,oaTermType)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModTerm_static_find_doc[] = 
"Class: oaModTerm, Function: find\n"
"  Paramegers: (oaModule,oaName)\n"
"    Calls: oaModTerm* find(const oaModule* module,const oaName& name)\n"
"    Signature: find|ptr-oaModTerm|cptr-oaModule,cref-oaName,\n"
"    This function searches the terminals in the specified module for the one with the specified name . The terminal name cannot be hierarchical since a terminal is local to an instance. If the terminal is found, it is returned. Otherwise, NULL is returned.\n"
"  Paramegers: (oaModule,oaUInt4)\n"
"    Calls: oaModTerm* find(const oaModule* module,oaUInt4 position)\n"
"    Signature: find|ptr-oaModTerm|cptr-oaModule,simple-oaUInt4,\n"
"    This function the specified module for a terminal assigned to the specified position . The terminal is returned if found. Otherwise, NULL is returned.\n"
"    module\n"
"    The module to search for the terminal\n"
"    position\n"
"    The position of the terminal to match\n"
"    A pointer to an oaModTerm\n"
;

static PyObject*
oaModTerm_static_find(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaModule,oaName)
    {
        PyParamoaModule p1;
        PyParamoaName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaName_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModTermp result= (oaModTerm::find(p1.Data(),p2.Data()));
            return PyoaModTerm_FromoaModTerm(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaUInt4)
    {
        PyParamoaModule p1;
        PyParamoaUInt4 p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaUInt4_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModTermp result= (oaModTerm::find(p1.Data(),p2.Data()));
            return PyoaModTerm_FromoaModTerm(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModTerm, function: find, Choices are:\n"
        "    (oaModule,oaName)\n"
        "    (oaModule,oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModTerm_static_getMaxPosition_doc[] = 
"Class: oaModTerm, Function: getMaxPosition\n"
"  Paramegers: (oaModule)\n"
"    Calls: oaUInt4 getMaxPosition(const oaModule* module)\n"
"    Signature: getMaxPosition|simple-oaUInt4|cptr-oaModule,\n"
"    This function returns the highest position occupied by a terminal in the specified module . If there are no terminals in the module or no position has been assigned a terminal, the value oacNullIndex is returned.\n"
"    module\n"
"    The module to report the highest assigned terminal position from\n"
;

static PyObject*
oaModTerm_static_getMaxPosition(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaModule_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaUInt4 result= (oaModTerm::getMaxPosition(p1.Data()));
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModTerm_static_isValidName_doc[] = 
"Class: oaModTerm, Function: isValidName\n"
"  Paramegers: (oaModNet,oaName)\n"
"    Calls: oaBoolean isValidName(const oaModNet* net,const oaName& name)\n"
"    Signature: isValidName|simple-oaBoolean|cptr-oaModNet,cref-oaName,\n"
"    This function returns a boolean value indicating whether the specified name , associated with the specified net , is valid for a new oaModTerm object.\n"
;

static PyObject*
oaModTerm_static_isValidName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModNet p1;
    PyParamoaName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaModNet_Convert,&p1,
          &PyoaName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (oaModTerm::isValidName(p1.Data(),p2.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaModTerm_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaModTerm_static_create,METH_VARARGS,oaModTerm_static_create_doc},
    {"static_find",(PyCFunction)oaModTerm_static_find,METH_VARARGS,oaModTerm_static_find_doc},
    {"static_getMaxPosition",(PyCFunction)oaModTerm_static_getMaxPosition,METH_VARARGS,oaModTerm_static_getMaxPosition_doc},
    {"static_isValidName",(PyCFunction)oaModTerm_static_isValidName,METH_VARARGS,oaModTerm_static_isValidName_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModTerm_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModTerm_Type)<0) {
      printf("** PyType_Ready failed for: oaModTerm\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModTerm",
           (PyObject*)(&PyoaModTerm_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModTerm\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaModTerm_Type.tp_dict;
    for(method=oaModTerm_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


// ==================================================================
// Array for class: oaModTerm
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModTerm_Array_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModTerm_Array_Type);
    PyObject* gself = type->tp_alloc(type,0);
    if (gself == NULL) return gself;
    PyoaModTerm_ArrayObject* self = (PyoaModTerm_ArrayObject*)gself;
    self->borrow = 0;
    self->locks=NULL;
    static char *kwlist [] = { NULL } ;
    /* Case: () */ 
    {
        if (PyArg_ParseTuple(args,"")) {
            return gself;
        }
    }
    PyErr_Clear();
    /* Case: (int) */
    {
        int p1;
        if (PyArg_ParseTuple(args,(char*)"i",&p1)) {
            self->data.SetLen(p1);
            return gself;
        }
    }
    PyErr_Clear();
    /* Case: (oaModTerm_Array) */
    {
        PyParamoaModTerm_Array p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModTerm_Array_Convert,&p1)) {
            self->data.TakeAway(p1);
            return gself;
        }
    }
    /* Error */
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModTerm_Array, Choices are:\n"
        "    ()\n"
        "    (int)\n"
        "    (oaModTerm_Array)\n"
    );
    Py_DECREF(gself);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModTerm_Array_dealloc(PyObject* gself)
{
    PyoaModTerm_ArrayObject* self = (PyoaModTerm_ArrayObject*)gself;
    Py_XDECREF(self->locks);
    self->ob_type->tp_free(gself);
}

// ------------------------------------------------------------------
static PyObject*
oaModTerm_Array_str(PyObject *ob)
{
    PyParamoaModTerm_Array value;
    int convert_status=PyoaModTerm_Array_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* lst=PyoaModTerm_Array_CreateList(value);
    PyObject* result=PyObject_Str(lst);
    Py_DECREF(lst);
    return result;
}

// ------------------------------------------------------------------
static PyObject*
oaModTerm_Array_repr(PyObject *ob)
{
    PyParamoaModTerm_Array value;
    int convert_status=PyoaModTerm_Array_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* lst=PyoaModTerm_Array_CreateList(value);
    PyObject* result=PyObject_Repr(lst);
    Py_DECREF(lst);
    return result;
}

// ------------------------------------------------------------------
static int
oaModTerm_Array_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModTerm_Array p1;
    PyParamoaModTerm_Array p2;
    int s1=PyoaModTerm_Array_Convert(ob1,&p1);
    int s2=PyoaModTerm_Array_Convert(ob2,&p2);
    assert(s1!=0);
    assert(s2!=0);
    PyObject* l1=PyoaModTerm_Array_CreateList(p1);
    PyObject* l2=PyoaModTerm_Array_CreateList(p2);
    int result=PyObject_Compare(l1,l2);
    Py_DECREF(l1);
    Py_DECREF(l2);
    return result;
}

// ------------------------------------------------------------------
int
PyoaModTerm_Array_Convert(PyObject* ob,PyParamoaModTerm_Array* result)
{
  Pyoa_ssize_t len,i;
  if (PyoaModTerm_Array_Check(ob)) {
    PyoaModTerm_ArrayObject* self = (PyoaModTerm_ArrayObject*)ob;
    result->Borrow(self->data);
  }
  else if (PyList_Check(ob)) {
    len=PyList_Size(ob);
    result->SetLen(len);
    PyParamoaModTerm data;
    for(i=0;i<len;i++) {
      PyObject* a=PyList_GetItem(ob,i);
      if (!PyoaModTerm_Convert(a,&data)) return 0;
      result->SetItem(i,data.Data());
    }
  }
  else if (PyTuple_Check(ob)) {
    len=PyTuple_Size(ob);
    result->SetLen(len);
    PyParamoaModTerm data;
    for(i=0;i<len;i++) {
      PyObject* a=PyTuple_GetItem(ob,i);
      if (!PyoaModTerm_Convert(a,&data)) return 0;
      result->SetItem(i,data.Data());
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError,
      "Convertion of parameter to class: oaModTerm_Array Failed");
    return 0;
  }
  return 1;
}

// ------------------------------------------------------------------
PyObject* PyoaModTerm_Array_FromoaModTerm_Array(const oaModTerm_Array& value)
{
  PyObject* gself = PyoaModTerm_Array_Type.tp_alloc(&PyoaModTerm_Array_Type,0);
  if (gself == NULL) return gself;
  PyoaModTerm_ArrayObject* self = (PyoaModTerm_ArrayObject*)gself;
  self->data = value;
  self->borrow = 0;
  self->locks=NULL;
  return gself;
}

// ------------------------------------------------------------------
PyObject* PyoaModTerm_Array_FromoaModTerm_Array(PyTypeoaModTerm* data,Pyoa_ssize_t len,PyObject* lock)
{
  PyObject* gself = PyoaModTerm_Array_Type.tp_alloc(&PyoaModTerm_Array_Type,0);
  if (gself == NULL) return gself;
  PyoaModTerm_ArrayObject* self = (PyoaModTerm_ArrayObject*)gself;
  self->data.Borrow(data,len);
  self->borrow = 1;
  self->locks=NULL;
  if (lock) PyoaLockObject(self->locks,lock);
  return gself;
}

// ------------------------------------------------------------------
PyObject* PyoaModTerm_Array_CreateList(PyParamoaModTerm_Array& value)
{
  Pyoa_ssize_t i;
  PyObject* lst=PyList_New(value.Len());
  for(i=0;i<value.Len();i++) {
    PyObject* ob=PyoaModTerm_FromoaModTerm(value.Data()[i]);
    PyList_SetItem(lst,i,ob);
  }
  return lst;
}

// ------------------------------------------------------------------
// Methods
// ------------------------------------------------------------------
static char oaModTerm_Array_assign_doc[] = 
"Class: oaModTerm_Array, Function: assign\n"
"  Paramegers: (oaModTerm_Array)\n"
"    This function assigns the current value.\n"
;

static PyObject*
oaModTerm_Array_assign(PyObject* ob, PyObject *args)
{
  PyoaModTerm_ArrayObject* self=(PyoaModTerm_ArrayObject*)ob;
  try {
    PyParamoaModTerm_Array p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModTerm_Array_Convert,&p1)) {
        self->data=p1;
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}
// ------------------------------------------------------------------
static char oaModTerm_Array_list_doc[] = 
"Class: oaModTerm_Array, Function: list\n"
"  Paramegers: ()\n"
"    This function returns the current value as a list.\n"
;

static PyObject*
oaModTerm_Array_list(PyObject* ob, PyObject *args)
{
  PyoaModTerm_ArrayObject* self=(PyoaModTerm_ArrayObject*)ob;
  try {
    if (PyArg_ParseTuple(args,(char*)"")) {
      return PyoaModTerm_Array_CreateList(self->data);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}
// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------
static PyMethodDef oaModTerm_Array_methodlist[] = {
    {"assign",(PyCFunction)oaModTerm_Array_assign,METH_VARARGS,oaModTerm_Array_assign_doc},
    {"list",(PyCFunction)oaModTerm_Array_list,METH_VARARGS,oaModTerm_Array_list_doc},
   {NULL,NULL,0,NULL}
};

// ------------------------------------------------------------------
static PyObject*
oaModTerm_Array_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaModTerm_ArrayObject* self=(PyoaModTerm_ArrayObject*)ob;
  try {
    PyParamoaModTerm_Array data;
    int convert_status=PyoaModTerm_Array_Convert(ob,&data);
    assert(convert_status!=0);
    if (index<0 || index>=data.Len()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    return PyoaModTerm_FromoaModTerm(data.GetItemPtr(index),1,self->locks);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static Pyoa_ssize_t
oaModTerm_Array_index_get_length(PyObject* ob)
{
    PyParamoaModTerm_Array data;
    int convert_status=PyoaModTerm_Array_Convert(ob,&data);
    assert(convert_status!=0);
    return data.Len();
}

// ------------------------------------------------------------------
static int
oaModTerm_Array_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaModTerm_Array data;
    PyParamoaModTerm dataitem;
    int convert_status=PyoaModTerm_Array_Convert(ob,&data);
    assert(convert_status!=0);
    if (index<0 || index>=data.Len()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    if (PyoaModTerm_Convert(value,&dataitem)==0) return -1;
    data.SetItem(index,dataitem.Data());
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return 0;
  }
}

// ------------------------------------------------------------------
static char oaModTerm_Array_doc[] =
"Class: oaModTerm_Array\n"
"  The oaModTerm_Array utility class provides an array of oaModTerm.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaModTerm_Array()\n"
"    Signature: oaModTerm_Array||\n"
"    This is the default constructor for the oaModTerm_Array class. This constructor creates an empty oaModTerm_Array.\n"
"  Paramegers: (oaModTerm_Array)\n"
"    Calls: (const oaModTerm_Array&)\n"
"    Signature: oaModTerm_Array||cref-oaModTerm_Array,\n"
;

// ------------------------------------------------------------------
static PySequenceMethods oaModTerm_Array_as_sequence = {
    (Pyoa_inquiry)oaModTerm_Array_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,              /* sq_concat */
    (Pyoa_intargfunc)0,              /* sq_repeat */
    (Pyoa_intargfunc)oaModTerm_Array_index_get, /* sq_item */
    (Pyoa_intintargfunc)0,           /* sq_slice */
    (Pyoa_intobjargproc)oaModTerm_Array_index_set,      /* sq_ass_item */
};

// ------------------------------------------------------------------
PyTypeObject PyoaModTerm_Array_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModTerm_Array",
    sizeof(PyoaModTerm_ArrayObject),
    0,
    oaModTerm_Array_dealloc, /* tp_dealloc */
    0,  /* tp_print */
    0,                                  /* tp_getattr */
    0,                                  /* tp_setattr */
    oaModTerm_Array_compare,    /* tp_compare */
    oaModTerm_Array_repr,      /* tp_repr */
    0,                                  /* tp_as_number */
    &oaModTerm_Array_as_sequence,  /* tp_as_sequence */
    0,                                  /* tp_as_mapping */
    0,                                  /* tp_as_hash */
    0,                                  /* tp_as_call */
    oaModTerm_Array_str,               /* tp_str */
    0,                                  /* tp_getattro */
    0,                                  /* tp_setattro */
    0,                                  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModTerm_Array_doc, /* tp_doc */
    0,                                  /* tp_traverse */
    0,                                  /* tp_clear */
    0,                                  /* tp_richcompre */
    0,                                  /* tp_weaklistoffset */
    0,                                  /* tp_iter */
    0,                                  /* tp_iternext */
    oaModTerm_Array_methodlist, /* tp_methods */
    0,                                  /* tp_members */
    0,                                  /* tp_getset */
    0,                                  /* tp_base */
    0,                                  /* tp_dict */
    0,                                  /* tp_descr_get */
    0,                                  /* tp_descr_set */
    0,                                  /* tp_dictoffset */
    0,                                  /* tp_init */
    PyType_GenericAlloc,        /* tp_alloc */
    oaModTerm_Array_new, /* tp_new */
    _PyObject_Del,      /* tp_free */
};


// ------------------------------------------------------------------
int
PyoaModTerm_Array_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModTerm_Array_Type)<0) {
      printf("** PyType_Ready failed for: oaModTerm_Array\n");
      return -1;
    }
    if (PyDict_SetItemString(mod_dict,"oaModTerm_Array",
           (PyObject*)(&PyoaModTerm_Array_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModTerm_Array\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModTermArray
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModTermArray_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModTermArray_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModTermArrayObject* self = (PyoaModTermArrayObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaArrayBase_oaModTerm*)  new oaModTermArray();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value = (oaArrayBase_oaModTerm*)  new oaModTermArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaModTermArray)
    {
        PyParamoaModTermArray p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModTermArray_Convert,&p1)) {
            self->value=(oaArrayBase_oaModTerm*)  new oaModTermArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModTermArray, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaModTermArray)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModTermArray_tp_dealloc(PyoaModTermArrayObject* self)
{
    if (!self->borrow) {
        delete (oaModTermArray*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModTermArray_tp_repr(PyObject *ob)
{
    PyParamoaModTermArray value;
    int convert_status=PyoaModTermArray_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[36];
    sprintf(buffer,"<oaModTermArray::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModTermArray_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModTermArray v1;
    PyParamoaModTermArray v2;
    int convert_status1=PyoaModTermArray_Convert(ob1,&v1);
    int convert_status2=PyoaModTermArray_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModTermArray_Convert(PyObject* ob,PyParamoaModTermArray* result)
{
    if (ob == NULL) return 1;
    if (PyoaModTermArray_Check(ob)) {
        result->SetData( (oaModTermArray*) ((PyoaModTermArrayObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModTermArray Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModTermArray_FromoaModTermArray(oaModTermArray* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaModTermArray_Type.tp_alloc(&PyoaModTermArray_Type,0);
        if (bself == NULL) return bself;
        PyoaModTermArrayObject* self = (PyoaModTermArrayObject*)bself;
        self->value = (oaArrayBase_oaModTerm*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModTermArray_doc[] = 
"Class: oaModTermArray\n"
"  The oaModTermArray is a utility class that implements an array of module terminal pointers.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaModTermArray()\n"
"    Signature: oaModTermArray||simple-oaUInt4,\n"
"    This is the constructor for the oaModTermArray class. It constructs an array of oaModTerm pointers of the specified size.\n"
"    sizeIn\n"
"    The initial size for this array\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaModTermArray(oaUInt4 sizeIn)\n"
"    Signature: oaModTermArray||simple-oaUInt4,\n"
"    This is the constructor for the oaModTermArray class. It constructs an array of oaModTerm pointers of the specified size.\n"
"    sizeIn\n"
"    The initial size for this array\n"
"  Paramegers: (oaModTermArray)\n"
"    Calls: (const oaModTermArray&)\n"
"    Signature: oaModTermArray||cref-oaModTermArray,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModTermArray_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModTermArray",
    sizeof(PyoaModTermArrayObject),
    0,
    (destructor)oaModTermArray_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModTermArray_tp_compare,	/* tp_compare */
    (reprfunc)oaModTermArray_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModTermArray_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaArray_oaModTerm_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModTermArray_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModTermArray_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModTermArray_Type)<0) {
      printf("** PyType_Ready failed for: oaModTermArray\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModTermArray",
           (PyObject*)(&PyoaModTermArray_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModTermArray\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModTermConnectDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModTermConnectDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModTermConnectDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModTermConnectDefObject* self = (PyoaModTermConnectDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModTermConnectDef)
    {
        PyParamoaModTermConnectDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModTermConnectDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModTermConnectDef, Choices are:\n"
        "    (oaModTermConnectDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModTermConnectDef_tp_dealloc(PyoaModTermConnectDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModTermConnectDef_tp_repr(PyObject *ob)
{
    PyParamoaModTermConnectDef value;
    int convert_status=PyoaModTermConnectDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[41];
    sprintf(buffer,"<oaModTermConnectDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModTermConnectDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModTermConnectDef v1;
    PyParamoaModTermConnectDef v2;
    int convert_status1=PyoaModTermConnectDef_Convert(ob1,&v1);
    int convert_status2=PyoaModTermConnectDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModTermConnectDef_Convert(PyObject* ob,PyParamoaModTermConnectDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaModTermConnectDef_Check(ob)) {
        result->SetData( (oaModTermConnectDef**) ((PyoaModTermConnectDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModTermConnectDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModTermConnectDef_FromoaModTermConnectDef(oaModTermConnectDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaModTermConnectDef* data=*value;
        PyObject* bself = PyoaModTermConnectDef_Type.tp_alloc(&PyoaModTermConnectDef_Type,0);
        if (bself == NULL) return bself;
        PyoaModTermConnectDefObject* self = (PyoaModTermConnectDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaModTermConnectDef_FromoaModTermConnectDef(oaModTermConnectDef* data)
{
    if (data) {
       PyObject* bself = PyoaModTermConnectDef_Type.tp_alloc(&PyoaModTermConnectDef_Type,0);
       if (bself == NULL) return bself;
       PyoaModTermConnectDefObject* self = (PyoaModTermConnectDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModTermConnectDef_getTerm_doc[] = 
"Class: oaModTermConnectDef, Function: getTerm\n"
"  Paramegers: ()\n"
"    Calls: oaModBitTerm* getTerm() const\n"
"    Signature: getTerm|ptr-oaModBitTerm|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the modBitTerm associated with this connection definition.\n"
;

static PyObject*
oaModTermConnectDef_getTerm(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModTermConnectDef data;
    int convert_status=PyoaModTermConnectDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModTermConnectDefObject* self=(PyoaModTermConnectDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModBitTermp result= (data.DataCall()->getTerm());
        return PyoaModBitTerm_FromoaModBitTerm(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModTermConnectDef_isNull_doc[] =
"Class: oaModTermConnectDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaModTermConnectDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaModTermConnectDef data;
    int convert_status=PyoaModTermConnectDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaModTermConnectDef_assign_doc[] = 
"Class: oaModTermConnectDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModTermConnectDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModTermConnectDef data;
  int convert_status=PyoaModTermConnectDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModTermConnectDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModTermConnectDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModTermConnectDef_methodlist[] = {
    {"getTerm",(PyCFunction)oaModTermConnectDef_getTerm,METH_VARARGS,oaModTermConnectDef_getTerm_doc},
    {"isNull",(PyCFunction)oaModTermConnectDef_tp_isNull,METH_VARARGS,oaModTermConnectDef_isNull_doc},
    {"assign",(PyCFunction)oaModTermConnectDef_tp_assign,METH_VARARGS,oaModTermConnectDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModTermConnectDef_doc[] = 
"Class: oaModTermConnectDef\n"
"  The oaModTermConnectDef class implements a connection definition that associates an oaAssignmentDef with a single-bit terminal. The oaAssignmentDef used to create the oaModTermConnectDef specifies the name of an oaModAssignment and a default net name.\n"
"  Applications that analyze design connectivity must resolve the name of the net to externally connect to the terminal associated with the oaModTermConnectDef. The application searches up the design hierarchy for an oaModAssignment that matches the assignment name specified in the oaModTermConnectDef. If the assignment is found, the application uses the net name it specifies as the name of the net to externally connect to the terminal that is associated with the oaModTermConnectDef. If an assignment is not found, the application uses the default net name specified in the oaModTermConnectDef.\n"
"  An oaModTermConnectDef is often used\n"
"  as part of parameterized power and ground symbols\n"
"  to specify substrate connections\n"
"  For example, you want to use a 4 terminal transistor device but aren't sure what the bulk node connection will connect to yet. You can create an oaModTermConnectDef on the bulk terminal that specifies the name of an assignment called \"bulk_override\" and has a default name name \"gnd\".\n"
"  Once you've determined what you want the bulk nodes connected to, you can create a matching oaModAssignValue on an instance representing that part of the design where you want to make the assignment. You would name the oaModAssignValue \"bulk_override\" and its value would be the name of the net you want to connect the bulk nodes to. If you didn't create an oaModAssignment named \"bulk_override\", the default net name \"gnd\" would be used.\n"
"  Note: Not all applications support resolving connectivity specified with connection definitions and assignments. You should verify that downstream consumers of the data are able to resolve such connectivity.\n"
"Constructors:\n"
"  Paramegers: (oaModTermConnectDef)\n"
"    Calls: (const oaModTermConnectDef&)\n"
"    Signature: oaModTermConnectDef||cref-oaModTermConnectDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModTermConnectDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModTermConnectDef",
    sizeof(PyoaModTermConnectDefObject),
    0,
    (destructor)oaModTermConnectDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModTermConnectDef_tp_compare,	/* tp_compare */
    (reprfunc)oaModTermConnectDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModTermConnectDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaModTermConnectDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaModConnectDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModTermConnectDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModTermConnectDef_static_create_doc[] = 
"Class: oaModTermConnectDef, Function: create\n"
"  Paramegers: (oaModBitTerm,oaAssignmentDef)\n"
"    Calls: oaModTermConnectDef* create(const oaModBitTerm* term,const oaAssignmentDef& assignmentDef)\n"
"    Signature: create|ptr-oaModTermConnectDef|cptr-oaModBitTerm,cref-oaAssignmentDef,\n"
"    This function creates a connection definition on the specified term using the information in the given assignmentDef .\n"
"    term\n"
"    The single-bit terminal for which to define the connection\n"
"    assignmentDef\n"
"    The assignment definition that specifies the name of an oaModAssignment to search for in order to resolve the connectivity and a default net name to use if a matching assignment is not found\n"
"    A pointer to an oaModTermConnectDef\n"
"    oacTermAlreadyHasConnectDef\n"
;

static PyObject*
oaModTermConnectDef_static_create(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModBitTerm p1;
    PyParamoaAssignmentDef p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaModBitTerm_Convert,&p1,
          &PyoaAssignmentDef_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaModTermConnectDefp result= (oaModTermConnectDef::create(p1.Data(),p2.Data()));
        return PyoaModTermConnectDef_FromoaModTermConnectDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaModTermConnectDef_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaModTermConnectDef_static_create,METH_VARARGS,oaModTermConnectDef_static_create_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModTermConnectDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModTermConnectDef_Type)<0) {
      printf("** PyType_Ready failed for: oaModTermConnectDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModTermConnectDef",
           (PyObject*)(&PyoaModTermConnectDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModTermConnectDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaModTermConnectDef_Type.tp_dict;
    for(method=oaModTermConnectDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModVectorInst
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModVectorInst_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModVectorInst_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModVectorInstObject* self = (PyoaModVectorInstObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModVectorInst)
    {
        PyParamoaModVectorInst p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModVectorInst_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModVectorInst, Choices are:\n"
        "    (oaModVectorInst)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModVectorInst_tp_dealloc(PyoaModVectorInstObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModVectorInst_tp_repr(PyObject *ob)
{
    PyParamoaModVectorInst value;
    int convert_status=PyoaModVectorInst_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaModVectorInst::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaSimpleName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[37];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaModVectorInst::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModVectorInst_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModVectorInst v1;
    PyParamoaModVectorInst v2;
    int convert_status1=PyoaModVectorInst_Convert(ob1,&v1);
    int convert_status2=PyoaModVectorInst_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModVectorInst_Convert(PyObject* ob,PyParamoaModVectorInst* result)
{
    if (ob == NULL) return 1;
    if (PyoaModVectorInst_Check(ob)) {
        result->SetData( (oaModVectorInst**) ((PyoaModVectorInstObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModVectorInst Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModVectorInst_FromoaModVectorInst(oaModVectorInst** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaModVectorInst* data=*value;
        PyObject* bself = PyoaModVectorInst_Type.tp_alloc(&PyoaModVectorInst_Type,0);
        if (bself == NULL) return bself;
        PyoaModVectorInstObject* self = (PyoaModVectorInstObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaModVectorInst_FromoaModVectorInst(oaModVectorInst* data)
{
    if (data) {
       PyObject* bself = PyoaModVectorInst_Type.tp_alloc(&PyoaModVectorInst_Type,0);
       if (bself == NULL) return bself;
       PyoaModVectorInstObject* self = (PyoaModVectorInstObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModVectorInst_getBit_doc[] = 
"Class: oaModVectorInst, Function: getBit\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaModVectorInstBit* getBit(oaUInt4 bitIndex) const\n"
"    Signature: getBit|ptr-oaModVectorInstBit|simple-oaUInt4,\n"
"    This function returns a pointer to the vectorInstBit that corresponds to the specified bitIndex bit of this vectorInst. For example, if this is a vectorInst \"i[7:0]\" and bitIndex is zero, this function will return the vectorInstBit corresponding to \"i[7]\".\n"
"    bitIndex\n"
"    Specifies which bit of the instance to return\n"
"    A pointer to an oaModVectorInstBit\n"
"    oacInvalidBitIndexIntoInst\n"
;

static PyObject*
oaModVectorInst_getBit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModVectorInst data;
    int convert_status=PyoaModVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModVectorInstObject* self=(PyoaModVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaModVectorInstBitp result= (data.DataCall()->getBit(p1.Data()));
        return PyoaModVectorInstBit_FromoaModVectorInstBit(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInst_getDef_doc[] = 
"Class: oaModVectorInst, Function: getDef\n"
"  Paramegers: ()\n"
"    Calls: oaModVectorInstDef* getDef() const\n"
"    Signature: getDef|ptr-oaModVectorInstDef|\n"
"    BrowseData: 1\n"
"    This function returns the module vectorInstDef for this module vectorInst. The module vectorInstDef is used to access all module vectorInsts with the same baseName but different index ranges.\n"
;

static PyObject*
oaModVectorInst_getDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModVectorInst data;
    int convert_status=PyoaModVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModVectorInstObject* self=(PyoaModVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModVectorInstDefp result= (data.DataCall()->getDef());
        return PyoaModVectorInstDef_FromoaModVectorInstDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInst_getName_doc[] = 
"Class: oaModVectorInst, Function: getName\n"
"  Paramegers: (oaVectorName)\n"
"    Calls: void getName(oaVectorName& name) const\n"
"    Signature: getName|void-void|ref-oaVectorName,\n"
"    BrowseData: 0,oaVectorName\n"
"    This function returns the vectorName of this modVectorInst.\n"
"    name\n"
"    The name of the modVectorInst to return\n"
"  Paramegers: (oaSimpleName)\n"
"    Calls: void getName(oaSimpleName& name) const\n"
"    Signature: getName|void-void|ref-oaSimpleName,\n"
"    BrowseData: 0,oaSimpleName\n"
"    This function fills out name with the name of this instance.\n"
"    name\n"
"    The returned instance name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function fills out name with the name of this instance. The name is mapped according to the specified nameSpace.\n"
"    ns\n"
"    The nameSpace used to map the name\n"
"    name\n"
"    The returned instance name\n"
;

static PyObject*
oaModVectorInst_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModVectorInst data;
    int convert_status=PyoaModVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModVectorInstObject* self=(PyoaModVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaVectorName)
    {
        PyParamoaVectorName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName)
    {
        PyParamoaSimpleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSimpleName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModVectorInst, function: getName, Choices are:\n"
        "    (oaVectorName)\n"
        "    (oaSimpleName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInst_getStart_doc[] = 
"Class: oaModVectorInst, Function: getStart\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getStart() const\n"
"    Signature: getStart|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the start index of this module vectorInst.\n"
;

static PyObject*
oaModVectorInst_getStart(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModVectorInst data;
    int convert_status=PyoaModVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModVectorInstObject* self=(PyoaModVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getStart());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInst_getStop_doc[] = 
"Class: oaModVectorInst, Function: getStop\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getStop() const\n"
"    Signature: getStop|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the stop index of this module vectorInst.\n"
;

static PyObject*
oaModVectorInst_getStop(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModVectorInst data;
    int convert_status=PyoaModVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModVectorInstObject* self=(PyoaModVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getStop());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInst_setBaseName_doc[] = 
"Class: oaModVectorInst, Function: setBaseName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void setBaseName(const oaScalarName& baseName)\n"
"    Signature: setBaseName|void-void|cref-oaScalarName,\n"
"    This function changes the base name of this vectorInst. Exceptions are thrown if the new name is the name of an existing scalar, an arrayInst, or if another vectorInst exists whose indices overlap with this vectorInst, or if the given baseName matches the form of the system-generated scalarInst name.\n"
"    oacCannotSetNameOfImplicitInst\n"
;

static PyObject*
oaModVectorInst_setBaseName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModVectorInst data;
    int convert_status=PyoaModVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModVectorInstObject* self=(PyoaModVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScalarName p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaScalarName_Convert,&p1)) {
        data.DataCall()->setBaseName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInst_setRange_doc[] = 
"Class: oaModVectorInst, Function: setRange\n"
"  Paramegers: (oaUInt4,oaUInt4)\n"
"    Calls: void setRange(oaUInt4 start,oaUInt4 stop)\n"
"    Signature: setRange|void-void|simple-oaUInt4,simple-oaUInt4,\n"
"    This function sets the start and stop bit indices of this vectorInst.\n"
"    start\n"
"    The new start value to give this instance\n"
"    stop\n"
"    The new stop value to give this instance\n"
"    oacInstNameOverlapsOtherInst\n"
"    oacCannotSetNameOfImplicitInst\n"
"    oacInvalidBusStartStopRange\n"
;

static PyObject*
oaModVectorInst_setRange(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModVectorInst data;
    int convert_status=PyoaModVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModVectorInstObject* self=(PyoaModVectorInstObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    PyParamoaUInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaUInt4_Convert,&p1,
          &PyoaUInt4_Convert,&p2)) {
        data.DataCall()->setRange(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInst_isNull_doc[] =
"Class: oaModVectorInst, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaModVectorInst_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaModVectorInst data;
    int convert_status=PyoaModVectorInst_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaModVectorInst_assign_doc[] = 
"Class: oaModVectorInst, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModVectorInst_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModVectorInst data;
  int convert_status=PyoaModVectorInst_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModVectorInst p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModVectorInst_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModVectorInst_methodlist[] = {
    {"getBit",(PyCFunction)oaModVectorInst_getBit,METH_VARARGS,oaModVectorInst_getBit_doc},
    {"getDef",(PyCFunction)oaModVectorInst_getDef,METH_VARARGS,oaModVectorInst_getDef_doc},
    {"getName",(PyCFunction)oaModVectorInst_getName,METH_VARARGS,oaModVectorInst_getName_doc},
    {"getStart",(PyCFunction)oaModVectorInst_getStart,METH_VARARGS,oaModVectorInst_getStart_doc},
    {"getStop",(PyCFunction)oaModVectorInst_getStop,METH_VARARGS,oaModVectorInst_getStop_doc},
    {"setBaseName",(PyCFunction)oaModVectorInst_setBaseName,METH_VARARGS,oaModVectorInst_setBaseName_doc},
    {"setRange",(PyCFunction)oaModVectorInst_setRange,METH_VARARGS,oaModVectorInst_setRange_doc},
    {"isNull",(PyCFunction)oaModVectorInst_tp_isNull,METH_VARARGS,oaModVectorInst_isNull_doc},
    {"assign",(PyCFunction)oaModVectorInst_tp_assign,METH_VARARGS,oaModVectorInst_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModVectorInst_doc[] = 
"Class: oaModVectorInst\n"
"  The oaModVectorInst class implements a vector instance of a design master in the module domain. A vector instance represents several copies of the instance master with a range of index numbers to differentiate them.\n"
"  An oaModVectorInst object is always in the module domain. It is an instance of a design as opposed to an oaModModuleVectorInst , which is a vector instance of a local module.\n"
"Constructors:\n"
"  Paramegers: (oaModVectorInst)\n"
"    Calls: (const oaModVectorInst&)\n"
"    Signature: oaModVectorInst||cref-oaModVectorInst,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModVectorInst_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModVectorInst",
    sizeof(PyoaModVectorInstObject),
    0,
    (destructor)oaModVectorInst_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModVectorInst_tp_compare,	/* tp_compare */
    (reprfunc)oaModVectorInst_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModVectorInst_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaModVectorInst_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaModDesignInst_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModVectorInst_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModVectorInst_static_create_doc[] = 
"Class: oaModVectorInst, Function: create\n"
"  Paramegers: (oaModule,oaDesign,oaScalarName,oaUInt4,oaUInt4)\n"
"    Calls: oaModVectorInst* create(oaModule* module,oaDesign* master,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop)\n"
"    Signature: create|ptr-oaModVectorInst|ptr-oaModule,ptr-oaDesign,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,cptr-oaParamArray,\n"
"    This function creates a new vector instance of the master design inside of the specified parent module. This form uses a pointer to the master design\n"
"    The specified baseName and start/stop indices are first checked to verify that they are legal and don't specify an instance that already exists.\n"
"    The optional params argument is used if the master design is a pcell.\n"
"    module\n"
"    The module in which to create the instance\n"
"    master\n"
"    The master design\n"
"    baseName\n"
"    The base name of the instance\n"
"    start\n"
"    The start index\n"
"    stop\n"
"    The stop index\n"
"    params\n"
"    Optional parameter array for pCell instances\n"
"    oacInvalidSuperMaster\n"
"  Paramegers: (oaModule,oaDesign,oaScalarName,oaUInt4,oaUInt4,oaParamArray)\n"
"    Calls: oaModVectorInst* create(oaModule* module,oaDesign* master,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop,const oaParamArray* params)\n"
"    Signature: create|ptr-oaModVectorInst|ptr-oaModule,ptr-oaDesign,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,cptr-oaParamArray,\n"
"    This function creates a new vector instance of the master design inside of the specified parent module. This form uses a pointer to the master design\n"
"    The specified baseName and start/stop indices are first checked to verify that they are legal and don't specify an instance that already exists.\n"
"    The optional params argument is used if the master design is a pcell.\n"
"    module\n"
"    The module in which to create the instance\n"
"    master\n"
"    The master design\n"
"    baseName\n"
"    The base name of the instance\n"
"    start\n"
"    The start index\n"
"    stop\n"
"    The stop index\n"
"    params\n"
"    Optional parameter array for pCell instances\n"
"    oacInvalidSuperMaster\n"
"  Paramegers: (oaModule,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaUInt4)\n"
"    Calls: oaModVectorInst* create(oaModule* module,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop)\n"
"    Signature: create|ptr-oaModVectorInst|ptr-oaModule,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,cptr-oaParamArray,\n"
"    This function creates a new vector instance of the master design inside of the specified parent module. This form of the create function identifies the master by name. The master does not have to be open and it does not have to exist yet when this form is used.\n"
"    The specified baseName and start/stop indices are first checked to verify that they are legal and don't specify an instance that already exists.\n"
"    The optional params argument is used if the master design is a pcell.\n"
"    module\n"
"    The module in which to create the instance\n"
"    libName\n"
"    The libary name of the master design\n"
"    cellName\n"
"    The cell name of the master design\n"
"    viewName\n"
"    The view name of the master design\n"
"    baseName\n"
"    The base name of the instance\n"
"    start\n"
"    The start index\n"
"    stop\n"
"    The stop index\n"
"    params\n"
"    Optional parameter array for pCell instances\n"
"    oacInvalidSuperMaster\n"
"  Paramegers: (oaModule,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaUInt4,oaParamArray)\n"
"    Calls: oaModVectorInst* create(oaModule* module,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop,const oaParamArray* params)\n"
"    Signature: create|ptr-oaModVectorInst|ptr-oaModule,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,cptr-oaParamArray,\n"
"    This function creates a new vector instance of the master design inside of the specified parent module. This form of the create function identifies the master by name. The master does not have to be open and it does not have to exist yet when this form is used.\n"
"    The specified baseName and start/stop indices are first checked to verify that they are legal and don't specify an instance that already exists.\n"
"    The optional params argument is used if the master design is a pcell.\n"
"    module\n"
"    The module in which to create the instance\n"
"    libName\n"
"    The libary name of the master design\n"
"    cellName\n"
"    The cell name of the master design\n"
"    viewName\n"
"    The view name of the master design\n"
"    baseName\n"
"    The base name of the instance\n"
"    start\n"
"    The start index\n"
"    stop\n"
"    The stop index\n"
"    params\n"
"    Optional parameter array for pCell instances\n"
"    oacInvalidSuperMaster\n"
;

static PyObject*
oaModVectorInst_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaModule,oaDesign,oaScalarName,oaUInt4,oaUInt4)
    {
        PyParamoaModule p1;
        PyParamoaDesign p2;
        PyParamoaScalarName p3;
        PyParamoaUInt4 p4;
        PyParamoaUInt4 p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaDesign_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaUInt4_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaModVectorInstp result= (oaModVectorInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
            return PyoaModVectorInst_FromoaModVectorInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaDesign,oaScalarName,oaUInt4,oaUInt4,oaParamArray)
    {
        PyParamoaModule p1;
        PyParamoaDesign p2;
        PyParamoaScalarName p3;
        PyParamoaUInt4 p4;
        PyParamoaUInt4 p5;
        PyParamoaParamArray p6;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaDesign_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaUInt4_Convert,&p5,
              &PyoaParamArray_ConvertAof,&p6)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaModVectorInstp result= (oaModVectorInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.DataAof()));
            return PyoaModVectorInst_FromoaModVectorInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaUInt4)
    {
        PyParamoaModule p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        PyParamoaScalarName p5;
        PyParamoaUInt4 p6;
        PyParamoaUInt4 p7;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4,
              &PyoaScalarName_Convert,&p5,
              &PyoaUInt4_Convert,&p6,
              &PyoaUInt4_Convert,&p7)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModVectorInstp result= (oaModVectorInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data()));
            return PyoaModVectorInst_FromoaModVectorInst(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaUInt4,oaParamArray)
    {
        PyParamoaModule p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        PyParamoaScalarName p5;
        PyParamoaUInt4 p6;
        PyParamoaUInt4 p7;
        PyParamoaParamArray p8;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4,
              &PyoaScalarName_Convert,&p5,
              &PyoaUInt4_Convert,&p6,
              &PyoaUInt4_Convert,&p7,
              &PyoaParamArray_ConvertAof,&p8)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModVectorInstp result= (oaModVectorInst::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.Data(),p8.DataAof()));
            return PyoaModVectorInst_FromoaModVectorInst(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModVectorInst, function: create, Choices are:\n"
        "    (oaModule,oaDesign,oaScalarName,oaUInt4,oaUInt4)\n"
        "    (oaModule,oaDesign,oaScalarName,oaUInt4,oaUInt4,oaParamArray)\n"
        "    (oaModule,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaUInt4)\n"
        "    (oaModule,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaUInt4,oaParamArray)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInst_static_find_doc[] = 
"Class: oaModVectorInst, Function: find\n"
"  Paramegers: (oaModule,oaScalarName,oaUInt4,oaUInt4)\n"
"    Calls: oaModVectorInst* find(const oaModule* module,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop)\n"
"    Signature: find|ptr-oaModVectorInst|cptr-oaModule,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,\n"
"    This function searches the specified module for a module vectorInst with the specified name and start or stop bits. The function returns the instance if it finds one. Otherwise, NULL is returned.\n"
;

static PyObject*
oaModVectorInst_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule p1;
    PyParamoaScalarName p2;
    PyParamoaUInt4 p3;
    PyParamoaUInt4 p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaModule_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaUInt4_Convert,&p3,
          &PyoaUInt4_Convert,&p4)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaModVectorInstp result= (oaModVectorInst::find(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
        return PyoaModVectorInst_FromoaModVectorInst(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInst_static_isValidName_doc[] = 
"Class: oaModVectorInst, Function: isValidName\n"
"  Paramegers: (oaModule,oaScalarName,oaUInt4,oaUInt4)\n"
"    Calls: oaBoolean isValidName(const oaModule* module,const oaScalarName& baseName,oaUInt4 start,oaUInt4 stop)\n"
"    Signature: isValidName|simple-oaBoolean|cptr-oaModule,cref-oaScalarName,simple-oaUInt4,simple-oaUInt4,\n"
"    This function returns a boolean value that indicates if the specified baseName , combined with the start and stop values, is a valid new oaModVectorInst in the specified module .\n"
;

static PyObject*
oaModVectorInst_static_isValidName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule p1;
    PyParamoaScalarName p2;
    PyParamoaUInt4 p3;
    PyParamoaUInt4 p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaModule_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaUInt4_Convert,&p3,
          &PyoaUInt4_Convert,&p4)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (oaModVectorInst::isValidName(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaModVectorInst_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaModVectorInst_static_create,METH_VARARGS,oaModVectorInst_static_create_doc},
    {"static_find",(PyCFunction)oaModVectorInst_static_find,METH_VARARGS,oaModVectorInst_static_find_doc},
    {"static_isValidName",(PyCFunction)oaModVectorInst_static_isValidName,METH_VARARGS,oaModVectorInst_static_isValidName_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModVectorInst_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModVectorInst_Type)<0) {
      printf("** PyType_Ready failed for: oaModVectorInst\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModVectorInst",
           (PyObject*)(&PyoaModVectorInst_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModVectorInst\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaModVectorInst_Type.tp_dict;
    for(method=oaModVectorInst_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModVectorInstBit
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModVectorInstBit_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModVectorInstBit_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModVectorInstBitObject* self = (PyoaModVectorInstBitObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModVectorInstBit)
    {
        PyParamoaModVectorInstBit p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModVectorInstBit_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModVectorInstBit, Choices are:\n"
        "    (oaModVectorInstBit)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModVectorInstBit_tp_dealloc(PyoaModVectorInstBitObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModVectorInstBit_tp_repr(PyObject *ob)
{
    PyParamoaModVectorInstBit value;
    int convert_status=PyoaModVectorInstBit_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaModVectorInstBit::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaSimpleName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[40];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaModVectorInstBit::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModVectorInstBit_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModVectorInstBit v1;
    PyParamoaModVectorInstBit v2;
    int convert_status1=PyoaModVectorInstBit_Convert(ob1,&v1);
    int convert_status2=PyoaModVectorInstBit_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModVectorInstBit_Convert(PyObject* ob,PyParamoaModVectorInstBit* result)
{
    if (ob == NULL) return 1;
    if (PyoaModVectorInstBit_Check(ob)) {
        result->SetData( (oaModVectorInstBit**) ((PyoaModVectorInstBitObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModVectorInstBit Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModVectorInstBit_FromoaModVectorInstBit(oaModVectorInstBit** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaModVectorInstBit* data=*value;
        PyObject* bself = PyoaModVectorInstBit_Type.tp_alloc(&PyoaModVectorInstBit_Type,0);
        if (bself == NULL) return bself;
        PyoaModVectorInstBitObject* self = (PyoaModVectorInstBitObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaModVectorInstBit_FromoaModVectorInstBit(oaModVectorInstBit* data)
{
    if (data) {
       PyObject* bself = PyoaModVectorInstBit_Type.tp_alloc(&PyoaModVectorInstBit_Type,0);
       if (bself == NULL) return bself;
       PyoaModVectorInstBitObject* self = (PyoaModVectorInstBitObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModVectorInstBit_getBitIndex_doc[] = 
"Class: oaModVectorInstBit, Function: getBitIndex\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getBitIndex() const\n"
"    Signature: getBitIndex|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the bitIndex of this vectorInstBit.\n"
;

static PyObject*
oaModVectorInstBit_getBitIndex(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModVectorInstBit data;
    int convert_status=PyoaModVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModVectorInstBitObject* self=(PyoaModVectorInstBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getBitIndex());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInstBit_getDef_doc[] = 
"Class: oaModVectorInstBit, Function: getDef\n"
"  Paramegers: ()\n"
"    Calls: oaModVectorInstDef* getDef() const\n"
"    Signature: getDef|ptr-oaModVectorInstDef|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the vectorInstDef for this vectorInstBit.\n"
;

static PyObject*
oaModVectorInstBit_getDef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModVectorInstBit data;
    int convert_status=PyoaModVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModVectorInstBitObject* self=(PyoaModVectorInstBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaModVectorInstDefp result= (data.DataCall()->getDef());
        return PyoaModVectorInstDef_FromoaModVectorInstDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInstBit_getName_doc[] = 
"Class: oaModVectorInstBit, Function: getName\n"
"  Paramegers: (oaVectorBitName)\n"
"    Calls: void getName(oaVectorBitName& name) const\n"
"    Signature: getName|void-void|ref-oaVectorBitName,\n"
"    BrowseData: 0,oaVectorBitName\n"
"    This function returns the vectorName of this modVectorInstBit.\n"
"    name\n"
"    The name of the modVectorInstBit to return\n"
"  Paramegers: (oaSimpleName)\n"
"    Calls: void getName(oaSimpleName& name) const\n"
"    Signature: getName|void-void|ref-oaSimpleName,\n"
"    BrowseData: 0,oaSimpleName\n"
"    This function fills out name with the name of this instance.\n"
"    name\n"
"    The returned instance name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function fills out name with the name of this instance. The name is mapped according to the specified nameSpace.\n"
"    ns\n"
"    The nameSpace used to map the name\n"
"    name\n"
"    The returned instance name\n"
;

static PyObject*
oaModVectorInstBit_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModVectorInstBit data;
    int convert_status=PyoaModVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModVectorInstBitObject* self=(PyoaModVectorInstBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaVectorBitName)
    {
        PyParamoaVectorBitName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorBitName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName)
    {
        PyParamoaSimpleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSimpleName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModVectorInstBit, function: getName, Choices are:\n"
        "    (oaVectorBitName)\n"
        "    (oaSimpleName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInstBit_setName_doc[] = 
"Class: oaModVectorInstBit, Function: setName\n"
"  Paramegers: (oaScalarName,oaUInt4)\n"
"    Calls: void setName(const oaScalarName& baseName,oaUInt4 bitIndex)\n"
"    Signature: setName|void-void|cref-oaScalarName,simple-oaUInt4,\n"
"    This function changes the name of this vectorInstBit. An exception is thrown if the new baseName is the name of an existing scalar or array instance or if a vectorInstBit already exists with the new name. An exception is also thrown if the new name would overlap with existing vectorInsts.\n"
"    baseName\n"
"    The new base name for this instance\n"
"    bitIndex\n"
"    The new bit index for this instance\n"
"    oacCannotSetNameOfImplicitInst\n"
;

static PyObject*
oaModVectorInstBit_setName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModVectorInstBit data;
    int convert_status=PyoaModVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModVectorInstBitObject* self=(PyoaModVectorInstBitObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScalarName p1;
    PyParamoaUInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaScalarName_Convert,&p1,
          &PyoaUInt4_Convert,&p2)) {
        data.DataCall()->setName(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInstBit_isNull_doc[] =
"Class: oaModVectorInstBit, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaModVectorInstBit_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaModVectorInstBit data;
    int convert_status=PyoaModVectorInstBit_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaModVectorInstBit_assign_doc[] = 
"Class: oaModVectorInstBit, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModVectorInstBit_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModVectorInstBit data;
  int convert_status=PyoaModVectorInstBit_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModVectorInstBit p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModVectorInstBit_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModVectorInstBit_methodlist[] = {
    {"getBitIndex",(PyCFunction)oaModVectorInstBit_getBitIndex,METH_VARARGS,oaModVectorInstBit_getBitIndex_doc},
    {"getDef",(PyCFunction)oaModVectorInstBit_getDef,METH_VARARGS,oaModVectorInstBit_getDef_doc},
    {"getName",(PyCFunction)oaModVectorInstBit_getName,METH_VARARGS,oaModVectorInstBit_getName_doc},
    {"setName",(PyCFunction)oaModVectorInstBit_setName,METH_VARARGS,oaModVectorInstBit_setName_doc},
    {"isNull",(PyCFunction)oaModVectorInstBit_tp_isNull,METH_VARARGS,oaModVectorInstBit_isNull_doc},
    {"assign",(PyCFunction)oaModVectorInstBit_tp_assign,METH_VARARGS,oaModVectorInstBit_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModVectorInstBit_doc[] = 
"Class: oaModVectorInstBit\n"
"  The oaModVectorInstBit class implements a single bit of a vectorInst in a module. VectorInstBits are automatically created and destroyed as vectorInsts are created or destroyed. Implicitly-created vectorInstBits cannot be modified to insure consistency with its defining vectorInst. Explicitly-created vectorInstBits define a unique bit of a vectorInst definition since the bits of a vectorInst are not allowed to overlap with other vectorInsts.\n"
"  oaVectorInstBit objects are always in the block domain. They may be physical-only instances that are only in the block hierarchy, or they can be cross-domain instances that directly correspond to an oaModVectorInstBit in the module domain and an oaOccVectorInstBit in the occurrence domain.\n"
"Constructors:\n"
"  Paramegers: (oaModVectorInstBit)\n"
"    Calls: (const oaModVectorInstBit&)\n"
"    Signature: oaModVectorInstBit||cref-oaModVectorInstBit,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModVectorInstBit_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModVectorInstBit",
    sizeof(PyoaModVectorInstBitObject),
    0,
    (destructor)oaModVectorInstBit_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModVectorInstBit_tp_compare,	/* tp_compare */
    (reprfunc)oaModVectorInstBit_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModVectorInstBit_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaModVectorInstBit_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaModBitInst_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModVectorInstBit_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModVectorInstBit_static_create_doc[] = 
"Class: oaModVectorInstBit, Function: create\n"
"  Paramegers: (oaModule,oaDesign,oaScalarName,oaUInt4)\n"
"    Calls: oaModVectorInstBit* create(oaModule* module,oaDesign* master,const oaScalarName& baseName,oaUInt4 bitIndex)\n"
"    Signature: create|ptr-oaModVectorInstBit|ptr-oaModule,ptr-oaDesign,cref-oaScalarName,simple-oaUInt4,cptr-oaParamArray,\n"
"    This function creates an oaModVectorInstBit object with the specified attributes. The given baseName and bitIndex are checked if they are legal and do not specify an instance that already exists. This version creates an instance of the specified master design. An optional array of parameters may be specified in the case where the master is a pCell.\n"
"    module\n"
"    The module in which to create the instance\n"
"    master\n"
"    The master of the design to instantiate\n"
"    baseName\n"
"    The base name for the instance\n"
"    bitIndex\n"
"    The bit index for the instance\n"
"    params\n"
"    Optional parameter array for pCell instances\n"
"    oacInvalidSuperMaster\n"
"    oacInvalidHierInstName\n"
"    oacVectorInstBitNameMatchesAutoName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"  Paramegers: (oaModule,oaDesign,oaScalarName,oaUInt4,oaParamArray)\n"
"    Calls: oaModVectorInstBit* create(oaModule* module,oaDesign* master,const oaScalarName& baseName,oaUInt4 bitIndex,const oaParamArray* params)\n"
"    Signature: create|ptr-oaModVectorInstBit|ptr-oaModule,ptr-oaDesign,cref-oaScalarName,simple-oaUInt4,cptr-oaParamArray,\n"
"    This function creates an oaModVectorInstBit object with the specified attributes. The given baseName and bitIndex are checked if they are legal and do not specify an instance that already exists. This version creates an instance of the specified master design. An optional array of parameters may be specified in the case where the master is a pCell.\n"
"    module\n"
"    The module in which to create the instance\n"
"    master\n"
"    The master of the design to instantiate\n"
"    baseName\n"
"    The base name for the instance\n"
"    bitIndex\n"
"    The bit index for the instance\n"
"    params\n"
"    Optional parameter array for pCell instances\n"
"    oacInvalidSuperMaster\n"
"    oacInvalidHierInstName\n"
"    oacVectorInstBitNameMatchesAutoName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"  Paramegers: (oaModule,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4)\n"
"    Calls: oaModVectorInstBit* create(oaModule* module,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName,const oaScalarName& baseName,oaUInt4 bitIndex)\n"
"    Signature: create|ptr-oaModVectorInstBit|ptr-oaModule,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,simple-oaUInt4,cptr-oaParamArray,\n"
"    This function creates an oaModVectorInstBit object with the specified attributes. The given baseName and bitIndex are checked if they are legal and do not specify an instance that already exists. This version creates an instance of the master implied by the specified library, cell, and view names (the master need not be opened to create instances of it). An optional array of parameters may be specified in the case where the master is a pCell.\n"
"    module\n"
"    The module in which to create the instance\n"
"    libName\n"
"    The library name of the instance master\n"
"    cellName\n"
"    The cell name of the instance master\n"
"    viewName\n"
"    The view name of the instance master\n"
"    baseName\n"
"    The base name for the instance\n"
"    bitIndex\n"
"    The bit index for the instance\n"
"    params\n"
"    Optional parameter array for pCell instances\n"
"    oacInvalidHierInstName\n"
"    oacVectorInstBitNameMatchesAutoName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
"  Paramegers: (oaModule,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaParamArray)\n"
"    Calls: oaModVectorInstBit* create(oaModule* module,const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName,const oaScalarName& baseName,oaUInt4 bitIndex,const oaParamArray* params)\n"
"    Signature: create|ptr-oaModVectorInstBit|ptr-oaModule,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,simple-oaUInt4,cptr-oaParamArray,\n"
"    This function creates an oaModVectorInstBit object with the specified attributes. The given baseName and bitIndex are checked if they are legal and do not specify an instance that already exists. This version creates an instance of the master implied by the specified library, cell, and view names (the master need not be opened to create instances of it). An optional array of parameters may be specified in the case where the master is a pCell.\n"
"    module\n"
"    The module in which to create the instance\n"
"    libName\n"
"    The library name of the instance master\n"
"    cellName\n"
"    The cell name of the instance master\n"
"    viewName\n"
"    The view name of the instance master\n"
"    baseName\n"
"    The base name for the instance\n"
"    bitIndex\n"
"    The bit index for the instance\n"
"    params\n"
"    Optional parameter array for pCell instances\n"
"    oacInvalidHierInstName\n"
"    oacVectorInstBitNameMatchesAutoName\n"
"    oacInstNameExists\n"
"    oacInstNameOverlapsOtherInst\n"
;

static PyObject*
oaModVectorInstBit_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaModule,oaDesign,oaScalarName,oaUInt4)
    {
        PyParamoaModule p1;
        PyParamoaDesign p2;
        PyParamoaScalarName p3;
        PyParamoaUInt4 p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaDesign_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaUInt4_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaModVectorInstBitp result= (oaModVectorInstBit::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaModVectorInstBit_FromoaModVectorInstBit(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaDesign,oaScalarName,oaUInt4,oaParamArray)
    {
        PyParamoaModule p1;
        PyParamoaDesign p2;
        PyParamoaScalarName p3;
        PyParamoaUInt4 p4;
        PyParamoaParamArray p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaDesign_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaParamArray_ConvertAof,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaModVectorInstBitp result= (oaModVectorInstBit::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.DataAof()));
            return PyoaModVectorInstBit_FromoaModVectorInstBit(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4)
    {
        PyParamoaModule p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        PyParamoaScalarName p5;
        PyParamoaUInt4 p6;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4,
              &PyoaScalarName_Convert,&p5,
              &PyoaUInt4_Convert,&p6)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModVectorInstBitp result= (oaModVectorInstBit::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data()));
            return PyoaModVectorInstBit_FromoaModVectorInstBit(result);
        }
    }
    PyErr_Clear();
    // Case: (oaModule,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaParamArray)
    {
        PyParamoaModule p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaScalarName p4;
        PyParamoaScalarName p5;
        PyParamoaUInt4 p6;
        PyParamoaParamArray p7;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&O&O&",
              &PyoaModule_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaScalarName_Convert,&p4,
              &PyoaScalarName_Convert,&p5,
              &PyoaUInt4_Convert,&p6,
              &PyoaParamArray_ConvertAof,&p7)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModVectorInstBitp result= (oaModVectorInstBit::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data(),p6.Data(),p7.DataAof()));
            return PyoaModVectorInstBit_FromoaModVectorInstBit(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModVectorInstBit, function: create, Choices are:\n"
        "    (oaModule,oaDesign,oaScalarName,oaUInt4)\n"
        "    (oaModule,oaDesign,oaScalarName,oaUInt4,oaParamArray)\n"
        "    (oaModule,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4)\n"
        "    (oaModule,oaScalarName,oaScalarName,oaScalarName,oaScalarName,oaUInt4,oaParamArray)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInstBit_static_find_doc[] = 
"Class: oaModVectorInstBit, Function: find\n"
"  Paramegers: (oaModule,oaScalarName,oaUInt4)\n"
"    Calls: oaModVectorInstBit* find(const oaModule* module,const oaScalarName& baseName,oaUInt4 bitIndex)\n"
"    Signature: find|ptr-oaModVectorInstBit|cptr-oaModule,cref-oaScalarName,simple-oaUInt4,\n"
"    This function searches the specified module looking for a vectorInstBit with the specified baseName and bitIndex . If the instance is found, it is returned; otherwise, NULL is returned.\n"
"    module\n"
"    The module to search for the instance\n"
"    baseName\n"
"    The base name of the instance to find\n"
"    bitIndex\n"
"    The bit index of the instance to find\n"
;

static PyObject*
oaModVectorInstBit_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule p1;
    PyParamoaScalarName p2;
    PyParamoaUInt4 p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaModule_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaUInt4_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaModVectorInstBitp result= (oaModVectorInstBit::find(p1.Data(),p2.Data(),p3.Data()));
        return PyoaModVectorInstBit_FromoaModVectorInstBit(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInstBit_static_isValidName_doc[] = 
"Class: oaModVectorInstBit, Function: isValidName\n"
"  Paramegers: (oaModule,oaScalarName,oaUInt4)\n"
"    Calls: oaBoolean isValidName(const oaModule* module,const oaScalarName& baseName,oaUInt4 bitIndex)\n"
"    Signature: isValidName|simple-oaBoolean|cptr-oaModule,cref-oaScalarName,simple-oaUInt4,\n"
"    This function returns a boolean indicating whether the specified baseName and bitIndex would be valid for an oaModVectorInstBit in the specified module .\n"
"    module\n"
"    The module to check the name against\n"
"    baseName\n"
"    The base name to be checked\n"
"    bitIndex\n"
"    The bit index to be checked\n"
;

static PyObject*
oaModVectorInstBit_static_isValidName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule p1;
    PyParamoaScalarName p2;
    PyParamoaUInt4 p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaModule_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaUInt4_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (oaModVectorInstBit::isValidName(p1.Data(),p2.Data(),p3.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaModVectorInstBit_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaModVectorInstBit_static_create,METH_VARARGS,oaModVectorInstBit_static_create_doc},
    {"static_find",(PyCFunction)oaModVectorInstBit_static_find,METH_VARARGS,oaModVectorInstBit_static_find_doc},
    {"static_isValidName",(PyCFunction)oaModVectorInstBit_static_isValidName,METH_VARARGS,oaModVectorInstBit_static_isValidName_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModVectorInstBit_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModVectorInstBit_Type)<0) {
      printf("** PyType_Ready failed for: oaModVectorInstBit\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModVectorInstBit",
           (PyObject*)(&PyoaModVectorInstBit_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModVectorInstBit\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaModVectorInstBit_Type.tp_dict;
    for(method=oaModVectorInstBit_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModVectorInstDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModVectorInstDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModVectorInstDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModVectorInstDefObject* self = (PyoaModVectorInstDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModVectorInstDef)
    {
        PyParamoaModVectorInstDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModVectorInstDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModVectorInstDef, Choices are:\n"
        "    (oaModVectorInstDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModVectorInstDef_tp_dealloc(PyoaModVectorInstDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModVectorInstDef_tp_repr(PyObject *ob)
{
    PyParamoaModVectorInstDef value;
    int convert_status=PyoaModVectorInstDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaModVectorInstDef::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaScalarName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[40];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaModVectorInstDef::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModVectorInstDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModVectorInstDef v1;
    PyParamoaModVectorInstDef v2;
    int convert_status1=PyoaModVectorInstDef_Convert(ob1,&v1);
    int convert_status2=PyoaModVectorInstDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModVectorInstDef_Convert(PyObject* ob,PyParamoaModVectorInstDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaModVectorInstDef_Check(ob)) {
        result->SetData( (oaModVectorInstDef**) ((PyoaModVectorInstDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModVectorInstDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModVectorInstDef_FromoaModVectorInstDef(oaModVectorInstDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaModVectorInstDef* data=*value;
        PyObject* bself = PyoaModVectorInstDef_Type.tp_alloc(&PyoaModVectorInstDef_Type,0);
        if (bself == NULL) return bself;
        PyoaModVectorInstDefObject* self = (PyoaModVectorInstDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaModVectorInstDef_FromoaModVectorInstDef(oaModVectorInstDef* data)
{
    if (data) {
       PyObject* bself = PyoaModVectorInstDef_Type.tp_alloc(&PyoaModVectorInstDef_Type,0);
       if (bself == NULL) return bself;
       PyoaModVectorInstDefObject* self = (PyoaModVectorInstDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModVectorInstDef_destroy_doc[] = 
"Class: oaModVectorInstDef, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function destroys this oaModVectorInstDef, removing it from the database. An exception is thrown if the oaModVectorInstDef is implicit or if there are still oaModVectorInsts associated with it.\n"
"    oacCannotDestroyImplicitVectorInstDef\n"
"    oacCannotDestroyVectorInstDefWithInsts\n"
;

static PyObject*
oaModVectorInstDef_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModVectorInstDef data;
    int convert_status=PyoaModVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModVectorInstDefObject* self=(PyoaModVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInstDef_getBitOrder_doc[] = 
"Class: oaModVectorInstDef, Function: getBitOrder\n"
"  Paramegers: ()\n"
"    Calls: oaBitOrder getBitOrder() const\n"
"    Signature: getBitOrder|simple-oaBitOrder|\n"
"    BrowseData: 1\n"
"    This function returns the bitOrder associated with this oaModVectorInstDef object.\n"
;

static PyObject*
oaModVectorInstDef_getBitOrder(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModVectorInstDef data;
    int convert_status=PyoaModVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModVectorInstDefObject* self=(PyoaModVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBitOrder* result= new oaBitOrder(data.DataCall()->getBitOrder());
        return PyoaBitOrder_FromoaBitOrder(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInstDef_getMaxIndex_doc[] = 
"Class: oaModVectorInstDef, Function: getMaxIndex\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getMaxIndex() const\n"
"    Signature: getMaxIndex|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the largest bit number in use for this oaModVectorInstDef object. This is the largest index used across all vectorInsts associated with this oaModVectorInstDef object.\n"
;

static PyObject*
oaModVectorInstDef_getMaxIndex(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModVectorInstDef data;
    int convert_status=PyoaModVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModVectorInstDefObject* self=(PyoaModVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getMaxIndex());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInstDef_getMinIndex_doc[] = 
"Class: oaModVectorInstDef, Function: getMinIndex\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getMinIndex() const\n"
"    Signature: getMinIndex|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the smallest bit number in use for this oaModVectorInstDef object. This is the smallest index used across all vectorInsts associated with this oaModVectorInstDef object.\n"
;

static PyObject*
oaModVectorInstDef_getMinIndex(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModVectorInstDef data;
    int convert_status=PyoaModVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModVectorInstDefObject* self=(PyoaModVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getMinIndex());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInstDef_getName_doc[] = 
"Class: oaModVectorInstDef, Function: getName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getName(oaScalarName& name) const\n"
"    Signature: getName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the name of this oaModVectorInstDef object.\n"
"    name\n"
"    The scalar name in which to return the oaModVectorInstDef object name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the name string of this oaModVectorInstDef object in the specified nameSpace.\n"
"    ns\n"
"    The nameSpace to use when getting the name string\n"
"    name\n"
"    Returns the string name of this oaModVectorInstDef\n"
;

static PyObject*
oaModVectorInstDef_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModVectorInstDef data;
    int convert_status=PyoaModVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModVectorInstDefObject* self=(PyoaModVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModVectorInstDef, function: getName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInstDef_getNumBits_doc[] = 
"Class: oaModVectorInstDef, Function: getNumBits\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumBits() const\n"
"    Signature: getNumBits|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of bits covered by the vectorInsts in this oaModVectorInstDef. The number of bits is equal to abs(maxIndex - minIndex) + 1.\n"
;

static PyObject*
oaModVectorInstDef_getNumBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModVectorInstDef data;
    int convert_status=PyoaModVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModVectorInstDefObject* self=(PyoaModVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumBits());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInstDef_getVectorInstBits_doc[] = 
"Class: oaModVectorInstDef, Function: getVectorInstBits\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaModInst_oaModVectorInstDef getVectorInstBits() const\n"
"    Signature: getVectorInstBits|simple-oaCollection_oaModInst_oaModVectorInstDef|\n"
"    BrowseData: 1\n"
"    This function returns a collection of oaModVectorInstBit and oaModModuleVectorInstBit objects associated with this oaModVectorInstDef object.\n"
;

static PyObject*
oaModVectorInstDef_getVectorInstBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModVectorInstDef data;
    int convert_status=PyoaModVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModVectorInstDefObject* self=(PyoaModVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaModInst_oaModVectorInstDef* result= new oaCollection_oaModInst_oaModVectorInstDef(data.DataCall()->getVectorInstBits());
        return PyoaCollection_oaModInst_oaModVectorInstDef_FromoaCollection_oaModInst_oaModVectorInstDef(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInstDef_getVectorInstBitsIter_doc[] = 
"Class: oaModVectorInstDef, Function: getVectorInstBitsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaModInst getVectorInstBitsIter() const\n"
"    Signature: getVectorInstBitsIter|simple-oaIter_oaModInst|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of oaModVectorInstBit and oaModModuleVectorInstBit objects associated with this oaModVectorInstDef object.\n"
;

static PyObject*
oaModVectorInstDef_getVectorInstBitsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModVectorInstDef data;
    int convert_status=PyoaModVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModVectorInstDefObject* self=(PyoaModVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaModInst* result= new oaIter_oaModInst(data.DataCall()->getVectorInstBits());
        return PyoaIter_oaModInst_FromoaIter_oaModInst(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInstDef_getVectorInsts_doc[] = 
"Class: oaModVectorInstDef, Function: getVectorInsts\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaModInst_oaModVectorInstDef getVectorInsts() const\n"
"    Signature: getVectorInsts|simple-oaCollection_oaModInst_oaModVectorInstDef|\n"
"    BrowseData: 1\n"
"    This function returns a collection of oaModVectorInst and oaModModuleVectorInst objects associated with this oaModVectorInstDef object.\n"
;

static PyObject*
oaModVectorInstDef_getVectorInsts(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModVectorInstDef data;
    int convert_status=PyoaModVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModVectorInstDefObject* self=(PyoaModVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaModInst_oaModVectorInstDef* result= new oaCollection_oaModInst_oaModVectorInstDef(data.DataCall()->getVectorInsts());
        return PyoaCollection_oaModInst_oaModVectorInstDef_FromoaCollection_oaModInst_oaModVectorInstDef(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInstDef_getVectorInstsIter_doc[] = 
"Class: oaModVectorInstDef, Function: getVectorInstsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaModInst getVectorInstsIter() const\n"
"    Signature: getVectorInstsIter|simple-oaIter_oaModInst|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of oaModVectorInst and oaModModuleVectorInst objects associated with this oaModVectorInstDef object.\n"
;

static PyObject*
oaModVectorInstDef_getVectorInstsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModVectorInstDef data;
    int convert_status=PyoaModVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModVectorInstDefObject* self=(PyoaModVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaModInst* result= new oaIter_oaModInst(data.DataCall()->getVectorInsts());
        return PyoaIter_oaModInst_FromoaIter_oaModInst(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInstDef_isImplicit_doc[] = 
"Class: oaModVectorInstDef, Function: isImplicit\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isImplicit() const\n"
"    Signature: isImplicit|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether this oaModVectorInstDef was implicitly created or not.\n"
;

static PyObject*
oaModVectorInstDef_isImplicit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModVectorInstDef data;
    int convert_status=PyoaModVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModVectorInstDefObject* self=(PyoaModVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isImplicit());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInstDef_setBitOrder_doc[] = 
"Class: oaModVectorInstDef, Function: setBitOrder\n"
"  Paramegers: (oaBitOrder)\n"
"    Calls: void setBitOrder(oaBitOrder order)\n"
"    Signature: setBitOrder|void-void|simple-oaBitOrder,\n"
"    This function changes the bitOrder value associated with the oaModVectorInstDef. An exception is thrown if this vectorInstDef was implicitly created.\n"
"    order\n"
"    The new bitOrder value for this vectorInstDef\n"
"    oacBitOrderVectorInstDefImplicit\n"
;

static PyObject*
oaModVectorInstDef_setBitOrder(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModVectorInstDef data;
    int convert_status=PyoaModVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModVectorInstDefObject* self=(PyoaModVectorInstDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBitOrder p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBitOrder_Convert,&p1)) {
        data.DataCall()->setBitOrder(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInstDef_isNull_doc[] =
"Class: oaModVectorInstDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaModVectorInstDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaModVectorInstDef data;
    int convert_status=PyoaModVectorInstDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaModVectorInstDef_assign_doc[] = 
"Class: oaModVectorInstDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModVectorInstDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModVectorInstDef data;
  int convert_status=PyoaModVectorInstDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModVectorInstDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModVectorInstDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModVectorInstDef_methodlist[] = {
    {"destroy",(PyCFunction)oaModVectorInstDef_destroy,METH_VARARGS,oaModVectorInstDef_destroy_doc},
    {"getBitOrder",(PyCFunction)oaModVectorInstDef_getBitOrder,METH_VARARGS,oaModVectorInstDef_getBitOrder_doc},
    {"getMaxIndex",(PyCFunction)oaModVectorInstDef_getMaxIndex,METH_VARARGS,oaModVectorInstDef_getMaxIndex_doc},
    {"getMinIndex",(PyCFunction)oaModVectorInstDef_getMinIndex,METH_VARARGS,oaModVectorInstDef_getMinIndex_doc},
    {"getName",(PyCFunction)oaModVectorInstDef_getName,METH_VARARGS,oaModVectorInstDef_getName_doc},
    {"getNumBits",(PyCFunction)oaModVectorInstDef_getNumBits,METH_VARARGS,oaModVectorInstDef_getNumBits_doc},
    {"getVectorInstBits",(PyCFunction)oaModVectorInstDef_getVectorInstBits,METH_VARARGS,oaModVectorInstDef_getVectorInstBits_doc},
    {"getVectorInstBitsIter",(PyCFunction)oaModVectorInstDef_getVectorInstBitsIter,METH_VARARGS,oaModVectorInstDef_getVectorInstBitsIter_doc},
    {"getVectorInsts",(PyCFunction)oaModVectorInstDef_getVectorInsts,METH_VARARGS,oaModVectorInstDef_getVectorInsts_doc},
    {"getVectorInstsIter",(PyCFunction)oaModVectorInstDef_getVectorInstsIter,METH_VARARGS,oaModVectorInstDef_getVectorInstsIter_doc},
    {"isImplicit",(PyCFunction)oaModVectorInstDef_isImplicit,METH_VARARGS,oaModVectorInstDef_isImplicit_doc},
    {"setBitOrder",(PyCFunction)oaModVectorInstDef_setBitOrder,METH_VARARGS,oaModVectorInstDef_setBitOrder_doc},
    {"isNull",(PyCFunction)oaModVectorInstDef_tp_isNull,METH_VARARGS,oaModVectorInstDef_isNull_doc},
    {"assign",(PyCFunction)oaModVectorInstDef_tp_assign,METH_VARARGS,oaModVectorInstDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModVectorInstDef_doc[] = 
"Class: oaModVectorInstDef\n"
"  The oaModVectorInstDef class implements the definition of a module vectorInst, including its base name and bit-range. All vectorInsts in a module with the same base name are managed by the same vectorInst definition. The oaModvectorInstDef class tracks the minimum and maximum indices referred to by all of its corresponding vectorInst objects.\n"
"  A vectorInstDef can be 'sparse' (have missing bits). Vectors do not have to start or end at zero. For example, a[22:25] is a legal vectorInst name. Vector indexes must be non-negative.\n"
"  An vectorInstDef is automatically created if necessary whenever applications create vectorInsts. Implicitly created vectorInst definitions have no bitOrder. Applications may explicitly create a vectorInst definition in order to specify that it has a specific bitOrder.\n"
"  Implicitly created vectorInst definitions are automatically destroyed when the last vectorInst with the same base name is destroyed. Explicitly created vectorInst definitions must be explicitly destroyed.\n"
"  The oaModVectorInstDef class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaModVectorInstDef)\n"
"    Calls: (const oaModVectorInstDef&)\n"
"    Signature: oaModVectorInstDef||cref-oaModVectorInstDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModVectorInstDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModVectorInstDef",
    sizeof(PyoaModVectorInstDefObject),
    0,
    (destructor)oaModVectorInstDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModVectorInstDef_tp_compare,	/* tp_compare */
    (reprfunc)oaModVectorInstDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModVectorInstDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaModVectorInstDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaModObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModVectorInstDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModVectorInstDef_static_create_doc[] = 
"Class: oaModVectorInstDef, Function: create\n"
"  Paramegers: (oaModule,oaScalarName,oaBitOrder)\n"
"    Calls: oaModVectorInstDef* create(const oaModule* module,const oaScalarName& name,oaBitOrder order)\n"
"    Signature: create|ptr-oaModVectorInstDef|cptr-oaModule,cref-oaScalarName,simple-oaBitOrder,\n"
"    This function creates an oaModVectorInstDef in the specified module with the given base name and bit order. An exception is thrown if an oaModVectorInstDef already exists with the specified name . Explicitly creating an oaModVectorInstDef also means that the vectorInst definition must be explicitly destroyed.\n"
"    module\n"
"    The module to create the oaModVectorInstDef object in\n"
"    name\n"
"    The base name for the oaModVectorInstDef\n"
"    order\n"
"    The bit order for the oaModVectorInstDef\n"
"    oacVectorInstDefAlreadyExists\n"
;

static PyObject*
oaModVectorInstDef_static_create(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule p1;
    PyParamoaScalarName p2;
    PyParamoaBitOrder p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaModule_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaBitOrder_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaModVectorInstDefp result= (oaModVectorInstDef::create(p1.Data(),p2.Data(),p3.Data()));
        return PyoaModVectorInstDef_FromoaModVectorInstDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModVectorInstDef_static_find_doc[] = 
"Class: oaModVectorInstDef, Function: find\n"
"  Paramegers: (oaModule,oaScalarName)\n"
"    Calls: oaModVectorInstDef* find(const oaModule* module,const oaScalarName& name)\n"
"    Signature: find|ptr-oaModVectorInstDef|cptr-oaModule,cref-oaScalarName,\n"
"    This function searches the specified module for a vectorInstDef with the specified name. The function returns the vectorInstDef if it finds it. Otherwise, NULL is returned.\n"
;

static PyObject*
oaModVectorInstDef_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaModule_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaModVectorInstDefp result= (oaModVectorInstDef::find(p1.Data(),p2.Data()));
        return PyoaModVectorInstDef_FromoaModVectorInstDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaModVectorInstDef_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaModVectorInstDef_static_create,METH_VARARGS,oaModVectorInstDef_static_create_doc},
    {"static_find",(PyCFunction)oaModVectorInstDef_static_find,METH_VARARGS,oaModVectorInstDef_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModVectorInstDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModVectorInstDef_Type)<0) {
      printf("** PyType_Ready failed for: oaModVectorInstDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModVectorInstDef",
           (PyObject*)(&PyoaModVectorInstDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModVectorInstDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaModVectorInstDef_Type.tp_dict;
    for(method=oaModVectorInstDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModule
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaModule_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaModule_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaModuleObject* self = (PyoaModuleObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaModule)
    {
        PyParamoaModule p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaModule_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaModule, Choices are:\n"
        "    (oaModule)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaModule_tp_dealloc(PyoaModuleObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaModule_tp_repr(PyObject *ob)
{
    PyParamoaModule value;
    int convert_status=PyoaModule_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaModule::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaScalarName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[30];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaModule::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaModule_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaModule v1;
    PyParamoaModule v2;
    int convert_status1=PyoaModule_Convert(ob1,&v1);
    int convert_status2=PyoaModule_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaModule_Convert(PyObject* ob,PyParamoaModule* result)
{
    if (ob == NULL) return 1;
    if (PyoaModule_Check(ob)) {
        result->SetData( (oaModule**) ((PyoaModuleObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModule Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaModule_FromoaModule(oaModule** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaModule* data=*value;
        PyObject* bself = PyoaModule_Type.tp_alloc(&PyoaModule_Type,0);
        if (bself == NULL) return bself;
        PyoaModuleObject* self = (PyoaModuleObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaModule_FromoaModule(oaModule* data)
{
    if (data) {
       PyObject* bself = PyoaModule_Type.tp_alloc(&PyoaModule_Type,0);
       if (bself == NULL) return bself;
       PyoaModuleObject* self = (PyoaModuleObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModule_destroy_doc[] = 
"Class: oaModule, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function destroys this module. If this module is the top module of the design, the top block of the design and all block-domain objects in the top block also will be deleted.\n"
;

static PyObject*
oaModule_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_detach_doc[] = 
"Class: oaModule, Function: detach\n"
"  Paramegers: (oaScalarName,oaScalarName,oaScalarName)\n"
"    Calls: oaDesign* detach(const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName)\n"
"    Signature: detach|ptr-oaDesign|cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,simple-oaDetachVisibilityEnum,\n"
"    This function detaches this module and the module domain hierarchy rooted under it by moving them from the owning design into a new design. The modules are removed from the original design and the module instances will become design instances. The new design is created with the specified lib/cell/view names and the pointer to it is returned. An exception is thrown if a design with the specified lib/cell/view names already exists.\n"
"    Note: This operation cannot be undone and it is an explicit requirement that undo be disabled for the module's design before attempting this operation. An exception will be thrown if undo is not disabled before this operation. Undo can be re-enabled after the operation is complete.\n"
"    libName\n"
"    The library name of the new design\n"
"    cellName\n"
"    The cell name of the new design\n"
"    viewName\n"
"    The view name of the new design\n"
"    view\n"
"    Specifies the visibility of the detached module\n"
"    oacModuleDetachDesignExists\n"
"    oacModuleDetachRequiresUndoToBeDisabled\n"
"  Paramegers: (oaScalarName,oaScalarName,oaScalarName,oaDetachVisibilityEnum)\n"
"    Calls: oaDesign* detach(const oaScalarName& libName,const oaScalarName& cellName,const oaScalarName& viewName,oaDetachVisibilityEnum view)\n"
"    Signature: detach|ptr-oaDesign|cref-oaScalarName,cref-oaScalarName,cref-oaScalarName,simple-oaDetachVisibilityEnum,\n"
"    This function detaches this module and the module domain hierarchy rooted under it by moving them from the owning design into a new design. The modules are removed from the original design and the module instances will become design instances. The new design is created with the specified lib/cell/view names and the pointer to it is returned. An exception is thrown if a design with the specified lib/cell/view names already exists.\n"
"    Note: This operation cannot be undone and it is an explicit requirement that undo be disabled for the module's design before attempting this operation. An exception will be thrown if undo is not disabled before this operation. Undo can be re-enabled after the operation is complete.\n"
"    libName\n"
"    The library name of the new design\n"
"    cellName\n"
"    The cell name of the new design\n"
"    viewName\n"
"    The view name of the new design\n"
"    view\n"
"    Specifies the visibility of the detached module\n"
"    oacModuleDetachDesignExists\n"
"    oacModuleDetachRequiresUndoToBeDisabled\n"
;

static PyObject*
oaModule_detach(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName,oaScalarName,oaScalarName)
    {
        PyParamoaScalarName p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaScalarName_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3)) {
            oaDesignp result= (data.DataCall()->detach(p1.Data(),p2.Data(),p3.Data()));
            return PyoaDesign_FromoaDesign(result);
        }
    }
    PyErr_Clear();
    // Case: (oaScalarName,oaScalarName,oaScalarName,oaDetachVisibilityEnum)
    {
        PyParamoaScalarName p1;
        PyParamoaScalarName p2;
        PyParamoaScalarName p3;
        PyParamoaDetachVisibilityEnum p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaScalarName_Convert,&p1,
              &PyoaScalarName_Convert,&p2,
              &PyoaScalarName_Convert,&p3,
              &PyoaDetachVisibilityEnum_Convert,&p4)) {
            oaDesignp result= (data.DataCall()->detach(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaDesign_FromoaDesign(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModule, function: detach, Choices are:\n"
        "    (oaScalarName,oaScalarName,oaScalarName)\n"
        "    (oaScalarName,oaScalarName,oaScalarName,oaDetachVisibilityEnum)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getAssignments_doc[] = 
"Class: oaModule, Function: getAssignments\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaModAssignment_oaModule getAssignments() const\n"
"    Signature: getAssignments|simple-oaCollection_oaModAssignment_oaModule|\n"
"    BrowseData: 1\n"
"    This function returns a collection of assignments in this module.\n"
;

static PyObject*
oaModule_getAssignments(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaModAssignment_oaModule* result= new oaCollection_oaModAssignment_oaModule(data.DataCall()->getAssignments());
        return PyoaCollection_oaModAssignment_oaModule_FromoaCollection_oaModAssignment_oaModule(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getAssignmentsIter_doc[] = 
"Class: oaModule, Function: getAssignmentsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaModAssignment getAssignmentsIter() const\n"
"    Signature: getAssignmentsIter|simple-oaIter_oaModAssignment|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of assignments in this module.\n"
;

static PyObject*
oaModule_getAssignmentsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaModAssignment* result= new oaIter_oaModAssignment(data.DataCall()->getAssignments());
        return PyoaIter_oaModAssignment_FromoaIter_oaModAssignment(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getBlock_doc[] = 
"Class: oaModule, Function: getBlock\n"
"  Paramegers: ()\n"
"    Calls: oaBlock* getBlock() const\n"
"    Signature: getBlock|ptr-oaBlock|\n"
"    BrowseData: 1\n"
"    This function returns the block that corresponds to this module. Only top modules may have a corresponding block -- the top block in the same design. The correspondence of a top module and a top block is established by the visibleToBlock parameter passed to oaDesign::setTopModule and the visibleToModule parameter passed to oaBlock::create .\n"
"    This function returns NULL if this module is not a top module or if it is a top module but does not have a corresponding block.\n"
;

static PyObject*
oaModule_getBlock(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBlockp result= (data.DataCall()->getBlock());
        return PyoaBlock_FromoaBlock(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getBusNetDefs_doc[] = 
"Class: oaModule, Function: getBusNetDefs\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaModBusNetDef_oaModule getBusNetDefs() const\n"
"    Signature: getBusNetDefs|simple-oaCollection_oaModBusNetDef_oaModule|\n"
"    BrowseData: 1\n"
"    This function returns a collection of busNetDefs in this module.\n"
;

static PyObject*
oaModule_getBusNetDefs(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaModBusNetDef_oaModule* result= new oaCollection_oaModBusNetDef_oaModule(data.DataCall()->getBusNetDefs());
        return PyoaCollection_oaModBusNetDef_oaModule_FromoaCollection_oaModBusNetDef_oaModule(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getBusNetDefsIter_doc[] = 
"Class: oaModule, Function: getBusNetDefsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaModBusNetDef getBusNetDefsIter() const\n"
"    Signature: getBusNetDefsIter|simple-oaIter_oaModBusNetDef|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of busNetDefs in this module.\n"
;

static PyObject*
oaModule_getBusNetDefsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaModBusNetDef* result= new oaIter_oaModBusNetDef(data.DataCall()->getBusNetDefs());
        return PyoaIter_oaModBusNetDef_FromoaIter_oaModBusNetDef(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getBusTermDefs_doc[] = 
"Class: oaModule, Function: getBusTermDefs\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaModBusTermDef_oaModule getBusTermDefs() const\n"
"    Signature: getBusTermDefs|simple-oaCollection_oaModBusTermDef_oaModule|\n"
"    BrowseData: 1\n"
"    This function returns a collection of busTermDefs in this module.\n"
;

static PyObject*
oaModule_getBusTermDefs(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaModBusTermDef_oaModule* result= new oaCollection_oaModBusTermDef_oaModule(data.DataCall()->getBusTermDefs());
        return PyoaCollection_oaModBusTermDef_oaModule_FromoaCollection_oaModBusTermDef_oaModule(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getBusTermDefsIter_doc[] = 
"Class: oaModule, Function: getBusTermDefsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaModBusTermDef getBusTermDefsIter() const\n"
"    Signature: getBusTermDefsIter|simple-oaIter_oaModBusTermDef|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of busTermDefs in this module.\n"
;

static PyObject*
oaModule_getBusTermDefsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaModBusTermDef* result= new oaIter_oaModBusTermDef(data.DataCall()->getBusTermDefs());
        return PyoaIter_oaModBusTermDef_FromoaIter_oaModBusTermDef(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getConnectDefs_doc[] = 
"Class: oaModule, Function: getConnectDefs\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaModConnectDef_oaModule getConnectDefs() const\n"
"    Signature: getConnectDefs|simple-oaCollection_oaModConnectDef_oaModule|\n"
"    BrowseData: 1\n"
"    This function returns a collection of connectDefs in this module.\n"
;

static PyObject*
oaModule_getConnectDefs(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaModConnectDef_oaModule* result= new oaCollection_oaModConnectDef_oaModule(data.DataCall()->getConnectDefs());
        return PyoaCollection_oaModConnectDef_oaModule_FromoaCollection_oaModConnectDef_oaModule(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getConnectDefsIter_doc[] = 
"Class: oaModule, Function: getConnectDefsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaModConnectDef getConnectDefsIter() const\n"
"    Signature: getConnectDefsIter|simple-oaIter_oaModConnectDef|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of connectDefs in this module.\n"
;

static PyObject*
oaModule_getConnectDefsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaModConnectDef* result= new oaIter_oaModConnectDef(data.DataCall()->getConnectDefs());
        return PyoaIter_oaModConnectDef_FromoaIter_oaModConnectDef(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getDefaultConstraintGroup_doc[] = 
"Class: oaModule, Function: getDefaultConstraintGroup\n"
"  Paramegers: ()\n"
"    Calls: oaConstraintGroup* getDefaultConstraintGroup() const\n"
"    Signature: getDefaultConstraintGroup|ptr-oaConstraintGroup|\n"
"    BrowseData: 1\n"
"    This function returns the default constraint group for this module. If no constraints have been set on the default constraint group, a new constraint group is created and returned.\n"
;

static PyObject*
oaModule_getDefaultConstraintGroup(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaConstraintGroupp result= (data.DataCall()->getDefaultConstraintGroup());
        return PyoaConstraintGroup_FromoaConstraintGroup(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getInstTerms_doc[] = 
"Class: oaModule, Function: getInstTerms\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaModInstTerm_oaModule getInstTerms() const\n"
"    Signature: getInstTerms|simple-oaCollection_oaModInstTerm_oaModule|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns a collection of instTerms in this module.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bits flags are defined as follows:\n"
"    oacInstTermIterNotImplicit: the collection will only contain instTerms that were explicitly created\n"
"    oacInstTermIterSingleBit: the collection will only contain instTerms that make a single-bit connection\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaModInstTerm_oaModule getInstTerms(oaUInt4 filterFlags) const\n"
"    Signature: getInstTerms|simple-oaCollection_oaModInstTerm_oaModule|simple-oaUInt4,\n"
"    This function returns a collection of instTerms in this module.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bits flags are defined as follows:\n"
"    oacInstTermIterNotImplicit: the collection will only contain instTerms that were explicitly created\n"
"    oacInstTermIterSingleBit: the collection will only contain instTerms that make a single-bit connection\n"
;

static PyObject*
oaModule_getInstTerms(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaModInstTerm_oaModule* result= new oaCollection_oaModInstTerm_oaModule(data.DataCall()->getInstTerms());
            return PyoaCollection_oaModInstTerm_oaModule_FromoaCollection_oaModInstTerm_oaModule(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaModInstTerm_oaModule* result= new oaCollection_oaModInstTerm_oaModule(data.DataCall()->getInstTerms(p1.Data()));
            return PyoaCollection_oaModInstTerm_oaModule_FromoaCollection_oaModInstTerm_oaModule(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModule, function: getInstTerms, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getInstTermsIter_doc[] = 
"Class: oaModule, Function: getInstTermsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaModInstTerm getInstTermsIter() const\n"
"    Signature: getInstTermsIter|simple-oaIter_oaModInstTerm|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of instTerms in this module.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bits flags are defined as follows:\n"
"    oacInstTermIterNotImplicit: the collection will only contain instTerms that were explicitly created\n"
"    oacInstTermIterSingleBit: the collection will only contain instTerms that make a single-bit connection\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaModInstTerm getInstTermsIter(oaUInt4 filterFlags) const\n"
"    Signature: getInstTermsIter|simple-oaIter_oaModInstTerm|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of instTerms in this module.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bits flags are defined as follows:\n"
"    oacInstTermIterNotImplicit: the collection will only contain instTerms that were explicitly created\n"
"    oacInstTermIterSingleBit: the collection will only contain instTerms that make a single-bit connection\n"
;

static PyObject*
oaModule_getInstTermsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaModInstTerm* result= new oaIter_oaModInstTerm(data.DataCall()->getInstTerms());
            return PyoaIter_oaModInstTerm_FromoaIter_oaModInstTerm(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaModInstTerm* result= new oaIter_oaModInstTerm(data.DataCall()->getInstTerms(p1.Data()));
            return PyoaIter_oaModInstTerm_FromoaIter_oaModInstTerm(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModule, function: getInstTermsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getInsts_doc[] = 
"Class: oaModule, Function: getInsts\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaModInst_oaModule getInsts() const\n"
"    Signature: getInsts|simple-oaCollection_oaModInst_oaModule|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns a collection of instances in this module. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaModInst_oaModule getInsts(oaUInt4 filterFlags) const\n"
"    Signature: getInsts|simple-oaCollection_oaModInst_oaModule|simple-oaUInt4,\n"
"    This function returns a collection of instances in this module. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
;

static PyObject*
oaModule_getInsts(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaModInst_oaModule* result= new oaCollection_oaModInst_oaModule(data.DataCall()->getInsts());
            return PyoaCollection_oaModInst_oaModule_FromoaCollection_oaModInst_oaModule(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaModInst_oaModule* result= new oaCollection_oaModInst_oaModule(data.DataCall()->getInsts(p1.Data()));
            return PyoaCollection_oaModInst_oaModule_FromoaCollection_oaModInst_oaModule(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModule, function: getInsts, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getInstsIter_doc[] = 
"Class: oaModule, Function: getInstsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaModInst getInstsIter() const\n"
"    Signature: getInstsIter|simple-oaIter_oaModInst|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of instances in this module. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaModInst getInstsIter(oaUInt4 filterFlags) const\n"
"    Signature: getInstsIter|simple-oaIter_oaModInst|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of instances in this module. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacInstIterSingleBit: the collection contains single-bit instances\n"
"    oacInstIterNotImplicit: the collection will not contain any implicitly created instances\n"
;

static PyObject*
oaModule_getInstsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaModInst* result= new oaIter_oaModInst(data.DataCall()->getInsts());
            return PyoaIter_oaModInst_FromoaIter_oaModInst(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaModInst* result= new oaIter_oaModInst(data.DataCall()->getInsts(p1.Data()));
            return PyoaIter_oaModInst_FromoaIter_oaModInst(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModule, function: getInstsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getModuleInstHeaders_doc[] = 
"Class: oaModule, Function: getModuleInstHeaders\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaModModuleInstHeader_oaModule getModuleInstHeaders() const\n"
"    Signature: getModuleInstHeaders|simple-oaCollection_oaModModuleInstHeader_oaModule|\n"
"    BrowseData: 1\n"
"    This function returns a collection of moduleInstHeaders in this module.\n"
;

static PyObject*
oaModule_getModuleInstHeaders(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaModModuleInstHeader_oaModule* result= new oaCollection_oaModModuleInstHeader_oaModule(data.DataCall()->getModuleInstHeaders());
        return PyoaCollection_oaModModuleInstHeader_oaModule_FromoaCollection_oaModModuleInstHeader_oaModule(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getModuleInstHeadersIter_doc[] = 
"Class: oaModule, Function: getModuleInstHeadersIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaModModuleInstHeader getModuleInstHeadersIter() const\n"
"    Signature: getModuleInstHeadersIter|simple-oaIter_oaModModuleInstHeader|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of moduleInstHeaders in this module.\n"
;

static PyObject*
oaModule_getModuleInstHeadersIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaModModuleInstHeader* result= new oaIter_oaModModuleInstHeader(data.DataCall()->getModuleInstHeaders());
        return PyoaIter_oaModModuleInstHeader_FromoaIter_oaModModuleInstHeader(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getName_doc[] = 
"Class: oaModule, Function: getName\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void getName(oaScalarName& name) const\n"
"    Signature: getName|void-void|ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName\n"
"    This function returns the name of this module.\n"
"    name\n"
"    The returned module name\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& nameSpace,oaString& nameStr) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the name of this module in the specified string in the given nameSpace.\n"
"    nameSpace\n"
"    The nameSpace used to generate the name string.\n"
"    nameStr\n"
"    The name of the module.\n"
;

static PyObject*
oaModule_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModule, function: getName, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getNets_doc[] = 
"Class: oaModule, Function: getNets\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaModNet_oaModule getNets() const\n"
"    Signature: getNets|simple-oaCollection_oaModNet_oaModule|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    oaModule::getNets\n"
"    This function returns a collection of nets in this module. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    This specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacNetIterAll: the collection contains all nets\n"
"    oacNetIterSingleBit: the collection contains single-bit nets\n"
"    oacNetIterBundle: the collection contains all the bundleNets in the module\n"
"    oacNetIterPreferred: the collection only contains the preferred nets; equivalent nets are omitted\n"
"    oacNetIterNotImplicit: the collection contains explicitly created nets\n"
"    oacInvalidModuleNetIterFlags\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaModNet_oaModule getNets(oaUInt4 filterFlags) const\n"
"    Signature: getNets|simple-oaCollection_oaModNet_oaModule|simple-oaUInt4,\n"
"    oaModule::getNets\n"
"    This function returns a collection of nets in this module. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    This specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacNetIterAll: the collection contains all nets\n"
"    oacNetIterSingleBit: the collection contains single-bit nets\n"
"    oacNetIterBundle: the collection contains all the bundleNets in the module\n"
"    oacNetIterPreferred: the collection only contains the preferred nets; equivalent nets are omitted\n"
"    oacNetIterNotImplicit: the collection contains explicitly created nets\n"
"    oacInvalidModuleNetIterFlags\n"
;

static PyObject*
oaModule_getNets(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaModNet_oaModule* result= new oaCollection_oaModNet_oaModule(data.DataCall()->getNets());
            return PyoaCollection_oaModNet_oaModule_FromoaCollection_oaModNet_oaModule(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaModNet_oaModule* result= new oaCollection_oaModNet_oaModule(data.DataCall()->getNets(p1.Data()));
            return PyoaCollection_oaModNet_oaModule_FromoaCollection_oaModNet_oaModule(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModule, function: getNets, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getNetsIter_doc[] = 
"Class: oaModule, Function: getNetsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaModNet getNetsIter() const\n"
"    Signature: getNetsIter|simple-oaIter_oaModNet|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: oaModule::getNets\n"
"    This function returns a collection of nets in this module. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    This specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacNetIterAll: the collection contains all nets\n"
"    oacNetIterSingleBit: the collection contains single-bit nets\n"
"    oacNetIterBundle: the collection contains all the bundleNets in the module\n"
"    oacNetIterPreferred: the collection only contains the preferred nets; equivalent nets are omitted\n"
"    oacNetIterNotImplicit: the collection contains explicitly created nets\n"
"    oacInvalidModuleNetIterFlags\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaModNet getNetsIter(oaUInt4 filterFlags) const\n"
"    Signature: getNetsIter|simple-oaIter_oaModNet|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: oaModule::getNets\n"
"    This function returns a collection of nets in this module. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    This specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacNetIterAll: the collection contains all nets\n"
"    oacNetIterSingleBit: the collection contains single-bit nets\n"
"    oacNetIterBundle: the collection contains all the bundleNets in the module\n"
"    oacNetIterPreferred: the collection only contains the preferred nets; equivalent nets are omitted\n"
"    oacNetIterNotImplicit: the collection contains explicitly created nets\n"
"    oacInvalidModuleNetIterFlags\n"
;

static PyObject*
oaModule_getNetsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaModNet* result= new oaIter_oaModNet(data.DataCall()->getNets());
            return PyoaIter_oaModNet_FromoaIter_oaModNet(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaModNet* result= new oaIter_oaModNet(data.DataCall()->getNets(p1.Data()));
            return PyoaIter_oaModNet_FromoaIter_oaModNet(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModule, function: getNetsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getOccurrences_doc[] = 
"Class: oaModule, Function: getOccurrences\n"
"  Paramegers: (oaOccurrence)\n"
"    Calls: oaCollection_oaOccurrence_oaModule getOccurrences(const oaOccurrence* top) const\n"
"    Signature: getOccurrences|simple-oaCollection_oaOccurrence_oaModule|cptr-oaOccurrence,\n"
"    This function returns a collection of all the occurrences of this module in the design hierarchy under the specified top occurrence. It is an error if the top occurrence specified is not in the same design as the module.\n"
"    Note: The resulting collection will be empty unless the occurrence hierarchy under the specified top occurrence has been expanded in the current session. For more information see oaOccInst::getMasterOccurrence .\n"
;

static PyObject*
oaModule_getOccurrences(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaOccurrence p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccurrence_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaCollection_oaOccurrence_oaModule* result= new oaCollection_oaOccurrence_oaModule(data.DataCall()->getOccurrences(p1.Data()));
        return PyoaCollection_oaOccurrence_oaModule_FromoaCollection_oaOccurrence_oaModule(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getOccurrencesIter_doc[] = 
"Class: oaModule, Function: getOccurrencesIter\n"
"  Paramegers: (oaOccurrence)\n"
"    Calls: oaIter_oaOccurrence getOccurrencesIter(const oaOccurrence* top) const\n"
"    Signature: getOccurrencesIter|simple-oaIter_oaOccurrence|cptr-oaOccurrence,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of all the occurrences of this module in the design hierarchy under the specified top occurrence. It is an error if the top occurrence specified is not in the same design as the module.\n"
"    Note: The resulting collection will be empty unless the occurrence hierarchy under the specified top occurrence has been expanded in the current session. For more information see oaOccInst::getMasterOccurrence .\n"
;

static PyObject*
oaModule_getOccurrencesIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaOccurrence p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccurrence_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaIter_oaOccurrence* result= new oaIter_oaOccurrence(data.DataCall()->getOccurrences(p1.Data()));
        return PyoaIter_oaOccurrence_FromoaIter_oaOccurrence(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getOrig_doc[] = 
"Class: oaModule, Function: getOrig\n"
"  Paramegers: (oaScalarName,oaScalarName,oaScalarName,oaScalarName)\n"
"    Calls: void getOrig(oaScalarName& name,oaScalarName& libName,oaScalarName& cellName,oaScalarName& viewName) const\n"
"    Signature: getOrig|void-void|ref-oaScalarName,ref-oaScalarName,ref-oaScalarName,ref-oaScalarName,\n"
"    BrowseData: 0,oaScalarName,oaScalarName,oaScalarName,oaScalarName\n"
"    oaModule::getOrig\n"
"    This function returns the name of the original module and the library, cell, and view names of the design containing the original module. An exception is thrown if this module is not derived from another module.\n"
"    name\n"
"    The name of the original module\n"
"    libName\n"
"    The library name of the design containing the original module\n"
"    cellName\n"
"    The cell name of the design containing the original module\n"
"    viewName\n"
"    The view name of the design containing the original module\n"
"    oacModuleNotDerived\n"
;

static PyObject*
oaModule_getOrig(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaScalarName p1;
    PyParamoaScalarName p2;
    PyParamoaScalarName p3;
    PyParamoaScalarName p4;
    if (PyArg_ParseTuple(args,"O&O&O&O&",
          &PyoaScalarName_Convert,&p1,
          &PyoaScalarName_Convert,&p2,
          &PyoaScalarName_Convert,&p3,
          &PyoaScalarName_Convert,&p4)) {
        data.DataCall()->getOrig(p1.Data(),p2.Data(),p3.Data(),p4.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getTerms_doc[] = 
"Class: oaModule, Function: getTerms\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaModTerm_oaModule getTerms() const\n"
"    Signature: getTerms|simple-oaCollection_oaModTerm_oaModule|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns a collection of terms in this module. The filter flag bits can be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacTermIterAll: the collection contains all terminals\n"
"    oacTermIterSingleBit: the collection contains single-bit terminals\n"
"    oacTermIterBundle: the collection contains all the bundleTerms in the module\n"
"    oacTermIterNotImplicit: the collection contains explicitly created terminals\n"
"    oacInvalidModuleTermIterFlags\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaModTerm_oaModule getTerms(oaUInt4 filterFlags) const\n"
"    Signature: getTerms|simple-oaCollection_oaModTerm_oaModule|simple-oaUInt4,\n"
"    This function returns a collection of terms in this module. The filter flag bits can be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacTermIterAll: the collection contains all terminals\n"
"    oacTermIterSingleBit: the collection contains single-bit terminals\n"
"    oacTermIterBundle: the collection contains all the bundleTerms in the module\n"
"    oacTermIterNotImplicit: the collection contains explicitly created terminals\n"
"    oacInvalidModuleTermIterFlags\n"
;

static PyObject*
oaModule_getTerms(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaModTerm_oaModule* result= new oaCollection_oaModTerm_oaModule(data.DataCall()->getTerms());
            return PyoaCollection_oaModTerm_oaModule_FromoaCollection_oaModTerm_oaModule(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaModTerm_oaModule* result= new oaCollection_oaModTerm_oaModule(data.DataCall()->getTerms(p1.Data()));
            return PyoaCollection_oaModTerm_oaModule_FromoaCollection_oaModTerm_oaModule(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModule, function: getTerms, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getTermsByPosition_doc[] = 
"Class: oaModule, Function: getTermsByPosition\n"
"  Paramegers: (oaModTermArray)\n"
"    Calls: void getTermsByPosition(oaModTermArray& array) const\n"
"    Signature: getTermsByPosition|void-void|ref-oaModTermArray,\n"
"    BrowseData: 0,oaModTermArray\n"
"    This function retrieves the terminals in this module that have been assigned a position and returns them in the specified oaModTermArray . A position in the array may be NULL to reflect that there is no terminal assigned to that position. The position of a terminal in the array reflects the position assigned to the terminal.\n"
;

static PyObject*
oaModule_getTermsByPosition(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaModTermArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaModTermArray_Convert,&p1)) {
        data.DataCall()->getTermsByPosition(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getTermsIter_doc[] = 
"Class: oaModule, Function: getTermsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaModTerm getTermsIter() const\n"
"    Signature: getTermsIter|simple-oaIter_oaModTerm|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of terms in this module. The filter flag bits can be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacTermIterAll: the collection contains all terminals\n"
"    oacTermIterSingleBit: the collection contains single-bit terminals\n"
"    oacTermIterBundle: the collection contains all the bundleTerms in the module\n"
"    oacTermIterNotImplicit: the collection contains explicitly created terminals\n"
"    oacInvalidModuleTermIterFlags\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaModTerm getTermsIter(oaUInt4 filterFlags) const\n"
"    Signature: getTermsIter|simple-oaIter_oaModTerm|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of terms in this module. The filter flag bits can be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bit flags are defined as follows:\n"
"    oacTermIterAll: the collection contains all terminals\n"
"    oacTermIterSingleBit: the collection contains single-bit terminals\n"
"    oacTermIterBundle: the collection contains all the bundleTerms in the module\n"
"    oacTermIterNotImplicit: the collection contains explicitly created terminals\n"
"    oacInvalidModuleTermIterFlags\n"
;

static PyObject*
oaModule_getTermsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaModTerm* result= new oaIter_oaModTerm(data.DataCall()->getTerms());
            return PyoaIter_oaModTerm_FromoaIter_oaModTerm(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaModTerm* result= new oaIter_oaModTerm(data.DataCall()->getTerms(p1.Data()));
            return PyoaIter_oaModTerm_FromoaIter_oaModTerm(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModule, function: getTermsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getVectorInstDefs_doc[] = 
"Class: oaModule, Function: getVectorInstDefs\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaModVectorInstDef_oaModule getVectorInstDefs() const\n"
"    Signature: getVectorInstDefs|simple-oaCollection_oaModVectorInstDef_oaModule|\n"
"    BrowseData: 1\n"
"    This function returns a collection of vectorInstDefs in this module.\n"
;

static PyObject*
oaModule_getVectorInstDefs(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaModVectorInstDef_oaModule* result= new oaCollection_oaModVectorInstDef_oaModule(data.DataCall()->getVectorInstDefs());
        return PyoaCollection_oaModVectorInstDef_oaModule_FromoaCollection_oaModVectorInstDef_oaModule(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_getVectorInstDefsIter_doc[] = 
"Class: oaModule, Function: getVectorInstDefsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaModVectorInstDef getVectorInstDefsIter() const\n"
"    Signature: getVectorInstDefsIter|simple-oaIter_oaModVectorInstDef|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of vectorInstDefs in this module.\n"
;

static PyObject*
oaModule_getVectorInstDefsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaModVectorInstDef* result= new oaIter_oaModVectorInstDef(data.DataCall()->getVectorInstDefs());
        return PyoaIter_oaModVectorInstDef_FromoaIter_oaModVectorInstDef(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_hasDefaultConstraintGroup_doc[] = 
"Class: oaModule, Function: hasDefaultConstraintGroup\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean hasDefaultConstraintGroup() const\n"
"    Signature: hasDefaultConstraintGroup|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether there is a default constraint group for this module.\n"
;

static PyObject*
oaModule_hasDefaultConstraintGroup(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->hasDefaultConstraintGroup());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_isClone_doc[] = 
"Class: oaModule, Function: isClone\n"
"  Paramegers: (oaModule)\n"
"    Calls: oaBoolean isClone(oaModule* module) const\n"
"    Signature: isClone|simple-oaBoolean|ptr-oaModule,\n"
"    This function returns true if this module originated from the specified module (via a detach, uniquify, or embed operation), and neither this module nor the specified module has been changed since that operation. Otherwise it returns false.\n"
"    It is an error if the current module did not originate from the specified module.\n"
"    oacModuleNotDerived\n"
"    oacModuleNotDerivedFromModule\n"
;

static PyObject*
oaModule_isClone(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaModule p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaModule_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->isClone(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_isDerived_doc[] = 
"Class: oaModule, Function: isDerived\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isDerived() const\n"
"    Signature: isDerived|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function indicates whether this module was created with a uniquify call on another module in the same design.\n"
;

static PyObject*
oaModule_isDerived(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isDerived());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_isEmbedded_doc[] = 
"Class: oaModule, Function: isEmbedded\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isEmbedded() const\n"
"    Signature: isEmbedded|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function indicates whether this module was created by an embed() call that copied it from another design into its current database.\n"
;

static PyObject*
oaModule_isEmbedded(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isEmbedded());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_isOrigModified_doc[] = 
"Class: oaModule, Function: isOrigModified\n"
"  Paramegers: (oaModule)\n"
"    Calls: oaBoolean isOrigModified(oaModule* module) const\n"
"    Signature: isOrigModified|simple-oaBoolean|ptr-oaModule,\n"
"    This function returns true if this module was derived from the specified module, and the specified module has been changed since that derivation, otherwise it returns false. It is an error if the current module was not derived from the specified module.\n"
"    oacModuleNotDerived\n"
"    oacModuleNotDerivedFromModule\n"
;

static PyObject*
oaModule_isOrigModified(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaModule p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaModule_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->isOrigModified(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_isVariant_doc[] = 
"Class: oaModule, Function: isVariant\n"
"  Paramegers: (oaModule)\n"
"    Calls: oaBoolean isVariant(oaModule* module) const\n"
"    Signature: isVariant|simple-oaBoolean|ptr-oaModule,\n"
"    This function returns true if this module originated from the specified module (via a detach, uniquify, or embed operation), and this module has been changed since that operation. Otherwise it returns false.\n"
"    It is an error if the current module did not originate from the specified module.\n"
"    oacModuleNotDerived\n"
"    oacModuleNotDerivedFromModule\n"
;

static PyObject*
oaModule_isVariant(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaModuleObject* self=(PyoaModuleObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaModule p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaModule_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (data.DataCall()->isVariant(p1.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_isNull_doc[] =
"Class: oaModule, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaModule_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaModule data;
    int convert_status=PyoaModule_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaModule_assign_doc[] = 
"Class: oaModule, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaModule_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaModule data;
  int convert_status=PyoaModule_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaModule p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaModule_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaModule_methodlist[] = {
    {"destroy",(PyCFunction)oaModule_destroy,METH_VARARGS,oaModule_destroy_doc},
    {"detach",(PyCFunction)oaModule_detach,METH_VARARGS,oaModule_detach_doc},
    {"getAssignments",(PyCFunction)oaModule_getAssignments,METH_VARARGS,oaModule_getAssignments_doc},
    {"getAssignmentsIter",(PyCFunction)oaModule_getAssignmentsIter,METH_VARARGS,oaModule_getAssignmentsIter_doc},
    {"getBlock",(PyCFunction)oaModule_getBlock,METH_VARARGS,oaModule_getBlock_doc},
    {"getBusNetDefs",(PyCFunction)oaModule_getBusNetDefs,METH_VARARGS,oaModule_getBusNetDefs_doc},
    {"getBusNetDefsIter",(PyCFunction)oaModule_getBusNetDefsIter,METH_VARARGS,oaModule_getBusNetDefsIter_doc},
    {"getBusTermDefs",(PyCFunction)oaModule_getBusTermDefs,METH_VARARGS,oaModule_getBusTermDefs_doc},
    {"getBusTermDefsIter",(PyCFunction)oaModule_getBusTermDefsIter,METH_VARARGS,oaModule_getBusTermDefsIter_doc},
    {"getConnectDefs",(PyCFunction)oaModule_getConnectDefs,METH_VARARGS,oaModule_getConnectDefs_doc},
    {"getConnectDefsIter",(PyCFunction)oaModule_getConnectDefsIter,METH_VARARGS,oaModule_getConnectDefsIter_doc},
    {"getDefaultConstraintGroup",(PyCFunction)oaModule_getDefaultConstraintGroup,METH_VARARGS,oaModule_getDefaultConstraintGroup_doc},
    {"getInstTerms",(PyCFunction)oaModule_getInstTerms,METH_VARARGS,oaModule_getInstTerms_doc},
    {"getInstTermsIter",(PyCFunction)oaModule_getInstTermsIter,METH_VARARGS,oaModule_getInstTermsIter_doc},
    {"getInsts",(PyCFunction)oaModule_getInsts,METH_VARARGS,oaModule_getInsts_doc},
    {"getInstsIter",(PyCFunction)oaModule_getInstsIter,METH_VARARGS,oaModule_getInstsIter_doc},
    {"getModuleInstHeaders",(PyCFunction)oaModule_getModuleInstHeaders,METH_VARARGS,oaModule_getModuleInstHeaders_doc},
    {"getModuleInstHeadersIter",(PyCFunction)oaModule_getModuleInstHeadersIter,METH_VARARGS,oaModule_getModuleInstHeadersIter_doc},
    {"getName",(PyCFunction)oaModule_getName,METH_VARARGS,oaModule_getName_doc},
    {"getNets",(PyCFunction)oaModule_getNets,METH_VARARGS,oaModule_getNets_doc},
    {"getNetsIter",(PyCFunction)oaModule_getNetsIter,METH_VARARGS,oaModule_getNetsIter_doc},
    {"getOccurrences",(PyCFunction)oaModule_getOccurrences,METH_VARARGS,oaModule_getOccurrences_doc},
    {"getOccurrencesIter",(PyCFunction)oaModule_getOccurrencesIter,METH_VARARGS,oaModule_getOccurrencesIter_doc},
    {"getOrig",(PyCFunction)oaModule_getOrig,METH_VARARGS,oaModule_getOrig_doc},
    {"getTerms",(PyCFunction)oaModule_getTerms,METH_VARARGS,oaModule_getTerms_doc},
    {"getTermsByPosition",(PyCFunction)oaModule_getTermsByPosition,METH_VARARGS,oaModule_getTermsByPosition_doc},
    {"getTermsIter",(PyCFunction)oaModule_getTermsIter,METH_VARARGS,oaModule_getTermsIter_doc},
    {"getVectorInstDefs",(PyCFunction)oaModule_getVectorInstDefs,METH_VARARGS,oaModule_getVectorInstDefs_doc},
    {"getVectorInstDefsIter",(PyCFunction)oaModule_getVectorInstDefsIter,METH_VARARGS,oaModule_getVectorInstDefsIter_doc},
    {"hasDefaultConstraintGroup",(PyCFunction)oaModule_hasDefaultConstraintGroup,METH_VARARGS,oaModule_hasDefaultConstraintGroup_doc},
    {"isClone",(PyCFunction)oaModule_isClone,METH_VARARGS,oaModule_isClone_doc},
    {"isDerived",(PyCFunction)oaModule_isDerived,METH_VARARGS,oaModule_isDerived_doc},
    {"isEmbedded",(PyCFunction)oaModule_isEmbedded,METH_VARARGS,oaModule_isEmbedded_doc},
    {"isOrigModified",(PyCFunction)oaModule_isOrigModified,METH_VARARGS,oaModule_isOrigModified_doc},
    {"isVariant",(PyCFunction)oaModule_isVariant,METH_VARARGS,oaModule_isVariant_doc},
    {"isNull",(PyCFunction)oaModule_tp_isNull,METH_VARARGS,oaModule_isNull_doc},
    {"assign",(PyCFunction)oaModule_tp_assign,METH_VARARGS,oaModule_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModule_doc[] = 
"Class: oaModule\n"
"  The oaModule class represents a level of hierarchy in the module domain of a design. The module domain is used to represent the logical hierarchy that may have several levels of hierarchy for each level in the block hierarchy.\n"
"  OpenAccess will maintain the correspondence between the module hierarchy and the block hierarchy for all module objects that are underneath a design's top module. There are zero or one top modules in a design.\n"
"  A module may be created directly through the oaModule API, by embedding the top module from a foreign design into a design, and through uniquification.\n"
"  The oaModule class can be observed by deriving from\n"
"  See Understanding EMH in the Programmers Guide for more information about the module domain.\n"
"Constructors:\n"
"  Paramegers: (oaModule)\n"
"    Calls: (const oaModule&)\n"
"    Signature: oaModule||cref-oaModule,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaModule_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaModule",
    sizeof(PyoaModuleObject),
    0,
    (destructor)oaModule_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaModule_tp_compare,	/* tp_compare */
    (reprfunc)oaModule_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaModule_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaModule_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaModObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaModule_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaModule_static_create_doc[] = 
"Class: oaModule, Function: create\n"
"  Paramegers: (oaDesign,oaScalarName)\n"
"    Calls: oaModule* create(const oaDesign* design,const oaScalarName& name)\n"
"    Signature: create|ptr-oaModule|cptr-oaDesign,cref-oaScalarName,\n"
"    oaModule::create\n"
"    This function creates a module in the given design with the specified name.\n"
"    design\n"
"    The design in which to create the module\n"
"    name\n"
"    The name of the module\n"
"    oacModuleExists\n"
"    oacInvalidDesign\n"
"  Paramegers: (oaDesign)\n"
"    Calls: oaModule* create(const oaDesign* design)\n"
"    Signature: create|ptr-oaModule|cptr-oaDesign,\n"
"    This function creates a module in the given design. The name of the module is automatically generated.\n"
"    design\n"
"    The design in which to create the module\n"
;

static PyObject*
oaModule_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaDesign,oaScalarName)
    {
        PyParamoaDesign p1;
        PyParamoaScalarName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaDesign_Convert,&p1,
              &PyoaScalarName_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModulep result= (oaModule::create(p1.Data(),p2.Data()));
            return PyoaModule_FromoaModule(result);
        }
    }
    PyErr_Clear();
    // Case: (oaDesign)
    {
        PyParamoaDesign p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaDesign_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaModulep result= (oaModule::create(p1.Data()));
            return PyoaModule_FromoaModule(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaModule, function: create, Choices are:\n"
        "    (oaDesign,oaScalarName)\n"
        "    (oaDesign)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_static_embed_doc[] = 
"Class: oaModule, Function: embed\n"
"  Paramegers: (oaDesign,oaDesign)\n"
"    Calls: oaModule* embed(oaDesign* design,const oaDesign* master)\n"
"    Signature: embed|ptr-oaModule|ptr-oaDesign,cptr-oaDesign,\n"
"    oaModule::embed\n"
"    This function takes the module hierarchy starting at the top module of the master design and copies it into the design specified by the first argument. The master design is unchanged, but it will no longer be referenced in hierarchies underneath the destination design.\n"
"    Any oaModDesignInst of the master in the destination design will be converted to an oaModModuleInst after the embed. The top module from the master design will not be set as top in the destination design. If desired, the caller should use oaDesign::setTopModule() after the embed.\n"
"    An exception is thrown if the master design does not exist, or it is the same as the target design, or it does not contain any module, or if any of the modules to be embedded already exist in the destination design. When any of these errors occur, the destination will be unchanged.\n"
"    oacInvalidModuleEmbedMaster\n"
;

static PyObject*
oaModule_static_embed(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign p1;
    PyParamoaDesign p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaDesign_Convert,&p1,
          &PyoaDesign_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!PyValidateDbObject(p2.Data(),2)) return NULL;
        oaModulep result= (oaModule::embed(p1.Data(),p2.Data()));
        return PyoaModule_FromoaModule(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaModule_static_find_doc[] = 
"Class: oaModule, Function: find\n"
"  Paramegers: (oaDesign,oaScalarName)\n"
"    Calls: oaModule* find(const oaDesign* design,const oaScalarName& name)\n"
"    Signature: find|ptr-oaModule|cptr-oaDesign,cref-oaScalarName,\n"
"    This function searches the given design for a module that matches the specified name. If found, a pointer to the oaModule is returned, otherwise NULL is returned.\n"
"    design\n"
"    The design in which to search for the module\n"
"    name\n"
"    The name of the module to search\n"
;

static PyObject*
oaModule_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaDesign p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaDesign_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaModulep result= (oaModule::find(p1.Data(),p2.Data()));
        return PyoaModule_FromoaModule(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaModule_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaModule_static_create,METH_VARARGS,oaModule_static_create_doc},
    {"static_embed",(PyCFunction)oaModule_static_embed,METH_VARARGS,oaModule_static_embed_doc},
    {"static_find",(PyCFunction)oaModule_static_find,METH_VARARGS,oaModule_static_find_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaModule_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaModule_Type)<0) {
      printf("** PyType_Ready failed for: oaModule\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaModule",
           (PyObject*)(&PyoaModule_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaModule\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaModule_Type.tp_dict;
    for(method=oaModule_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModuleInstHeaderModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaModuleInstHeaderModTypeEnum_Convert(PyObject* ob,PyParamoaModuleInstHeaderModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacBindModuleInstHeaderModType")==0) { result->SetData(oacBindModuleInstHeaderModType); return 1;}
        if (strcasecmp(str,"oacUnbindModuleInstHeaderModType")==0) { result->SetData(oacUnbindModuleInstHeaderModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaModuleInstHeaderModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModuleInstHeaderModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaModuleInstHeaderModTypeEnum_FromoaModuleInstHeaderModTypeEnum(oaModuleInstHeaderModTypeEnum ob)
{
    if (ob==oacBindModuleInstHeaderModType) return PyString_FromString("oacBindModuleInstHeaderModType");
    if (ob==oacUnbindModuleInstHeaderModType) return PyString_FromString("oacUnbindModuleInstHeaderModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaModuleInstHeaderModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaModuleInstHeaderModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaModuleInstHeaderModTypeEnum_FromoaModuleInstHeaderModTypeEnum(oaModuleInstHeaderModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaModuleInstHeaderModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaModuleInstHeaderModTypeEnum_doc[] =
"Type convert function for enum: oaModuleInstHeaderModTypeEnum";
                               
static PyMethodDef PyoaModuleInstHeaderModTypeEnum_method =
  {"oaModuleInstHeaderModTypeEnum",(PyCFunction)PyoaModuleInstHeaderModTypeEnum_TypeFunction,METH_VARARGS,oaModuleInstHeaderModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaModuleInstHeaderModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacBindModuleInstHeaderModType");
    PyDict_SetItemString(mod_dict,"oacBindModuleInstHeaderModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacUnbindModuleInstHeaderModType");
    PyDict_SetItemString(mod_dict,"oacUnbindModuleInstHeaderModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaModuleInstHeaderModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaModuleInstHeaderModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaModuleInstHeaderModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaModuleModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaModuleModTypeEnum_Convert(PyObject* ob,PyParamoaModuleModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacSetDefaultConstraintGroupModuleModType")==0) { result->SetData(oacSetDefaultConstraintGroupModuleModType); return 1;}
        if (strcasecmp(str,"oacSetTopModuleModType")==0) { result->SetData(oacSetTopModuleModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaModuleModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaModuleModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaModuleModTypeEnum_FromoaModuleModTypeEnum(oaModuleModTypeEnum ob)
{
    if (ob==oacSetDefaultConstraintGroupModuleModType) return PyString_FromString("oacSetDefaultConstraintGroupModuleModType");
    if (ob==oacSetTopModuleModType) return PyString_FromString("oacSetTopModuleModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaModuleModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaModuleModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaModuleModTypeEnum_FromoaModuleModTypeEnum(oaModuleModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaModuleModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaModuleModTypeEnum_doc[] =
"Type convert function for enum: oaModuleModTypeEnum";
                               
static PyMethodDef PyoaModuleModTypeEnum_method =
  {"oaModuleModTypeEnum",(PyCFunction)PyoaModuleModTypeEnum_TypeFunction,METH_VARARGS,oaModuleModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaModuleModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacSetDefaultConstraintGroupModuleModType");
    PyDict_SetItemString(mod_dict,"oacSetDefaultConstraintGroupModuleModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetTopModuleModType");
    PyDict_SetItemString(mod_dict,"oacSetTopModuleModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaModuleModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaModuleModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaModuleModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaMutualInductor
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaMutualInductor_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaMutualInductor_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaMutualInductorObject* self = (PyoaMutualInductorObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaMutualInductor)
    {
        PyParamoaMutualInductor p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaMutualInductor_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaMutualInductor, Choices are:\n"
        "    (oaMutualInductor)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaMutualInductor_tp_dealloc(PyoaMutualInductorObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaMutualInductor_tp_repr(PyObject *ob)
{
    PyParamoaMutualInductor value;
    int convert_status=PyoaMutualInductor_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[38];
    sprintf(buffer,"<oaMutualInductor::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaMutualInductor_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaMutualInductor v1;
    PyParamoaMutualInductor v2;
    int convert_status1=PyoaMutualInductor_Convert(ob1,&v1);
    int convert_status2=PyoaMutualInductor_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaMutualInductor_Convert(PyObject* ob,PyParamoaMutualInductor* result)
{
    if (ob == NULL) return 1;
    if (PyoaMutualInductor_Check(ob)) {
        result->SetData( (oaMutualInductor**) ((PyoaMutualInductorObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaMutualInductor Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaMutualInductor_FromoaMutualInductor(oaMutualInductor** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaMutualInductor* data=*value;
        PyObject* bself = PyoaMutualInductor_Type.tp_alloc(&PyoaMutualInductor_Type,0);
        if (bself == NULL) return bself;
        PyoaMutualInductorObject* self = (PyoaMutualInductorObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaMutualInductor_FromoaMutualInductor(oaMutualInductor* data)
{
    if (data) {
       PyObject* bself = PyoaMutualInductor_Type.tp_alloc(&PyoaMutualInductor_Type,0);
       if (bself == NULL) return bself;
       PyoaMutualInductorObject* self = (PyoaMutualInductorObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaMutualInductor_getInductor_doc[] = 
"Class: oaMutualInductor, Function: getInductor\n"
"  Paramegers: (oaEndpointType)\n"
"    Calls: oaInductor* getInductor(oaEndpointType endpoint) const\n"
"    Signature: getInductor|ptr-oaInductor|simple-oaEndpointType,\n"
"    This function returns the inductor connected to the specified endpoint of this mutual inductor. If this mutual inductor couples to an inductor within another parasitic network, NULL is returned for the \"to\" endpoint.\n"
"    endpoint\n"
"    The endpoint value\n"
;

static PyObject*
oaMutualInductor_getInductor(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaMutualInductor data;
    int convert_status=PyoaMutualInductor_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaMutualInductorObject* self=(PyoaMutualInductorObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaEndpointType p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaEndpointType_Convert,&p1)) {
        oaInductorp result= (data.DataCall()->getInductor(p1.Data()));
        return PyoaInductor_FromoaInductor(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaMutualInductor_getOtherInductor_doc[] = 
"Class: oaMutualInductor, Function: getOtherInductor\n"
"  Paramegers: (oaInductor)\n"
"    Calls: oaInductor* getOtherInductor(oaInductor* inductor) const\n"
"    Signature: getOtherInductor|ptr-oaInductor|ptr-oaInductor,\n"
"    This function returns the inductor connected to the other endpoint of this device (the endpoint that is not connected to inductor ). When inductor is the from endpoint of this mutual inductor and this mutual inductor couples to an inductor within another parasitic network, NULL is returned.\n"
"    inductor\n"
"    The inductor connected to the other endpoint of this device\n"
"  Paramegers: (oaDesignObject,oaUInt4)\n"
"    Calls: void getOtherInductor(oaDesignObject*& otherNet,oaUInt4& otherInductorId) const\n"
"    Signature: getOtherInductor|void-void|ptrref-oaDesignObject,ref-oaUInt4,\n"
"    BrowseData: 0,oaDesignObject,oaUInt4\n"
"    This function returns information about the inductor connected to the \"to\" endpoint of this device. The parasitic network for otherNet does not have to exist or be in memory at the time that this function is called. When this is a local mutual inductor, the otherInductorId is set to oacNullIndex if the other inductor does not have an ID.\n"
"    otherNet\n"
"    The other network from which to return information\n"
"    otherInductorId\n"
"    A unique ID for the inductor in the other parasitic network\n"
;

static PyObject*
oaMutualInductor_getOtherInductor(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaMutualInductor data;
    int convert_status=PyoaMutualInductor_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaMutualInductorObject* self=(PyoaMutualInductorObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaInductor)
    {
        PyParamoaInductor p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaInductor_Convert,&p1)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaInductorp result= (data.DataCall()->getOtherInductor(p1.Data()));
            return PyoaInductor_FromoaInductor(result);
        }
    }
    PyErr_Clear();
    // Case: (oaDesignObject,oaUInt4)
    {
        PyParamoaDesignObject p1;
        PyParamoaUInt4 p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaDesignObject_Convert,&p1,
              &PyoaUInt4_Convert,&p2)) {
            data.DataCall()->getOtherInductor(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaMutualInductor, function: getOtherInductor, Choices are:\n"
        "    (oaInductor)\n"
        "    (oaDesignObject,oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaMutualInductor_getValue_doc[] = 
"Class: oaMutualInductor, Function: getValue\n"
"  Paramegers: (oaAnalysisPoint)\n"
"    Calls: oaFloat getValue(const oaAnalysisPoint* ap) const\n"
"    Signature: getValue|simple-oaFloat|cptr-oaAnalysisPoint,\n"
"    This function returns the mutual inductance value of this device for the specified analysis point.\n"
"    ap\n"
"    The analysis point for which to return the mutual inductance\n"
;

static PyObject*
oaMutualInductor_getValue(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaMutualInductor data;
    int convert_status=PyoaMutualInductor_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaMutualInductorObject* self=(PyoaMutualInductorObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaAnalysisPoint p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaAnalysisPoint_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaFloat result= (data.DataCall()->getValue(p1.Data()));
        return PyoaFloat_FromoaFloat(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaMutualInductor_isLocal_doc[] = 
"Class: oaMutualInductor, Function: isLocal\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isLocal() const\n"
"    Signature: isLocal|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns true if this mutual inductor connects two inductors within the same parasitic network.\n"
;

static PyObject*
oaMutualInductor_isLocal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaMutualInductor data;
    int convert_status=PyoaMutualInductor_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaMutualInductorObject* self=(PyoaMutualInductorObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isLocal());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaMutualInductor_setValue_doc[] = 
"Class: oaMutualInductor, Function: setValue\n"
"  Paramegers: (oaAnalysisPoint,oaFloat)\n"
"    Calls: void setValue(const oaAnalysisPoint* ap,oaFloat value)\n"
"    Signature: setValue|void-void|cptr-oaAnalysisPoint,simple-oaFloat,\n"
"    This function sets the mutual inductance value of this device for the specified analysis point.\n"
"    ap\n"
"    The analysis point for which to set the mutual inductance\n"
"    value\n"
"    The inductance value to set\n"
;

static PyObject*
oaMutualInductor_setValue(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaMutualInductor data;
    int convert_status=PyoaMutualInductor_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaMutualInductorObject* self=(PyoaMutualInductorObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaAnalysisPoint p1;
    PyParamoaFloat p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaAnalysisPoint_Convert,&p1,
          &PyoaFloat_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->setValue(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaMutualInductor_isNull_doc[] =
"Class: oaMutualInductor, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaMutualInductor_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaMutualInductor data;
    int convert_status=PyoaMutualInductor_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaMutualInductor_assign_doc[] = 
"Class: oaMutualInductor, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaMutualInductor_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaMutualInductor data;
  int convert_status=PyoaMutualInductor_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaMutualInductor p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaMutualInductor_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaMutualInductor_methodlist[] = {
    {"getInductor",(PyCFunction)oaMutualInductor_getInductor,METH_VARARGS,oaMutualInductor_getInductor_doc},
    {"getOtherInductor",(PyCFunction)oaMutualInductor_getOtherInductor,METH_VARARGS,oaMutualInductor_getOtherInductor_doc},
    {"getValue",(PyCFunction)oaMutualInductor_getValue,METH_VARARGS,oaMutualInductor_getValue_doc},
    {"isLocal",(PyCFunction)oaMutualInductor_isLocal,METH_VARARGS,oaMutualInductor_isLocal_doc},
    {"setValue",(PyCFunction)oaMutualInductor_setValue,METH_VARARGS,oaMutualInductor_setValue_doc},
    {"isNull",(PyCFunction)oaMutualInductor_tp_isNull,METH_VARARGS,oaMutualInductor_isNull_doc},
    {"assign",(PyCFunction)oaMutualInductor_tp_assign,METH_VARARGS,oaMutualInductor_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaMutualInductor_doc[] = 
"Class: oaMutualInductor\n"
"  The oaMutualInductor class represents the mutual inductance between two inductor devices. The two inductors can be within the same parasitic network or within the parasitic networks for two different nets.\n"
"Constructors:\n"
"  Paramegers: (oaMutualInductor)\n"
"    Calls: (const oaMutualInductor&)\n"
"    Signature: oaMutualInductor||cref-oaMutualInductor,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaMutualInductor_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaMutualInductor",
    sizeof(PyoaMutualInductorObject),
    0,
    (destructor)oaMutualInductor_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaMutualInductor_tp_compare,	/* tp_compare */
    (reprfunc)oaMutualInductor_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaMutualInductor_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaMutualInductor_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaDevice_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaMutualInductor_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaMutualInductor_static_create_doc[] = 
"Class: oaMutualInductor, Function: create\n"
"  Paramegers: (oaInductor,oaInductor)\n"
"    Calls: oaMutualInductor* create(oaInductor* fromInductor,oaInductor* toInductor)\n"
"    Signature: create|ptr-oaMutualInductor|ptr-oaInductor,ptr-oaInductor,\n"
"    This function creates a local mutual inductor between the specified pair of inductors. An exception will be thrown if the two inductors are not in the same design. The mutual inductor created does not have an ID associated with it. The hasId() function will return false for these inductors and the getId() function will return an oacInvalidDeviceID value.\n"
"    Mutual inductors can be created between inductors in different partitions of the same root parasitic network, where one of the partitions must be an ancestor of the other. In this case, the mutual inductor device will be created in the lower level partition, and the inductor in the higher level partition must have an id so that it can be found when loading the lower level partition.\n"
"    fromInductor\n"
"    The inductor from which to couple\n"
"    toInductor\n"
"    The inductor to which to couple\n"
"    oacInductorsNotInSameDesign\n"
"    oacInductorsNotInSameNetwork\n"
"    oacInductorsNotInRelatedPartitions\n"
"    oacAncestorInductorWithoutId\n"
"  Paramegers: (oaInductor,oaInductor,oaUInt4)\n"
"    Calls: oaMutualInductor* create(oaInductor* fromInductor,oaInductor* toInductor,oaUInt4 id)\n"
"    Signature: create|ptr-oaMutualInductor|ptr-oaInductor,ptr-oaInductor,simple-oaUInt4,\n"
"    This function creates a local mutual inductor between the specified pair of inductors. An exception will be thrown if the two inductors are not in the same design. An explicit unique mutual inductor ID id is required to be specified. An exception will be thrown if the id is the reserved oacInvalidDeviceID value or if a mutual inductor with the specified id value already exists. The hasId() function will return true for mutual inductors created with this function and the getId() function will return the user-specified id.\n"
"    Mutual inductors can be created between inductors in different partitions of the same root parasitic network, where one of the partitions must be an ancestor of the other. In this case, the mutual inductor device will be created in the lower level partition, and the inductor in the higher level partition must have an id so that it can be found when loading the lower level partition.\n"
"    fromInductor\n"
"    The inductor from which to couple\n"
"    toInductor\n"
"    The inductor to which to couple\n"
"    id\n"
"    The unique ID value\n"
"    oacInvalidDeviceIdSpecified\n"
"    oacLocalDeviceIdExists\n"
"    oacInductorsNotInSameDesign\n"
"    oacInductorsNotInSameNetwork\n"
"    oacInductorsNotInRelatedPartitions\n"
"    oacAncestorInductorWithoutId\n"
"  Paramegers: (oaInductor,oaDesignObject,oaUInt4,oaUInt4)\n"
"    Calls: oaMutualInductor* create(oaInductor* fromInductor,oaDesignObject* otherNet,oaUInt4 otherInductorId,oaUInt4 id)\n"
"    Signature: create|ptr-oaMutualInductor|ptr-oaInductor,ptr-oaDesignObject,simple-oaUInt4,simple-oaUInt4,\n"
"    This function creates a mutual inductor in fromInductor's parasitic network that couples between fromInductor and an inductor in the parasitic network for another net. The parasitic network for otherNet does not have to exist or be in memory at the time this function is called. The otherInductorId value specifies a unique ID for the inductor in otherNet's parasitic network, and that ID must be specified when the inductor is created.\n"
"    If the inductance is between 2 nets, those nets must be in a single hierarchy domain. Each must be an oaNet , or each must be an oaOccNet .\n"
"    fromInductor\n"
"    The inductor from which to couple\n"
"    otherNet\n"
"    The other network to which to couple\n"
"    otherInductorId\n"
"    A unique ID for the inductor in the other parasitic network\n"
"    id\n"
"    The unique ID value\n"
"    oacCoupledInductorWithoutId\n"
"    oacInvalidNet\n"
"    oacInvalidMutualInductorId\n"
"    oacInductorNetNotInSameDesign\n"
"    oacDeviceNetNotInSameDomain\n"
"    oacNonLocalDeviceIdExists\n"
;

static PyObject*
oaMutualInductor_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaInductor,oaInductor)
    {
        PyParamoaInductor p1;
        PyParamoaInductor p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaInductor_Convert,&p1,
              &PyoaInductor_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaMutualInductorp result= (oaMutualInductor::create(p1.Data(),p2.Data()));
            return PyoaMutualInductor_FromoaMutualInductor(result);
        }
    }
    PyErr_Clear();
    // Case: (oaInductor,oaInductor,oaUInt4)
    {
        PyParamoaInductor p1;
        PyParamoaInductor p2;
        PyParamoaUInt4 p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaInductor_Convert,&p1,
              &PyoaInductor_Convert,&p2,
              &PyoaUInt4_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaMutualInductorp result= (oaMutualInductor::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaMutualInductor_FromoaMutualInductor(result);
        }
    }
    PyErr_Clear();
    // Case: (oaInductor,oaDesignObject,oaUInt4,oaUInt4)
    {
        PyParamoaInductor p1;
        PyParamoaDesignObject p2;
        PyParamoaUInt4 p3;
        PyParamoaUInt4 p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaInductor_Convert,&p1,
              &PyoaDesignObject_Convert,&p2,
              &PyoaUInt4_Convert,&p3,
              &PyoaUInt4_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            if (!PyValidateDbObject(p2.Data(),2)) return NULL;
            oaMutualInductorp result= (oaMutualInductor::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaMutualInductor_FromoaMutualInductor(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaMutualInductor, function: create, Choices are:\n"
        "    (oaInductor,oaInductor)\n"
        "    (oaInductor,oaInductor,oaUInt4)\n"
        "    (oaInductor,oaDesignObject,oaUInt4,oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaMutualInductor_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaMutualInductor_static_create,METH_VARARGS,oaMutualInductor_static_create_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaMutualInductor_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaMutualInductor_Type)<0) {
      printf("** PyType_Ready failed for: oaMutualInductor\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaMutualInductor",
           (PyObject*)(&PyoaMutualInductor_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaMutualInductor\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaMutualInductor_Type.tp_dict;
    for(method=oaMutualInductor_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaName
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaName_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaName_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaNameObject* self = (PyoaNameObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaName();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,[oaChar])
    {
        PyParamoaNameSpace p1;
        PyParamoaChar_Array p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaChar_Array_Convert,&p2)) {
            self->value =  new oaName(p1.Data(),p2.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaName)
    {
        PyParamoaName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaName_Convert,&p1)) {
            self->value =  new oaName(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName)
    {
        PyParamoaSimpleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaSimpleName_Convert,&p1)) {
            self->value =  new oaName(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaBundleName)
    {
        PyParamoaBundleName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBundleName_Convert,&p1)) {
            self->value =  new oaName(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaVectorName)
    {
        PyParamoaVectorName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorName_Convert,&p1)) {
            self->value =  new oaName(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaVectorBitName)
    {
        PyParamoaVectorBitName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorBitName_Convert,&p1)) {
            self->value =  new oaName(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            self->value =  new oaName(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaName, Choices are:\n"
        "    ()\n"
        "    (oaNameSpace,[oaChar])\n"
        "    (oaName)\n"
        "    (oaSimpleName)\n"
        "    (oaBundleName)\n"
        "    (oaVectorName)\n"
        "    (oaVectorBitName)\n"
        "    (oaScalarName)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaName_tp_dealloc(PyoaNameObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaName_tp_repr(PyObject *ob)
{
    PyParamoaName value;
    int convert_status=PyoaName_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    oaString sresult;
    value.DataCall()->get(sresult);

    char addr[28];
    sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
    oaString buffer;
    buffer+=oaString("<oaName::");
    buffer+=oaString(addr);
    buffer+=oaString("::");
    buffer+=oaString(sresult);
    buffer+=oaString(">");
    result=PyString_FromString((char*)(const char*)buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaName_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaName v1;
    PyParamoaName v2;
    int convert_status1=PyoaName_Convert(ob1,&v1);
    int convert_status2=PyoaName_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    if (v1.Data()==v2.Data()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaName_Convert(PyObject* ob,PyParamoaName* result)
{
    if (ob == NULL) return 1;
    if (PyoaName_Check(ob)) {
        result->SetData(  ((PyoaNameObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaName Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaName_FromoaName(oaName* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaName_Type.tp_alloc(&PyoaName_Type,0);
        if (bself == NULL) return bself;
        PyoaNameObject* self = (PyoaNameObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaName_addHierMem_doc[] = 
"Class: oaName, Function: addHierMem\n"
"  Paramegers: (oaNameSpace,[oaChar],oaUInt4)\n"
"    Calls: void addHierMem(const oaNameSpace& nSpace,const oaChar* in,oaUInt4 len)\n"
"    Signature: addHierMem|void-void|cref-oaNameSpace,cptr-oaChar,simple-oaUInt4,\n"
"    This function adds the given string as a member of the hierarchical portion of this name. An exception is thrown if this name is empty.\n"
"    If this name is a bundle name, this function adds the given string as a nameMem to the hierarchical portion of the name for each of the members of this bundle name. For each bundle member, the nameMem is inserted after the existing hierarchical nameMems and before the last nameMem, which represents the local name of the bundle member.\n"
"    The in string must not contain any hierarchy delimiters. Only len characters of in are considered. An exception is thrown if this name is empty.\n"
"    nSpace\n"
"    The nameSpace in which to evaluate the given string\n"
"    in\n"
"    The input string to add to the hierarchy of this name\n"
"    len\n"
"    The length of the specified input string\n"
"    oacInvalidName\n"
"  Paramegers: (oaNameMem)\n"
"    Calls: void addHierMem(const oaNameMem& in)\n"
"    Signature: addHierMem|void-void|cref-oaNameMem,\n"
"    This function adds a hierarchical nameMem to each of the bundle members of this name. For each bundle member, this function inserts a copy of in after the existing nameMems that represent the hierarchical path for the bundle member, and before the last nameMem, which represents the local name. An exception is thrown if this name is empty.\n"
"    in\n"
"    The member to be added\n"
"    oacInvalidName\n"
;

static PyObject*
oaName_addHierMem(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaName data;
    int convert_status=PyoaName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameObject* self=(PyoaNameObject*)ob;

    // Case: (oaNameSpace,[oaChar],oaUInt4)
    {
        PyParamoaNameSpace p1;
        PyParamoaChar_Array p2;
        PyParamoaUInt4 p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaChar_Array_Convert,&p2,
              &PyoaUInt4_Convert,&p3)) {
            data.DataCall()->addHierMem(p1.Data(),p2.Data(),p3.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameMem)
    {
        PyParamoaNameMem p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaNameMem_Convert,&p1)) {
            data.DataCall()->addHierMem(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaName, function: addHierMem, Choices are:\n"
        "    (oaNameSpace,[oaChar],oaUInt4)\n"
        "    (oaNameMem)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaName_addHierPath_doc[] = 
"Class: oaName, Function: addHierPath\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void addHierPath(const oaScalarName& path)\n"
"    Signature: addHierPath|void-void|cref-oaScalarName,\n"
"    This function prepends a hierarchical path to this name. If this name is a bundle name, the hierarchical path is added to each of the members of the bundle. An exception is thrown if this name is empty.\n"
"    path\n"
"    The path to add\n"
"    oacInvalidName\n"
"  Paramegers: (oaVectorBitName)\n"
"    Calls: void addHierPath(const oaVectorBitName& path)\n"
"    Signature: addHierPath|void-void|cref-oaVectorBitName,\n"
"    This function prepends a hierarchical path to this name. If this name is a bundle name, the hierarchical path is added to each of the members of the bundle. An exception is thrown if this name is empty.\n"
"    path\n"
"    The path to add\n"
"    oacInvalidName\n"
;

static PyObject*
oaName_addHierPath(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaName data;
    int convert_status=PyoaName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameObject* self=(PyoaNameObject*)ob;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->addHierPath(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaVectorBitName)
    {
        PyParamoaVectorBitName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorBitName_Convert,&p1)) {
            data.DataCall()->addHierPath(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaName, function: addHierPath, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaVectorBitName)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaName_get_doc[] = 
"Class: oaName, Function: get\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void get(const oaNameSpace& nSpace,oaString& out) const\n"
"    Signature: get|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function fills in out with the oaName, mapped into the specified oaNameSpace .\n"
"    An exception is thrown if the specified nameSpace does not support the type of thus oaName. For information on the names supported in each nameSpace, see Details of OpenAccess Name Spaces .\n"
"    nSpace\n"
"    The nameSpace in which to map this name\n"
"    out\n"
"    The string in which to output the mapped name\n"
"    oacVectorNameInvalid\n"
"    oacBundleNameInvalid\n"
"    oacHierNameInvalid\n"
"    oacIndexedNameInvalid\n"
"  Paramegers: (oaString)\n"
"    Calls: void get(oaString& out) const\n"
"    Signature: get|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function fills the string out with the oaName, mapped into the oaNative nameSpace.\n"
;

static PyObject*
oaName_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaName data;
    int convert_status=PyoaName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameObject* self=(PyoaNameObject*)ob;

    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->get(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            data.DataCall()->get(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaName, function: get, Choices are:\n"
        "    (oaNameSpace,oaString)\n"
        "    (oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaName_getBitName_doc[] = 
"Class: oaName, Function: getBitName\n"
"  Paramegers: (oaNameSpace,oaUInt4,oaString)\n"
"    Calls: void getBitName(const oaNameSpace& nSpace,oaUInt4 bit,oaString& out) const\n"
"    Signature: getBitName|void-void|cref-oaNameSpace,simple-oaUInt4,ref-oaString,\n"
"    This function fills the string out with the bit name of this vector name, mapped into the specified oaNameSpace .\n"
"    oacBitNotInRangeForName\n"
;

static PyObject*
oaName_getBitName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaName data;
    int convert_status=PyoaName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameObject* self=(PyoaNameObject*)ob;

    PyParamoaNameSpace p1;
    PyParamoaUInt4 p2;
    PyParamoaString p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaNameSpace_Convert,&p1,
          &PyoaUInt4_Convert,&p2,
          &PyoaString_Convert,&p3)) {
        data.DataCall()->getBitName(p1.Data(),p2.Data(),p3.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaName_getBundle_doc[] = 
"Class: oaName, Function: getBundle\n"
"  Paramegers: ()\n"
"    Calls: oaBundleName* getBundle() const\n"
"    Signature: getBundle|ptr-oaBundleName|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the bundle name data if this name represents an oaBundleName . If this name does not contain a bundle name, NULL is returned.\n"
;

static PyObject*
oaName_getBundle(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaName data;
    int convert_status=PyoaName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameObject* self=(PyoaNameObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaBundleName* result=(data.DataCall()->getBundle());
        if (result==NULL) {
            Py_INCREF(Py_None);
            return Py_None;
        }
        return PyoaBundleName_FromoaBundleName(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaName_getNumBits_doc[] = 
"Class: oaName, Function: getNumBits\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumBits() const\n"
"    Signature: getNumBits|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of bits this name represents.\n"
;

static PyObject*
oaName_getNumBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaName data;
    int convert_status=PyoaName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameObject* self=(PyoaNameObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumBits());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaName_getScalar_doc[] = 
"Class: oaName, Function: getScalar\n"
"  Paramegers: ()\n"
"    Calls: oaScalarName* getScalar() const\n"
"    Signature: getScalar|ptr-oaScalarName|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the scalar name data if this name represents an oaScalarName . If this name does not contain a scalar name, NULL is returned. The scalar name data returned belongs to the oaName object and should not be destroyed on its own by the application code.\n"
;

static PyObject*
oaName_getScalar(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaName data;
    int convert_status=PyoaName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameObject* self=(PyoaNameObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaScalarName* result=(data.DataCall()->getScalar());
        if (result==NULL) {
            Py_INCREF(Py_None);
            return Py_None;
        }
        return PyoaScalarName_FromoaScalarName(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaName_getType_doc[] = 
"Class: oaName, Function: getType\n"
"  Paramegers: ()\n"
"    Calls: oaNameType getType() const\n"
"    Signature: getType|simple-oaNameType|\n"
"    BrowseData: 1\n"
"    This function returns the type of name that this name contains.\n"
;

static PyObject*
oaName_getType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaName data;
    int convert_status=PyoaName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameObject* self=(PyoaNameObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaNameType* result= new oaNameType(data.DataCall()->getType());
        return PyoaNameType_FromoaNameType(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaName_getVector_doc[] = 
"Class: oaName, Function: getVector\n"
"  Paramegers: ()\n"
"    Calls: oaVectorName* getVector() const\n"
"    Signature: getVector|ptr-oaVectorName|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the vector name data if this name represents an oaVectorName . If this name does not contain a vector name, NULL is returned.\n"
;

static PyObject*
oaName_getVector(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaName data;
    int convert_status=PyoaName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameObject* self=(PyoaNameObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaVectorName* result=(data.DataCall()->getVector());
        if (result==NULL) {
            Py_INCREF(Py_None);
            return Py_None;
        }
        return PyoaVectorName_FromoaVectorName(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaName_getVectorBit_doc[] = 
"Class: oaName, Function: getVectorBit\n"
"  Paramegers: ()\n"
"    Calls: oaVectorBitName* getVectorBit() const\n"
"    Signature: getVectorBit|ptr-oaVectorBitName|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the vector bit name data if this name represents an oaVectorBitName . If this name does contain a vector bit name, NULL is returned.\n"
;

static PyObject*
oaName_getVectorBit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaName data;
    int convert_status=PyoaName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameObject* self=(PyoaNameObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaVectorBitName* result=(data.DataCall()->getVectorBit());
        if (result==NULL) {
            Py_INCREF(Py_None);
            return Py_None;
        }
        return PyoaVectorBitName_FromoaVectorBitName(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaName_init_doc[] = 
"Class: oaName, Function: init\n"
"  Paramegers: (oaNameSpace,[oaChar])\n"
"    Calls: void init(const oaNameSpace& nSpace,const oaChar* in)\n"
"    Signature: init|void-void|cref-oaNameSpace,cptr-oaChar,\n"
"    This function initializes this oaName object by deleting the previous name data, and then re-initializes its value to the string specified by in , evaluated in the specified nameSpace. This allows reuse of the oaName object to improve application performance and capacity.\n"
"    in\n"
"    The input string to evaluate\n"
"    nSpace\n"
"    The nameSpace in which to evaluate the string\n"
"    oacInvalidNameLength\n"
"    oacInvalidNameSyntax\n"
;

static PyObject*
oaName_init(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaName data;
    int convert_status=PyoaName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameObject* self=(PyoaNameObject*)ob;

    PyParamoaNameSpace p1;
    PyParamoaChar_Array p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaNameSpace_Convert,&p1,
          &PyoaChar_Array_Convert,&p2)) {
        data.DataCall()->init(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaName_assign_doc[] = 
"Class: oaName, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaName_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaName data;
  int convert_status=PyoaName_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaName p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaName_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaName_methodlist[] = {
    {"addHierMem",(PyCFunction)oaName_addHierMem,METH_VARARGS,oaName_addHierMem_doc},
    {"addHierPath",(PyCFunction)oaName_addHierPath,METH_VARARGS,oaName_addHierPath_doc},
    {"get",(PyCFunction)oaName_get,METH_VARARGS,oaName_get_doc},
    {"getBitName",(PyCFunction)oaName_getBitName,METH_VARARGS,oaName_getBitName_doc},
    {"getBundle",(PyCFunction)oaName_getBundle,METH_VARARGS,oaName_getBundle_doc},
    {"getNumBits",(PyCFunction)oaName_getNumBits,METH_VARARGS,oaName_getNumBits_doc},
    {"getScalar",(PyCFunction)oaName_getScalar,METH_VARARGS,oaName_getScalar_doc},
    {"getType",(PyCFunction)oaName_getType,METH_VARARGS,oaName_getType_doc},
    {"getVector",(PyCFunction)oaName_getVector,METH_VARARGS,oaName_getVector_doc},
    {"getVectorBit",(PyCFunction)oaName_getVectorBit,METH_VARARGS,oaName_getVectorBit_doc},
    {"init",(PyCFunction)oaName_init,METH_VARARGS,oaName_init_doc},
    {"assign",(PyCFunction)oaName_tp_assign,METH_VARARGS,oaName_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaName_doc[] = 
"Class: oaName\n"
"  Named objects that commonly appear in netlists and other file formats are represented by oaNames in the OpenAccess API. oaNames provide a form of a name that is free from any assumptions about which specific name syntax and rules the name is following. Such rules are incorporated into the oaNameSpace classes that are used whenever a name is transferred out of or into a string.\n"
"  There are several oaName classes: oaName, oaScalarName , oaVectorName , oaVectorBitName , oaSimpleName , and oaBundleName . The specialized forms are present to help the name handling functions in OpenAccess be as efficient as possible and to make some functions in the API more type specific. The oaName class itself can hold any type of name from any of its specializations. The specialized name classes differ in the forms of indexing and grouping of names that they allow. All of the oaName classes are capable of representing hierarchical names.\n"
"  oaNames work in conjunction with the oaNameSpace classes to enable the mapping of names from one nameSpace to another. See the Name Mapping section of the Programmer's Guide for more information about mapping names between different namespaces.\n"
"  Names are somewhat complex objects in order to allow flexible name mapping between different name spaces. They should be used carefully in order to avoid performance issues. In general, when using the oaName classes, it is best to choose the object type with closest match to the name. For example, if an application only uses scalar names, using the oaScalarName object is the most efficient even though using oaName would work also. In addition, name objects should be re-used whenever possible, in order to improve application capacity and performance. oaName member functions such as init() are provided for this purpose.\n"
"  When using the more general forms of the name classes (oaName and oaSimpleName ), one technique for getting the best performance is to use the getScalar() , getVector() , getVectorBit() , or getBundle() functions. These functions return a pointer to the specific name object that the oaName or oaSimpleName represents. Applications can then pass this pointer to functions where a specific name type is required. It is the application's responsibility to call getType() to determine what type of name object the oaName or oaSimpleName represents before calling the corresponding get[NameType] function. Note that the object returned by these get functions is managed by the oaName or oaSimpleName class and should not be destroyed on its own.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaName()\n"
"    Signature: oaName||\n"
"    This function constructs a default oaName object with an empty name type.\n"
"  Paramegers: (oaNameSpace,[oaChar])\n"
"    Calls: oaName(const oaNameSpace& nSpace,const oaChar* in)\n"
"    Signature: oaName||cref-oaNameSpace,cptr-oaChar,\n"
"    This function constructs an oaName object, evaluating the input string in the specified nameSpace.\n"
"    nSpace\n"
"    The nameSpace to evaluate the string\n"
"    in\n"
"    The input string to evaluate\n"
"    oacInvalidNameLength\n"
"  Paramegers: (oaName)\n"
"    Calls: oaName(const oaName& name)\n"
"    Signature: oaName||cref-oaName,\n"
"    This function constructs a copy of the specified oaName object.\n"
"  Paramegers: (oaSimpleName)\n"
"    Calls: oaName(const oaSimpleName& name)\n"
"    Signature: oaName||cref-oaSimpleName,\n"
"    This function constructs an oaName object from the specified oaSimpleName object.\n"
"  Paramegers: (oaBundleName)\n"
"    Calls: oaName(const oaBundleName& name)\n"
"    Signature: oaName||cref-oaBundleName,\n"
"    This function constructs an oaName object from the specified oaBundleName object.\n"
"  Paramegers: (oaVectorName)\n"
"    Calls: oaName(const oaVectorName& name)\n"
"    Signature: oaName||cref-oaVectorName,\n"
"    This function constructs an oaName object from the specified oaVectorName object.\n"
"  Paramegers: (oaVectorBitName)\n"
"    Calls: oaName(const oaVectorBitName& name)\n"
"    Signature: oaName||cref-oaVectorBitName,\n"
"    This function constructs an oaName object from the specified oaVectorBitName object.\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: oaName(const oaScalarName& name)\n"
"    Signature: oaName||cref-oaScalarName,\n"
"    This function constructs an oaName object from the specified oaScalarName object.\n"
"  Paramegers: (oaName)\n"
"    Calls: (const oaName&)\n"
"    Signature: oaName||cref-oaName,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaName_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaName",
    sizeof(PyoaNameObject),
    0,
    (destructor)oaName_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaName_tp_compare,	/* tp_compare */
    (reprfunc)oaName_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaName_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaName_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaName_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaName_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaName_Type)<0) {
      printf("** PyType_Ready failed for: oaName\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaName",
           (PyObject*)(&PyoaName_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaName\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaNameBase
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaNameBase_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaNameBase_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaNameBaseObject* self = (PyoaNameBaseObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaNameBase();
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaNameBase, Choices are:\n"
        "    ()\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaNameBase_tp_dealloc(PyoaNameBaseObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaNameBase_tp_repr(PyObject *ob)
{
    PyParamoaNameBase value;
    int convert_status=PyoaNameBase_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[32];
    sprintf(buffer,"<oaNameBase::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaNameBase_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaNameBase v1;
    PyParamoaNameBase v2;
    int convert_status1=PyoaNameBase_Convert(ob1,&v1);
    int convert_status2=PyoaNameBase_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaNameBase_Convert(PyObject* ob,PyParamoaNameBase* result)
{
    if (ob == NULL) return 1;
    if (PyoaNameBase_Check(ob)) {
        result->SetData(  ((PyoaNameBaseObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaNameBase Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaNameBase_FromoaNameBase(oaNameBase* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaNameBase_Type.tp_alloc(&PyoaNameBase_Type,0);
        if (bself == NULL) return bself;
        PyoaNameBaseObject* self = (PyoaNameBaseObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNameBase_index_get_doc[] = 
"Class: oaNameBase, Function: index_get\n"
;

static PyObject*
oaNameBase_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaNameBaseObject* self=(PyoaNameBaseObject*)ob;
  try {
    PyParamoaNameBase data;
    int convert_status=PyoaNameBase_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameBaseObject* self=(PyoaNameBaseObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumMembers()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaNameMem* result= new oaNameMem(data.Data()[index]);
    return PyoaNameMem_FromoaNameMem(result,0,NULL);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaNameBase_index_get_length(PyObject* ob)
{
    PyParamoaNameBase data;
    int convert_status=PyoaNameBase_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameBaseObject* self=(PyoaNameBaseObject*)ob;

    return data.Data().getNumMembers();
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNameBase_addHierMem_doc[] = 
"Class: oaNameBase, Function: addHierMem\n"
"  Paramegers: (oaNameSpace,[oaChar],oaUInt4)\n"
"    Calls: void addHierMem(const oaNameSpace& nSpace,const oaChar* in,oaUInt4 len)\n"
"    Signature: addHierMem|void-void|cref-oaNameSpace,cptr-oaChar,simple-oaUInt4,\n"
"    This function adds the given string as a member of the hierarchical portion of this name. An exception is thrown if this name is empty.\n"
"    The in string must not contain any hierarchy delimiters. Only len characters of in are considered. An exception is thrown if this name is empty.\n"
"    nSpace\n"
"    The nameSpace in which to evaluate the given string\n"
"    in\n"
"    The input string to add to the hierarchy of this name\n"
"    len\n"
"    The length of the specified input string\n"
"    oacInvalidName\n"
"  Paramegers: (oaNameMem)\n"
"    Calls: void addHierMem(const oaNameMem& in)\n"
"    Signature: addHierMem|void-void|cref-oaNameMem,\n"
"    This function adds a hierarchical member to this name, inserting a copy of in after the existing members that represent a partial hierarchical path, and before the last member, which represents the local name. An exception is thrown if this name is empty.\n"
"    in\n"
"    The member to be added\n"
"    oacInvalidName\n"
;

static PyObject*
oaNameBase_addHierMem(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameBase data;
    int convert_status=PyoaNameBase_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameBaseObject* self=(PyoaNameBaseObject*)ob;

    // Case: (oaNameSpace,[oaChar],oaUInt4)
    {
        PyParamoaNameSpace p1;
        PyParamoaChar_Array p2;
        PyParamoaUInt4 p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaChar_Array_Convert,&p2,
              &PyoaUInt4_Convert,&p3)) {
            data.DataCall()->addHierMem(p1.Data(),p2.Data(),p3.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameMem)
    {
        PyParamoaNameMem p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaNameMem_Convert,&p1)) {
            data.DataCall()->addHierMem(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaNameBase, function: addHierMem, Choices are:\n"
        "    (oaNameSpace,[oaChar],oaUInt4)\n"
        "    (oaNameMem)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNameBase_addHierPath_doc[] = 
"Class: oaNameBase, Function: addHierPath\n"
"  Paramegers: (oaScalarName)\n"
"    Calls: void addHierPath(const oaScalarName& path)\n"
"    Signature: addHierPath|void-void|cref-oaScalarName,\n"
"    This function prepends a hierarchical path to this name. An exception is thrown if this name is empty.\n"
"    path\n"
"    The path to add\n"
"    oacInvalidName\n"
"  Paramegers: (oaVectorBitName)\n"
"    Calls: void addHierPath(const oaVectorBitName& path)\n"
"    Signature: addHierPath|void-void|cref-oaVectorBitName,\n"
"    This function prepends a hierarchical path to this name. An exception is thrown if this name is empty.\n"
"    path\n"
"    The path to add\n"
"    oacInvalidName\n"
;

static PyObject*
oaNameBase_addHierPath(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameBase data;
    int convert_status=PyoaNameBase_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameBaseObject* self=(PyoaNameBaseObject*)ob;

    // Case: (oaScalarName)
    {
        PyParamoaScalarName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaScalarName_Convert,&p1)) {
            data.DataCall()->addHierPath(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaVectorBitName)
    {
        PyParamoaVectorBitName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaVectorBitName_Convert,&p1)) {
            data.DataCall()->addHierPath(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaNameBase, function: addHierPath, Choices are:\n"
        "    (oaScalarName)\n"
        "    (oaVectorBitName)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNameBase_getNumMembers_doc[] = 
"Class: oaNameBase, Function: getNumMembers\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumMembers() const\n"
"    Signature: getNumMembers|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of members in this oaNameBase object. A name will have more than one member if it has hierarchical delimiters.\n"
;

static PyObject*
oaNameBase_getNumMembers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameBase data;
    int convert_status=PyoaNameBase_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameBaseObject* self=(PyoaNameBaseObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumMembers());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNameBase_isEmpty_doc[] = 
"Class: oaNameBase, Function: isEmpty\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isEmpty() const\n"
"    Signature: isEmpty|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value that indicates if this oaNameBase object is empty.\n"
;

static PyObject*
oaNameBase_isEmpty(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameBase data;
    int convert_status=PyoaNameBase_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameBaseObject* self=(PyoaNameBaseObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isEmpty());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNameBase_isHier_doc[] = 
"Class: oaNameBase, Function: isHier\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isHier() const\n"
"    Signature: isHier|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value that indicates if this oaNameBase object is hierarchical (has more than one name member).\n"
;

static PyObject*
oaNameBase_isHier(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameBase data;
    int convert_status=PyoaNameBase_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameBaseObject* self=(PyoaNameBaseObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isHier());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaNameBase_assign_doc[] = 
"Class: oaNameBase, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaNameBase_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaNameBase data;
  int convert_status=PyoaNameBase_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaNameBase p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaNameBase_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaNameBase_methodlist[] = {
    {"addHierMem",(PyCFunction)oaNameBase_addHierMem,METH_VARARGS,oaNameBase_addHierMem_doc},
    {"addHierPath",(PyCFunction)oaNameBase_addHierPath,METH_VARARGS,oaNameBase_addHierPath_doc},
    {"getNumMembers",(PyCFunction)oaNameBase_getNumMembers,METH_VARARGS,oaNameBase_getNumMembers_doc},
    {"isEmpty",(PyCFunction)oaNameBase_isEmpty,METH_VARARGS,oaNameBase_isEmpty_doc},
    {"isHier",(PyCFunction)oaNameBase_isHier,METH_VARARGS,oaNameBase_isHier_doc},
    {"assign",(PyCFunction)oaNameBase_tp_assign,METH_VARARGS,oaNameBase_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaNameBase_as_sequence = {
    (Pyoa_inquiry)oaNameBase_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaNameBase_index_get,	/* sq_item */
};
// ------------------------------------------------------------------
static char oaNameBase_doc[] = 
"Class: oaNameBase\n"
"  The oaNameBase class is an abstract class that includes functions common to Scalar, Vector and VectorBit names. It contains the actual oaNameMem instances that store the strings that comprise a name. For a hierarchical name, it will contain an array of oaNameMems. This class is generally only used directly by code that implements a namespace.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaNameBase()\n"
"    Signature: oaNameBase||\n"
"    This function creates an empty oaNameBase object.\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaNameBase_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaNameBase",
    sizeof(PyoaNameBaseObject),
    0,
    (destructor)oaNameBase_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaNameBase_tp_compare,	/* tp_compare */
    (reprfunc)oaNameBase_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaNameBase_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaNameBase_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaNameBase_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaNameBase_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaNameBase_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaNameBase_Type)<0) {
      printf("** PyType_Ready failed for: oaNameBase\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaNameBase",
           (PyObject*)(&PyoaNameBase_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaNameBase\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaNameMem
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaNameMem_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaNameMem_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaNameMemObject* self = (PyoaNameMemObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value =  new oaNameMem();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaString,oaBoolean)
    {
        PyParamoaString p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaString_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            self->value =  new oaNameMem(p1.Data(),p2.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ([oaChar],oaBoolean)
    {
        PyParamoaChar_Array p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaChar_Array_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            self->value =  new oaNameMem(p1.Data(),p2.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaNameMem)
    {
        PyParamoaNameMem p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaNameMem_Convert,&p1)) {
            self->value =  new oaNameMem(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaNameMem, Choices are:\n"
        "    ()\n"
        "    (oaString,oaBoolean)\n"
        "    ([oaChar],oaBoolean)\n"
        "    (oaNameMem)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaNameMem_tp_dealloc(PyoaNameMemObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaNameMem_tp_repr(PyObject *ob)
{
    PyParamoaNameMem value;
    int convert_status=PyoaNameMem_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    oaString sresult;
    value.DataCall()->getBaseName(sresult);

    char addr[31];
    sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
    oaString buffer;
    buffer+=oaString("<oaNameMem::");
    buffer+=oaString(addr);
    buffer+=oaString("::");
    buffer+=oaString(sresult);
    buffer+=oaString(">");
    result=PyString_FromString((char*)(const char*)buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaNameMem_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaNameMem v1;
    PyParamoaNameMem v2;
    int convert_status1=PyoaNameMem_Convert(ob1,&v1);
    int convert_status2=PyoaNameMem_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaNameMem_Convert(PyObject* ob,PyParamoaNameMem* result)
{
    if (ob == NULL) return 1;
    if (PyoaNameMem_Check(ob)) {
        result->SetData(  ((PyoaNameMemObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaNameMem Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaNameMem_FromoaNameMem(oaNameMem* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaNameMem_Type.tp_alloc(&PyoaNameMem_Type,0);
        if (bself == NULL) return bself;
        PyoaNameMemObject* self = (PyoaNameMemObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaNameMem_FromoaNameMem(const oaNameMem& data)
{
    PyObject* bself = PyoaNameMem_Type.tp_alloc(&PyoaNameMem_Type,0);
    if (bself == NULL) return bself;
    PyoaNameMemObject* self = (PyoaNameMemObject*)bself;
    self->value =  new oaNameMem(data);
    self->borrow = 0;
    self->locks = NULL;
    return bself;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNameMem_getBaseName_doc[] = 
"Class: oaNameMem, Function: getBaseName\n"
"  Paramegers: (oaString)\n"
"    Calls: void getBaseName(oaString& out) const\n"
"    Signature: getBaseName|void-void|ref-oaString,\n"
"    BrowseData: 0,oaString\n"
"    This function returns the string portion of this object without its index portion, mapped to the oaNative nameSpace.\n"
"    For example, an oaNameMem with the string value test[4] returns test .\n"
"    out\n"
"    The string value of this name member without its index\n"
;

static PyObject*
oaNameMem_getBaseName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameMem data;
    int convert_status=PyoaNameMem_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameMemObject* self=(PyoaNameMemObject*)ob;

    PyParamoaString p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaString_Convert,&p1)) {
        data.DataCall()->getBaseName(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNameMem_getIndex_doc[] = 
"Class: oaNameMem, Function: getIndex\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getIndex() const\n"
"    Signature: getIndex|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns an integer indicating the index value of this name member. For example, an oaNameMem with the string value test[4] returns the value 4 .\n"
"    The integer value of the index of this name member\n"
"    oacNameNotIndexed\n"
;

static PyObject*
oaNameMem_getIndex(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameMem data;
    int convert_status=PyoaNameMem_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameMemObject* self=(PyoaNameMemObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getIndex());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNameMem_getValue_doc[] = 
"Class: oaNameMem, Function: getValue\n"
"  Paramegers: ()\n"
"    Calls: const oaString& getValue() const\n"
"    Signature: getValue|cref-oaString|\n"
"    BrowseData: 1\n"
"    This function returns the string value of the oaNameMem object in the oaNative nameSpace. If the name member has an index, the index is included in the string returned.\n"
"    The string value of this name member in the oaNative nameSpace\n"
;

static PyObject*
oaNameMem_getValue(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameMem data;
    int convert_status=PyoaNameMem_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameMemObject* self=(PyoaNameMemObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaString result= (data.DataCall()->getValue());
        return PyoaString_FromoaString(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNameMem_hasIndex_doc[] = 
"Class: oaNameMem, Function: hasIndex\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean hasIndex() const\n"
"    Signature: hasIndex|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value that indicates if this object has an associated index.\n"
;

static PyObject*
oaNameMem_hasIndex(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameMem data;
    int convert_status=PyoaNameMem_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameMemObject* self=(PyoaNameMemObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->hasIndex());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNameMem_isCaseSensitive_doc[] = 
"Class: oaNameMem, Function: isCaseSensitive\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isCaseSensitive() const\n"
"    Signature: isCaseSensitive|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value that indicates if this name member was case sensitive in its original nameSpace.\n"
;

static PyObject*
oaNameMem_isCaseSensitive(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameMem data;
    int convert_status=PyoaNameMem_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameMemObject* self=(PyoaNameMemObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isCaseSensitive());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaNameMem_assign_doc[] = 
"Class: oaNameMem, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaNameMem_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaNameMem data;
  int convert_status=PyoaNameMem_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaNameMem p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaNameMem_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaNameMem_methodlist[] = {
    {"getBaseName",(PyCFunction)oaNameMem_getBaseName,METH_VARARGS,oaNameMem_getBaseName_doc},
    {"getIndex",(PyCFunction)oaNameMem_getIndex,METH_VARARGS,oaNameMem_getIndex_doc},
    {"getValue",(PyCFunction)oaNameMem_getValue,METH_VARARGS,oaNameMem_getValue_doc},
    {"hasIndex",(PyCFunction)oaNameMem_hasIndex,METH_VARARGS,oaNameMem_hasIndex_doc},
    {"isCaseSensitive",(PyCFunction)oaNameMem_isCaseSensitive,METH_VARARGS,oaNameMem_isCaseSensitive_doc},
    {"assign",(PyCFunction)oaNameMem_tp_assign,METH_VARARGS,oaNameMem_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNameMem_doc[] = 
"Class: oaNameMem\n"
"  The oaNameMem class is an internal part of the structure of any oaName . It is used by code that implements namespaces. Each oaNameMem holds a single hierarchical part of a name. So a hierarchical name that would look like mod4.abuf[4] in the Verilog namespace would be stored in two oaNameMems. This class exposes the internal storage of names as a string in the Native namespace. Each nameMem may be set as case-insensitive or case-sensitive. Regular application code should not directly reference oaNameMems.\n"
"  Instances of oaNameMem are referenced by various oaName classes. If a name is hierarchical, its oaName will reference an array of oaNameMems. See oaNameBase for information on accessing these NameMems.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaNameMem()\n"
"    Signature: oaNameMem||\n"
"    This function constructs an empty oaNameMem object.\n"
"  Paramegers: (oaString,oaBoolean)\n"
"    Calls: oaNameMem(const oaString& in,oaBoolean caseSensitive)\n"
"    Signature: oaNameMem||cref-oaString,simple-oaBoolean,\n"
"    This function constructs an oaNameMem object, initializing the name to the specified input string value.\n"
"    in\n"
"    The string value to which to initialize this name\n"
"    caseSensitive\n"
"    The case sensitivity of this name in its original nameSpace\n"
"  Paramegers: ([oaChar],oaBoolean)\n"
"    Calls: oaNameMem(const oaChar* in,oaBoolean caseSensitive)\n"
"    Signature: oaNameMem||cptr-oaChar,simple-oaBoolean,\n"
"    This function constructs an oaNameMem object, initializing the name to the specified input character value.\n"
"    in\n"
"    The string value to which to initialize this name\n"
"    caseSensitive\n"
"    The case sensitivity of this name in its original nameSpace\n"
"  Paramegers: (oaNameMem)\n"
"    Calls: oaNameMem(const oaNameMem& name)\n"
"    Signature: oaNameMem||cref-oaNameMem,\n"
"    This function constructs a copy of this oaNameMem object, initializing it to the specified name value.\n"
"  Paramegers: (oaNameMem)\n"
"    Calls: (const oaNameMem&)\n"
"    Signature: oaNameMem||cref-oaNameMem,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaNameMem_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaNameMem",
    sizeof(PyoaNameMemObject),
    0,
    (destructor)oaNameMem_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaNameMem_tp_compare,	/* tp_compare */
    (reprfunc)oaNameMem_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaNameMem_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaNameMem_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaNameMem_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaNameMem_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaNameMem_Type)<0) {
      printf("** PyType_Ready failed for: oaNameMem\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaNameMem",
           (PyObject*)(&PyoaNameMem_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaNameMem\n");
       return -1;
    }
    return 0;
}


// ==================================================================
// Array for class: oaNameMem
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaNameMem_Array_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaNameMem_Array_Type);
    PyObject* gself = type->tp_alloc(type,0);
    if (gself == NULL) return gself;
    PyoaNameMem_ArrayObject* self = (PyoaNameMem_ArrayObject*)gself;
    self->borrow = 0;
    self->locks=NULL;
    static char *kwlist [] = { NULL } ;
    /* Case: () */ 
    {
        if (PyArg_ParseTuple(args,"")) {
            return gself;
        }
    }
    PyErr_Clear();
    /* Case: (int) */
    {
        int p1;
        if (PyArg_ParseTuple(args,(char*)"i",&p1)) {
            self->data.SetLen(p1);
            return gself;
        }
    }
    PyErr_Clear();
    /* Case: (oaNameMem_Array) */
    {
        PyParamoaNameMem_Array p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaNameMem_Array_Convert,&p1)) {
            self->data.TakeAway(p1);
            return gself;
        }
    }
    /* Error */
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaNameMem_Array, Choices are:\n"
        "    ()\n"
        "    (int)\n"
        "    (oaNameMem_Array)\n"
    );
    Py_DECREF(gself);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaNameMem_Array_dealloc(PyObject* gself)
{
    PyoaNameMem_ArrayObject* self = (PyoaNameMem_ArrayObject*)gself;
    Py_XDECREF(self->locks);
    self->ob_type->tp_free(gself);
}

// ------------------------------------------------------------------
static PyObject*
oaNameMem_Array_str(PyObject *ob)
{
    PyParamoaNameMem_Array value;
    int convert_status=PyoaNameMem_Array_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* lst=PyoaNameMem_Array_CreateList(value);
    PyObject* result=PyObject_Str(lst);
    Py_DECREF(lst);
    return result;
}

// ------------------------------------------------------------------
static PyObject*
oaNameMem_Array_repr(PyObject *ob)
{
    PyParamoaNameMem_Array value;
    int convert_status=PyoaNameMem_Array_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* lst=PyoaNameMem_Array_CreateList(value);
    PyObject* result=PyObject_Repr(lst);
    Py_DECREF(lst);
    return result;
}

// ------------------------------------------------------------------
static int
oaNameMem_Array_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaNameMem_Array p1;
    PyParamoaNameMem_Array p2;
    int s1=PyoaNameMem_Array_Convert(ob1,&p1);
    int s2=PyoaNameMem_Array_Convert(ob2,&p2);
    assert(s1!=0);
    assert(s2!=0);
    PyObject* l1=PyoaNameMem_Array_CreateList(p1);
    PyObject* l2=PyoaNameMem_Array_CreateList(p2);
    int result=PyObject_Compare(l1,l2);
    Py_DECREF(l1);
    Py_DECREF(l2);
    return result;
}

// ------------------------------------------------------------------
int
PyoaNameMem_Array_Convert(PyObject* ob,PyParamoaNameMem_Array* result)
{
  Pyoa_ssize_t len,i;
  if (PyoaNameMem_Array_Check(ob)) {
    PyoaNameMem_ArrayObject* self = (PyoaNameMem_ArrayObject*)ob;
    result->Borrow(self->data);
  }
  else if (PyList_Check(ob)) {
    len=PyList_Size(ob);
    result->SetLen(len);
    PyParamoaNameMem data;
    for(i=0;i<len;i++) {
      PyObject* a=PyList_GetItem(ob,i);
      if (!PyoaNameMem_Convert(a,&data)) return 0;
      result->SetItem(i,data.Data());
    }
  }
  else if (PyTuple_Check(ob)) {
    len=PyTuple_Size(ob);
    result->SetLen(len);
    PyParamoaNameMem data;
    for(i=0;i<len;i++) {
      PyObject* a=PyTuple_GetItem(ob,i);
      if (!PyoaNameMem_Convert(a,&data)) return 0;
      result->SetItem(i,data.Data());
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError,
      "Convertion of parameter to class: oaNameMem_Array Failed");
    return 0;
  }
  return 1;
}

// ------------------------------------------------------------------
PyObject* PyoaNameMem_Array_FromoaNameMem_Array(const oaNameMem_Array& value)
{
  PyObject* gself = PyoaNameMem_Array_Type.tp_alloc(&PyoaNameMem_Array_Type,0);
  if (gself == NULL) return gself;
  PyoaNameMem_ArrayObject* self = (PyoaNameMem_ArrayObject*)gself;
  self->data = value;
  self->borrow = 0;
  self->locks=NULL;
  return gself;
}

// ------------------------------------------------------------------
PyObject* PyoaNameMem_Array_FromoaNameMem_Array(PyTypeoaNameMem* data,Pyoa_ssize_t len,PyObject* lock)
{
  PyObject* gself = PyoaNameMem_Array_Type.tp_alloc(&PyoaNameMem_Array_Type,0);
  if (gself == NULL) return gself;
  PyoaNameMem_ArrayObject* self = (PyoaNameMem_ArrayObject*)gself;
  self->data.Borrow(data,len);
  self->borrow = 1;
  self->locks=NULL;
  if (lock) PyoaLockObject(self->locks,lock);
  return gself;
}

// ------------------------------------------------------------------
PyObject* PyoaNameMem_Array_CreateList(PyParamoaNameMem_Array& value)
{
  Pyoa_ssize_t i;
  PyObject* lst=PyList_New(value.Len());
  for(i=0;i<value.Len();i++) {
    PyObject* ob=PyoaNameMem_FromoaNameMem(value.Data()[i]);
    PyList_SetItem(lst,i,ob);
  }
  return lst;
}

// ------------------------------------------------------------------
// Methods
// ------------------------------------------------------------------
static char oaNameMem_Array_assign_doc[] = 
"Class: oaNameMem_Array, Function: assign\n"
"  Paramegers: (oaNameMem_Array)\n"
"    This function assigns the current value.\n"
;

static PyObject*
oaNameMem_Array_assign(PyObject* ob, PyObject *args)
{
  PyoaNameMem_ArrayObject* self=(PyoaNameMem_ArrayObject*)ob;
  try {
    PyParamoaNameMem_Array p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaNameMem_Array_Convert,&p1)) {
        self->data=p1;
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}
// ------------------------------------------------------------------
static char oaNameMem_Array_list_doc[] = 
"Class: oaNameMem_Array, Function: list\n"
"  Paramegers: ()\n"
"    This function returns the current value as a list.\n"
;

static PyObject*
oaNameMem_Array_list(PyObject* ob, PyObject *args)
{
  PyoaNameMem_ArrayObject* self=(PyoaNameMem_ArrayObject*)ob;
  try {
    if (PyArg_ParseTuple(args,(char*)"")) {
      return PyoaNameMem_Array_CreateList(self->data);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}
// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------
static PyMethodDef oaNameMem_Array_methodlist[] = {
    {"assign",(PyCFunction)oaNameMem_Array_assign,METH_VARARGS,oaNameMem_Array_assign_doc},
    {"list",(PyCFunction)oaNameMem_Array_list,METH_VARARGS,oaNameMem_Array_list_doc},
   {NULL,NULL,0,NULL}
};

// ------------------------------------------------------------------
static PyObject*
oaNameMem_Array_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaNameMem_ArrayObject* self=(PyoaNameMem_ArrayObject*)ob;
  try {
    PyParamoaNameMem_Array data;
    int convert_status=PyoaNameMem_Array_Convert(ob,&data);
    assert(convert_status!=0);
    if (index<0 || index>=data.Len()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    return PyoaNameMem_FromoaNameMem(data.GetItemPtr(index),1,self->locks);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static Pyoa_ssize_t
oaNameMem_Array_index_get_length(PyObject* ob)
{
    PyParamoaNameMem_Array data;
    int convert_status=PyoaNameMem_Array_Convert(ob,&data);
    assert(convert_status!=0);
    return data.Len();
}

// ------------------------------------------------------------------
static int
oaNameMem_Array_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaNameMem_Array data;
    PyParamoaNameMem dataitem;
    int convert_status=PyoaNameMem_Array_Convert(ob,&data);
    assert(convert_status!=0);
    if (index<0 || index>=data.Len()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    if (PyoaNameMem_Convert(value,&dataitem)==0) return -1;
    data.SetItem(index,dataitem.Data());
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return 0;
  }
}

// ------------------------------------------------------------------
static char oaNameMem_Array_doc[] =
"Class: oaNameMem_Array\n"
"  The oaNameMem_Array utility class provides an array of oaNameMem.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaNameMem_Array()\n"
"    Signature: oaNameMem_Array||\n"
"    This is the default constructor for the oaNameMem_Array class. This constructor creates an empty oaNameMem_Array.\n"
"  Paramegers: (oaNameMem_Array)\n"
"    Calls: (const oaNameMem_Array&)\n"
"    Signature: oaNameMem_Array||cref-oaNameMem_Array,\n"
;

// ------------------------------------------------------------------
static PySequenceMethods oaNameMem_Array_as_sequence = {
    (Pyoa_inquiry)oaNameMem_Array_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,              /* sq_concat */
    (Pyoa_intargfunc)0,              /* sq_repeat */
    (Pyoa_intargfunc)oaNameMem_Array_index_get, /* sq_item */
    (Pyoa_intintargfunc)0,           /* sq_slice */
    (Pyoa_intobjargproc)oaNameMem_Array_index_set,      /* sq_ass_item */
};

// ------------------------------------------------------------------
PyTypeObject PyoaNameMem_Array_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaNameMem_Array",
    sizeof(PyoaNameMem_ArrayObject),
    0,
    oaNameMem_Array_dealloc, /* tp_dealloc */
    0,  /* tp_print */
    0,                                  /* tp_getattr */
    0,                                  /* tp_setattr */
    oaNameMem_Array_compare,    /* tp_compare */
    oaNameMem_Array_repr,      /* tp_repr */
    0,                                  /* tp_as_number */
    &oaNameMem_Array_as_sequence,  /* tp_as_sequence */
    0,                                  /* tp_as_mapping */
    0,                                  /* tp_as_hash */
    0,                                  /* tp_as_call */
    oaNameMem_Array_str,               /* tp_str */
    0,                                  /* tp_getattro */
    0,                                  /* tp_setattro */
    0,                                  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaNameMem_Array_doc, /* tp_doc */
    0,                                  /* tp_traverse */
    0,                                  /* tp_clear */
    0,                                  /* tp_richcompre */
    0,                                  /* tp_weaklistoffset */
    0,                                  /* tp_iter */
    0,                                  /* tp_iternext */
    oaNameMem_Array_methodlist, /* tp_methods */
    0,                                  /* tp_members */
    0,                                  /* tp_getset */
    0,                                  /* tp_base */
    0,                                  /* tp_dict */
    0,                                  /* tp_descr_get */
    0,                                  /* tp_descr_set */
    0,                                  /* tp_dictoffset */
    0,                                  /* tp_init */
    PyType_GenericAlloc,        /* tp_alloc */
    oaNameMem_Array_new, /* tp_new */
    _PyObject_Del,      /* tp_free */
};


// ------------------------------------------------------------------
int
PyoaNameMem_Array_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaNameMem_Array_Type)<0) {
      printf("** PyType_Ready failed for: oaNameMem_Array\n");
      return -1;
    }
    if (PyDict_SetItemString(mod_dict,"oaNameMem_Array",
           (PyObject*)(&PyoaNameMem_Array_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaNameMem_Array\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaNameSpace
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaNameSpace_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaNameSpace_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaNameSpaceObject* self = (PyoaNameSpaceObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaNameSpace, Choices are:\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaNameSpace_tp_dealloc(PyoaNameSpaceObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaNameSpace_tp_repr(PyObject *ob)
{
    PyParamoaNameSpace value;
    int convert_status=PyoaNameSpace_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[33];
    sprintf(buffer,"<oaNameSpace::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaNameSpace_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaNameSpace v1;
    PyParamoaNameSpace v2;
    int convert_status1=PyoaNameSpace_Convert(ob1,&v1);
    int convert_status2=PyoaNameSpace_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaNameSpace_Convert(PyObject* ob,PyParamoaNameSpace* result)
{
    if (ob == NULL) return 1;
    if (PyoaNameSpace_Check(ob)) {
        result->SetData(  ((PyoaNameSpaceObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaNameSpace Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaNameSpace_FromoaNameSpace(oaNameSpace* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaNameSpace_Type.tp_alloc(&PyoaNameSpace_Type,0);
        if (bself == NULL) return bself;
        PyoaNameSpaceObject* self = (PyoaNameSpaceObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNameSpace_getBundleName_doc[] = 
"Class: oaNameSpace, Function: getBundleName\n"
"  Paramegers: (oaBundleName,oaString,oaUInt4)\n"
"    Calls: void getBundleName(const oaBundleName& in,oaString& out,oaUInt4& loc) const\n"
"    Signature: getBundleName|void-void|cref-oaBundleName,ref-oaString,ref-oaUInt4,\n"
"    This function returns in the string out , beginning at the location loc , the input bundle name in mapped into this name space. It is assumed the input name is in the native name space format. Derived name spaces that support bundle names should reimplement this function.\n"
"    in\n"
"    The input bundle name in the native name space format\n"
"    out\n"
"    The string value of the input name in this name space\n"
"    loc\n"
"    The location in out at which the function starts writing\n"
"    oacBundleNameInvalid\n"
;

static PyObject*
oaNameSpace_getBundleName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameSpace data;
    int convert_status=PyoaNameSpace_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameSpaceObject* self=(PyoaNameSpaceObject*)ob;

    PyParamoaBundleName p1;
    PyParamoaString p2;
    PyParamoaUInt4 p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaBundleName_Convert,&p1,
          &PyoaString_Convert,&p2,
          &PyoaUInt4_Convert,&p3)) {
        data.DataCall()->getBundleName(p1.Data(),p2.Data(),p3.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNameSpace_getInternalBundle_doc[] = 
"Class: oaNameSpace, Function: getInternalBundle\n"
"  Paramegers: ([oaChar],oaBundleName)\n"
"    Calls: void getInternalBundle(const oaChar* in,oaBundleName& out) const\n"
"    Signature: getInternalBundle|void-void|cptr-oaChar,ref-oaBundleName,\n"
"    This function returns in out , the input string mapped into the internal name space. Derived name spaces that support bundle names should reimplement this function.\n"
"    in\n"
"    The input string representing a bundle name in this name space\n"
"    out\n"
"    The output bundle name object created from mapping input string into the native name space\n"
"    oacBundleNameInvalid\n"
;

static PyObject*
oaNameSpace_getInternalBundle(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameSpace data;
    int convert_status=PyoaNameSpace_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameSpaceObject* self=(PyoaNameSpaceObject*)ob;

    PyParamoaChar_Array p1;
    PyParamoaBundleName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaChar_Array_Convert,&p1,
          &PyoaBundleName_Convert,&p2)) {
        data.DataCall()->getInternalBundle(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNameSpace_getInternalMember_doc[] = 
"Class: oaNameSpace, Function: getInternalMember\n"
"  Paramegers: ([oaChar],oaString,oaBoolean,oaUInt4)\n"
"    Calls: virtual void getInternalMember(const oaChar* in,oaString& out,oaBoolean& caseSensitive,oaUInt4 len) const\n"
"    Signature: getInternalMember|void-void|cptr-oaChar,ref-oaString,ref-oaBoolean,simple-oaUInt4,simple-oaUInt4,\n"
"    oaNameSpace::getInternalMember\n"
"    This function returns in out , the input string mapped into the internal name space. The len characters of the input string are evaluated. The default is to evaluate the entire string.\n"
"    Note: This is a pure virtual function, defined but not implemented in oaNameSpace. Classes derived from oaNameSpace must define this function in order to be instantiated.\n"
"    in\n"
"    The input string representing a name member in this name space\n"
"    out\n"
"    The output name member object created from mapping input string into the native name space\n"
"    caseSensitive\n"
"    Determines if the string is case sensitive\n"
"    len\n"
"    The number of characters of in to evaluate\n"
"    flags\n"
"    Has no valid values other than 0 in this name space\n"
"  Paramegers: ([oaChar],oaString,oaBoolean,oaUInt4,oaUInt4)\n"
"    Calls: virtual void getInternalMember(const oaChar* in,oaString& out,oaBoolean& caseSensitive,oaUInt4 len,oaUInt4 flags) const\n"
"    Signature: getInternalMember|void-void|cptr-oaChar,ref-oaString,ref-oaBoolean,simple-oaUInt4,simple-oaUInt4,\n"
"    oaNameSpace::getInternalMember\n"
"    This function returns in out , the input string mapped into the internal name space. The len characters of the input string are evaluated. The default is to evaluate the entire string.\n"
"    Note: This is a pure virtual function, defined but not implemented in oaNameSpace. Classes derived from oaNameSpace must define this function in order to be instantiated.\n"
"    in\n"
"    The input string representing a name member in this name space\n"
"    out\n"
"    The output name member object created from mapping input string into the native name space\n"
"    caseSensitive\n"
"    Determines if the string is case sensitive\n"
"    len\n"
"    The number of characters of in to evaluate\n"
"    flags\n"
"    Has no valid values other than 0 in this name space\n"
;

static PyObject*
oaNameSpace_getInternalMember(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameSpace data;
    int convert_status=PyoaNameSpace_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameSpaceObject* self=(PyoaNameSpaceObject*)ob;

    // Case: ([oaChar],oaString,oaBoolean,oaUInt4)
    {
        PyParamoaChar_Array p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        PyParamoaUInt4 p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaChar_Array_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3,
              &PyoaUInt4_Convert,&p4)) {
            PyErr_SetString(PyExc_TypeError,
                "Call to Pure-Virtual Function class: oaNameSpace, function: getInternalMember");
                return NULL;
        }
    }
    PyErr_Clear();
    // Case: ([oaChar],oaString,oaBoolean,oaUInt4,oaUInt4)
    {
        PyParamoaChar_Array p1;
        PyParamoaString p2;
        PyParamoaBoolean p3;
        PyParamoaUInt4 p4;
        PyParamoaUInt4 p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaChar_Array_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaBoolean_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaUInt4_Convert,&p5)) {
            PyErr_SetString(PyExc_TypeError,
                "Call to Pure-Virtual Function class: oaNameSpace, function: getInternalMember");
                return NULL;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaNameSpace, function: getInternalMember, Choices are:\n"
        "    ([oaChar],oaString,oaBoolean,oaUInt4)\n"
        "    ([oaChar],oaString,oaBoolean,oaUInt4,oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNameSpace_getInternalScalar_doc[] = 
"Class: oaNameSpace, Function: getInternalScalar\n"
"  Paramegers: ([oaChar],oaScalarName)\n"
"    Calls: virtual void getInternalScalar(const oaChar* in,oaScalarName& out) const\n"
"    Signature: getInternalScalar|void-void|cptr-oaChar,ref-oaScalarName,\n"
"    oaNameSpace::getInternalScalar\n"
"    This function returns in out , the input string mapped into the internal name space.\n"
"    Note: This is a pure virtual function, defined but not implemented in oaNameSpace. Classes derived from oaNameSpace must define this function in order to be instantiated.\n"
"    in\n"
"    The input string representing a scalar name in this name space\n"
"    out\n"
"    The output scalar name object created from mapping input string into the native name space\n"
;

static PyObject*
oaNameSpace_getInternalScalar(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameSpace data;
    int convert_status=PyoaNameSpace_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameSpaceObject* self=(PyoaNameSpaceObject*)ob;

    PyParamoaChar_Array p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaChar_Array_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        PyErr_SetString(PyExc_TypeError,
            "Call to Pure-Virtual Function class: oaNameSpace, function: getInternalScalar");
            return NULL;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNameSpace_getInternalVBit_doc[] = 
"Class: oaNameSpace, Function: getInternalVBit\n"
"  Paramegers: ([oaChar],oaVectorBitName)\n"
"    Calls: void getInternalVBit(const oaChar* in,oaVectorBitName& out) const\n"
"    Signature: getInternalVBit|void-void|cptr-oaChar,ref-oaVectorBitName,simple-oaBoolean,\n"
"    This function returns in out , the input string mapped into the internal name space. If the value of baseOnly is false, the string is interpreted as an entire vector bit name. If the value is true, in is interpreted as the base of the vector bit name. Derived name spaces that support indexed names should reimplement this function.\n"
"    in\n"
"    The input string representing a vector base name in this name space\n"
"    out\n"
"    The output vector bit name object created from mapping input string into the native name space\n"
"    baseOnly\n"
"    Determines if the input string is an entire vectorbit name or just the base value\n"
"    oacIndexedNameInvalid\n"
"  Paramegers: ([oaChar],oaVectorBitName,oaBoolean)\n"
"    Calls: void getInternalVBit(const oaChar* in,oaVectorBitName& out,oaBoolean baseOnly) const\n"
"    Signature: getInternalVBit|void-void|cptr-oaChar,ref-oaVectorBitName,simple-oaBoolean,\n"
"    This function returns in out , the input string mapped into the internal name space. If the value of baseOnly is false, the string is interpreted as an entire vector bit name. If the value is true, in is interpreted as the base of the vector bit name. Derived name spaces that support indexed names should reimplement this function.\n"
"    in\n"
"    The input string representing a vector base name in this name space\n"
"    out\n"
"    The output vector bit name object created from mapping input string into the native name space\n"
"    baseOnly\n"
"    Determines if the input string is an entire vectorbit name or just the base value\n"
"    oacIndexedNameInvalid\n"
;

static PyObject*
oaNameSpace_getInternalVBit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameSpace data;
    int convert_status=PyoaNameSpace_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameSpaceObject* self=(PyoaNameSpaceObject*)ob;

    // Case: ([oaChar],oaVectorBitName)
    {
        PyParamoaChar_Array p1;
        PyParamoaVectorBitName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaChar_Array_Convert,&p1,
              &PyoaVectorBitName_Convert,&p2)) {
            data.DataCall()->getInternalVBit(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: ([oaChar],oaVectorBitName,oaBoolean)
    {
        PyParamoaChar_Array p1;
        PyParamoaVectorBitName p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaChar_Array_Convert,&p1,
              &PyoaVectorBitName_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            data.DataCall()->getInternalVBit(p1.Data(),p2.Data(),p3.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaNameSpace, function: getInternalVBit, Choices are:\n"
        "    ([oaChar],oaVectorBitName)\n"
        "    ([oaChar],oaVectorBitName,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNameSpace_getInternalVector_doc[] = 
"Class: oaNameSpace, Function: getInternalVector\n"
"  Paramegers: ([oaChar],oaVectorName)\n"
"    Calls: void getInternalVector(const oaChar* in,oaVectorName& out) const\n"
"    Signature: getInternalVector|void-void|cptr-oaChar,ref-oaVectorName,simple-oaBoolean,\n"
"    This function returns in out , the input string mapped into the internal name space. If the value of baseOnly is false, the string is interpreted as an entire vector name. If the value is true, in is interpreted as the base of the vector bit name. Derived name spaces that support vector names should reimplement this function.\n"
"    in\n"
"    The input string representing a vector name in this name space\n"
"    out\n"
"    The output vector name object created from mapping input string into the native name space\n"
"    baseOnly\n"
"    Determines if the input string is an entire vector name or just the base value\n"
"    oacVectorNameInvalid\n"
"  Paramegers: ([oaChar],oaVectorName,oaBoolean)\n"
"    Calls: void getInternalVector(const oaChar* in,oaVectorName& out,oaBoolean baseOnly) const\n"
"    Signature: getInternalVector|void-void|cptr-oaChar,ref-oaVectorName,simple-oaBoolean,\n"
"    This function returns in out , the input string mapped into the internal name space. If the value of baseOnly is false, the string is interpreted as an entire vector name. If the value is true, in is interpreted as the base of the vector bit name. Derived name spaces that support vector names should reimplement this function.\n"
"    in\n"
"    The input string representing a vector name in this name space\n"
"    out\n"
"    The output vector name object created from mapping input string into the native name space\n"
"    baseOnly\n"
"    Determines if the input string is an entire vector name or just the base value\n"
"    oacVectorNameInvalid\n"
;

static PyObject*
oaNameSpace_getInternalVector(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameSpace data;
    int convert_status=PyoaNameSpace_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameSpaceObject* self=(PyoaNameSpaceObject*)ob;

    // Case: ([oaChar],oaVectorName)
    {
        PyParamoaChar_Array p1;
        PyParamoaVectorName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaChar_Array_Convert,&p1,
              &PyoaVectorName_Convert,&p2)) {
            data.DataCall()->getInternalVector(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: ([oaChar],oaVectorName,oaBoolean)
    {
        PyParamoaChar_Array p1;
        PyParamoaVectorName p2;
        PyParamoaBoolean p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaChar_Array_Convert,&p1,
              &PyoaVectorName_Convert,&p2,
              &PyoaBoolean_Convert,&p3)) {
            data.DataCall()->getInternalVector(p1.Data(),p2.Data(),p3.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaNameSpace, function: getInternalVector, Choices are:\n"
        "    ([oaChar],oaVectorName)\n"
        "    ([oaChar],oaVectorName,oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNameSpace_getMember_doc[] = 
"Class: oaNameSpace, Function: getMember\n"
"  Paramegers: ([oaChar],oaBoolean,oaString,oaUInt4)\n"
"    Calls: virtual void getMember(const oaChar* in,oaBoolean caseSensitive,oaString& out,oaUInt4& loc) const\n"
"    Signature: getMember|void-void|cptr-oaChar,simple-oaBoolean,ref-oaString,ref-oaUInt4,simple-oaUInt4,\n"
"    oaNameSpace::getMember\n"
"    This function returns in the string out , at the location loc , the input name member in with case sensitivity value caseSensitive mapped into this name space. It is assumed that the input name is in the native name space format.\n"
"    Note: This is a pure virtual function, defined but not implemented in oaNameSpace. Classes derived from oaNameSpace must define this function in order to be instantiated.\n"
"    in\n"
"    The input name member in the native name space format\n"
"    caseSensitive\n"
"    The case sensitivity value of the input name member\n"
"    out\n"
"    The string value of the input name in this name space\n"
"    loc\n"
"    The location in out at which the function starts writing\n"
"    flags\n"
"    Has no valid values other than 0 in this name space\n"
"  Paramegers: ([oaChar],oaBoolean,oaString,oaUInt4,oaUInt4)\n"
"    Calls: virtual void getMember(const oaChar* in,oaBoolean caseSensitive,oaString& out,oaUInt4& loc,oaUInt4 flags) const\n"
"    Signature: getMember|void-void|cptr-oaChar,simple-oaBoolean,ref-oaString,ref-oaUInt4,simple-oaUInt4,\n"
"    oaNameSpace::getMember\n"
"    This function returns in the string out , at the location loc , the input name member in with case sensitivity value caseSensitive mapped into this name space. It is assumed that the input name is in the native name space format.\n"
"    Note: This is a pure virtual function, defined but not implemented in oaNameSpace. Classes derived from oaNameSpace must define this function in order to be instantiated.\n"
"    in\n"
"    The input name member in the native name space format\n"
"    caseSensitive\n"
"    The case sensitivity value of the input name member\n"
"    out\n"
"    The string value of the input name in this name space\n"
"    loc\n"
"    The location in out at which the function starts writing\n"
"    flags\n"
"    Has no valid values other than 0 in this name space\n"
;

static PyObject*
oaNameSpace_getMember(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameSpace data;
    int convert_status=PyoaNameSpace_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameSpaceObject* self=(PyoaNameSpaceObject*)ob;

    // Case: ([oaChar],oaBoolean,oaString,oaUInt4)
    {
        PyParamoaChar_Array p1;
        PyParamoaBoolean p2;
        PyParamoaString p3;
        PyParamoaUInt4 p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaChar_Array_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaUInt4_Convert,&p4)) {
            PyErr_SetString(PyExc_TypeError,
                "Call to Pure-Virtual Function class: oaNameSpace, function: getMember");
                return NULL;
        }
    }
    PyErr_Clear();
    // Case: ([oaChar],oaBoolean,oaString,oaUInt4,oaUInt4)
    {
        PyParamoaChar_Array p1;
        PyParamoaBoolean p2;
        PyParamoaString p3;
        PyParamoaUInt4 p4;
        PyParamoaUInt4 p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaChar_Array_Convert,&p1,
              &PyoaBoolean_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaUInt4_Convert,&p4,
              &PyoaUInt4_Convert,&p5)) {
            PyErr_SetString(PyExc_TypeError,
                "Call to Pure-Virtual Function class: oaNameSpace, function: getMember");
                return NULL;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaNameSpace, function: getMember, Choices are:\n"
        "    ([oaChar],oaBoolean,oaString,oaUInt4)\n"
        "    ([oaChar],oaBoolean,oaString,oaUInt4,oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNameSpace_getMemberArray_doc[] = 
"Class: oaNameSpace, Function: getMemberArray\n"
"  Paramegers: ([oaNameMem],oaString,oaUInt4)\n"
"    Calls: void getMemberArray(const oaNameMem* in,oaString& out,oaUInt4& loc) const\n"
"    Signature: getMemberArray|void-void|cptr-oaNameMem,simple-oaUInt4,ref-oaString,ref-oaUInt4,\n"
"    This function returns in the string out , at the location loc , the input name member array in , mapped into this name space. It is assumed the array has numMembers elements and the input name is in the internal name space format. Derived name spaces that support hierarchical names should reimplement this function.\n"
"    in\n"
"    The input name member array\n"
"    numMembers\n"
"    The number of members in the input array\n"
"    out\n"
"    The string value of the input array in this name space\n"
"    loc\n"
"    The location in out at which the function starts writing\n"
"    oacHierNameInvalid\n"
;

static PyObject*
oaNameSpace_getMemberArray(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameSpace data;
    int convert_status=PyoaNameSpace_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameSpaceObject* self=(PyoaNameSpaceObject*)ob;

    PyParamoaNameMem_Array p1;
    PyParamoaString p2;
    PyParamoaUInt4 p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaNameMem_Array_Convert,&p1,
          &PyoaString_Convert,&p2,
          &PyoaUInt4_Convert,&p3)) {
        data.DataCall()->getMemberArray(p1.Data(),p1.Len(),p2.Data(),p3.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNameSpace_getScalarName_doc[] = 
"Class: oaNameSpace, Function: getScalarName\n"
"  Paramegers: (oaScalarName,oaString,oaUInt4)\n"
"    Calls: virtual void getScalarName(const oaScalarName& in,oaString& out,oaUInt4& loc) const\n"
"    Signature: getScalarName|void-void|cref-oaScalarName,ref-oaString,ref-oaUInt4,\n"
"    oaNameSpace::getScalarName\n"
"    This function returns in the string out , at the location loc , the input scalar name in mapped into this name space. It is assumed the input name is in the internal namespace format.\n"
"    Note: This is a pure virtual function, defined but not implemented in oaNameSpace. Classes derived from oaNameSpace must define this function in order to be instantiated.\n"
"    in\n"
"    The input scalar name\n"
"    out\n"
"    The string value of the scalar name in this name space\n"
"    loc\n"
"    The location in out at which the function starts writing\n"
;

static PyObject*
oaNameSpace_getScalarName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameSpace data;
    int convert_status=PyoaNameSpace_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameSpaceObject* self=(PyoaNameSpaceObject*)ob;

    PyParamoaScalarName p1;
    PyParamoaString p2;
    PyParamoaUInt4 p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaScalarName_Convert,&p1,
          &PyoaString_Convert,&p2,
          &PyoaUInt4_Convert,&p3)) {
        PyErr_SetString(PyExc_TypeError,
            "Call to Pure-Virtual Function class: oaNameSpace, function: getScalarName");
            return NULL;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNameSpace_getSimpleName_doc[] = 
"Class: oaNameSpace, Function: getSimpleName\n"
"  Paramegers: (oaSimpleName,oaString,oaUInt4)\n"
"    Calls: void getSimpleName(const oaSimpleName& in,oaString& out,oaUInt4& loc) const\n"
"    Signature: getSimpleName|void-void|cref-oaSimpleName,ref-oaString,ref-oaUInt4,\n"
"    This function returns in the string out , at the location loc , the input simpleName in mapped into this name space. It is assumed the input name is in the internal namespace format. The default implementation calls the correct 'get' function for the type of name the simple name represents: scalar, vector bit, or vector.\n"
"    in\n"
"    The input simple name\n"
"    out\n"
"    The string value of the simple name in this name space\n"
"    loc\n"
"    The location in out at which the function starts writing\n"
;

static PyObject*
oaNameSpace_getSimpleName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameSpace data;
    int convert_status=PyoaNameSpace_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameSpaceObject* self=(PyoaNameSpaceObject*)ob;

    PyParamoaSimpleName p1;
    PyParamoaString p2;
    PyParamoaUInt4 p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaSimpleName_Convert,&p1,
          &PyoaString_Convert,&p2,
          &PyoaUInt4_Convert,&p3)) {
        data.DataCall()->getSimpleName(p1.Data(),p2.Data(),p3.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNameSpace_getType_doc[] = 
"Class: oaNameSpace, Function: getType\n"
"  Paramegers: ([oaChar])\n"
"    Calls: virtual oaNameType getType(const oaChar* in) const\n"
"    Signature: getType|simple-oaNameType|cptr-oaChar,\n"
"    oaNameSpace::getType\n"
"    This function returns the type of name represented by the specified string this name space: scalar, vector bit, vector, or bundle. This function does not indicate if the name is valid.\n"
"    Note: This is a pure virtual function, defined but not implemented in oaNameSpace. Classes derived from oaNameSpace must define this function in order to be instantiated.\n"
"    in\n"
"    The input string\n"
"    The type of name in represents in this name space\n"
;

static PyObject*
oaNameSpace_getType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameSpace data;
    int convert_status=PyoaNameSpace_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameSpaceObject* self=(PyoaNameSpaceObject*)ob;

    PyParamoaChar_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaChar_Array_Convert,&p1)) {
        PyErr_SetString(PyExc_TypeError,
            "Call to Pure-Virtual Function class: oaNameSpace, function: getType");
            return NULL;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNameSpace_getVectorBitName_doc[] = 
"Class: oaNameSpace, Function: getVectorBitName\n"
"  Paramegers: (oaVectorBitName,oaString,oaUInt4)\n"
"    Calls: void getVectorBitName(const oaVectorBitName& in,oaString& out,oaUInt4& loc) const\n"
"    Signature: getVectorBitName|void-void|cref-oaVectorBitName,ref-oaString,ref-oaUInt4,\n"
"    This function returns in the string out , at the location loc , the input vector bit name in mapped into this name space. It is assumed the input name is in the internal namespace format. Derived name spaces that support indexed names should reimplement this function.\n"
"    in\n"
"    The input vector bit name\n"
"    out\n"
"    The string value of the vector bit name in this name space\n"
"    loc\n"
"    The location in out at which the function starts writing\n"
"    oacIndexedNameInvalid\n"
"  Paramegers: ([oaNameMem],oaUInt4,oaString,oaUInt4)\n"
"    Calls: void getVectorBitName(const oaNameMem* in,oaUInt4 start,oaString& out,oaUInt4& loc) const\n"
"    Signature: getVectorBitName|void-void|cptr-oaNameMem,simple-oaUInt4,simple-oaUInt4,ref-oaString,ref-oaUInt4,\n"
"    This function returns in the string out , at the location loc , the input vector bit name in mapped into this name space. It is assumed the array has numMembers elements and is in the internal namespace format. Derived name spaces that support indexed names should reimplement this function.\n"
"    in\n"
"    The input vector bit name\n"
"    numMembers\n"
"    The number of members in the input array\n"
"    start\n"
"    out\n"
"    The string value of the vector bit name in this name space\n"
"    loc\n"
"    The location in out at which the function starts writing\n"
"    oacIndexedNameInvalid\n"
;

static PyObject*
oaNameSpace_getVectorBitName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameSpace data;
    int convert_status=PyoaNameSpace_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameSpaceObject* self=(PyoaNameSpaceObject*)ob;

    // Case: (oaVectorBitName,oaString,oaUInt4)
    {
        PyParamoaVectorBitName p1;
        PyParamoaString p2;
        PyParamoaUInt4 p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaVectorBitName_Convert,&p1,
              &PyoaString_Convert,&p2,
              &PyoaUInt4_Convert,&p3)) {
            data.DataCall()->getVectorBitName(p1.Data(),p2.Data(),p3.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: ([oaNameMem],oaUInt4,oaString,oaUInt4)
    {
        PyParamoaNameMem_Array p1;
        PyParamoaUInt4 p2;
        PyParamoaString p3;
        PyParamoaUInt4 p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaNameMem_Array_Convert,&p1,
              &PyoaUInt4_Convert,&p2,
              &PyoaString_Convert,&p3,
              &PyoaUInt4_Convert,&p4)) {
            data.DataCall()->getVectorBitName(p1.Data(),p1.Len(),p2.Data(),p3.Data(),p4.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaNameSpace, function: getVectorBitName, Choices are:\n"
        "    (oaVectorBitName,oaString,oaUInt4)\n"
        "    ([oaNameMem],oaUInt4,oaString,oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNameSpace_getVectorName_doc[] = 
"Class: oaNameSpace, Function: getVectorName\n"
"  Paramegers: (oaVectorName,oaString,oaUInt4)\n"
"    Calls: void getVectorName(const oaVectorName& in,oaString& out,oaUInt4& loc) const\n"
"    Signature: getVectorName|void-void|cref-oaVectorName,ref-oaString,ref-oaUInt4,\n"
"    This function returns in the string out , at the location loc , the input vector name in mapped into this name space. It is assumed the input name is in the native name space format. Derived name spaces that support vector names should reimplement this function.\n"
"    in\n"
"    The input vector name\n"
"    out\n"
"    The string value of the vector name in this name space\n"
"    loc\n"
"    The location in out at which the function starts writing\n"
"    oacVectorNameInvalid\n"
;

static PyObject*
oaNameSpace_getVectorName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameSpace data;
    int convert_status=PyoaNameSpace_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameSpaceObject* self=(PyoaNameSpaceObject*)ob;

    PyParamoaVectorName p1;
    PyParamoaString p2;
    PyParamoaUInt4 p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaVectorName_Convert,&p1,
          &PyoaString_Convert,&p2,
          &PyoaUInt4_Convert,&p3)) {
        data.DataCall()->getVectorName(p1.Data(),p2.Data(),p3.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNameSpace_isEqual_doc[] = 
"Class: oaNameSpace, Function: isEqual\n"
"  Paramegers: (oaScalarName,oaScalarName)\n"
"    Calls: virtual oaBoolean isEqual(const oaScalarName& n1,const oaScalarName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaScalarName,cref-oaScalarName,\n"
"    This function returns a boolean value that indicates if the two specified scalar names are equal in this name space. Since this function is both overloaded and virtual, derived name spaces need to implement all of the isEqual functions.\n"
"    Note: This is a pure virtual function, defined but not implemented in oaNameSpace. Classes derived from oaNameSpace must define this function in order to be instantiated.\n"
"    n1\n"
"    The first name to check\n"
"    n2\n"
"    The second name to check\n"
"  Paramegers: (oaVectorName,oaVectorName)\n"
"    Calls: virtual oaBoolean isEqual(const oaVectorName& n1,const oaVectorName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaVectorName,cref-oaVectorName,\n"
"    This function returns a boolean value that indicates if the two specified vector names are equal in this name space. Since this function is both overloaded and virtual, derived name spaces need to implement all of the isEqual functions. A default implementation is provided to make this easier.\n"
"    n1\n"
"    The first name to check\n"
"    n2\n"
"    The second name to check\n"
"    oacVectorNameInvalid\n"
"  Paramegers: (oaVectorBitName,oaVectorBitName)\n"
"    Calls: virtual oaBoolean isEqual(const oaVectorBitName& n1,const oaVectorBitName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaVectorBitName,cref-oaVectorBitName,\n"
"    This function returns a boolean value that indicates if the two specified vector bit names are equal in this name space. Since this function is both overloaded and virtual, derived name spaces need to implement all of the isEqual functions. A default implementation is provided to make this easier.\n"
"    n1\n"
"    The first name to check\n"
"    n2\n"
"    The second name to check\n"
"    oacIndexedNameInvalid\n"
"  Paramegers: (oaBundleName,oaBundleName)\n"
"    Calls: virtual oaBoolean isEqual(const oaBundleName& n1,const oaBundleName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaBundleName,cref-oaBundleName,\n"
"    This function returns a boolean value that indicates if the two specified bundle names are equal in this name space. Since this function is both overloaded and virtual, derived name spaces need to implement all of the isEqual functions. A default implementation is provided to make this easier.\n"
"    n1\n"
"    The first name to check\n"
"    n2\n"
"    The second name to check\n"
"    oacBundleNameInvalid\n"
"  Paramegers: (oaSimpleName,oaSimpleName)\n"
"    Calls: virtual oaBoolean isEqual(const oaSimpleName& n1,const oaSimpleName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaSimpleName,cref-oaSimpleName,\n"
"    This function returns a boolean value that indicates if the two specified simple names are equal in this name space. Since this function is both overloaded and virtual, derived name spaces need to implement all of the isEqual functions. A default implementation is provided to make this easier.\n"
"    n1\n"
"    The first name to check\n"
"    n2\n"
"    The second name to check\n"
"  Paramegers: (oaName,oaName)\n"
"    Calls: virtual oaBoolean isEqual(const oaName& n1,const oaName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaName,cref-oaName,\n"
"    This function returns a boolean value that indicates if the two specified names are equal in this name space. Since this function is both overloaded and virtual, derived name spaces need to implement all of the isEqual functions. A default implementation is provided to make this easier.\n"
"    n1\n"
"    The first name to check\n"
"    n2\n"
"    The second name to check\n"
"  Paramegers: (oaNameMem,oaNameMem)\n"
"    Calls: virtual oaBoolean isEqual(const oaNameMem& n1,const oaNameMem& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaNameMem,cref-oaNameMem,\n"
"    oaNameSpace::isEqual\n"
"    This function returns a boolean value that indicates if the two specified name members are equal in this name space. Since this function is both overloaded and virtual, derived name spaces needs to implement all of the isEqual functions.\n"
"    Note: This is a pure virtual function, defined but not implemented in oaNameSpace. Classes derived from oaNameSpace must define this function in order to be instantiated.\n"
"    n1\n"
"    The first name to check\n"
"    n2\n"
"    The second name to check\n"
;

static PyObject*
oaNameSpace_isEqual(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameSpace data;
    int convert_status=PyoaNameSpace_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameSpaceObject* self=(PyoaNameSpaceObject*)ob;

    // Case: (oaScalarName,oaScalarName)
    {
        PyParamoaScalarName p1;
        PyParamoaScalarName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaScalarName_Convert,&p1,
              &PyoaScalarName_Convert,&p2)) {
            PyErr_SetString(PyExc_TypeError,
                "Call to Pure-Virtual Function class: oaNameSpace, function: isEqual");
                return NULL;
        }
    }
    PyErr_Clear();
    // Case: (oaVectorName,oaVectorName)
    {
        PyParamoaVectorName p1;
        PyParamoaVectorName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaVectorName_Convert,&p1,
              &PyoaVectorName_Convert,&p2)) {
            PyErr_SetString(PyExc_TypeError,
                "Call to Pure-Virtual Function class: oaNameSpace, function: isEqual");
                return NULL;
        }
    }
    PyErr_Clear();
    // Case: (oaVectorBitName,oaVectorBitName)
    {
        PyParamoaVectorBitName p1;
        PyParamoaVectorBitName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaVectorBitName_Convert,&p1,
              &PyoaVectorBitName_Convert,&p2)) {
            PyErr_SetString(PyExc_TypeError,
                "Call to Pure-Virtual Function class: oaNameSpace, function: isEqual");
                return NULL;
        }
    }
    PyErr_Clear();
    // Case: (oaBundleName,oaBundleName)
    {
        PyParamoaBundleName p1;
        PyParamoaBundleName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBundleName_Convert,&p1,
              &PyoaBundleName_Convert,&p2)) {
            PyErr_SetString(PyExc_TypeError,
                "Call to Pure-Virtual Function class: oaNameSpace, function: isEqual");
                return NULL;
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName,oaSimpleName)
    {
        PyParamoaSimpleName p1;
        PyParamoaSimpleName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaSimpleName_Convert,&p1,
              &PyoaSimpleName_Convert,&p2)) {
            PyErr_SetString(PyExc_TypeError,
                "Call to Pure-Virtual Function class: oaNameSpace, function: isEqual");
                return NULL;
        }
    }
    PyErr_Clear();
    // Case: (oaName,oaName)
    {
        PyParamoaName p1;
        PyParamoaName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaName_Convert,&p1,
              &PyoaName_Convert,&p2)) {
            PyErr_SetString(PyExc_TypeError,
                "Call to Pure-Virtual Function class: oaNameSpace, function: isEqual");
                return NULL;
        }
    }
    PyErr_Clear();
    // Case: (oaNameMem,oaNameMem)
    {
        PyParamoaNameMem p1;
        PyParamoaNameMem p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameMem_Convert,&p1,
              &PyoaNameMem_Convert,&p2)) {
            PyErr_SetString(PyExc_TypeError,
                "Call to Pure-Virtual Function class: oaNameSpace, function: isEqual");
                return NULL;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaNameSpace, function: isEqual, Choices are:\n"
        "    (oaScalarName,oaScalarName)\n"
        "    (oaVectorName,oaVectorName)\n"
        "    (oaVectorBitName,oaVectorBitName)\n"
        "    (oaBundleName,oaBundleName)\n"
        "    (oaSimpleName,oaSimpleName)\n"
        "    (oaName,oaName)\n"
        "    (oaNameMem,oaNameMem)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaNameSpace_assign_doc[] = 
"Class: oaNameSpace, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaNameSpace_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaNameSpace data;
  int convert_status=PyoaNameSpace_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaNameSpace p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaNameSpace_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaNameSpace_methodlist[] = {
    {"getBundleName",(PyCFunction)oaNameSpace_getBundleName,METH_VARARGS,oaNameSpace_getBundleName_doc},
    {"getInternalBundle",(PyCFunction)oaNameSpace_getInternalBundle,METH_VARARGS,oaNameSpace_getInternalBundle_doc},
    {"getInternalMember",(PyCFunction)oaNameSpace_getInternalMember,METH_VARARGS,oaNameSpace_getInternalMember_doc},
    {"getInternalScalar",(PyCFunction)oaNameSpace_getInternalScalar,METH_VARARGS,oaNameSpace_getInternalScalar_doc},
    {"getInternalVBit",(PyCFunction)oaNameSpace_getInternalVBit,METH_VARARGS,oaNameSpace_getInternalVBit_doc},
    {"getInternalVector",(PyCFunction)oaNameSpace_getInternalVector,METH_VARARGS,oaNameSpace_getInternalVector_doc},
    {"getMember",(PyCFunction)oaNameSpace_getMember,METH_VARARGS,oaNameSpace_getMember_doc},
    {"getMemberArray",(PyCFunction)oaNameSpace_getMemberArray,METH_VARARGS,oaNameSpace_getMemberArray_doc},
    {"getScalarName",(PyCFunction)oaNameSpace_getScalarName,METH_VARARGS,oaNameSpace_getScalarName_doc},
    {"getSimpleName",(PyCFunction)oaNameSpace_getSimpleName,METH_VARARGS,oaNameSpace_getSimpleName_doc},
    {"getType",(PyCFunction)oaNameSpace_getType,METH_VARARGS,oaNameSpace_getType_doc},
    {"getVectorBitName",(PyCFunction)oaNameSpace_getVectorBitName,METH_VARARGS,oaNameSpace_getVectorBitName_doc},
    {"getVectorName",(PyCFunction)oaNameSpace_getVectorName,METH_VARARGS,oaNameSpace_getVectorName_doc},
    {"isEqual",(PyCFunction)oaNameSpace_isEqual,METH_VARARGS,oaNameSpace_isEqual_doc},
    {"assign",(PyCFunction)oaNameSpace_tp_assign,METH_VARARGS,oaNameSpace_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNameSpace_doc[] = 
"Class: oaNameSpace\n"
"  A name space refers to a set of rules for creating and interpreting legal names within an application. The oaNameSpace utility class is an abstract base class for defining the name spaces used in name mapping. In conjunction with the oaName object, derived oaNameSpace classes facilitate mapping names to and from the internal representation of a name. See the Name Mapping Section of the Programmer's Guide for more information about mapping names between different namespaces.\n"
"  Functions for oaNameSpace are not used by the normal application code. The functions are only used by the developers creating their own name space. To create your own name space, create a class derived from oaNameSpace and implement the virtual functions in oaNameSpace that require non-default behavior for your own name space. These functions have default implementations on the oaNameSpace class itself, and the defaults described here are appropriate for some name spaces.\n"
"  All namespaces apply to external representations of names. Names have an internal representation that is not simply a string. This internal format uses the oaNative name space for portions of the name. Thus, when implementing a new derived name space, you need to determine how to translate names from your original language to the desired output names in the oaNative name space, and vice versa. Since any name handed to a name space is in internal format, the derived name space just needs to provide a translation from oaNative to their name space, and from their name space to oaNative. Once this is implemented, names in the new derived name space can be mapped to any other derived name space.\n"
"  When a name space receives a name from the database, the name is stored in a tighly packed byte array for efficiency. The oaNameSpace class provides utility functions such as readUInt4() and readStr() to help interpret this byte array. A derived name space must implement the get() function which reads in the byte array and maps it to an output string in the derived name space.\n"
"  See Deriving Your Own Namespace Section of the Programmer's Guide for more information.\n"
"Constructors:\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaNameSpace_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaNameSpace",
    sizeof(PyoaNameSpaceObject),
    0,
    (destructor)oaNameSpace_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaNameSpace_tp_compare,	/* tp_compare */
    (reprfunc)oaNameSpace_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaNameSpace_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaNameSpace_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaNameSpace_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaNameSpace_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaNameSpace_Type)<0) {
      printf("** PyType_Ready failed for: oaNameSpace\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaNameSpace",
           (PyObject*)(&PyoaNameSpace_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaNameSpace\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaNameType
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaNameType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaNameType_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaNameTypeObject* self = (PyoaNameTypeObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaNameTypeEnum)
    {
        PyParamoaNameTypeEnum p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaNameTypeEnum_Convert,&p1)) {
            self->value =  new oaNameType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            self->value =  new oaNameType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaNameType)
    {
        PyParamoaNameType p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaNameType_Convert,&p1)) {
            self->value= new oaNameType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaNameType, Choices are:\n"
        "    (oaNameTypeEnum)\n"
        "    (oaString)\n"
        "    (oaNameType)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaNameType_tp_dealloc(PyoaNameTypeObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaNameType_tp_repr(PyObject *ob)
{
    PyParamoaNameType value;
    int convert_status=PyoaNameType_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    oaString sresult(value.DataCall()->getName());

    char addr[32];
    sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
    oaString buffer;
    buffer+=oaString("<oaNameType::");
    buffer+=oaString(addr);
    buffer+=oaString("::");
    buffer+=oaString(sresult);
    buffer+=oaString(">");
    result=PyString_FromString((char*)(const char*)buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaNameType_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaNameType v1;
    PyParamoaNameType v2;
    int convert_status1=PyoaNameType_Convert(ob1,&v1);
    int convert_status2=PyoaNameType_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaNameType_Convert(PyObject* ob,PyParamoaNameType* result)
{
    if (ob == NULL) return 1;
    if (PyoaNameType_Check(ob)) {
        result->SetData(  ((PyoaNameTypeObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaNameType Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaNameType_FromoaNameType(oaNameType* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaNameType_Type.tp_alloc(&PyoaNameType_Type,0);
        if (bself == NULL) return bself;
        PyoaNameTypeObject* self = (PyoaNameTypeObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNameType_getName_doc[] = 
"Class: oaNameType, Function: getName\n"
"  Paramegers: ()\n"
"    Calls: const oaString& getName() const\n"
"    Signature: getName|cref-oaString|\n"
"    BrowseData: 1\n"
"    This function returns the name string associated with the encapsulated #oaNameTypeEnum object.\n"
;

static PyObject*
oaNameType_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameType data;
    int convert_status=PyoaNameType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameTypeObject* self=(PyoaNameTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaString result= (data.DataCall()->getName());
        return PyoaString_FromoaString(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNameType_oaNameTypeEnum_doc[] = 
"Class: oaNameType, Function: oaNameTypeEnum\n"
"  Paramegers: ()\n"
"    Calls: oaNameTypeEnum oaNameTypeEnum() const\n"
"    Signature: operator oaNameTypeEnum|simple-oaNameTypeEnum|\n"
"    BrowseData: 1\n"
"    This operator casts this oaName object into the corresponding #oaNameTypeEnum value.\n"
;

static PyObject*
oaNameType_oaNameTypeEnum(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNameType data;
    int convert_status=PyoaNameType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNameTypeObject* self=(PyoaNameTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaNameTypeEnum result= (data.DataCall()->operator oaNameTypeEnum());
        return PyoaNameTypeEnum_FromoaNameTypeEnum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaNameType_assign_doc[] = 
"Class: oaNameType, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaNameType_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaNameType data;
  int convert_status=PyoaNameType_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaNameType p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaNameType_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaNameType_methodlist[] = {
    {"getName",(PyCFunction)oaNameType_getName,METH_VARARGS,oaNameType_getName_doc},
    {"oaNameTypeEnum",(PyCFunction)oaNameType_oaNameTypeEnum,METH_VARARGS,oaNameType_oaNameTypeEnum_doc},
    {"assign",(PyCFunction)oaNameType_tp_assign,METH_VARARGS,oaNameType_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNameType_doc[] = 
"Class: oaNameType\n"
"  The oaNameType class is an enum wrapper class that describes the different uses of an oaName object. The nameType is important when determining the syntactic rules for mapping the name object into different nameSpaces. See oaName::getType to see where this is used.\n"
"  See Enum Wrappers in the Programmers Guide for a discussion of enum wrappers.\n"
"  oaNameTypeEnum\n"
"Constructors:\n"
"  Paramegers: (oaNameTypeEnum)\n"
"    Calls: oaNameType(oaNameTypeEnum valueIn)\n"
"    Signature: oaNameType||simple-oaNameTypeEnum,\n"
"    This function constructs an instance of an oaNameType class using the specified #oaNameTypeEnum value.\n"
"  Paramegers: (oaString)\n"
"    Calls: oaNameType(const oaString& name)\n"
"    Signature: oaNameType||cref-oaString,\n"
"    This function constructs an instance of an oaNameType class using the #oaNameTypeEnum associated with the specified string name . This name must be defined in the legal set of names associated with #oaNameTypeEnum.\n"
"    oacInvalidNameTypeName\n"
"  Paramegers: (oaNameType)\n"
"    Calls: (const oaNameType&)\n"
"    Signature: oaNameType||cref-oaNameType,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaNameType_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaNameType",
    sizeof(PyoaNameTypeObject),
    0,
    (destructor)oaNameType_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaNameType_tp_compare,	/* tp_compare */
    (reprfunc)oaNameType_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaNameType_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaNameType_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaNameType_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaNameType_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaNameType_Type)<0) {
      printf("** PyType_Ready failed for: oaNameType\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaNameType",
           (PyObject*)(&PyoaNameType_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaNameType\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaNameTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaNameTypeEnum_Convert(PyObject* ob,PyParamoaNameTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacEmptyNameType")==0) { result->SetData(oacEmptyNameType); return 1;}
        if (strcasecmp(str,"oacScalarNameType")==0) { result->SetData(oacScalarNameType); return 1;}
        if (strcasecmp(str,"oacVectorNameType")==0) { result->SetData(oacVectorNameType); return 1;}
        if (strcasecmp(str,"oacVectorBitNameType")==0) { result->SetData(oacVectorBitNameType); return 1;}
        if (strcasecmp(str,"oacBundleNameType")==0) { result->SetData(oacBundleNameType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaNameTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaNameTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaNameTypeEnum_FromoaNameTypeEnum(oaNameTypeEnum ob)
{
    if (ob==oacEmptyNameType) return PyString_FromString("oacEmptyNameType");
    if (ob==oacScalarNameType) return PyString_FromString("oacScalarNameType");
    if (ob==oacVectorNameType) return PyString_FromString("oacVectorNameType");
    if (ob==oacVectorBitNameType) return PyString_FromString("oacVectorBitNameType");
    if (ob==oacBundleNameType) return PyString_FromString("oacBundleNameType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaNameTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaNameTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaNameTypeEnum_FromoaNameTypeEnum(oaNameTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaNameTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaNameTypeEnum_doc[] =
"Type convert function for enum: oaNameTypeEnum";
                               
static PyMethodDef PyoaNameTypeEnum_method =
  {"oaNameTypeEnum",(PyCFunction)PyoaNameTypeEnum_TypeFunction,METH_VARARGS,oaNameTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaNameTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacEmptyNameType");
    PyDict_SetItemString(mod_dict,"oacEmptyNameType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacScalarNameType");
    PyDict_SetItemString(mod_dict,"oacScalarNameType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacVectorNameType");
    PyDict_SetItemString(mod_dict,"oacVectorNameType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacVectorBitNameType");
    PyDict_SetItemString(mod_dict,"oacVectorBitNameType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBundleNameType");
    PyDict_SetItemString(mod_dict,"oacBundleNameType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaNameTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaNameTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaNameTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaNativeNS
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaNativeNS_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaNativeNS_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaNativeNSObject* self = (PyoaNativeNSObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaNameSpace*)  new oaNativeNS();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaNativeNS)
    {
        PyParamoaNativeNS p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaNativeNS_Convert,&p1)) {
            self->value=(oaNameSpace*)  new oaNativeNS(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaNativeNS, Choices are:\n"
        "    ()\n"
        "    (oaNativeNS)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaNativeNS_tp_dealloc(PyoaNativeNSObject* self)
{
    if (!self->borrow) {
        delete (oaNativeNS*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaNativeNS_tp_repr(PyObject *ob)
{
    PyParamoaNativeNS value;
    int convert_status=PyoaNativeNS_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[32];
    sprintf(buffer,"<oaNativeNS::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaNativeNS_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaNativeNS v1;
    PyParamoaNativeNS v2;
    int convert_status1=PyoaNativeNS_Convert(ob1,&v1);
    int convert_status2=PyoaNativeNS_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaNativeNS_Convert(PyObject* ob,PyParamoaNativeNS* result)
{
    if (ob == NULL) return 1;
    if (PyoaNativeNS_Check(ob)) {
        result->SetData( (oaNativeNS*) ((PyoaNativeNSObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaNativeNS Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaNativeNS_FromoaNativeNS(oaNativeNS* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaNativeNS_Type.tp_alloc(&PyoaNativeNS_Type,0);
        if (bself == NULL) return bself;
        PyoaNativeNSObject* self = (PyoaNativeNSObject*)bself;
        self->value = (oaNameSpace*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNativeNS_getType_doc[] = 
"Class: oaNativeNS, Function: getType\n"
"  Paramegers: ([oaChar])\n"
"    Calls: oaNameType getType(const oaChar* in) const\n"
"    Signature: getType|simple-oaNameType|cptr-oaChar,\n"
"    This function returns the type of name represented by the specified string in this nameSpace. This function does not indicate whether the name is valid.\n"
;

static PyObject*
oaNativeNS_getType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNativeNS data;
    int convert_status=PyoaNativeNS_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNativeNSObject* self=(PyoaNativeNSObject*)ob;

    PyParamoaChar_Array p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaChar_Array_Convert,&p1)) {
        oaNameType* result= new oaNameType(data.DataCall()->getType(p1.Data()));
        return PyoaNameType_FromoaNameType(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNativeNS_isEqual_doc[] = 
"Class: oaNativeNS, Function: isEqual\n"
"  Paramegers: (oaScalarName,oaScalarName)\n"
"    Calls: oaBoolean isEqual(const oaScalarName& n1,const oaScalarName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaScalarName,cref-oaScalarName,\n"
"    This function returns a boolean value that indicates if the two specified scalar names are equal in this nameSpace.\n"
"  Paramegers: (oaVectorName,oaVectorName)\n"
"    Calls: oaBoolean isEqual(const oaVectorName& n1,const oaVectorName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaVectorName,cref-oaVectorName,\n"
"    This function returns a boolean value that indicates if the two specified vector names are equal in this nameSpace.\n"
"  Paramegers: (oaVectorBitName,oaVectorBitName)\n"
"    Calls: oaBoolean isEqual(const oaVectorBitName& n1,const oaVectorBitName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaVectorBitName,cref-oaVectorBitName,\n"
"    This function returns a boolean value that indicates if the two specified vector bit names are equal in this nameSpace.\n"
"  Paramegers: (oaBundleName,oaBundleName)\n"
"    Calls: oaBoolean isEqual(const oaBundleName& n1,const oaBundleName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaBundleName,cref-oaBundleName,\n"
"    This function returns a boolean value that indicates if the two specified bundle names are equal in this nameSpace.\n"
"  Paramegers: (oaSimpleName,oaSimpleName)\n"
"    Calls: oaBoolean isEqual(const oaSimpleName& n1,const oaSimpleName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaSimpleName,cref-oaSimpleName,\n"
"    This function returns a boolean value that indicates if the two specified simple names are equal in this nameSpace.\n"
"  Paramegers: (oaName,oaName)\n"
"    Calls: oaBoolean isEqual(const oaName& n1,const oaName& n2) const\n"
"    Signature: isEqual|simple-oaBoolean|cref-oaName,cref-oaName,\n"
"    This function returns a boolean value that indicates if the two specified names are equal in this nameSpace.\n"
;

static PyObject*
oaNativeNS_isEqual(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNativeNS data;
    int convert_status=PyoaNativeNS_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNativeNSObject* self=(PyoaNativeNSObject*)ob;

    // Case: (oaScalarName,oaScalarName)
    {
        PyParamoaScalarName p1;
        PyParamoaScalarName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaScalarName_Convert,&p1,
              &PyoaScalarName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaVectorName,oaVectorName)
    {
        PyParamoaVectorName p1;
        PyParamoaVectorName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaVectorName_Convert,&p1,
              &PyoaVectorName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaVectorBitName,oaVectorBitName)
    {
        PyParamoaVectorBitName p1;
        PyParamoaVectorBitName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaVectorBitName_Convert,&p1,
              &PyoaVectorBitName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBundleName,oaBundleName)
    {
        PyParamoaBundleName p1;
        PyParamoaBundleName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBundleName_Convert,&p1,
              &PyoaBundleName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaSimpleName,oaSimpleName)
    {
        PyParamoaSimpleName p1;
        PyParamoaSimpleName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaSimpleName_Convert,&p1,
              &PyoaSimpleName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    // Case: (oaName,oaName)
    {
        PyParamoaName p1;
        PyParamoaName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaName_Convert,&p1,
              &PyoaName_Convert,&p2)) {
            oaBoolean result= (data.DataCall()->isEqual(p1.Data(),p2.Data()));
            return PyoaBoolean_FromoaBoolean(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaNativeNS, function: isEqual, Choices are:\n"
        "    (oaScalarName,oaScalarName)\n"
        "    (oaVectorName,oaVectorName)\n"
        "    (oaVectorBitName,oaVectorBitName)\n"
        "    (oaBundleName,oaBundleName)\n"
        "    (oaSimpleName,oaSimpleName)\n"
        "    (oaName,oaName)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaNativeNS_assign_doc[] = 
"Class: oaNativeNS, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaNativeNS_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaNativeNS data;
  int convert_status=PyoaNativeNS_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaNativeNS p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaNativeNS_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaNativeNS_methodlist[] = {
    {"getType",(PyCFunction)oaNativeNS_getType,METH_VARARGS,oaNativeNS_getType_doc},
    {"isEqual",(PyCFunction)oaNativeNS_isEqual,METH_VARARGS,oaNativeNS_isEqual_doc},
    {"assign",(PyCFunction)oaNativeNS_tp_assign,METH_VARARGS,oaNativeNS_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNativeNS_doc[] = 
"Class: oaNativeNS\n"
"  The oaNativeNS class implements the OpenAccess name space used in name mapping. In conjunction with the oaName object, the oaNativeNS class facilitates mapping names to and from OpenAccess.\n"
"  The OpenAccess name space is case sensitive and supports vectored, stepped, hierarchical, and bundled names. There are no keywords in the Native name space. See the Name Mapping Section of the Programmer's Guide for more information.\n"
"  Functions for oaNativeNS for not used by normal application code. The functions are only used by the name mapping code and can be used as an example for developers creating their own name space. See the Deriving Your Own Name Space Section of the Programmer's Guide for more details.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaNativeNS()\n"
"    Signature: oaNativeNS||\n"
"    This function constructs an empty oaNativeNS instance.\n"
"  Paramegers: (oaNativeNS)\n"
"    Calls: (const oaNativeNS&)\n"
"    Signature: oaNativeNS||cref-oaNativeNS,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaNativeNS_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaNativeNS",
    sizeof(PyoaNativeNSObject),
    0,
    (destructor)oaNativeNS_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaNativeNS_tp_compare,	/* tp_compare */
    (reprfunc)oaNativeNS_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaNativeNS_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaNativeNS_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaNameSpace_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaNativeNS_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaNativeNS_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaNativeNS_Type)<0) {
      printf("** PyType_Ready failed for: oaNativeNS\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaNativeNS",
           (PyObject*)(&PyoaNativeNS_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaNativeNS\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaNet
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaNet_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaNet_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaNetObject* self = (PyoaNetObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaNet)
    {
        PyParamoaNet p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaNet_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaNet, Choices are:\n"
        "    (oaNet)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaNet_tp_dealloc(PyoaNetObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaNet_tp_repr(PyObject *ob)
{
    PyParamoaNet value;
    int convert_status=PyoaNet_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    if (!value.Data()) {
        oaString buffer("<oaNet::NULL>");
        result=PyString_FromString((char*)(const char*)buffer);
    }
    else {
        oaName name;
        oaString sresult;
        value.DataCall()->getName(name);
        name.get(sresult);
    
        char addr[27];
        sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
        oaString buffer;
        buffer+=oaString("<oaNet::");
        buffer+=oaString(addr);
        buffer+=oaString("::");
        buffer+=oaString(sresult);
        buffer+=oaString(">");
        result=PyString_FromString((char*)(const char*)buffer);
    
    }
    return result;
}
        
// ------------------------------------------------------------------
static int
oaNet_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaNet v1;
    PyParamoaNet v2;
    int convert_status1=PyoaNet_Convert(ob1,&v1);
    int convert_status2=PyoaNet_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaNet_Convert(PyObject* ob,PyParamoaNet* result)
{
    if (ob == NULL) return 1;
    if (PyoaNet_Check(ob)) {
        result->SetData( (oaNet**) ((PyoaNetObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaNet Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaNet_FromoaNet(oaNet** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaNet* data=*value;
        if (data->getType()==oacBundleNetType) return PyoaBundleNet_FromoaBundleNet((oaBundleNet**)value,borrow,lock);
        if (data->isBitNet()) return PyoaBitNet_FromoaBitNet((oaBitNet**)value,borrow,lock);
        if (data->getType()==oacBusNetType) return PyoaBusNet_FromoaBusNet((oaBusNet**)value,borrow,lock);
        PyObject* bself = PyoaNet_Type.tp_alloc(&PyoaNet_Type,0);
        if (bself == NULL) return bself;
        PyoaNetObject* self = (PyoaNetObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaNet_FromoaNet(oaNet* data)
{
    if (data) {
        if (data->getType()==oacBundleNetType) return PyoaBundleNet_FromoaBundleNet((oaBundleNet*)data);
        if (data->isBitNet()) return PyoaBitNet_FromoaBitNet((oaBitNet*)data);
        if (data->getType()==oacBusNetType) return PyoaBusNet_FromoaBusNet((oaBusNet*)data);
       PyObject* bself = PyoaNet_Type.tp_alloc(&PyoaNet_Type,0);
       if (bself == NULL) return bself;
       PyoaNetObject* self = (PyoaNetObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNet_destroy_doc[] = 
"Class: oaNet, Function: destroy\n"
"  Paramegers: ()\n"
"    Calls: void destroy()\n"
"    Signature: destroy|void-void|\n"
"    BrowseData: 0\n"
"    This function destroys this net, removing it from the database.\n"
"    oacCannotDestroyImplicitNet\n"
"    oacCannotDestroyNetInNonUniqueSpan\n"
;

static PyObject*
oaNet_destroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->destroy();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getBit_doc[] = 
"Class: oaNet, Function: getBit\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaBitNet* getBit(oaUInt4 bitIndex) const\n"
"    Signature: getBit|ptr-oaBitNet|simple-oaUInt4,\n"
"    This function returns a pointer to the net that corresponds to the specified bitIndex bit of this net. For scalarNets, this function simply returns the net. For busNets, the busNetBit corresponding to the bitIndex bit is returned. For example, if this net is a busNet \"a[7:0]\" and bitIndex is zero, this function will return the busNetBit corresponding to \"a[7]\". For bundleNets, a scalarNet or busNetBit is returned.\n"
"    bitIndex\n"
"    Specifies which bit of the net to return\n"
"    A pointer to an oaNet\n"
"    oacInvalidBusNetBitIndex\n"
"    oacInvalidNetIndex\n"
;

static PyObject*
oaNet_getBit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaBitNetp result= (data.DataCall()->getBit(p1.Data()));
        return PyoaBitNet_FromoaBitNet(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getDefaultConstraintGroup_doc[] = 
"Class: oaNet, Function: getDefaultConstraintGroup\n"
"  Paramegers: ()\n"
"    Calls: oaConstraintGroup* getDefaultConstraintGroup() const\n"
"    Signature: getDefaultConstraintGroup|ptr-oaConstraintGroup|\n"
"    BrowseData: 1\n"
"    This function returns the constraint group for this oaNet. Constraints in this constraint group apply to all of the objects that make up the oaNet such as shapes, routes, pins and terminals. A new group is created if no constraints exist on the net.\n"
"    Todo\n"
"    Check function desciption.\n"
;

static PyObject*
oaNet_getDefaultConstraintGroup(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaConstraintGroupp result= (data.DataCall()->getDefaultConstraintGroup());
        return PyoaConstraintGroup_FromoaConstraintGroup(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getGuides_doc[] = 
"Class: oaNet, Function: getGuides\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaGuide_oaNet getGuides() const\n"
"    Signature: getGuides|simple-oaCollection_oaGuide_oaNet|simple-oaBoolean,\n"
"    BrowseData: 1\n"
"    This function returns a collection of guides associated with this net. An optional boolean parameter 'includeRouteGuides' allows the application to customize the collection of guides by either including or excluding the guides that are part of routes on this net. The default behavior is to return all guides that may be explicitly or implicitly on this net.\n"
"    includeRouteGuides\n"
"    Allows application to include or exclude the guides that may be part of routes on this net\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: oaCollection_oaGuide_oaNet getGuides(oaBoolean includeRouteGuides) const\n"
"    Signature: getGuides|simple-oaCollection_oaGuide_oaNet|simple-oaBoolean,\n"
"    This function returns a collection of guides associated with this net. An optional boolean parameter 'includeRouteGuides' allows the application to customize the collection of guides by either including or excluding the guides that are part of routes on this net. The default behavior is to return all guides that may be explicitly or implicitly on this net.\n"
"    includeRouteGuides\n"
"    Allows application to include or exclude the guides that may be part of routes on this net\n"
;

static PyObject*
oaNet_getGuides(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaGuide_oaNet* result= new oaCollection_oaGuide_oaNet(data.DataCall()->getGuides());
            return PyoaCollection_oaGuide_oaNet_FromoaCollection_oaGuide_oaNet(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            oaCollection_oaGuide_oaNet* result= new oaCollection_oaGuide_oaNet(data.DataCall()->getGuides(p1.Data()));
            return PyoaCollection_oaGuide_oaNet_FromoaCollection_oaGuide_oaNet(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaNet, function: getGuides, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getGuidesIter_doc[] = 
"Class: oaNet, Function: getGuidesIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaGuide getGuidesIter() const\n"
"    Signature: getGuidesIter|simple-oaIter_oaGuide|simple-oaBoolean,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of guides associated with this net. An optional boolean parameter 'includeRouteGuides' allows the application to customize the collection of guides by either including or excluding the guides that are part of routes on this net. The default behavior is to return all guides that may be explicitly or implicitly on this net.\n"
"    includeRouteGuides\n"
"    Allows application to include or exclude the guides that may be part of routes on this net\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: oaIter_oaGuide getGuidesIter(oaBoolean includeRouteGuides) const\n"
"    Signature: getGuidesIter|simple-oaIter_oaGuide|simple-oaBoolean,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of guides associated with this net. An optional boolean parameter 'includeRouteGuides' allows the application to customize the collection of guides by either including or excluding the guides that are part of routes on this net. The default behavior is to return all guides that may be explicitly or implicitly on this net.\n"
"    includeRouteGuides\n"
"    Allows application to include or exclude the guides that may be part of routes on this net\n"
;

static PyObject*
oaNet_getGuidesIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaGuide* result= new oaIter_oaGuide(data.DataCall()->getGuides());
            return PyoaIter_oaGuide_FromoaIter_oaGuide(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            oaIter_oaGuide* result= new oaIter_oaGuide(data.DataCall()->getGuides(p1.Data()));
            return PyoaIter_oaGuide_FromoaIter_oaGuide(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaNet, function: getGuidesIter, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getInstTerms_doc[] = 
"Class: oaNet, Function: getInstTerms\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaInstTerm_oaNet getInstTerms() const\n"
"    Signature: getInstTerms|simple-oaCollection_oaInstTerm_oaNet|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    oaNet::getInstTerms\n"
"    This function returns a collection of instTerms in this net. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bits flags are defined as follows:\n"
"    oacInstTermIterNotImplicit: the collection will only contain instTerms that were explicitly created\n"
"    oacInstTermIterEquivNets: the collection will also contain the instTerms on the nets that are equivalent to this one\n"
"    oacInstTermIterFlagNotApplicableOnNets\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaInstTerm_oaNet getInstTerms(oaUInt4 filterFlags) const\n"
"    Signature: getInstTerms|simple-oaCollection_oaInstTerm_oaNet|simple-oaUInt4,\n"
"    oaNet::getInstTerms\n"
"    This function returns a collection of instTerms in this net. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bits flags are defined as follows:\n"
"    oacInstTermIterNotImplicit: the collection will only contain instTerms that were explicitly created\n"
"    oacInstTermIterEquivNets: the collection will also contain the instTerms on the nets that are equivalent to this one\n"
"    oacInstTermIterFlagNotApplicableOnNets\n"
;

static PyObject*
oaNet_getInstTerms(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaInstTerm_oaNet* result= new oaCollection_oaInstTerm_oaNet(data.DataCall()->getInstTerms());
            return PyoaCollection_oaInstTerm_oaNet_FromoaCollection_oaInstTerm_oaNet(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaInstTerm_oaNet* result= new oaCollection_oaInstTerm_oaNet(data.DataCall()->getInstTerms(p1.Data()));
            return PyoaCollection_oaInstTerm_oaNet_FromoaCollection_oaInstTerm_oaNet(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaNet, function: getInstTerms, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getInstTermsIter_doc[] = 
"Class: oaNet, Function: getInstTermsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaInstTerm getInstTermsIter() const\n"
"    Signature: getInstTermsIter|simple-oaIter_oaInstTerm|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: oaNet::getInstTerms\n"
"    This function returns a collection of instTerms in this net. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bits flags are defined as follows:\n"
"    oacInstTermIterNotImplicit: the collection will only contain instTerms that were explicitly created\n"
"    oacInstTermIterEquivNets: the collection will also contain the instTerms on the nets that are equivalent to this one\n"
"    oacInstTermIterFlagNotApplicableOnNets\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaInstTerm getInstTermsIter(oaUInt4 filterFlags) const\n"
"    Signature: getInstTermsIter|simple-oaIter_oaInstTerm|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: oaNet::getInstTerms\n"
"    This function returns a collection of instTerms in this net. The filter flag bits are defined below and may be logically OR'd together to refine the contents of the collection.\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bits flags are defined as follows:\n"
"    oacInstTermIterNotImplicit: the collection will only contain instTerms that were explicitly created\n"
"    oacInstTermIterEquivNets: the collection will also contain the instTerms on the nets that are equivalent to this one\n"
"    oacInstTermIterFlagNotApplicableOnNets\n"
;

static PyObject*
oaNet_getInstTermsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaInstTerm* result= new oaIter_oaInstTerm(data.DataCall()->getInstTerms());
            return PyoaIter_oaInstTerm_FromoaIter_oaInstTerm(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaInstTerm* result= new oaIter_oaInstTerm(data.DataCall()->getInstTerms(p1.Data()));
            return PyoaIter_oaInstTerm_FromoaIter_oaInstTerm(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaNet, function: getInstTermsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getMemberNets_doc[] = 
"Class: oaNet, Function: getMemberNets\n"
"  Paramegers: ()\n"
"    Calls: oaMemNetCollection getMemberNets() const\n"
"    Signature: getMemberNets|simple-oaMemNetCollection|simple-oaBoolean,\n"
"    BrowseData: 1\n"
"    oaNet::getMemberNets\n"
"    This function returns a collection of nets of which this net is a member. For example, if a design contains scalar net a and bundle net x,y,a , then this collection for net a contains both nets a and x,y,a .\n"
"    In particular:\n"
"    Explicit nets are always members of themselves so the collection is never empty for such nets.\n"
"    Implicit nets are never returned in this collection.\n"
"    BundleNets can only be members of themselves.\n"
"    ScalarNets and busNets are members of themselves and bundleNets.\n"
"    BusNetBits are members of all busNets where the bit is present so busNetBit A[1] is a member of A[2:0]\n"
"    A single-bit busNet will only return itself\n"
"    Nets are members of bundles that contain a member that is in exactly the same form as the specified net\n"
"    A[1:0] is not a member of A[4:0]\n"
"    A[1:0] is not a member of A[0:1]\n"
"    Where a net occurs multiple times in a bundle, it will occur multiple times in this collection. See oaMemNetIter for details about iterating over this collection.\n"
"    unique\n"
"    Specifies that only the preferred equivalent nets are included in the collection\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: oaMemNetCollection getMemberNets(oaBoolean unique) const\n"
"    Signature: getMemberNets|simple-oaMemNetCollection|simple-oaBoolean,\n"
"    oaNet::getMemberNets\n"
"    This function returns a collection of nets of which this net is a member. For example, if a design contains scalar net a and bundle net x,y,a , then this collection for net a contains both nets a and x,y,a .\n"
"    In particular:\n"
"    Explicit nets are always members of themselves so the collection is never empty for such nets.\n"
"    Implicit nets are never returned in this collection.\n"
"    BundleNets can only be members of themselves.\n"
"    ScalarNets and busNets are members of themselves and bundleNets.\n"
"    BusNetBits are members of all busNets where the bit is present so busNetBit A[1] is a member of A[2:0]\n"
"    A single-bit busNet will only return itself\n"
"    Nets are members of bundles that contain a member that is in exactly the same form as the specified net\n"
"    A[1:0] is not a member of A[4:0]\n"
"    A[1:0] is not a member of A[0:1]\n"
"    Where a net occurs multiple times in a bundle, it will occur multiple times in this collection. See oaMemNetIter for details about iterating over this collection.\n"
"    unique\n"
"    Specifies that only the preferred equivalent nets are included in the collection\n"
;

static PyObject*
oaNet_getMemberNets(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaMemNetCollection* result= new oaMemNetCollection(data.DataCall()->getMemberNets());
            return PyoaMemNetCollection_FromoaMemNetCollection(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            oaMemNetCollection* result= new oaMemNetCollection(data.DataCall()->getMemberNets(p1.Data()));
            return PyoaMemNetCollection_FromoaMemNetCollection(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaNet, function: getMemberNets, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getMemberNetsIter_doc[] = 
"Class: oaNet, Function: getMemberNetsIter\n"
"  Paramegers: ()\n"
"    Calls: oaMemNetIter getMemberNetsIter() const\n"
"    Signature: getMemberNetsIter|simple-oaMemNetIter|simple-oaBoolean,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: oaNet::getMemberNets\n"
"    This function returns a collection of nets of which this net is a member. For example, if a design contains scalar net a and bundle net x,y,a , then this collection for net a contains both nets a and x,y,a .\n"
"    In particular:\n"
"    Explicit nets are always members of themselves so the collection is never empty for such nets.\n"
"    Implicit nets are never returned in this collection.\n"
"    BundleNets can only be members of themselves.\n"
"    ScalarNets and busNets are members of themselves and bundleNets.\n"
"    BusNetBits are members of all busNets where the bit is present so busNetBit A[1] is a member of A[2:0]\n"
"    A single-bit busNet will only return itself\n"
"    Nets are members of bundles that contain a member that is in exactly the same form as the specified net\n"
"    A[1:0] is not a member of A[4:0]\n"
"    A[1:0] is not a member of A[0:1]\n"
"    Where a net occurs multiple times in a bundle, it will occur multiple times in this collection. See oaMemNetIter for details about iterating over this collection.\n"
"    unique\n"
"    Specifies that only the preferred equivalent nets are included in the collection\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: oaMemNetIter getMemberNetsIter(oaBoolean unique) const\n"
"    Signature: getMemberNetsIter|simple-oaMemNetIter|simple-oaBoolean,\n"
"    This function returns an Iterator over the following collection: oaNet::getMemberNets\n"
"    This function returns a collection of nets of which this net is a member. For example, if a design contains scalar net a and bundle net x,y,a , then this collection for net a contains both nets a and x,y,a .\n"
"    In particular:\n"
"    Explicit nets are always members of themselves so the collection is never empty for such nets.\n"
"    Implicit nets are never returned in this collection.\n"
"    BundleNets can only be members of themselves.\n"
"    ScalarNets and busNets are members of themselves and bundleNets.\n"
"    BusNetBits are members of all busNets where the bit is present so busNetBit A[1] is a member of A[2:0]\n"
"    A single-bit busNet will only return itself\n"
"    Nets are members of bundles that contain a member that is in exactly the same form as the specified net\n"
"    A[1:0] is not a member of A[4:0]\n"
"    A[1:0] is not a member of A[0:1]\n"
"    Where a net occurs multiple times in a bundle, it will occur multiple times in this collection. See oaMemNetIter for details about iterating over this collection.\n"
"    unique\n"
"    Specifies that only the preferred equivalent nets are included in the collection\n"
;

static PyObject*
oaNet_getMemberNetsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaMemNetIter* result= new oaMemNetIter(data.DataCall()->getMemberNets());
            return PyoaMemNetIter_FromoaMemNetIter(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaBoolean)
    {
        PyParamoaBoolean p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaBoolean_Convert,&p1)) {
            oaMemNetIter* result= new oaMemNetIter(data.DataCall()->getMemberNets(p1.Data()));
            return PyoaMemNetIter_FromoaMemNetIter(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaNet, function: getMemberNetsIter, Choices are:\n"
        "    ()\n"
        "    (oaBoolean)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getName_doc[] = 
"Class: oaNet, Function: getName\n"
"  Paramegers: (oaName)\n"
"    Calls: void getName(oaName& name) const\n"
"    Signature: getName|void-void|ref-oaName,\n"
"    BrowseData: 0,oaName\n"
"    This function returns the name of this net in the name argument.\n"
"  Paramegers: (oaNameSpace,oaString)\n"
"    Calls: void getName(const oaNameSpace& ns,oaString& name) const\n"
"    Signature: getName|void-void|cref-oaNameSpace,ref-oaString,\n"
"    This function returns the name of this net in the specified nameSpace in the specified name string.\n"
;

static PyObject*
oaNet_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: (oaName)
    {
        PyParamoaName p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaName_Convert,&p1)) {
            data.DataCall()->getName(p1.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    // Case: (oaNameSpace,oaString)
    {
        PyParamoaNameSpace p1;
        PyParamoaString p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaNameSpace_Convert,&p1,
              &PyoaString_Convert,&p2)) {
            data.DataCall()->getName(p1.Data(),p2.Data());
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaNet, function: getName, Choices are:\n"
        "    (oaName)\n"
        "    (oaNameSpace,oaString)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getNumBits_doc[] = 
"Class: oaNet, Function: getNumBits\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumBits() const\n"
"    Signature: getNumBits|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of bits in this net.\n"
;

static PyObject*
oaNet_getNumBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumBits());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getOccNet_doc[] = 
"Class: oaNet, Function: getOccNet\n"
"  Paramegers: ()\n"
"    Calls: oaOccNet* getOccNet() const\n"
"    Signature: getOccNet|ptr-oaOccNet|\n"
"    BrowseData: 1\n"
"    This function returns the occurrence net that is the reflection of this block net in the context of the top occurrence of the design that contains the net. There may be multiple occurrences of the block net, but only one is selected as the representative occurrence net. The choice will remain consistent until the connectivity of the net (either in the block or the module domains) changes.\n"
;

static PyObject*
oaNet_getOccNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaOccNetp result= (data.DataCall()->getOccNet());
        return PyoaOccNet_FromoaOccNet(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getOccNets_doc[] = 
"Class: oaNet, Function: getOccNets\n"
"  Paramegers: (oaOccurrence)\n"
"    Calls: oaCollection_oaOccNet_oaNet getOccNets(const oaOccurrence* top) const\n"
"    Signature: getOccNets|simple-oaCollection_oaOccNet_oaNet|cptr-oaOccurrence,\n"
"    This function returns a collection of the occurrences of this net in the occurrence hierarchy with the specified top occurrence.\n"
"    top\n"
"    The top Occurrence in the hierarchy from which the collection of occurrence nets is to be obtained for this net\n"
;

static PyObject*
oaNet_getOccNets(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaOccurrence p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccurrence_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaCollection_oaOccNet_oaNet* result= new oaCollection_oaOccNet_oaNet(data.DataCall()->getOccNets(p1.Data()));
        return PyoaCollection_oaOccNet_oaNet_FromoaCollection_oaOccNet_oaNet(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getOccNetsIter_doc[] = 
"Class: oaNet, Function: getOccNetsIter\n"
"  Paramegers: (oaOccurrence)\n"
"    Calls: oaIter_oaOccNet getOccNetsIter(const oaOccurrence* top) const\n"
"    Signature: getOccNetsIter|simple-oaIter_oaOccNet|cptr-oaOccurrence,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of the occurrences of this net in the occurrence hierarchy with the specified top occurrence.\n"
"    top\n"
"    The top Occurrence in the hierarchy from which the collection of occurrence nets is to be obtained for this net\n"
;

static PyObject*
oaNet_getOccNetsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaOccurrence p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaOccurrence_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaIter_oaOccNet* result= new oaIter_oaOccNet(data.DataCall()->getOccNets(p1.Data()));
        return PyoaIter_oaOccNet_FromoaIter_oaOccNet(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getPins_doc[] = 
"Class: oaNet, Function: getPins\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaPin_oaNet getPins() const\n"
"    Signature: getPins|simple-oaCollection_oaPin_oaNet|\n"
"    BrowseData: 1\n"
"    This function returns a collection of pins on this net.\n"
;

static PyObject*
oaNet_getPins(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaPin_oaNet* result= new oaCollection_oaPin_oaNet(data.DataCall()->getPins());
        return PyoaCollection_oaPin_oaNet_FromoaCollection_oaPin_oaNet(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getPinsIter_doc[] = 
"Class: oaNet, Function: getPinsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaPin getPinsIter() const\n"
"    Signature: getPinsIter|simple-oaIter_oaPin|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of pins on this net.\n"
;

static PyObject*
oaNet_getPinsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaPin* result= new oaIter_oaPin(data.DataCall()->getPins());
        return PyoaIter_oaPin_FromoaIter_oaPin(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getPriority_doc[] = 
"Class: oaNet, Function: getPriority\n"
"  Paramegers: ()\n"
"    Calls: oaInt4 getPriority() const\n"
"    Signature: getPriority|simple-oaInt4|\n"
"    BrowseData: 1\n"
"    This function returns the priority value of this net. If a priority has never been set, it will return 0.\n"
;

static PyObject*
oaNet_getPriority(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaInt4 result= (data.DataCall()->getPriority());
        return PyoaInt4_FromoaInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getRoutes_doc[] = 
"Class: oaNet, Function: getRoutes\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaRoute_oaNet getRoutes() const\n"
"    Signature: getRoutes|simple-oaCollection_oaRoute_oaNet|\n"
"    BrowseData: 1\n"
"    This function returns a collection of routes in this net.\n"
;

static PyObject*
oaNet_getRoutes(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaRoute_oaNet* result= new oaCollection_oaRoute_oaNet(data.DataCall()->getRoutes());
        return PyoaCollection_oaRoute_oaNet_FromoaCollection_oaRoute_oaNet(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getRoutesIter_doc[] = 
"Class: oaNet, Function: getRoutesIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaRoute getRoutesIter() const\n"
"    Signature: getRoutesIter|simple-oaIter_oaRoute|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of routes in this net.\n"
;

static PyObject*
oaNet_getRoutesIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaRoute* result= new oaIter_oaRoute(data.DataCall()->getRoutes());
        return PyoaIter_oaRoute_FromoaIter_oaRoute(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getShapes_doc[] = 
"Class: oaNet, Function: getShapes\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaShape_oaNet getShapes() const\n"
"    Signature: getShapes|simple-oaCollection_oaShape_oaNet|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns a collection of shapes on this net. An application can customize the collection of shapes on a net to include shapes (pathSegs) that are part of routes on the same net or shapes that implement pins on all the terminals on that net. The default is to include shapes in routes on the same net. The collection always includes shapes that are explicitly on that net.\n"
"    The filter flags can be specified as a bit-wise OR combination of the following: oacShapeIterNetOnly, oacShapeIterNetRoutes or oacShapeIterNetPins. oacShapeIterNetOnly is for stand-alone use only when a collection of shapes explicitly on the net is required. It is implied for oacShapeIterNetRoutes and oacShapeIterNetPins which can be used together and return the shapes in routes on this net or shapes implementing pins on this net's terminals. Note that the collection will never include shapes contained within vias associated with the net or the net's routes, and it will never include shapes contained within vias or instances associated with the net s pins.\n"
"    filterFlags\n"
"    This value specifies the customization required by an application\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaShape_oaNet getShapes(oaUInt4 filterFlags) const\n"
"    Signature: getShapes|simple-oaCollection_oaShape_oaNet|simple-oaUInt4,\n"
"    This function returns a collection of shapes on this net. An application can customize the collection of shapes on a net to include shapes (pathSegs) that are part of routes on the same net or shapes that implement pins on all the terminals on that net. The default is to include shapes in routes on the same net. The collection always includes shapes that are explicitly on that net.\n"
"    The filter flags can be specified as a bit-wise OR combination of the following: oacShapeIterNetOnly, oacShapeIterNetRoutes or oacShapeIterNetPins. oacShapeIterNetOnly is for stand-alone use only when a collection of shapes explicitly on the net is required. It is implied for oacShapeIterNetRoutes and oacShapeIterNetPins which can be used together and return the shapes in routes on this net or shapes implementing pins on this net's terminals. Note that the collection will never include shapes contained within vias associated with the net or the net's routes, and it will never include shapes contained within vias or instances associated with the net s pins.\n"
"    filterFlags\n"
"    This value specifies the customization required by an application\n"
;

static PyObject*
oaNet_getShapes(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaShape_oaNet* result= new oaCollection_oaShape_oaNet(data.DataCall()->getShapes());
            return PyoaCollection_oaShape_oaNet_FromoaCollection_oaShape_oaNet(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaShape_oaNet* result= new oaCollection_oaShape_oaNet(data.DataCall()->getShapes(p1.Data()));
            return PyoaCollection_oaShape_oaNet_FromoaCollection_oaShape_oaNet(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaNet, function: getShapes, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getShapesIter_doc[] = 
"Class: oaNet, Function: getShapesIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaShape getShapesIter() const\n"
"    Signature: getShapesIter|simple-oaIter_oaShape|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of shapes on this net. An application can customize the collection of shapes on a net to include shapes (pathSegs) that are part of routes on the same net or shapes that implement pins on all the terminals on that net. The default is to include shapes in routes on the same net. The collection always includes shapes that are explicitly on that net.\n"
"    The filter flags can be specified as a bit-wise OR combination of the following: oacShapeIterNetOnly, oacShapeIterNetRoutes or oacShapeIterNetPins. oacShapeIterNetOnly is for stand-alone use only when a collection of shapes explicitly on the net is required. It is implied for oacShapeIterNetRoutes and oacShapeIterNetPins which can be used together and return the shapes in routes on this net or shapes implementing pins on this net's terminals. Note that the collection will never include shapes contained within vias associated with the net or the net's routes, and it will never include shapes contained within vias or instances associated with the net s pins.\n"
"    filterFlags\n"
"    This value specifies the customization required by an application\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaShape getShapesIter(oaUInt4 filterFlags) const\n"
"    Signature: getShapesIter|simple-oaIter_oaShape|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of shapes on this net. An application can customize the collection of shapes on a net to include shapes (pathSegs) that are part of routes on the same net or shapes that implement pins on all the terminals on that net. The default is to include shapes in routes on the same net. The collection always includes shapes that are explicitly on that net.\n"
"    The filter flags can be specified as a bit-wise OR combination of the following: oacShapeIterNetOnly, oacShapeIterNetRoutes or oacShapeIterNetPins. oacShapeIterNetOnly is for stand-alone use only when a collection of shapes explicitly on the net is required. It is implied for oacShapeIterNetRoutes and oacShapeIterNetPins which can be used together and return the shapes in routes on this net or shapes implementing pins on this net's terminals. Note that the collection will never include shapes contained within vias associated with the net or the net's routes, and it will never include shapes contained within vias or instances associated with the net s pins.\n"
"    filterFlags\n"
"    This value specifies the customization required by an application\n"
;

static PyObject*
oaNet_getShapesIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaShape* result= new oaIter_oaShape(data.DataCall()->getShapes());
            return PyoaIter_oaShape_FromoaIter_oaShape(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaShape* result= new oaIter_oaShape(data.DataCall()->getShapes(p1.Data()));
            return PyoaIter_oaShape_FromoaIter_oaShape(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaNet, function: getShapesIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getSigType_doc[] = 
"Class: oaNet, Function: getSigType\n"
"  Paramegers: ()\n"
"    Calls: oaSigType getSigType() const\n"
"    Signature: getSigType|simple-oaSigType|\n"
"    BrowseData: 1\n"
"    This function returns the signal type of this net.\n"
;

static PyObject*
oaNet_getSigType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaSigType* result= new oaSigType(data.DataCall()->getSigType());
        return PyoaSigType_FromoaSigType(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getSingleBitMembers_doc[] = 
"Class: oaNet, Function: getSingleBitMembers\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaBitNet_oaNet getSingleBitMembers() const\n"
"    Signature: getSingleBitMembers|simple-oaCollection_oaBitNet_oaNet|\n"
"    BrowseData: 1\n"
"    This function returns a collection of single-bit member nets that are in this net. If this net is a single-bit net, the collection contains itself. If this net is a busNet, the collection contains all of the corresponding busNetBits.\n"
;

static PyObject*
oaNet_getSingleBitMembers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaBitNet_oaNet* result= new oaCollection_oaBitNet_oaNet(data.DataCall()->getSingleBitMembers());
        return PyoaCollection_oaBitNet_oaNet_FromoaCollection_oaBitNet_oaNet(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getSingleBitMembersIter_doc[] = 
"Class: oaNet, Function: getSingleBitMembersIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaBitNet getSingleBitMembersIter() const\n"
"    Signature: getSingleBitMembersIter|simple-oaIter_oaBitNet|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of single-bit member nets that are in this net. If this net is a single-bit net, the collection contains itself. If this net is a busNet, the collection contains all of the corresponding busNetBits.\n"
;

static PyObject*
oaNet_getSingleBitMembersIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaBitNet* result= new oaIter_oaBitNet(data.DataCall()->getSingleBitMembers());
        return PyoaIter_oaBitNet_FromoaIter_oaBitNet(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getSource_doc[] = 
"Class: oaNet, Function: getSource\n"
"  Paramegers: ()\n"
"    Calls: oaSource getSource() const\n"
"    Signature: getSource|simple-oaSource|\n"
"    BrowseData: 1\n"
"    This function returns the source value of this net.\n"
;

static PyObject*
oaNet_getSource(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaSource* result= new oaSource(data.DataCall()->getSource());
        return PyoaSource_FromoaSource(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getSteiners_doc[] = 
"Class: oaNet, Function: getSteiners\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaSteiner_oaNet getSteiners() const\n"
"    Signature: getSteiners|simple-oaCollection_oaSteiner_oaNet|\n"
"    BrowseData: 1\n"
"    This function returns a collection of Steiners associated with this net.\n"
;

static PyObject*
oaNet_getSteiners(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaCollection_oaSteiner_oaNet* result= new oaCollection_oaSteiner_oaNet(data.DataCall()->getSteiners());
        return PyoaCollection_oaSteiner_oaNet_FromoaCollection_oaSteiner_oaNet(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getSteinersIter_doc[] = 
"Class: oaNet, Function: getSteinersIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaSteiner getSteinersIter() const\n"
"    Signature: getSteinersIter|simple-oaIter_oaSteiner|\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of Steiners associated with this net.\n"
;

static PyObject*
oaNet_getSteinersIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaIter_oaSteiner* result= new oaIter_oaSteiner(data.DataCall()->getSteiners());
        return PyoaIter_oaSteiner_FromoaIter_oaSteiner(result,0,NULL);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getTerms_doc[] = 
"Class: oaNet, Function: getTerms\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaTerm_oaNet getTerms() const\n"
"    Signature: getTerms|simple-oaCollection_oaTerm_oaNet|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    oaNet::getTerms\n"
"    This function returns a collection of terminals in this modNet. By default, the collection only contains explicit terminals associated with this net. When oacTermIterAll is included in filterFlags , the collection will contain all terminals associated with this net, including implicit terminals.\n"
"    When oacTermIterEquivNets is included in filterFlags , the collection will contain all terminals in the set of nets that are equivalent to this net.\n"
"    filterFlags\n"
"    Specifies which types of terminals to include in the collection\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaTerm_oaNet getTerms(oaUInt4 filterflags) const\n"
"    Signature: getTerms|simple-oaCollection_oaTerm_oaNet|simple-oaUInt4,\n"
"    oaNet::getTerms\n"
"    This function returns a collection of terminals in this modNet. By default, the collection only contains explicit terminals associated with this net. When oacTermIterAll is included in filterFlags , the collection will contain all terminals associated with this net, including implicit terminals.\n"
"    When oacTermIterEquivNets is included in filterFlags , the collection will contain all terminals in the set of nets that are equivalent to this net.\n"
"    filterFlags\n"
"    Specifies which types of terminals to include in the collection\n"
;

static PyObject*
oaNet_getTerms(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaTerm_oaNet* result= new oaCollection_oaTerm_oaNet(data.DataCall()->getTerms());
            return PyoaCollection_oaTerm_oaNet_FromoaCollection_oaTerm_oaNet(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaTerm_oaNet* result= new oaCollection_oaTerm_oaNet(data.DataCall()->getTerms(p1.Data()));
            return PyoaCollection_oaTerm_oaNet_FromoaCollection_oaTerm_oaNet(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaNet, function: getTerms, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getTermsIter_doc[] = 
"Class: oaNet, Function: getTermsIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaTerm getTermsIter() const\n"
"    Signature: getTermsIter|simple-oaIter_oaTerm|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: oaNet::getTerms\n"
"    This function returns a collection of terminals in this modNet. By default, the collection only contains explicit terminals associated with this net. When oacTermIterAll is included in filterFlags , the collection will contain all terminals associated with this net, including implicit terminals.\n"
"    When oacTermIterEquivNets is included in filterFlags , the collection will contain all terminals in the set of nets that are equivalent to this net.\n"
"    filterFlags\n"
"    Specifies which types of terminals to include in the collection\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaTerm getTermsIter(oaUInt4 filterflags) const\n"
"    Signature: getTermsIter|simple-oaIter_oaTerm|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: oaNet::getTerms\n"
"    This function returns a collection of terminals in this modNet. By default, the collection only contains explicit terminals associated with this net. When oacTermIterAll is included in filterFlags , the collection will contain all terminals associated with this net, including implicit terminals.\n"
"    When oacTermIterEquivNets is included in filterFlags , the collection will contain all terminals in the set of nets that are equivalent to this net.\n"
"    filterFlags\n"
"    Specifies which types of terminals to include in the collection\n"
;

static PyObject*
oaNet_getTermsIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaTerm* result= new oaIter_oaTerm(data.DataCall()->getTerms());
            return PyoaIter_oaTerm_FromoaIter_oaTerm(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaTerm* result= new oaIter_oaTerm(data.DataCall()->getTerms(p1.Data()));
            return PyoaIter_oaTerm_FromoaIter_oaTerm(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaNet, function: getTermsIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getVias_doc[] = 
"Class: oaNet, Function: getVias\n"
"  Paramegers: ()\n"
"    Calls: oaCollection_oaVia_oaNet getVias() const\n"
"    Signature: getVias|simple-oaCollection_oaVia_oaNet|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns a collection of vias associated this net.\n"
"    filterFlags\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bits flags are defined as follows:\n"
"    oacViaIterNetOnly: the collection will only all vias associated with this net\n"
"    oacViaIterNetRoutes: the collection will only contain vias that are associated with routes\n"
"    oacViaIterNetPins: the collection will only contain the vias that are associated with pins\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaCollection_oaVia_oaNet getVias(oaUInt4 filterFlags) const\n"
"    Signature: getVias|simple-oaCollection_oaVia_oaNet|simple-oaUInt4,\n"
"    This function returns a collection of vias associated this net.\n"
"    filterFlags\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bits flags are defined as follows:\n"
"    oacViaIterNetOnly: the collection will only all vias associated with this net\n"
"    oacViaIterNetRoutes: the collection will only contain vias that are associated with routes\n"
"    oacViaIterNetPins: the collection will only contain the vias that are associated with pins\n"
;

static PyObject*
oaNet_getVias(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaCollection_oaVia_oaNet* result= new oaCollection_oaVia_oaNet(data.DataCall()->getVias());
            return PyoaCollection_oaVia_oaNet_FromoaCollection_oaVia_oaNet(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaCollection_oaVia_oaNet* result= new oaCollection_oaVia_oaNet(data.DataCall()->getVias(p1.Data()));
            return PyoaCollection_oaVia_oaNet_FromoaCollection_oaVia_oaNet(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaNet, function: getVias, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_getViasIter_doc[] = 
"Class: oaNet, Function: getViasIter\n"
"  Paramegers: ()\n"
"    Calls: oaIter_oaVia getViasIter() const\n"
"    Signature: getViasIter|simple-oaIter_oaVia|simple-oaUInt4,\n"
"    BrowseData: 1\n"
"    This function returns an Iterator over the following collection: This function returns a collection of vias associated this net.\n"
"    filterFlags\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bits flags are defined as follows:\n"
"    oacViaIterNetOnly: the collection will only all vias associated with this net\n"
"    oacViaIterNetRoutes: the collection will only contain vias that are associated with routes\n"
"    oacViaIterNetPins: the collection will only contain the vias that are associated with pins\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaIter_oaVia getViasIter(oaUInt4 filterFlags) const\n"
"    Signature: getViasIter|simple-oaIter_oaVia|simple-oaUInt4,\n"
"    This function returns an Iterator over the following collection: This function returns a collection of vias associated this net.\n"
"    filterFlags\n"
"    filterFlags\n"
"    Specifies what the collection contains. The bits flags are defined as follows:\n"
"    oacViaIterNetOnly: the collection will only all vias associated with this net\n"
"    oacViaIterNetRoutes: the collection will only contain vias that are associated with routes\n"
"    oacViaIterNetPins: the collection will only contain the vias that are associated with pins\n"
;

static PyObject*
oaNet_getViasIter(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            oaIter_oaVia* result= new oaIter_oaVia(data.DataCall()->getVias());
            return PyoaIter_oaVia_FromoaIter_oaVia(result,0,NULL);
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            oaIter_oaVia* result= new oaIter_oaVia(data.DataCall()->getVias(p1.Data()));
            return PyoaIter_oaVia_FromoaIter_oaVia(result,0,NULL);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaNet, function: getViasIter, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_hasDefaultConstraintGroup_doc[] = 
"Class: oaNet, Function: hasDefaultConstraintGroup\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean hasDefaultConstraintGroup() const\n"
"    Signature: hasDefaultConstraintGroup|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean indicating whether there are constraints associated with this net.\n"
"    Todo\n"
"    Check function description.\n"
;

static PyObject*
oaNet_hasDefaultConstraintGroup(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->hasDefaultConstraintGroup());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_isEmpty_doc[] = 
"Class: oaNet, Function: isEmpty\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isEmpty() const\n"
"    Signature: isEmpty|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value that indicates if this net has any objects attached to it or associated with it.\n"
;

static PyObject*
oaNet_isEmpty(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isEmpty());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_isGlobal_doc[] = 
"Class: oaNet, Function: isGlobal\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isGlobal() const\n"
"    Signature: isGlobal|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value that indicates if this net is a global net.\n"
;

static PyObject*
oaNet_isGlobal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isGlobal());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_isImplicit_doc[] = 
"Class: oaNet, Function: isImplicit\n"
"  Paramegers: ()\n"
"    Calls: oaBoolean isImplicit() const\n"
"    Signature: isImplicit|simple-oaBoolean|\n"
"    BrowseData: 1\n"
"    This function returns a boolean value that indicates if this net is implicit, having been automatically created as a result of the creation of a bundleNet or busNet.\n"
;

static PyObject*
oaNet_isImplicit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBoolean result= (data.DataCall()->isImplicit());
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_merge_doc[] = 
"Class: oaNet, Function: merge\n"
"  Paramegers: (oaNet)\n"
"    Calls: void merge(oaNet* fromNet)\n"
"    Signature: merge|void-void|ptr-oaNet,\n"
"    This function merges the specified fromNet into this net. The two nets must have the same number of bits. All of the following objects in the fromNet are transferred to this net: terminals, instTerms, figures, guides, properties, and textDisplays.\n"
"    Net attributes are merged, with the greater of the net priorities between the two nets retained. If the fromNet is global, this net is made global.\n"
"    If both nets have properties of the same name, the properties on this net are retained.\n"
"    If the fromNet is equivalent to other nets, those nets are also made equivalent to this net. If the nets are multi-bit nets, equivalences between scalar members are established for those members that are not implicit. For example, if there are nets \"x,y\", \"a,b\", \"x\", \"y\", \"a\", and \"b\" and \"a,b\" is merged into \"x,y\", net \"a\" is made equivalent to \"x\" and net \"b\" is made equivalent to \"y.\"\n"
"    The fromNet is then destroyed.\n"
"    oacCannotMergeNetsWithDiffNumBits\n"
"    oacMergeNetsNotInSameBlock\n"
"    oacMergeNetsMustBeInUniqueOccHier\n"
"    oacTermMustJoinSameNet\n"
;

static PyObject*
oaNet_merge(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaNet p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaNet_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->merge(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_scalarize_doc[] = 
"Class: oaNet, Function: scalarize\n"
"  Paramegers: ()\n"
"    Calls: void scalarize()\n"
"    Signature: scalarize|void-void|\n"
"    BrowseData: 0\n"
"    This function insures that the bitNets associated with this net have been promoted to the explicit state so that they can support implementation data such as shapes and routes.\n"
"    If this net is a multibit net, this function insures that all constituent bitNets are promoted to the explicit state. The multibit net is then demoted to the implicit state so that no implementation data can be associated with it. When a net is demoted to the implicit state, associated implementation data is removed from it.\n"
"    oacCannotScalarizeImplicitNet\n"
;

static PyObject*
oaNet_scalarize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        data.DataCall()->scalarize();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_setGlobal_doc[] = 
"Class: oaNet, Function: setGlobal\n"
"  Paramegers: (oaBoolean)\n"
"    Calls: void setGlobal(oaBoolean isGlobal)\n"
"    Signature: setGlobal|void-void|simple-oaBoolean,\n"
"    This function sets the global attribute of this net.\n"
;

static PyObject*
oaNet_setGlobal(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaBoolean p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaBoolean_Convert,&p1)) {
        data.DataCall()->setGlobal(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_setPriority_doc[] = 
"Class: oaNet, Function: setPriority\n"
"  Paramegers: (oaInt4)\n"
"    Calls: void setPriority(oaInt4 priority)\n"
"    Signature: setPriority|void-void|simple-oaInt4,\n"
"    This function sets the priority value for this net. The specified priority value must be in the range of -128 to 128. The default priority is 0 if no set has been done.\n"
"    oacInvalidNetPriority\n"
;

static PyObject*
oaNet_setPriority(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaInt4_Convert,&p1)) {
        data.DataCall()->setPriority(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_setSigType_doc[] = 
"Class: oaNet, Function: setSigType\n"
"  Paramegers: (oaSigType)\n"
"    Calls: void setSigType(const oaSigType& sigType)\n"
"    Signature: setSigType|void-void|cref-oaSigType,\n"
"    This function sets the sigType attribute of this net to the specified value.\n"
"    Note: The sigType of an oaNet can be different from the sigType of its corresponding oaModNet . In other words, this function sets the sigType on the this net in the block domain only.\n"
;

static PyObject*
oaNet_setSigType(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaSigType p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaSigType_Convert,&p1)) {
        data.DataCall()->setSigType(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_setSource_doc[] = 
"Class: oaNet, Function: setSource\n"
"  Paramegers: (oaSource)\n"
"    Calls: void setSource(oaSource source)\n"
"    Signature: setSource|void-void|simple-oaSource,\n"
"    This function sets the source for this net to the specified value.\n"
;

static PyObject*
oaNet_setSource(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaSource p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaSource_Convert,&p1)) {
        data.DataCall()->setSource(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_transfer_doc[] = 
"Class: oaNet, Function: transfer\n"
"  Paramegers: (oaNet)\n"
"    Calls: void transfer(oaNet* fromNet)\n"
"    Signature: transfer|void-void|ptr-oaNet,\n"
"    This function transfers objects from the specified fromNet to this net. Shapes, routes, terminals, and instance terminals are moved from the specified net to this net. Properties are copied or merged and textDisplays are updated accordingly.\n"
"    oacCannotTransferNetWithInstTerm\n"
"    oacCannotTransferNetWithTerm\n"
"    oacTransferNetsNotInSameBlock\n"
"    oacTransferNetsMustBeInUniqueOccHier\n"
;

static PyObject*
oaNet_transfer(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetObject* self=(PyoaNetObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    PyParamoaNet p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaNet_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->transfer(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_isNull_doc[] =
"Class: oaNet, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaNet_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaNet data;
    int convert_status=PyoaNet_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaNet_assign_doc[] = 
"Class: oaNet, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaNet_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaNet data;
  int convert_status=PyoaNet_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaNet p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaNet_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaNet_methodlist[] = {
    {"destroy",(PyCFunction)oaNet_destroy,METH_VARARGS,oaNet_destroy_doc},
    {"getBit",(PyCFunction)oaNet_getBit,METH_VARARGS,oaNet_getBit_doc},
    {"getDefaultConstraintGroup",(PyCFunction)oaNet_getDefaultConstraintGroup,METH_VARARGS,oaNet_getDefaultConstraintGroup_doc},
    {"getGuides",(PyCFunction)oaNet_getGuides,METH_VARARGS,oaNet_getGuides_doc},
    {"getGuidesIter",(PyCFunction)oaNet_getGuidesIter,METH_VARARGS,oaNet_getGuidesIter_doc},
    {"getInstTerms",(PyCFunction)oaNet_getInstTerms,METH_VARARGS,oaNet_getInstTerms_doc},
    {"getInstTermsIter",(PyCFunction)oaNet_getInstTermsIter,METH_VARARGS,oaNet_getInstTermsIter_doc},
    {"getMemberNets",(PyCFunction)oaNet_getMemberNets,METH_VARARGS,oaNet_getMemberNets_doc},
    {"getMemberNetsIter",(PyCFunction)oaNet_getMemberNetsIter,METH_VARARGS,oaNet_getMemberNetsIter_doc},
    {"getName",(PyCFunction)oaNet_getName,METH_VARARGS,oaNet_getName_doc},
    {"getNumBits",(PyCFunction)oaNet_getNumBits,METH_VARARGS,oaNet_getNumBits_doc},
    {"getOccNet",(PyCFunction)oaNet_getOccNet,METH_VARARGS,oaNet_getOccNet_doc},
    {"getOccNets",(PyCFunction)oaNet_getOccNets,METH_VARARGS,oaNet_getOccNets_doc},
    {"getOccNetsIter",(PyCFunction)oaNet_getOccNetsIter,METH_VARARGS,oaNet_getOccNetsIter_doc},
    {"getPins",(PyCFunction)oaNet_getPins,METH_VARARGS,oaNet_getPins_doc},
    {"getPinsIter",(PyCFunction)oaNet_getPinsIter,METH_VARARGS,oaNet_getPinsIter_doc},
    {"getPriority",(PyCFunction)oaNet_getPriority,METH_VARARGS,oaNet_getPriority_doc},
    {"getRoutes",(PyCFunction)oaNet_getRoutes,METH_VARARGS,oaNet_getRoutes_doc},
    {"getRoutesIter",(PyCFunction)oaNet_getRoutesIter,METH_VARARGS,oaNet_getRoutesIter_doc},
    {"getShapes",(PyCFunction)oaNet_getShapes,METH_VARARGS,oaNet_getShapes_doc},
    {"getShapesIter",(PyCFunction)oaNet_getShapesIter,METH_VARARGS,oaNet_getShapesIter_doc},
    {"getSigType",(PyCFunction)oaNet_getSigType,METH_VARARGS,oaNet_getSigType_doc},
    {"getSingleBitMembers",(PyCFunction)oaNet_getSingleBitMembers,METH_VARARGS,oaNet_getSingleBitMembers_doc},
    {"getSingleBitMembersIter",(PyCFunction)oaNet_getSingleBitMembersIter,METH_VARARGS,oaNet_getSingleBitMembersIter_doc},
    {"getSource",(PyCFunction)oaNet_getSource,METH_VARARGS,oaNet_getSource_doc},
    {"getSteiners",(PyCFunction)oaNet_getSteiners,METH_VARARGS,oaNet_getSteiners_doc},
    {"getSteinersIter",(PyCFunction)oaNet_getSteinersIter,METH_VARARGS,oaNet_getSteinersIter_doc},
    {"getTerms",(PyCFunction)oaNet_getTerms,METH_VARARGS,oaNet_getTerms_doc},
    {"getTermsIter",(PyCFunction)oaNet_getTermsIter,METH_VARARGS,oaNet_getTermsIter_doc},
    {"getVias",(PyCFunction)oaNet_getVias,METH_VARARGS,oaNet_getVias_doc},
    {"getViasIter",(PyCFunction)oaNet_getViasIter,METH_VARARGS,oaNet_getViasIter_doc},
    {"hasDefaultConstraintGroup",(PyCFunction)oaNet_hasDefaultConstraintGroup,METH_VARARGS,oaNet_hasDefaultConstraintGroup_doc},
    {"isEmpty",(PyCFunction)oaNet_isEmpty,METH_VARARGS,oaNet_isEmpty_doc},
    {"isGlobal",(PyCFunction)oaNet_isGlobal,METH_VARARGS,oaNet_isGlobal_doc},
    {"isImplicit",(PyCFunction)oaNet_isImplicit,METH_VARARGS,oaNet_isImplicit_doc},
    {"merge",(PyCFunction)oaNet_merge,METH_VARARGS,oaNet_merge_doc},
    {"scalarize",(PyCFunction)oaNet_scalarize,METH_VARARGS,oaNet_scalarize_doc},
    {"setGlobal",(PyCFunction)oaNet_setGlobal,METH_VARARGS,oaNet_setGlobal_doc},
    {"setPriority",(PyCFunction)oaNet_setPriority,METH_VARARGS,oaNet_setPriority_doc},
    {"setSigType",(PyCFunction)oaNet_setSigType,METH_VARARGS,oaNet_setSigType_doc},
    {"setSource",(PyCFunction)oaNet_setSource,METH_VARARGS,oaNet_setSource_doc},
    {"transfer",(PyCFunction)oaNet_transfer,METH_VARARGS,oaNet_transfer_doc},
    {"isNull",(PyCFunction)oaNet_tp_isNull,METH_VARARGS,oaNet_isNull_doc},
    {"assign",(PyCFunction)oaNet_tp_assign,METH_VARARGS,oaNet_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNet_doc[] = 
"Class: oaNet\n"
"  The oaNet class is an abstract base class for scalar and multi-bit nets that are part of the design's physical description. Nets represent the logical connectivity within a block of a design. Nets connect to terminals, which are the logical connection points on instances of the net's block. Nets also connect to instTerms that represent connections to the lower-level instances in the net's block.\n"
"  oaNet objects are always in the block domain. Nets span the domains in a design. An oaNet may have one or more equivalent oaModNet's in the module hierarchy and will have an equivalent oaOccNet in the occurrence hierarchy.\n"
"  All nets have names. These names can be assigned by the creator. For scalar nets, a name can be automatically assigned by the database.\n"
"  Multi-bit nets represent a collection of logical connections. Nets can include busNets having a single base name with an index range, or they can include bundleNets, which are a more complex grouping of nets. Multi-bit nets can have overlapping names. For example, busNets addr<7:0> and addr<3:0> .\n"
"  All busNets with the same root name are managed by an oaBusNetDef . The busNetDef tracks:\n"
"  lowest numbered bit of all of the associated busNets\n"
"  highest numbered bit of all of the associated busNets\n"
"  busNets with the same base name\n"
"  associated busNetBits\n"
"  The busNetBits are automatically created for each bit of a busNet, if they do not already exist. They are available for those applications performing scalarized connectivity traversal of the data.\n"
"  Bundle nets can contain scalar nets or buses. When an oaBundleNet is created, the constituent scalarNets and busNets are automatically created in addition to the bundleNet itself.\n"
"  All automatically created net objects are considered \"implicit.\" Filter flags can be used by net iterators so that implicit nets are not visited when traversing. Implicit nets are more restricted in terms of the operations that are allowed to work with them. Implicit nets can not be explicitly destroyed by the user. Certain attributes can only be set on explicit net objects--for example, parasitic confidence. Implicit nets can become explicit when a caller explicitly creates a net with the same name.\n"
"  Names are normally associated with nets. The various net objects take and return names through the general oaName object but also use the oaScalarName , oaVectorBitName , oaVectorName , and oaBundleName objects. These name objects manage the mapping of names from one nameSpace to another. For example, a net is created using the name in CDBA nameSpace; another application can retrieve the net's name in the Verilog nameSpace.\n"
"  You can have two or more nets that are equivalent. Equivalent nets are traversed separately or logically as the same net. You can only set single-bit nets equivalent to each other.\n"
"  You can associate geometric oaConnFig objects with nets: shapes, routes and guides. Nets are required in order to create other connectivity objects such as oaTerm objects.\n"
"  The oaNet class can be observed by deriving from\n"
"Constructors:\n"
"  Paramegers: (oaNet)\n"
"    Calls: (const oaNet&)\n"
"    Signature: oaNet||cref-oaNet,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaNet_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaNet",
    sizeof(PyoaNetObject),
    0,
    (destructor)oaNet_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaNet_tp_compare,	/* tp_compare */
    (reprfunc)oaNet_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaNet_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaNet_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaBlockObject_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaNet_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNet_static_create_doc[] = 
"Class: oaNet, Function: create\n"
"  Paramegers: (oaBlock,oaName)\n"
"    Calls: oaNet* create(oaBlock* block,const oaName& name)\n"
"    Signature: create|ptr-oaNet|ptr-oaBlock,cref-oaName,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates a net in the specified design with the specified name . The type of net (scalarNet, busNetBit, busNet, or bundleNet) created is determined by the specified name .\n"
"    block\n"
"    The block in which to create the net\n"
"    name\n"
"    The name of the net\n"
"    sigType\n"
"    The signal type to associate with the net; if not specified, the default is oacSignalSigType\n"
"    isGlobal\n"
"    Specifies if this net is considered global; if not specified, the default is false\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaNet\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacInvalidNetName\n"
"    oacNetExists\n"
"    oacScalarNetNameMatchesBusBaseName\n"
"  Paramegers: (oaBlock,oaName,oaSigType)\n"
"    Calls: oaNet* create(oaBlock* block,const oaName& name,oaSigType sigType)\n"
"    Signature: create|ptr-oaNet|ptr-oaBlock,cref-oaName,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates a net in the specified design with the specified name . The type of net (scalarNet, busNetBit, busNet, or bundleNet) created is determined by the specified name .\n"
"    block\n"
"    The block in which to create the net\n"
"    name\n"
"    The name of the net\n"
"    sigType\n"
"    The signal type to associate with the net; if not specified, the default is oacSignalSigType\n"
"    isGlobal\n"
"    Specifies if this net is considered global; if not specified, the default is false\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaNet\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacInvalidNetName\n"
"    oacNetExists\n"
"    oacScalarNetNameMatchesBusBaseName\n"
"  Paramegers: (oaBlock,oaName,oaSigType,oaBoolean)\n"
"    Calls: oaNet* create(oaBlock* block,const oaName& name,oaSigType sigType,oaBoolean isGlobal)\n"
"    Signature: create|ptr-oaNet|ptr-oaBlock,cref-oaName,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates a net in the specified design with the specified name . The type of net (scalarNet, busNetBit, busNet, or bundleNet) created is determined by the specified name .\n"
"    block\n"
"    The block in which to create the net\n"
"    name\n"
"    The name of the net\n"
"    sigType\n"
"    The signal type to associate with the net; if not specified, the default is oacSignalSigType\n"
"    isGlobal\n"
"    Specifies if this net is considered global; if not specified, the default is false\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaNet\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacInvalidNetName\n"
"    oacNetExists\n"
"    oacScalarNetNameMatchesBusBaseName\n"
"  Paramegers: (oaBlock,oaName,oaSigType,oaBoolean,oaBlockDomainVisibility)\n"
"    Calls: oaNet* create(oaBlock* block,const oaName& name,oaSigType sigType,oaBoolean isGlobal,oaBlockDomainVisibility view)\n"
"    Signature: create|ptr-oaNet|ptr-oaBlock,cref-oaName,simple-oaSigType,simple-oaBoolean,simple-oaBlockDomainVisibility,\n"
"    This function creates a net in the specified design with the specified name . The type of net (scalarNet, busNetBit, busNet, or bundleNet) created is determined by the specified name .\n"
"    block\n"
"    The block in which to create the net\n"
"    name\n"
"    The name of the net\n"
"    sigType\n"
"    The signal type to associate with the net; if not specified, the default is oacSignalSigType\n"
"    isGlobal\n"
"    Specifies if this net is considered global; if not specified, the default is false\n"
"    view\n"
"    Specifies whether this net is visible in the module domain\n"
"    A pointer to an oaNet\n"
"    oacBusNetBaseNameMatchesScalarName\n"
"    oacBusNetNameMatchesAutoName\n"
"    oacInvalidNetName\n"
"    oacNetExists\n"
"    oacScalarNetNameMatchesBusBaseName\n"
;

static PyObject*
oaNet_static_create(PyObject* ob, PyObject *args)
{
  try {
    // Case: (oaBlock,oaName)
    {
        PyParamoaBlock p1;
        PyParamoaName p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaName_Convert,&p2)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaNetp result= (oaNet::create(p1.Data(),p2.Data()));
            return PyoaNet_FromoaNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaName,oaSigType)
    {
        PyParamoaBlock p1;
        PyParamoaName p2;
        PyParamoaSigType p3;
        if (PyArg_ParseTuple(args,"O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaName_Convert,&p2,
              &PyoaSigType_Convert,&p3)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaNetp result= (oaNet::create(p1.Data(),p2.Data(),p3.Data()));
            return PyoaNet_FromoaNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaName,oaSigType,oaBoolean)
    {
        PyParamoaBlock p1;
        PyParamoaName p2;
        PyParamoaSigType p3;
        PyParamoaBoolean p4;
        if (PyArg_ParseTuple(args,"O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaName_Convert,&p2,
              &PyoaSigType_Convert,&p3,
              &PyoaBoolean_Convert,&p4)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaNetp result= (oaNet::create(p1.Data(),p2.Data(),p3.Data(),p4.Data()));
            return PyoaNet_FromoaNet(result);
        }
    }
    PyErr_Clear();
    // Case: (oaBlock,oaName,oaSigType,oaBoolean,oaBlockDomainVisibility)
    {
        PyParamoaBlock p1;
        PyParamoaName p2;
        PyParamoaSigType p3;
        PyParamoaBoolean p4;
        PyParamoaBlockDomainVisibility p5;
        if (PyArg_ParseTuple(args,"O&O&O&O&O&",
              &PyoaBlock_Convert,&p1,
              &PyoaName_Convert,&p2,
              &PyoaSigType_Convert,&p3,
              &PyoaBoolean_Convert,&p4,
              &PyoaBlockDomainVisibility_Convert,&p5)) {
            if (!PyValidateDbObject(p1.Data(),1)) return NULL;
            oaNetp result= (oaNet::create(p1.Data(),p2.Data(),p3.Data(),p4.Data(),p5.Data()));
            return PyoaNet_FromoaNet(result);
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Function found for class: oaNet, function: create, Choices are:\n"
        "    (oaBlock,oaName)\n"
        "    (oaBlock,oaName,oaSigType)\n"
        "    (oaBlock,oaName,oaSigType,oaBoolean)\n"
        "    (oaBlock,oaName,oaSigType,oaBoolean,oaBlockDomainVisibility)\n"
    );
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_static_find_doc[] = 
"Class: oaNet, Function: find\n"
"  Paramegers: (oaBlock,oaName)\n"
"    Calls: oaNet* find(const oaBlock* block,const oaName& name)\n"
"    Signature: find|ptr-oaNet|cptr-oaBlock,cref-oaName,\n"
"    This function searches the specified block for a net with the specified name . If found, the function returns the net. Otherwise, NULL is returned.\n"
;

static PyObject*
oaNet_static_find(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaNetp result= (oaNet::find(p1.Data(),p2.Data()));
        return PyoaNet_FromoaNet(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNet_static_isValidName_doc[] = 
"Class: oaNet, Function: isValidName\n"
"  Paramegers: (oaBlock,oaName)\n"
"    Calls: oaBoolean isValidName(const oaBlock* block,const oaName& name)\n"
"    Signature: isValidName|simple-oaBoolean|cptr-oaBlock,cref-oaName,\n"
"    This function returns a boolean value that indicates if the specified name is valid for a new oaNet in the specified block .\n"
;

static PyObject*
oaNet_static_isValidName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBlock p1;
    PyParamoaName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaBlock_Convert,&p1,
          &PyoaName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaBoolean result= (oaNet::isValidName(p1.Data(),p2.Data()));
        return PyoaBoolean_FromoaBoolean(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaNet_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaNet_static_create,METH_VARARGS,oaNet_static_create_doc},
    {"static_find",(PyCFunction)oaNet_static_find,METH_VARARGS,oaNet_static_find_doc},
    {"static_isValidName",(PyCFunction)oaNet_static_isValidName,METH_VARARGS,oaNet_static_isValidName_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaNet_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaNet_Type)<0) {
      printf("** PyType_Ready failed for: oaNet\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaNet",
           (PyObject*)(&PyoaNet_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaNet\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaNet_Type.tp_dict;
    for(method=oaNet_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaNetAttrType
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaNetAttrType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaNetAttrType_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaNetAttrTypeObject* self = (PyoaNetAttrTypeObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaNetAttrTypeEnum)
    {
        PyParamoaNetAttrTypeEnum p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaNetAttrTypeEnum_Convert,&p1)) {
            self->value = (oaAttrType*)  new oaNetAttrType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaString)
    {
        PyParamoaString p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaString_Convert,&p1)) {
            self->value = (oaAttrType*)  new oaNetAttrType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaAttrType)
    {
        PyParamoaAttrType p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaAttrType_Convert,&p1)) {
            self->value = (oaAttrType*)  new oaNetAttrType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaNetAttrType)
    {
        PyParamoaNetAttrType p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaNetAttrType_Convert,&p1)) {
            self->value=(oaAttrType*)  new oaNetAttrType(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaNetAttrType, Choices are:\n"
        "    (oaNetAttrTypeEnum)\n"
        "    (oaString)\n"
        "    (oaAttrType)\n"
        "    (oaNetAttrType)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaNetAttrType_tp_dealloc(PyoaNetAttrTypeObject* self)
{
    if (!self->borrow) {
        delete (oaNetAttrType*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaNetAttrType_tp_repr(PyObject *ob)
{
    PyParamoaNetAttrType value;
    int convert_status=PyoaNetAttrType_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;
    oaString sresult(value.DataCall()->getName());

    char addr[35];
    sprintf(addr,DISPLAY_FORMAT,POINTER_AS_DISPLAY(value.DataCall()));
    oaString buffer;
    buffer+=oaString("<oaNetAttrType::");
    buffer+=oaString(addr);
    buffer+=oaString("::");
    buffer+=oaString(sresult);
    buffer+=oaString(">");
    result=PyString_FromString((char*)(const char*)buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaNetAttrType_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaNetAttrType v1;
    PyParamoaNetAttrType v2;
    int convert_status1=PyoaNetAttrType_Convert(ob1,&v1);
    int convert_status2=PyoaNetAttrType_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaNetAttrType_Convert(PyObject* ob,PyParamoaNetAttrType* result)
{
    if (ob == NULL) return 1;
    if (PyoaNetAttrType_Check(ob)) {
        result->SetData( (oaNetAttrType*) ((PyoaNetAttrTypeObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaNetAttrType Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaNetAttrType_FromoaNetAttrType(oaNetAttrType* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaNetAttrType_Type.tp_alloc(&PyoaNetAttrType_Type,0);
        if (bself == NULL) return bself;
        PyoaNetAttrTypeObject* self = (PyoaNetAttrTypeObject*)bself;
        self->value = (oaAttrType*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNetAttrType_getName_doc[] = 
"Class: oaNetAttrType, Function: getName\n"
"  Paramegers: ()\n"
"    Calls: const oaString& getName() const\n"
"    Signature: getName|cref-oaString|\n"
"    BrowseData: 1\n"
"    This function returns the name string associated with the encapsulated #oaNetAttrTypeEnum object.\n"
;

static PyObject*
oaNetAttrType_getName(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNetAttrType data;
    int convert_status=PyoaNetAttrType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetAttrTypeObject* self=(PyoaNetAttrTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaString result= (data.DataCall()->getName());
        return PyoaString_FromoaString(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNetAttrType_getValue_doc[] = 
"Class: oaNetAttrType, Function: getValue\n"
"  Paramegers: ()\n"
"    Calls: oaNetAttrTypeEnum getValue() const\n"
"    Signature: getValue|simple-oaNetAttrTypeEnum|\n"
"    BrowseData: 1\n"
"    This function returns the value string of this net attribute type.\n"
;

static PyObject*
oaNetAttrType_getValue(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNetAttrType data;
    int convert_status=PyoaNetAttrType_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetAttrTypeObject* self=(PyoaNetAttrTypeObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaNetAttrTypeEnum result= (data.DataCall()->getValue());
        return PyoaNetAttrTypeEnum_FromoaNetAttrTypeEnum(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaNetAttrType_assign_doc[] = 
"Class: oaNetAttrType, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaNetAttrType_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaNetAttrType data;
  int convert_status=PyoaNetAttrType_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaNetAttrType p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaNetAttrType_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaNetAttrType_methodlist[] = {
    {"getName",(PyCFunction)oaNetAttrType_getName,METH_VARARGS,oaNetAttrType_getName_doc},
    {"getValue",(PyCFunction)oaNetAttrType_getValue,METH_VARARGS,oaNetAttrType_getValue_doc},
    {"assign",(PyCFunction)oaNetAttrType_tp_assign,METH_VARARGS,oaNetAttrType_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNetAttrType_doc[] = 
"Class: oaNetAttrType\n"
"  The oaNetAttrType class is an enum wrapper class that represents the different attributes of an oaNet object that can be displayed by an oaAttrDisplay object associated with a net.\n"
"  See Enum Wrappers in the Programmers Guide for a discussion of enum wrappers.\n"
"  oaNetAttrTypeEnum\n"
"Constructors:\n"
"  Paramegers: (oaNetAttrTypeEnum)\n"
"    Calls: oaNetAttrType(oaNetAttrTypeEnum valueIn)\n"
"    Signature: oaNetAttrType||simple-oaNetAttrTypeEnum,\n"
"    This function constructs an instance of an oaNetAttrType class using the specified enum value. The enum values are defined in #oaNetAttrTypeEnum.\n"
"  Paramegers: (oaString)\n"
"    Calls: oaNetAttrType(const oaString& name)\n"
"    Signature: oaNetAttrType||cref-oaString,\n"
"    This function constructs an instance of an oaNetAttrType class using the oaNetAttrTypeEnum associated with the specified string name . This name must be defined in the legal set of names associated with #oaNetAttrTypeEnum.\n"
"    oacInvalidNetAttrTypeName\n"
"  Paramegers: (oaAttrType)\n"
"    Calls: oaNetAttrType(oaAttrType attr)\n"
"    Signature: oaNetAttrType||simple-oaAttrType,\n"
"    This function constructs an oaNetAttrType class using the oaAttrType as input to support the class down-cast.\n"
"    attr\n"
"    The attribute type to use\n"
"  Paramegers: (oaNetAttrType)\n"
"    Calls: (const oaNetAttrType&)\n"
"    Signature: oaNetAttrType||cref-oaNetAttrType,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaNetAttrType_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaNetAttrType",
    sizeof(PyoaNetAttrTypeObject),
    0,
    (destructor)oaNetAttrType_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaNetAttrType_tp_compare,	/* tp_compare */
    (reprfunc)oaNetAttrType_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaNetAttrType_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaNetAttrType_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaAttrType_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaNetAttrType_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaNetAttrType_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaNetAttrType_Type)<0) {
      printf("** PyType_Ready failed for: oaNetAttrType\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaNetAttrType",
           (PyObject*)(&PyoaNetAttrType_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaNetAttrType\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaNetAttrTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaNetAttrTypeEnum_Convert(PyObject* ob,PyParamoaNetAttrTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacNameNetAttrType")==0) { result->SetData(oacNameNetAttrType); return 1;}
        if (strcasecmp(str,"oacSigTypeNetAttrType")==0) { result->SetData(oacSigTypeNetAttrType); return 1;}
        if (strcasecmp(str,"oacIsGlobalNetAttrType")==0) { result->SetData(oacIsGlobalNetAttrType); return 1;}
        if (strcasecmp(str,"oacIsImplicitNetAttrType")==0) { result->SetData(oacIsImplicitNetAttrType); return 1;}
        if (strcasecmp(str,"oacIsEmptyNetAttrType")==0) { result->SetData(oacIsEmptyNetAttrType); return 1;}
        if (strcasecmp(str,"oacNumBitsNetAttrType")==0) { result->SetData(oacNumBitsNetAttrType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaNetAttrTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaNetAttrTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaNetAttrTypeEnum_FromoaNetAttrTypeEnum(oaNetAttrTypeEnum ob)
{
    if (ob==oacNameNetAttrType) return PyString_FromString("oacNameNetAttrType");
    if (ob==oacSigTypeNetAttrType) return PyString_FromString("oacSigTypeNetAttrType");
    if (ob==oacIsGlobalNetAttrType) return PyString_FromString("oacIsGlobalNetAttrType");
    if (ob==oacIsImplicitNetAttrType) return PyString_FromString("oacIsImplicitNetAttrType");
    if (ob==oacIsEmptyNetAttrType) return PyString_FromString("oacIsEmptyNetAttrType");
    if (ob==oacNumBitsNetAttrType) return PyString_FromString("oacNumBitsNetAttrType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaNetAttrTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaNetAttrTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaNetAttrTypeEnum_FromoaNetAttrTypeEnum(oaNetAttrTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaNetAttrTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaNetAttrTypeEnum_doc[] =
"Type convert function for enum: oaNetAttrTypeEnum";
                               
static PyMethodDef PyoaNetAttrTypeEnum_method =
  {"oaNetAttrTypeEnum",(PyCFunction)PyoaNetAttrTypeEnum_TypeFunction,METH_VARARGS,oaNetAttrTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaNetAttrTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacNameNetAttrType");
    PyDict_SetItemString(mod_dict,"oacNameNetAttrType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSigTypeNetAttrType");
    PyDict_SetItemString(mod_dict,"oacSigTypeNetAttrType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacIsGlobalNetAttrType");
    PyDict_SetItemString(mod_dict,"oacIsGlobalNetAttrType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacIsImplicitNetAttrType");
    PyDict_SetItemString(mod_dict,"oacIsImplicitNetAttrType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacIsEmptyNetAttrType");
    PyDict_SetItemString(mod_dict,"oacIsEmptyNetAttrType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacNumBitsNetAttrType");
    PyDict_SetItemString(mod_dict,"oacNumBitsNetAttrType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaNetAttrTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaNetAttrTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaNetAttrTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaNetConnectDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaNetConnectDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaNetConnectDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaNetConnectDefObject* self = (PyoaNetConnectDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaNetConnectDef)
    {
        PyParamoaNetConnectDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaNetConnectDef_Convert,&p1)) {
            self->data=p1.Data();
            self->value=&(self->data);
            return bself;
        }
    }
    PyErr_Clear();
    // Case: ()
    {
        if (PyArg_ParseTuple(args,(char*)"")) {
          self->data=NULL;
          self->value=&(self->data);
          return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaNetConnectDef, Choices are:\n"
        "    (oaNetConnectDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaNetConnectDef_tp_dealloc(PyoaNetConnectDefObject* self)
{
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaNetConnectDef_tp_repr(PyObject *ob)
{
    PyParamoaNetConnectDef value;
    int convert_status=PyoaNetConnectDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[37];
    sprintf(buffer,"<oaNetConnectDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaNetConnectDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaNetConnectDef v1;
    PyParamoaNetConnectDef v2;
    int convert_status1=PyoaNetConnectDef_Convert(ob1,&v1);
    int convert_status2=PyoaNetConnectDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaNetConnectDef_Convert(PyObject* ob,PyParamoaNetConnectDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaNetConnectDef_Check(ob)) {
        result->SetData( (oaNetConnectDef**) ((PyoaNetConnectDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaNetConnectDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaNetConnectDef_FromoaNetConnectDef(oaNetConnectDef** value,int borrow,PyObject* lock)
{
    if (value && *value) {
        oaNetConnectDef* data=*value;
        PyObject* bself = PyoaNetConnectDef_Type.tp_alloc(&PyoaNetConnectDef_Type,0);
        if (bself == NULL) return bself;
        PyoaNetConnectDefObject* self = (PyoaNetConnectDefObject*)bself;
        self->value = (oaObject**) value;
        self->data = NULL;
        self->locks = NULL;
        self->borrow = 0; // Ignore borrow flag, since we copied
       if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
// ------------------------------------------------------------------
PyObject* PyoaNetConnectDef_FromoaNetConnectDef(oaNetConnectDef* data)
{
    if (data) {
       PyObject* bself = PyoaNetConnectDef_Type.tp_alloc(&PyoaNetConnectDef_Type,0);
       if (bself == NULL) return bself;
       PyoaNetConnectDefObject* self = (PyoaNetConnectDefObject*)bself;
       self->data = (oaObject*) data;
       self->value = &(self->data);
       self->borrow = 0; 
       self->locks = NULL;
       return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNetConnectDef_getNet_doc[] = 
"Class: oaNetConnectDef, Function: getNet\n"
"  Paramegers: ()\n"
"    Calls: oaBitNet* getNet() const\n"
"    Signature: getNet|ptr-oaBitNet|\n"
"    BrowseData: 1\n"
"    This function returns a pointer to the bitNet associated with this connection definition.\n"
;

static PyObject*
oaNetConnectDef_getNet(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNetConnectDef data;
    int convert_status=PyoaNetConnectDef_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetConnectDefObject* self=(PyoaNetConnectDefObject*)ob;
    if (!PyValidateDbObject(data.Data(),0)) return NULL;

    if (PyArg_ParseTuple(args,"")) {
        oaBitNetp result= (data.DataCall()->getNet());
        return PyoaBitNet_FromoaBitNet(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNetConnectDef_isNull_doc[] =
"Class: oaNetConnectDef, Function: isNull\n"
"  Parameters: () \n"
"    This functions returns 1 if the DbPointer is NULL, and 0 otherwise.\n"
;

static PyObject*
oaNetConnectDef_tp_isNull(PyObject* ob, PyObject *args)
{
    PyParamoaNetConnectDef data;
    int convert_status=PyoaNetConnectDef_Convert(ob,&data);
    assert(convert_status!=0);
    if (data.DataCall()==NULL)
        return PyInt_FromLong(1);
    else
        return PyInt_FromLong(0);
}
static char oaNetConnectDef_assign_doc[] = 
"Class: oaNetConnectDef, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaNetConnectDef_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaNetConnectDef data;
  int convert_status=PyoaNetConnectDef_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaNetConnectDef p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaNetConnectDef_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaNetConnectDef_methodlist[] = {
    {"getNet",(PyCFunction)oaNetConnectDef_getNet,METH_VARARGS,oaNetConnectDef_getNet_doc},
    {"isNull",(PyCFunction)oaNetConnectDef_tp_isNull,METH_VARARGS,oaNetConnectDef_isNull_doc},
    {"assign",(PyCFunction)oaNetConnectDef_tp_assign,METH_VARARGS,oaNetConnectDef_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNetConnectDef_doc[] = 
"Class: oaNetConnectDef\n"
"  The oaNetConnectDef class implements a connection definition that associates an oaAssignmentDef with a single-bit net. The oaAssignmentDef used to create the oaNetConnectDef specifies the name of an oaAssignment and a default net name.\n"
"  Applications that analyze design connectivity must resolve the net name of the net associated with an oaNetConnectDef. The application searches up the design hierarchy for an oaAssignment that matches the assignment name specified in the oaNetConnectDef. If the assignment is found, the application uses the net name it specifies instead of the name of the net that is associated with the oaNetConnectDef. If an assignment is not found, the application uses the default net name specified in the oaNetConnectDef.\n"
"  An oaNetConnectDef is usually associated with a global net. This allows\n"
"  easier specification of multiple power supplies\n"
"  easier specification of substrate connections\n"
"  the use of parameterized power and ground symbols\n"
"  For example, a global net named vdd is used in a lower-level part of a design. At a higher level, you decide that you want all of the vdd connections connected to a net named vcc . To accomplish this, you could create an oaNetConnectDef on the vdd net that specifies the name of an assignment called \"vdd_override\". Up in the hierarchy, you would then create an oaAssignValue on an instance representing that part of the design you want to replace the net name vcc for vdd . The oaAssignValue would be named \"vdd_override\" and it would have the net name value vcc .\n"
"  Note: Not all applications support resolving connectivity specified with connection definitions and assignments. You should verify that downstream consumers of the data are able to resolve such connectivity.\n"
"Constructors:\n"
"  Paramegers: (oaNetConnectDef)\n"
"    Calls: (const oaNetConnectDef&)\n"
"    Signature: oaNetConnectDef||cref-oaNetConnectDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaNetConnectDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaNetConnectDef",
    sizeof(PyoaNetConnectDefObject),
    0,
    (destructor)oaNetConnectDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaNetConnectDef_tp_compare,	/* tp_compare */
    (reprfunc)oaNetConnectDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaNetConnectDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaNetConnectDef_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaConnectDef_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaNetConnectDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNetConnectDef_static_create_doc[] = 
"Class: oaNetConnectDef, Function: create\n"
"  Paramegers: (oaBitNet,oaAssignmentDef)\n"
"    Calls: oaNetConnectDef* create(const oaBitNet* net,const oaAssignmentDef& assignmentDef)\n"
"    Signature: create|ptr-oaNetConnectDef|cptr-oaBitNet,cref-oaAssignmentDef,\n"
"    This function creates a connection definition on the specified net using the information in the given assignmentDef .\n"
"    net\n"
"    The bitNet for which to define the connection\n"
"    assignmentDef\n"
"    The assignment definition that specifies the name of an assignment to search for in order to resolve the connectivity and a default net name to use if a matching assignment is not found\n"
"    A pointer to an oaNetConnectDef\n"
"    oacNetAlreadyHasConnectDef\n"
;

static PyObject*
oaNetConnectDef_static_create(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaBitNet p1;
    PyParamoaAssignmentDef p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaBitNet_Convert,&p1,
          &PyoaAssignmentDef_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaNetConnectDefp result= (oaNetConnectDef::create(p1.Data(),p2.Data()));
        return PyoaNetConnectDef_FromoaNetConnectDef(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaNetConnectDef_staticmethodlist[] = {
    {"static_create",(PyCFunction)oaNetConnectDef_static_create,METH_VARARGS,oaNetConnectDef_static_create_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaNetConnectDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaNetConnectDef_Type)<0) {
      printf("** PyType_Ready failed for: oaNetConnectDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaNetConnectDef",
           (PyObject*)(&PyoaNetConnectDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaNetConnectDef\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaNetConnectDef_Type.tp_dict;
    for(method=oaNetConnectDef_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaNetModTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaNetModTypeEnum_Convert(PyObject* ob,PyParamoaNetModTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacSetImplicitNetModType")==0) { result->SetData(oacSetImplicitNetModType); return 1;}
        if (strcasecmp(str,"oacAddEquivNetModType")==0) { result->SetData(oacAddEquivNetModType); return 1;}
        if (strcasecmp(str,"oacBreakEquivNetModType")==0) { result->SetData(oacBreakEquivNetModType); return 1;}
        if (strcasecmp(str,"oacSetGlobalNetModType")==0) { result->SetData(oacSetGlobalNetModType); return 1;}
        if (strcasecmp(str,"oacSetSigTypeNetModType")==0) { result->SetData(oacSetSigTypeNetModType); return 1;}
        if (strcasecmp(str,"oacSetPreferredEquivNetModType")==0) { result->SetData(oacSetPreferredEquivNetModType); return 1;}
        if (strcasecmp(str,"oacSetMustJoinNetModType")==0) { result->SetData(oacSetMustJoinNetModType); return 1;}
        if (strcasecmp(str,"oacSetPriorityNetModType")==0) { result->SetData(oacSetPriorityNetModType); return 1;}
        if (strcasecmp(str,"oacSetRoutePatternNetModType")==0) { result->SetData(oacSetRoutePatternNetModType); return 1;}
        if (strcasecmp(str,"oacSetSourceNetModType")==0) { result->SetData(oacSetSourceNetModType); return 1;}
        if (strcasecmp(str,"oacSetVoltageNetModType")==0) { result->SetData(oacSetVoltageNetModType); return 1;}
        if (strcasecmp(str,"oacSetShieldNet1NetModType")==0) { result->SetData(oacSetShieldNet1NetModType); return 1;}
        if (strcasecmp(str,"oacSetShieldNet2NetModType")==0) { result->SetData(oacSetShieldNet2NetModType); return 1;}
        if (strcasecmp(str,"oacSetOriginalNetModType")==0) { result->SetData(oacSetOriginalNetModType); return 1;}
        if (strcasecmp(str,"oacSetConnStatusNetModType")==0) { result->SetData(oacSetConnStatusNetModType); return 1;}
        if (strcasecmp(str,"oacSetParasiticConfNetModType")==0) { result->SetData(oacSetParasiticConfNetModType); return 1;}
        if (strcasecmp(str,"oacScalarizeNetModType")==0) { result->SetData(oacScalarizeNetModType); return 1;}
        if (strcasecmp(str,"oacScalarNetSetNameNetModType")==0) { result->SetData(oacScalarNetSetNameNetModType); return 1;}
        if (strcasecmp(str,"oacBusNetSetBaseNameNetModType")==0) { result->SetData(oacBusNetSetBaseNameNetModType); return 1;}
        if (strcasecmp(str,"oacBusNetSetRangeNetModType")==0) { result->SetData(oacBusNetSetRangeNetModType); return 1;}
        if (strcasecmp(str,"oacResetBusBitToBusNetModType")==0) { result->SetData(oacResetBusBitToBusNetModType); return 1;}
        if (strcasecmp(str,"oacResetBusToBusBitNetModType")==0) { result->SetData(oacResetBusToBusBitNetModType); return 1;}
        if (strcasecmp(str,"oacBusNetBitSetNameNetModType")==0) { result->SetData(oacBusNetBitSetNameNetModType); return 1;}
        if (strcasecmp(str,"oacUpdateExistingSpanNetModType")==0) { result->SetData(oacUpdateExistingSpanNetModType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaNetModTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaNetModTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaNetModTypeEnum_FromoaNetModTypeEnum(oaNetModTypeEnum ob)
{
    if (ob==oacSetImplicitNetModType) return PyString_FromString("oacSetImplicitNetModType");
    if (ob==oacAddEquivNetModType) return PyString_FromString("oacAddEquivNetModType");
    if (ob==oacBreakEquivNetModType) return PyString_FromString("oacBreakEquivNetModType");
    if (ob==oacSetGlobalNetModType) return PyString_FromString("oacSetGlobalNetModType");
    if (ob==oacSetSigTypeNetModType) return PyString_FromString("oacSetSigTypeNetModType");
    if (ob==oacSetPreferredEquivNetModType) return PyString_FromString("oacSetPreferredEquivNetModType");
    if (ob==oacSetMustJoinNetModType) return PyString_FromString("oacSetMustJoinNetModType");
    if (ob==oacSetPriorityNetModType) return PyString_FromString("oacSetPriorityNetModType");
    if (ob==oacSetRoutePatternNetModType) return PyString_FromString("oacSetRoutePatternNetModType");
    if (ob==oacSetSourceNetModType) return PyString_FromString("oacSetSourceNetModType");
    if (ob==oacSetVoltageNetModType) return PyString_FromString("oacSetVoltageNetModType");
    if (ob==oacSetShieldNet1NetModType) return PyString_FromString("oacSetShieldNet1NetModType");
    if (ob==oacSetShieldNet2NetModType) return PyString_FromString("oacSetShieldNet2NetModType");
    if (ob==oacSetOriginalNetModType) return PyString_FromString("oacSetOriginalNetModType");
    if (ob==oacSetConnStatusNetModType) return PyString_FromString("oacSetConnStatusNetModType");
    if (ob==oacSetParasiticConfNetModType) return PyString_FromString("oacSetParasiticConfNetModType");
    if (ob==oacScalarizeNetModType) return PyString_FromString("oacScalarizeNetModType");
    if (ob==oacScalarNetSetNameNetModType) return PyString_FromString("oacScalarNetSetNameNetModType");
    if (ob==oacBusNetSetBaseNameNetModType) return PyString_FromString("oacBusNetSetBaseNameNetModType");
    if (ob==oacBusNetSetRangeNetModType) return PyString_FromString("oacBusNetSetRangeNetModType");
    if (ob==oacResetBusBitToBusNetModType) return PyString_FromString("oacResetBusBitToBusNetModType");
    if (ob==oacResetBusToBusBitNetModType) return PyString_FromString("oacResetBusToBusBitNetModType");
    if (ob==oacBusNetBitSetNameNetModType) return PyString_FromString("oacBusNetBitSetNameNetModType");
    if (ob==oacUpdateExistingSpanNetModType) return PyString_FromString("oacUpdateExistingSpanNetModType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaNetModTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaNetModTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaNetModTypeEnum_FromoaNetModTypeEnum(oaNetModTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaNetModTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaNetModTypeEnum_doc[] =
"Type convert function for enum: oaNetModTypeEnum";
                               
static PyMethodDef PyoaNetModTypeEnum_method =
  {"oaNetModTypeEnum",(PyCFunction)PyoaNetModTypeEnum_TypeFunction,METH_VARARGS,oaNetModTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaNetModTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacSetImplicitNetModType");
    PyDict_SetItemString(mod_dict,"oacSetImplicitNetModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacAddEquivNetModType");
    PyDict_SetItemString(mod_dict,"oacAddEquivNetModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBreakEquivNetModType");
    PyDict_SetItemString(mod_dict,"oacBreakEquivNetModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetGlobalNetModType");
    PyDict_SetItemString(mod_dict,"oacSetGlobalNetModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetSigTypeNetModType");
    PyDict_SetItemString(mod_dict,"oacSetSigTypeNetModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetPreferredEquivNetModType");
    PyDict_SetItemString(mod_dict,"oacSetPreferredEquivNetModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetMustJoinNetModType");
    PyDict_SetItemString(mod_dict,"oacSetMustJoinNetModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetPriorityNetModType");
    PyDict_SetItemString(mod_dict,"oacSetPriorityNetModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetRoutePatternNetModType");
    PyDict_SetItemString(mod_dict,"oacSetRoutePatternNetModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetSourceNetModType");
    PyDict_SetItemString(mod_dict,"oacSetSourceNetModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetVoltageNetModType");
    PyDict_SetItemString(mod_dict,"oacSetVoltageNetModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetShieldNet1NetModType");
    PyDict_SetItemString(mod_dict,"oacSetShieldNet1NetModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetShieldNet2NetModType");
    PyDict_SetItemString(mod_dict,"oacSetShieldNet2NetModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetOriginalNetModType");
    PyDict_SetItemString(mod_dict,"oacSetOriginalNetModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetConnStatusNetModType");
    PyDict_SetItemString(mod_dict,"oacSetConnStatusNetModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSetParasiticConfNetModType");
    PyDict_SetItemString(mod_dict,"oacSetParasiticConfNetModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacScalarizeNetModType");
    PyDict_SetItemString(mod_dict,"oacScalarizeNetModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacScalarNetSetNameNetModType");
    PyDict_SetItemString(mod_dict,"oacScalarNetSetNameNetModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBusNetSetBaseNameNetModType");
    PyDict_SetItemString(mod_dict,"oacBusNetSetBaseNameNetModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBusNetSetRangeNetModType");
    PyDict_SetItemString(mod_dict,"oacBusNetSetRangeNetModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacResetBusBitToBusNetModType");
    PyDict_SetItemString(mod_dict,"oacResetBusBitToBusNetModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacResetBusToBusBitNetModType");
    PyDict_SetItemString(mod_dict,"oacResetBusToBusBitNetModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBusNetBitSetNameNetModType");
    PyDict_SetItemString(mod_dict,"oacBusNetBitSetNameNetModType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacUpdateExistingSpanNetModType");
    PyDict_SetItemString(mod_dict,"oacUpdateExistingSpanNetModType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaNetModTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaNetModTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaNetModTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaNetNetCollTypeEnum
// ==================================================================

// ------------------------------------------------------------------

int
PyoaNetNetCollTypeEnum_Convert(PyObject* ob,PyParamoaNetNetCollTypeEnum* result)
{
    if (ob == NULL) return 1;
    if (PyString_Check(ob)) {
        char* str=PyString_AsString(ob);
        if (strcasecmp(str,"oacSingleBitMemNetCollType")==0) { result->SetData(oacSingleBitMemNetCollType); return 1;}
        if (strcasecmp(str,"oacBundleMemNetCollType")==0) { result->SetData(oacBundleMemNetCollType); return 1;}
        if (strcasecmp(str,"oacEquivNetCollType")==0) { result->SetData(oacEquivNetCollType); return 1;}
        if (strcasecmp(str,"oacGlobalNetCollType")==0) { result->SetData(oacGlobalNetCollType); return 1;}
        if (strcasecmp(str,"oacSpanNetCollType")==0) { result->SetData(oacSpanNetCollType); return 1;}
    }            
    if (PyInt_Check(ob)) {
        long val=PyInt_AsLong(ob);
        result->SetData((oaNetNetCollTypeEnum)val);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaNetNetCollTypeEnum Failed");
    return 0;
}
// ------------------------------------------------------------------

PyObject* PyoaNetNetCollTypeEnum_FromoaNetNetCollTypeEnum(oaNetNetCollTypeEnum ob)
{
    if (ob==oacSingleBitMemNetCollType) return PyString_FromString("oacSingleBitMemNetCollType");
    if (ob==oacBundleMemNetCollType) return PyString_FromString("oacBundleMemNetCollType");
    if (ob==oacEquivNetCollType) return PyString_FromString("oacEquivNetCollType");
    if (ob==oacGlobalNetCollType) return PyString_FromString("oacGlobalNetCollType");
    if (ob==oacSpanNetCollType) return PyString_FromString("oacSpanNetCollType");

    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Enum Typecast function:
// ------------------------------------------------------------------

static PyObject*
PyoaNetNetCollTypeEnum_TypeFunction(PyObject* mod,PyObject* args)
{
    int v;
    oaNetNetCollTypeEnum e;
    if (PyArg_ParseTuple(args,(char*)"i",&v)) {
       return PyoaNetNetCollTypeEnum_FromoaNetNetCollTypeEnum(oaNetNetCollTypeEnum(v));
    }
    PyErr_Clear();
    if (PyArg_ParseTuple(args,(char*)"O&",&PyoaNetNetCollTypeEnum_Convert,&e)) {
       return PyInt_FromLong(long(e));
    }
    return NULL;
}
static char oaNetNetCollTypeEnum_doc[] =
"Type convert function for enum: oaNetNetCollTypeEnum";
                               
static PyMethodDef PyoaNetNetCollTypeEnum_method =
  {"oaNetNetCollTypeEnum",(PyCFunction)PyoaNetNetCollTypeEnum_TypeFunction,METH_VARARGS,oaNetNetCollTypeEnum_doc};
  

// ------------------------------------------------------------------
//  Enum Init:
// ------------------------------------------------------------------

int
PyoaNetNetCollTypeEnum_TypeInit(PyObject* mod_dict)
{
    // Put Enum values in Dictionary
    PyObject* value;
    value=PyString_FromString("oacSingleBitMemNetCollType");
    PyDict_SetItemString(mod_dict,"oacSingleBitMemNetCollType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacBundleMemNetCollType");
    PyDict_SetItemString(mod_dict,"oacBundleMemNetCollType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacEquivNetCollType");
    PyDict_SetItemString(mod_dict,"oacEquivNetCollType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacGlobalNetCollType");
    PyDict_SetItemString(mod_dict,"oacGlobalNetCollType",value);
    Py_DECREF(value);
    value=PyString_FromString("oacSpanNetCollType");
    PyDict_SetItemString(mod_dict,"oacSpanNetCollType",value);
    Py_DECREF(value);

    // Put Enum name function in Dictionary
    value=PyCFunction_New(&PyoaNetNetCollTypeEnum_method,NULL);
    if (PyDict_SetItemString(mod_dict,"oaNetNetCollTypeEnum",value)!=0) {
    Py_DECREF(value);
        printf("** Failed to add enum function to module dictionary for: oaNetNetCollTypeEnum\n");
        return -1;
    }
    Py_DECREF(value);
    return 0;
}

/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaNetTermArray
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaNetTermArray_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaNetTermArray_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaNetTermArrayObject* self = (PyoaNetTermArrayObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: ()
    {
        if (PyArg_ParseTuple(args,"")) {
            self->value = (oaNetTermArrayBase_oaNet_oaTerm*)  new oaNetTermArray();
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value = (oaNetTermArrayBase_oaNet_oaTerm*)  new oaNetTermArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaNetTermArray)
    {
        PyParamoaNetTermArray p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaNetTermArray_Convert,&p1)) {
            self->value=(oaNetTermArrayBase_oaNet_oaTerm*)  new oaNetTermArray(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaNetTermArray, Choices are:\n"
        "    ()\n"
        "    (oaUInt4)\n"
        "    (oaNetTermArray)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaNetTermArray_tp_dealloc(PyoaNetTermArrayObject* self)
{
    if (!self->borrow) {
        delete (oaNetTermArray*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaNetTermArray_tp_repr(PyObject *ob)
{
    PyParamoaNetTermArray value;
    int convert_status=PyoaNetTermArray_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[36];
    sprintf(buffer,"<oaNetTermArray::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaNetTermArray_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaNetTermArray v1;
    PyParamoaNetTermArray v2;
    int convert_status1=PyoaNetTermArray_Convert(ob1,&v1);
    int convert_status2=PyoaNetTermArray_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaNetTermArray_Convert(PyObject* ob,PyParamoaNetTermArray* result)
{
    if (ob == NULL) return 1;
    if (PyoaNetTermArray_Check(ob)) {
        result->SetData( (oaNetTermArray*) ((PyoaNetTermArrayObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaNetTermArray Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaNetTermArray_FromoaNetTermArray(oaNetTermArray* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaNetTermArray_Type.tp_alloc(&PyoaNetTermArray_Type,0);
        if (bself == NULL) return bself;
        PyoaNetTermArrayObject* self = (PyoaNetTermArrayObject*)bself;
        self->value = (oaNetTermArrayBase_oaNet_oaTerm*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNetTermArray_doc[] = 
"Class: oaNetTermArray\n"
"  The oaNetTermArray class implements a specification of all the connections between a set of nets and a set of terminals in an instance master. It is used with the oaInstTerm::create() and oaModInstTerm::create() APIs.\n"
"Constructors:\n"
"  Paramegers: ()\n"
"    Calls: oaNetTermArray()\n"
"    Signature: oaNetTermArray||simple-oaUInt4,\n"
"    This class associates nets with pointers.\n"
"    size\n"
"    An integer value indicating the initial size of the array.\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaNetTermArray(oaUInt4 size)\n"
"    Signature: oaNetTermArray||simple-oaUInt4,\n"
"    This class associates nets with pointers.\n"
"    size\n"
"    An integer value indicating the initial size of the array.\n"
"  Paramegers: (oaNetTermArray)\n"
"    Calls: (const oaNetTermArray&)\n"
"    Signature: oaNetTermArray||cref-oaNetTermArray,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaNetTermArray_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaNetTermArray",
    sizeof(PyoaNetTermArrayObject),
    0,
    (destructor)oaNetTermArray_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaNetTermArray_tp_compare,	/* tp_compare */
    (reprfunc)oaNetTermArray_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaNetTermArray_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaNetTermArrayBase_oaNet_oaTerm_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaNetTermArray_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaNetTermArray_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaNetTermArray_Type)<0) {
      printf("** PyType_Ready failed for: oaNetTermArray\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaNetTermArray",
           (PyObject*)(&PyoaNetTermArray_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaNetTermArray\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaNetTermArrayBase_oaModNet_oaModTerm
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaNetTermArrayBase_oaModNet_oaModTerm_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaNetTermArrayBase_oaModNet_oaModTerm_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaNetTermArrayBase_oaModNet_oaModTermObject* self = (PyoaNetTermArrayBase_oaModNet_oaModTermObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaNetTermArrayBase_oaModNet_oaModTerm(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaNetTermArrayBase_oaModNet_oaModTerm, Choices are:\n"
        "    (oaUInt4)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaNetTermArrayBase_oaModNet_oaModTerm_tp_dealloc(PyoaNetTermArrayBase_oaModNet_oaModTermObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaNetTermArrayBase_oaModNet_oaModTerm_tp_repr(PyObject *ob)
{
    PyParamoaNetTermArrayBase_oaModNet_oaModTerm value;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaModTerm_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[59];
    sprintf(buffer,"<oaNetTermArrayBase_oaModNet_oaModTerm::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaNetTermArrayBase_oaModNet_oaModTerm_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaNetTermArrayBase_oaModNet_oaModTerm v1;
    PyParamoaNetTermArrayBase_oaModNet_oaModTerm v2;
    int convert_status1=PyoaNetTermArrayBase_oaModNet_oaModTerm_Convert(ob1,&v1);
    int convert_status2=PyoaNetTermArrayBase_oaModNet_oaModTerm_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaNetTermArrayBase_oaModNet_oaModTerm_Convert(PyObject* ob,PyParamoaNetTermArrayBase_oaModNet_oaModTerm* result)
{
    if (ob == NULL) return 1;
    if (PyoaNetTermArrayBase_oaModNet_oaModTerm_Check(ob)) {
        result->SetData(  ((PyoaNetTermArrayBase_oaModNet_oaModTermObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaNetTermArrayBase_oaModNet_oaModTerm Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaNetTermArrayBase_oaModNet_oaModTerm_FromoaNetTermArrayBase_oaModNet_oaModTerm(oaNetTermArrayBase_oaModNet_oaModTerm* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaNetTermArrayBase_oaModNet_oaModTerm_Type.tp_alloc(&PyoaNetTermArrayBase_oaModNet_oaModTerm_Type,0);
        if (bself == NULL) return bself;
        PyoaNetTermArrayBase_oaModNet_oaModTermObject* self = (PyoaNetTermArrayBase_oaModNet_oaModTermObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaModTerm_index_get_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaModTerm, Function: index_get\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaModTerm_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaNetTermArrayBase_oaModNet_oaModTermObject* self=(PyoaNetTermArrayBase_oaModNet_oaModTermObject*)ob;
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaModTerm data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaModTermObject* self=(PyoaNetTermArrayBase_oaModNet_oaModTermObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaNetTermPair_oaModNet_oaModTerm* result=&(data.Data()[index]);
    return PyoaNetTermPair_oaModNet_oaModTerm_FromoaNetTermPair_oaModNet_oaModTerm(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaNetTermArrayBase_oaModNet_oaModTerm_index_get_length(PyObject* ob)
{
    PyParamoaNetTermArrayBase_oaModNet_oaModTerm data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaModTermObject* self=(PyoaNetTermArrayBase_oaModNet_oaModTermObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaModTerm_index_set_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaModTerm, Function: index_set\n"
;

static int
oaNetTermArrayBase_oaModNet_oaModTerm_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaModTerm data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaModTermObject* self=(PyoaNetTermArrayBase_oaModNet_oaModTermObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaNetTermPair_oaModNet_oaModTerm result;
    if (PyoaNetTermPair_oaModNet_oaModTerm_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaModTerm_append_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaModTerm, Function: append\n"
"  Paramegers: (oaModNet,oaModTerm)\n"
"    Calls: void append( net, term)\n"
"    Signature: append|void-void|cptrref-oaModNet,cptrref-oaModTerm,\n"
"    This function appends the given net and term pair to the end of the array.\n"
"    net\n"
"    The net to append to the array.\n"
"    term\n"
"    The term to append to the array.\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaModTerm_append(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaModTerm data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaModTermObject* self=(PyoaNetTermArrayBase_oaModNet_oaModTermObject*)ob;

    PyParamoaModNet p1;
    PyParamoaModTerm p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaModNet_Convert,&p1,
          &PyoaModTerm_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!PyValidateDbObject(p2.Data(),2)) return NULL;
        data.DataCall()->append(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaModTerm_get_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaModTerm, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaNetTermPair_oaModNet_oaModTerm& get(oaUInt4 index)\n"
"    Signature: get|ref-oaNetTermPair_oaModNet_oaModTerm|simple-oaUInt4,\n"
"    This function returns the element at the given index of the array.\n"
"    index\n"
"    The index value of the element to return.\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaModTerm_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaModTerm data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaModTermObject* self=(PyoaNetTermArrayBase_oaModNet_oaModTermObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaNetTermPair_oaModNet_oaModTerm* result=&(data.DataCall()->get(p1.Data()));
        return PyoaNetTermPair_oaModNet_oaModTerm_FromoaNetTermPair_oaModNet_oaModTerm(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaModTerm_getNumBits_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaModTerm, Function: getNumBits\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumBits() const\n"
"    Signature: getNumBits|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the total number of bits in the elements of the array.\n"
"    Todo\n"
"    Add description of member function.\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaModTerm_getNumBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaModTerm data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaModTermObject* self=(PyoaNetTermArrayBase_oaModNet_oaModTermObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumBits());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaModTerm_getNumElements_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaModTerm, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements in the array.\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaModTerm_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaModTerm data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaModTermObject* self=(PyoaNetTermArrayBase_oaModNet_oaModTermObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaModTerm_getNumMultiBit_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaModTerm, Function: getNumMultiBit\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumMultiBit() const\n"
"    Signature: getNumMultiBit|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of multi-bit terms in the elements array.\n"
"    Todo\n"
"    Check description of member function.\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaModTerm_getNumMultiBit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaModTerm data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaModTermObject* self=(PyoaNetTermArrayBase_oaModNet_oaModTermObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumMultiBit());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaModTerm_getSize_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaModTerm, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size of the array.\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaModTerm_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaModTerm data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaModTermObject* self=(PyoaNetTermArrayBase_oaModNet_oaModTermObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaModTerm_setNumElements_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaModTerm, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 numElements)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in the array.\n"
"    numElements\n"
"    The number of array elements.\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaModTerm_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaModTerm data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaModTerm_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaModTermObject* self=(PyoaNetTermArrayBase_oaModNet_oaModTermObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaNetTermArrayBase_oaModNet_oaModTerm_assign_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaModTerm, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaModTerm_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaNetTermArrayBase_oaModNet_oaModTerm data;
  int convert_status=PyoaNetTermArrayBase_oaModNet_oaModTerm_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaModTerm p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaNetTermArrayBase_oaModNet_oaModTerm_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaNetTermArrayBase_oaModNet_oaModTerm_methodlist[] = {
    {"append",(PyCFunction)oaNetTermArrayBase_oaModNet_oaModTerm_append,METH_VARARGS,oaNetTermArrayBase_oaModNet_oaModTerm_append_doc},
    {"get",(PyCFunction)oaNetTermArrayBase_oaModNet_oaModTerm_get,METH_VARARGS,oaNetTermArrayBase_oaModNet_oaModTerm_get_doc},
    {"getNumBits",(PyCFunction)oaNetTermArrayBase_oaModNet_oaModTerm_getNumBits,METH_VARARGS,oaNetTermArrayBase_oaModNet_oaModTerm_getNumBits_doc},
    {"getNumElements",(PyCFunction)oaNetTermArrayBase_oaModNet_oaModTerm_getNumElements,METH_VARARGS,oaNetTermArrayBase_oaModNet_oaModTerm_getNumElements_doc},
    {"getNumMultiBit",(PyCFunction)oaNetTermArrayBase_oaModNet_oaModTerm_getNumMultiBit,METH_VARARGS,oaNetTermArrayBase_oaModNet_oaModTerm_getNumMultiBit_doc},
    {"getSize",(PyCFunction)oaNetTermArrayBase_oaModNet_oaModTerm_getSize,METH_VARARGS,oaNetTermArrayBase_oaModNet_oaModTerm_getSize_doc},
    {"setNumElements",(PyCFunction)oaNetTermArrayBase_oaModNet_oaModTerm_setNumElements,METH_VARARGS,oaNetTermArrayBase_oaModNet_oaModTerm_setNumElements_doc},
    {"assign",(PyCFunction)oaNetTermArrayBase_oaModNet_oaModTerm_tp_assign,METH_VARARGS,oaNetTermArrayBase_oaModNet_oaModTerm_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaNetTermArrayBase_oaModNet_oaModTerm_as_sequence = {
    (Pyoa_inquiry)oaNetTermArrayBase_oaModNet_oaModTerm_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaNetTermArrayBase_oaModNet_oaModTerm_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaNetTermArrayBase_oaModNet_oaModTerm_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaModTerm_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaModTerm\n"
"  This class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is used as a buffer because the need to re-allocate the array is reduced.\n"
"  Todo\n"
"  Add <> template identifiers to appropriate functions.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaNetTermArrayBase_oaModNet_oaModTerm(oaUInt4 size)\n"
"    Signature: oaNetTermArrayBase_oaModNet_oaModTerm||simple-oaUInt4,\n"
"    This is the constructor for the oaNetTermArrayBase class.\n"
"    size\n"
"    An integer value indicating the initial size of the array.\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaNetTermArrayBase_oaModNet_oaModTerm_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaNetTermArrayBase_oaModNet_oaModTerm",
    sizeof(PyoaNetTermArrayBase_oaModNet_oaModTermObject),
    0,
    (destructor)oaNetTermArrayBase_oaModNet_oaModTerm_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaNetTermArrayBase_oaModNet_oaModTerm_tp_compare,	/* tp_compare */
    (reprfunc)oaNetTermArrayBase_oaModNet_oaModTerm_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaNetTermArrayBase_oaModNet_oaModTerm_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaNetTermArrayBase_oaModNet_oaModTerm_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaNetTermArrayBase_oaModNet_oaModTerm_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaNetTermArrayBase_oaModNet_oaModTerm_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaNetTermArrayBase_oaModNet_oaModTerm_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaNetTermArrayBase_oaModNet_oaModTerm_Type)<0) {
      printf("** PyType_Ready failed for: oaNetTermArrayBase_oaModNet_oaModTerm\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaNetTermArrayBase_oaModNet_oaModTerm",
           (PyObject*)(&PyoaNetTermArrayBase_oaModNet_oaModTerm_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaNetTermArrayBase_oaModNet_oaModTerm\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaNetTermArrayBase_oaModNet_oaName
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaNetTermArrayBase_oaModNet_oaName_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaNetTermArrayBase_oaModNet_oaName_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaNetTermArrayBase_oaModNet_oaNameObject* self = (PyoaNetTermArrayBase_oaModNet_oaNameObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaNetTermArrayBase_oaModNet_oaName(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaNetTermArrayBase_oaModNet_oaName, Choices are:\n"
        "    (oaUInt4)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaNetTermArrayBase_oaModNet_oaName_tp_dealloc(PyoaNetTermArrayBase_oaModNet_oaNameObject* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaNetTermArrayBase_oaModNet_oaName_tp_repr(PyObject *ob)
{
    PyParamoaNetTermArrayBase_oaModNet_oaName value;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaName_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[56];
    sprintf(buffer,"<oaNetTermArrayBase_oaModNet_oaName::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaNetTermArrayBase_oaModNet_oaName_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaNetTermArrayBase_oaModNet_oaName v1;
    PyParamoaNetTermArrayBase_oaModNet_oaName v2;
    int convert_status1=PyoaNetTermArrayBase_oaModNet_oaName_Convert(ob1,&v1);
    int convert_status2=PyoaNetTermArrayBase_oaModNet_oaName_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaNetTermArrayBase_oaModNet_oaName_Convert(PyObject* ob,PyParamoaNetTermArrayBase_oaModNet_oaName* result)
{
    if (ob == NULL) return 1;
    if (PyoaNetTermArrayBase_oaModNet_oaName_Check(ob)) {
        result->SetData(  ((PyoaNetTermArrayBase_oaModNet_oaNameObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaNetTermArrayBase_oaModNet_oaName Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaNetTermArrayBase_oaModNet_oaName_FromoaNetTermArrayBase_oaModNet_oaName(oaNetTermArrayBase_oaModNet_oaName* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaNetTermArrayBase_oaModNet_oaName_Type.tp_alloc(&PyoaNetTermArrayBase_oaModNet_oaName_Type,0);
        if (bself == NULL) return bself;
        PyoaNetTermArrayBase_oaModNet_oaNameObject* self = (PyoaNetTermArrayBase_oaModNet_oaNameObject*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaName_index_get_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaName, Function: index_get\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaName_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaNetTermArrayBase_oaModNet_oaNameObject* self=(PyoaNetTermArrayBase_oaModNet_oaNameObject*)ob;
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaName data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaNameObject* self=(PyoaNetTermArrayBase_oaModNet_oaNameObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaNetTermPair_oaModNet_oaName* result=&(data.Data()[index]);
    return PyoaNetTermPair_oaModNet_oaName_FromoaNetTermPair_oaModNet_oaName(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaNetTermArrayBase_oaModNet_oaName_index_get_length(PyObject* ob)
{
    PyParamoaNetTermArrayBase_oaModNet_oaName data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaNameObject* self=(PyoaNetTermArrayBase_oaModNet_oaNameObject*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaName_index_set_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaName, Function: index_set\n"
;

static int
oaNetTermArrayBase_oaModNet_oaName_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaName data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaNameObject* self=(PyoaNetTermArrayBase_oaModNet_oaNameObject*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaNetTermPair_oaModNet_oaName result;
    if (PyoaNetTermPair_oaModNet_oaName_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaName_append_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaName, Function: append\n"
"  Paramegers: (oaModNet,oaName)\n"
"    Calls: void append( net,const oaName& term)\n"
"    Signature: append|void-void|cptrref-oaModNet,cref-oaName,\n"
"    This function appends the given net and term pair to the end of the array.\n"
"    net\n"
"    The net to append to the array.\n"
"    term\n"
"    The term to append to the array.\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaName_append(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaName data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaNameObject* self=(PyoaNetTermArrayBase_oaModNet_oaNameObject*)ob;

    PyParamoaModNet p1;
    PyParamoaName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaModNet_Convert,&p1,
          &PyoaName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->append(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaName_get_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaName, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaNetTermPair_oaModNet_oaName& get(oaUInt4 index)\n"
"    Signature: get|ref-oaNetTermPair_oaModNet_oaName|simple-oaUInt4,\n"
"    This function returns the element at the given index of the array.\n"
"    index\n"
"    The index value of the element to return.\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaName_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaName data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaNameObject* self=(PyoaNetTermArrayBase_oaModNet_oaNameObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaNetTermPair_oaModNet_oaName* result=&(data.DataCall()->get(p1.Data()));
        return PyoaNetTermPair_oaModNet_oaName_FromoaNetTermPair_oaModNet_oaName(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaName_getNumBits_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaName, Function: getNumBits\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumBits() const\n"
"    Signature: getNumBits|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the total number of bits in the elements of the array.\n"
"    Todo\n"
"    Add description of member function.\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaName_getNumBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaName data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaNameObject* self=(PyoaNetTermArrayBase_oaModNet_oaNameObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumBits());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaName_getNumElements_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaName, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements in the array.\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaName_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaName data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaNameObject* self=(PyoaNetTermArrayBase_oaModNet_oaNameObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaName_getNumMultiBit_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaName, Function: getNumMultiBit\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumMultiBit() const\n"
"    Signature: getNumMultiBit|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of multi-bit terms in the elements array.\n"
"    Todo\n"
"    Check description of member function.\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaName_getNumMultiBit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaName data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaNameObject* self=(PyoaNetTermArrayBase_oaModNet_oaNameObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumMultiBit());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaName_getSize_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaName, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size of the array.\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaName_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaName data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaNameObject* self=(PyoaNetTermArrayBase_oaModNet_oaNameObject*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaName_setNumElements_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaName, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 numElements)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in the array.\n"
"    numElements\n"
"    The number of array elements.\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaName_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaName data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaName_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaNameObject* self=(PyoaNetTermArrayBase_oaModNet_oaNameObject*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaNetTermArrayBase_oaModNet_oaName_assign_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaName, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaName_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaNetTermArrayBase_oaModNet_oaName data;
  int convert_status=PyoaNetTermArrayBase_oaModNet_oaName_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaName p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaNetTermArrayBase_oaModNet_oaName_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaNetTermArrayBase_oaModNet_oaName_methodlist[] = {
    {"append",(PyCFunction)oaNetTermArrayBase_oaModNet_oaName_append,METH_VARARGS,oaNetTermArrayBase_oaModNet_oaName_append_doc},
    {"get",(PyCFunction)oaNetTermArrayBase_oaModNet_oaName_get,METH_VARARGS,oaNetTermArrayBase_oaModNet_oaName_get_doc},
    {"getNumBits",(PyCFunction)oaNetTermArrayBase_oaModNet_oaName_getNumBits,METH_VARARGS,oaNetTermArrayBase_oaModNet_oaName_getNumBits_doc},
    {"getNumElements",(PyCFunction)oaNetTermArrayBase_oaModNet_oaName_getNumElements,METH_VARARGS,oaNetTermArrayBase_oaModNet_oaName_getNumElements_doc},
    {"getNumMultiBit",(PyCFunction)oaNetTermArrayBase_oaModNet_oaName_getNumMultiBit,METH_VARARGS,oaNetTermArrayBase_oaModNet_oaName_getNumMultiBit_doc},
    {"getSize",(PyCFunction)oaNetTermArrayBase_oaModNet_oaName_getSize,METH_VARARGS,oaNetTermArrayBase_oaModNet_oaName_getSize_doc},
    {"setNumElements",(PyCFunction)oaNetTermArrayBase_oaModNet_oaName_setNumElements,METH_VARARGS,oaNetTermArrayBase_oaModNet_oaName_setNumElements_doc},
    {"assign",(PyCFunction)oaNetTermArrayBase_oaModNet_oaName_tp_assign,METH_VARARGS,oaNetTermArrayBase_oaModNet_oaName_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaNetTermArrayBase_oaModNet_oaName_as_sequence = {
    (Pyoa_inquiry)oaNetTermArrayBase_oaModNet_oaName_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaNetTermArrayBase_oaModNet_oaName_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaNetTermArrayBase_oaModNet_oaName_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaName_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaName\n"
"  This class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is used as a buffer because the need to re-allocate the array is reduced.\n"
"  Todo\n"
"  Add <> template identifiers to appropriate functions.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaNetTermArrayBase_oaModNet_oaName(oaUInt4 size)\n"
"    Signature: oaNetTermArrayBase_oaModNet_oaName||simple-oaUInt4,\n"
"    This is the constructor for the oaNetTermArrayBase class.\n"
"    size\n"
"    An integer value indicating the initial size of the array.\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaNetTermArrayBase_oaModNet_oaName_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaNetTermArrayBase_oaModNet_oaName",
    sizeof(PyoaNetTermArrayBase_oaModNet_oaNameObject),
    0,
    (destructor)oaNetTermArrayBase_oaModNet_oaName_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaNetTermArrayBase_oaModNet_oaName_tp_compare,	/* tp_compare */
    (reprfunc)oaNetTermArrayBase_oaModNet_oaName_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaNetTermArrayBase_oaModNet_oaName_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaNetTermArrayBase_oaModNet_oaName_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaNetTermArrayBase_oaModNet_oaName_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaNetTermArrayBase_oaModNet_oaName_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaNetTermArrayBase_oaModNet_oaName_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaNetTermArrayBase_oaModNet_oaName_Type)<0) {
      printf("** PyType_Ready failed for: oaNetTermArrayBase_oaModNet_oaName\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaNetTermArrayBase_oaModNet_oaName",
           (PyObject*)(&PyoaNetTermArrayBase_oaModNet_oaName_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaNetTermArrayBase_oaModNet_oaName\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaNetTermArrayBase_oaModNet_oaUInt4
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaNetTermArrayBase_oaModNet_oaUInt4_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaNetTermArrayBase_oaModNet_oaUInt4_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaNetTermArrayBase_oaModNet_oaUInt4Object* self = (PyoaNetTermArrayBase_oaModNet_oaUInt4Object*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            self->value =  new oaNetTermArrayBase_oaModNet_oaUInt4(p1.Data());
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaNetTermArrayBase_oaModNet_oaUInt4, Choices are:\n"
        "    (oaUInt4)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaNetTermArrayBase_oaModNet_oaUInt4_tp_dealloc(PyoaNetTermArrayBase_oaModNet_oaUInt4Object* self)
{
    if (!self->borrow) {
        delete (self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaNetTermArrayBase_oaModNet_oaUInt4_tp_repr(PyObject *ob)
{
    PyParamoaNetTermArrayBase_oaModNet_oaUInt4 value;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaUInt4_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[57];
    sprintf(buffer,"<oaNetTermArrayBase_oaModNet_oaUInt4::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaNetTermArrayBase_oaModNet_oaUInt4_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaNetTermArrayBase_oaModNet_oaUInt4 v1;
    PyParamoaNetTermArrayBase_oaModNet_oaUInt4 v2;
    int convert_status1=PyoaNetTermArrayBase_oaModNet_oaUInt4_Convert(ob1,&v1);
    int convert_status2=PyoaNetTermArrayBase_oaModNet_oaUInt4_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaNetTermArrayBase_oaModNet_oaUInt4_Convert(PyObject* ob,PyParamoaNetTermArrayBase_oaModNet_oaUInt4* result)
{
    if (ob == NULL) return 1;
    if (PyoaNetTermArrayBase_oaModNet_oaUInt4_Check(ob)) {
        result->SetData(  ((PyoaNetTermArrayBase_oaModNet_oaUInt4Object*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaNetTermArrayBase_oaModNet_oaUInt4 Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaNetTermArrayBase_oaModNet_oaUInt4_FromoaNetTermArrayBase_oaModNet_oaUInt4(oaNetTermArrayBase_oaModNet_oaUInt4* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaNetTermArrayBase_oaModNet_oaUInt4_Type.tp_alloc(&PyoaNetTermArrayBase_oaModNet_oaUInt4_Type,0);
        if (bself == NULL) return bself;
        PyoaNetTermArrayBase_oaModNet_oaUInt4Object* self = (PyoaNetTermArrayBase_oaModNet_oaUInt4Object*)bself;
        self->value =  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// IndexGetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaUInt4_index_get_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaUInt4, Function: index_get\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaUInt4_index_get(PyObject* ob,Pyoa_ssize_t index)
{
  PyoaNetTermArrayBase_oaModNet_oaUInt4Object* self=(PyoaNetTermArrayBase_oaModNet_oaUInt4Object*)ob;
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaUInt4 data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaUInt4_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaUInt4Object* self=(PyoaNetTermArrayBase_oaModNet_oaUInt4Object*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return NULL;
    }
    oaNetTermPair_oaModNet_oaUInt4* result=&(data.Data()[index]);
    return PyoaNetTermPair_oaModNet_oaUInt4_FromoaNetTermPair_oaModNet_oaUInt4(result,1,ob);
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static Pyoa_ssize_t
oaNetTermArrayBase_oaModNet_oaUInt4_index_get_length(PyObject* ob)
{
    PyParamoaNetTermArrayBase_oaModNet_oaUInt4 data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaUInt4_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaUInt4Object* self=(PyoaNetTermArrayBase_oaModNet_oaUInt4Object*)ob;

    return data.Data().getNumElements();
}


// ------------------------------------------------------------------
// IndexSetMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaUInt4_index_set_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaUInt4, Function: index_set\n"
;

static int
oaNetTermArrayBase_oaModNet_oaUInt4_index_set(PyObject *ob, Pyoa_ssize_t index, PyObject* value)
{
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaUInt4 data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaUInt4_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaUInt4Object* self=(PyoaNetTermArrayBase_oaModNet_oaUInt4Object*)ob;

    PyParamoaUInt4 p1;
    if (index<0 || index>=data.Data().getNumElements()) {
        PyObject* err=PyString_FromString("index out of range");
        PyErr_SetObject(PyExc_IndexError, err);
        Py_DECREF(err);
        return -1;
    }
    PyParamoaNetTermPair_oaModNet_oaUInt4 result;
    if (PyoaNetTermPair_oaModNet_oaUInt4_Convert(value,&result)==0) return -1;
    data.Data()[index]=result.Data();
    return 0;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return -1;
  }
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaUInt4_append_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaUInt4, Function: append\n"
"  Paramegers: (oaModNet,oaUInt4)\n"
"    Calls: void append( net,const oaUInt4& term)\n"
"    Signature: append|void-void|cptrref-oaModNet,cref-oaUInt4,\n"
"    This function appends the given net and term pair to the end of the array.\n"
"    net\n"
"    The net to append to the array.\n"
"    term\n"
"    The term to append to the array.\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaUInt4_append(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaUInt4 data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaUInt4_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaUInt4Object* self=(PyoaNetTermArrayBase_oaModNet_oaUInt4Object*)ob;

    PyParamoaModNet p1;
    PyParamoaUInt4 p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaModNet_Convert,&p1,
          &PyoaUInt4_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->append(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaUInt4_get_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaUInt4, Function: get\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaNetTermPair_oaModNet_oaUInt4& get(oaUInt4 index)\n"
"    Signature: get|ref-oaNetTermPair_oaModNet_oaUInt4|simple-oaUInt4,\n"
"    This function returns the element at the given index of the array.\n"
"    index\n"
"    The index value of the element to return.\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaUInt4_get(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaUInt4 data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaUInt4_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaUInt4Object* self=(PyoaNetTermArrayBase_oaModNet_oaUInt4Object*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        oaNetTermPair_oaModNet_oaUInt4* result=&(data.DataCall()->get(p1.Data()));
        return PyoaNetTermPair_oaModNet_oaUInt4_FromoaNetTermPair_oaModNet_oaUInt4(result,1,ob);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaUInt4_getNumBits_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaUInt4, Function: getNumBits\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumBits() const\n"
"    Signature: getNumBits|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the total number of bits in the elements of the array.\n"
"    Todo\n"
"    Add description of member function.\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaUInt4_getNumBits(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaUInt4 data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaUInt4_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaUInt4Object* self=(PyoaNetTermArrayBase_oaModNet_oaUInt4Object*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumBits());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaUInt4_getNumElements_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaUInt4, Function: getNumElements\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumElements() const\n"
"    Signature: getNumElements|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of elements in the array.\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaUInt4_getNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaUInt4 data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaUInt4_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaUInt4Object* self=(PyoaNetTermArrayBase_oaModNet_oaUInt4Object*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumElements());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaUInt4_getNumMultiBit_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaUInt4, Function: getNumMultiBit\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getNumMultiBit() const\n"
"    Signature: getNumMultiBit|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the number of multi-bit terms in the elements array.\n"
"    Todo\n"
"    Check description of member function.\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaUInt4_getNumMultiBit(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaUInt4 data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaUInt4_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaUInt4Object* self=(PyoaNetTermArrayBase_oaModNet_oaUInt4Object*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getNumMultiBit());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaUInt4_getSize_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaUInt4, Function: getSize\n"
"  Paramegers: ()\n"
"    Calls: oaUInt4 getSize() const\n"
"    Signature: getSize|simple-oaUInt4|\n"
"    BrowseData: 1\n"
"    This function returns the size of the array.\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaUInt4_getSize(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaUInt4 data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaUInt4_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaUInt4Object* self=(PyoaNetTermArrayBase_oaModNet_oaUInt4Object*)ob;

    if (PyArg_ParseTuple(args,"")) {
        oaUInt4 result= (data.DataCall()->getSize());
        return PyoaUInt4_FromoaUInt4(result);
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaUInt4_setNumElements_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaUInt4, Function: setNumElements\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: void setNumElements(oaUInt4 numElements)\n"
"    Signature: setNumElements|void-void|simple-oaUInt4,\n"
"    This function sets the number of elements in the array.\n"
"    numElements\n"
"    The number of array elements.\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaUInt4_setNumElements(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaUInt4 data;
    int convert_status=PyoaNetTermArrayBase_oaModNet_oaUInt4_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaNetTermArrayBase_oaModNet_oaUInt4Object* self=(PyoaNetTermArrayBase_oaModNet_oaUInt4Object*)ob;

    PyParamoaUInt4 p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaUInt4_Convert,&p1)) {
        data.DataCall()->setNumElements(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaNetTermArrayBase_oaModNet_oaUInt4_assign_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaUInt4, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaNetTermArrayBase_oaModNet_oaUInt4_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaNetTermArrayBase_oaModNet_oaUInt4 data;
  int convert_status=PyoaNetTermArrayBase_oaModNet_oaUInt4_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaNetTermArrayBase_oaModNet_oaUInt4 p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaNetTermArrayBase_oaModNet_oaUInt4_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaNetTermArrayBase_oaModNet_oaUInt4_methodlist[] = {
    {"append",(PyCFunction)oaNetTermArrayBase_oaModNet_oaUInt4_append,METH_VARARGS,oaNetTermArrayBase_oaModNet_oaUInt4_append_doc},
    {"get",(PyCFunction)oaNetTermArrayBase_oaModNet_oaUInt4_get,METH_VARARGS,oaNetTermArrayBase_oaModNet_oaUInt4_get_doc},
    {"getNumBits",(PyCFunction)oaNetTermArrayBase_oaModNet_oaUInt4_getNumBits,METH_VARARGS,oaNetTermArrayBase_oaModNet_oaUInt4_getNumBits_doc},
    {"getNumElements",(PyCFunction)oaNetTermArrayBase_oaModNet_oaUInt4_getNumElements,METH_VARARGS,oaNetTermArrayBase_oaModNet_oaUInt4_getNumElements_doc},
    {"getNumMultiBit",(PyCFunction)oaNetTermArrayBase_oaModNet_oaUInt4_getNumMultiBit,METH_VARARGS,oaNetTermArrayBase_oaModNet_oaUInt4_getNumMultiBit_doc},
    {"getSize",(PyCFunction)oaNetTermArrayBase_oaModNet_oaUInt4_getSize,METH_VARARGS,oaNetTermArrayBase_oaModNet_oaUInt4_getSize_doc},
    {"setNumElements",(PyCFunction)oaNetTermArrayBase_oaModNet_oaUInt4_setNumElements,METH_VARARGS,oaNetTermArrayBase_oaModNet_oaUInt4_setNumElements_doc},
    {"assign",(PyCFunction)oaNetTermArrayBase_oaModNet_oaUInt4_tp_assign,METH_VARARGS,oaNetTermArrayBase_oaModNet_oaUInt4_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------

static PySequenceMethods oaNetTermArrayBase_oaModNet_oaUInt4_as_sequence = {
    (Pyoa_inquiry)oaNetTermArrayBase_oaModNet_oaUInt4_index_get_length, /* sq_length */
    (Pyoa_binaryfunc)0,		/* sq_concat */
    (Pyoa_intargfunc)0,		/* sq_repeat */
    (Pyoa_intargfunc)oaNetTermArrayBase_oaModNet_oaUInt4_index_get,	/* sq_item */
    (Pyoa_intintargfunc)0,		/* sq_slice */
    (Pyoa_intobjargproc)oaNetTermArrayBase_oaModNet_oaUInt4_index_set,	/* sq_ass_item */
};
// ------------------------------------------------------------------
static char oaNetTermArrayBase_oaModNet_oaUInt4_doc[] = 
"Class: oaNetTermArrayBase_oaModNet_oaUInt4\n"
"  This class implements a template for an array of elements. The size of the array can be different than the number of elements actually stored. This is useful in situations where the array is used as a buffer because the need to re-allocate the array is reduced.\n"
"  Todo\n"
"  Add <> template identifiers to appropriate functions.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaNetTermArrayBase_oaModNet_oaUInt4(oaUInt4 size)\n"
"    Signature: oaNetTermArrayBase_oaModNet_oaUInt4||simple-oaUInt4,\n"
"    This is the constructor for the oaNetTermArrayBase class.\n"
"    size\n"
"    An integer value indicating the initial size of the array.\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaNetTermArrayBase_oaModNet_oaUInt4_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaNetTermArrayBase_oaModNet_oaUInt4",
    sizeof(PyoaNetTermArrayBase_oaModNet_oaUInt4Object),
    0,
    (destructor)oaNetTermArrayBase_oaModNet_oaUInt4_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaNetTermArrayBase_oaModNet_oaUInt4_tp_compare,	/* tp_compare */
    (reprfunc)oaNetTermArrayBase_oaModNet_oaUInt4_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    &oaNetTermArrayBase_oaModNet_oaUInt4_as_sequence,	/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaNetTermArrayBase_oaModNet_oaUInt4_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaNetTermArrayBase_oaModNet_oaUInt4_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    0,					/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaNetTermArrayBase_oaModNet_oaUInt4_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaNetTermArrayBase_oaModNet_oaUInt4_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaNetTermArrayBase_oaModNet_oaUInt4_Type)<0) {
      printf("** PyType_Ready failed for: oaNetTermArrayBase_oaModNet_oaUInt4\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaNetTermArrayBase_oaModNet_oaUInt4",
           (PyObject*)(&PyoaNetTermArrayBase_oaModNet_oaUInt4_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaNetTermArrayBase_oaModNet_oaUInt4\n");
       return -1;
    }
    return 0;
}

